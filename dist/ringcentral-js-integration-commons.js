(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RcPhone"] = factory();
	else
		root["RcPhone"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _slicedToArray2 = __webpack_require__(45);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _addModule = __webpack_require__(119);
	
	var _addModule2 = _interopRequireDefault(_addModule);
	
	var _ringcentral = __webpack_require__(120);
	
	var _ringcentral2 = _interopRequireDefault(_ringcentral);
	
	var _ringcentralClient = __webpack_require__(132);
	
	var _ringcentralClient2 = _interopRequireDefault(_ringcentralClient);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _settings = __webpack_require__(152);
	
	var _settings2 = _interopRequireDefault(_settings);
	
	var _brand = __webpack_require__(166);
	
	var _brand2 = _interopRequireDefault(_brand);
	
	var _auth = __webpack_require__(169);
	
	var _auth2 = _interopRequireDefault(_auth);
	
	var _subscription = __webpack_require__(192);
	
	var _subscription2 = _interopRequireDefault(_subscription);
	
	var _user = __webpack_require__(199);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _webphone = __webpack_require__(203);
	
	var _webphone2 = _interopRequireDefault(_webphone);
	
	var _redux = __webpack_require__(153);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var REDUCER = (0, _symbol2.default)();
	
	function getStoreRegisterAndResolver() {
	  var handlers = new _set2.default();
	  return [function (fn) {
	    return handlers.add(fn);
	  }, function (store) {
	    return handlers.forEach(function (fn) {
	      return fn(store);
	    });
	  }];
	}
	
	var RcPhone = function (_RcModule) {
	  (0, _inherits3.default)(RcPhone, _RcModule);
	
	  function RcPhone(_ref) {
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var getStore = _ref.getStore;
	    var _stateMapper = _ref.stateMapper;
	    var _ref$prefix = _ref.prefix;
	    var prefix = _ref$prefix === undefined ? 'rc' : _ref$prefix;
	    var sdkSettings = _ref.sdkSettings;
	    var defaultBrand = _ref.defaultBrand;
	    (0, _classCallCheck3.default)(this, RcPhone);
	
	    var register = registerStoreHandler;
	    var resolve = void 0;
	    if (!register) {
	      var _getStoreRegisterAndR = getStoreRegisterAndResolver();
	
	      var _getStoreRegisterAndR2 = (0, _slicedToArray3.default)(_getStoreRegisterAndR, 2);
	
	      register = _getStoreRegisterAndR2[0];
	      resolve = _getStoreRegisterAndR2[1];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RcPhone).call(this, {
	      registerStoreHandler: register,
	      stateMapper: _stateMapper
	    }));
	
	    _addModule2.default.call(_this, 'sdk', new _ringcentral2.default((0, _extends3.default)({
	
	      cachePrefix: prefix + '-'
	    }, sdkSettings)));
	
	    _addModule2.default.call(_this, 'platform', _this.sdk.platform());
	
	    _addModule2.default.call(_this, 'api', new _ringcentralClient2.default(_this.sdk));
	
	    _addModule2.default.call(_this, 'auth', new _auth2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).auth;
	      },
	      prefix: prefix,
	      platform: _this.platform
	    }));
	
	    _addModule2.default.call(_this, 'settings', new _settings2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).settings;
	      }
	    }));
	
	    _addModule2.default.call(_this, 'defaultBrand', new _brand2.default((0, _extends3.default)({
	      registerStoreHandler: register,
	      prefix: prefix + '-default',
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).defaultBrand;
	      }
	    }, defaultBrand)));
	
	    _addModule2.default.call(_this, 'subscription', new _subscription2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).subscription;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      sdk: _this.sdk,
	      auth: _this.auth
	    }));
	
	    _addModule2.default.call(_this, 'user', new _user2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).user;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      settings: _this.settings
	    }));
	
	    _addModule2.default.call(_this, 'webphone', new _webphone2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).webphone;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      settings: _this.settings
	    }));
	
	    // combine reducers
	    _this[REDUCER] = (0, _redux.combineReducers)({
	      auth: _this.auth.reducer,
	      defaultBrand: _this.defaultBrand.reducer,
	      subscription: _this.subscription.reducer,
	      user: _this.user.reducer,
	      webphone: _this.webphone.reducer,
	      settings: _this.settings.reducer
	    });
	
	    if (resolve) {
	      resolve(getStore(_this.reducer));
	      // resolve(createStore(this.reducer));
	    }
	    return _this;
	  }
	
	  (0, _createClass3.default)(RcPhone, [{
	    key: 'reducer',
	    get: function get() {
	      return this[REDUCER];
	    }
	  }]);
	  return RcPhone;
	}(_rcModule2.default);
	
	exports.default = RcPhone;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	
	  return target;
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(4), __esModule: true };

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(5);
	module.exports = __webpack_require__(8).Object.assign;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(6);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(21)});

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(7)
	  , core      = __webpack_require__(8)
	  , ctx       = __webpack_require__(9)
	  , hide      = __webpack_require__(11)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 7 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 8 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(10);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(12)
	  , createDesc = __webpack_require__(20);
	module.exports = __webpack_require__(16) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(13)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , toPrimitive    = __webpack_require__(19)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(16) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(16) && !__webpack_require__(17)(function(){
	  return Object.defineProperty(__webpack_require__(18)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(17)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , document = __webpack_require__(7).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(14);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(22)
	  , gOPS     = __webpack_require__(37)
	  , pIE      = __webpack_require__(38)
	  , toObject = __webpack_require__(39)
	  , IObject  = __webpack_require__(26)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(17)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(23)
	  , enumBugKeys = __webpack_require__(36);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(24)
	  , toIObject    = __webpack_require__(25)
	  , arrayIndexOf = __webpack_require__(29)(false)
	  , IE_PROTO     = __webpack_require__(33)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(26)
	  , defined = __webpack_require__(28);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(27);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(25)
	  , toLength  = __webpack_require__(30)
	  , toIndex   = __webpack_require__(32);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(31)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(34)('keys')
	  , uid    = __webpack_require__(35);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(7)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 37 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 38 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(28);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(41), __esModule: true };

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(42);
	module.exports = __webpack_require__(8).Object.getPrototypeOf;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(39)
	  , $getPrototypeOf = __webpack_require__(43);
	
	__webpack_require__(44)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(24)
	  , toObject    = __webpack_require__(39)
	  , IE_PROTO    = __webpack_require__(33)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(6)
	  , core    = __webpack_require__(8)
	  , fails   = __webpack_require__(17);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(46);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(66);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(47), __esModule: true };

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(62);
	module.exports = __webpack_require__(64);

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(49);
	var global        = __webpack_require__(7)
	  , hide          = __webpack_require__(11)
	  , Iterators     = __webpack_require__(52)
	  , TO_STRING_TAG = __webpack_require__(61)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(50)
	  , step             = __webpack_require__(51)
	  , Iterators        = __webpack_require__(52)
	  , toIObject        = __webpack_require__(25);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(53)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(54)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(55)
	  , hide           = __webpack_require__(11)
	  , has            = __webpack_require__(24)
	  , Iterators      = __webpack_require__(52)
	  , $iterCreate    = __webpack_require__(56)
	  , setToStringTag = __webpack_require__(60)
	  , getPrototypeOf = __webpack_require__(43)
	  , ITERATOR       = __webpack_require__(61)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11);

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(57)
	  , descriptor     = __webpack_require__(20)
	  , setToStringTag = __webpack_require__(60)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(11)(IteratorPrototype, __webpack_require__(61)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(13)
	  , dPs         = __webpack_require__(58)
	  , enumBugKeys = __webpack_require__(36)
	  , IE_PROTO    = __webpack_require__(33)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(18)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(59).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(12)
	  , anObject = __webpack_require__(13)
	  , getKeys  = __webpack_require__(22);
	
	module.exports = __webpack_require__(16) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(7).document && document.documentElement;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(12).f
	  , has = __webpack_require__(24)
	  , TAG = __webpack_require__(61)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(34)('wks')
	  , uid        = __webpack_require__(35)
	  , Symbol     = __webpack_require__(7).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(63)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(53)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31)
	  , defined   = __webpack_require__(28);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(65)
	  , ITERATOR  = __webpack_require__(61)('iterator')
	  , Iterators = __webpack_require__(52);
	module.exports = __webpack_require__(8).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(27)
	  , TAG = __webpack_require__(61)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(67), __esModule: true };

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(62);
	module.exports = __webpack_require__(68);

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(13)
	  , get      = __webpack_require__(69);
	module.exports = __webpack_require__(8).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(65)
	  , ITERATOR  = __webpack_require__(61)('iterator')
	  , Iterators = __webpack_require__(52);
	module.exports = __webpack_require__(8).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 70 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(73), __esModule: true };

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(74);
	var $Object = __webpack_require__(8).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(16), 'Object', {defineProperty: __webpack_require__(12).f});

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(77);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(78), __esModule: true };

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(48);
	module.exports = __webpack_require__(79).f('iterator');

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(61);

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(81), __esModule: true };

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(82);
	__webpack_require__(91);
	__webpack_require__(92);
	__webpack_require__(93);
	module.exports = __webpack_require__(8).Symbol;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(7)
	  , has            = __webpack_require__(24)
	  , DESCRIPTORS    = __webpack_require__(16)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(55)
	  , META           = __webpack_require__(83).KEY
	  , $fails         = __webpack_require__(17)
	  , shared         = __webpack_require__(34)
	  , setToStringTag = __webpack_require__(60)
	  , uid            = __webpack_require__(35)
	  , wks            = __webpack_require__(61)
	  , wksExt         = __webpack_require__(79)
	  , wksDefine      = __webpack_require__(84)
	  , keyOf          = __webpack_require__(85)
	  , enumKeys       = __webpack_require__(86)
	  , isArray        = __webpack_require__(87)
	  , anObject       = __webpack_require__(13)
	  , toIObject      = __webpack_require__(25)
	  , toPrimitive    = __webpack_require__(19)
	  , createDesc     = __webpack_require__(20)
	  , _create        = __webpack_require__(57)
	  , gOPNExt        = __webpack_require__(88)
	  , $GOPD          = __webpack_require__(90)
	  , $DP            = __webpack_require__(12)
	  , $keys          = __webpack_require__(22)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(89).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(38).f  = $propertyIsEnumerable;
	  __webpack_require__(37).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(54)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(35)('meta')
	  , isObject = __webpack_require__(14)
	  , has      = __webpack_require__(24)
	  , setDesc  = __webpack_require__(12).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(17)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(7)
	  , core           = __webpack_require__(8)
	  , LIBRARY        = __webpack_require__(54)
	  , wksExt         = __webpack_require__(79)
	  , defineProperty = __webpack_require__(12).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(22)
	  , toIObject = __webpack_require__(25);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(22)
	  , gOPS    = __webpack_require__(37)
	  , pIE     = __webpack_require__(38);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(27);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(25)
	  , gOPN      = __webpack_require__(89).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(23)
	  , hiddenKeys = __webpack_require__(36).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(38)
	  , createDesc     = __webpack_require__(20)
	  , toIObject      = __webpack_require__(25)
	  , toPrimitive    = __webpack_require__(19)
	  , has            = __webpack_require__(24)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(16) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 91 */
/***/ function(module, exports) {



/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(84)('asyncIterator');

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(84)('observable');

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(95);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(99);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(96), __esModule: true };

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(97);
	module.exports = __webpack_require__(8).Object.setPrototypeOf;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(6);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(98).set});

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(14)
	  , anObject = __webpack_require__(13);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(9)(Function.call, __webpack_require__(90).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(100), __esModule: true };

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(101);
	var $Object = __webpack_require__(8).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(57)});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(103), __esModule: true };

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	__webpack_require__(62);
	__webpack_require__(48);
	__webpack_require__(104);
	__webpack_require__(116);
	module.exports = __webpack_require__(8).Set;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(105);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(112)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(12).f
	  , create      = __webpack_require__(57)
	  , hide        = __webpack_require__(11)
	  , redefineAll = __webpack_require__(106)
	  , ctx         = __webpack_require__(9)
	  , anInstance  = __webpack_require__(107)
	  , defined     = __webpack_require__(28)
	  , forOf       = __webpack_require__(108)
	  , $iterDefine = __webpack_require__(53)
	  , step        = __webpack_require__(51)
	  , setSpecies  = __webpack_require__(111)
	  , DESCRIPTORS = __webpack_require__(16)
	  , fastKey     = __webpack_require__(83).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(11);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(9)
	  , call        = __webpack_require__(109)
	  , isArrayIter = __webpack_require__(110)
	  , anObject    = __webpack_require__(13)
	  , toLength    = __webpack_require__(30)
	  , getIterFn   = __webpack_require__(69)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(13);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(52)
	  , ITERATOR   = __webpack_require__(61)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(7)
	  , core        = __webpack_require__(8)
	  , dP          = __webpack_require__(12)
	  , DESCRIPTORS = __webpack_require__(16)
	  , SPECIES     = __webpack_require__(61)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(7)
	  , $export        = __webpack_require__(6)
	  , meta           = __webpack_require__(83)
	  , fails          = __webpack_require__(17)
	  , hide           = __webpack_require__(11)
	  , redefineAll    = __webpack_require__(106)
	  , forOf          = __webpack_require__(108)
	  , anInstance     = __webpack_require__(107)
	  , isObject       = __webpack_require__(14)
	  , setToStringTag = __webpack_require__(60)
	  , dP             = __webpack_require__(12).f
	  , each           = __webpack_require__(113)(0)
	  , DESCRIPTORS    = __webpack_require__(16);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    C = wrapper(function(target, iterable){
	      anInstance(target, C, NAME, '_c');
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        anInstance(this, C, KEY);
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)dP(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(9)
	  , IObject  = __webpack_require__(26)
	  , toObject = __webpack_require__(39)
	  , toLength = __webpack_require__(30)
	  , asc      = __webpack_require__(114);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(115);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , isArray  = __webpack_require__(87)
	  , SPECIES  = __webpack_require__(61)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(6);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(117)('Set')});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(65)
	  , from    = __webpack_require__(118);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(108);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	exports.default = addModule;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function addModule(name, module) {
	  if (Object.prototype.hasOwnProperty.call(this, name)) {
	    throw new Error("module '" + name + "' already exists...");
	  }
	
	  (0, _defineProperty2.default)(this, name, {
	    get: function get() {
	      return module;
	    },
	
	    enumerable: true
	  });
	}

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(126), __webpack_require__(130), __webpack_require__(131));
		else if(typeof define === 'function' && define.amd)
			define([, , "pubnub"], factory);
		else if(typeof exports === 'object')
			exports["SDK"] = factory(require("es6-promise"), require("node-fetch"), require("pubnub"));
		else
			root["RingCentral"] = root["RingCentral"] || {}, root["RingCentral"]["SDK"] = factory(root[undefined], root[undefined], root[undefined]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "/build/";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(1);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	__webpack_require__(2);
	
	var _Utils = __webpack_require__(3);
	
	var Utils = _interopRequireWildcard(_Utils);
	
	var _Cache = __webpack_require__(8);
	
	var _Cache2 = _interopRequireDefault(_Cache);
	
	var _Externals = __webpack_require__(4);
	
	var Externals = _interopRequireWildcard(_Externals);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Client = __webpack_require__(10);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	var _ClientMock = __webpack_require__(12);
	
	var _ClientMock2 = _interopRequireDefault(_ClientMock);
	
	var _Mock = __webpack_require__(14);
	
	var _Mock2 = _interopRequireDefault(_Mock);
	
	var _Registry = __webpack_require__(13);
	
	var _Registry2 = _interopRequireDefault(_Registry);
	
	var _Platform = __webpack_require__(15);
	
	var _Platform2 = _interopRequireDefault(_Platform);
	
	var _Auth = __webpack_require__(16);
	
	var _Auth2 = _interopRequireDefault(_Auth);
	
	var _PubnubFactory = __webpack_require__(17);
	
	var _PubnubFactory2 = _interopRequireDefault(_PubnubFactory);
	
	var _Subscription = __webpack_require__(19);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _CachedSubscription = __webpack_require__(20);
	
	var _CachedSubscription2 = _interopRequireDefault(_CachedSubscription);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SDK = function () {
	
	    /**
	     * @namespace RingCentral
	     * @constructor
	     * @param {object} [options]
	     * @param {string} [options.server]
	     * @param {string} [options.cachePrefix]
	     * @param {string} [options.appSecret]
	     * @param {string} [options.appKey]
	     * @param {string} [options.appName]
	     * @param {string} [options.appVersion]
	     * @param {string} [options.pubnubFactory]
	     * @param {string} [options.client]
	     */
	
	    function SDK(options) {
	        _classCallCheck(this, SDK);
	
	        options = options || {};
	
	        if (!Externals.fetch) {
	            throw new Error('Native Fetch is missing, set RingCentral.SDK.core.Externals.fetch to your favorite alternative');
	        }
	
	        if (!Externals.Promise) {
	            throw new Error('Native Promise is missing, set RingCentral.SDK.core.Externals.Promise to your favorite alternative');
	        }
	
	        this._cache = new _Cache2.default(Externals.localStorage, options.cachePrefix);
	
	        this._client = options.client || new _Client2.default();
	
	        this._platform = new _Platform2.default(this._client, this._cache, options.server, options.appKey, options.appSecret, options.appName, options.appVersion, SDK.version);
	
	        this._pubnubFactory = options.pubnubFactory || Externals.PUBNUB;
	    }
	
	    /**
	     * @return {Platform}
	     */
	
	
	    SDK.prototype.platform = function platform() {
	        return this._platform;
	    };
	
	    /**
	     * @return {Subscription}
	     */
	
	
	    SDK.prototype.createSubscription = function createSubscription() {
	        return new _Subscription2.default(this._pubnubFactory, this._platform);
	    };
	
	    /**
	     * @return {CachedSubscription}
	     */
	
	
	    SDK.prototype.createCachedSubscription = function createCachedSubscription(cacheKey) {
	        return new _CachedSubscription2.default(this._pubnubFactory, this._platform, this._cache, cacheKey);
	    };
	
	    /**
	     * @return {Cache}
	     */
	
	
	    SDK.prototype.cache = function cache() {
	        return this._cache;
	    };
	
	    SDK.handleLoginRedirect = function handleLoginRedirect(origin) {
	        window.opener.postMessage({ RCAuthorizationCode: window.location.search }, origin || window.location.origin);
	    };
	
	    return SDK;
	}();
	
	SDK.version =  true ? ("3.0.0-rc1") : 'x.x.x';
	SDK.server = {
	    sandbox: 'https://platform.devtest.ringcentral.com',
	    production: 'https://platform.ringcentral.com'
	};
	SDK.core = {
	    Cache: _Cache2.default,
	    EventEmitter: _events2.default,
	    Utils: Utils,
	    Externals: Externals
	};
	SDK.http = {
	    Client: _Client2.default,
	    ApiResponse: _ApiResponse2.default
	};
	SDK.platform = {
	    Auth: _Auth2.default,
	    Platform: _Platform2.default
	};
	SDK.subscription = {
	    Subscription: _Subscription2.default
	};
	SDK.mocks = {
	    Client: _ClientMock2.default,
	    Registry: _Registry2.default,
	    Mock: _Mock2.default
	};
	SDK.pubnub = {
	    PubnubMockFactory: _PubnubFactory2.default
	};
	
	
	module.exports = SDK;
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var iteratorSymbol =
	    typeof Symbol === "function" && Symbol.iterator || "@@iterator";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    // This invoke function is written in a style that assumes some
	    // calling function (or Promise) will handle exceptions.
	    function invoke(method, arg) {
	      var result = generator[method](arg);
	      var value = result.value;
	      return value instanceof AwaitArgument
	        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
	        : Promise.resolve(value).then(function(unwrapped) {
	            // When a yielded Promise is resolved, its final value becomes
	            // the .value of the Promise<{value,done}> result for the
	            // current iteration. If the Promise is rejected, however, the
	            // result for this iteration will be rejected with the same
	            // reason. Note that rejections of yielded Promises are not
	            // thrown back into the generator function, as is the case
	            // when an awaited Promise is rejected. This difference in
	            // behavior between yield and await is important, because it
	            // allows the consumer to decide what to do with the yielded
	            // rejection (swallow it and continue, manually .throw it back
	            // into the generator, abandon iteration, whatever). With
	            // await, by contrast, there is no opportunity to examine the
	            // rejection reason outside the generator function, so the
	            // only option is to throw it from the await expression, and
	            // let the generator function handle the exception.
	            result.value = unwrapped;
	            return result;
	          });
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var invokeNext = invoke.bind(generator, "next");
	    var invokeThrow = invoke.bind(generator, "throw");
	    var invokeReturn = invoke.bind(generator, "return");
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return invoke(method, arg);
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : new Promise(function (resolve) {
	          resolve(callInvokeWithMethodAndArg());
	        });
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          context._sent = arg;
	
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            context.sent = undefined;
	          }
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.queryStringify = queryStringify;
	exports.parseQueryString = parseQueryString;
	exports.isFunction = isFunction;
	exports.isArray = isArray;
	exports.isObject = isObject;
	exports.isObjectObject = isObjectObject;
	exports.isPlainObject = isPlainObject;
	exports.isNodeJS = isNodeJS;
	exports.isBrowser = isBrowser;
	exports.delay = delay;
	
	var _Externals = __webpack_require__(4);
	
	/**
	 * TODO Replace with something better
	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js
	 * @param {object} parameters
	 * @returns {string}
	 */
	function queryStringify(parameters) {
	
	    var array = [];
	
	    parameters = parameters || {};
	
	    Object.keys(parameters).forEach(function (k) {
	
	        var v = parameters[k];
	
	        if (isArray(v)) {
	            v.forEach(function (vv) {
	                array.push(encodeURIComponent(k) + '=' + encodeURIComponent(vv));
	            });
	        } else {
	            array.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));
	        }
	    });
	
	    return array.join('&');
	}
	
	/**
	 * TODO Replace with something better
	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js
	 * @param {string} queryString
	 * @returns {object}
	 */
	function parseQueryString(queryString) {
	
	    var argsParsed = {};
	
	    queryString.split('&').forEach(function (arg) {
	
	        arg = decodeURIComponent(arg);
	
	        if (arg.indexOf('=') == -1) {
	
	            argsParsed[arg.trim()] = true;
	        } else {
	
	            var pair = arg.split('='),
	                key = pair[0].trim(),
	                value = pair[1].trim();
	
	            if (key in argsParsed) {
	                if (key in argsParsed && !isArray(argsParsed[key])) argsParsed[key] = [argsParsed[key]];
	                argsParsed[key].push(value);
	            } else {
	                argsParsed[key] = value;
	            }
	        }
	    });
	
	    return argsParsed;
	}
	
	/**
	 * @param obj
	 * @return {boolean}
	 */
	function isFunction(obj) {
	    return typeof obj === "function";
	}
	
	/**
	 * @param obj
	 * @return {boolean}
	 */
	function isArray(obj) {
	    return Array.isArray ? Array.isArray(obj) : typeof obj === "array";
	}
	
	function isObject(o) {
	    return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && !isArray(o);
	}
	
	function isObjectObject(o) {
	    return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';
	}
	
	function isPlainObject(o) {
	    var ctor, prot;
	
	    if (isObjectObject(o) === false) return false;
	
	    // If has modified constructor
	    ctor = o.constructor;
	    if (typeof ctor !== 'function') return false;
	
	    // If has modified prototype
	    prot = ctor.prototype;
	    if (isObjectObject(prot) === false) return false;
	
	    // If constructor does not have an Object-specific method
	    if (prot.hasOwnProperty('isPrototypeOf') === false) {
	        return false;
	    }
	
	    // Most likely a plain Object
	    return true;
	}
	
	function isNodeJS() {
	    return typeof process !== 'undefined';
	}
	
	function isBrowser() {
	    return typeof window !== 'undefined';
	}
	
	function delay(timeout) {
	    return new _Externals.Promise(function (resolve, reject) {
	        setTimeout(function () {
	            resolve(null);
	        }, timeout);
	    });
	}
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	exports.__esModule = true;
	exports.localStorage = exports.PUBNUB = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.Promise = undefined;
	
	var _es6Promise = __webpack_require__(5);
	
	var _es6Promise2 = _interopRequireDefault(_es6Promise);
	
	var _nodeFetch = __webpack_require__(6);
	
	var _nodeFetch2 = _interopRequireDefault(_nodeFetch);
	
	var _pubnub = __webpack_require__(7);
	
	var _pubnub2 = _interopRequireDefault(_pubnub);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var root = typeof window !== "undefined" && window || typeof global !== "undefined" && global || Function("return this;")();
	
	var Promise = _es6Promise2.default && _es6Promise2.default.Promise || root.Promise;
	
	var fetch = _nodeFetch2.default && typeof _nodeFetch2.default == 'function' ? _nodeFetch2.default : root.fetch;
	var Request = fetch.Request || root.Request;
	var Response = fetch.Response || root.Response;
	var Headers = fetch.Headers || root.Headers;
	
	var PUBNUB = _pubnub2.default || root.PUBNUB;
	
	var localStorage = typeof root.localStorage !== 'undefined' ? root.localStorage : {};
	
	exports.Promise = Promise;
	exports.fetch = fetch;
	exports.Request = Request;
	exports.Response = Response;
	exports.Headers = Headers;
	exports.PUBNUB = PUBNUB;
	exports.localStorage = localStorage;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_6__;
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_7__;
	
	/***/ },
	/* 8 */
	/***/ function(module, exports) {
	
	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Cache = function () {
	    function Cache(storage, prefix) {
	        _classCallCheck(this, Cache);
	
	        this.setPrefix(prefix);
	        this._storage = storage;
	    }
	
	    Cache.prototype.setPrefix = function setPrefix(prefix) {
	        this._prefix = prefix || Cache.defaultPrefix;
	        return this;
	    };
	
	    Cache.prototype.setItem = function setItem(key, data) {
	        this._storage[this._prefixKey(key)] = JSON.stringify(data);
	        return this;
	    };
	
	    Cache.prototype.removeItem = function removeItem(key) {
	        delete this._storage[this._prefixKey(key)];
	        return this;
	    };
	
	    Cache.prototype.getItem = function getItem(key) {
	        var item = this._storage[this._prefixKey(key)];
	        if (!item) return null;
	        return JSON.parse(item);
	    };
	
	    Cache.prototype.clean = function clean() {
	
	        for (var key in this._storage) {
	
	            if (!this._storage.hasOwnProperty(key)) continue;
	
	            if (key.indexOf(this._prefix) === 0) {
	                delete this._storage[key];
	            }
	        }
	
	        return this;
	    };
	
	    Cache.prototype._prefixKey = function _prefixKey(key) {
	        return this._prefix + key;
	    };
	
	    return Cache;
	}();
	
	Cache.defaultPrefix = 'rc-';
	exports.default = Cache;
	
	/***/ },
	/* 9 */
	/***/ function(module, exports) {
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	exports.findHeaderName = findHeaderName;
	
	var _Externals = __webpack_require__(4);
	
	var _Utils = __webpack_require__(3);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Client = function (_EventEmitter) {
	    _inherits(Client, _EventEmitter);
	
	    function Client() {
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Client);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _EventEmitter.call.apply(_EventEmitter, [this].concat(args))), _this), _this.events = {
	            beforeRequest: 'beforeRequest',
	            requestSuccess: 'requestSuccess',
	            requestError: 'requestError'
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    /**
	     * @param {Request} request
	     * @return {Promise<ApiResponse>}
	     */
	
	    Client.prototype.sendRequest = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            var apiResponse;
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            apiResponse = new _ApiResponse2.default(request);
	                            _context.prev = 1;
	
	
	                            //TODO Stop request if listeners return false
	                            this.emit(this.events.beforeRequest, apiResponse);
	
	                            _context.next = 5;
	                            return this._loadResponse(request);
	
	                        case 5:
	                            apiResponse._response = _context.sent;
	                            _context.next = 8;
	                            return apiResponse._init();
	
	                        case 8:
	                            if (apiResponse.ok()) {
	                                _context.next = 10;
	                                break;
	                            }
	
	                            throw new Error('Response has unsuccessful status');
	
	                        case 10:
	
	                            this.emit(this.events.requestSuccess, apiResponse);
	
	                            return _context.abrupt("return", apiResponse);
	
	                        case 14:
	                            _context.prev = 14;
	                            _context.t0 = _context["catch"](1);
	
	
	                            if (!_context.t0.apiResponse) _context.t0 = this.makeError(_context.t0, apiResponse);
	
	                            this.emit(this.events.requestError, _context.t0);
	
	                            throw _context.t0;
	
	                        case 19:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this, [[1, 14]]);
	        }));
	
	        function sendRequest(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return sendRequest;
	    }();
	
	    /**
	     * @param {Request} request
	     * @return {Promise<Response>}
	     * @private
	     */
	
	
	    Client.prototype._loadResponse = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(request) {
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.next = 2;
	                            return _Externals.fetch.call(null, request);
	
	                        case 2:
	                            return _context2.abrupt("return", _context2.sent);
	
	                        case 3:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this);
	        }));
	
	        function _loadResponse(_x2) {
	            return _ref2.apply(this, arguments);
	        }
	
	        return _loadResponse;
	    }();
	
	    /**
	     * Wraps the JS Error object with transaction information
	     * @param {Error|IApiError} e
	     * @param {ApiResponse} apiResponse
	     * @return {IApiError}
	     */
	
	
	    Client.prototype.makeError = function makeError(e, apiResponse) {
	
	        // Wrap only if regular error
	        if (!e.hasOwnProperty('apiResponse') && !e.hasOwnProperty('originalMessage')) {
	
	            e.apiResponse = apiResponse;
	            e.originalMessage = e.message;
	            e.message = apiResponse && apiResponse.error(true) || e.originalMessage;
	        }
	
	        return e;
	    };
	
	    /**
	     *
	     * @param {object} init
	     * @param {object} [init.url]
	     * @param {object} [init.body]
	     * @param {string} [init.method]
	     * @param {object} [init.query]
	     * @param {object} [init.headers]
	     * @return {Request}
	     */
	
	
	    Client.prototype.createRequest = function createRequest(init) {
	
	        init = init || {};
	        init.headers = init.headers || {};
	
	        // Sanity checks
	        if (!init.url) throw new Error('Url is not defined');
	        if (!init.method) init.method = 'GET';
	        if (init.method && Client._allowedMethods.indexOf(init.method.toUpperCase()) < 0) {
	            throw new Error('Method has wrong value: ' + init.method);
	        }
	
	        // Defaults
	        init.credentials = init.credentials || 'include';
	        init.mode = init.mode || 'cors';
	
	        // Append Query String
	        if (init.query) {
	            init.url = init.url + (init.url.indexOf('?') > -1 ? '&' : '?') + (0, _Utils.queryStringify)(init.query);
	        }
	
	        if (!findHeaderName('Accept', init.headers)) {
	            init.headers['Accept'] = _ApiResponse2.default._jsonContentType;
	        }
	
	        // Serialize body
	        if ((0, _Utils.isPlainObject)(init.body) || !init.body) {
	
	            var contentTypeHeaderName = findHeaderName(_ApiResponse2.default._contentType, init.headers);
	
	            if (!contentTypeHeaderName) {
	                contentTypeHeaderName = _ApiResponse2.default._contentType;
	                init.headers[contentTypeHeaderName] = _ApiResponse2.default._jsonContentType;
	            }
	
	            var contentType = init.headers[contentTypeHeaderName];
	
	            // Assign a new encoded body
	            if (contentType.indexOf(_ApiResponse2.default._jsonContentType) > -1) {
	                init.body = JSON.stringify(init.body);
	            } else if (contentType.indexOf(_ApiResponse2.default._urlencodedContentType) > -1) {
	                init.body = (0, _Utils.queryStringify)(init.body);
	            }
	        }
	
	        // Create a request with encoded body
	        var req = new _Externals.Request(init.url, init);
	
	        // Keep the original body accessible directly (for mocks)
	        req.originalBody = init.body;
	
	        return req;
	    };
	
	    return Client;
	}(_events2.default);
	
	Client._allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];
	exports.default = Client;
	function findHeaderName(name, headers) {
	    name = name.toLowerCase();
	    return Object.keys(headers).reduce(function (res, key) {
	        if (res) return res;
	        if (name == key.toLowerCase()) return key;
	        return res;
	    }, null);
	}
	
	/**
	 * @name IApiError
	 * @property {string} stack
	 * @property {string} originalMessage
	 * @property {ApiResponse} apiResponse
	 */
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ApiResponse = function () {
	
	    /**
	     * @param {Request} request
	     * @param {Response} response
	     * @param {string} responseText
	     */
	
	    function ApiResponse(request, response, responseText) {
	        _classCallCheck(this, ApiResponse);
	
	        /** @type {Request} */
	        this._request = request;
	
	        /** @type {Response} */
	        this._response = response;
	
	        this._text = responseText;
	        this._json = null;
	        this._multipart = [];
	    }
	
	    ApiResponse.prototype._init = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!(this._isMultipart() || this._isJson())) {
	                                _context.next = 4;
	                                break;
	                            }
	
	                            _context.next = 3;
	                            return this.response().text();
	
	                        case 3:
	                            this._text = _context.sent;
	
	                        case 4:
	                            return _context.abrupt('return', this);
	
	                        case 5:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function _init() {
	            return _ref.apply(this, arguments);
	        }
	
	        return _init;
	    }();
	
	    /**
	     * @return {Response}
	     */
	
	
	    ApiResponse.prototype.response = function response() {
	        return this._response;
	    };
	
	    /**
	     * @return {Request}
	     */
	
	
	    ApiResponse.prototype.request = function request() {
	        return this._request;
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    ApiResponse.prototype.ok = function ok() {
	        return this._response && this._response.ok;
	    };
	
	    /**
	     * @return {string}
	     */
	
	
	    ApiResponse.prototype.text = function text() {
	        if (!this._isJson() && !this._isMultipart()) throw new Error('Response is not text');
	        return this._text;
	    };
	
	    /**
	     * @return {object}
	     */
	
	
	    ApiResponse.prototype.json = function json() {
	        if (!this._isJson()) throw new Error('Response is not JSON');
	        if (!this._json) {
	            this._json = this._text ? JSON.parse(this._text) : null;
	        }
	        return this._json;
	    };
	
	    /**
	     * @param [skipOKCheck]
	     * @return {string}
	     */
	
	
	    ApiResponse.prototype.error = function error(skipOKCheck) {
	
	        if (this.ok() && !skipOKCheck) return null;
	
	        var message = (this._response && this._response.status ? this._response.status + ' ' : '') + (this._response && this._response.statusText ? this._response.statusText : '');
	
	        try {
	
	            if (this.json().message) message = this.json().message;
	            if (this.json().error_description) message = this.json().error_description;
	            if (this.json().description) message = this.json().description;
	        } catch (e) {}
	
	        return message;
	    };
	
	    /**
	     * @return {ApiResponse[]}
	     */
	
	
	    ApiResponse.prototype.multipart = function multipart() {
	
	        if (!this._isMultipart()) throw new Error('Response is not multipart');
	
	        if (!this._multipart.length) {
	
	            // Step 1. Split multipart response
	
	            var text = this.text();
	
	            if (!text) throw new Error('No response body');
	
	            var boundary = this._getContentType().match(/boundary=([^;]+)/i)[1];
	
	            if (!boundary) throw new Error('Cannot find boundary');
	
	            var parts = text.toString().split(ApiResponse._boundarySeparator + boundary);
	
	            if (parts[0].trim() === '') parts.shift();
	            if (parts[parts.length - 1].trim() == ApiResponse._boundarySeparator) parts.pop();
	
	            if (parts.length < 1) throw new Error('No parts in body');
	
	            // Step 2. Parse status info
	
	            var statusInfo = ApiResponse.create(parts.shift(), this._response.status, this._response.statusText).json();
	
	            // Step 3. Parse all other parts
	
	            this._multipart = parts.map(function (part, i) {
	
	                var status = statusInfo.response[i].status;
	
	                return ApiResponse.create(part, status);
	            });
	        }
	
	        return this._multipart;
	    };
	
	    ApiResponse.prototype._isContentType = function _isContentType(contentType) {
	        return this._getContentType().indexOf(contentType) > -1;
	    };
	
	    ApiResponse.prototype._getContentType = function _getContentType() {
	        return this._response.headers.get(ApiResponse._contentType) || '';
	    };
	
	    ApiResponse.prototype._isMultipart = function _isMultipart() {
	        return this._isContentType(ApiResponse._multipartContentType);
	    };
	
	    ApiResponse.prototype._isUrlEncoded = function _isUrlEncoded() {
	        return this._isContentType(ApiResponse._urlencodedContentType);
	    };
	
	    ApiResponse.prototype._isJson = function _isJson() {
	        return this._isContentType(ApiResponse._jsonContentType);
	    };
	
	    /**
	     * Method is used to create ApiResponse object from string parts of multipart/mixed response
	     * @param {string} [text]
	     * @param {number} [status]
	     * @param {string} [statusText]
	     * @return {ApiResponse}
	     */
	
	
	    ApiResponse.create = function create(text, status, statusText) {
	
	        text = text || '';
	        status = status || 200;
	        statusText = statusText || 'OK';
	
	        text = text.replace(/\r/g, '');
	
	        var headers = new _Externals.Headers(),
	            headersAndBody = text.split(ApiResponse._bodySeparator),
	            headersText = headersAndBody.length > 1 ? headersAndBody.shift() : '';
	
	        text = headersAndBody.length > 0 ? headersAndBody.join(ApiResponse._bodySeparator) : null;
	
	        (headersText || '').split('\n').forEach(function (header) {
	
	            var split = header.trim().split(ApiResponse._headerSeparator),
	                key = split.shift().trim(),
	                value = split.join(ApiResponse._headerSeparator).trim();
	
	            if (key) headers.append(key, value);
	        });
	
	        return new ApiResponse(null, new _Externals.Response(text ? text : undefined, {
	            headers: headers,
	            status: status,
	            statusText: statusText
	        }), text);
	    };
	
	    return ApiResponse;
	}();
	
	ApiResponse._contentType = 'Content-Type';
	ApiResponse._jsonContentType = 'application/json';
	ApiResponse._multipartContentType = 'multipart/mixed';
	ApiResponse._urlencodedContentType = 'application/x-www-form-urlencoded';
	ApiResponse._headerSeparator = ':';
	ApiResponse._bodySeparator = '\n\n';
	ApiResponse._boundarySeparator = '--';
	exports.default = ApiResponse;
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Registry = __webpack_require__(13);
	
	var _Registry2 = _interopRequireDefault(_Registry);
	
	var _Client = __webpack_require__(10);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Client = function (_HttpClient) {
	    _inherits(Client, _HttpClient);
	
	    function Client() {
	        _classCallCheck(this, Client);
	
	        var _this = _possibleConstructorReturn(this, _HttpClient.call(this));
	
	        _this._registry = new _Registry2.default();
	        return _this;
	    }
	
	    Client.prototype.registry = function registry() {
	        return this._registry;
	    };
	
	    Client.prototype._loadResponse = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            var mock;
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            mock = this._registry.find(request);
	                            _context.next = 3;
	                            return mock.getResponse(request);
	
	                        case 3:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 4:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function _loadResponse(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return _loadResponse;
	    }();
	
	    return Client;
	}(_Client2.default);
	
	exports.default = Client;
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Mock = __webpack_require__(14);
	
	var _Mock2 = _interopRequireDefault(_Mock);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Registry = function () {
	    function Registry() {
	        _classCallCheck(this, Registry);
	
	        this._mocks = [];
	    }
	
	    Registry.prototype.add = function add(mock) {
	        this._mocks.push(mock);
	        return this;
	    };
	
	    Registry.prototype.clear = function clear() {
	        this._mocks = [];
	        return this;
	    };
	
	    Registry.prototype.find = function find(request) {
	
	        //console.log('Registry is looking for', request);
	
	        var mock = this._mocks.shift();
	
	        if (!mock) throw new Error('No mock in registry for request ' + request.method + ' ' + request.url);
	
	        if (!mock.test(request)) throw new Error('Wrong request ' + request.method + ' ' + request.url + ' for expected mock ' + mock.method() + ' ' + mock.path());
	
	        return mock;
	    };
	
	    Registry.prototype.apiCall = function apiCall(method, path, response, status, statusText, delay) {
	
	        this.add(new _Mock2.default(method, path, response, status, statusText, delay));
	
	        return this;
	    };
	
	    Registry.prototype.authentication = function authentication() {
	
	        this.apiCall('POST', '/restapi/oauth/token', {
	            'access_token': 'ACCESS_TOKEN',
	            'token_type': 'bearer',
	            'expires_in': 3600,
	            'refresh_token': 'REFRESH_TOKEN',
	            'refresh_token_expires_in': 60480,
	            'scope': 'SMS RCM Foo Boo',
	            'expireTime': new Date().getTime() + 3600000
	        });
	
	        return this;
	    };
	
	    Registry.prototype.logout = function logout() {
	
	        this.apiCall('POST', '/restapi/oauth/revoke', {});
	
	        return this;
	    };
	
	    Registry.prototype.presenceLoad = function presenceLoad(id) {
	
	        this.apiCall('GET', '/restapi/v1.0/account/~/extension/' + id + '/presence', {
	            "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id + "/presence",
	            "extension": {
	                "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id,
	                "id": id,
	                "extensionNumber": "101"
	            },
	            "activeCalls": [],
	            "presenceStatus": "Available",
	            "telephonyStatus": "Ringing",
	            "userStatus": "Available",
	            "dndStatus": "TakeAllCalls",
	            "extensionId": id
	        });
	
	        return this;
	    };
	
	    Registry.prototype.subscribeGeneric = function subscribeGeneric(expiresIn) {
	
	        expiresIn = expiresIn || 15 * 60 * 60;
	
	        var date = new Date();
	
	        this.apiCall('POST', '/restapi/v1.0/subscription', {
	            'eventFilters': ['/restapi/v1.0/account/~/extension/~/presence'],
	            'expirationTime': new Date(date.getTime() + expiresIn * 1000).toISOString(),
	            'expiresIn': expiresIn,
	            'deliveryMode': {
	                'transportType': 'PubNub',
	                'encryption': false,
	                'address': '123_foo',
	                'subscriberKey': 'sub-c-foo',
	                'secretKey': 'sec-c-bar'
	            },
	            'id': 'foo-bar-baz',
	            'creationTime': date.toISOString(),
	            'status': 'Active',
	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
	        });
	
	        return this;
	    };
	
	    Registry.prototype.subscribeOnPresence = function subscribeOnPresence(id, detailed) {
	
	        id = id || '1';
	
	        var date = new Date();
	
	        this.apiCall('POST', '/restapi/v1.0/subscription', {
	            'eventFilters': ['/restapi/v1.0/account/~/extension/' + id + '/presence' + (detailed ? '?detailedTelephonyState=true' : '')],
	            'expirationTime': new Date(date.getTime() + 15 * 60 * 60 * 1000).toISOString(),
	            'deliveryMode': {
	                'transportType': 'PubNub',
	                'encryption': true,
	                'address': '123_foo',
	                'subscriberKey': 'sub-c-foo',
	                'secretKey': 'sec-c-bar',
	                'encryptionAlgorithm': 'AES',
	                'encryptionKey': 'VQwb6EVNcQPBhE/JgFZ2zw=='
	            },
	            'creationTime': date.toISOString(),
	            'id': 'foo-bar-baz',
	            'status': 'Active',
	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
	        });
	
	        return this;
	    };
	
	    Registry.prototype.tokenRefresh = function tokenRefresh(failure) {
	
	        if (!failure) {
	
	            this.apiCall('POST', '/restapi/oauth/token', {
	                'access_token': 'ACCESS_TOKEN_FROM_REFRESH',
	                'token_type': 'bearer',
	                'expires_in': 3600,
	                'refresh_token': 'REFRESH_TOKEN_FROM_REFRESH',
	                'refresh_token_expires_in': 60480,
	                'scope': 'SMS RCM Foo Boo'
	            });
	        } else {
	
	            this.apiCall('POST', '/restapi/oauth/token', {
	                'message': 'Wrong token',
	                'error_description': 'Wrong token',
	                'description': 'Wrong token'
	            }, 400);
	        }
	
	        return this;
	    };
	
	    return Registry;
	}();
	
	exports.default = Registry;
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	var _Utils = __webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Mock = function () {
	    function Mock(method, path, json, status, statusText, delay) {
	        _classCallCheck(this, Mock);
	
	        this._method = method.toUpperCase();
	        this._path = path;
	        this._json = json || {};
	        this._delay = delay || 10;
	        this._status = status || 200;
	        this._statusText = statusText || 'OK';
	    }
	
	    Mock.prototype.path = function path() {
	        return this._path;
	    };
	
	    Mock.prototype.method = function method() {
	        return this._method;
	    };
	
	    Mock.prototype.test = function test(request) {
	
	        return request.url.indexOf(this._path) > -1 && request.method.toUpperCase() == this._method;
	    };
	
	    Mock.prototype.getResponse = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return (0, _Utils.delay)(this._delay);
	
	                        case 2:
	                            return _context.abrupt('return', this.createResponse(this._json));
	
	                        case 3:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function getResponse(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return getResponse;
	    }();
	
	    Mock.prototype.createResponse = function createResponse(json, init) {
	
	        init = init || {};
	
	        init.status = init.status || this._status;
	        init.statusText = init.statusText || this._statusText;
	
	        var str = JSON.stringify(json),
	            res = new _Externals.Response(str, init);
	
	        res.headers.set(_ApiResponse2.default._contentType, _ApiResponse2.default._jsonContentType);
	
	        return res;
	    };
	
	    return Mock;
	}();
	
	exports.default = Mock;
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Auth = __webpack_require__(16);
	
	var _Auth2 = _interopRequireDefault(_Auth);
	
	var _Utils = __webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Platform = function (_EventEmitter) {
	    _inherits(Platform, _EventEmitter);
	
	    function Platform(client, cache, server, appKey, appSecret, appName, appVersion, sdkVersion) {
	        _classCallCheck(this, Platform);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.events = {
	            beforeLogin: 'beforeLogin',
	            loginSuccess: 'loginSuccess',
	            loginError: 'loginError',
	            beforeRefresh: 'beforeRefresh',
	            refreshSuccess: 'refreshSuccess',
	            refreshError: 'refreshError',
	            beforeLogout: 'beforeLogout',
	            logoutSuccess: 'logoutSuccess',
	            logoutError: 'logoutError'
	        };
	
	
	        _this._server = server;
	        _this._appKey = appKey;
	        _this._appSecret = appSecret;
	
	        /** @type {Cache} */
	        _this._cache = cache;
	
	        /** @type {Client} */
	        _this._client = client;
	
	        /** @type {Promise<ApiResponse>} */
	        _this._refreshPromise = null;
	
	        _this._auth = new _Auth2.default(_this._cache, Platform._cacheId);
	
	        _this._userAgent = (appName ? appName + (appVersion ? '/' + appVersion : '') + ' ' : '') + 'RCJSSDK/' + sdkVersion;
	
	        return _this;
	    }
	
	    /**
	     * @return {Auth}
	     */
	
	
	    Platform.prototype.auth = function auth() {
	        return this._auth;
	    };
	
	    /**
	     * @return {Client}
	     */
	
	
	    Platform.prototype.client = function client() {
	        return this._client;
	    };
	
	    /**
	     * @param {string} path
	     * @param {object} [options]
	     * @param {boolean} [options.addServer]
	     * @param {string} [options.addMethod]
	     * @param {boolean} [options.addToken]
	     * @return {string}
	     */
	
	
	    Platform.prototype.createUrl = function createUrl(path, options) {
	
	        path = path || '';
	        options = options || {};
	
	        var builtUrl = '',
	            hasHttp = path.indexOf('http://') != -1 || path.indexOf('https://') != -1;
	
	        if (options.addServer && !hasHttp) builtUrl += this._server;
	
	        if (path.indexOf(Platform._urlPrefix) == -1 && !hasHttp) builtUrl += Platform._urlPrefix + '/' + Platform._apiVersion;
	
	        builtUrl += path;
	
	        if (options.addMethod || options.addToken) builtUrl += path.indexOf('?') > -1 ? '&' : '?';
	
	        if (options.addMethod) builtUrl += '_method=' + options.addMethod;
	        if (options.addToken) builtUrl += (options.addMethod ? '&' : '') + 'access_token=' + this._auth.accessToken();
	
	        return builtUrl;
	    };
	
	    /**
	     * @param {string} options.redirectUri
	     * @param {string} options.state
	     * @param {string} options.brandId
	     * @param {string} options.display
	     * @param {string} options.prompt
	     * @param {object} [options]
	     * @return {string}
	     */
	
	
	    Platform.prototype.loginUrl = function loginUrl(options) {
	
	        options = options || {};
	
	        return this.createUrl(Platform._authorizeEndpoint + '?' + (0, _Utils.queryStringify)({
	            'response_type': 'code',
	            'redirect_uri': options.redirectUri || '',
	            'client_id': this._appKey,
	            'state': options.state || '',
	            'brand_id': options.brandId || '',
	            'display': options.display || '',
	            'prompt': options.prompt || ''
	        }), { addServer: true });
	    };
	
	    /**
	     * @param {string} url
	     * @return {Object}
	     */
	
	
	    Platform.prototype.parseLoginRedirectUrl = function parseLoginRedirectUrl(url) {
	
	        var qs = (0, _Utils.parseQueryString)(url.split('?').reverse()[0]),
	            error = qs.error_description || qs.error;
	
	        if (error) {
	            var e = new Error(error);
	            e.error = qs.error;
	            throw e;
	        }
	
	        return qs;
	    };
	
	    /**
	     * Convenience method to handle 3-legged OAuth
	     *
	     * Attention! This is an experimental method and it's signature and behavior may change without notice.
	     *
	     * @experimental
	     * @param {number} [options.width]
	     * @param {number} [options.height]
	     * @param {object} [options.login] additional options for login()
	     * @param {string} [options.origin]
	     * @param {string} [options.property] name of window.postMessage's event data property
	     * @param {string} [options.target] target for window.open()
	     * @param {string} options.url
	     * @return {Promise}
	     */
	
	
	    Platform.prototype.loginWindow = function loginWindow(options) {
	        var _this2 = this;
	
	        return new _Externals.Promise(function (resolve, reject) {
	
	            if (!(0, _Utils.isBrowser)()) throw new Error('This method can be used only in browser');
	
	            if (!options.url) throw new Error('Missing mandatory URL parameter');
	
	            options = options || {};
	            options.url = options.url || 400;
	            options.width = options.width || 400;
	            options.height = options.height || 600;
	            options.origin = options.origin || window.location.origin;
	            options.property = options.property || 'RCAuthorizationCode';
	            options.target = options.target || '_blank';
	
	            var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
	            var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;
	
	            var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
	            var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;
	
	            var left = width / 2 - options.width / 2 + dualScreenLeft;
	            var top = height / 2 - options.height / 2 + dualScreenTop;
	            var win = window.open(options.url, '_blank', options.target == '_blank' ? 'scrollbars=yes, status=yes, width=' + options.width + ', height=' + options.height + ', left=' + left + ', top=' + top : '');
	
	            if (window.focus) win.focus();
	
	            var eventMethod = window.addEventListener ? 'addEventListener' : 'attachEvent';
	            var eventRemoveMethod = eventMethod == 'addEventListener' ? 'removeEventListener' : 'detachEvent';
	            var messageEvent = eventMethod == 'addEventListener' ? 'message' : 'onmessage';
	
	            var eventListener = function eventListener(e) {
	
	                if (e.origin != options.origin) return;
	                if (!e.data || !e.data[options.property]) return; // keep waiting
	
	                win.close();
	                window[eventRemoveMethod](messageEvent, eventListener);
	
	                try {
	
	                    var loginOptions = _this2.parseLoginRedirectUrl(e.data[options.property]);
	
	                    if (!loginOptions.code) throw new Error('No authorization code');
	
	                    resolve(loginOptions);
	                } catch (e) {
	                    reject(e);
	                }
	            };
	
	            window[eventMethod](messageEvent, eventListener, false);
	        });
	    };
	
	    /**
	     * @return {Promise<boolean>}
	     */
	
	
	    Platform.prototype.loggedIn = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.prev = 0;
	                            _context.next = 3;
	                            return this.ensureLoggedIn();
	
	                        case 3:
	                            return _context.abrupt("return", true);
	
	                        case 6:
	                            _context.prev = 6;
	                            _context.t0 = _context["catch"](0);
	                            return _context.abrupt("return", false);
	
	                        case 9:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this, [[0, 6]]);
	        }));
	
	        function loggedIn() {
	            return _ref.apply(this, arguments);
	        }
	
	        return loggedIn;
	    }();
	
	    /**
	     * @param {string} options.username
	     * @param {string} options.password
	     * @param {string} options.extension
	     * @param {string} options.code
	     * @param {string} options.redirectUri
	     * @param {string} options.endpointId
	     * @param {string} options.remember
	     * @param {string} options.accessTokenTtl
	     * @param {string} options.refreshTokenTtl
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.login = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(options) {
	            var body, apiResponse, json;
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.prev = 0;
	
	
	                            options = options || {};
	
	                            this.emit(this.events.beforeLogin);
	
	                            body = {};
	
	
	                            if (!options.code) {
	
	                                body.grant_type = 'password';
	                                body.username = options.username;
	                                body.password = options.password;
	                                body.extension = options.extension || '';
	                            } else if (options.code) {
	
	                                body.grant_type = 'authorization_code';
	                                body.code = options.code;
	                                body.redirect_uri = options.redirectUri;
	                                //body.client_id = this.getCredentials().key; // not needed
	                            }
	
	                            if (options.endpointId) body.endpoint_id = options.endpointId;
	                            if (options.accessTokenTtl) body.accessTokenTtl = options.accessTokenTtl;
	                            if (options.refreshTokenTtl) body.refreshTokenTtl = options.refreshTokenTtl;
	
	                            _context2.next = 10;
	                            return this._tokenRequest(Platform._tokenEndpoint, body);
	
	                        case 10:
	                            apiResponse = _context2.sent;
	                            json = apiResponse.json();
	
	
	                            this._auth.setData(json);
	
	                            this.emit(this.events.loginSuccess, apiResponse);
	
	                            return _context2.abrupt("return", apiResponse);
	
	                        case 17:
	                            _context2.prev = 17;
	                            _context2.t0 = _context2["catch"](0);
	
	
	                            this._cache.clean();
	
	                            this.emit(this.events.loginError, _context2.t0);
	
	                            throw _context2.t0;
	
	                        case 22:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this, [[0, 17]]);
	        }));
	
	        function login(_x) {
	            return _ref2.apply(this, arguments);
	        }
	
	        return login;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     * @private
	     */
	
	
	    Platform.prototype._refresh = function () {
	        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	            var res, json;
	            return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.prev = 0;
	
	
	                            this.emit(this.events.beforeRefresh);
	
	                            _context3.next = 4;
	                            return (0, _Utils.delay)(Platform._refreshDelayMs);
	
	                        case 4:
	                            if (this._auth.refreshToken()) {
	                                _context3.next = 6;
	                                break;
	                            }
	
	                            throw new Error('Refresh token is missing');
	
	                        case 6:
	                            if (this._auth.refreshTokenValid()) {
	                                _context3.next = 8;
	                                break;
	                            }
	
	                            throw new Error('Refresh token has expired');
	
	                        case 8:
	                            _context3.next = 10;
	                            return this._tokenRequest(Platform._tokenEndpoint, {
	                                "grant_type": "refresh_token",
	                                "refresh_token": this._auth.refreshToken(),
	                                "access_token_ttl": this._auth.data().expires_in + 1,
	                                "refresh_token_ttl": this._auth.data().refresh_token_expires_in + 1
	                            });
	
	                        case 10:
	                            res = _context3.sent;
	                            json = res.json();
	
	                            if (json.access_token) {
	                                _context3.next = 14;
	                                break;
	                            }
	
	                            throw this._client.makeError(new Error('Malformed OAuth response'), res);
	
	                        case 14:
	
	                            this._auth.setData(json);
	
	                            this.emit(this.events.refreshSuccess, res);
	
	                            return _context3.abrupt("return", res);
	
	                        case 19:
	                            _context3.prev = 19;
	                            _context3.t0 = _context3["catch"](0);
	
	
	                            _context3.t0 = this._client.makeError(_context3.t0);
	
	                            if (Platform._clearCacheOnRefreshError) {
	                                this._cache.clean();
	                            }
	
	                            this.emit(this.events.refreshError, _context3.t0);
	
	                            throw _context3.t0;
	
	                        case 25:
	                        case "end":
	                            return _context3.stop();
	                    }
	                }
	            }, _callee3, this, [[0, 19]]);
	        }));
	
	        function _refresh() {
	            return _ref3.apply(this, arguments);
	        }
	
	        return _refresh;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.refresh = function () {
	        var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	            var _this3 = this;
	
	            return regeneratorRuntime.wrap(function _callee4$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            if (!this._refreshPromise) {
	                                _context4.next = 2;
	                                break;
	                            }
	
	                            return _context4.abrupt("return", this._refreshPromise);
	
	                        case 2:
	                            _context4.prev = 2;
	
	
	                            this._refreshPromise = this._refresh().then(function (res) {
	                                _this3._refreshPromise = null;
	                                return res;
	                            });
	
	                            return _context4.abrupt("return", this._refreshPromise);
	
	                        case 7:
	                            _context4.prev = 7;
	                            _context4.t0 = _context4["catch"](2);
	
	
	                            this._refreshPromise = null;
	                            throw _context4.t0;
	
	                        case 11:
	                        case "end":
	                            return _context4.stop();
	                    }
	                }
	            }, _callee4, this, [[2, 7]]);
	        }));
	
	        function refresh() {
	            return _ref4.apply(this, arguments);
	        }
	
	        return refresh;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.logout = function () {
	        var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
	            var res;
	            return regeneratorRuntime.wrap(function _callee5$(_context5) {
	                while (1) {
	                    switch (_context5.prev = _context5.next) {
	                        case 0:
	                            _context5.prev = 0;
	
	
	                            this.emit(this.events.beforeLogout);
	
	                            _context5.next = 4;
	                            return this._tokenRequest(Platform._revokeEndpoint, {
	                                token: this._auth.accessToken()
	                            });
	
	                        case 4:
	                            res = _context5.sent;
	
	
	                            this._cache.clean();
	
	                            this.emit(this.events.logoutSuccess, res);
	
	                            return _context5.abrupt("return", res);
	
	                        case 10:
	                            _context5.prev = 10;
	                            _context5.t0 = _context5["catch"](0);
	
	
	                            this.emit(this.events.logoutError, _context5.t0);
	
	                            throw _context5.t0;
	
	                        case 14:
	                        case "end":
	                            return _context5.stop();
	                    }
	                }
	            }, _callee5, this, [[0, 10]]);
	        }));
	
	        function logout() {
	            return _ref5.apply(this, arguments);
	        }
	
	        return logout;
	    }();
	
	    /**
	     * @param {Request} request
	     * @param {object} [options]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<Request>}
	     */
	
	
	    Platform.prototype.inflateRequest = function () {
	        var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(request, options) {
	            return regeneratorRuntime.wrap(function _callee6$(_context6) {
	                while (1) {
	                    switch (_context6.prev = _context6.next) {
	                        case 0:
	
	                            options = options || {};
	
	                            if (!options.skipAuthCheck) {
	                                _context6.next = 3;
	                                break;
	                            }
	
	                            return _context6.abrupt("return", request);
	
	                        case 3:
	                            _context6.next = 5;
	                            return this.ensureLoggedIn();
	
	                        case 5:
	
	                            request.headers.set('X-User-Agent', this._userAgent);
	                            request.headers.set('Client-Id', this._appKey);
	                            request.headers.set('Authorization', this._authHeader());
	                            //request.url = this.createUrl(request.url, {addServer: true}); //FIXME Spec prevents this...
	
	                            return _context6.abrupt("return", request);
	
	                        case 9:
	                        case "end":
	                            return _context6.stop();
	                    }
	                }
	            }, _callee6, this);
	        }));
	
	        function inflateRequest(_x2, _x3) {
	            return _ref6.apply(this, arguments);
	        }
	
	        return inflateRequest;
	    }();
	
	    /**
	     * @param {Request} request
	     * @param {object} [options]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.sendRequest = function () {
	        var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(request, options) {
	            return regeneratorRuntime.wrap(function _callee7$(_context7) {
	                while (1) {
	                    switch (_context7.prev = _context7.next) {
	                        case 0:
	                            _context7.prev = 0;
	                            _context7.next = 3;
	                            return this.inflateRequest(request, options);
	
	                        case 3:
	                            request = _context7.sent;
	                            _context7.next = 6;
	                            return this._client.sendRequest(request);
	
	                        case 6:
	                            return _context7.abrupt("return", _context7.sent);
	
	                        case 9:
	                            _context7.prev = 9;
	                            _context7.t0 = _context7["catch"](0);
	
	                            if (!(!_context7.t0.apiResponse || !_context7.t0.apiResponse.response() || _context7.t0.apiResponse.response().status != 401)) {
	                                _context7.next = 13;
	                                break;
	                            }
	
	                            throw _context7.t0;
	
	                        case 13:
	
	                            this._auth.cancelAccessToken();
	
	                            _context7.next = 16;
	                            return this.sendRequest(request, options);
	
	                        case 16:
	                            return _context7.abrupt("return", _context7.sent);
	
	                        case 17:
	                        case "end":
	                            return _context7.stop();
	                    }
	                }
	            }, _callee7, this, [[0, 9]]);
	        }));
	
	        function sendRequest(_x4, _x5) {
	            return _ref7.apply(this, arguments);
	        }
	
	        return sendRequest;
	    }();
	
	    /**
	     * General purpose function to send anything to server
	     * @param {string} options.url
	     * @param {object} [options.body]
	     * @param {string} [options.method]
	     * @param {object} [options.query]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.send = function () {
	        var _ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
	            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	            return regeneratorRuntime.wrap(function _callee8$(_context8) {
	                while (1) {
	                    switch (_context8.prev = _context8.next) {
	                        case 0:
	
	                            //FIXME https://github.com/bitinn/node-fetch/issues/43
	                            options.url = this.createUrl(options.url, { addServer: true });
	
	                            _context8.next = 3;
	                            return this.sendRequest(this._client.createRequest(options), options);
	
	                        case 3:
	                            return _context8.abrupt("return", _context8.sent);
	
	                        case 4:
	                        case "end":
	                            return _context8.stop();
	                    }
	                }
	            }, _callee8, this);
	        }));
	
	        function send(_x6) {
	            return _ref8.apply(this, arguments);
	        }
	
	        return send;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.get = function () {
	        var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(url, query, options) {
	            return regeneratorRuntime.wrap(function _callee9$(_context9) {
	                while (1) {
	                    switch (_context9.prev = _context9.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'GET';
	                            options.url = url;
	                            options.query = query;
	                            _context9.next = 6;
	                            return this.send(options);
	
	                        case 6:
	                            return _context9.abrupt("return", _context9.sent);
	
	                        case 7:
	                        case "end":
	                            return _context9.stop();
	                    }
	                }
	            }, _callee9, this);
	        }));
	
	        function get(_x8, _x9, _x10) {
	            return _ref9.apply(this, arguments);
	        }
	
	        return get;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} body
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.post = function () {
	        var _ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(url, body, query, options) {
	            return regeneratorRuntime.wrap(function _callee10$(_context10) {
	                while (1) {
	                    switch (_context10.prev = _context10.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'POST';
	                            options.url = url;
	                            options.query = query;
	                            options.body = body;
	                            _context10.next = 7;
	                            return this.send(options);
	
	                        case 7:
	                            return _context10.abrupt("return", _context10.sent);
	
	                        case 8:
	                        case "end":
	                            return _context10.stop();
	                    }
	                }
	            }, _callee10, this);
	        }));
	
	        function post(_x11, _x12, _x13, _x14) {
	            return _ref10.apply(this, arguments);
	        }
	
	        return post;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} [body]
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.put = function () {
	        var _ref11 = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(url, body, query, options) {
	            return regeneratorRuntime.wrap(function _callee11$(_context11) {
	                while (1) {
	                    switch (_context11.prev = _context11.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'PUT';
	                            options.url = url;
	                            options.query = query;
	                            options.body = body;
	                            _context11.next = 7;
	                            return this.send(options);
	
	                        case 7:
	                            return _context11.abrupt("return", _context11.sent);
	
	                        case 8:
	                        case "end":
	                            return _context11.stop();
	                    }
	                }
	            }, _callee11, this);
	        }));
	
	        function put(_x15, _x16, _x17, _x18) {
	            return _ref11.apply(this, arguments);
	        }
	
	        return put;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {string} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype['delete'] = function () {
	        var _ref12 = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(url, query, options) {
	            return regeneratorRuntime.wrap(function _callee12$(_context12) {
	                while (1) {
	                    switch (_context12.prev = _context12.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'DELETE';
	                            options.url = url;
	                            options.query = query;
	                            _context12.next = 6;
	                            return this.send(options);
	
	                        case 6:
	                            return _context12.abrupt("return", _context12.sent);
	
	                        case 7:
	                        case "end":
	                            return _context12.stop();
	                    }
	                }
	            }, _callee12, this);
	        }));
	
	        function _delete(_x19, _x20, _x21) {
	            return _ref12.apply(this, arguments);
	        }
	
	        return _delete;
	    }();
	
	    Platform.prototype._tokenRequest = function () {
	        var _ref13 = _asyncToGenerator(regeneratorRuntime.mark(function _callee13(path, body) {
	            return regeneratorRuntime.wrap(function _callee13$(_context13) {
	                while (1) {
	                    switch (_context13.prev = _context13.next) {
	                        case 0:
	                            _context13.next = 2;
	                            return this.send({
	                                url: path,
	                                skipAuthCheck: true,
	                                body: body,
	                                method: 'POST',
	                                headers: {
	                                    'Authorization': 'Basic ' + this._apiKey(),
	                                    'Content-Type': 'application/x-www-form-urlencoded'
	                                }
	                            });
	
	                        case 2:
	                            return _context13.abrupt("return", _context13.sent);
	
	                        case 3:
	                        case "end":
	                            return _context13.stop();
	                    }
	                }
	            }, _callee13, this);
	        }));
	
	        function _tokenRequest(_x22, _x23) {
	            return _ref13.apply(this, arguments);
	        }
	
	        return _tokenRequest;
	    }();
	
	    Platform.prototype.ensureLoggedIn = function () {
	        var _ref14 = _asyncToGenerator(regeneratorRuntime.mark(function _callee14() {
	            return regeneratorRuntime.wrap(function _callee14$(_context14) {
	                while (1) {
	                    switch (_context14.prev = _context14.next) {
	                        case 0:
	                            if (!this._isAccessTokenValid()) {
	                                _context14.next = 2;
	                                break;
	                            }
	
	                            return _context14.abrupt("return", null);
	
	                        case 2:
	                            _context14.next = 4;
	                            return this.refresh();
	
	                        case 4:
	                            return _context14.abrupt("return", _context14.sent);
	
	                        case 5:
	                        case "end":
	                            return _context14.stop();
	                    }
	                }
	            }, _callee14, this);
	        }));
	
	        function ensureLoggedIn() {
	            return _ref14.apply(this, arguments);
	        }
	
	        return ensureLoggedIn;
	    }();
	
	    Platform.prototype._isAccessTokenValid = function _isAccessTokenValid() {
	        return this._auth.accessTokenValid();
	    };
	
	    Platform.prototype._apiKey = function _apiKey() {
	        var apiKey = this._appKey + ':' + this._appSecret;
	        return typeof btoa == 'function' ? btoa(apiKey) : new Buffer(apiKey).toString('base64');
	    };
	
	    Platform.prototype._authHeader = function _authHeader() {
	        var token = this._auth.accessToken();
	        return this._auth.tokenType() + (token ? ' ' + token : '');
	    };
	
	    return Platform;
	}(_events2.default);
	
	Platform._urlPrefix = '/restapi';
	Platform._apiVersion = 'v1.0';
	Platform._tokenEndpoint = '/restapi/oauth/token';
	Platform._revokeEndpoint = '/restapi/oauth/revoke';
	Platform._authorizeEndpoint = '/restapi/oauth/authorize';
	Platform._refreshDelayMs = 100;
	Platform._cacheId = 'platform';
	Platform._clearCacheOnRefreshError = false;
	exports.default = Platform;
	
	/***/ },
	/* 16 */
	/***/ function(module, exports) {
	
	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Auth = function () {
	    function Auth(cache, cacheId) {
	        _classCallCheck(this, Auth);
	
	        /** @type {Cache} */
	        this._cache = cache;
	        this._cacheId = cacheId;
	    } // 1 minute
	
	
	    Auth.prototype.accessToken = function accessToken() {
	        return this.data().access_token;
	    };
	
	    Auth.prototype.refreshToken = function refreshToken() {
	        return this.data().refresh_token;
	    };
	
	    Auth.prototype.tokenType = function tokenType() {
	        return this.data().token_type;
	    };
	
	    /**
	     * @return {{token_type: string, access_token: string, expires_in: number, refresh_token: string, refresh_token_expires_in: number}}
	     */
	
	
	    Auth.prototype.data = function data() {
	
	        return this._cache.getItem(this._cacheId) || {
	            token_type: '',
	            access_token: '',
	            expires_in: 0,
	            refresh_token: '',
	            refresh_token_expires_in: 0
	        };
	    };
	
	    /**
	     * @param {object} newData
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.setData = function setData(newData) {
	
	        newData = newData || {};
	
	        var data = this.data();
	
	        Object.keys(newData).forEach(function (key) {
	            data[key] = newData[key];
	        });
	
	        data.expire_time = Date.now() + data.expires_in * 1000;
	        data.refresh_token_expire_time = Date.now() + data.refresh_token_expires_in * 1000;
	
	        this._cache.setItem(this._cacheId, data);
	
	        return this;
	    };
	
	    /**
	     * Check if there is a valid (not expired) access token
	     * @return {boolean}
	     */
	
	
	    Auth.prototype.accessTokenValid = function accessTokenValid() {
	
	        var authData = this.data();
	        return authData.token_type === Auth.forcedTokenType || authData.expire_time - Auth.refreshHandicapMs > Date.now();
	    };
	
	    /**
	     * Check if there is a valid (not expired) access token
	     * @return {boolean}
	     */
	
	
	    Auth.prototype.refreshTokenValid = function refreshTokenValid() {
	
	        return this.data().refresh_token_expire_time > Date.now();
	    };
	
	    /**
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.cancelAccessToken = function cancelAccessToken() {
	
	        return this.setData({
	            access_token: '',
	            expires_in: 0
	        });
	    };
	
	    /**
	     * This method sets a special authentication mode used in Service Web
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.forceAuthentication = function forceAuthentication() {
	
	        this.setData({
	            token_type: Auth.forcedTokenType,
	            access_token: '',
	            expires_in: 0,
	            refresh_token: '',
	            refresh_token_expires_in: 0
	        });
	
	        return this;
	    };
	
	    return Auth;
	}();
	
	//export interface IAuthData {
	//    remember?:boolean;
	//    token_type?:string;
	//    access_token?:string;
	//    expires_in?:number; // actually it's string
	//    expire_time?:number;
	//    refresh_token?:string;
	//    refresh_token_expires_in?:number; // actually it's string
	//    refresh_token_expire_time?:number;
	//    scope?:string;
	//}
	
	
	Auth.refreshHandicapMs = 60 * 1000;
	Auth.forcedTokenType = 'forced';
	exports.default = Auth;
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _PubnubMock = __webpack_require__(18);
	
	var _PubnubMock2 = _interopRequireDefault(_PubnubMock);
	
	var _Externals = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PubnubMockFactory = function () {
	    function PubnubMockFactory() {
	        _classCallCheck(this, PubnubMockFactory);
	
	        this.crypto_obj = _Externals.PUBNUB.crypto_obj;
	    }
	
	    PubnubMockFactory.prototype.init = function init(options) {
	        return new _PubnubMock2.default(options);
	    };
	
	    return PubnubMockFactory;
	}();
	
	exports.default = PubnubMockFactory;
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Externals = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PubnubMock = function (_EventEmitter) {
	    _inherits(PubnubMock, _EventEmitter);
	
	    function PubnubMock(options) {
	        _classCallCheck(this, PubnubMock);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.options = options;
	        _this.crypto_obj = _Externals.PUBNUB.crypto_obj;
	        return _this;
	    }
	
	    PubnubMock.prototype.init = function init(options) {
	        this.options = options;
	    };
	
	    PubnubMock.prototype.ready = function ready() {};
	
	    PubnubMock.prototype.subscribe = function subscribe(options) {
	        this.on('message-' + options.channel, options.message);
	    };
	
	    PubnubMock.prototype.unsubscribe = function unsubscribe(options) {
	        this.removeAllListeners('message-' + options.channel);
	    };
	
	    PubnubMock.prototype.receiveMessage = function receiveMessage(msg, channel) {
	        this.emit('message-' + channel, msg, 'env', channel);
	    };
	
	    return PubnubMock;
	}(_events2.default);
	
	exports.default = PubnubMock;
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Subscription = function (_EventEmitter) {
	    _inherits(Subscription, _EventEmitter);
	
	    function Subscription(pubnubFactory, platform) {
	        _classCallCheck(this, Subscription);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.events = {
	            notification: 'notification',
	            removeSuccess: 'removeSuccess',
	            removeError: 'removeError',
	            renewSuccess: 'renewSuccess',
	            renewError: 'renewError',
	            subscribeSuccess: 'subscribeSuccess',
	            subscribeError: 'subscribeError'
	        };
	
	
	        _this._pubnubFactory = pubnubFactory;
	        _this._platform = platform;
	        _this._pubnub = null;
	        _this._pubnubLastChannel = null;
	        _this._timeout = null;
	        _this._subscription = null;
	
	        return _this;
	    }
	
	    Subscription.prototype.subscribed = function subscribed() {
	
	        var subscription = this.subscription();
	
	        return !!(subscription.id && subscription.deliveryMode && subscription.deliveryMode.subscriberKey && subscription.deliveryMode.address);
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    Subscription.prototype.alive = function alive() {
	        return this.subscribed() && Date.now() < this.expirationTime();
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    Subscription.prototype.expired = function expired() {
	        if (!this.subscribed()) return true;
	        return !this.subscribed() || Date.now() > this.subscription().expirationTime;
	    };
	
	    Subscription.prototype.expirationTime = function expirationTime() {
	        return new Date(this.subscription().expirationTime || 0).getTime() - Subscription._renewHandicapMs;
	    };
	
	    Subscription.prototype.setSubscription = function setSubscription(subscription) {
	
	        subscription = subscription || {};
	
	        this._clearTimeout();
	        this._setSubscription(subscription);
	        this._subscribeAtPubnub();
	        this._setTimeout();
	
	        return this;
	    };
	
	    Subscription.prototype.subscription = function subscription() {
	        return this._subscription || {};
	    };
	
	    /**
	     * Creates or updates subscription if there is an active one
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.register = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!this.alive()) {
	                                _context.next = 6;
	                                break;
	                            }
	
	                            _context.next = 3;
	                            return this.renew();
	
	                        case 3:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 6:
	                            _context.next = 8;
	                            return this.subscribe();
	
	                        case 8:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 9:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function register() {
	            return _ref.apply(this, arguments);
	        }
	
	        return register;
	    }();
	
	    Subscription.prototype.eventFilters = function eventFilters() {
	        return this.subscription().eventFilters || [];
	    };
	
	    /**
	     * @param {string[]} events
	     * @return {Subscription}
	     */
	
	
	    Subscription.prototype.addEventFilters = function addEventFilters(events) {
	        this.setEventFilters(this.eventFilters().concat(events));
	        return this;
	    };
	
	    /**
	     * @param {string[]} events
	     * @return {Subscription}
	     */
	
	
	    Subscription.prototype.setEventFilters = function setEventFilters(events) {
	        var subscription = this.subscription();
	        subscription.eventFilters = events;
	        this._setSubscription(subscription);
	        return this;
	    };
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.subscribe = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	            var response, json;
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.prev = 0;
	
	
	                            this._clearTimeout();
	
	                            if (this.eventFilters().length) {
	                                _context2.next = 4;
	                                break;
	                            }
	
	                            throw new Error('Events are undefined');
	
	                        case 4:
	                            _context2.next = 6;
	                            return this._platform.post('/subscription', {
	                                eventFilters: this._getFullEventFilters(),
	                                deliveryMode: {
	                                    transportType: 'PubNub'
	                                }
	                            });
	
	                        case 6:
	                            response = _context2.sent;
	                            json = response.json();
	
	
	                            this.setSubscription(json).emit(this.events.subscribeSuccess, response);
	
	                            return _context2.abrupt('return', response);
	
	                        case 12:
	                            _context2.prev = 12;
	                            _context2.t0 = _context2['catch'](0);
	
	
	                            _context2.t0 = this._platform.client().makeError(_context2.t0);
	
	                            this.reset().emit(this.events.subscribeError, _context2.t0);
	
	                            throw _context2.t0;
	
	                        case 17:
	                        case 'end':
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this, [[0, 12]]);
	        }));
	
	        function subscribe() {
	            return _ref2.apply(this, arguments);
	        }
	
	        return subscribe;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.renew = function () {
	        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	            var response, json;
	            return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.prev = 0;
	
	
	                            this._clearTimeout();
	
	                            if (this.subscribed()) {
	                                _context3.next = 4;
	                                break;
	                            }
	
	                            throw new Error('No subscription');
	
	                        case 4:
	                            if (this.eventFilters().length) {
	                                _context3.next = 6;
	                                break;
	                            }
	
	                            throw new Error('Events are undefined');
	
	                        case 6:
	                            _context3.next = 8;
	                            return this._platform.put('/subscription/' + this.subscription().id, {
	                                eventFilters: this._getFullEventFilters()
	                            });
	
	                        case 8:
	                            response = _context3.sent;
	                            json = response.json();
	
	
	                            this.setSubscription(json).emit(this.events.renewSuccess, response);
	
	                            return _context3.abrupt('return', response);
	
	                        case 14:
	                            _context3.prev = 14;
	                            _context3.t0 = _context3['catch'](0);
	
	
	                            _context3.t0 = this._platform.client().makeError(_context3.t0);
	
	                            this.reset().emit(this.events.renewError, _context3.t0);
	
	                            throw _context3.t0;
	
	                        case 19:
	                        case 'end':
	                            return _context3.stop();
	                    }
	                }
	            }, _callee3, this, [[0, 14]]);
	        }));
	
	        function renew() {
	            return _ref3.apply(this, arguments);
	        }
	
	        return renew;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.remove = function () {
	        var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	            var response;
	            return regeneratorRuntime.wrap(function _callee4$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            _context4.prev = 0;
	
	                            if (this.subscribed()) {
	                                _context4.next = 3;
	                                break;
	                            }
	
	                            throw new Error('No subscription');
	
	                        case 3:
	                            _context4.next = 5;
	                            return this._platform.delete('/subscription/' + this.subscription().id);
	
	                        case 5:
	                            response = _context4.sent;
	
	
	                            this.reset().emit(this.events.removeSuccess, response);
	
	                            return _context4.abrupt('return', response);
	
	                        case 10:
	                            _context4.prev = 10;
	                            _context4.t0 = _context4['catch'](0);
	
	
	                            _context4.t0 = this._platform.client().makeError(_context4.t0);
	
	                            this.emit(this.events.removeError, _context4.t0);
	
	                            throw _context4.t0;
	
	                        case 15:
	                        case 'end':
	                            return _context4.stop();
	                    }
	                }
	            }, _callee4, this, [[0, 10]]);
	        }));
	
	        function remove() {
	            return _ref4.apply(this, arguments);
	        }
	
	        return remove;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.resubscribe = function resubscribe() {
	        var filters = this.eventFilters();
	        return this.reset().setEventFilters(filters).subscribe();
	    };
	
	    /**
	     * Remove subscription and disconnect from PUBNUB
	     * This method resets subscription at client side but backend is not notified
	     */
	
	
	    Subscription.prototype.reset = function reset() {
	        this._clearTimeout();
	        if (this.subscribed() && this._pubnub) this._pubnub.unsubscribe({ channel: this.subscription().deliveryMode.address });
	        this._setSubscription(null);
	        return this;
	    };
	
	    Subscription.prototype._setSubscription = function _setSubscription(subscription) {
	        this._subscription = subscription;
	    };
	
	    Subscription.prototype._getFullEventFilters = function _getFullEventFilters() {
	        var _this2 = this;
	
	        return this.eventFilters().map(function (event) {
	            return _this2._platform.createUrl(event);
	        });
	    };
	
	    Subscription.prototype._setTimeout = function _setTimeout() {
	        var _this3 = this;
	
	        this._clearTimeout();
	
	        if (!this.alive()) throw new Error('Subscription is not alive');
	
	        this._timeout = setInterval(function () {
	
	            if (_this3.alive()) return;
	
	            if (_this3.expired()) {
	                _this3.subscribe();
	            } else {
	                _this3.renew();
	            }
	        }, Subscription._pollInterval);
	
	        return this;
	    };
	
	    Subscription.prototype._clearTimeout = function _clearTimeout() {
	        clearInterval(this._timeout);
	        return this;
	    };
	
	    Subscription.prototype._decrypt = function _decrypt(message) {
	
	        if (!this.subscribed()) throw new Error('No subscription');
	
	        if (this.subscription().deliveryMode.encryptionKey) {
	
	            message = this._pubnubFactory.crypto_obj.decrypt(message, this.subscription().deliveryMode.encryptionKey, {
	                encryptKey: false,
	                keyEncoding: 'base64',
	                keyLength: 128,
	                mode: 'ecb'
	            });
	        }
	
	        return message;
	    };
	
	    Subscription.prototype._notify = function _notify(message) {
	        this.emit(this.events.notification, this._decrypt(message));
	        return this;
	    };
	
	    Subscription.prototype._subscribeAtPubnub = function _subscribeAtPubnub() {
	
	        if (!this.alive()) throw new Error('Subscription is not alive');
	
	        var deliveryMode = this.subscription().deliveryMode;
	
	        if (this._pubnub) {
	
	            if (this._pubnubLastChannel == deliveryMode.address) {
	                // Nothing to update, keep listening to same channel
	                return this;
	            } else if (this._pubnubLastChannel) {
	                // Need to subscribe to new channel
	                this._pubnub.unsubscribe({ channel: this._pubnubLastChannel });
	            }
	
	            // Re-init for new data
	            this._pubnub = this._pubnub.init({
	                ssl: true,
	                subscribe_key: deliveryMode.subscriberKey
	            });
	        } else {
	
	            // Init from scratch
	            this._pubnub = this._pubnubFactory.init({
	                ssl: true,
	                subscribe_key: deliveryMode.subscriberKey
	            });
	
	            this._pubnub.ready(); //TODO This may be not needed anymore
	        }
	
	        this._pubnubLastChannel = deliveryMode.address;
	
	        this._pubnub.subscribe({
	            channel: deliveryMode.address,
	            message: this._notify.bind(this),
	            connect: function connect() {}
	        });
	
	        return this;
	    };
	
	    return Subscription;
	}(_events2.default);
	
	//export interface ISubscription {
	//    id?:string;
	//    uri?: string;
	//    eventFilters?:string[];
	//    expirationTime?:string; // 2014-03-12T19:54:35.613Z
	//    expiresIn?:number;
	//    deliveryMode?: {
	//        transportType?:string;
	//        encryption?:boolean;
	//        address?:string;
	//        subscriberKey?:string;
	//        encryptionKey?:string;
	//        secretKey?:string;
	//    };
	//    creationTime?:string; // 2014-03-12T19:54:35.613Z
	//    status?:string; // Active
	//}
	
	
	Subscription._renewHandicapMs = 2 * 60 * 1000;
	Subscription._pollInterval = 10 * 1000;
	exports.default = Subscription;
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _Subscription2 = __webpack_require__(19);
	
	var _Subscription3 = _interopRequireDefault(_Subscription2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CachedSubscription = function (_Subscription) {
	    _inherits(CachedSubscription, _Subscription);
	
	    function CachedSubscription(pubnubFactory, platform, cache, cacheKey) {
	        _classCallCheck(this, CachedSubscription);
	
	        /** @type {Cache} */
	
	        var _this = _possibleConstructorReturn(this, _Subscription.call(this, pubnubFactory, platform));
	
	        _this._cache = cache;
	        _this._cacheKey = cacheKey;
	
	        return _this;
	    }
	
	    CachedSubscription.prototype.subscription = function subscription() {
	        return this._cache.getItem(this._cacheKey) || {};
	    };
	
	    CachedSubscription.prototype._setSubscription = function _setSubscription(subscription) {
	        return this._cache.setItem(this._cacheKey, subscription);
	    };
	
	    /**
	     * This function checks whether there are any pre-defined eventFilters in cache and if not -- uses provided as defaults
	     * @param {string[]} events
	     * @return {CachedSubscription}
	     */
	
	
	    CachedSubscription.prototype.restore = function restore(events) {
	
	        if (!this.eventFilters().length) {
	            this.setEventFilters(events);
	        }
	
	        return this;
	    };
	
	    return CachedSubscription;
	}(_Subscription3.default);
	
	exports.default = CachedSubscription;
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=ringcentral.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121), __webpack_require__(122).Buffer))

/***/ },
/* 121 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(123)
	var ieee754 = __webpack_require__(124)
	var isArray = __webpack_require__(125)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(122).Buffer, (function() { return this; }())))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 124 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 125 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.2.1
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(128);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	      var parent = this;
	
	      var child = new this.constructor(lib$es6$promise$$internal$$noop);
	
	      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
	        lib$es6$promise$$internal$$makePromise(child);
	      }
	
	      var state = parent._state;
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$es6$promise$asap$$asap(function(){
	          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
	        });
	      } else {
	        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$es6$promise$then$$default &&
	          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    var lib$es6$promise$$internal$$id = 0;
	    function lib$es6$promise$$internal$$nextId() {
	      return lib$es6$promise$$internal$$id++;
	    }
	
	    function lib$es6$promise$$internal$$makePromise(promise) {
	      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
	      promise._state = undefined;
	      promise._result = undefined;
	      promise._subscribers = [];
	    }
	
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        return new Constructor(function(resolve, reject) {
	          reject(new TypeError('You must pass an array to race.'));
	        });
	      } else {
	        return new Constructor(function(resolve, reject) {
	          var length = entries.length;
	          for (var i = 0; i < length; i++) {
	            Constructor.resolve(entries[i]).then(resolve, reject);
	          }
	        });
	      }
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
	      this._result = this._state = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$es6$promise$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
	        lib$es6$promise$$internal$$makePromise(this.promise);
	      }
	
	      if (lib$es6$promise$utils$$isArray(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._result = new Array(this.length);
	
	        if (this.length === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
	      }
	    }
	
	    function lib$es6$promise$enumerator$$validationError() {
	      return new Error('Array Methods must be provided an Array');
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length  = this.length;
	      var input   = this._input;
	
	      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$es6$promise$promise$resolve$$default) {
	        var then = lib$es6$promise$$internal$$getThen(entry);
	
	        if (then === lib$es6$promise$then$$default &&
	            entry._state !== lib$es6$promise$$internal$$PENDING) {
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = entry;
	        } else if (c === lib$es6$promise$promise$$default) {
	          var promise = new c(lib$es6$promise$$internal$$noop);
	          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        this._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = value;
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(129)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121), (function() { return this; }()), __webpack_require__(127)(module)))

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 128 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 130 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var list = this.map[name]
	    if (!list) {
	      list = []
	      this.map[name] = list
	    }
	    list.push(value)
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    var values = this.map[normalizeName(name)]
	    return values ? values[0] : null
	  }
	
	  Headers.prototype.getAll = function(name) {
	    return this.map[normalizeName(name)] || []
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = [normalizeValue(value)]
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    Object.getOwnPropertyNames(this.map).forEach(function(name) {
	      this.map[name].forEach(function(value) {
	        callback.call(thisArg, value, name, this)
	      }, this)
	    }, this)
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    reader.readAsArrayBuffer(blob)
	    return fileReaderReady(reader)
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    reader.readAsText(blob)
	    return fileReaderReady(reader)
	  }
	
	  var support = {
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (!body) {
	        this._bodyText = ''
	      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
	        // Only support ArrayBuffers for POST method.
	        // Receiving ArrayBuffers happens via Blobs, instead.
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        return this.blob().then(readBlobAsArrayBuffer)
	      }
	
	      this.text = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return readBlobAsText(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as text')
	        } else {
	          return Promise.resolve(this._bodyText)
	        }
	      }
	    } else {
	      this.text = function() {
	        var rejected = consumed(this)
	        return rejected ? rejected : Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	    if (Request.prototype.isPrototypeOf(input)) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = input
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this)
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function headers(xhr) {
	    var head = new Headers()
	    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
	    pairs.forEach(function(header) {
	      var split = header.trim().split(':')
	      var key = split.shift().trim()
	      var value = split.join(':').trim()
	      head.append(key, value)
	    })
	    return head
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = options.status
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = options.statusText
	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request
	      if (Request.prototype.isPrototypeOf(input) && !init) {
	        request = input
	      } else {
	        request = new Request(input, init)
	      }
	
	      var xhr = new XMLHttpRequest()
	
	      function responseURL() {
	        if ('responseURL' in xhr) {
	          return xhr.responseURL
	        }
	
	        // Avoid security warnings on getResponseHeader when not allowed by CORS
	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	          return xhr.getResponseHeader('X-Request-URL')
	        }
	
	        return
	      }
	
	      xhr.onload = function() {
	        var status = (xhr.status === 1223) ? 204 : xhr.status
	        if (status < 100 || status > 599) {
	          reject(new TypeError('Network request failed'))
	          return
	        }
	        var options = {
	          status: status,
	          statusText: xhr.statusText,
	          headers: headers(xhr),
	          url: responseURL()
	        }
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/*! 3.15.2 / modern */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["PUBNUB"] = factory();
		else
			root["PUBNUB"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* globals 'Modern' */
		/* eslint curly: 0, camelcase: 0, dot-notation: 0 */
	
		var packageJSON = __webpack_require__(1);
		var pubNubCore = __webpack_require__(2);
		var crypto_obj = __webpack_require__(5);
		var CryptoJS = __webpack_require__(6);
		var WS = __webpack_require__(7);
	
		/**
		 * UTIL LOCALS
		 */
		var PNSDK = 'PubNub-JS-' + 'Modern' + '/' + packageJSON.version;
	
		/**
		 * LOCAL STORAGE
		 */
		var db = (function () {
		  var ls = typeof localStorage !== 'undefined' && localStorage;
		  return {
		    get: function (key) {
		      try {
		        if (ls) return ls.getItem(key);
		        if (document.cookie.indexOf(key) === -1) return null;
		        return ((document.cookie || '').match(
		            RegExp(key + '=([^;]+)')
		          ) || [])[1] || null;
		      } catch (e) {
		        return;
		      }
		    },
		    set: function (key, value) {
		      try {
		        if (ls) return ls.setItem(key, value) && 0;
		        document.cookie = key + '=' + value +
		          '; expires=Thu, 1 Aug 2030 20:00:00 UTC; path=/';
		      } catch (e) {
		        return;
		      }
		    }
		  };
		})();
	
	
		/**
		 * CORS XHR Request
		 * ================
		 *  xdr({
		 *     url     : ['http://www.blah.com/url'],
		 *     success : function(response) {},
		 *     fail    : function() {}
		 *  });
		 */
		function xdr(setup) {
		  var xhr;
		  var timer;
		  var complete = 0;
		  var loaded = 0;
		  var async = true; /* do not allow sync operations in modern builds */
		  var xhrtme = setup.timeout || pubNubCore.DEF_TIMEOUT;
		  var data = setup.data || {};
		  var fail = setup.fail || function () {};
		  var success = setup.success || function () {};
	
		  var done = function (failed, response) {
		    if (complete) return;
		    complete = 1;
	
		    clearTimeout(timer);
	
		    if (xhr) {
		      xhr.onerror = xhr.onload = null;
		      if (xhr.abort) xhr.abort();
		      xhr = null;
		    }
	
		    if (failed) fail(response);
		  };
	
		  var finished = function () {
		    if (loaded) return;
		    var response;
		    loaded = 1;
	
		    clearTimeout(timer);
	
		    try {
		      response = JSON.parse(xhr.responseText);
		    } catch (r) {
		      return done(1);
		    }
	
		    success(response);
		  };
	
		  timer = pubNubCore.timeout(function () {
		    done(1);
		  }, xhrtme);
	
		  // Send
		  try {
		    xhr = typeof XDomainRequest !== 'undefined' &&
		      new XDomainRequest() ||
		      new XMLHttpRequest();
	
		    xhr.onerror = xhr.onabort = function () {
		      done(1, xhr.responseText || { error: 'Network Connection Error' });
		    };
		    xhr.onload = xhr.onloadend = finished;
	
		    data.pnsdk = PNSDK;
		    var url = pubNubCore.build_url(setup.url, data);
		    xhr.open('GET', url, async);
		    if (async) xhr.timeout = xhrtme;
		    xhr.send();
		  } catch (eee) {
		    done(1, { error: 'XHR Failed', stacktrace: eee });
		  }
	
		  // Return 'done'
		  return done;
		}
	
		/**
		 * BIND
		 * ====
		 * bind( 'keydown', search('a')[0], function(element) {
		 *     ...
		 * } );
		 */
		function bind(type, el, fun) {
		  pubNubCore.each(type.split(','), function (etype) {
		    var rapfun = function (e) {
		      if (!e) e = window.event;
		      if (!fun(e)) {
		        e.cancelBubble = true;
		        e.returnValue = false;
		        if (e.preventDefault) e.preventDefault();
		        if (e.stopPropagation) e.stopPropagation();
		      }
		    };
	
		    if (el.addEventListener) el.addEventListener(etype, rapfun, false);
		    else if (el.attachEvent) el.attachEvent('on' + etype, rapfun);
		    else el['on' + etype] = rapfun;
		  });
		}
	
		/**
		 * ERROR
		 * ===
		 * error('message');
		 */
		function error(message) {
		  console.error(message); // eslint-disable-line no-console
		}
	
		/**
		 * EVENTS
		 * ======
		 * PUBNUB.events.bind( 'you-stepped-on-flower', function(message) {
		 *     // Do Stuff with message
		 * } );
		 *
		 * PUBNUB.events.fire( 'you-stepped-on-flower', "message-data" );
		 * PUBNUB.events.fire( 'you-stepped-on-flower', {message:"data"} );
		 * PUBNUB.events.fire( 'you-stepped-on-flower', [1,2,3] );
		 *
		 */
		var events = {
		  list: {},
		  unbind: function (name) {
		    events.list[name] = [];
		  },
		  bind: function (name, fun) {
		    (events.list[name] = events.list[name] || []).push(fun);
		  },
		  fire: function (name, data) {
		    pubNubCore.each(
		      events.list[name] || [],
		      function (fun) {
		        fun(data);
		      }
		    );
		  }
		};
	
		/**
		 * ATTR
		 * ====
		 * var attribute = attr( node, 'attribute' );
		 */
		function attr(node, attribute, value) {
		  if (value) node.setAttribute(attribute, value);
		  else return node && node.getAttribute && node.getAttribute(attribute);
		}
	
		/**
		 * $
		 * =
		 * var div = $('divid');
		 */
		function $(id) {
		  return document.getElementById(id);
		}
	
	
		/**
		 * SEARCH
		 * ======
		 * var elements = search('a div span');
		 */
		function search(elements, start) {
		  var list = [];
		  pubNubCore.each(elements.split(/\s+/), function (el) {
		    pubNubCore.each((start || document).getElementsByTagName(el), function (node) {
		      list.push(node);
		    });
		  });
		  return list;
		}
	
		/**
		 * CSS
		 * ===
		 * var obj = create('div');
		 */
		function css(element, styles) {
		  for (var style in styles) if (styles.hasOwnProperty(style))
		    try {
		      element.style[style] = styles[style] + (
		          '|width|height|top|left|'.indexOf(style) > 0 &&
		          typeof styles[style] === 'number'
		            ? 'px' : ''
		        );
		    } catch (e) {
		      return;
		    }
		}
	
		/**
		 * CREATE
		 * ======
		 * var obj = create('div');
		 */
		function create(element) {
		  return document.createElement(element);
		}
	
	
		function get_hmac_SHA256(data, key) {
		  var hash = CryptoJS['HmacSHA256'](data, key);
		  return hash.toString(CryptoJS['enc']['Base64']);
		}
	
		/* =-====================================================================-= */
		/* =-====================================================================-= */
		/* =-=========================     PUBNUB     ===========================-= */
		/* =-====================================================================-= */
		/* =-====================================================================-= */
	
		function CREATE_PUBNUB(setup) {
		  setup.db = db;
		  setup.xdr = xdr;
		  setup.error = setup.error || error;
		  setup.hmac_SHA256 = get_hmac_SHA256;
		  setup.crypto_obj = crypto_obj();
		  setup.WS = WS;
		  setup.params = { pnsdk: PNSDK };
	
		  var SELF = function (setup) {
		    return CREATE_PUBNUB(setup);
		  };
	
		  var PN = pubNubCore.PN_API(setup);
		  for (var prop in PN) {
		    if (PN.hasOwnProperty(prop)) {
		      SELF[prop] = PN[prop];
		    }
		  }
	
		  SELF.init = SELF;
		  SELF.$ = $;
		  SELF.attr = attr;
		  SELF.search = search;
		  SELF.bind = bind;
		  SELF.css = css;
		  SELF.create = create;
		  SELF.crypto_obj = crypto_obj();
		  SELF.WS = WS;
		  SELF.PNmessage = pubNubCore.PNmessage;
		  SELF.supplant = pubNubCore.supplant;
	
		  if (typeof(window) !== 'undefined') {
		    bind('beforeunload', window, function () {
		      SELF['each-channel'](function (ch) {
		        SELF['LEAVE'](ch.name, 1);
		      });
		      return true;
		    });
		  }
	
		  SELF.ready();
	
		  // Return without Testing
		  if (setup.notest) return SELF;
	
		  if (typeof(window) !== 'undefined') {
		    bind('offline', window, SELF['offline']);
		  }
	
		  if (typeof(document) !== 'undefined') {
		    bind('offline', document, SELF['offline']);
		  }
	
		  return SELF;
		}
	
		CREATE_PUBNUB.init = CREATE_PUBNUB;
		CREATE_PUBNUB.secure = CREATE_PUBNUB;
		CREATE_PUBNUB.crypto_obj = crypto_obj();
		CREATE_PUBNUB.WS = WS;
		CREATE_PUBNUB.db = db;
		CREATE_PUBNUB.PNmessage = pubNubCore.PNmessage;
		CREATE_PUBNUB.uuid = pubNubCore.uuid;
	
		CREATE_PUBNUB.css = css;
		CREATE_PUBNUB.$ = $;
		CREATE_PUBNUB.create = $;
		CREATE_PUBNUB.bind = bind;
		CREATE_PUBNUB.search = search;
		CREATE_PUBNUB.attr = attr;
		CREATE_PUBNUB.events = events;
	
		CREATE_PUBNUB.map = pubNubCore.map;
		CREATE_PUBNUB.each = pubNubCore.each;
		CREATE_PUBNUB.grep = pubNubCore.grep;
		CREATE_PUBNUB.supplant = pubNubCore.supplant;
		CREATE_PUBNUB.now = pubNubCore.now;
		CREATE_PUBNUB.unique = pubNubCore.unique;
		CREATE_PUBNUB.updater = pubNubCore.updater;
	
		module.exports = CREATE_PUBNUB;
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
		module.exports = {
			"name": "pubnub",
			"preferGlobal": false,
			"version": "3.15.2",
			"author": "PubNub <support@pubnub.com>",
			"description": "Publish & Subscribe Real-time Messaging with PubNub",
			"contributors": [
				{
					"name": "Stephen Blum",
					"email": "stephen@pubnub.com"
				}
			],
			"bin": {},
			"scripts": {
				"test": "grunt test --force"
			},
			"main": "./node.js/pubnub.js",
			"browser": "./modern/dist/pubnub.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/pubnub/javascript.git"
			},
			"keywords": [
				"cloud",
				"publish",
				"subscribe",
				"websockets",
				"comet",
				"bosh",
				"xmpp",
				"real-time",
				"messaging"
			],
			"dependencies": {
				"agentkeepalive": "~0.2",
				"lodash": "^4.1.0"
			},
			"noAnalyze": false,
			"devDependencies": {
				"chai": "^3.5.0",
				"eslint": "2.4.0",
				"eslint-config-airbnb": "^6.0.2",
				"eslint-plugin-flowtype": "^2.1.0",
				"eslint-plugin-mocha": "^2.0.0",
				"eslint-plugin-react": "^4.1.0",
				"flow-bin": "^0.22.0",
				"grunt": "^0.4.5",
				"grunt-contrib-clean": "^1.0.0",
				"grunt-contrib-copy": "^0.8.2",
				"grunt-contrib-uglify": "^0.11.1",
				"grunt-env": "^0.4.4",
				"grunt-eslint": "^18.0.0",
				"grunt-flow": "^1.0.3",
				"grunt-karma": "^0.12.1",
				"grunt-mocha-istanbul": "^3.0.1",
				"grunt-text-replace": "^0.4.0",
				"grunt-webpack": "^1.0.11",
				"imports-loader": "^0.6.5",
				"isparta": "^4.0.0",
				"json-loader": "^0.5.4",
				"karma": "^0.13.21",
				"karma-chai": "^0.1.0",
				"karma-mocha": "^0.2.1",
				"karma-phantomjs-launcher": "^1.0.0",
				"karma-spec-reporter": "0.0.24",
				"load-grunt-tasks": "^3.4.0",
				"mocha": "^2.4.5",
				"nock": "^1.1.0",
				"node-uuid": "^1.4.7",
				"nodeunit": "^0.9.0",
				"phantomjs-prebuilt": "^2.1.4",
				"proxyquire": "^1.7.4",
				"sinon": "^1.17.2",
				"uglify-js": "^2.6.1",
				"underscore": "^1.7.0",
				"webpack": "^1.12.13",
				"webpack-dev-server": "^1.14.1"
			},
			"bundleDependencies": [],
			"license": "MIT",
			"engine": {
				"node": ">=0.8"
			},
			"files": [
				"core",
				"node.js",
				"modern",
				"CHANGELOG",
				"FUTURE.md",
				"LICENSE",
				"README.md"
			]
		};
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint camelcase: 0, no-use-before-define: 0, no-unused-expressions: 0  */
		/* eslint eqeqeq: 0, one-var: 0 */
		/* eslint no-redeclare: 0 */
		/* eslint guard-for-in: 0 */
		/* eslint block-scoped-var: 0 space-return-throw-case: 0, no-unused-vars: 0 */
	
		var packageJSON = __webpack_require__(1);
		var defaultConfiguration = __webpack_require__(3);
		var utils = __webpack_require__(4);
	
		var NOW = 1;
		var READY = false;
		var READY_BUFFER = [];
		var PRESENCE_SUFFIX = '-pnpres';
		var DEF_WINDOWING = 10; // MILLISECONDS.
		var DEF_TIMEOUT = 15000; // MILLISECONDS.
		var DEF_SUB_TIMEOUT = 310; // SECONDS.
		var DEF_KEEPALIVE = 60; // SECONDS (FOR TIMESYNC).
		var SECOND = 1000; // A THOUSAND MILLISECONDS.
		var PRESENCE_HB_THRESHOLD = 5;
		var PRESENCE_HB_DEFAULT = 30;
		var SDK_VER = packageJSON.version;
	
		/**
		 * UTILITIES
		 */
		function unique() {
		  return 'x' + ++NOW + '' + (+new Date);
		}
	
		/**
		 * NEXTORIGIN
		 * ==========
		 * var next_origin = nextorigin();
		 */
		var nextorigin = (function () {
		  var max = 20;
		  var ori = Math.floor(Math.random() * max);
		  return function (origin, failover) {
		    return origin.indexOf('pubsub.') > 0
		      && origin.replace(
		        'pubsub', 'ps' + (
		          failover ? utils.generateUUID().split('-')[0] :
		            (++ori < max ? ori : ori = 1)
		        )) || origin;
		  };
		})();
	
	
		/**
		 * Generate Subscription Channel List
		 * ==================================
		 * generate_channel_list(channels_object);
		 */
		function generate_channel_list(channels, nopresence) {
		  var list = [];
		  utils.each(channels, function (channel, status) {
		    if (nopresence) {
		      if (channel.search('-pnpres') < 0) {
		        if (status.subscribed) list.push(channel);
		      }
		    } else {
		      if (status.subscribed) list.push(channel);
		    }
		  });
		  return list.sort();
		}
	
		/**
		 * Generate Subscription Channel Groups List
		 * ==================================
		 * generate_channel_group_list(channels_groups object);
		 */
		function generate_channel_group_list(channel_groups, nopresence) {
		  var list = [];
		  utils.each(channel_groups, function (channel_group, status) {
		    if (nopresence) {
		      if (channel_group.search('-pnpres') < 0) {
		        if (status.subscribed) list.push(channel_group);
		      }
		    } else {
		      if (status.subscribed) list.push(channel_group);
		    }
		  });
		  return list.sort();
		}
	
		// PUBNUB READY TO CONNECT
		function ready() {
		  if (READY) return;
		  READY = 1;
		  utils.each(READY_BUFFER, function (connect) {
		    connect();
		  });
		}
	
		function PNmessage(args) {
		  var msg = args || { apns: {} };
	
		  msg['getPubnubMessage'] = function () {
		    var m = {};
	
		    if (Object.keys(msg['apns']).length) {
		      m['pn_apns'] = {
		        aps: {
		          alert: msg['apns']['alert'],
		          badge: msg['apns']['badge']
		        }
		      };
		      for (var k in msg['apns']) {
		        m['pn_apns'][k] = msg['apns'][k];
		      }
		      var exclude1 = ['badge', 'alert'];
		      for (var k in exclude1) {
		        delete m['pn_apns'][exclude1[k]];
		      }
		    }
	
		    if (msg['gcm']) {
		      m['pn_gcm'] = {
		        data: msg['gcm']
		      };
		    }
	
		    for (var k in msg) {
		      m[k] = msg[k];
		    }
		    var exclude = ['apns', 'gcm', 'publish', 'channel', 'callback', 'error'];
		    for (var k in exclude) {
		      delete m[exclude[k]];
		    }
	
		    return m;
		  };
		  msg['publish'] = function () {
		    var m = msg.getPubnubMessage();
	
		    if (msg['pubnub'] && msg['channel']) {
		      msg['pubnub'].publish({
		        message: m,
		        channel: msg['channel'],
		        callback: msg['callback'],
		        error: msg['error']
		      });
		    }
		  };
		  return msg;
		}
	
		function PN_API(setup) {
		  var SUB_WINDOWING = +setup['windowing'] || DEF_WINDOWING;
		  var SUB_TIMEOUT = (+setup['timeout'] || DEF_SUB_TIMEOUT) * SECOND;
		  var KEEPALIVE = (+setup['keepalive'] || DEF_KEEPALIVE) * SECOND;
		  var TIME_CHECK = setup['timecheck'] || 0;
		  var NOLEAVE = setup['noleave'] || 0;
		  var PUBLISH_KEY = setup['publish_key'];
		  var SUBSCRIBE_KEY = setup['subscribe_key'];
		  var AUTH_KEY = setup['auth_key'] || '';
		  var SECRET_KEY = setup['secret_key'] || '';
		  var hmac_SHA256 = setup['hmac_SHA256'];
		  var SSL = setup['ssl'] ? 's' : '';
		  var ORIGIN = 'http' + SSL + '://' + (setup['origin'] || 'pubsub.pubnub.com');
		  var STD_ORIGIN = nextorigin(ORIGIN);
		  var SUB_ORIGIN = nextorigin(ORIGIN);
		  var CONNECT = function () {
		  };
		  var PUB_QUEUE = [];
		  var CLOAK = true;
		  var TIME_DRIFT = 0;
		  var SUB_CALLBACK = 0;
		  var SUB_CHANNEL = 0;
		  var SUB_RECEIVER = 0;
		  var SUB_RESTORE = setup['restore'] || 0;
		  var SUB_BUFF_WAIT = 0;
		  var TIMETOKEN = 0;
		  var RESUMED = false;
		  var CHANNELS = {};
		  var CHANNEL_GROUPS = {};
		  var SUB_ERROR = function () {
		  };
		  var STATE = {};
		  var PRESENCE_HB_TIMEOUT = null;
		  var PRESENCE_HB = validate_presence_heartbeat(
		    setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']
		  );
		  var PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || (PRESENCE_HB / 2) - 1;
		  var PRESENCE_HB_RUNNING = false;
		  var NO_WAIT_FOR_PENDING = setup['no_wait_for_pending'];
		  var COMPATIBLE_35 = setup['compatible_3.5'] || false;
		  var xdr = setup['xdr'];
		  var params = setup['params'] || {};
		  var error = setup['error'] || function () {};
		  var _is_online = setup['_is_online'] || function () { return 1;};
		  var jsonp_cb = setup['jsonp_cb'] || function () { return 0; };
		  var db = setup['db'] || { get: function () {}, set: function () {} };
		  var CIPHER_KEY = setup['cipher_key'];
		  var UUID = setup['uuid'] || (!setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY + 'uuid') || '');
		  var USE_INSTANCEID = setup['instance_id'] || false;
		  var INSTANCEID = '';
		  var shutdown = setup['shutdown'];
		  var use_send_beacon = (typeof setup['use_send_beacon'] != 'undefined') ? setup['use_send_beacon'] : true;
		  var sendBeacon = (use_send_beacon) ? setup['sendBeacon'] : null;
		  var _poll_timer;
		  var _poll_timer2;
	
		  if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;
	
		  var crypto_obj = setup['crypto_obj'] || {
		    encrypt: function (a, key) {
		      return a;
		    },
		    decrypt: function (b, key) {
		      return b;
		    }
		  };
	
		  function _get_url_params(data) {
		    if (!data) data = {};
		    utils.each(params, function (key, value) {
		      if (!(key in data)) data[key] = value;
		    });
		    return data;
		  }
	
		  function _object_to_key_list(o) {
		    var l = [];
		    utils.each(o, function (key, value) {
		      l.push(key);
		    });
		    return l;
		  }
	
		  function _object_to_key_list_sorted(o) {
		    return _object_to_key_list(o).sort();
		  }
	
		  function _get_pam_sign_input_from_params(params) {
		    var si = '';
		    var l = _object_to_key_list_sorted(params);
	
		    for (var i in l) {
		      var k = l[i];
		      si += k + '=' + utils.pamEncode(params[k]);
		      if (i != l.length - 1) si += '&';
		    }
		    return si;
		  }
	
		  function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {
		    var err = false;
	
		    if (typeof heartbeat === 'undefined') {
		      return cur_heartbeat;
		    }
	
		    if (typeof heartbeat === 'number') {
		      if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0) {
		        err = false;
		      } else {
		        err = true;
		      }
		    } else if (typeof heartbeat === 'boolean') {
		      if (!heartbeat) {
		        return 0;
		      } else {
		        return PRESENCE_HB_DEFAULT;
		      }
		    } else {
		      err = true;
		    }
	
		    if (err) {
		      error && error('Presence Heartbeat value invalid. Valid range ( x > ' + PRESENCE_HB_THRESHOLD + ' or x = 0). Current Value : ' + (cur_heartbeat || PRESENCE_HB_THRESHOLD));
		      return cur_heartbeat || PRESENCE_HB_THRESHOLD;
		    } else return heartbeat;
		  }
	
		  function encrypt(input, key) {
		    return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;
		  }
	
		  function decrypt(input, key) {
		    return crypto_obj['decrypt'](input, key || CIPHER_KEY) ||
		      crypto_obj['decrypt'](input, CIPHER_KEY) ||
		      input;
		  }
	
		  function error_common(message, callback) {
		    callback && callback({ error: message || 'error occurred' });
		    error && error(message);
		  }
	
		  function _presence_heartbeat() {
		    clearTimeout(PRESENCE_HB_TIMEOUT);
	
		    if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 ||
		      PRESENCE_HB_INTERVAL < 1 ||
		      (!generate_channel_list(CHANNELS, true).length && !generate_channel_group_list(CHANNEL_GROUPS, true).length)) {
		      PRESENCE_HB_RUNNING = false;
		      return;
		    }
	
		    PRESENCE_HB_RUNNING = true;
		    SELF['presence_heartbeat']({
		      callback: function (r) {
		        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND);
		      },
		      error: function (e) {
		        error && error('Presence Heartbeat unable to reach Pubnub servers.' + JSON.stringify(e));
		        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND);
		      }
		    });
		  }
	
		  function start_presence_heartbeat() {
		    !PRESENCE_HB_RUNNING && _presence_heartbeat();
		  }
	
		  function publish(next) {
		    if (NO_WAIT_FOR_PENDING) {
		      if (!PUB_QUEUE.length) return;
		    } else {
		      if (next) PUB_QUEUE.sending = 0;
		      if (PUB_QUEUE.sending || !PUB_QUEUE.length) return;
		      PUB_QUEUE.sending = 1;
		    }
	
		    xdr(PUB_QUEUE.shift());
		  }
	
		  function each_channel_group(callback) {
		    var count = 0;
	
		    utils.each(generate_channel_group_list(CHANNEL_GROUPS), function (channel_group) {
		      var chang = CHANNEL_GROUPS[channel_group];
	
		      if (!chang) return;
	
		      count++;
		      (callback || function () {
		      })(chang);
		    });
	
		    return count;
		  }
	
		  function each_channel(callback) {
		    var count = 0;
	
		    utils.each(generate_channel_list(CHANNELS), function (channel) {
		      var chan = CHANNELS[channel];
	
		      if (!chan) return;
	
		      count++;
		      (callback || function () {
		      })(chan);
		    });
	
		    return count;
		  }
	
		  function _invoke_callback(response, callback, err) {
		    if (typeof response == 'object') {
		      if (response['error']) {
		        var callback_data = {};
	
		        if (response['message']) {
		          callback_data['message'] = response['message'];
		        }
	
		        if (response['payload']) {
		          callback_data['payload'] = response['payload'];
		        }
	
		        err && err(callback_data);
		        return;
		      }
		      if (response['payload']) {
		        if (response['next_page']) {
		          callback && callback(response['payload'], response['next_page']);
		        } else {
		          callback && callback(response['payload']);
		        }
		        return;
		      }
		    }
		    callback && callback(response);
		  }
	
		  function _invoke_error(response, err) {
		    if (typeof response == 'object' && response['error']) {
		      var callback_data = {};
	
		      if (response['message']) {
		        callback_data['message'] = response['message'];
		      }
	
		      if (response['payload']) {
		        callback_data['payload'] = response['payload'];
		      }
	
		      err && err(callback_data);
		      return;
		    } else {
		      err && err(response);
		    }
		  }
	
		  function CR(args, callback, url1, data) {
		    var callback = args['callback'] || callback;
		    var err = args['error'] || error;
		    var jsonp = jsonp_cb();
	
		    data = data || {};
	
		    if (!data['auth']) {
		      data['auth'] = args['auth_key'] || AUTH_KEY;
		    }
	
		    var url = [
		      STD_ORIGIN, 'v1', 'channel-registration',
		      'sub-key', SUBSCRIBE_KEY
		    ];
	
		    url.push.apply(url, url1);
	
		    if (jsonp) data['callback'] = jsonp;
	
		    xdr({
		      callback: jsonp,
		      data: _get_url_params(data),
		      success: function (response) {
		        _invoke_callback(response, callback, err);
		      },
		      fail: function (response) {
		        _invoke_error(response, err);
		      },
		      url: url
		    });
		  }
	
		  // Announce Leave Event
		  var SELF = {
		    LEAVE: function (channel, blocking, auth_key, callback, error) {
		      var data = { uuid: UUID, auth: auth_key || AUTH_KEY };
		      var origin = nextorigin(ORIGIN);
		      var callback = callback || function () {};
		      var err = error || function () {};
		      var url;
		      var params;
		      var jsonp = jsonp_cb();
	
		      // Prevent Leaving a Presence Channel
		      if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;
	
	
		      if (COMPATIBLE_35) {
		        if (!SSL) return false;
		        if (jsonp == '0') return false;
		      }
	
		      if (NOLEAVE) return false;
	
		      if (jsonp != '0') data['callback'] = jsonp;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      url = [
		        origin, 'v2', 'presence', 'sub_key',
		        SUBSCRIBE_KEY, 'channel', utils.encode(channel), 'leave'
		      ];
	
		      params = _get_url_params(data);
	
	
		      if (sendBeacon) {
		        var url_string = utils.buildURL(url, params);
		        if (sendBeacon(url_string)) {
		          callback && callback({ status: 200, action: 'leave', message: 'OK', service: 'Presence' });
		          return true;
		        }
		      }
	
	
		      xdr({
		        blocking: blocking || SSL,
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		      return true;
		    },
	
		    LEAVE_GROUP: function (channel_group, blocking, auth_key, callback, error) {
		      var data = { uuid: UUID, auth: auth_key || AUTH_KEY };
		      var origin = nextorigin(ORIGIN);
		      var url;
		      var params;
		      var callback = callback || function () {};
		      var err = error || function () {};
		      var jsonp = jsonp_cb();
	
		      // Prevent Leaving a Presence Channel Group
		      if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;
	
		      if (COMPATIBLE_35) {
		        if (!SSL) return false;
		        if (jsonp == '0') return false;
		      }
	
		      if (NOLEAVE) return false;
	
		      if (jsonp != '0') data['callback'] = jsonp;
	
		      if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      url = [
		        origin, 'v2', 'presence', 'sub_key',
		        SUBSCRIBE_KEY, 'channel', utils.encode(','), 'leave'
		      ];
	
		      params = _get_url_params(data);
	
		      if (sendBeacon) {
		        var url_string = utils.buildURL(url, params);
		        if (sendBeacon(url_string)) {
		          callback && callback({ status: 200, action: 'leave', message: 'OK', service: 'Presence' });
		          return true;
		        }
		      }
	
		      xdr({
		        blocking: blocking || SSL,
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		      return true;
		    },
	
		    set_resumed: function (resumed) {
		      RESUMED = resumed;
		    },
	
		    get_cipher_key: function () {
		      return CIPHER_KEY;
		    },
	
		    set_cipher_key: function (key) {
		      CIPHER_KEY = key;
		    },
	
		    raw_encrypt: function (input, key) {
		      return encrypt(input, key);
		    },
	
		    raw_decrypt: function (input, key) {
		      return decrypt(input, key);
		    },
	
		    get_heartbeat: function () {
		      return PRESENCE_HB;
		    },
	
		    set_heartbeat: function (heartbeat, heartbeat_interval) {
		      PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, error);
		      PRESENCE_HB_INTERVAL = heartbeat_interval || (PRESENCE_HB / 2) - 1;
		      if (PRESENCE_HB == 2) {
		        PRESENCE_HB_INTERVAL = 1;
		      }
		      CONNECT();
		      _presence_heartbeat();
		    },
	
		    get_heartbeat_interval: function () {
		      return PRESENCE_HB_INTERVAL;
		    },
	
		    set_heartbeat_interval: function (heartbeat_interval) {
		      PRESENCE_HB_INTERVAL = heartbeat_interval;
		      _presence_heartbeat();
		    },
	
		    get_version: function () {
		      return SDK_VER;
		    },
	
		    getGcmMessageObject: function (obj) {
		      return {
		        data: obj
		      };
		    },
	
		    getApnsMessageObject: function (obj) {
		      var x = {
		        aps: { badge: 1, alert: '' }
		      };
		      for (var k in obj) {
		        k[x] = obj[k];
		      }
		      return x;
		    },
	
		    _add_param: function (key, val) {
		      params[key] = val;
		    },
	
		    channel_group: function (args, callback) {
		      var ns_ch = args['channel_group'];
		      var callback = callback || args['callback'];
		      var channels = args['channels'] || args['channel'];
		      var cloak = args['cloak'];
		      var namespace;
		      var channel_group;
		      var url = [];
		      var data = {};
		      var mode = args['mode'] || 'add';
	
	
		      if (ns_ch) {
		        var ns_ch_a = ns_ch.split(':');
	
		        if (ns_ch_a.length > 1) {
		          namespace = (ns_ch_a[0] === '*') ? null : ns_ch_a[0];
	
		          channel_group = ns_ch_a[1];
		        } else {
		          channel_group = ns_ch_a[0];
		        }
		      }
	
		      namespace && url.push('namespace') && url.push(utils.encode(namespace));
	
		      url.push('channel-group');
	
		      if (channel_group && channel_group !== '*') {
		        url.push(channel_group);
		      }
	
		      if (channels) {
		        if (utils.isArray(channels)) {
		          channels = channels.join(',');
		        }
		        data[mode] = channels;
		        data['cloak'] = (CLOAK) ? 'true' : 'false';
		      } else {
		        if (mode === 'remove') url.push('remove');
		      }
	
		      if (typeof cloak != 'undefined') data['cloak'] = (cloak) ? 'true' : 'false';
	
		      CR(args, callback, url, data);
		    },
	
		    channel_group_list_groups: function (args, callback) {
		      var namespace;
	
		      namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;
		      if (namespace) {
		        args['channel_group'] = namespace + ':*';
		      }
	
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_list_channels: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_remove_channel: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (!args['channel'] && !args['channels']) return error('Missing Channel');
	
		      args['mode'] = 'remove';
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_remove_group: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (args['channel']) return error('Use channel_group_remove_channel if you want to remove a channel from a group.');
	
		      args['mode'] = 'remove';
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_add_channel: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (!args['channel'] && !args['channels']) return error('Missing Channel');
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_cloak: function (args, callback) {
		      if (typeof args['cloak'] == 'undefined') {
		        callback(CLOAK);
		        return;
		      }
		      CLOAK = args['cloak'];
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_list_namespaces: function (args, callback) {
		      var url = ['namespace'];
		      CR(args, callback, url);
		    },
	
		    channel_group_remove_namespace: function (args, callback) {
		      var url = ['namespace', args['namespace'], 'remove'];
		      CR(args, callback, url);
		    },
	
		    /*
		     PUBNUB.history({
		     channel  : 'my_chat_channel',
		     limit    : 100,
		     callback : function(history) { }
		     });
		     */
		    history: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var count = args['count'] || args['limit'] || 100;
		      var reverse = args['reverse'] || 'false';
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var cipher_key = args['cipher_key'];
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var start = args['start'];
		      var end = args['end'];
		      var include_token = args['include_token'];
		      var string_msg_token = args['string_message_token'] || false;
		      var params = {};
		      var jsonp = jsonp_cb();
	
		      // Make sure we have a Channel
		      if (!channel && !channel_group) return error('Missing Channel');
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      params['stringtoken'] = 'true';
		      params['count'] = count;
		      params['reverse'] = reverse;
		      params['auth'] = auth_key;
	
		      if (channel_group) {
		        params['channel-group'] = channel_group;
		        if (!channel) {
		          channel = ',';
		        }
		      }
		      if (jsonp) params['callback'] = jsonp;
		      if (start) params['start'] = start;
		      if (end) params['end'] = end;
		      if (include_token) params['include_token'] = 'true';
		      if (string_msg_token) params['string_message_token'] = 'true';
	
		      // Send Message
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(params),
		        success: function (response) {
		          if (typeof response == 'object' && response['error']) {
		            err({ message: response['message'], payload: response['payload'] });
		            return;
		          }
		          var messages = response[0];
		          var decrypted_messages = [];
		          for (var a = 0; a < messages.length; a++) {
		            if (include_token) {
		              var new_message = decrypt(messages[a]['message'], cipher_key);
		              var timetoken = messages[a]['timetoken'];
		              try {
		                decrypted_messages['push']({ message: JSON['parse'](new_message), timetoken: timetoken });
		              } catch (e) {
		                decrypted_messages['push'](({ message: new_message, timetoken: timetoken }));
		              }
		            } else {
		              var new_message = decrypt(messages[a], cipher_key);
		              try {
		                decrypted_messages['push'](JSON['parse'](new_message));
		              } catch (e) {
		                decrypted_messages['push']((new_message));
		              }
		            }
		          }
		          callback([decrypted_messages, response[1], response[2]]);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v2', 'history', 'sub-key',
		          SUBSCRIBE_KEY, 'channel', utils.encode(channel)
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.replay({
		     source      : 'my_channel',
		     destination : 'new_channel'
		     });
		     */
		    replay: function (args, callback) {
		      var callback = callback || args['callback'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var source = args['source'];
		      var destination = args['destination'];
		      var err = args['error'] || args['error'] || function () {};
		      var stop = args['stop'];
		      var start = args['start'];
		      var end = args['end'];
		      var reverse = args['reverse'];
		      var limit = args['limit'];
		      var jsonp = jsonp_cb();
		      var data = {};
		      var url;
	
		      // Check User Input
		      if (!source) return error('Missing Source Channel');
		      if (!destination) return error('Missing Destination Channel');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      // Setup URL Params
		      if (jsonp != '0') data['callback'] = jsonp;
		      if (stop) data['stop'] = 'all';
		      if (reverse) data['reverse'] = 'true';
		      if (start) data['start'] = start;
		      if (end) data['end'] = end;
		      if (limit) data['count'] = limit;
	
		      data['auth'] = auth_key;
	
		      // Compose URL Parts
		      url = [
		        STD_ORIGIN, 'v1', 'replay',
		        PUBLISH_KEY, SUBSCRIBE_KEY,
		        source, destination
		      ];
	
		      // Start (or Stop) Replay!
		      xdr({
		        callback: jsonp,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function () {
		          callback([0, 'Disconnected']);
		        },
		        url: url,
		        data: _get_url_params(data)
		      });
		    },
	
		    /*
		     PUBNUB.auth('AJFLKAJSDKLA');
		     */
		    auth: function (auth) {
		      AUTH_KEY = auth;
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.time(function(time){ });
		     */
		    time: function (callback) {
		      var jsonp = jsonp_cb();
	
		      var data = { uuid: UUID, auth: AUTH_KEY };
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        url: [STD_ORIGIN, 'time', jsonp],
		        success: function (response) {
		          callback(response[0]);
		        },
		        fail: function () {
		          callback(0);
		        }
		      });
		    },
	
		    /*
		     PUBNUB.publish({
		     channel : 'my_chat_channel',
		     message : 'hello!'
		     });
		     */
		    publish: function (args, callback) {
		      var msg = args['message'];
		      if (!msg) return error('Missing Message');
	
		      var callback = callback || args['callback'] || msg['callback'] || args['success'] || function () {};
		      var channel = args['channel'] || msg['channel'];
		      var meta = args['meta'] || args['metadata'];
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var cipher_key = args['cipher_key'];
		      var err = args['error'] || msg['error'] || function () {};
		      var post = args['post'] || false;
		      var store = ('store_in_history' in args) ? args['store_in_history'] : true;
		      var replicate = ('replicate' in args) ? args['replicate'] : true;
		      var jsonp = jsonp_cb();
		      var add_msg = 'push';
		      var params;
		      var url;
	
		      if (args['prepend']) add_msg = 'unshift';
	
		      if (!channel) return error('Missing Channel');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (msg['getPubnubMessage']) {
		        msg = msg['getPubnubMessage']();
		      }
	
		      // If trying to send Object
		      msg = JSON['stringify'](encrypt(msg, cipher_key));
	
		      // Create URL
		      url = [
		        STD_ORIGIN, 'publish',
		        PUBLISH_KEY, SUBSCRIBE_KEY,
		        0, utils.encode(channel),
		        jsonp, utils.encode(msg)
		      ];
	
		      params = { uuid: UUID, auth: auth_key };
	
		      if (meta && typeof meta === 'object') {
		        params['meta'] = JSON.stringify(meta);
		      }
	
		      if (!store) params['store'] = '0';
		      if (!replicate) params['norep'] = 'true';
	
		      if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;
	
		      // Queue Message Send
		      PUB_QUEUE[add_msg]({
		        callback: jsonp,
		        url: url,
		        data: _get_url_params(params),
		        fail: function (response) {
		          _invoke_error(response, err);
		          publish(1);
		        },
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		          publish(1);
		        },
		        mode: (post) ? 'POST' : 'GET'
		      });
	
		      // Send Message
		      publish();
		    },
	
		    fire: function (args, callback) {
		      args.store_in_history = false;
		      args.replicate = false;
		      SELF['publish'](args, callback);
		    },
	
		    /*
		     PUBNUB.unsubscribe({ channel : 'my_chat' });
		     */
		    unsubscribe: function (args, callback) {
		      var channelArg = args['channel'];
		      var channelGroupArg = args['channel_group'];
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var callback = callback || args['callback'] || function () {};
		      var err = args['error'] || function () {};
	
		      if (!channelArg && !channelGroupArg) return error('Missing Channel or Channel Group');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (channelArg) {
		        var channels = utils.isArray(channelArg) ? channelArg : ('' + channelArg).split(',');
		        var existingChannels = [];
		        var presenceChannels = [];
	
		        utils.each(channels, function (channel) {
		          if (CHANNELS[channel]) existingChannels.push(channel);
		        });
	
		        // if we do not have any channels to unsubscribe from, trigger a callback.
		        if (existingChannels.length == 0) {
		          callback({ action: 'leave' });
		          return;
		        }
	
		        // Prepare presence channels
		        utils.each(existingChannels, function (channel) {
		          presenceChannels.push(channel + PRESENCE_SUFFIX);
		        });
	
		        utils.each(existingChannels.concat(presenceChannels), function (channel) {
		          if (channel in CHANNELS) delete CHANNELS[channel];
		          if (channel in STATE) delete STATE[channel];
		        });
	
		        if (CHANNELS.length === 0 && CHANNEL_GROUPS.length === 0) {
		          TIMETOKEN = 0;
		        }
	
		        var CB_CALLED = true;
		        if (READY) {
		          CB_CALLED = SELF['LEAVE'](existingChannels.join(','), 0, auth_key, callback, err);
		        }
		        if (!CB_CALLED) callback({ action: 'leave' });
		      }
	
		      if (channelGroupArg) {
		        var channelGroups = utils.isArray(channelGroupArg) ? channelGroupArg : ('' + channelGroupArg).split(',');
		        var existingChannelGroups = [];
		        var presenceChannelGroups = [];
	
		        utils.each(channelGroups, function (channelGroup) {
		          if (CHANNEL_GROUPS[channelGroup]) existingChannelGroups.push(channelGroup);
		        });
	
		        // if we do not have any channel groups to unsubscribe from, trigger a callback.
		        if (existingChannelGroups.length == 0) {
		          callback({ action: 'leave' });
		          return;
		        }
	
		        // Prepare presence channels
		        utils.each(existingChannelGroups, function (channelGroup) {
		          presenceChannelGroups.push(channelGroup + PRESENCE_SUFFIX);
		        });
	
		        utils.each(existingChannelGroups.concat(presenceChannelGroups), function (channelGroup) {
		          if (channelGroup in CHANNEL_GROUPS) delete CHANNEL_GROUPS[channelGroup];
		          if (channelGroup in STATE) delete STATE[channelGroup];
		        });
	
		        if (CHANNELS.length === 0 && CHANNEL_GROUPS.length === 0) {
		          TIMETOKEN = 0;
		        }
	
		        var CB_CALLED = true;
		        if (READY) {
		          CB_CALLED = SELF['LEAVE_GROUP'](existingChannelGroups.join(','), 0, auth_key, callback, err);
		        }
		        if (!CB_CALLED) callback({ action: 'leave' });
		      }
	
		      // Reset Connection if Count Less
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.subscribe({
		     channel  : 'my_chat'
		     callback : function(message) { }
		     });
		     */
		    subscribe: function (args, callback) {
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var callback = callback || args['callback'];
		      var callback = callback || args['message'];
		      var connect = args['connect'] || function () {};
		      var reconnect = args['reconnect'] || function () {};
		      var disconnect = args['disconnect'] || function () {};
		      var SUB_ERROR = args['error'] || SUB_ERROR || function () {};
		      var idlecb = args['idle'] || function () {};
		      var presence = args['presence'] || 0;
		      var noheresync = args['noheresync'] || 0;
		      var backfill = args['backfill'] || 0;
		      var timetoken = args['timetoken'] || 0;
		      var sub_timeout = args['timeout'] || SUB_TIMEOUT;
		      var windowing = args['windowing'] || SUB_WINDOWING;
		      var state = args['state'];
		      var heartbeat = args['heartbeat'] || args['pnexpires'];
		      var heartbeat_interval = args['heartbeat_interval'];
		      var restore = args['restore'] || SUB_RESTORE;
	
		      AUTH_KEY = args['auth_key'] || AUTH_KEY;
	
		      // Restore Enabled?
		      SUB_RESTORE = restore;
	
		      // Always Reset the TT
		      TIMETOKEN = timetoken;
	
		      // Make sure we have a Channel
		      if (!channel && !channel_group) {
		        return error('Missing Channel');
		      }
	
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {
		        SELF['set_heartbeat'](heartbeat, heartbeat_interval);
		      }
	
		      // Setup Channel(s)
		      if (channel) {
		        utils.each((channel.join ? channel.join(',') : '' + channel).split(','),
		          function (channel) {
		            var settings = CHANNELS[channel] || {};
	
		            // Store Channel State
		            CHANNELS[SUB_CHANNEL = channel] = {
		              name: channel,
		              connected: settings.connected,
		              disconnected: settings.disconnected,
		              subscribed: 1,
		              callback: SUB_CALLBACK = callback,
		              cipher_key: args['cipher_key'],
		              connect: connect,
		              disconnect: disconnect,
		              reconnect: reconnect
		            };
	
		            if (state) {
		              if (channel in state) {
		                STATE[channel] = state[channel];
		              } else {
		                STATE[channel] = state;
		              }
		            }
	
		            // Presence Enabled?
		            if (!presence) return;
	
		            // Subscribe Presence Channel
		            SELF['subscribe']({
		              channel: channel + PRESENCE_SUFFIX,
		              callback: presence,
		              restore: restore
		            });
	
		            // Presence Subscribed?
		            if (settings.subscribed) return;
	
		            // See Who's Here Now?
		            if (noheresync) return;
		            SELF['here_now']({
		              channel: channel,
		              data: _get_url_params({ uuid: UUID, auth: AUTH_KEY }),
		              callback: function (here) {
		                utils.each('uuids' in here ? here['uuids'] : [], function (uid) {
		                  presence({
		                    action: 'join',
		                    uuid: uid,
		                    timestamp: Math.floor(utils.rnow() / 1000),
		                    occupancy: here['occupancy'] || 1
		                  }, here, channel);
		                });
		              }
		            });
		          });
		      }
	
		      // Setup Channel Groups
		      if (channel_group) {
		        utils.each((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','),
		          function (channel_group) {
		            var settings = CHANNEL_GROUPS[channel_group] || {};
	
		            CHANNEL_GROUPS[channel_group] = {
		              name: channel_group,
		              connected: settings.connected,
		              disconnected: settings.disconnected,
		              subscribed: 1,
		              callback: SUB_CALLBACK = callback,
		              cipher_key: args['cipher_key'],
		              connect: connect,
		              disconnect: disconnect,
		              reconnect: reconnect
		            };
	
		            // Presence Enabled?
		            if (!presence) return;
	
		            // Subscribe Presence Channel
		            SELF['subscribe']({
		              channel_group: channel_group + PRESENCE_SUFFIX,
		              callback: presence,
		              restore: restore,
		              auth_key: AUTH_KEY
		            });
	
		            // Presence Subscribed?
		            if (settings.subscribed) return;
	
		            // See Who's Here Now?
		            if (noheresync) return;
		            SELF['here_now']({
		              channel_group: channel_group,
		              data: _get_url_params({ uuid: UUID, auth: AUTH_KEY }),
		              callback: function (here) {
		                utils.each('uuids' in here ? here['uuids'] : [], function (uid) {
		                  presence({
		                    action: 'join',
		                    uuid: uid,
		                    timestamp: Math.floor(utils.rnow() / 1000),
		                    occupancy: here['occupancy'] || 1
		                  }, here, channel_group);
		                });
		              }
		            });
		          });
		      }
	
	
		      // Test Network Connection
		      function _test_connection(success) {
		        if (success) {
		          // Begin Next Socket Connection
		          utils.timeout(CONNECT, windowing);
		        } else {
		          // New Origin on Failed Connection
		          STD_ORIGIN = nextorigin(ORIGIN, 1);
		          SUB_ORIGIN = nextorigin(ORIGIN, 1);
	
		          // Re-test Connection
		          utils.timeout(function () {
		            SELF['time'](_test_connection);
		          }, SECOND);
		        }
	
		        // Disconnect & Reconnect
		        each_channel(function (channel) {
		          // Reconnect
		          if (success && channel.disconnected) {
		            channel.disconnected = 0;
		            return channel.reconnect(channel.name);
		          }
	
		          // Disconnect
		          if (!success && !channel.disconnected) {
		            channel.disconnected = 1;
		            channel.disconnect(channel.name);
		          }
		        });
	
		        // Disconnect & Reconnect for channel groups
		        each_channel_group(function (channel_group) {
		          // Reconnect
		          if (success && channel_group.disconnected) {
		            channel_group.disconnected = 0;
		            return channel_group.reconnect(channel_group.name);
		          }
	
		          // Disconnect
		          if (!success && !channel_group.disconnected) {
		            channel_group.disconnected = 1;
		            channel_group.disconnect(channel_group.name);
		          }
		        });
		      }
	
		      // Evented Subscribe
		      function _connect() {
		        var jsonp = jsonp_cb();
		        var channels = generate_channel_list(CHANNELS).join(',');
		        var channel_groups = generate_channel_group_list(CHANNEL_GROUPS).join(',');
	
		        // Stop Connection
		        if (!channels && !channel_groups) return;
	
		        if (!channels) channels = ',';
	
		        // Connect to PubNub Subscribe Servers
		        _reset_offline();
	
		        var data = _get_url_params({ uuid: UUID, auth: AUTH_KEY });
	
		        if (channel_groups) {
		          data['channel-group'] = channel_groups;
		        }
	
	
		        var st = JSON.stringify(STATE);
		        if (st.length > 2) data['state'] = JSON.stringify(STATE);
	
		        if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;
	
		        if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		        start_presence_heartbeat();
		        SUB_RECEIVER = xdr({
		          timeout: sub_timeout,
		          callback: jsonp,
		          fail: function (response) {
		            if (response && response['error'] && response['service']) {
		              _invoke_error(response, SUB_ERROR);
		              _test_connection(false);
		            } else {
		              SELF['time'](function (success) {
		                !success && (_invoke_error(response, SUB_ERROR));
		                _test_connection(success);
		              });
		            }
		          },
		          data: _get_url_params(data),
		          url: [
		            SUB_ORIGIN, 'subscribe',
		            SUBSCRIBE_KEY, utils.encode(channels),
		            jsonp, TIMETOKEN
		          ],
		          success: function (messages) {
		            // Check for Errors
		            if (!messages || (typeof messages == 'object' && 'error' in messages && messages['error'])) {
		              SUB_ERROR(messages);
		              return utils.timeout(CONNECT, SECOND);
		            }
	
		            // User Idle Callback
		            idlecb(messages[1]);
	
		            // Restore Previous Connection Point if Needed
		            TIMETOKEN = !TIMETOKEN && SUB_RESTORE && db['get'](SUBSCRIBE_KEY) || messages[1];
	
		            /*
		             // Connect
		             each_channel_registry(function(registry){
		             if (registry.connected) return;
		             registry.connected = 1;
		             registry.connect(channel.name);
		             });
		             */
	
		            // Connect
		            each_channel(function (channel) {
		              if (channel.connected) return;
		              channel.connected = 1;
		              channel.connect(channel.name);
		            });
	
		            // Connect for channel groups
		            each_channel_group(function (channel_group) {
		              if (channel_group.connected) return;
		              channel_group.connected = 1;
		              channel_group.connect(channel_group.name);
		            });
	
		            if (RESUMED && !SUB_RESTORE) {
		              TIMETOKEN = 0;
		              RESUMED = false;
		              // Update Saved Timetoken
		              db['set'](SUBSCRIBE_KEY, 0);
		              utils.timeout(_connect, windowing);
		              return;
		            }
	
		            // Invoke Memory Catchup and Receive Up to 100
		            // Previous Messages from the Queue.
		            if (backfill) {
		              TIMETOKEN = 10000;
		              backfill = 0;
		            }
	
		            // Update Saved Timetoken
		            db['set'](SUBSCRIBE_KEY, messages[1]);
	
		            // Route Channel <---> Callback for Message
		            var next_callback = (function () {
		              var channels = '';
		              var channels2 = '';
	
		              if (messages.length > 3) {
		                channels = messages[3];
		                channels2 = messages[2];
		              } else if (messages.length > 2) {
		                channels = messages[2];
		              } else {
		                channels = utils.map(
		                  generate_channel_list(CHANNELS), function (chan) {
		                    return utils.map(
		                      Array(messages[0].length)
		                        .join(',').split(','),
		                      function () {
		                        return chan;
		                      }
		                    );
		                  }).join(',');
		              }
	
		              var list = channels.split(',');
		              var list2 = (channels2) ? channels2.split(',') : [];
	
		              return function () {
		                var channel = list.shift() || SUB_CHANNEL;
		                var channel2 = list2.shift();
	
		                var chobj = {};
	
		                if (channel2) {
		                  if (channel && channel.indexOf('-pnpres') >= 0
		                    && channel2.indexOf('-pnpres') < 0) {
		                    channel2 += '-pnpres';
		                  }
		                  chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || { callback: function () {} };
		                } else {
		                  chobj = CHANNELS[channel];
		                }
	
		                var r = [
		                  chobj
		                    .callback || SUB_CALLBACK,
		                  channel.split(PRESENCE_SUFFIX)[0]
		                ];
		                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);
		                return r;
		              };
		            })();
	
		            var latency = detect_latency(+messages[1]);
		            utils.each(messages[0], function (msg) {
		              var next = next_callback();
		              var decrypted_msg = decrypt(msg,
		                (CHANNELS[next[1]]) ? CHANNELS[next[1]]['cipher_key'] : null);
		              next[0] && next[0](decrypted_msg, messages, next[2] || next[1], latency, next[1]);
		            });
	
		            utils.timeout(_connect, windowing);
		          }
		        });
		      }
	
		      CONNECT = function () {
		        _reset_offline();
		        utils.timeout(_connect, windowing);
		      };
	
		      // Reduce Status Flicker
		      if (!READY) return READY_BUFFER.push(CONNECT);
	
		      // Connect Now
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.here_now({ channel : 'my_chat', callback : fun });
		     */
		    here_now: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var debug = args['debug'];
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var jsonp = jsonp_cb();
		      var uuids = ('uuids' in args) ? args['uuids'] : true;
		      var state = args['state'];
		      var data = { uuid: UUID, auth: auth_key };
	
		      if (!uuids) data['disable_uuids'] = 1;
		      if (state) data['state'] = 1;
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      var url = [
		        STD_ORIGIN, 'v2', 'presence',
		        'sub_key', SUBSCRIBE_KEY
		      ];
	
		      channel && url.push('channel') && url.push(utils.encode(channel));
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (channel_group) {
		        data['channel-group'] = channel_group;
		        !channel && url.push('channel') && url.push(',');
		      }
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        debug: debug,
		        url: url
		      });
		    },
	
		    /*
		     PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });
		     */
		    where_now: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var jsonp = jsonp_cb();
		      var uuid = args['uuid'] || UUID;
		      var data = { auth: auth_key };
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub_key', SUBSCRIBE_KEY,
		          'uuid', utils.encode(uuid)
		        ]
		      });
		    },
	
		    state: function (args, callback) {
		      var callback = args['callback'] || callback || function (r) {};
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var jsonp = jsonp_cb();
		      var state = args['state'];
		      var uuid = args['uuid'] || UUID;
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var url;
		      var data = _get_url_params({ auth: auth_key });
	
		      // Make sure we have a Channel
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!uuid) return error('Missing UUID');
		      if (!channel && !channel_group) return error('Missing Channel');
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (typeof channel != 'undefined'
		        && CHANNELS[channel] && CHANNELS[channel].subscribed) {
		        if (state) STATE[channel] = state;
		      }
	
		      if (typeof channel_group != 'undefined'
		        && CHANNEL_GROUPS[channel_group]
		        && CHANNEL_GROUPS[channel_group].subscribed
		      ) {
		        if (state) STATE[channel_group] = state;
		        data['channel-group'] = channel_group;
	
		        if (!channel) {
		          channel = ',';
		        }
		      }
	
		      data['state'] = JSON.stringify(state);
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      if (state) {
		        url = [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channel,
		          'uuid', uuid, 'data'
		        ];
		      } else {
		        url = [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channel,
		          'uuid', utils.encode(uuid)
		        ];
		      }
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
	
		      });
		    },
	
		    /*
		     PUBNUB.grant({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     ttl      : 24 * 60, // Minutes
		     read     : true,
		     write    : true,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    grant: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var channel = args['channel'] || args['channels'];
		      var channel_group = args['channel_group'];
		      var jsonp = jsonp_cb();
		      var ttl = args['ttl'];
		      var r = (args['read']) ? '1' : '0';
		      var w = (args['write']) ? '1' : '0';
		      var m = (args['manage']) ? '1' : '0';
		      var auth_key = args['auth_key'] || args['auth_keys'];
	
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SECRET_KEY) return error('Missing Secret Key');
	
		      var timestamp = Math.floor(new Date().getTime() / 1000);
		      var sign_input = SUBSCRIBE_KEY + '\n' + PUBLISH_KEY + '\n' + 'grant' + '\n';
	
		      var data = { w: w, r: r, timestamp: timestamp };
	
		      if (args['manage']) {
		        data['m'] = m;
		      }
		      if (utils.isArray(channel)) {
		        channel = channel['join'](',');
		      }
		      if (utils.isArray(auth_key)) {
		        auth_key = auth_key['join'](',');
		      }
		      if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;
		      if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {
		        data['channel-group'] = channel_group;
		      }
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
		      if (ttl || ttl === 0) data['ttl'] = ttl;
	
		      if (auth_key) data['auth'] = auth_key;
	
		      data = _get_url_params(data);
	
		      if (!auth_key) delete data['auth'];
	
		      sign_input += _get_pam_sign_input_from_params(data);
	
		      var signature = hmac_SHA256(sign_input, SECRET_KEY);
	
		      signature = signature.replace(/\+/g, '-');
		      signature = signature.replace(/\//g, '_');
	
		      data['signature'] = signature;
	
		      xdr({
		        callback: jsonp,
		        data: data,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v1', 'auth', 'grant',
		          'sub-key', SUBSCRIBE_KEY
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.mobile_gw_provision ({
		     device_id: 'A655FBA9931AB',
		     op       : 'add' | 'remove',
		     gw_type  : 'apns' | 'gcm',
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     });
		     */
	
		    mobile_gw_provision: function (args) {
		      var callback = args['callback'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var err = args['error'] || function () {};
		      var jsonp = jsonp_cb();
		      var channel = args['channel'];
		      var op = args['op'];
		      var gw_type = args['gw_type'];
		      var device_id = args['device_id'];
		      var params;
		      var url;
	
		      if (!device_id) return error('Missing Device ID (device_id)');
		      if (!gw_type) return error('Missing GW Type (gw_type: gcm or apns)');
		      if (!op) return error('Missing GW Operation (op: add or remove)');
		      if (!channel) return error('Missing gw destination Channel (channel)');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      // Create URL
		      url = [
		        STD_ORIGIN, 'v1/push/sub-key',
		        SUBSCRIBE_KEY, 'devices', device_id
		      ];
	
		      params = { uuid: UUID, auth: auth_key, type: gw_type };
	
		      if (op == 'add') {
		        params['add'] = channel;
		      } else if (op == 'remove') {
		        params['remove'] = channel;
		      }
	
		      if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		    },
	
		    /*
		     PUBNUB.audit({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     read     : true,
		     write    : true,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    audit: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var auth_key = args['auth_key'];
		      var jsonp = jsonp_cb();
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SECRET_KEY) return error('Missing Secret Key');
	
		      var timestamp = Math.floor(new Date().getTime() / 1000);
		      var sign_input = SUBSCRIBE_KEY + '\n' + PUBLISH_KEY + '\n' + 'audit' + '\n';
	
		      var data = { timestamp: timestamp };
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
		      if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;
		      if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {
		        data['channel-group'] = channel_group;
		      }
		      if (auth_key) data['auth'] = auth_key;
	
		      data = _get_url_params(data);
	
		      if (!auth_key) delete data['auth'];
	
		      sign_input += _get_pam_sign_input_from_params(data);
	
		      var signature = hmac_SHA256(sign_input, SECRET_KEY);
	
		      signature = signature.replace(/\+/g, '-');
		      signature = signature.replace(/\//g, '_');
	
		      data['signature'] = signature;
		      xdr({
		        callback: jsonp,
		        data: data,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v1', 'auth', 'audit',
		          'sub-key', SUBSCRIBE_KEY
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.revoke({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    revoke: function (args, callback) {
		      args['read'] = false;
		      args['write'] = false;
		      SELF['grant'](args, callback);
		    },
	
		    set_uuid: function (uuid) {
		      UUID = uuid;
		      CONNECT();
		    },
	
		    get_uuid: function () {
		      return UUID;
		    },
	
		    isArray: function (arg) {
		      return utils.isArray(arg);
		    },
	
		    get_subscribed_channels: function () {
		      return generate_channel_list(CHANNELS, true);
		    },
	
		    presence_heartbeat: function (args) {
		      var callback = args['callback'] || function () {};
		      var err = args['error'] || function () {};
		      var jsonp = jsonp_cb();
		      var data = { uuid: UUID, auth: AUTH_KEY };
	
		      var st = JSON['stringify'](STATE);
		      if (st.length > 2) data['state'] = JSON['stringify'](STATE);
	
		      if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      var channels = utils.encode(generate_channel_list(CHANNELS, true)['join'](','));
		      var channel_groups = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');
	
		      if (!channels) channels = ',';
		      if (channel_groups) data['channel-group'] = channel_groups;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        url: [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channels,
		          'heartbeat'
		        ],
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        }
		      });
		    },
	
		    stop_timers: function () {
		      clearTimeout(_poll_timer);
		      clearTimeout(_poll_timer2);
		      clearTimeout(PRESENCE_HB_TIMEOUT);
		    },
	
		    shutdown: function () {
		      SELF['stop_timers']();
		      shutdown && shutdown();
		    },
	
		    // Expose PUBNUB Functions
		    xdr: xdr,
		    ready: ready,
		    db: db,
		    uuid: utils.generateUUID,
		    map: utils.map,
		    each: utils.each,
		    'each-channel': each_channel,
		    grep: utils.grep,
		    offline: function () {
		      _reset_offline(1, { message: 'Offline. Please check your network settings.' });
		    },
		    supplant: utils.supplant,
		    now: utils.rnow,
		    unique: unique,
		    updater: utils.updater
		  };
	
		  function _poll_online() {
		    _is_online() || _reset_offline(1, { error: 'Offline. Please check your network settings.' });
		    _poll_timer && clearTimeout(_poll_timer);
		    _poll_timer = utils.timeout(_poll_online, SECOND);
		  }
	
		  function _poll_online2() {
		    if (!TIME_CHECK) return;
		    SELF['time'](function (success) {
		      detect_time_detla(function () {
		      }, success);
		      success || _reset_offline(1, {
		        error: 'Heartbeat failed to connect to Pubnub Servers.' +
		        'Please check your network settings.'
		      });
		      _poll_timer2 && clearTimeout(_poll_timer2);
		      _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE);
		    });
		  }
	
		  function _reset_offline(err, msg) {
		    SUB_RECEIVER && SUB_RECEIVER(err, msg);
		    SUB_RECEIVER = null;
	
		    clearTimeout(_poll_timer);
		    clearTimeout(_poll_timer2);
		  }
	
		  if (!UUID) UUID = SELF['uuid']();
		  if (!INSTANCEID) INSTANCEID = SELF['uuid']();
		  db['set'](SUBSCRIBE_KEY + 'uuid', UUID);
	
		  _poll_timer = utils.timeout(_poll_online, SECOND);
		  _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE);
		  PRESENCE_HB_TIMEOUT = utils.timeout(
		    start_presence_heartbeat,
		    (PRESENCE_HB_INTERVAL - 3) * SECOND
		  );
	
		  // Detect Age of Message
		  function detect_latency(tt) {
		    var adjusted_time = utils.rnow() - TIME_DRIFT;
		    return adjusted_time - tt / 10000;
		  }
	
		  detect_time_detla();
		  function detect_time_detla(cb, time) {
		    var stime = utils.rnow();
	
		    time && calculate(time) || SELF['time'](calculate);
	
		    function calculate(time) {
		      if (!time) return;
		      var ptime = time / 10000;
		      var latency = (utils.rnow() - stime) / 2;
		      TIME_DRIFT = utils.rnow() - (ptime + latency);
		      cb && cb(TIME_DRIFT);
		    }
		  }
	
		  return SELF;
		}
	
		module.exports = {
		  PN_API: PN_API,
		  unique: unique,
		  PNmessage: PNmessage,
		  DEF_TIMEOUT: DEF_TIMEOUT,
		  timeout: utils.timeout,
		  build_url: utils.buildURL,
		  each: utils.each,
		  uuid: utils.generateUUID,
		  URLBIT: defaultConfiguration.URLBIT,
		  grep: utils.grep,
		  supplant: utils.supplant,
		  now: utils.rnow,
		  updater: utils.updater,
		  map: utils.map
		};
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		module.exports = {
			"PARAMSBIT": "&",
			"URLBIT": "/"
		};
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint no-unused-expressions: 0, block-scoped-var: 0, no-redeclare: 0, guard-for-in: 0 */
	
		var defaultConfiguration = __webpack_require__(3);
		var REPL = /{([\w\-]+)}/g;
	
		function rnow() {
		  return +new Date;
		}
	
		function isArray(arg) {
		  return !!arg && typeof arg !== 'string' && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === 'number');
		  // return !!arg && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === "number")
		}
	
		/**
		 * EACH
		 * ====
		 * each( [1,2,3], function(item) { } )
		 */
		function each(o, f) {
		  if (!o || !f) {
		    return;
		  }
	
		  if (isArray(o)) {
		    for (var i = 0, l = o.length; i < l;) {
		      f.call(o[i], o[i], i++);
		    }
		  } else {
		    for (var i in o) {
		      o.hasOwnProperty &&
		      o.hasOwnProperty(i) &&
		      f.call(o[i], i, o[i]);
		    }
		  }
		}
	
		/**
		 * ENCODE
		 * ======
		 * var encoded_data = encode('path');
		 */
		function encode(path) { return encodeURIComponent(path); }
	
		/**
		 * Build Url
		 * =======
		 *
		 */
		function buildURL(urlComponents, urlParams) {
		  var url = urlComponents.join(defaultConfiguration.URLBIT);
		  var params = [];
	
		  if (!urlParams) return url;
	
		  each(urlParams, function (key, value) {
		    var valueStr = (typeof value === 'object') ? JSON['stringify'](value) : value;
		    (typeof value !== 'undefined' &&
		      value !== null && encode(valueStr).length > 0
		    ) && params.push(key + '=' + encode(valueStr));
		  });
	
		  url += '?' + params.join(defaultConfiguration.PARAMSBIT);
		  return url;
		}
	
		/**
		 * UPDATER
		 * =======
		 * var timestamp = unique();
		 */
		function updater(fun, rate) {
		  var timeout;
		  var last = 0;
		  var runnit = function () {
		    if (last + rate > rnow()) {
		      clearTimeout(timeout);
		      timeout = setTimeout(runnit, rate);
		    } else {
		      last = rnow();
		      fun();
		    }
		  };
	
		  return runnit;
		}
	
		/**
		 * GREP
		 * ====
		 * var list = grep( [1,2,3], function(item) { return item % 2 } )
		 */
		function grep(list, fun) {
		  var fin = [];
		  each(list || [], function (l) {
		    fun(l) && fin.push(l);
		  });
		  return fin;
		}
	
		/**
		 * SUPPLANT
		 * ========
		 * var text = supplant( 'Hello {name}!', { name : 'John' } )
		 */
		function supplant(str, values) {
		  return str.replace(REPL, function (_, match) {
		    return values[match] || _;
		  });
		}
	
		/**
		 * timeout
		 * =======
		 * timeout( function(){}, 100 );
		 */
		function timeout(fun, wait) {
		  if (typeof setTimeout === 'undefined') {
		    return;
		  }
	
		  return setTimeout(fun, wait);
		}
	
		/**
		 * uuid
		 * ====
		 * var my_uuid = generateUUID();
		 */
		function generateUUID(callback) {
		  var u = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,
		    function (c) {
		      var r = Math.random() * 16 | 0;
		      var v = c === 'x' ? r : (r & 0x3 | 0x8);
		      return v.toString(16);
		    });
		  if (callback) callback(u);
		  return u;
		}
	
		/**
		 * MAP
		 * ===
		 * var list = map( [1,2,3], function(item) { return item + 1 } )
		 */
		function map(list, fun) {
		  var fin = [];
		  each(list || [], function (k, v) {
		    fin.push(fun(k, v));
		  });
		  return fin;
		}
	
	
		function pamEncode(str) {
		  return encodeURIComponent(str).replace(/[!'()*~]/g, function (c) {
		    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		  });
		}
	
	
		module.exports = {
		  buildURL: buildURL,
		  encode: encode,
		  each: each,
		  updater: updater,
		  rnow: rnow,
		  isArray: isArray,
		  map: map,
		  pamEncode: pamEncode,
		  generateUUID: generateUUID,
		  timeout: timeout,
		  supplant: supplant,
		  grep: grep
		};
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint camelcase: 0 eqeqeq: 0 */
	
		var CryptoJS = __webpack_require__(6);
	
		function crypto_obj() {
		  function SHA256(s) {
		    return CryptoJS['SHA256'](s)['toString'](CryptoJS['enc']['Hex']);
		  }
	
		  var iv = '0123456789012345';
	
		  var allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];
		  var allowedKeyLengths = [128, 256];
		  var allowedModes = ['ecb', 'cbc'];
	
		  var defaultOptions = {
		    encryptKey: true,
		    keyEncoding: 'utf8',
		    keyLength: 256,
		    mode: 'cbc'
		  };
	
		  function parse_options(options) {
		    // Defaults
		    options = options || {};
		    if (!options['hasOwnProperty']('encryptKey')) options['encryptKey'] = defaultOptions['encryptKey'];
		    if (!options['hasOwnProperty']('keyEncoding')) options['keyEncoding'] = defaultOptions['keyEncoding'];
		    if (!options['hasOwnProperty']('keyLength')) options['keyLength'] = defaultOptions['keyLength'];
		    if (!options['hasOwnProperty']('mode')) options['mode'] = defaultOptions['mode'];
	
		    // Validation
		    if (allowedKeyEncodings['indexOf'](options['keyEncoding']['toLowerCase']()) == -1) options['keyEncoding'] = defaultOptions['keyEncoding'];
		    if (allowedKeyLengths['indexOf'](parseInt(options['keyLength'], 10)) == -1) options['keyLength'] = defaultOptions['keyLength'];
		    if (allowedModes['indexOf'](options['mode']['toLowerCase']()) == -1) options['mode'] = defaultOptions['mode'];
	
		    return options;
		  }
	
		  function decode_key(key, options) {
		    if (options['keyEncoding'] === 'base64') {
		      return CryptoJS['enc']['Base64']['parse'](key);
		    } else if (options['keyEncoding'] === 'hex') {
		      return CryptoJS['enc']['Hex']['parse'](key);
		    } else {
		      return key;
		    }
		  }
	
		  function get_padded_key(key, options) {
		    key = decode_key(key, options);
		    if (options['encryptKey']) {
		      return CryptoJS['enc']['Utf8']['parse'](SHA256(key)['slice'](0, 32));
		    } else {
		      return key;
		    }
		  }
	
		  function get_mode(options) {
		    if (options['mode'] === 'ecb') {
		      return CryptoJS['mode']['ECB'];
		    } else {
		      return CryptoJS['mode']['CBC'];
		    }
		  }
	
		  function get_iv(options) {
		    return (options['mode'] === 'cbc') ? CryptoJS['enc']['Utf8']['parse'](iv) : null;
		  }
	
		  return {
		    encrypt: function (data, key, options) {
		      if (!key) return data;
		      options = parse_options(options);
		      var iv = get_iv(options);
		      var mode = get_mode(options);
		      var cipher_key = get_padded_key(key, options);
		      var hex_message = JSON['stringify'](data);
		      var encryptedHexArray = CryptoJS['AES']['encrypt'](hex_message, cipher_key, { iv: iv, mode: mode })['ciphertext'];
		      var base_64_encrypted = encryptedHexArray['toString'](CryptoJS['enc']['Base64']);
		      return base_64_encrypted || data;
		    },
	
		    decrypt: function (data, key, options) {
		      if (!key) return data;
		      options = parse_options(options);
		      var iv = get_iv(options);
		      var mode = get_mode(options);
		      var cipher_key = get_padded_key(key, options);
		      try {
		        var binary_enc = CryptoJS['enc']['Base64']['parse'](data);
		        var json_plain = CryptoJS['AES']['decrypt']({ ciphertext: binary_enc }, cipher_key, { iv: iv, mode: mode })['toString'](CryptoJS['enc']['Utf8']);
		        var plaintext = JSON['parse'](json_plain);
		        return plaintext;
		      } catch (e) {
		        return undefined;
		      }
		    }
		  };
		}
	
		module.exports = crypto_obj;
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
		/*
		 CryptoJS v3.1.2
		 code.google.com/p/crypto-js
		 (c) 2009-2013 by Jeff Mott. All rights reserved.
		 code.google.com/p/crypto-js/wiki/License
		 */
		var CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
		    r=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
		      32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
		        2),16)<<24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},
		    u=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);
		      a._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,
		    d)).finalize(c)}}});var t=f.algo={};return f}(Math);
	
		// SHA256
		(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64>n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t<=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64>p;p++){if(16>p)a[p]=
		  c[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+a[p-7]+((l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10)+a[p-16]}k=q+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&m^~h&n)+r[p]+a[p];l=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
		  d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);
	
		// HMAC SHA256
		(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;"string"==typeof g&&(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes>m&&(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j<h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=
		  this._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();
	
		// Base64
		(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<
		l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
	
		// BlockCipher
		(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
		  _doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
		    f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
		      m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
		      E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/
		    4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
		(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
		  l)}})();
	
		// Cipher
		CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
		  finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return("string"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return("string"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=
		  c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
		  e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
		  this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
		  1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
		  decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
		  b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
	
		// AES
		(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
		  16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>
		8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=
		  d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();
	
		// Mode ECB
		CryptoJS.mode.ECB = (function () {
		  var ECB = CryptoJS.lib.BlockCipherMode.extend();
	
		  ECB.Encryptor = ECB.extend({
		    processBlock: function (words, offset) {
		      this._cipher.encryptBlock(words, offset);
		    }
		  });
	
		  ECB.Decryptor = ECB.extend({
		    processBlock: function (words, offset) {
		      this._cipher.decryptBlock(words, offset);
		    }
		  });
	
		  return ECB;
		}());
	
		module.exports = CryptoJS;
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET INTERFACE
		// ---------------------------------------------------------------------------
		var WS = function( url, protocols ) {
		  if (!(this instanceof WS)) return new WS( url, protocols );
	
		  var self     = this
		    ,   url      = self.url      = url || ''
		    ,   protocol = self.protocol = protocols || 'Sec-WebSocket-Protocol'
		    ,   bits     = url.split('/')
		    ,   setup    = {
		    'ssl'           : bits[0] === 'wss:'
		    ,'origin'        : bits[2]
		    ,'publish_key'   : bits[3]
		    ,'subscribe_key' : bits[4]
		    ,'channel'       : bits[5]
		  };
	
		  // READY STATES
		  self['CONNECTING'] = 0; // The connection is not yet open.
		  self['OPEN']       = 1; // The connection is open and ready to communicate.
		  self['CLOSING']    = 2; // The connection is in the process of closing.
		  self['CLOSED']     = 3; // The connection is closed or couldn't be opened.
	
		  // CLOSE STATES
		  self['CLOSE_NORMAL']         = 1000; // Normal Intended Close; completed.
		  self['CLOSE_GOING_AWAY']     = 1001; // Closed Unexpecttedly.
		  self['CLOSE_PROTOCOL_ERROR'] = 1002; // Server: Not Supported.
		  self['CLOSE_UNSUPPORTED']    = 1003; // Server: Unsupported Protocol.
		  self['CLOSE_TOO_LARGE']      = 1004; // Server: Too Much Data.
		  self['CLOSE_NO_STATUS']      = 1005; // Server: No reason.
		  self['CLOSE_ABNORMAL']       = 1006; // Abnormal Disconnect.
	
		  // Events Default
		  self['onclose']   = self['onerror'] =
		    self['onmessage'] = self['onopen']  =
		      self['onsend']    =  function(){};
	
		  // Attributes
		  self['binaryType']     = '';
		  self['extensions']     = '';
		  self['bufferedAmount'] = 0;
		  self['trasnmitting']   = false;
		  self['buffer']         = [];
		  self['readyState']     = self['CONNECTING'];
	
		  // Close if no setup.
		  if (!url) {
		    self['readyState'] = self['CLOSED'];
		    self['onclose']({
		      'code'     : self['CLOSE_ABNORMAL'],
		      'reason'   : 'Missing URL',
		      'wasClean' : true
		    });
		    return self;
		  }
	
		  // PubNub WebSocket Emulation
		  self.pubnub       = PUBNUB['init'](setup);
		  self.pubnub.setup = setup;
		  self.setup        = setup;
	
		  self.pubnub['subscribe']({
		    'restore'    : false,
		    'channel'    : setup['channel'],
		    'disconnect' : self['onerror'],
		    'reconnect'  : self['onopen'],
		    'error'      : function() {
		      self['onclose']({
		        'code'     : self['CLOSE_ABNORMAL'],
		        'reason'   : 'Missing URL',
		        'wasClean' : false
		      });
		    },
		    'callback'   : function(message) {
		      self['onmessage']({ 'data' : message });
		    },
		    'connect'    : function() {
		      self['readyState'] = self['OPEN'];
		      self['onopen']();
		    }
		  });
		};
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET SEND
		// ---------------------------------------------------------------------------
		WS.prototype.send = function(data) {
		  var self = this;
		  self.pubnub['publish']({
		    'channel'  : self.pubnub.setup['channel'],
		    'message'  : data,
		    'callback' : function(response) {
		      self['onsend']({ 'data' : response });
		    }
		  });
		};
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET CLOSE
		// ---------------------------------------------------------------------------
		WS.prototype.close = function() {
		  var self = this;
		  self.pubnub['unsubscribe']({ 'channel' : self.pubnub.setup['channel'] });
		  self['readyState'] = self['CLOSED'];
		  self['onclose']({});
		};
	
		module.exports = WS;
	
	
	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["Client"] = factory();
		else
			root["RingCentral"] = root["RingCentral"] || {}, root["RingCentral"]["Client"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(1);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="./externals.d.ts" />
	"use strict";
	var accountClient = __webpack_require__(2);
	var callLogClient = __webpack_require__(40);
	var dictionaryClient = __webpack_require__(55);
	var extensionClient = __webpack_require__(70);
	var messagesClient = __webpack_require__(77);
	var notificationsClient = __webpack_require__(84);
	var presenceClient = __webpack_require__(87);
	var ringoutClient = __webpack_require__(93);
	var forwardingNumbersClient = __webpack_require__(96);
	var blockedNumbersClient = __webpack_require__(99);
	var Client = (function () {
	    function Client(sdk) {
	        this._sdk = sdk;
	        this._account = new accountClient.Account(sdk);
	        this._callLog = new callLogClient.CallLog(sdk);
	        this._dictionary = new dictionaryClient.Dictionary(sdk);
	        this._extension = new extensionClient.Extension(sdk);
	        this._messages = new messagesClient.Messages(sdk);
	        this._notifications = new notificationsClient.NotificationsSubscriptionAPI(sdk);
	        this._presence = new presenceClient.Presence(sdk);
	        this._ringout = new ringoutClient.RingOut(sdk);
	        this._forwardingNumbers = new forwardingNumbersClient.ForwardingNumbers(sdk);
	        this._blockedNumbers = new blockedNumbersClient.BlockedNumbers(sdk);
	    }
	    Client.prototype.account = function () { return this._account; };
	    Client.prototype.callLog = function () { return this._callLog; };
	    Client.prototype.dictionary = function () { return this._dictionary; };
	    Client.prototype.extension = function () { return this._extension; };
	    Client.prototype.messages = function () { return this._messages; };
	    Client.prototype.notifications = function () { return this._notifications; };
	    Client.prototype.presence = function () { return this._presence; };
	    Client.prototype.ringout = function () { return this._ringout; };
	    Client.prototype.forwardingNumbers = function () { return this._forwardingNumbers; };
	    Client.prototype.blockedNumbers = function () { return this._blockedNumbers; };
	    Client.version = '0.1.0';
	    return Client;
	}());
	module.exports = Client;
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var accountinfo = __webpack_require__(4);
	var accountbusinessaddress = __webpack_require__(28);
	var dialingplaninfo = __webpack_require__(30);
	var phonenumberinfo = __webpack_require__(34);
	var accountphonenumbers = __webpack_require__(36);
	var accountserviceinfo = __webpack_require__(37);
	var Account = (function (_super) {
	    __extends(Account, _super);
	    function Account() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Account
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Creates the account in Initial state.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>Accounts</td>
	     *             <td>Managing accounts: creating new accounts, viewing and updating account information, deleting existing accounts</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.createAccount = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account', options, exports.createAccountOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Get Account Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns basic information about a particular RingCentral customer account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccount = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}', options, exports.loadAccountOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Get Account Business Address
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccountBusinessAddress = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/business-address', options, exports.loadAccountBusinessAddressOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Update Account Business Address
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.updateAccountBusinessAddress = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/business-address', options, exports.updateAccountBusinessAddressOptions), accountbusinessaddress.AccountBusinessAddress);
	    };
	    /**
	     * Get Account Dialing Plan
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns list of countries which can be selected for a dialing plan (to call short numbers and special services).</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Account.prototype.listDialingPlans = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/dialing-plan', options, exports.listDialingPlansOptions), dialingplaninfo.DialingPlanInfo);
	    };
	    /**
	     * Provision Phone Numbers
	     *
	     * <p style='font-style:italic;'>Since 1.0.11 (Release 6.3)</p>
	     * <p>Provisions a phone number.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.provisionPhoneNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/phone-number', options, exports.provisionPhoneNumberOptions), phonenumberinfo.PhoneNumberInfo);
	    };
	    /**
	     * Get Account Phone Numbers
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers assigned to the RingCentral customer account. Both company-level and extension-level numbers are returned.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Account.prototype.listAccountPhoneNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/phone-number', options, exports.listAccountPhoneNumbersOptions), accountphonenumbers.AccountPhoneNumbers);
	    };
	    /**
	     * Get Phone Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccountPhoneNumber = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/phone-number/{phoneNumberId}', options, exports.loadAccountPhoneNumberOptions), phonenumberinfo.PhoneNumberInfo);
	    };
	    /**
	     * Get Account Service Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns the information about service plan, available features and limitations for a particular RingCentral customer account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadServiceInfo = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/service-info', options, exports.loadServiceInfoOptions), accountserviceinfo.AccountServiceInfo);
	    };
	    return Account;
	}(client.Client));
	exports.Account = Account;
	/**
	 * Definition of options for createAccount operation
	 */
	exports.createAccountOptions = [
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createaccountrequest.CreateAccountRequest"
	    }
	];
	/**
	 * Definition of options for loadAccount operation
	 */
	exports.loadAccountOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadAccountBusinessAddress operation
	 */
	exports.loadAccountBusinessAddressOptions = [];
	/**
	 * Definition of options for updateAccountBusinessAddress operation
	 */
	exports.updateAccountBusinessAddressOptions = [
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "modifyaccountbusinessaddressrequest.ModifyAccountBusinessAddressRequest"
	    }
	];
	/**
	 * Definition of options for listDialingPlans operation
	 */
	exports.listDialingPlansOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for provisionPhoneNumber operation
	 */
	exports.provisionPhoneNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "provisionphonenumbers.ProvisionPhoneNumbers"
	    }
	];
	/**
	 * Definition of options for listAccountPhoneNumbers operation
	 */
	exports.listAccountPhoneNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "usageType",
	        "type": "IListAccountPhoneNumbersUsageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "MainCompanyNumber",
	            "AdditionalCompanyNumber",
	            "CompanyNumber",
	            "DirectNumber",
	            "CompanyFaxNumber",
	            "ForwardedNumber"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountPhoneNumber operation
	 */
	exports.loadAccountPhoneNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "phoneNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for loadServiceInfo operation
	 */
	exports.loadServiceInfoOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	(function (IListAccountPhoneNumbersUsageType) {
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.IListAccountPhoneNumbersUsageType || (exports.IListAccountPhoneNumbersUsageType = {}));
	var IListAccountPhoneNumbersUsageType = exports.IListAccountPhoneNumbersUsageType;
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var Client = (function () {
	    function Client(sdk) {
	        this._sdk = sdk;
	    }
	    Client.prototype.parseOptions = function (method, url, options, operationParameters) {
	        options = options || {};
	        var request = {
	            url: url,
	            method: method,
	            query: {},
	            body: undefined
	        };
	        operationParameters.forEach(function (param) {
	            if (param.required && !param.default && !options.hasOwnProperty(param.name)) {
	                throw new Error('Required parameter "' + param.name + '" not found');
	            }
	            if (param.default && !options.hasOwnProperty(param.name)) {
	                options[param.name] = param.default;
	            }
	            if (param.in == 'path') {
	                request.url = request.url.replace('{' + param.name + '}', options[param.name]);
	            }
	            if (param.in == 'query' && options.hasOwnProperty(param.name)) {
	                request.query[param.name] = options[param.name];
	            }
	            if (param.in == 'body') {
	                request.body = options[param.name];
	            }
	        });
	        return request;
	    };
	    Client.prototype.send = function (apiOptions, Class) {
	        var _this = this;
	        return this._sdk.platform()
	            .send(apiOptions)
	            .then(function (res) {
	            //TODO Support multipart
	            //TODO Think how to pass headers&stuff to outside
	            if (Class && !res._isMultipart())
	                return new Class(_this._sdk, res.json());
	            return res;
	        });
	    };
	    return Client;
	}());
	exports.Client = Client;
	
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var serviceinfo = __webpack_require__(22);
	var accountstatusinfo = __webpack_require__(27);
	var AccountInfo = (function (_super) {
	    __extends(AccountInfo, _super);
	    function AccountInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'mainNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'operator', Class: extensioninfo.ExtensionInfo, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'serviceInfo', Class: serviceinfo.ServiceInfo, isArray: false, isRequired: false },
	            { property: 'setupWizardState', Class: AccountInfoSetupWizardState, isArray: false, isRequired: false },
	            { property: 'status', Class: AccountInfoStatus, isArray: false, isRequired: false },
	            { property: 'statusInfo', Class: accountstatusinfo.AccountStatusInfo, isArray: false, isRequired: false }
	        ];
	    };
	    AccountInfo.prototype.getClassName = function () {
	        return 'AccountInfo';
	    };
	    return AccountInfo;
	}(model.Model));
	exports.AccountInfo = AccountInfo;
	(function (AccountInfoSetupWizardState) {
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["NotStarted"] = 'NotStarted'] = "NotStarted";
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["Incomplete"] = 'Incomplete'] = "Incomplete";
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["Completed"] = 'Completed'] = "Completed";
	})(exports.AccountInfoSetupWizardState || (exports.AccountInfoSetupWizardState = {}));
	var AccountInfoSetupWizardState = exports.AccountInfoSetupWizardState;
	(function (AccountInfoStatus) {
	    AccountInfoStatus[AccountInfoStatus["Confirmed"] = 'Confirmed'] = "Confirmed";
	    AccountInfoStatus[AccountInfoStatus["Disabled"] = 'Disabled'] = "Disabled";
	})(exports.AccountInfoStatus || (exports.AccountInfoStatus = {}));
	var AccountInfoStatus = exports.AccountInfoStatus;
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var Model = (function () {
	    function Model(sdk, data) {
	        var _this = this;
	        this._sdk = sdk;
	        data = data || {};
	        this.getPropertyMappings().forEach(function (mapping) {
	            var Class = mapping.Class, prop = mapping.property;
	            if (!data.hasOwnProperty(prop)) {
	                if (mapping.isRequired)
	                    console.warn('Required property "' + prop + '" not defined');
	                return;
	            }
	            var processProperty = function (dataPart) {
	                if (!Class || typeof Class !== 'function') {
	                    return dataPart;
	                }
	                else {
	                    return new Class(_this._sdk, dataPart);
	                }
	            };
	            if (mapping.isArray) {
	                _this[prop] = data[prop].map(processProperty);
	            }
	            else {
	                _this[prop] = processProperty(data[prop]);
	            }
	        });
	    }
	    Model.prototype.getPropertyMappings = function () {
	        return [];
	    };
	    Model.prototype.getClassName = function () {
	        return 'Model';
	    };
	    Model.prototype.getId = function () {
	        return this['id'];
	    };
	    return Model;
	}());
	exports.Model = Model;
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var contactinfo = __webpack_require__(7);
	var departmentinfo = __webpack_require__(9);
	var extensionpermissions = __webpack_require__(10);
	var profileimageinfo = __webpack_require__(12);
	var referenceinfo = __webpack_require__(13);
	var regionalsettings = __webpack_require__(14);
	var extensionservicefeatureinfo = __webpack_require__(20);
	var extensionstatusinfo = __webpack_require__(21);
	var ExtensionInfo = (function (_super) {
	    __extends(ExtensionInfo, _super);
	    function ExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'contact', Class: contactinfo.ContactInfo, isArray: false, isRequired: false },
	            { property: 'departments', Class: departmentinfo.DepartmentInfo, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'permissions', Class: extensionpermissions.ExtensionPermissions, isArray: false, isRequired: false },
	            { property: 'profileImage', Class: profileimageinfo.ProfileImageInfo, isArray: false, isRequired: true },
	            { property: 'references', Class: referenceinfo.ReferenceInfo, isArray: true, isRequired: false },
	            { property: 'regionalSettings', Class: regionalsettings.RegionalSettings, isArray: false, isRequired: false },
	            { property: 'serviceFeatures', Class: extensionservicefeatureinfo.ExtensionServiceFeatureInfo, isArray: true, isRequired: false },
	            { property: 'setupWizardState', Class: ExtensionInfoSetupWizardState, isArray: false, isRequired: false },
	            { property: 'status', Class: ExtensionInfoStatus, isArray: false, isRequired: true },
	            { property: 'statusInfo', Class: extensionstatusinfo.ExtensionStatusInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionInfoType, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionInfo.prototype.getClassName = function () {
	        return 'ExtensionInfo';
	    };
	    return ExtensionInfo;
	}(model.Model));
	exports.ExtensionInfo = ExtensionInfo;
	(function (ExtensionInfoSetupWizardState) {
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["NotStarted"] = 'NotStarted'] = "NotStarted";
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["Incomplete"] = 'Incomplete'] = "Incomplete";
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["Completed"] = 'Completed'] = "Completed";
	})(exports.ExtensionInfoSetupWizardState || (exports.ExtensionInfoSetupWizardState = {}));
	var ExtensionInfoSetupWizardState = exports.ExtensionInfoSetupWizardState;
	(function (ExtensionInfoStatus) {
	    ExtensionInfoStatus[ExtensionInfoStatus["Enabled"] = 'Enabled'] = "Enabled";
	    ExtensionInfoStatus[ExtensionInfoStatus["Disabled"] = 'Disabled'] = "Disabled";
	    ExtensionInfoStatus[ExtensionInfoStatus["NotActivated"] = 'NotActivated'] = "NotActivated";
	    ExtensionInfoStatus[ExtensionInfoStatus["Unassigned"] = 'Unassigned'] = "Unassigned";
	})(exports.ExtensionInfoStatus || (exports.ExtensionInfoStatus = {}));
	var ExtensionInfoStatus = exports.ExtensionInfoStatus;
	(function (ExtensionInfoType) {
	    ExtensionInfoType[ExtensionInfoType["User"] = 'User'] = "User";
	    ExtensionInfoType[ExtensionInfoType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    ExtensionInfoType[ExtensionInfoType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    ExtensionInfoType[ExtensionInfoType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    ExtensionInfoType[ExtensionInfoType["Department"] = 'Department'] = "Department";
	    ExtensionInfoType[ExtensionInfoType["Announcement"] = 'Announcement'] = "Announcement";
	    ExtensionInfoType[ExtensionInfoType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionInfoType[ExtensionInfoType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    ExtensionInfoType[ExtensionInfoType["PagingOnlyGroup"] = 'PagingOnlyGroup'] = "PagingOnlyGroup";
	    ExtensionInfoType[ExtensionInfoType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    ExtensionInfoType[ExtensionInfoType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    ExtensionInfoType[ExtensionInfoType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.ExtensionInfoType || (exports.ExtensionInfoType = {}));
	var ExtensionInfoType = exports.ExtensionInfoType;
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var contactaddressinfo = __webpack_require__(8);
	var ContactInfo = (function (_super) {
	    __extends(ContactInfo, _super);
	    function ContactInfo() {
	        _super.apply(this, arguments);
	    }
	    ContactInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'firstName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'company', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'email', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessPhone', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessAddress', Class: contactaddressinfo.ContactAddressInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ContactInfo.prototype.getClassName = function () {
	        return 'ContactInfo';
	    };
	    return ContactInfo;
	}(model.Model));
	exports.ContactInfo = ContactInfo;
	
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ContactAddressInfo = (function (_super) {
	    __extends(ContactAddressInfo, _super);
	    function ContactAddressInfo() {
	        _super.apply(this, arguments);
	    }
	    ContactAddressInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'country', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'street', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'zip', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ContactAddressInfo.prototype.getClassName = function () {
	        return 'ContactAddressInfo';
	    };
	    return ContactAddressInfo;
	}(model.Model));
	exports.ContactAddressInfo = ContactAddressInfo;
	
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DepartmentInfo = (function (_super) {
	    __extends(DepartmentInfo, _super);
	    function DepartmentInfo() {
	        _super.apply(this, arguments);
	    }
	    DepartmentInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DepartmentInfo.prototype.getClassName = function () {
	        return 'DepartmentInfo';
	    };
	    return DepartmentInfo;
	}(model.Model));
	exports.DepartmentInfo = DepartmentInfo;
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var permissioninfo = __webpack_require__(11);
	var ExtensionPermissions = (function (_super) {
	    __extends(ExtensionPermissions, _super);
	    function ExtensionPermissions() {
	        _super.apply(this, arguments);
	    }
	    ExtensionPermissions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'admin', Class: permissioninfo.PermissionInfo, isArray: false, isRequired: false },
	            { property: 'internationalCalling', Class: permissioninfo.PermissionInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionPermissions.prototype.getClassName = function () {
	        return 'ExtensionPermissions';
	    };
	    return ExtensionPermissions;
	}(model.Model));
	exports.ExtensionPermissions = ExtensionPermissions;
	
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PermissionInfo = (function (_super) {
	    __extends(PermissionInfo, _super);
	    function PermissionInfo() {
	        _super.apply(this, arguments);
	    }
	    PermissionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'enabled', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    PermissionInfo.prototype.getClassName = function () {
	        return 'PermissionInfo';
	    };
	    return PermissionInfo;
	}(model.Model));
	exports.PermissionInfo = PermissionInfo;
	
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ProfileImageInfo = (function (_super) {
	    __extends(ProfileImageInfo, _super);
	    function ProfileImageInfo() {
	        _super.apply(this, arguments);
	    }
	    ProfileImageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'etag', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastModified', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'scales', Class: null /* string[] */, isArray: true, isRequired: false }
	        ];
	    };
	    ProfileImageInfo.prototype.getClassName = function () {
	        return 'ProfileImageInfo';
	    };
	    return ProfileImageInfo;
	}(model.Model));
	exports.ProfileImageInfo = ProfileImageInfo;
	
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ReferenceInfo = (function (_super) {
	    __extends(ReferenceInfo, _super);
	    function ReferenceInfo() {
	        _super.apply(this, arguments);
	    }
	    ReferenceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'ref', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: ReferenceInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    ReferenceInfo.prototype.getClassName = function () {
	        return 'ReferenceInfo';
	    };
	    return ReferenceInfo;
	}(model.Model));
	exports.ReferenceInfo = ReferenceInfo;
	(function (ReferenceInfoType) {
	    ReferenceInfoType[ReferenceInfoType["PartnerId"] = 'PartnerId'] = "PartnerId";
	    ReferenceInfoType[ReferenceInfoType["CustomerDirectoryId"] = 'CustomerDirectoryId'] = "CustomerDirectoryId";
	})(exports.ReferenceInfoType || (exports.ReferenceInfoType = {}));
	var ReferenceInfoType = exports.ReferenceInfoType;
	
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var timezoneinfo = __webpack_require__(16);
	var languageinfo = __webpack_require__(17);
	var greetinglanguageinfo = __webpack_require__(18);
	var formattinglocaleinfo = __webpack_require__(19);
	var RegionalSettings = (function (_super) {
	    __extends(RegionalSettings, _super);
	    function RegionalSettings() {
	        _super.apply(this, arguments);
	    }
	    RegionalSettings.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'homeCountry', Class: countryinfo.CountryInfo, isArray: false, isRequired: false },
	            { property: 'timezone', Class: timezoneinfo.TimezoneInfo, isArray: false, isRequired: false },
	            { property: 'language', Class: languageinfo.LanguageInfo, isArray: false, isRequired: false },
	            { property: 'greetingLanguage', Class: greetinglanguageinfo.GreetingLanguageInfo, isArray: false, isRequired: false },
	            { property: 'formattingLocale', Class: formattinglocaleinfo.FormattingLocaleInfo, isArray: false, isRequired: false }
	        ];
	    };
	    RegionalSettings.prototype.getClassName = function () {
	        return 'RegionalSettings';
	    };
	    return RegionalSettings;
	}(model.Model));
	exports.RegionalSettings = RegionalSettings;
	
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CountryInfo = (function (_super) {
	    __extends(CountryInfo, _super);
	    function CountryInfo() {
	        _super.apply(this, arguments);
	    }
	    CountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    CountryInfo.prototype.getClassName = function () {
	        return 'CountryInfo';
	    };
	    return CountryInfo;
	}(model.Model));
	exports.CountryInfo = CountryInfo;
	
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var TimezoneInfo = (function (_super) {
	    __extends(TimezoneInfo, _super);
	    function TimezoneInfo() {
	        _super.apply(this, arguments);
	    }
	    TimezoneInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'description', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    TimezoneInfo.prototype.getClassName = function () {
	        return 'TimezoneInfo';
	    };
	    return TimezoneInfo;
	}(model.Model));
	exports.TimezoneInfo = TimezoneInfo;
	
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var LanguageInfo = (function (_super) {
	    __extends(LanguageInfo, _super);
	    function LanguageInfo() {
	        _super.apply(this, arguments);
	    }
	    LanguageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'greeting', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'formattingLocale', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'ui', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    LanguageInfo.prototype.getClassName = function () {
	        return 'LanguageInfo';
	    };
	    return LanguageInfo;
	}(model.Model));
	exports.LanguageInfo = LanguageInfo;
	
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var GreetingLanguageInfo = (function (_super) {
	    __extends(GreetingLanguageInfo, _super);
	    function GreetingLanguageInfo() {
	        _super.apply(this, arguments);
	    }
	    GreetingLanguageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    GreetingLanguageInfo.prototype.getClassName = function () {
	        return 'GreetingLanguageInfo';
	    };
	    return GreetingLanguageInfo;
	}(model.Model));
	exports.GreetingLanguageInfo = GreetingLanguageInfo;
	
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var FormattingLocaleInfo = (function (_super) {
	    __extends(FormattingLocaleInfo, _super);
	    function FormattingLocaleInfo() {
	        _super.apply(this, arguments);
	    }
	    FormattingLocaleInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    FormattingLocaleInfo.prototype.getClassName = function () {
	        return 'FormattingLocaleInfo';
	    };
	    return FormattingLocaleInfo;
	}(model.Model));
	exports.FormattingLocaleInfo = FormattingLocaleInfo;
	
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionServiceFeatureInfo = (function (_super) {
	    __extends(ExtensionServiceFeatureInfo, _super);
	    function ExtensionServiceFeatureInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionServiceFeatureInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'enabled', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'featureName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionServiceFeatureInfo.prototype.getClassName = function () {
	        return 'ExtensionServiceFeatureInfo';
	    };
	    return ExtensionServiceFeatureInfo;
	}(model.Model));
	exports.ExtensionServiceFeatureInfo = ExtensionServiceFeatureInfo;
	
	
	/***/ },
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionStatusInfo = (function (_super) {
	    __extends(ExtensionStatusInfo, _super);
	    function ExtensionStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'comment', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: ExtensionStatusInfoReason, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionStatusInfo.prototype.getClassName = function () {
	        return 'ExtensionStatusInfo';
	    };
	    return ExtensionStatusInfo;
	}(model.Model));
	exports.ExtensionStatusInfo = ExtensionStatusInfo;
	(function (ExtensionStatusInfoReason) {
	    ExtensionStatusInfoReason[ExtensionStatusInfoReason["Voluntarily"] = 'Voluntarily'] = "Voluntarily";
	    ExtensionStatusInfoReason[ExtensionStatusInfoReason["Involuntarily"] = 'Involuntarily'] = "Involuntarily";
	})(exports.ExtensionStatusInfoReason || (exports.ExtensionStatusInfoReason = {}));
	var ExtensionStatusInfoReason = exports.ExtensionStatusInfoReason;
	
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var billingplaninfo = __webpack_require__(23);
	var brandinfo = __webpack_require__(24);
	var serviceplaninfo = __webpack_require__(25);
	var targetserviceplaninfo = __webpack_require__(26);
	var ServiceInfo = (function (_super) {
	    __extends(ServiceInfo, _super);
	    function ServiceInfo() {
	        _super.apply(this, arguments);
	    }
	    ServiceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'billingPlan', Class: billingplaninfo.BillingPlanInfo, isArray: false, isRequired: false },
	            { property: 'brand', Class: brandinfo.BrandInfo, isArray: false, isRequired: false },
	            { property: 'servicePlan', Class: serviceplaninfo.ServicePlanInfo, isArray: false, isRequired: false },
	            { property: 'targetServicePlan', Class: targetserviceplaninfo.TargetServicePlanInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ServiceInfo.prototype.getClassName = function () {
	        return 'ServiceInfo';
	    };
	    return ServiceInfo;
	}(model.Model));
	exports.ServiceInfo = ServiceInfo;
	
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BillingPlanInfo = (function (_super) {
	    __extends(BillingPlanInfo, _super);
	    function BillingPlanInfo() {
	        _super.apply(this, arguments);
	    }
	    BillingPlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'durationUnit', Class: BillingPlanInfoDurationUnit, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: BillingPlanInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    BillingPlanInfo.prototype.getClassName = function () {
	        return 'BillingPlanInfo';
	    };
	    return BillingPlanInfo;
	}(model.Model));
	exports.BillingPlanInfo = BillingPlanInfo;
	(function (BillingPlanInfoDurationUnit) {
	    BillingPlanInfoDurationUnit[BillingPlanInfoDurationUnit["Month"] = 'Month'] = "Month";
	    BillingPlanInfoDurationUnit[BillingPlanInfoDurationUnit["Day"] = 'Day'] = "Day";
	})(exports.BillingPlanInfoDurationUnit || (exports.BillingPlanInfoDurationUnit = {}));
	var BillingPlanInfoDurationUnit = exports.BillingPlanInfoDurationUnit;
	(function (BillingPlanInfoType) {
	    BillingPlanInfoType[BillingPlanInfoType["Initial"] = 'Initial'] = "Initial";
	    BillingPlanInfoType[BillingPlanInfoType["Regular"] = 'Regular'] = "Regular";
	    BillingPlanInfoType[BillingPlanInfoType["Suspended"] = 'Suspended'] = "Suspended";
	    BillingPlanInfoType[BillingPlanInfoType["Trial"] = 'Trial'] = "Trial";
	    BillingPlanInfoType[BillingPlanInfoType["TrialNoCC"] = 'TrialNoCC'] = "TrialNoCC";
	    BillingPlanInfoType[BillingPlanInfoType["Free"] = 'Free'] = "Free";
	})(exports.BillingPlanInfoType || (exports.BillingPlanInfoType = {}));
	var BillingPlanInfoType = exports.BillingPlanInfoType;
	
	
	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var BrandInfo = (function (_super) {
	    __extends(BrandInfo, _super);
	    function BrandInfo() {
	        _super.apply(this, arguments);
	    }
	    BrandInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'homeCountry', Class: countryinfo.CountryInfo, isArray: false, isRequired: false }
	        ];
	    };
	    BrandInfo.prototype.getClassName = function () {
	        return 'BrandInfo';
	    };
	    return BrandInfo;
	}(model.Model));
	exports.BrandInfo = BrandInfo;
	
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ServicePlanInfo = (function (_super) {
	    __extends(ServicePlanInfo, _super);
	    function ServicePlanInfo() {
	        _super.apply(this, arguments);
	    }
	    ServicePlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'edition', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ServicePlanInfo.prototype.getClassName = function () {
	        return 'ServicePlanInfo';
	    };
	    return ServicePlanInfo;
	}(model.Model));
	exports.ServicePlanInfo = ServicePlanInfo;
	
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var TargetServicePlanInfo = (function (_super) {
	    __extends(TargetServicePlanInfo, _super);
	    function TargetServicePlanInfo() {
	        _super.apply(this, arguments);
	    }
	    TargetServicePlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    TargetServicePlanInfo.prototype.getClassName = function () {
	        return 'TargetServicePlanInfo';
	    };
	    return TargetServicePlanInfo;
	}(model.Model));
	exports.TargetServicePlanInfo = TargetServicePlanInfo;
	
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var AccountStatusInfo = (function (_super) {
	    __extends(AccountStatusInfo, _super);
	    function AccountStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'comment', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: AccountStatusInfoReason, isArray: false, isRequired: false }
	        ];
	    };
	    AccountStatusInfo.prototype.getClassName = function () {
	        return 'AccountStatusInfo';
	    };
	    return AccountStatusInfo;
	}(model.Model));
	exports.AccountStatusInfo = AccountStatusInfo;
	(function (AccountStatusInfoReason) {
	    AccountStatusInfoReason[AccountStatusInfoReason["Voluntarily"] = 'Voluntarily'] = "Voluntarily";
	    AccountStatusInfoReason[AccountStatusInfoReason["Involuntarily"] = 'Involuntarily'] = "Involuntarily";
	})(exports.AccountStatusInfoReason || (exports.AccountStatusInfoReason = {}));
	var AccountStatusInfoReason = exports.AccountStatusInfoReason;
	
	
	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var businessaddressinfo = __webpack_require__(29);
	var AccountBusinessAddress = (function (_super) {
	    __extends(AccountBusinessAddress, _super);
	    function AccountBusinessAddress() {
	        _super.apply(this, arguments);
	    }
	    AccountBusinessAddress.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'company', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'email', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessAddress', Class: businessaddressinfo.BusinessAddressInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountBusinessAddress.prototype.getClassName = function () {
	        return 'AccountBusinessAddress';
	    };
	    return AccountBusinessAddress;
	}(model.Model));
	exports.AccountBusinessAddress = AccountBusinessAddress;
	
	
	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BusinessAddressInfo = (function (_super) {
	    __extends(BusinessAddressInfo, _super);
	    function BusinessAddressInfo() {
	        _super.apply(this, arguments);
	    }
	    BusinessAddressInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'country', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'street', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'zip', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    BusinessAddressInfo.prototype.getClassName = function () {
	        return 'BusinessAddressInfo';
	    };
	    return BusinessAddressInfo;
	}(model.Model));
	exports.BusinessAddressInfo = BusinessAddressInfo;
	
	
	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dialingplancountryinfo = __webpack_require__(31);
	var paginginfo = __webpack_require__(32);
	var navigationinfo = __webpack_require__(33);
	var DialingPlanInfo = (function (_super) {
	    __extends(DialingPlanInfo, _super);
	    function DialingPlanInfo() {
	        _super.apply(this, arguments);
	    }
	    DialingPlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dialingplancountryinfo.DialingPlanCountryInfo, isArray: true, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DialingPlanInfo.prototype.getClassName = function () {
	        return 'DialingPlanInfo';
	    };
	    return DialingPlanInfo;
	}(model.Model));
	exports.DialingPlanInfo = DialingPlanInfo;
	
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DialingPlanCountryInfo = (function (_super) {
	    __extends(DialingPlanCountryInfo, _super);
	    function DialingPlanCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    DialingPlanCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'callingCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DialingPlanCountryInfo.prototype.getClassName = function () {
	        return 'DialingPlanCountryInfo';
	    };
	    return DialingPlanCountryInfo;
	}(model.Model));
	exports.DialingPlanCountryInfo = DialingPlanCountryInfo;
	
	
	/***/ },
	/* 32 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PagingInfo = (function (_super) {
	    __extends(PagingInfo, _super);
	    function PagingInfo() {
	        _super.apply(this, arguments);
	    }
	    PagingInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'page', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'perPage', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'pageStart', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'pageEnd', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'totalPages', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'totalElements', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    PagingInfo.prototype.getClassName = function () {
	        return 'PagingInfo';
	    };
	    return PagingInfo;
	}(model.Model));
	exports.PagingInfo = PagingInfo;
	
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var NavigationInfo = (function (_super) {
	    __extends(NavigationInfo, _super);
	    function NavigationInfo() {
	        _super.apply(this, arguments);
	    }
	    NavigationInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'firstPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'nextPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'previousPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastPage', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    NavigationInfo.prototype.getClassName = function () {
	        return 'NavigationInfo';
	    };
	    return NavigationInfo;
	}(model.Model));
	exports.NavigationInfo = NavigationInfo;
	
	
	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var phonenumbersextensioninfo = __webpack_require__(35);
	var PhoneNumberInfo = (function (_super) {
	    __extends(PhoneNumberInfo, _super);
	    function PhoneNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    PhoneNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'country', Class: countryinfo.CountryInfo, isArray: false, isRequired: false },
	            { property: 'extension', Class: phonenumbersextensioninfo.PhoneNumbersExtensionInfo, isArray: false, isRequired: false },
	            { property: 'features', Class: null /* string[] */, isArray: true, isRequired: false },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'paymentType', Class: PhoneNumberInfoPaymentType, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'status', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: PhoneNumberInfoType, isArray: false, isRequired: false },
	            { property: 'usageType', Class: PhoneNumberInfoUsageType, isArray: false, isRequired: false }
	        ];
	    };
	    PhoneNumberInfo.prototype.getClassName = function () {
	        return 'PhoneNumberInfo';
	    };
	    return PhoneNumberInfo;
	}(model.Model));
	exports.PhoneNumberInfo = PhoneNumberInfo;
	(function (PhoneNumberInfoPaymentType) {
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["External"] = 'External'] = "External";
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["TollFree"] = 'TollFree'] = "TollFree";
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["Local"] = 'Local'] = "Local";
	})(exports.PhoneNumberInfoPaymentType || (exports.PhoneNumberInfoPaymentType = {}));
	var PhoneNumberInfoPaymentType = exports.PhoneNumberInfoPaymentType;
	(function (PhoneNumberInfoType) {
	    PhoneNumberInfoType[PhoneNumberInfoType["VoiceFax"] = 'VoiceFax'] = "VoiceFax";
	    PhoneNumberInfoType[PhoneNumberInfoType["FaxOnly"] = 'FaxOnly'] = "FaxOnly";
	    PhoneNumberInfoType[PhoneNumberInfoType["VoiceOnly"] = 'VoiceOnly'] = "VoiceOnly";
	})(exports.PhoneNumberInfoType || (exports.PhoneNumberInfoType = {}));
	var PhoneNumberInfoType = exports.PhoneNumberInfoType;
	(function (PhoneNumberInfoUsageType) {
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.PhoneNumberInfoUsageType || (exports.PhoneNumberInfoUsageType = {}));
	var PhoneNumberInfoUsageType = exports.PhoneNumberInfoUsageType;
	
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PhoneNumbersExtensionInfo = (function (_super) {
	    __extends(PhoneNumbersExtensionInfo, _super);
	    function PhoneNumbersExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    PhoneNumbersExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    PhoneNumbersExtensionInfo.prototype.getClassName = function () {
	        return 'PhoneNumbersExtensionInfo';
	    };
	    return PhoneNumbersExtensionInfo;
	}(model.Model));
	exports.PhoneNumbersExtensionInfo = PhoneNumbersExtensionInfo;
	
	
	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var phonenumberinfo = __webpack_require__(34);
	var paginginfo = __webpack_require__(32);
	var navigationinfo = __webpack_require__(33);
	var AccountPhoneNumbers = (function (_super) {
	    __extends(AccountPhoneNumbers, _super);
	    function AccountPhoneNumbers() {
	        _super.apply(this, arguments);
	    }
	    AccountPhoneNumbers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: phonenumberinfo.PhoneNumberInfo, isArray: true, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountPhoneNumbers.prototype.getClassName = function () {
	        return 'AccountPhoneNumbers';
	    };
	    return AccountPhoneNumbers;
	}(model.Model));
	exports.AccountPhoneNumbers = AccountPhoneNumbers;
	
	
	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var servicefeatureinfo = __webpack_require__(38);
	var accountlimits = __webpack_require__(39);
	var AccountServiceInfo = (function (_super) {
	    __extends(AccountServiceInfo, _super);
	    function AccountServiceInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountServiceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'servicePlanName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'serviceFeatures', Class: servicefeatureinfo.ServiceFeatureInfo, isArray: true, isRequired: false },
	            { property: 'limits', Class: accountlimits.AccountLimits, isArray: true, isRequired: false }
	        ];
	    };
	    AccountServiceInfo.prototype.getClassName = function () {
	        return 'AccountServiceInfo';
	    };
	    return AccountServiceInfo;
	}(model.Model));
	exports.AccountServiceInfo = AccountServiceInfo;
	
	
	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ServiceFeatureInfo = (function (_super) {
	    __extends(ServiceFeatureInfo, _super);
	    function ServiceFeatureInfo() {
	        _super.apply(this, arguments);
	    }
	    ServiceFeatureInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'featureName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'enabled', Class: ServiceFeatureInfoEnabled, isArray: false, isRequired: false }
	        ];
	    };
	    ServiceFeatureInfo.prototype.getClassName = function () {
	        return 'ServiceFeatureInfo';
	    };
	    return ServiceFeatureInfo;
	}(model.Model));
	exports.ServiceFeatureInfo = ServiceFeatureInfo;
	(function (ServiceFeatureInfoEnabled) {
	    ServiceFeatureInfoEnabled[ServiceFeatureInfoEnabled["True"] = 'True'] = "True";
	    ServiceFeatureInfoEnabled[ServiceFeatureInfoEnabled["False"] = 'False'] = "False";
	})(exports.ServiceFeatureInfoEnabled || (exports.ServiceFeatureInfoEnabled = {}));
	var ServiceFeatureInfoEnabled = exports.ServiceFeatureInfoEnabled;
	
	
	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var AccountLimits = (function (_super) {
	    __extends(AccountLimits, _super);
	    function AccountLimits() {
	        _super.apply(this, arguments);
	    }
	    AccountLimits.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'freeSoftPhoneLinesPerExtension', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'meetingSize', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'maxMonitoredExtensionsPerUser', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    AccountLimits.prototype.getClassName = function () {
	        return 'AccountLimits';
	    };
	    return AccountLimits;
	}(model.Model));
	exports.AccountLimits = AccountLimits;
	
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var accountactivecalls = __webpack_require__(41);
	var accountcalllog = __webpack_require__(47);
	var accountcalllogrecord = __webpack_require__(48);
	var extensionactivecalls = __webpack_require__(49);
	var extensioncalllog = __webpack_require__(50);
	var extensioncalllogrecord = __webpack_require__(51);
	var calllogsync = __webpack_require__(52);
	var callrecording = __webpack_require__(54);
	var CallLog = (function (_super) {
	    __extends(CallLog, _super);
	    function CallLog() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Account Active Calls
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns records of all calls that are in progress, ordered by start time in descending order.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.listAccountActiveCalls = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/active-calls', options, exports.listAccountActiveCallsOptions), accountactivecalls.AccountActiveCalls);
	    };
	    /**
	     * Get Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log records filtered by the specified parameters.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadAccountCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/call-log', options, exports.loadAccountCallLogOptions), accountcalllog.AccountCallLog);
	    };
	    /**
	     * Delete Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditCallLog</td>
	     *             <td>Viewing and updating user call logs</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.deleteAccountCallLog = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/call-log', options, exports.deleteAccountCallLogOptions), null);
	    };
	    /**
	     * Get Account Call Log Record(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns individual call log record(s) by ID(s). Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadAccountCallLogRecord = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/call-log/{callRecordId}', options, exports.loadAccountCallLogRecordOptions), accountcalllogrecord.AccountCallLogRecord);
	    };
	    /**
	     * Get Active Calls
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns records of all extension calls that are in progress, ordered by start time in descending order.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.listExtensionActiveCalls = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/active-calls', options, exports.listExtensionActiveCallsOptions), extensionactivecalls.ExtensionActiveCalls);
	    };
	    /**
	     * Get Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log records filtered by the specified parameters.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log', options, exports.loadExtensionCallLogOptions), extensioncalllog.ExtensionCallLog);
	    };
	    /**
	     * Delete Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditCallLog</td>
	     *             <td>Viewing and updating user call logs</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.deleteExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log', options, exports.deleteExtensionCallLogOptions), null);
	    };
	    /**
	     * Get Extension Call Log Record(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log record(s) by their ID(s). Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadExtensionCallLogRecord = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log/{callRecordId}', options, exports.loadExtensionCallLogRecordOptions), extensioncalllogrecord.ExtensionCallLogRecord);
	    };
	    /**
	     * Call Log Synchronization
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.syncExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log-sync', options, exports.syncExtensionCallLogOptions), calllogsync.CallLogSync);
	    };
	    /**
	     * Get Call Recording
	     *
	     * <p style='font-style:italic;'>Since 1.0.18</p>
	     * <p>Returns call recording metadata.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallRecording</td>
	     *             <td>Downloading call recording content</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadCallRecordingMetadata = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/recording/{recordingId}', options, exports.loadCallRecordingMetadataOptions), callrecording.CallRecording);
	    };
	    /**
	     * Get Call Recording Data
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallRecording</td>
	     *             <td>Downloading call recording content</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadCallRecordingContent = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/recording/{recordingId}/content', options, exports.loadCallRecordingContentOptions), null);
	    };
	    return CallLog;
	}(client.Client));
	exports.CallLog = CallLog;
	/**
	 * Definition of options for listAccountActiveCalls operation
	 */
	exports.listAccountActiveCallsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "direction",
	        "type": "IListAccountActiveCallsDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListAccountActiveCallsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountCallLog operation
	 */
	exports.loadAccountCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ILoadAccountCallLogDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "ILoadAccountCallLogType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "view",
	        "type": "ILoadAccountCallLogView",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Simple",
	            "Detailed"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withRecording",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for deleteAccountCallLog operation
	 */
	exports.deleteAccountCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountCallLogRecord operation
	 */
	exports.loadAccountCallLogRecordOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "callRecordId",
	        "type": "number",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listExtensionActiveCalls operation
	 */
	exports.listExtensionActiveCallsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "direction",
	        "type": "IListExtensionActiveCallsDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListExtensionActiveCallsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionCallLog operation
	 */
	exports.loadExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ILoadExtensionCallLogDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "ILoadExtensionCallLogType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "view",
	        "type": "ILoadExtensionCallLogView",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Simple",
	            "Detailed"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withRecording",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for deleteExtensionCallLog operation
	 */
	exports.deleteExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionCallLogRecord operation
	 */
	exports.loadExtensionCallLogRecordOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "callRecordId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for syncExtensionCallLog operation
	 */
	exports.syncExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "syncType",
	        "type": "ISyncExtensionCallLogSyncType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "FSync",
	            "ISync"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncToken",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "recordCount",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "statusGroup",
	        "type": "ISyncExtensionCallLogStatusGroup",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Missed",
	            "All"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadCallRecordingMetadata operation
	 */
	exports.loadCallRecordingMetadataOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "recordingId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for loadCallRecordingContent operation
	 */
	exports.loadCallRecordingContentOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "recordingId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	(function (IListAccountActiveCallsDirection) {
	    IListAccountActiveCallsDirection[IListAccountActiveCallsDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListAccountActiveCallsDirection[IListAccountActiveCallsDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListAccountActiveCallsDirection || (exports.IListAccountActiveCallsDirection = {}));
	var IListAccountActiveCallsDirection = exports.IListAccountActiveCallsDirection;
	(function (IListAccountActiveCallsType) {
	    IListAccountActiveCallsType[IListAccountActiveCallsType["Voice"] = 'Voice'] = "Voice";
	    IListAccountActiveCallsType[IListAccountActiveCallsType["Fax"] = 'Fax'] = "Fax";
	})(exports.IListAccountActiveCallsType || (exports.IListAccountActiveCallsType = {}));
	var IListAccountActiveCallsType = exports.IListAccountActiveCallsType;
	(function (ILoadAccountCallLogDirection) {
	    ILoadAccountCallLogDirection[ILoadAccountCallLogDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ILoadAccountCallLogDirection[ILoadAccountCallLogDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ILoadAccountCallLogDirection || (exports.ILoadAccountCallLogDirection = {}));
	var ILoadAccountCallLogDirection = exports.ILoadAccountCallLogDirection;
	(function (ILoadAccountCallLogType) {
	    ILoadAccountCallLogType[ILoadAccountCallLogType["Voice"] = 'Voice'] = "Voice";
	    ILoadAccountCallLogType[ILoadAccountCallLogType["Fax"] = 'Fax'] = "Fax";
	})(exports.ILoadAccountCallLogType || (exports.ILoadAccountCallLogType = {}));
	var ILoadAccountCallLogType = exports.ILoadAccountCallLogType;
	(function (ILoadAccountCallLogView) {
	    ILoadAccountCallLogView[ILoadAccountCallLogView["Simple"] = 'Simple'] = "Simple";
	    ILoadAccountCallLogView[ILoadAccountCallLogView["Detailed"] = 'Detailed'] = "Detailed";
	})(exports.ILoadAccountCallLogView || (exports.ILoadAccountCallLogView = {}));
	var ILoadAccountCallLogView = exports.ILoadAccountCallLogView;
	(function (IListExtensionActiveCallsDirection) {
	    IListExtensionActiveCallsDirection[IListExtensionActiveCallsDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListExtensionActiveCallsDirection[IListExtensionActiveCallsDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListExtensionActiveCallsDirection || (exports.IListExtensionActiveCallsDirection = {}));
	var IListExtensionActiveCallsDirection = exports.IListExtensionActiveCallsDirection;
	(function (IListExtensionActiveCallsType) {
	    IListExtensionActiveCallsType[IListExtensionActiveCallsType["Voice"] = 'Voice'] = "Voice";
	    IListExtensionActiveCallsType[IListExtensionActiveCallsType["Fax"] = 'Fax'] = "Fax";
	})(exports.IListExtensionActiveCallsType || (exports.IListExtensionActiveCallsType = {}));
	var IListExtensionActiveCallsType = exports.IListExtensionActiveCallsType;
	(function (ILoadExtensionCallLogDirection) {
	    ILoadExtensionCallLogDirection[ILoadExtensionCallLogDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ILoadExtensionCallLogDirection[ILoadExtensionCallLogDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ILoadExtensionCallLogDirection || (exports.ILoadExtensionCallLogDirection = {}));
	var ILoadExtensionCallLogDirection = exports.ILoadExtensionCallLogDirection;
	(function (ILoadExtensionCallLogType) {
	    ILoadExtensionCallLogType[ILoadExtensionCallLogType["Voice"] = 'Voice'] = "Voice";
	    ILoadExtensionCallLogType[ILoadExtensionCallLogType["Fax"] = 'Fax'] = "Fax";
	})(exports.ILoadExtensionCallLogType || (exports.ILoadExtensionCallLogType = {}));
	var ILoadExtensionCallLogType = exports.ILoadExtensionCallLogType;
	(function (ILoadExtensionCallLogView) {
	    ILoadExtensionCallLogView[ILoadExtensionCallLogView["Simple"] = 'Simple'] = "Simple";
	    ILoadExtensionCallLogView[ILoadExtensionCallLogView["Detailed"] = 'Detailed'] = "Detailed";
	})(exports.ILoadExtensionCallLogView || (exports.ILoadExtensionCallLogView = {}));
	var ILoadExtensionCallLogView = exports.ILoadExtensionCallLogView;
	(function (ISyncExtensionCallLogSyncType) {
	    ISyncExtensionCallLogSyncType[ISyncExtensionCallLogSyncType["FSync"] = 'FSync'] = "FSync";
	    ISyncExtensionCallLogSyncType[ISyncExtensionCallLogSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.ISyncExtensionCallLogSyncType || (exports.ISyncExtensionCallLogSyncType = {}));
	var ISyncExtensionCallLogSyncType = exports.ISyncExtensionCallLogSyncType;
	(function (ISyncExtensionCallLogStatusGroup) {
	    ISyncExtensionCallLogStatusGroup[ISyncExtensionCallLogStatusGroup["Missed"] = 'Missed'] = "Missed";
	    ISyncExtensionCallLogStatusGroup[ISyncExtensionCallLogStatusGroup["All"] = 'All'] = "All";
	})(exports.ISyncExtensionCallLogStatusGroup || (exports.ISyncExtensionCallLogStatusGroup = {}));
	var ISyncExtensionCallLogStatusGroup = exports.ISyncExtensionCallLogStatusGroup;
	
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var AccountActiveCalls = (function (_super) {
	    __extends(AccountActiveCalls, _super);
	    function AccountActiveCalls() {
	        _super.apply(this, arguments);
	    }
	    AccountActiveCalls.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountActiveCalls.prototype.getClassName = function () {
	        return 'AccountActiveCalls';
	    };
	    return AccountActiveCalls;
	}(model.Model));
	exports.AccountActiveCalls = AccountActiveCalls;
	
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var calllogrecordleginfo = __webpack_require__(45);
	var CallLogRecord = (function (_super) {
	    __extends(CallLogRecord, _super);
	    function CallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    CallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: CallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: CallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: CallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: CallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false },
	            { property: 'lastModifiedTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'transport', Class: CallLogRecordTransport, isArray: false, isRequired: false },
	            { property: 'legs', Class: calllogrecordleginfo.CallLogRecordLegInfo, isArray: true, isRequired: true }
	        ];
	    };
	    CallLogRecord.prototype.getClassName = function () {
	        return 'CallLogRecord';
	    };
	    return CallLogRecord;
	}(model.Model));
	exports.CallLogRecord = CallLogRecord;
	(function (CallLogRecordType) {
	    CallLogRecordType[CallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    CallLogRecordType[CallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.CallLogRecordType || (exports.CallLogRecordType = {}));
	var CallLogRecordType = exports.CallLogRecordType;
	(function (CallLogRecordDirection) {
	    CallLogRecordDirection[CallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    CallLogRecordDirection[CallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.CallLogRecordDirection || (exports.CallLogRecordDirection = {}));
	var CallLogRecordDirection = exports.CallLogRecordDirection;
	(function (CallLogRecordAction) {
	    CallLogRecordAction[CallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordAction[CallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    CallLogRecordAction[CallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    CallLogRecordAction[CallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    CallLogRecordAction[CallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    CallLogRecordAction[CallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    CallLogRecordAction[CallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    CallLogRecordAction[CallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    CallLogRecordAction[CallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    CallLogRecordAction[CallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    CallLogRecordAction[CallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    CallLogRecordAction[CallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    CallLogRecordAction[CallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    CallLogRecordAction[CallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    CallLogRecordAction[CallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    CallLogRecordAction[CallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    CallLogRecordAction[CallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    CallLogRecordAction[CallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    CallLogRecordAction[CallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    CallLogRecordAction[CallLogRecordAction["Support"] = 'Support'] = "Support";
	    CallLogRecordAction[CallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.CallLogRecordAction || (exports.CallLogRecordAction = {}));
	var CallLogRecordAction = exports.CallLogRecordAction;
	(function (CallLogRecordResult) {
	    CallLogRecordResult[CallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordResult[CallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    CallLogRecordResult[CallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    CallLogRecordResult[CallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    CallLogRecordResult[CallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    CallLogRecordResult[CallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    CallLogRecordResult[CallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    CallLogRecordResult[CallLogRecordResult["Received"] = 'Received'] = "Received";
	    CallLogRecordResult[CallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    CallLogRecordResult[CallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    CallLogRecordResult[CallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    CallLogRecordResult[CallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    CallLogRecordResult[CallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    CallLogRecordResult[CallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    CallLogRecordResult[CallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    CallLogRecordResult[CallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    CallLogRecordResult[CallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    CallLogRecordResult[CallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    CallLogRecordResult[CallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    CallLogRecordResult[CallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    CallLogRecordResult[CallLogRecordResult["Account"] = 'Account'] = "Account";
	    CallLogRecordResult[CallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    CallLogRecordResult[CallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    CallLogRecordResult[CallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    CallLogRecordResult[CallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    CallLogRecordResult[CallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    CallLogRecordResult[CallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    CallLogRecordResult[CallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    CallLogRecordResult[CallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    CallLogRecordResult[CallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    CallLogRecordResult[CallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    CallLogRecordResult[CallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    CallLogRecordResult[CallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    CallLogRecordResult[CallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    CallLogRecordResult[CallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    CallLogRecordResult[CallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    CallLogRecordResult[CallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.CallLogRecordResult || (exports.CallLogRecordResult = {}));
	var CallLogRecordResult = exports.CallLogRecordResult;
	(function (CallLogRecordTransport) {
	    CallLogRecordTransport[CallLogRecordTransport["PSTN"] = 'PSTN'] = "PSTN";
	    CallLogRecordTransport[CallLogRecordTransport["VoIP"] = 'VoIP'] = "VoIP";
	})(exports.CallLogRecordTransport || (exports.CallLogRecordTransport = {}));
	var CallLogRecordTransport = exports.CallLogRecordTransport;
	
	
	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CallLogCallerInfo = (function (_super) {
	    __extends(CallLogCallerInfo, _super);
	    function CallLogCallerInfo() {
	        _super.apply(this, arguments);
	    }
	    CallLogCallerInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogCallerInfo.prototype.getClassName = function () {
	        return 'CallLogCallerInfo';
	    };
	    return CallLogCallerInfo;
	}(model.Model));
	exports.CallLogCallerInfo = CallLogCallerInfo;
	
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var RecordingInfo = (function (_super) {
	    __extends(RecordingInfo, _super);
	    function RecordingInfo() {
	        _super.apply(this, arguments);
	    }
	    RecordingInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: RecordingInfoType, isArray: false, isRequired: false },
	            { property: 'contentUri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    RecordingInfo.prototype.getClassName = function () {
	        return 'RecordingInfo';
	    };
	    return RecordingInfo;
	}(model.Model));
	exports.RecordingInfo = RecordingInfo;
	(function (RecordingInfoType) {
	    RecordingInfoType[RecordingInfoType["Automatic"] = 'Automatic'] = "Automatic";
	    RecordingInfoType[RecordingInfoType["OnDemand"] = 'OnDemand'] = "OnDemand";
	})(exports.RecordingInfoType || (exports.RecordingInfoType = {}));
	var RecordingInfoType = exports.RecordingInfoType;
	
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfocalllog = __webpack_require__(46);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var CallLogRecordLegInfo = (function (_super) {
	    __extends(CallLogRecordLegInfo, _super);
	    function CallLogRecordLegInfo() {
	        _super.apply(this, arguments);
	    }
	    CallLogRecordLegInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'action', Class: CallLogRecordLegInfoAction, isArray: false, isRequired: false },
	            { property: 'direction', Class: CallLogRecordLegInfoDirection, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'extension', Class: extensioninfocalllog.ExtensionInfoCallLog, isArray: false, isRequired: false },
	            { property: 'legType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: CallLogRecordLegInfoType, isArray: false, isRequired: false },
	            { property: 'result', Class: CallLogRecordLegInfoResult, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'transport', Class: CallLogRecordLegInfoTransport, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogRecordLegInfo.prototype.getClassName = function () {
	        return 'CallLogRecordLegInfo';
	    };
	    return CallLogRecordLegInfo;
	}(model.Model));
	exports.CallLogRecordLegInfo = CallLogRecordLegInfo;
	(function (CallLogRecordLegInfoAction) {
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["FindMe"] = 'FindMe'] = "FindMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingMe"] = 'RingMe'] = "RingMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Transfer"] = 'Transfer'] = "Transfer";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction['411Info'] = '411 Info'] = '411Info';
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Emergency"] = 'Emergency'] = "Emergency";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Support"] = 'Support'] = "Support";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.CallLogRecordLegInfoAction || (exports.CallLogRecordLegInfoAction = {}));
	var CallLogRecordLegInfoAction = exports.CallLogRecordLegInfoAction;
	(function (CallLogRecordLegInfoDirection) {
	    CallLogRecordLegInfoDirection[CallLogRecordLegInfoDirection["Inbound"] = 'Inbound'] = "Inbound";
	    CallLogRecordLegInfoDirection[CallLogRecordLegInfoDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.CallLogRecordLegInfoDirection || (exports.CallLogRecordLegInfoDirection = {}));
	var CallLogRecordLegInfoDirection = exports.CallLogRecordLegInfoDirection;
	(function (CallLogRecordLegInfoType) {
	    CallLogRecordLegInfoType[CallLogRecordLegInfoType["Voice"] = 'Voice'] = "Voice";
	    CallLogRecordLegInfoType[CallLogRecordLegInfoType["Fax"] = 'Fax'] = "Fax";
	})(exports.CallLogRecordLegInfoType || (exports.CallLogRecordLegInfoType = {}));
	var CallLogRecordLegInfoType = exports.CallLogRecordLegInfoType;
	(function (CallLogRecordLegInfoResult) {
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Missed"] = 'Missed'] = "Missed";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Rejected"] = 'Rejected'] = "Rejected";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Reply"] = 'Reply'] = "Reply";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Received"] = 'Received'] = "Received";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Blocked"] = 'Blocked'] = "Blocked";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Busy"] = 'Busy'] = "Busy";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["SendError"] = 'Send Error'] = "SendError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Sent"] = 'Sent'] = "Sent";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Account"] = 'Account'] = "Account";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Suspended"] = 'Suspended'] = "Suspended";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternalError"] = 'Internal Error'] = "InternalError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Stopped"] = 'Stopped'] = "Stopped";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Hangup"] = 'Hang up'] = "Hangup";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Declined"] = 'Declined'] = "Declined";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.CallLogRecordLegInfoResult || (exports.CallLogRecordLegInfoResult = {}));
	var CallLogRecordLegInfoResult = exports.CallLogRecordLegInfoResult;
	(function (CallLogRecordLegInfoTransport) {
	    CallLogRecordLegInfoTransport[CallLogRecordLegInfoTransport["PSTN"] = 'PSTN'] = "PSTN";
	    CallLogRecordLegInfoTransport[CallLogRecordLegInfoTransport["VoIP"] = 'VoIP'] = "VoIP";
	})(exports.CallLogRecordLegInfoTransport || (exports.CallLogRecordLegInfoTransport = {}));
	var CallLogRecordLegInfoTransport = exports.CallLogRecordLegInfoTransport;
	
	
	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionInfoCallLog = (function (_super) {
	    __extends(ExtensionInfoCallLog, _super);
	    function ExtensionInfoCallLog() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfoCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionInfoCallLog.prototype.getClassName = function () {
	        return 'ExtensionInfoCallLog';
	    };
	    return ExtensionInfoCallLog;
	}(model.Model));
	exports.ExtensionInfoCallLog = ExtensionInfoCallLog;
	
	
	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var AccountCallLog = (function (_super) {
	    __extends(AccountCallLog, _super);
	    function AccountCallLog() {
	        _super.apply(this, arguments);
	    }
	    AccountCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountCallLog.prototype.getClassName = function () {
	        return 'AccountCallLog';
	    };
	    return AccountCallLog;
	}(model.Model));
	exports.AccountCallLog = AccountCallLog;
	
	
	/***/ },
	/* 48 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var AccountCallLogRecord = (function (_super) {
	    __extends(AccountCallLogRecord, _super);
	    function AccountCallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    AccountCallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: AccountCallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: AccountCallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: AccountCallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: AccountCallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    AccountCallLogRecord.prototype.getClassName = function () {
	        return 'AccountCallLogRecord';
	    };
	    return AccountCallLogRecord;
	}(model.Model));
	exports.AccountCallLogRecord = AccountCallLogRecord;
	(function (AccountCallLogRecordType) {
	    AccountCallLogRecordType[AccountCallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    AccountCallLogRecordType[AccountCallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.AccountCallLogRecordType || (exports.AccountCallLogRecordType = {}));
	var AccountCallLogRecordType = exports.AccountCallLogRecordType;
	(function (AccountCallLogRecordDirection) {
	    AccountCallLogRecordDirection[AccountCallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    AccountCallLogRecordDirection[AccountCallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.AccountCallLogRecordDirection || (exports.AccountCallLogRecordDirection = {}));
	var AccountCallLogRecordDirection = exports.AccountCallLogRecordDirection;
	(function (AccountCallLogRecordAction) {
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    AccountCallLogRecordAction[AccountCallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    AccountCallLogRecordAction[AccountCallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Support"] = 'Support'] = "Support";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.AccountCallLogRecordAction || (exports.AccountCallLogRecordAction = {}));
	var AccountCallLogRecordAction = exports.AccountCallLogRecordAction;
	(function (AccountCallLogRecordResult) {
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Received"] = 'Received'] = "Received";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Account"] = 'Account'] = "Account";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.AccountCallLogRecordResult || (exports.AccountCallLogRecordResult = {}));
	var AccountCallLogRecordResult = exports.AccountCallLogRecordResult;
	
	
	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionActiveCalls = (function (_super) {
	    __extends(ExtensionActiveCalls, _super);
	    function ExtensionActiveCalls() {
	        _super.apply(this, arguments);
	    }
	    ExtensionActiveCalls.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionActiveCalls.prototype.getClassName = function () {
	        return 'ExtensionActiveCalls';
	    };
	    return ExtensionActiveCalls;
	}(model.Model));
	exports.ExtensionActiveCalls = ExtensionActiveCalls;
	
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionCallLog = (function (_super) {
	    __extends(ExtensionCallLog, _super);
	    function ExtensionCallLog() {
	        _super.apply(this, arguments);
	    }
	    ExtensionCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionCallLog.prototype.getClassName = function () {
	        return 'ExtensionCallLog';
	    };
	    return ExtensionCallLog;
	}(model.Model));
	exports.ExtensionCallLog = ExtensionCallLog;
	
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var ExtensionCallLogRecord = (function (_super) {
	    __extends(ExtensionCallLogRecord, _super);
	    function ExtensionCallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    ExtensionCallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionCallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: ExtensionCallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: ExtensionCallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: ExtensionCallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionCallLogRecord.prototype.getClassName = function () {
	        return 'ExtensionCallLogRecord';
	    };
	    return ExtensionCallLogRecord;
	}(model.Model));
	exports.ExtensionCallLogRecord = ExtensionCallLogRecord;
	(function (ExtensionCallLogRecordType) {
	    ExtensionCallLogRecordType[ExtensionCallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    ExtensionCallLogRecordType[ExtensionCallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.ExtensionCallLogRecordType || (exports.ExtensionCallLogRecordType = {}));
	var ExtensionCallLogRecordType = exports.ExtensionCallLogRecordType;
	(function (ExtensionCallLogRecordDirection) {
	    ExtensionCallLogRecordDirection[ExtensionCallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ExtensionCallLogRecordDirection[ExtensionCallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ExtensionCallLogRecordDirection || (exports.ExtensionCallLogRecordDirection = {}));
	var ExtensionCallLogRecordDirection = exports.ExtensionCallLogRecordDirection;
	(function (ExtensionCallLogRecordAction) {
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Support"] = 'Support'] = "Support";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.ExtensionCallLogRecordAction || (exports.ExtensionCallLogRecordAction = {}));
	var ExtensionCallLogRecordAction = exports.ExtensionCallLogRecordAction;
	(function (ExtensionCallLogRecordResult) {
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Received"] = 'Received'] = "Received";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Account"] = 'Account'] = "Account";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.ExtensionCallLogRecordResult || (exports.ExtensionCallLogRecordResult = {}));
	var ExtensionCallLogRecordResult = exports.ExtensionCallLogRecordResult;
	
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var syncinfocalllog = __webpack_require__(53);
	var CallLogSync = (function (_super) {
	    __extends(CallLogSync, _super);
	    function CallLogSync() {
	        _super.apply(this, arguments);
	    }
	    CallLogSync.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'syncInfo', Class: syncinfocalllog.SyncInfoCallLog, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogSync.prototype.getClassName = function () {
	        return 'CallLogSync';
	    };
	    return CallLogSync;
	}(model.Model));
	exports.CallLogSync = CallLogSync;
	
	
	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var SyncInfoCallLog = (function (_super) {
	    __extends(SyncInfoCallLog, _super);
	    function SyncInfoCallLog() {
	        _super.apply(this, arguments);
	    }
	    SyncInfoCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'syncType', Class: SyncInfoCallLogSyncType, isArray: false, isRequired: false },
	            { property: 'syncToken', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'syncTime', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    SyncInfoCallLog.prototype.getClassName = function () {
	        return 'SyncInfoCallLog';
	    };
	    return SyncInfoCallLog;
	}(model.Model));
	exports.SyncInfoCallLog = SyncInfoCallLog;
	(function (SyncInfoCallLogSyncType) {
	    SyncInfoCallLogSyncType[SyncInfoCallLogSyncType["FSync"] = 'FSync'] = "FSync";
	    SyncInfoCallLogSyncType[SyncInfoCallLogSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.SyncInfoCallLogSyncType || (exports.SyncInfoCallLogSyncType = {}));
	var SyncInfoCallLogSyncType = exports.SyncInfoCallLogSyncType;
	
	
	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CallRecording = (function (_super) {
	    __extends(CallRecording, _super);
	    function CallRecording() {
	        _super.apply(this, arguments);
	    }
	    CallRecording.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentUri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    CallRecording.prototype.getClassName = function () {
	        return 'CallRecording';
	    };
	    return CallRecording;
	}(model.Model));
	exports.CallRecording = CallRecording;
	
	
	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var countrylist = __webpack_require__(56);
	var dictionarycountryinfo = __webpack_require__(57);
	var languagelist = __webpack_require__(58);
	var languageinfo = __webpack_require__(17);
	var dictionarylocationlist = __webpack_require__(59);
	var dictionarysecretquestionlist = __webpack_require__(61);
	var secretquestioninfo = __webpack_require__(62);
	var dictionaryshippingoptions = __webpack_require__(63);
	var dictionarystatelist = __webpack_require__(65);
	var dictionarystateinfo = __webpack_require__(66);
	var dictionarytimezonelist = __webpack_require__(68);
	var dictionarytimezoneinfo = __webpack_require__(69);
	var Dictionary = (function (_super) {
	    __extends(Dictionary, _super);
	    function Dictionary() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Country List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the countries available for calling.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listCountries = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/country', options, exports.listCountriesOptions), countrylist.CountryList);
	    };
	    /**
	     * Get Country
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on the required country.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadCountry = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/country/{countryId}', options, exports.loadCountryOptions), dictionarycountryinfo.DictionaryCountryInfo);
	    };
	    /**
	     * Get Language List
	     *
	     * <p style='font-style:italic;'>Since 1.0.14 (Release 6.6)</p>
	     * <p>Returns the information about supported languages.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listLanguages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/language', options, exports.listLanguagesOptions), languagelist.LanguageList);
	    };
	    /**
	     * Get Language
	     *
	     * <p style='font-style:italic;'>Since 1.0.14 (Release 6.6)</p>
	     * <p>Returns language by its respective ID.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadLanguage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/language/{languageId}', options, exports.loadLanguageOptions), languageinfo.LanguageInfo);
	    };
	    /**
	     * Get Location List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the available locations for the certain state.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listLocations = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/location', options, exports.listLocationsOptions), dictionarylocationlist.DictionaryLocationList);
	    };
	    /**
	     * Get Secret Question List
	     *
	     * <p style='font-style:italic;'>Since 1.0.20 (Release 7.4)</p>
	     * <p>Returns the list of secret questions for a specific language.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listSecretQuestions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/secret-question', options, exports.listSecretQuestionsOptions), dictionarysecretquestionlist.DictionarySecretQuestionList);
	    };
	    /**
	     * Get Secret Question
	     *
	     * <p style='font-style:italic;'>Since 1.0.20 (Release 7.4)</p>
	     * <p>Returns a particular secret question in specific language by question ID.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadSecretQuestion = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/secret-question/questionId', options, exports.loadSecretQuestionOptions), secretquestioninfo.SecretQuestionInfo);
	    };
	    /**
	     * Get Shipping Options
	     *
	     * <p style='font-style:italic;'>Since 1.0.16 (Release 7.1)</p>
	     * <p>Returns the list of device shipping options with their prices, according to brand, tier, number of ordered devices.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listShippingOptions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/shipping-options', options, exports.listShippingOptionsOptions), dictionaryshippingoptions.DictionaryShippingOptions);
	    };
	    /**
	     * Get State List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the states for a certain country.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadlistStates = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/state', options, exports.loadlistStatesOptions), dictionarystatelist.DictionaryStateList);
	    };
	    /**
	     * Get State
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on the required state.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadState = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/state/{stateId}', options, exports.loadStateOptions), dictionarystateinfo.DictionaryStateInfo);
	    };
	    /**
	     * Get Timezone List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all available timezones.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listTimezones = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/timezone', options, exports.listTimezonesOptions), dictionarytimezonelist.DictionaryTimezoneList);
	    };
	    /**
	     * Get Timezone
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on a certain timezone.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadTimezone = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/timezone/{timezoneId}', options, exports.loadTimezoneOptions), dictionarytimezoneinfo.DictionaryTimezoneInfo);
	    };
	    return Dictionary;
	}(client.Client));
	exports.Dictionary = Dictionary;
	/**
	 * Definition of options for listCountries operation
	 */
	exports.listCountriesOptions = [
	    {
	        "name": "loginAllowed",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "numberSelling",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadCountry operation
	 */
	exports.loadCountryOptions = [
	    {
	        "name": "countryId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listLanguages operation
	 */
	exports.listLanguagesOptions = [];
	/**
	 * Definition of options for loadLanguage operation
	 */
	exports.loadLanguageOptions = [
	    {
	        "name": "languageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listLocations operation
	 */
	exports.listLocationsOptions = [
	    {
	        "name": "orderBy",
	        "type": "IListLocationsOrderBy",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Npa",
	            "City"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "stateId",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withNxx",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for listSecretQuestions operation
	 */
	exports.listSecretQuestionsOptions = [];
	/**
	 * Definition of options for loadSecretQuestion operation
	 */
	exports.loadSecretQuestionOptions = [
	    {
	        "name": "questionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listShippingOptions operation
	 */
	exports.listShippingOptionsOptions = [];
	/**
	 * Definition of options for loadlistStates operation
	 */
	exports.loadlistStatesOptions = [
	    {
	        "name": "countryId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withPhoneNumbers",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadState operation
	 */
	exports.loadStateOptions = [
	    {
	        "name": "stateId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listTimezones operation
	 */
	exports.listTimezonesOptions = [
	    {
	        "name": "page",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadTimezone operation
	 */
	exports.loadTimezoneOptions = [
	    {
	        "name": "timezoneId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListLocationsOrderBy) {
	    IListLocationsOrderBy[IListLocationsOrderBy["Npa"] = 'Npa'] = "Npa";
	    IListLocationsOrderBy[IListLocationsOrderBy["City"] = 'City'] = "City";
	})(exports.IListLocationsOrderBy || (exports.IListLocationsOrderBy = {}));
	var IListLocationsOrderBy = exports.IListLocationsOrderBy;
	
	
	/***/ },
	/* 56 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarycountryinfo = __webpack_require__(57);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var CountryList = (function (_super) {
	    __extends(CountryList, _super);
	    function CountryList() {
	        _super.apply(this, arguments);
	    }
	    CountryList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarycountryinfo.DictionaryCountryInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    CountryList.prototype.getClassName = function () {
	        return 'CountryList';
	    };
	    return CountryList;
	}(model.Model));
	exports.CountryList = CountryList;
	
	
	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DictionaryCountryInfo = (function (_super) {
	    __extends(DictionaryCountryInfo, _super);
	    function DictionaryCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'callingCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'emergencyCalling', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'numberSelling', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'loginAllowed', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryCountryInfo.prototype.getClassName = function () {
	        return 'DictionaryCountryInfo';
	    };
	    return DictionaryCountryInfo;
	}(model.Model));
	exports.DictionaryCountryInfo = DictionaryCountryInfo;
	
	
	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var languageinfo = __webpack_require__(17);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var LanguageList = (function (_super) {
	    __extends(LanguageList, _super);
	    function LanguageList() {
	        _super.apply(this, arguments);
	    }
	    LanguageList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'records', Class: languageinfo.LanguageInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    LanguageList.prototype.getClassName = function () {
	        return 'LanguageList';
	    };
	    return LanguageList;
	}(model.Model));
	exports.LanguageList = LanguageList;
	
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var locationinfo = __webpack_require__(60);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryLocationList = (function (_super) {
	    __extends(DictionaryLocationList, _super);
	    function DictionaryLocationList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryLocationList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: locationinfo.LocationInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryLocationList.prototype.getClassName = function () {
	        return 'DictionaryLocationList';
	    };
	    return DictionaryLocationList;
	}(model.Model));
	exports.DictionaryLocationList = DictionaryLocationList;
	
	
	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var LocationInfo = (function (_super) {
	    __extends(LocationInfo, _super);
	    function LocationInfo() {
	        _super.apply(this, arguments);
	    }
	    LocationInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'areaCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'npa', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'nxx', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    LocationInfo.prototype.getClassName = function () {
	        return 'LocationInfo';
	    };
	    return LocationInfo;
	}(model.Model));
	exports.LocationInfo = LocationInfo;
	
	
	/***/ },
	/* 61 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var secretquestioninfo = __webpack_require__(62);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionarySecretQuestionList = (function (_super) {
	    __extends(DictionarySecretQuestionList, _super);
	    function DictionarySecretQuestionList() {
	        _super.apply(this, arguments);
	    }
	    DictionarySecretQuestionList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'records', Class: secretquestioninfo.SecretQuestionInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: false },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    DictionarySecretQuestionList.prototype.getClassName = function () {
	        return 'DictionarySecretQuestionList';
	    };
	    return DictionarySecretQuestionList;
	}(model.Model));
	exports.DictionarySecretQuestionList = DictionarySecretQuestionList;
	
	
	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var SecretQuestionInfo = (function (_super) {
	    __extends(SecretQuestionInfo, _super);
	    function SecretQuestionInfo() {
	        _super.apply(this, arguments);
	    }
	    SecretQuestionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'questionType', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'languageId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'questionText', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'showInSignUp', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    SecretQuestionInfo.prototype.getClassName = function () {
	        return 'SecretQuestionInfo';
	    };
	    return SecretQuestionInfo;
	}(model.Model));
	exports.SecretQuestionInfo = SecretQuestionInfo;
	
	
	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var shippingmethodinfo = __webpack_require__(64);
	var DictionaryShippingOptions = (function (_super) {
	    __extends(DictionaryShippingOptions, _super);
	    function DictionaryShippingOptions() {
	        _super.apply(this, arguments);
	    }
	    DictionaryShippingOptions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'quantity', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'price', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'method', Class: shippingmethodinfo.ShippingMethodInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryShippingOptions.prototype.getClassName = function () {
	        return 'DictionaryShippingOptions';
	    };
	    return DictionaryShippingOptions;
	}(model.Model));
	exports.DictionaryShippingOptions = DictionaryShippingOptions;
	
	
	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ShippingMethodInfo = (function (_super) {
	    __extends(ShippingMethodInfo, _super);
	    function ShippingMethodInfo() {
	        _super.apply(this, arguments);
	    }
	    ShippingMethodInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ShippingMethodInfo.prototype.getClassName = function () {
	        return 'ShippingMethodInfo';
	    };
	    return ShippingMethodInfo;
	}(model.Model));
	exports.ShippingMethodInfo = ShippingMethodInfo;
	
	
	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarystateinfo = __webpack_require__(66);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryStateList = (function (_super) {
	    __extends(DictionaryStateList, _super);
	    function DictionaryStateList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryStateList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarystateinfo.DictionaryStateInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryStateList.prototype.getClassName = function () {
	        return 'DictionaryStateList';
	    };
	    return DictionaryStateList;
	}(model.Model));
	exports.DictionaryStateList = DictionaryStateList;
	
	
	/***/ },
	/* 66 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var statecountryinfo = __webpack_require__(67);
	var DictionaryStateInfo = (function (_super) {
	    __extends(DictionaryStateInfo, _super);
	    function DictionaryStateInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryStateInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'country', Class: statecountryinfo.StateCountryInfo, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryStateInfo.prototype.getClassName = function () {
	        return 'DictionaryStateInfo';
	    };
	    return DictionaryStateInfo;
	}(model.Model));
	exports.DictionaryStateInfo = DictionaryStateInfo;
	
	
	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var StateCountryInfo = (function (_super) {
	    __extends(StateCountryInfo, _super);
	    function StateCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    StateCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    StateCountryInfo.prototype.getClassName = function () {
	        return 'StateCountryInfo';
	    };
	    return StateCountryInfo;
	}(model.Model));
	exports.StateCountryInfo = StateCountryInfo;
	
	
	/***/ },
	/* 68 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarytimezoneinfo = __webpack_require__(69);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryTimezoneList = (function (_super) {
	    __extends(DictionaryTimezoneList, _super);
	    function DictionaryTimezoneList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryTimezoneList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarytimezoneinfo.DictionaryTimezoneInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryTimezoneList.prototype.getClassName = function () {
	        return 'DictionaryTimezoneList';
	    };
	    return DictionaryTimezoneList;
	}(model.Model));
	exports.DictionaryTimezoneList = DictionaryTimezoneList;
	
	
	/***/ },
	/* 69 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DictionaryTimezoneInfo = (function (_super) {
	    __extends(DictionaryTimezoneInfo, _super);
	    function DictionaryTimezoneInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryTimezoneInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'description', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryTimezoneInfo.prototype.getClassName = function () {
	        return 'DictionaryTimezoneInfo';
	    };
	    return DictionaryTimezoneInfo;
	}(model.Model));
	exports.DictionaryTimezoneInfo = DictionaryTimezoneInfo;
	
	
	/***/ },
	/* 70 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var extensionlist = __webpack_require__(71);
	var extensioninfo = __webpack_require__(6);
	var extensionphonenumbers = __webpack_require__(72);
	var extensiongrantlist = __webpack_require__(73);
	var departmentmembers = __webpack_require__(76);
	var Extension = (function (_super) {
	    __extends(Extension, _super);
	    function Extension() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension List
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns the list of extensions created for a particular account. All types of extensions are included in this list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.listExtensions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension', options, exports.listExtensionsOptions), extensionlist.ExtensionList);
	    };
	    /**
	     * Get Extension Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns basic information about a particular extension of an account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.loadExtensionInfo = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}', options, exports.loadExtensionInfoOptions), extensioninfo.ExtensionInfo);
	    };
	    /**
	     * Get Extension Phone Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers that are used by a particular extension, and can be filtered by the phone number type. The returned list contains all numbers which are directly mapped to a given extension plus the features and also company-level numbers
	     *     which may be used when performing different operations on behalf of this extension.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listExtensionPhoneNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/phone-number', options, exports.listExtensionPhoneNumbersOptions), extensionphonenumbers.ExtensionPhoneNumbers);
	    };
	    /**
	     * Get Extension Grant List
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the list of extension grants.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listExtensionGrants = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/grant', options, exports.listExtensionGrantsOptions), extensiongrantlist.ExtensionGrantList);
	    };
	    /**
	     * Get Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.loadExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.loadExtensionProfileImageOptions), null);
	    };
	    /**
	     * Create Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>High</p>
	     */
	    Extension.prototype.createExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.createExtensionProfileImageOptions), null);
	    };
	    /**
	     * Update Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Updates the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>High</p>
	     */
	    Extension.prototype.updateExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.updateExtensionProfileImageOptions), null);
	    };
	    /**
	     * Get Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the scaled profile image of an extension.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.loadExtensionScaledProfileImage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image/{scaleSize}', options, exports.loadExtensionScaledProfileImageOptions), null);
	    };
	    /**
	     * Get Department Member List
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listDepartmentMembers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/department/{departmentId}/members', options, exports.listDepartmentMembersOptions), departmentmembers.DepartmentMembers);
	    };
	    return Extension;
	}(client.Client));
	exports.Extension = Extension;
	/**
	 * Definition of options for listExtensions operation
	 */
	exports.listExtensionsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "status",
	        "type": "IListExtensionsStatus",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Enabled",
	            "Disabled",
	            "NotActivated",
	            "Unassigned"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListExtensionsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "User",
	            "FaxUser",
	            "VirtualUser",
	            "DigitalUser",
	            "Department",
	            "Announcement",
	            "Voicemail",
	            "SharedLinesGroup",
	            "PagingOnlyGroup",
	            "IvrMenu",
	            "ApplicationExtension",
	            "ParkLocation"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionInfo operation
	 */
	exports.loadExtensionInfoOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listExtensionPhoneNumbers operation
	 */
	exports.listExtensionPhoneNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "usageType",
	        "type": "IListExtensionPhoneNumbersUsageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "MainCompanyNumber",
	            "AdditionalCompanyNumber",
	            "CompanyNumber",
	            "DirectNumber",
	            "CompanyFaxNumber",
	            "ForwardedNumber"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for listExtensionGrants operation
	 */
	exports.listExtensionGrantsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionProfileImage operation
	 */
	exports.loadExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for createExtensionProfileImage operation
	 */
	exports.createExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for updateExtensionProfileImage operation
	 */
	exports.updateExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadExtensionScaledProfileImage operation
	 */
	exports.loadExtensionScaledProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "scaleSize",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listDepartmentMembers operation
	 */
	exports.listDepartmentMembersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "departmentId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListExtensionsStatus) {
	    IListExtensionsStatus[IListExtensionsStatus["Enabled"] = 'Enabled'] = "Enabled";
	    IListExtensionsStatus[IListExtensionsStatus["Disabled"] = 'Disabled'] = "Disabled";
	    IListExtensionsStatus[IListExtensionsStatus["NotActivated"] = 'NotActivated'] = "NotActivated";
	    IListExtensionsStatus[IListExtensionsStatus["Unassigned"] = 'Unassigned'] = "Unassigned";
	})(exports.IListExtensionsStatus || (exports.IListExtensionsStatus = {}));
	var IListExtensionsStatus = exports.IListExtensionsStatus;
	(function (IListExtensionsType) {
	    IListExtensionsType[IListExtensionsType["User"] = 'User'] = "User";
	    IListExtensionsType[IListExtensionsType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    IListExtensionsType[IListExtensionsType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    IListExtensionsType[IListExtensionsType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    IListExtensionsType[IListExtensionsType["Department"] = 'Department'] = "Department";
	    IListExtensionsType[IListExtensionsType["Announcement"] = 'Announcement'] = "Announcement";
	    IListExtensionsType[IListExtensionsType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    IListExtensionsType[IListExtensionsType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    IListExtensionsType[IListExtensionsType["PagingOnlyGroup"] = 'PagingOnlyGroup'] = "PagingOnlyGroup";
	    IListExtensionsType[IListExtensionsType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    IListExtensionsType[IListExtensionsType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    IListExtensionsType[IListExtensionsType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.IListExtensionsType || (exports.IListExtensionsType = {}));
	var IListExtensionsType = exports.IListExtensionsType;
	(function (IListExtensionPhoneNumbersUsageType) {
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.IListExtensionPhoneNumbersUsageType || (exports.IListExtensionPhoneNumbersUsageType = {}));
	var IListExtensionPhoneNumbersUsageType = exports.IListExtensionPhoneNumbersUsageType;
	
	
	/***/ },
	/* 71 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionList = (function (_super) {
	    __extends(ExtensionList, _super);
	    function ExtensionList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: extensioninfo.ExtensionInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionList.prototype.getClassName = function () {
	        return 'ExtensionList';
	    };
	    return ExtensionList;
	}(model.Model));
	exports.ExtensionList = ExtensionList;
	
	
	/***/ },
	/* 72 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var phonenumberinfo = __webpack_require__(34);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionPhoneNumbers = (function (_super) {
	    __extends(ExtensionPhoneNumbers, _super);
	    function ExtensionPhoneNumbers() {
	        _super.apply(this, arguments);
	    }
	    ExtensionPhoneNumbers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: phonenumberinfo.PhoneNumberInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionPhoneNumbers.prototype.getClassName = function () {
	        return 'ExtensionPhoneNumbers';
	    };
	    return ExtensionPhoneNumbers;
	}(model.Model));
	exports.ExtensionPhoneNumbers = ExtensionPhoneNumbers;
	
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var grantinfo = __webpack_require__(74);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionGrantList = (function (_super) {
	    __extends(ExtensionGrantList, _super);
	    function ExtensionGrantList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionGrantList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: grantinfo.GrantInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionGrantList.prototype.getClassName = function () {
	        return 'ExtensionGrantList';
	    };
	    return ExtensionGrantList;
	}(model.Model));
	exports.ExtensionGrantList = ExtensionGrantList;
	
	
	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfogrants = __webpack_require__(75);
	var GrantInfo = (function (_super) {
	    __extends(GrantInfo, _super);
	    function GrantInfo() {
	        _super.apply(this, arguments);
	    }
	    GrantInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extension', Class: extensioninfogrants.ExtensionInfoGrants, isArray: false, isRequired: false },
	            { property: 'callPickup', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'callMonitoring', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    GrantInfo.prototype.getClassName = function () {
	        return 'GrantInfo';
	    };
	    return GrantInfo;
	}(model.Model));
	exports.GrantInfo = GrantInfo;
	
	
	/***/ },
	/* 75 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionInfoGrants = (function (_super) {
	    __extends(ExtensionInfoGrants, _super);
	    function ExtensionInfoGrants() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfoGrants.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionInfoGrantsType, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionInfoGrants.prototype.getClassName = function () {
	        return 'ExtensionInfoGrants';
	    };
	    return ExtensionInfoGrants;
	}(model.Model));
	exports.ExtensionInfoGrants = ExtensionInfoGrants;
	(function (ExtensionInfoGrantsType) {
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["User"] = 'User'] = "User";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["FaxUser"] = 'Fax User'] = "FaxUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Department"] = 'Department'] = "Department";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Announcement"] = 'Announcement'] = "Announcement";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["PagingOnly"] = 'PagingOnly'] = "PagingOnly";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["ParkLocation"] = 'Park Location'] = "ParkLocation";
	})(exports.ExtensionInfoGrantsType || (exports.ExtensionInfoGrantsType = {}));
	var ExtensionInfoGrantsType = exports.ExtensionInfoGrantsType;
	
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DepartmentMembers = (function (_super) {
	    __extends(DepartmentMembers, _super);
	    function DepartmentMembers() {
	        _super.apply(this, arguments);
	    }
	    DepartmentMembers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: extensioninfo.ExtensionInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DepartmentMembers.prototype.getClassName = function () {
	        return 'DepartmentMembers';
	    };
	    return DepartmentMembers;
	}(model.Model));
	exports.DepartmentMembers = DepartmentMembers;
	
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var messageinfo = __webpack_require__(78);
	var messagelist = __webpack_require__(81);
	var messagesync = __webpack_require__(82);
	var Messages = (function (_super) {
	    __extends(Messages, _super);
	    function Messages() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Pager Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends a pager message.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>InternalMessages</td>
	     *             <td>Sending and receiving intra-company text messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.sendInternalMessage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/company-pager', options, exports.sendInternalMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Create Fax Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends/resends new fax message. Resend can be done if sending failed.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>Faxes</td>
	     *             <td>Sending and receiving faxes</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Messages.prototype.sendFaxMessage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/fax', options, exports.sendFaxMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Create SMS Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends new SMS message. Sending SMS messages simultaneously to different recipients is limited up to 50 requests per minute; relevant for all client applications.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>SMS</td>
	     *             <td>Sending and receiving SMS (text) messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.sendSMS = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/sms', options, exports.sendSMSOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Get Message List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of messages from an extension mailbox.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.listMessages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store', options, exports.listMessagesOptions), messagelist.MessageList);
	    };
	    /**
	     * Get Message(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns individual message record(s) by the given message ID(s). The length of inbound messages is unlimited. Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.loadMessage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.loadMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Update Message(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Updates message(s) by ID(s). Batch request is supported, see Batch Requests for details. Currently, only the message read status updating is supported.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditMessages</td>
	     *             <td>Viewing and updating user messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.updateMessage = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.updateMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Delete Message(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Deletes message(s) by the given message ID(s). The first call of this method transfers the message to the 'Delete' status. The second call transfers the deleted message to the 'Purged' status. If it is required to make the message 'Purged' immediately
	     *     (from the first call), then set the query parameter purge to 'True'. Batch request is supported.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditMessages</td>
	     *             <td>Viewing and updating user messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.deleteMessage = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.deleteMessageOptions), null);
	    };
	    /**
	     * Get Message Attachment
	     *
	     * <p style='font-style:italic;'>Since 1.0.4 (Release 5.13)</p>
	     * <p>Returns particular message attachment data as a media stream.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.loadMessageAttachment = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}/content/{attachmentId}', options, exports.loadMessageAttachmentOptions), null);
	    };
	    /**
	     * Get Message Sync
	     *
	     * <p style='font-style:italic;'>Since 1.0.4 (Release 5.13)</p>
	     * <p>Provides facilities to synchronize mailbox content stored externally with server state.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.syncMessages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-sync', options, exports.syncMessagesOptions), messagesync.MessageSync);
	    };
	    return Messages;
	}(client.Client));
	exports.Messages = Messages;
	/**
	 * Definition of options for sendInternalMessage operation
	 */
	exports.sendInternalMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createpagermessagerequest.CreatePagerMessageRequest"
	    }
	];
	/**
	 * Definition of options for sendFaxMessage operation
	 */
	exports.sendFaxMessageOptions = [
	    {
	        "name": "accountId",
	        "in": "path",
	        "notes": "",
	        "paramType": "path",
	        "defaultValue": "~",
	        "required": true,
	        "allowMultiple": false,
	        "type": "string"
	    },
	    {
	        "name": "extensionId",
	        "in": "path",
	        "notes": "",
	        "paramType": "path",
	        "defaultValue": "~",
	        "required": true,
	        "allowMultiple": false,
	        "type": "string"
	    },
	    {
	        "name": "Content-Type",
	        "in": "header",
	        "default": "multipart/mixed; boundary=Boundary_1_14413901_1361871080888",
	        "type": "string"
	    },
	    {
	        "name": "Content-Length",
	        "in": "header",
	        "default": "",
	        "type": "string"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "consumes": [
	            "multipart/mixed; boundary=Boundary_1_14413901_1361871080888"
	        ],
	        "default": "--Boundary_1_14413901_1361871080888\nContent-Type: application/json\n\n{\n  \"to\":[{\"phoneNumber\":\"18005630003\"}],\n  \"faxResolution\":\"High\",\n  \"sendTime\":\"2013-02-26T09:31:20.882Z\"\n}\n\n--Boundary_1_14413901_1361871080888\nContent-Type: text/plain\n\nHello, World!\n\n--Boundary_1_14413901_1361871080888--",
	        "type": "string"
	    }
	];
	/**
	 * Definition of options for sendSMS operation
	 */
	exports.sendSMSOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createsmsmessage.CreateSMSMessage"
	    }
	];
	/**
	 * Definition of options for listMessages operation
	 */
	exports.listMessagesOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "availability",
	        "type": "IListMessagesAvailability",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Alive",
	            "Deleted",
	            "Purged"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "IListMessagesDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "distinctConversations",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "messageType",
	        "type": "IListMessagesMessageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Fax",
	            "SMS",
	            "VoiceMail",
	            "Pager",
	            "Text"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "readStatus",
	        "type": "IListMessagesReadStatus",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Read",
	            "Unread"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadMessage operation
	 */
	exports.loadMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "number",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for updateMessage operation
	 */
	exports.updateMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "updatemessagerequest.UpdateMessageRequest"
	    }
	];
	/**
	 * Definition of options for deleteMessage operation
	 */
	exports.deleteMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "purge",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadMessageAttachment operation
	 */
	exports.loadMessageAttachmentOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "attachmentId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for syncMessages operation
	 */
	exports.syncMessagesOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ISyncMessagesDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "distinctConversations",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "messageType",
	        "type": "ISyncMessagesMessageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Fax",
	            "SMS",
	            "VoiceMail",
	            "Pager",
	            "Text"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "recordCount",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncToken",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncType",
	        "type": "ISyncMessagesSyncType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "FSync",
	            "ISync"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListMessagesAvailability) {
	    IListMessagesAvailability[IListMessagesAvailability["Alive"] = 'Alive'] = "Alive";
	    IListMessagesAvailability[IListMessagesAvailability["Deleted"] = 'Deleted'] = "Deleted";
	    IListMessagesAvailability[IListMessagesAvailability["Purged"] = 'Purged'] = "Purged";
	})(exports.IListMessagesAvailability || (exports.IListMessagesAvailability = {}));
	var IListMessagesAvailability = exports.IListMessagesAvailability;
	(function (IListMessagesDirection) {
	    IListMessagesDirection[IListMessagesDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListMessagesDirection[IListMessagesDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListMessagesDirection || (exports.IListMessagesDirection = {}));
	var IListMessagesDirection = exports.IListMessagesDirection;
	(function (IListMessagesMessageType) {
	    IListMessagesMessageType[IListMessagesMessageType["Fax"] = 'Fax'] = "Fax";
	    IListMessagesMessageType[IListMessagesMessageType["SMS"] = 'SMS'] = "SMS";
	    IListMessagesMessageType[IListMessagesMessageType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    IListMessagesMessageType[IListMessagesMessageType["Pager"] = 'Pager'] = "Pager";
	    IListMessagesMessageType[IListMessagesMessageType["Text"] = 'Text'] = "Text";
	})(exports.IListMessagesMessageType || (exports.IListMessagesMessageType = {}));
	var IListMessagesMessageType = exports.IListMessagesMessageType;
	(function (IListMessagesReadStatus) {
	    IListMessagesReadStatus[IListMessagesReadStatus["Read"] = 'Read'] = "Read";
	    IListMessagesReadStatus[IListMessagesReadStatus["Unread"] = 'Unread'] = "Unread";
	})(exports.IListMessagesReadStatus || (exports.IListMessagesReadStatus = {}));
	var IListMessagesReadStatus = exports.IListMessagesReadStatus;
	(function (ISyncMessagesDirection) {
	    ISyncMessagesDirection[ISyncMessagesDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ISyncMessagesDirection[ISyncMessagesDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ISyncMessagesDirection || (exports.ISyncMessagesDirection = {}));
	var ISyncMessagesDirection = exports.ISyncMessagesDirection;
	(function (ISyncMessagesMessageType) {
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Fax"] = 'Fax'] = "Fax";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["SMS"] = 'SMS'] = "SMS";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Pager"] = 'Pager'] = "Pager";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Text"] = 'Text'] = "Text";
	})(exports.ISyncMessagesMessageType || (exports.ISyncMessagesMessageType = {}));
	var ISyncMessagesMessageType = exports.ISyncMessagesMessageType;
	(function (ISyncMessagesSyncType) {
	    ISyncMessagesSyncType[ISyncMessagesSyncType["FSync"] = 'FSync'] = "FSync";
	    ISyncMessagesSyncType[ISyncMessagesSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.ISyncMessagesSyncType || (exports.ISyncMessagesSyncType = {}));
	var ISyncMessagesSyncType = exports.ISyncMessagesSyncType;
	
	
	/***/ },
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageattachmentinfo = __webpack_require__(79);
	var messagestorecallerinfo = __webpack_require__(80);
	var MessageInfo = (function (_super) {
	    __extends(MessageInfo, _super);
	    function MessageInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'attachments', Class: messageattachmentinfo.MessageAttachmentInfo, isArray: true, isRequired: false },
	            { property: 'availability', Class: MessageInfoAvailability, isArray: false, isRequired: false },
	            { property: 'conversationId', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'creationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'deliveryErrorCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'direction', Class: MessageInfoDirection, isArray: false, isRequired: false },
	            { property: 'faxPageCount', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'faxResolution', Class: MessageInfoFaxResolution, isArray: false, isRequired: false },
	            { property: 'from', Class: messagestorecallerinfo.MessageStoreCallerInfo, isArray: false, isRequired: false },
	            { property: 'lastModifiedTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'messageStatus', Class: MessageInfoMessageStatus, isArray: false, isRequired: false },
	            { property: 'pgToDepartment', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'priority', Class: MessageInfoPriority, isArray: false, isRequired: false },
	            { property: 'readStatus', Class: MessageInfoReadStatus, isArray: false, isRequired: false },
	            { property: 'smsDeliveryTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'smsSendingAttemptsCount', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'subject', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'to', Class: messagestorecallerinfo.MessageStoreCallerInfo, isArray: true, isRequired: false },
	            { property: 'type', Class: MessageInfoType, isArray: false, isRequired: false },
	            { property: 'vmTranscriptionStatus', Class: MessageInfoVmTranscriptionStatus, isArray: false, isRequired: false }
	        ];
	    };
	    MessageInfo.prototype.getClassName = function () {
	        return 'MessageInfo';
	    };
	    return MessageInfo;
	}(model.Model));
	exports.MessageInfo = MessageInfo;
	(function (MessageInfoAvailability) {
	    MessageInfoAvailability[MessageInfoAvailability["Alive"] = 'Alive'] = "Alive";
	    MessageInfoAvailability[MessageInfoAvailability["Deleted"] = 'Deleted'] = "Deleted";
	    MessageInfoAvailability[MessageInfoAvailability["Purged"] = 'Purged'] = "Purged";
	})(exports.MessageInfoAvailability || (exports.MessageInfoAvailability = {}));
	var MessageInfoAvailability = exports.MessageInfoAvailability;
	(function (MessageInfoDirection) {
	    MessageInfoDirection[MessageInfoDirection["Inbound"] = 'Inbound'] = "Inbound";
	    MessageInfoDirection[MessageInfoDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.MessageInfoDirection || (exports.MessageInfoDirection = {}));
	var MessageInfoDirection = exports.MessageInfoDirection;
	(function (MessageInfoFaxResolution) {
	    MessageInfoFaxResolution[MessageInfoFaxResolution["High"] = 'High'] = "High";
	    MessageInfoFaxResolution[MessageInfoFaxResolution["Low"] = 'Low'] = "Low";
	})(exports.MessageInfoFaxResolution || (exports.MessageInfoFaxResolution = {}));
	var MessageInfoFaxResolution = exports.MessageInfoFaxResolution;
	(function (MessageInfoMessageStatus) {
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Queued"] = 'Queued'] = "Queued";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Sent"] = 'Sent'] = "Sent";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Delivered"] = 'Delivered'] = "Delivered";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["DeliveryFailed"] = 'DeliveryFailed'] = "DeliveryFailed";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["SendingFailed"] = 'SendingFailed'] = "SendingFailed";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Received"] = 'Received'] = "Received";
	})(exports.MessageInfoMessageStatus || (exports.MessageInfoMessageStatus = {}));
	var MessageInfoMessageStatus = exports.MessageInfoMessageStatus;
	(function (MessageInfoPriority) {
	    MessageInfoPriority[MessageInfoPriority["Normal"] = 'Normal'] = "Normal";
	    MessageInfoPriority[MessageInfoPriority["High"] = 'High'] = "High";
	})(exports.MessageInfoPriority || (exports.MessageInfoPriority = {}));
	var MessageInfoPriority = exports.MessageInfoPriority;
	(function (MessageInfoReadStatus) {
	    MessageInfoReadStatus[MessageInfoReadStatus["Read"] = 'Read'] = "Read";
	    MessageInfoReadStatus[MessageInfoReadStatus["Unread"] = 'Unread'] = "Unread";
	})(exports.MessageInfoReadStatus || (exports.MessageInfoReadStatus = {}));
	var MessageInfoReadStatus = exports.MessageInfoReadStatus;
	(function (MessageInfoType) {
	    MessageInfoType[MessageInfoType["Fax"] = 'Fax'] = "Fax";
	    MessageInfoType[MessageInfoType["SMS"] = 'SMS'] = "SMS";
	    MessageInfoType[MessageInfoType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    MessageInfoType[MessageInfoType["Pager"] = 'Pager'] = "Pager";
	    MessageInfoType[MessageInfoType["Text"] = 'Text'] = "Text";
	})(exports.MessageInfoType || (exports.MessageInfoType = {}));
	var MessageInfoType = exports.MessageInfoType;
	(function (MessageInfoVmTranscriptionStatus) {
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["NotAvailable"] = 'NotAvailable'] = "NotAvailable";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["InProgress"] = 'InProgress'] = "InProgress";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["TimedOut"] = 'TimedOut'] = "TimedOut";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["Completed"] = 'Completed'] = "Completed";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["CompletedPartially"] = 'CompletedPartially'] = "CompletedPartially";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["Failed"] = 'Failed'] = "Failed";
	})(exports.MessageInfoVmTranscriptionStatus || (exports.MessageInfoVmTranscriptionStatus = {}));
	var MessageInfoVmTranscriptionStatus = exports.MessageInfoVmTranscriptionStatus;
	
	
	/***/ },
	/* 79 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessageAttachmentInfo = (function (_super) {
	    __extends(MessageAttachmentInfo, _super);
	    function MessageAttachmentInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageAttachmentInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: MessageAttachmentInfoType, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'vmDuration', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    MessageAttachmentInfo.prototype.getClassName = function () {
	        return 'MessageAttachmentInfo';
	    };
	    return MessageAttachmentInfo;
	}(model.Model));
	exports.MessageAttachmentInfo = MessageAttachmentInfo;
	(function (MessageAttachmentInfoType) {
	    MessageAttachmentInfoType[MessageAttachmentInfoType["AudioRecording"] = 'AudioRecording'] = "AudioRecording";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["AudioTranscription"] = 'AudioTranscription'] = "AudioTranscription";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["Text"] = 'Text'] = "Text";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["SourceDocument"] = 'SourceDocument'] = "SourceDocument";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["RenderedDocument"] = 'RenderedDocument'] = "RenderedDocument";
	})(exports.MessageAttachmentInfoType || (exports.MessageAttachmentInfoType = {}));
	var MessageAttachmentInfoType = exports.MessageAttachmentInfoType;
	
	
	/***/ },
	/* 80 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessageStoreCallerInfo = (function (_super) {
	    __extends(MessageStoreCallerInfo, _super);
	    function MessageStoreCallerInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageStoreCallerInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'messageStatus', Class: MessageStoreCallerInfoMessageStatus, isArray: false, isRequired: false },
	            { property: 'faxErrorCode', Class: MessageStoreCallerInfoFaxErrorCode, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    MessageStoreCallerInfo.prototype.getClassName = function () {
	        return 'MessageStoreCallerInfo';
	    };
	    return MessageStoreCallerInfo;
	}(model.Model));
	exports.MessageStoreCallerInfo = MessageStoreCallerInfo;
	(function (MessageStoreCallerInfoMessageStatus) {
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Queued"] = 'Queued'] = "Queued";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Sent"] = 'Sent'] = "Sent";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Delivered"] = 'Delivered'] = "Delivered";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["DeliveryFailed"] = 'DeliveryFailed'] = "DeliveryFailed";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["SendingFailed"] = 'SendingFailed'] = "SendingFailed";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Received"] = 'Received'] = "Received";
	})(exports.MessageStoreCallerInfoMessageStatus || (exports.MessageStoreCallerInfoMessageStatus = {}));
	var MessageStoreCallerInfoMessageStatus = exports.MessageStoreCallerInfoMessageStatus;
	(function (MessageStoreCallerInfoFaxErrorCode) {
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["Undefined"] = 'Undefined'] = "Undefined";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoFaxSendPermission"] = 'NoFaxSendPermission'] = "NoFaxSendPermission";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoInternationalPermission"] = 'NoInternationalPermission'] = "NoInternationalPermission";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoFaxMachine"] = 'NoFaxMachine'] = "NoFaxMachine";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["OutgoingCallError"] = 'OutgoingCallError'] = "OutgoingCallError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["RenderingFailed"] = 'RenderingFailed'] = "RenderingFailed";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["TooManyPages"] = 'TooManyPages'] = "TooManyPages";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ReturnToDBQueue"] = 'ReturnToDBQueue'] = "ReturnToDBQueue";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoCallTime"] = 'NoCallTime'] = "NoCallTime";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["WrongNumber"] = 'WrongNumber'] = "WrongNumber";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ProhibitedNumber"] = 'ProhibitedNumber'] = "ProhibitedNumber";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["InternalError"] = 'InternalError'] = "InternalError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["FaxSendingProhibited"] = 'FaxSendingProhibited'] = "FaxSendingProhibited";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ThePhoneIsBlacklisted"] = 'ThePhoneIsBlacklisted'] = "ThePhoneIsBlacklisted";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["UserNotFound"] = 'UserNotFound'] = "UserNotFound";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ConvertError"] = 'ConvertError'] = "ConvertError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["DBGeneralError"] = 'DBGeneralError'] = "DBGeneralError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["SkypeBillingFailed"] = 'SkypeBillingFailed'] = "SkypeBillingFailed";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["AccountSuspended"] = 'AccountSuspended'] = "AccountSuspended";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ProhibitedDestination"] = 'ProhibitedDestination'] = "ProhibitedDestination";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	})(exports.MessageStoreCallerInfoFaxErrorCode || (exports.MessageStoreCallerInfoFaxErrorCode = {}));
	var MessageStoreCallerInfoFaxErrorCode = exports.MessageStoreCallerInfoFaxErrorCode;
	
	
	/***/ },
	/* 81 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageinfo = __webpack_require__(78);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var MessageList = (function (_super) {
	    __extends(MessageList, _super);
	    function MessageList() {
	        _super.apply(this, arguments);
	    }
	    MessageList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: messageinfo.MessageInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MessageList.prototype.getClassName = function () {
	        return 'MessageList';
	    };
	    return MessageList;
	}(model.Model));
	exports.MessageList = MessageList;
	
	
	/***/ },
	/* 82 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageinfo = __webpack_require__(78);
	var messagessyncinfo = __webpack_require__(83);
	var MessageSync = (function (_super) {
	    __extends(MessageSync, _super);
	    function MessageSync() {
	        _super.apply(this, arguments);
	    }
	    MessageSync.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: messageinfo.MessageInfo, isArray: true, isRequired: true },
	            { property: 'syncInfo', Class: messagessyncinfo.MessagesSyncInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MessageSync.prototype.getClassName = function () {
	        return 'MessageSync';
	    };
	    return MessageSync;
	}(model.Model));
	exports.MessageSync = MessageSync;
	
	
	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessagesSyncInfo = (function (_super) {
	    __extends(MessagesSyncInfo, _super);
	    function MessagesSyncInfo() {
	        _super.apply(this, arguments);
	    }
	    MessagesSyncInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'syncType', Class: MessagesSyncInfoSyncType, isArray: false, isRequired: false },
	            { property: 'syncToken', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'syncTime', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    MessagesSyncInfo.prototype.getClassName = function () {
	        return 'MessagesSyncInfo';
	    };
	    return MessagesSyncInfo;
	}(model.Model));
	exports.MessagesSyncInfo = MessagesSyncInfo;
	(function (MessagesSyncInfoSyncType) {
	    MessagesSyncInfoSyncType[MessagesSyncInfoSyncType["FSync"] = 'FSync'] = "FSync";
	    MessagesSyncInfoSyncType[MessagesSyncInfoSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.MessagesSyncInfoSyncType || (exports.MessagesSyncInfoSyncType = {}));
	var MessagesSyncInfoSyncType = exports.MessagesSyncInfoSyncType;
	
	
	/***/ },
	/* 84 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var getsubscriptioninforesponse = __webpack_require__(85);
	var NotificationsSubscriptionAPI = (function (_super) {
	    __extends(NotificationsSubscriptionAPI, _super);
	    function NotificationsSubscriptionAPI() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Subscription
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>Creates a new subscription. To call this method with APNS transport type you have to specify endpoint_id attribute in get token request at authorization.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.create = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/subscription', options, exports.createOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Get Subscription
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>Returns the requested subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Light</p>
	     */
	    NotificationsSubscriptionAPI.prototype.load = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.loadOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Renew Subscription / Modify Event Filters
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>With empty request body - renews the existent subscription. If event filters specified - modifies the event filters for the existing subscription. The client application can extend or narrow the events for which it receives notifications in the frame
	     *     of one subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.update = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.updateOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Cancel Subscription
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Cancels the existent subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.remove = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.removeOptions), null);
	    };
	    return NotificationsSubscriptionAPI;
	}(client.Client));
	exports.NotificationsSubscriptionAPI = NotificationsSubscriptionAPI;
	/**
	 * Definition of options for create operation
	 */
	exports.createOptions = [
	    {
	        "name": "body",
	        "type": "createsubscriptionrequest.CreateSubscriptionRequest",
	        "in": "body",
	        "required": true
	    }
	];
	/**
	 * Definition of options for load operation
	 */
	exports.loadOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for update operation
	 */
	exports.updateOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "type": "modifysubscriptionrequest.ModifySubscriptionRequest",
	        "in": "body",
	        "required": true
	    }
	];
	/**
	 * Definition of options for remove operation
	 */
	exports.removeOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var notificationdeliverymode = __webpack_require__(86);
	var GetSubscriptionInfoResponse = (function (_super) {
	    __extends(GetSubscriptionInfoResponse, _super);
	    function GetSubscriptionInfoResponse() {
	        _super.apply(this, arguments);
	    }
	    GetSubscriptionInfoResponse.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'eventFilters', Class: null /* string[] */, isArray: true, isRequired: false },
	            { property: 'expirationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'expiresIn', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'status', Class: GetSubscriptionInfoResponseStatus, isArray: false, isRequired: false },
	            { property: 'creationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'deliveryMode', Class: notificationdeliverymode.NotificationDeliveryMode, isArray: false, isRequired: true }
	        ];
	    };
	    GetSubscriptionInfoResponse.prototype.getClassName = function () {
	        return 'GetSubscriptionInfoResponse';
	    };
	    return GetSubscriptionInfoResponse;
	}(model.Model));
	exports.GetSubscriptionInfoResponse = GetSubscriptionInfoResponse;
	(function (GetSubscriptionInfoResponseStatus) {
	    GetSubscriptionInfoResponseStatus[GetSubscriptionInfoResponseStatus["Active"] = 'Active'] = "Active";
	    GetSubscriptionInfoResponseStatus[GetSubscriptionInfoResponseStatus["Suspended"] = 'Suspended'] = "Suspended";
	})(exports.GetSubscriptionInfoResponseStatus || (exports.GetSubscriptionInfoResponseStatus = {}));
	var GetSubscriptionInfoResponseStatus = exports.GetSubscriptionInfoResponseStatus;
	
	
	/***/ },
	/* 86 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var NotificationDeliveryMode = (function (_super) {
	    __extends(NotificationDeliveryMode, _super);
	    function NotificationDeliveryMode() {
	        _super.apply(this, arguments);
	    }
	    NotificationDeliveryMode.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'transportType', Class: NotificationDeliveryModeTransportType, isArray: false, isRequired: true },
	            { property: 'encryption', Class: null /* boolean */, isArray: false, isRequired: true },
	            { property: 'address', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'subscriberKey', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'encryptionAlgorithm', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'encryptionKey', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'registrationId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'certificateName', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    NotificationDeliveryMode.prototype.getClassName = function () {
	        return 'NotificationDeliveryMode';
	    };
	    return NotificationDeliveryMode;
	}(model.Model));
	exports.NotificationDeliveryMode = NotificationDeliveryMode;
	(function (NotificationDeliveryModeTransportType) {
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["PubNub"] = 'PubNub'] = "PubNub";
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["APNS"] = 'APNS'] = "APNS";
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType['PubNub/APNS/VoIP'] = 'PubNub/APNS/VoIP'] = 'PubNub/APNS/VoIP';
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["WebHook"] = 'WebHook'] = "WebHook";
	})(exports.NotificationDeliveryModeTransportType || (exports.NotificationDeliveryModeTransportType = {}));
	var NotificationDeliveryModeTransportType = exports.NotificationDeliveryModeTransportType;
	
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var presenceinfo = __webpack_require__(88);
	var monitoredextensions = __webpack_require__(90);
	var Presence = (function (_super) {
	    __extends(Presence, _super);
	    function Presence() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension(s) Presence Status by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns presence status of an extension or several extensions by their ID(s). Batch request is supported, see Batch Requests for details.The presenceStatus is returned as Offline (the parameters telephonyStatus, message, userStatus and dndStatus are not
	     *     returned at all) for the following extension types: Department/Announcement Only/Take Messages Only (Voicemail)/Fax User/Paging Only Group/Shared Lines Group/IVR Menu/Application Extension/Park Location.If the user requests his/her own presence status,
	     *     the response contains actual presence status even if the status publication is turned off.Batch request is supported. For batch requests the number of extensions in one request is limited to 30. If more extensions are included in the request, the
	     *     error code 400 Bad Request is returned with the logical error code InvalidMultipartRequest and the corresponding message 'Extension Presence Info multipart request is limited to 30 extensions'.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadPresence</td>
	     *             <td>Getting user presence information</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Presence.prototype.getPresenceStatus = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/presence', options, exports.getPresenceStatusOptions), presenceinfo.PresenceInfo);
	    };
	    /**
	     * Get Monitored Extensions
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns list of lines - extensions which presence status can be indicated and monitored on BLF-enabled (Busy Lamp Field) devices.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadPresence</td>
	     *             <td>Getting user presence information</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Presence.prototype.listMonitoredExtensions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/presence/line', options, exports.listMonitoredExtensionsOptions), monitoredextensions.MonitoredExtensions);
	    };
	    return Presence;
	}(client.Client));
	exports.Presence = Presence;
	/**
	 * Definition of options for getPresenceStatus operation
	 */
	exports.getPresenceStatusOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listMonitoredExtensions operation
	 */
	exports.listMonitoredExtensionsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	
	
	/***/ },
	/* 88 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var presenceextensioninfo = __webpack_require__(89);
	var PresenceInfo = (function (_super) {
	    __extends(PresenceInfo, _super);
	    function PresenceInfo() {
	        _super.apply(this, arguments);
	    }
	    PresenceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'allowSeeMyPresence', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'dndStatus', Class: PresenceInfoDndStatus, isArray: false, isRequired: false },
	            { property: 'extension', Class: presenceextensioninfo.PresenceExtensionInfo, isArray: false, isRequired: false },
	            { property: 'message', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'pickUpCallsOnHold', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'presenceStatus', Class: PresenceInfoPresenceStatus, isArray: false, isRequired: false },
	            { property: 'ringOnMonitoredCall', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'telephonyStatus', Class: PresenceInfoTelephonyStatus, isArray: false, isRequired: false },
	            { property: 'userStatus', Class: PresenceInfoUserStatus, isArray: false, isRequired: false }
	        ];
	    };
	    PresenceInfo.prototype.getClassName = function () {
	        return 'PresenceInfo';
	    };
	    return PresenceInfo;
	}(model.Model));
	exports.PresenceInfo = PresenceInfo;
	(function (PresenceInfoDndStatus) {
	    PresenceInfoDndStatus[PresenceInfoDndStatus["TakeAllCalls"] = 'TakeAllCalls'] = "TakeAllCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["DoNotAcceptAnyCalls"] = 'DoNotAcceptAnyCalls'] = "DoNotAcceptAnyCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["DoNotAcceptDepartmentCalls"] = 'DoNotAcceptDepartmentCalls'] = "DoNotAcceptDepartmentCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["TakeDepartmentCallsOnly"] = 'TakeDepartmentCallsOnly'] = "TakeDepartmentCallsOnly";
	})(exports.PresenceInfoDndStatus || (exports.PresenceInfoDndStatus = {}));
	var PresenceInfoDndStatus = exports.PresenceInfoDndStatus;
	(function (PresenceInfoPresenceStatus) {
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Offline"] = 'Offline'] = "Offline";
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Busy"] = 'Busy'] = "Busy";
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Available"] = 'Available'] = "Available";
	})(exports.PresenceInfoPresenceStatus || (exports.PresenceInfoPresenceStatus = {}));
	var PresenceInfoPresenceStatus = exports.PresenceInfoPresenceStatus;
	(function (PresenceInfoTelephonyStatus) {
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["NoCall"] = 'NoCall'] = "NoCall";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["CallConnected"] = 'CallConnected'] = "CallConnected";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["Ringing"] = 'Ringing'] = "Ringing";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["OnHold"] = 'OnHold'] = "OnHold";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["ParkedCall"] = 'ParkedCall'] = "ParkedCall";
	})(exports.PresenceInfoTelephonyStatus || (exports.PresenceInfoTelephonyStatus = {}));
	var PresenceInfoTelephonyStatus = exports.PresenceInfoTelephonyStatus;
	(function (PresenceInfoUserStatus) {
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Offline"] = 'Offline'] = "Offline";
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Busy"] = 'Busy'] = "Busy";
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Available"] = 'Available'] = "Available";
	})(exports.PresenceInfoUserStatus || (exports.PresenceInfoUserStatus = {}));
	var PresenceInfoUserStatus = exports.PresenceInfoUserStatus;
	
	
	/***/ },
	/* 89 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PresenceExtensionInfo = (function (_super) {
	    __extends(PresenceExtensionInfo, _super);
	    function PresenceExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    PresenceExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    PresenceExtensionInfo.prototype.getClassName = function () {
	        return 'PresenceExtensionInfo';
	    };
	    return PresenceExtensionInfo;
	}(model.Model));
	exports.PresenceExtensionInfo = PresenceExtensionInfo;
	
	
	/***/ },
	/* 90 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var lineinfo = __webpack_require__(91);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var MonitoredExtensions = (function (_super) {
	    __extends(MonitoredExtensions, _super);
	    function MonitoredExtensions() {
	        _super.apply(this, arguments);
	    }
	    MonitoredExtensions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'records', Class: lineinfo.LineInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MonitoredExtensions.prototype.getClassName = function () {
	        return 'MonitoredExtensions';
	    };
	    return MonitoredExtensions;
	}(model.Model));
	exports.MonitoredExtensions = MonitoredExtensions;
	
	
	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var monitoredlinesextensioninfo = __webpack_require__(92);
	var LineInfo = (function (_super) {
	    __extends(LineInfo, _super);
	    function LineInfo() {
	        _super.apply(this, arguments);
	    }
	    LineInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extension', Class: monitoredlinesextensioninfo.MonitoredLinesExtensionInfo, isArray: false, isRequired: false }
	        ];
	    };
	    LineInfo.prototype.getClassName = function () {
	        return 'LineInfo';
	    };
	    return LineInfo;
	}(model.Model));
	exports.LineInfo = LineInfo;
	
	
	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MonitoredLinesExtensionInfo = (function (_super) {
	    __extends(MonitoredLinesExtensionInfo, _super);
	    function MonitoredLinesExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    MonitoredLinesExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: MonitoredLinesExtensionInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    MonitoredLinesExtensionInfo.prototype.getClassName = function () {
	        return 'MonitoredLinesExtensionInfo';
	    };
	    return MonitoredLinesExtensionInfo;
	}(model.Model));
	exports.MonitoredLinesExtensionInfo = MonitoredLinesExtensionInfo;
	(function (MonitoredLinesExtensionInfoType) {
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["User"] = 'User'] = "User";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["Department"] = 'Department'] = "Department";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.MonitoredLinesExtensionInfoType || (exports.MonitoredLinesExtensionInfoType = {}));
	var MonitoredLinesExtensionInfoType = exports.MonitoredLinesExtensionInfoType;
	
	
	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var ringoutstatus = __webpack_require__(94);
	var RingOut = (function (_super) {
	    __extends(RingOut, _super);
	    function RingOut() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Make RingOut Call
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Makes a 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    RingOut.prototype.makeRingOutCall = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout', options, exports.makeRingOutCallOptions), ringoutstatus.RingOutStatus);
	    };
	    /**
	     * Get Status of RingOut Call
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Returns the status of a 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    RingOut.prototype.getRingOutCallStatus = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout/{ringoutId}', options, exports.getRingOutCallStatusOptions), ringoutstatus.RingOutStatus);
	    };
	    /**
	     * Cancel RingOut Call
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Cancels the 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    RingOut.prototype.cancelRingOutCall = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout/{ringoutId}', options, exports.cancelRingOutCallOptions), null);
	    };
	    return RingOut;
	}(client.Client));
	exports.RingOut = RingOut;
	/**
	 * Definition of options for makeRingOutCall operation
	 */
	exports.makeRingOutCallOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "makeringoutrequest.MakeRingOutRequest"
	    }
	];
	/**
	 * Definition of options for getRingOutCallStatus operation
	 */
	exports.getRingOutCallStatusOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "ringoutId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for cancelRingOutCall operation
	 */
	exports.cancelRingOutCallOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "ringoutId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 94 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ringoutstatusinfo = __webpack_require__(95);
	var RingOutStatus = (function (_super) {
	    __extends(RingOutStatus, _super);
	    function RingOutStatus() {
	        _super.apply(this, arguments);
	    }
	    RingOutStatus.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'status', Class: ringoutstatusinfo.RingOutStatusInfo, isArray: false, isRequired: false }
	        ];
	    };
	    RingOutStatus.prototype.getClassName = function () {
	        return 'RingOutStatus';
	    };
	    return RingOutStatus;
	}(model.Model));
	exports.RingOutStatus = RingOutStatus;
	
	
	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var RingOutStatusInfo = (function (_super) {
	    __extends(RingOutStatusInfo, _super);
	    function RingOutStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    RingOutStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'callStatus', Class: RingOutStatusInfoCallStatus, isArray: false, isRequired: false },
	            { property: 'callerStatus', Class: RingOutStatusInfoCallerStatus, isArray: false, isRequired: false },
	            { property: 'calleeStatus', Class: RingOutStatusInfoCalleeStatus, isArray: false, isRequired: false }
	        ];
	    };
	    RingOutStatusInfo.prototype.getClassName = function () {
	        return 'RingOutStatusInfo';
	    };
	    return RingOutStatusInfo;
	}(model.Model));
	exports.RingOutStatusInfo = RingOutStatusInfo;
	(function (RingOutStatusInfoCallStatus) {
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCallStatus || (exports.RingOutStatusInfoCallStatus = {}));
	var RingOutStatusInfoCallStatus = exports.RingOutStatusInfoCallStatus;
	(function (RingOutStatusInfoCallerStatus) {
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCallerStatus || (exports.RingOutStatusInfoCallerStatus = {}));
	var RingOutStatusInfoCallerStatus = exports.RingOutStatusInfoCallerStatus;
	(function (RingOutStatusInfoCalleeStatus) {
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCalleeStatus || (exports.RingOutStatusInfoCalleeStatus = {}));
	var RingOutStatusInfoCalleeStatus = exports.RingOutStatusInfoCalleeStatus;
	
	
	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var extensionforwardingnumberlist = __webpack_require__(97);
	var forwardingnumberinfo = __webpack_require__(98);
	var ForwardingNumbers = (function (_super) {
	    __extends(ForwardingNumbers, _super);
	    function ForwardingNumbers() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension Forwarding Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Returns the list of extension phone numbers used for call forwarding and call flip. The returned list contains all the extension phone numbers that are used for call forwarding and call flip.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    ForwardingNumbers.prototype.listExtensionForwardingNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number', options, exports.listExtensionForwardingNumbersOptions), extensionforwardingnumberlist.ExtensionForwardingNumberList);
	    };
	    /**
	     * Create Forwarding Number
	     *
	     * <p style='font-style:italic;'>Since 1.0.12 (Release 6.4)</p>
	     * <p>Adds a new forwarding number to the forwarding number list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.createExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number', options, exports.createExtensionForwardingNumberOptions), forwardingnumberinfo.ForwardingNumberInfo);
	    };
	    /**
	     * Update Forwarding Number by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.24 (Release 8.0)</p>
	     * <p>Updates an existent forwarding number from the forwarding number list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.updateExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number/{forwardingNumberId}', options, exports.updateExtensionForwardingNumberOptions), forwardingnumberinfo.ForwardingNumberInfo);
	    };
	    /**
	     * Delete Forwarding Number by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.24 (Release 8.0)</p>
	     * <p>Deletes a forwarding number from the forwarding number list by its ID.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.deleteExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number/{forwardingNumberId}', options, exports.deleteExtensionForwardingNumberOptions), null);
	    };
	    return ForwardingNumbers;
	}(client.Client));
	exports.ForwardingNumbers = ForwardingNumbers;
	/**
	 * Definition of options for listExtensionForwardingNumbers operation
	 */
	exports.listExtensionForwardingNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for createExtensionForwardingNumber operation
	 */
	exports.createExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createforwardingnumberrequest.CreateForwardingNumberRequest"
	    }
	];
	/**
	 * Definition of options for updateExtensionForwardingNumber operation
	 */
	exports.updateExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "forwardingNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "updateforwardingnumberrequest.UpdateForwardingNumberRequest"
	    }
	];
	/**
	 * Definition of options for deleteExtensionForwardingNumber operation
	 */
	exports.deleteExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "forwardingNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 97 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var forwardingnumberinfo = __webpack_require__(98);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionForwardingNumberList = (function (_super) {
	    __extends(ExtensionForwardingNumberList, _super);
	    function ExtensionForwardingNumberList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionForwardingNumberList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: forwardingnumberinfo.ForwardingNumberInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: false },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionForwardingNumberList.prototype.getClassName = function () {
	        return 'ExtensionForwardingNumberList';
	    };
	    return ExtensionForwardingNumberList;
	}(model.Model));
	exports.ExtensionForwardingNumberList = ExtensionForwardingNumberList;
	
	
	/***/ },
	/* 98 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ForwardingNumberInfo = (function (_super) {
	    __extends(ForwardingNumberInfo, _super);
	    function ForwardingNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    ForwardingNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'label', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'features', Class: ForwardingNumberInfoFeatures, isArray: false, isRequired: false },
	            { property: 'flipNumber', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    ForwardingNumberInfo.prototype.getClassName = function () {
	        return 'ForwardingNumberInfo';
	    };
	    return ForwardingNumberInfo;
	}(model.Model));
	exports.ForwardingNumberInfo = ForwardingNumberInfo;
	(function (ForwardingNumberInfoFeatures) {
	    ForwardingNumberInfoFeatures[ForwardingNumberInfoFeatures["CallFlip"] = 'CallFlip'] = "CallFlip";
	    ForwardingNumberInfoFeatures[ForwardingNumberInfoFeatures["CallForwarding"] = 'CallForwarding'] = "CallForwarding";
	})(exports.ForwardingNumberInfoFeatures || (exports.ForwardingNumberInfoFeatures = {}));
	var ForwardingNumberInfoFeatures = exports.ForwardingNumberInfoFeatures;
	
	
	/***/ },
	/* 99 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var blockednumberinfo = __webpack_require__(100);
	var blockednumberslist = __webpack_require__(101);
	var BlockedNumbers = (function (_super) {
	    __extends(BlockedNumbers, _super);
	    function BlockedNumbers() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Add Blocked Number
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.blockNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number', options, exports.blockNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Get Blocked Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers which are specified by the user to block inbound calls and SMS messages.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    BlockedNumbers.prototype.listBlockedNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number', options, exports.listBlockedNumbersOptions), blockednumberslist.BlockedNumbersList);
	    };
	    /**
	     * Get Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    BlockedNumbers.prototype.loadBlockedNumber = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.loadBlockedNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Update Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.updateBlockedNumber = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.updateBlockedNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Delete Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.unblockNumber = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.unblockNumberOptions), null);
	    };
	    return BlockedNumbers;
	}(client.Client));
	exports.BlockedNumbers = BlockedNumbers;
	/**
	 * Definition of options for blockNumber operation
	 */
	exports.blockNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listBlockedNumbers operation
	 */
	exports.listBlockedNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadBlockedNumber operation
	 */
	exports.loadBlockedNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for updateBlockedNumber operation
	 */
	exports.updateBlockedNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for unblockNumber operation
	 */
	exports.unblockNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 100 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BlockedNumberInfo = (function (_super) {
	    __extends(BlockedNumberInfo, _super);
	    function BlockedNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    BlockedNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    BlockedNumberInfo.prototype.getClassName = function () {
	        return 'BlockedNumberInfo';
	    };
	    return BlockedNumberInfo;
	}(model.Model));
	exports.BlockedNumberInfo = BlockedNumberInfo;
	
	
	/***/ },
	/* 101 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var blockednumberinfo = __webpack_require__(100);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var BlockedNumbersList = (function (_super) {
	    __extends(BlockedNumbersList, _super);
	    function BlockedNumbersList() {
	        _super.apply(this, arguments);
	    }
	    BlockedNumbersList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: blockednumberinfo.BlockedNumberInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    BlockedNumbersList.prototype.getClassName = function () {
	        return 'BlockedNumbersList';
	    };
	    return BlockedNumbersList;
	}(model.Model));
	exports.BlockedNumbersList = BlockedNumbersList;
	
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=ringcentral-client.js.map

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _reduxHelper = __webpack_require__(136);
	
	var _eventEmitter = __webpack_require__(137);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['store', 'mapper', 'prefix', 'actions', 'emitter']);
	
	/**
	 * @function
	 * @param {Object} state
	 * @return {Object}
	 * @description Default reducer if module does not has its own reducer.
	 */
	function defaultReducer(state) {
	  if (typeof state === 'undefined') return {};
	  return state;
	}
	/**
	 * @function
	 * @param {Object} state
	 * @return {Object}
	 * @description Default parent state to module state mapper.
	 */
	function defaultMapper(state) {
	  return state;
	}
	
	/**
	 * @class
	 * @default
	 * @description Base module class.
	 */
	
	var RcModule = function () {
	  /**
	   * @constructor
	   */
	
	  function RcModule(_ref) {
	    var _this = this;
	
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var _ref$stateMapper = _ref.stateMapper;
	    var stateMapper = _ref$stateMapper === undefined ? defaultMapper : _ref$stateMapper;
	    var prefix = _ref.prefix;
	    var actions = _ref.actions;
	    (0, _classCallCheck3.default)(this, RcModule);
	
	    // Extending EventEmitter breaks some mechanic, so we wire emitter up like this instead.
	    this[symbols.emitter] = new _eventEmitter2.default();
	    this[symbols.mapper] = stateMapper;
	    this[symbols.prefix] = prefix;
	    this[symbols.actions] = actions && (0, _reduxHelper.prefixActions)(actions, prefix);
	    registerStoreHandler(function (store) {
	      _this[symbols.store] = store;
	    });
	  }
	
	  /**
	   * @function
	   * @param {String} event
	   * @param {Function} handler
	   * @return {Function} Unregister function.
	   */
	
	
	  (0, _createClass3.default)(RcModule, [{
	    key: 'on',
	    value: function on(event, handler) {
	      var _this2 = this;
	
	      this[symbols.emitter].on(event, handler);
	      return function () {
	        _this2[symbols.emitter].off(event, handler);
	      };
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {Function)} handler
	     * @return {Function} Unregister function.
	     */
	
	  }, {
	    key: 'once',
	    value: function once(event, handler) {
	      var _this3 = this;
	
	      this[symbols.emitter].once(event, handler);
	      return function () {
	        _this3[symbols.emitter].off(event, handler);
	      };
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {...args} args
	     */
	
	  }, {
	    key: 'emit',
	    value: function emit(event) {
	      var _symbols$emitter;
	
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      (_symbols$emitter = this[symbols.emitter]).emit.apply(_symbols$emitter, [event].concat(args));
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {Function} handler
	     */
	
	  }, {
	    key: 'off',
	    value: function off(event, handler) {
	      this[symbols.emitter].off(event, handler);
	    }
	  }, {
	    key: 'state',
	    get: function get() {
	      return this[symbols.mapper](this[symbols.store].getState());
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return defaultReducer;
	    }
	  }, {
	    key: 'store',
	    get: function get() {
	      return this[symbols.store];
	    }
	  }, {
	    key: 'prefix',
	    get: function get() {
	      return this[symbols.prefix];
	    }
	  }, {
	    key: 'actions',
	    get: function get() {
	      return this[symbols.actions];
	    }
	  }]);
	  return RcModule;
	}();
	
	exports.default = RcModule;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class
	 * @description Helper class for creating a symbol mapping
	 */
	
	var SymbolMap = function (_Enum) {
	  (0, _inherits3.default)(SymbolMap, _Enum);
	
	  /**
	   * @constructor
	   * @param {String[]} keys
	   */
	
	  function SymbolMap(keys) {
	    (0, _classCallCheck3.default)(this, SymbolMap);
	
	    var definition = {};
	    keys.forEach(function (key) {
	      definition[key] = (0, _symbol2.default)();
	    });
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(SymbolMap).call(this, definition));
	  }
	
	  return SymbolMap;
	}(_enum2.default);
	
	exports.default = SymbolMap;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasOwnProperty = {}.hasOwnProperty;
	var DEFINITION = (0, _symbol2.default)();
	var VALUES = (0, _symbol2.default)();
	
	var Enum = function () {
	  function Enum(definition) {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, Enum);
	
	    this[DEFINITION] = (0, _assign2.default)({}, definition);
	    this[VALUES] = new _set2.default();
	
	    var _loop = function _loop(key) {
	      if (hasOwnProperty.call(definition, key)) {
	        (0, _defineProperty2.default)(_this, key, {
	          get: function get() {
	            return this[DEFINITION][key];
	          },
	
	          enumerable: true
	        });
	        _this[VALUES].add(_this[DEFINITION][key]);
	      }
	    };
	
	    for (var key in definition) {
	      _loop(key);
	    }
	  }
	
	  (0, _createClass3.default)(Enum, null, [{
	    key: "hasValue",
	    value: function hasValue(value) {
	      return this[VALUES].has(value);
	    }
	  }]);
	  return Enum;
	}();
	
	/*
	 * //with Proxy support
	 *const enumHandler = {
	 *  get(target, key) {
	 *    return target[key];
	 *  },
	 *  set() {
	 *    return;
	 *  }
	 *};
	 *Enum = class Enum extends Proxy {
	 *  constructor(definition) {
	 *    super(Object.assign({}, definition), enumHandler);
	 *  }
	 *}
	 */
	
	
	exports.default = Enum;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ActionMap = undefined;
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	exports.prefixActions = prefixActions;
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * @class
	 * @description helper class for creating redux action definition maps
	 */
	
	var ActionMap = exports.ActionMap = function (_Enum) {
	  (0, _inherits3.default)(ActionMap, _Enum);
	
	  /**
	   * @constructor
	   * @param {String[]} actions - list of action strings
	   * @extends Enum
	   */
	
	  function ActionMap() {
	    var actions = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
	    (0, _classCallCheck3.default)(this, ActionMap);
	
	    var definition = {};
	    actions.forEach(function (action) {
	      definition[action] = prefix !== '' ? prefix + '-' + action : action;
	    });
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ActionMap).call(this, definition));
	  }
	
	  return ActionMap;
	}(_enum2.default);
	
	/**
	 * @function
	 * @description helper function to return a prefixed action definition maps
	 */
	
	
	function prefixActions(actions, prefix) {
	  if (!prefix || prefix === '') return actions;
	  var definition = {};
	  for (var action in actions) {
	    if (hasOwnProperty.call(actions, action)) {
	      definition[action] = prefix + '-' + action;
	    }
	  }
	  return new _enum2.default(definition);
	}

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var d        = __webpack_require__(138)
	  , callable = __webpack_require__(151)
	
	  , apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }
	
	  , on, once, off, emit, methods, descriptors, base;
	
	on = function (type, listener) {
		var data;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];
	
		return this;
	};
	
	once = function (type, listener) {
		var once, self;
	
		callable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});
	
		once.__eeOnceListener__ = listener;
		return this;
	};
	
	off = function (type, listener) {
		var data, listeners, candidate, i;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];
	
		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}
	
		return this;
	};
	
	emit = function (type) {
		var i, l, listener, listeners, args;
	
		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;
	
		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];
	
			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};
	
	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};
	
	descriptors = {
		on: d(on),
		once: d(once),
		off: d(off),
		emit: d(emit)
	};
	
	base = defineProperties({}, descriptors);
	
	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign        = __webpack_require__(139)
	  , normalizeOpts = __webpack_require__(146)
	  , isCallable    = __webpack_require__(147)
	  , contains      = __webpack_require__(148)
	
	  , d;
	
	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}
	
		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};
	
	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}
	
		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(140)()
		? Object.assign
		: __webpack_require__(141);


/***/ },
/* 140 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== 'function') return false;
		obj = { foo: 'raz' };
		assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
		return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var keys  = __webpack_require__(142)
	  , value = __webpack_require__(145)
	
	  , max = Math.max;
	
	module.exports = function (dest, src/*, …srcn*/) {
		var error, i, l = max(arguments.length, 2), assign;
		dest = Object(value(dest));
		assign = function (key) {
			try { dest[key] = src[key]; } catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < l; ++i) {
			src = arguments[i];
			keys(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(143)()
		? Object.keys
		: __webpack_require__(144);


/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		try {
			Object.keys('primitive');
			return true;
		} catch (e) { return false; }
	};


/***/ },
/* 144 */
/***/ function(module, exports) {

	'use strict';
	
	var keys = Object.keys;
	
	module.exports = function (object) {
		return keys(object == null ? object : Object(object));
	};


/***/ },
/* 145 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (value) {
		if (value == null) throw new TypeError("Cannot use null or undefined");
		return value;
	};


/***/ },
/* 146 */
/***/ function(module, exports) {

	'use strict';
	
	var forEach = Array.prototype.forEach, create = Object.create;
	
	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};
	
	module.exports = function (options/*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (options == null) return;
			process(Object(options), result);
		});
		return result;
	};


/***/ },
/* 147 */
/***/ function(module, exports) {

	// Deprecated
	
	'use strict';
	
	module.exports = function (obj) { return typeof obj === 'function'; };


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(149)()
		? String.prototype.contains
		: __webpack_require__(150);


/***/ },
/* 149 */
/***/ function(module, exports) {

	'use strict';
	
	var str = 'razdwatrzy';
	
	module.exports = function () {
		if (typeof str.contains !== 'function') return false;
		return ((str.contains('dwa') === true) && (str.contains('foo') === false));
	};


/***/ },
/* 150 */
/***/ function(module, exports) {

	'use strict';
	
	var indexOf = String.prototype.indexOf;
	
	module.exports = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};


/***/ },
/* 151 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (fn) {
		if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
		return fn;
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _reduxHelper = __webpack_require__(136);
	
	var _redux = __webpack_require__(153);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['reducer']);
	
	function getSettingsReducer(prefix) {
	  return function (state, action) {
	    if (typeof state === 'undefined') return {};
	
	    return state;
	  };
	}
	
	var Settings = function (_RcModule) {
	  (0, _inherits3.default)(Settings, _RcModule);
	
	  function Settings(options) {
	    (0, _classCallCheck3.default)(this, Settings);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Settings).call(this, (0, _extends3.default)({}, options)));
	
	    _this[symbols.reducer] = {
	      base: getSettingsReducer(_this.prefix)
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(Settings, [{
	    key: 'registerReducer',
	    value: function registerReducer(name, reducer) {
	      this[symbols.reducer][name] = reducer;
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _redux.combineReducers)(this[symbols.reducer]);
	    }
	  }]);
	  return Settings;
	}(_rcModule2.default);
	
	exports.default = Settings;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(154);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(161);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(163);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(164);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(165);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(162);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(155);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(159);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var getPrototype = __webpack_require__(156),
	    isHostObject = __webpack_require__(157),
	    isObjectLike = __webpack_require__(158);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object,
	 *  else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ },
/* 156 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetPrototype = Object.getPrototypeOf;
	
	/**
	 * Gets the `[[Prototype]]` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {null|Object} Returns the `[[Prototype]]`.
	 */
	function getPrototype(value) {
	  return nativeGetPrototype(Object(value));
	}
	
	module.exports = getPrototype;


/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 158 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(160)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 160 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(154);
	
	var _isPlainObject = __webpack_require__(155);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(162);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ },
/* 162 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(165);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 165 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _brandActions = __webpack_require__(167);
	
	var _brandActions2 = _interopRequireDefault(_brandActions);
	
	var _brandReducer = __webpack_require__(168);
	
	var _brandReducer2 = _interopRequireDefault(_brandReducer);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['initialState']);
	
	var Brand = function (_RcModule) {
	  (0, _inherits3.default)(Brand, _RcModule);
	
	  function Brand(_ref) {
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var _ref$stateMapper = _ref.stateMapper;
	    var stateMapper = _ref$stateMapper === undefined ? function (state) {
	      return state.brand;
	    } : _ref$stateMapper;
	    var prefix = _ref.prefix;
	    var id = _ref.id;
	    var name = _ref.name;
	    (0, _classCallCheck3.default)(this, Brand);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Brand).call(this, {
	      registerStoreHandler: registerStoreHandler,
	      stateMapper: stateMapper,
	      prefix: prefix,
	      actions: _brandActions2.default
	    }));
	
	    _this[symbols.initialState] = {
	      id: id,
	      name: name
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(Brand, [{
	    key: 'reducer',
	    get: function get() {
	      return (0, _brandReducer2.default)(this[symbols.initialState], this.prefix);
	    }
	  }, {
	    key: 'id',
	    get: function get() {
	      return this.state.id;
	    }
	  }, {
	    key: 'name',
	    get: function get() {
	      return this.state.name;
	    }
	  }]);
	  return Brand;
	}(_rcModule2.default);
	
	exports.default = Brand;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['setBrand']);

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getReducer;
	
	var _brandActions = __webpack_require__(167);
	
	var _brandActions2 = _interopRequireDefault(_brandActions);
	
	var _reduxHelper = __webpack_require__(136);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getReducer(initialState, prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_brandActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	
	    if (!action) return state;
	    switch (action.type) {
	      case actions.setBrand:
	        return (0, _assign2.default)({}, state, {
	          name: action.payload.name,
	          id: action.payload.id
	        });
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getIterator2 = __webpack_require__(66);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _toConsumableArray2 = __webpack_require__(170);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	var _authActions = __webpack_require__(188);
	
	var _authActions2 = _interopRequireDefault(_authActions);
	
	var _authReducer = __webpack_require__(189);
	
	var _authReducer2 = _interopRequireDefault(_authReducer);
	
	var _authEvents = __webpack_require__(190);
	
	var _utils = __webpack_require__(191);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['platform', 'emitter', 'beforeLogoutHandlers']);
	
	var ENUMS = new _enum2.default({
	  loginStatus: _loginStatus2.default
	});
	
	/**
	 * @class
	 * @description Authentication module
	 */
	
	var Auth = function (_RcModule) {
	  (0, _inherits3.default)(Auth, _RcModule);
	
	  /**
	   * @function
	   */
	
	  function Auth(options) {
	    var _this2 = this;
	
	    (0, _classCallCheck3.default)(this, Auth);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Auth).call(this, (0, _extends3.default)({}, options, {
	      actions: _authActions2.default
	    })));
	
	    var platform = options.platform;
	
	
	    _this[symbols.platform] = platform;
	    _this[symbols.beforeLogoutHandlers] = new _set2.default();
	
	    // load info on login
	    platform.on(platform.events.loginSuccess, function () {
	      _this.store.dispatch({
	        type: _this.actions.loginSuccess
	      });
	      _utils.emit.call(_this, _authEvents.authEventTypes.loginStatusChanged, _this.state.status);
	    });
	    // loginError
	    platform.on(platform.events.loginError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.loginError,
	        error: error
	      });
	    });
	    // unload info on logout
	    platform.on(platform.events.logoutSuccess, function () {
	      _this.store.dispatch({
	        type: _this.actions.logoutSuccess
	      });
	      // this.emit(authEvents.userInfoCleared);
	    });
	
	    platform.on(platform.events.logoutError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.logoutError,
	        error: error
	      });
	    });
	
	    platform.on(platform.events.refreshError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.refreshError,
	        error: error
	      });
	    });
	
	    // load info if already logged in
	    (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	      var loggedIn;
	      return _regenerator2.default.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return platform.loggedIn();
	
	            case 2:
	              loggedIn = _context.sent;
	
	              _this.store.dispatch({
	                type: _this.actions.init,
	                status: loggedIn ? _loginStatus2.default.loggedIn : _loginStatus2.default.notLoggedIn
	              });
	              _this.emit(_authEvents.authEventTypes.authEventTypes, _this.state.status);
	
	            case 5:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this2);
	    }))();
	    return _this;
	  }
	
	  (0, _createClass3.default)(Auth, [{
	    key: 'login',
	
	    /**
	     * @function
	     * @async
	     * @description Login function using username and password
	     */
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(_ref) {
	        var username = _ref.username;
	        var password = _ref.password;
	        var extension = _ref.extension;
	        var remember = _ref.remember;
	        return _regenerator2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                this.store.dispatch({
	                  type: this.actions.login,
	                  payload: {
	                    username: username,
	                    password: password,
	                    extension: extension,
	                    remember: remember
	                  }
	                });
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingIn);
	                _context2.next = 4;
	                return this[symbols.platform].login({
	                  username: username,
	                  password: password,
	                  extension: extension,
	                  remember: remember
	                });
	
	              case 4:
	                return _context2.abrupt('return', _context2.sent);
	
	              case 5:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));
	
	      function login(_x) {
	        return ref.apply(this, arguments);
	      }
	
	      return login;
	    }()
	
	    /**
	     * @function
	     * @async
	     * @description Authorize using OAauth code
	     */
	
	  }, {
	    key: 'authorize',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(_ref2) {
	        var code = _ref2.code;
	        var redirectUri = _ref2.redirectUri;
	        return _regenerator2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                this.store.dispatch({
	                  type: this.actions.login,
	                  payload: {
	                    code: code,
	                    redirectUri: redirectUri
	                  }
	                });
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingIn);
	                _context3.next = 4;
	                return this[symbols.platform].login({
	                  code: code,
	                  redirectUri: redirectUri
	                });
	
	              case 4:
	                return _context3.abrupt('return', _context3.sent);
	
	              case 5:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));
	
	      function authorize(_x2) {
	        return ref.apply(this, arguments);
	      }
	
	      return authorize;
	    }()
	
	    /**
	     * @function
	     * @async
	     * @description Log the user out
	     */
	
	  }, {
	    key: 'logout',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	        var _this3 = this;
	
	        var handlers, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;
	
	        return _regenerator2.default.wrap(function _callee5$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                // deal with removing subscriptions
	
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingOut);
	                handlers = [].concat((0, _toConsumableArray3.default)(this[symbols.beforeLogoutHandlers]));
	                _iteratorNormalCompletion = true;
	                _didIteratorError = false;
	                _iteratorError = undefined;
	                _context6.prev = 5;
	                _loop = _regenerator2.default.mark(function _loop() {
	                  var handler;
	                  return _regenerator2.default.wrap(function _loop$(_context5) {
	                    while (1) {
	                      switch (_context5.prev = _context5.next) {
	                        case 0:
	                          handler = _step.value;
	                          _context5.prev = 1;
	                          _context5.next = 4;
	                          return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	                            return _regenerator2.default.wrap(function _callee4$(_context4) {
	                              while (1) {
	                                switch (_context4.prev = _context4.next) {
	                                  case 0:
	                                    return _context4.abrupt('return', handler());
	
	                                  case 1:
	                                  case 'end':
	                                    return _context4.stop();
	                                }
	                              }
	                            }, _callee4, _this3);
	                          }))();
	
	                        case 4:
	                          _context5.next = 8;
	                          break;
	
	                        case 6:
	                          _context5.prev = 6;
	                          _context5.t0 = _context5['catch'](1);
	
	                        case 8:
	                        case 'end':
	                          return _context5.stop();
	                      }
	                    }
	                  }, _loop, _this3, [[1, 6]]);
	                });
	                _iterator = (0, _getIterator3.default)(handlers);
	
	              case 8:
	                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
	                  _context6.next = 13;
	                  break;
	                }
	
	                return _context6.delegateYield(_loop(), 't0', 10);
	
	              case 10:
	                _iteratorNormalCompletion = true;
	                _context6.next = 8;
	                break;
	
	              case 13:
	                _context6.next = 19;
	                break;
	
	              case 15:
	                _context6.prev = 15;
	                _context6.t1 = _context6['catch'](5);
	                _didIteratorError = true;
	                _iteratorError = _context6.t1;
	
	              case 19:
	                _context6.prev = 19;
	                _context6.prev = 20;
	
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                  _iterator.return();
	                }
	
	              case 22:
	                _context6.prev = 22;
	
	                if (!_didIteratorError) {
	                  _context6.next = 25;
	                  break;
	                }
	
	                throw _iteratorError;
	
	              case 25:
	                return _context6.finish(22);
	
	              case 26:
	                return _context6.finish(19);
	
	              case 27:
	                _context6.next = 29;
	                return this[symbols.platform].logout();
	
	              case 29:
	                return _context6.abrupt('return', _context6.sent);
	
	              case 30:
	              case 'end':
	                return _context6.stop();
	            }
	          }
	        }, _callee5, this, [[5, 15, 19, 27], [20,, 22, 26]]);
	      }));
	
	      function logout() {
	        return ref.apply(this, arguments);
	      }
	
	      return logout;
	    }()
	    /**
	     * @function
	     * @param {Function} handler
	     * @returns {Function}
	     */
	
	  }, {
	    key: 'addBeforeLogoutHandler',
	    value: function addBeforeLogoutHandler(handler) {
	      var _this4 = this;
	
	      this[symbols.beforeLogoutHandlers].add(handler);
	      return function () {
	        _this4[symbols.beforeLogoutHandlers].remove(handler);
	      };
	    }
	    /**
	     * @function
	     * @param {Function} handler
	     */
	
	  }, {
	    key: 'removeBeforeLogoutHandler',
	    value: function removeBeforeLogoutHandler(handler) {
	      this[symbols.beforeLogoutHandlers].remove(handler);
	    }
	  }, {
	    key: 'isLoggedIn',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
	        return _regenerator2.default.wrap(function _callee6$(_context7) {
	          while (1) {
	            switch (_context7.prev = _context7.next) {
	              case 0:
	                _context7.next = 2;
	                return this[symbols.platform].loggedIn();
	
	              case 2:
	                return _context7.abrupt('return', _context7.sent);
	
	              case 3:
	              case 'end':
	                return _context7.stop();
	            }
	          }
	        }, _callee6, this);
	      }));
	
	      function isLoggedIn() {
	        return ref.apply(this, arguments);
	      }
	
	      return isLoggedIn;
	    }()
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _authReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'status',
	    get: function get() {
	      return this.state.status;
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _authEvents.authEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _authEvents.authEventTypes;
	    }
	  }, {
	    key: 'enums',
	    get: function get() {
	      return ENUMS;
	    }
	  }]);
	  return Auth;
	}(_rcModule2.default);
	
	exports.default = Auth;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(171);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(172), __esModule: true };

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(173);
	module.exports = __webpack_require__(8).Array.from;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(9)
	  , $export        = __webpack_require__(6)
	  , toObject       = __webpack_require__(39)
	  , call           = __webpack_require__(109)
	  , isArrayIter    = __webpack_require__(110)
	  , toLength       = __webpack_require__(30)
	  , createProperty = __webpack_require__(174)
	  , getIterFn      = __webpack_require__(69);
	
	$export($export.S + $export.F * !__webpack_require__(175)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(12)
	  , createDesc      = __webpack_require__(20);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(61)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(177);


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(178);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(121)))

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (fn) {
	  return function () {
	    var gen = fn.apply(this, arguments);
	    return new _promise2.default(function (resolve, reject) {
	      function step(key, arg) {
	        try {
	          var info = gen[key](arg);
	          var value = info.value;
	        } catch (error) {
	          reject(error);
	          return;
	        }
	
	        if (info.done) {
	          resolve(value);
	        } else {
	          return _promise2.default.resolve(value).then(function (value) {
	            return step("next", value);
	          }, function (err) {
	            return step("throw", err);
	          });
	        }
	      }
	
	      return step("next");
	    });
	  };
	};

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(181), __esModule: true };

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	__webpack_require__(62);
	__webpack_require__(48);
	__webpack_require__(182);
	module.exports = __webpack_require__(8).Promise;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(54)
	  , global             = __webpack_require__(7)
	  , ctx                = __webpack_require__(9)
	  , classof            = __webpack_require__(65)
	  , $export            = __webpack_require__(6)
	  , isObject           = __webpack_require__(14)
	  , anObject           = __webpack_require__(13)
	  , aFunction          = __webpack_require__(10)
	  , anInstance         = __webpack_require__(107)
	  , forOf              = __webpack_require__(108)
	  , setProto           = __webpack_require__(98).set
	  , speciesConstructor = __webpack_require__(183)
	  , task               = __webpack_require__(184).set
	  , microtask          = __webpack_require__(186)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(61)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(106)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(60)($Promise, PROMISE);
	__webpack_require__(111)(PROMISE);
	Wrapper = __webpack_require__(8)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(175)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(13)
	  , aFunction = __webpack_require__(10)
	  , SPECIES   = __webpack_require__(61)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(9)
	  , invoke             = __webpack_require__(185)
	  , html               = __webpack_require__(59)
	  , cel                = __webpack_require__(18)
	  , global             = __webpack_require__(7)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(27)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 185 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(7)
	  , macrotask = __webpack_require__(184).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(27)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  pending: 'PENDING', // after init, before status from platform is determined
	  notLoggedIn: 'NOT_LOGGED_IN',
	  loggingIn: 'LOGGING_IN',
	  loggedIn: 'LOGGED_IN',
	  loggingOut: 'LOGGING_OUT'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['login', 'loginSuccess', 'loginError', 'logout', 'logoutSuccess', 'logoutError', 'refresh', 'refreshSuccess', 'refreshError', 'init'], 'auth');

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getAuthReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _authActions = __webpack_require__(188);
	
	var _authActions2 = _interopRequireDefault(_authActions);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  status: _loginStatus2.default.pending,
	  authError: null
	};
	
	function getAuthReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_authActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      case actions.init:
	        return (0, _assign2.default)({}, state, { status: action.status });
	
	      case actions.login:
	        return {
	          status: _loginStatus2.default.loggingIn,
	          authError: null
	        };
	
	      case actions.loginSuccess:
	        return {
	          status: _loginStatus2.default.loggedIn,
	          authError: null
	        };
	
	      case actions.logoutSuccess:
	        return {
	          status: _loginStatus2.default.notLoggedIn,
	          authError: null
	        };
	
	      case actions.loginError:
	        return {
	          state: _loginStatus2.default.notLoggedIn,
	          authError: action.error
	        };
	
	      case actions.logoutError:
	        return {
	          status: _loginStatus2.default.loggedIn,
	          authError: action.error
	        };
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.authEventTypes = exports.authEvents = undefined;
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinitions = (0, _extends3.default)({}, _loginStatus2.default);
	
	var authEvents = exports.authEvents = new _enum2.default(eventDefinitions);
	
	var eventTypeDefinitions = {
	  loginStatusChanged: 'LOGIN_STATUS_CHANGED'
	};
	
	var authEventTypes = exports.authEventTypes = new _enum2.default(eventTypeDefinitions);

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.sleep = exports.fetchList = undefined;
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var fetchList = exports.fetchList = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(fn) {
	    var fetchedPages, totalPages, list, data;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            fetchedPages = 0;
	            totalPages = 1;
	            list = [];
	
	          case 3:
	            if (!(fetchedPages < totalPages)) {
	              _context.next = 12;
	              break;
	            }
	
	            fetchedPages++;
	            _context.next = 7;
	            return fn({
	              page: fetchedPages
	            });
	
	          case 7:
	            data = _context.sent;
	
	            totalPages = data.paging.totalPages;
	            list = list.concat(data.records);
	            _context.next = 3;
	            break;
	
	          case 12:
	            return _context.abrupt('return', list);
	
	          case 13:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	  return function fetchList(_x) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @param {String} eventType
	 * @param {String} event
	 * @description Helper function to emit eventTyped events and the event itself
	 */
	
	
	/**
	 * @function
	 * @param {Number} t
	 */
	
	var sleep = exports.sleep = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(t) {
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            return _context2.abrupt('return', new _promise2.default(function (resolve) {
	              setTimeout(resolve, t);
	            }));
	
	          case 1:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function sleep(_x2) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	exports.extractData = extractData;
	exports.emit = emit;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function extractData(model) {
	  if (Array.isArray(model)) {
	    return model.map(function (item) {
	      return extractData(item);
	    });
	  } else if ((typeof model === 'undefined' ? 'undefined' : (0, _typeof3.default)(model)) === 'object') {
	    var data = {};
	    for (var key in model) {
	      if (key[0] !== '_' && model.hasOwnProperty(key)) {
	        data[key] = extractData(model[key]);
	      }
	    }
	    return data;
	  }
	  return model;
	}
	
	function emit(eventType, event) {
	  for (var _len = arguments.length, payloads = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    payloads[_key - 2] = arguments[_key];
	  }
	
	  this.emit.apply(this, [event].concat(payloads));
	  this.emit.apply(this, [eventType, event].concat(payloads));
	}

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _stringify = __webpack_require__(193);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _subscriptionActions = __webpack_require__(195);
	
	var _subscriptionActions2 = _interopRequireDefault(_subscriptionActions);
	
	var _subscriptionReducer = __webpack_require__(196);
	
	var _subscriptionReducer2 = _interopRequireDefault(_subscriptionReducer);
	
	var _subscriptionEvents = __webpack_require__(197);
	
	var _subscriptionStatus = __webpack_require__(198);
	
	var _subscriptionStatus2 = _interopRequireDefault(_subscriptionStatus);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _utils = __webpack_require__(191);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['auth', 'sdk', 'platform', 'subscription', 'filterCache']);
	
	var filterRegex = {
	  message: /message-store$/,
	  presence: /presence(\?detailedTelephonyState=true)?$/,
	  telephony: /presence\?detailedTelephonyState=true$/,
	  line: /presence\/line$/,
	  linePresence: /presence\/line\/presence(\?detailedTelephonyState=true)?$/,
	  lineTelephony: /presence\/line\/presence\?detailedTelephonyState=true$/
	};
	
	/**
	 * @function
	 * @param {Object} message
	 * @description Handles messages delivered by the subscripton
	 */
	function messageHandler(message) {
	  var _this = this;
	
	  // determine which events the message falls under
	  var events = [];
	  if (filterRegex.message.test(message.event)) {
	    events.push('message');
	  } else if (filterRegex.line.test(message.event)) {
	    events.push('line');
	  } else if (filterRegex.linePresence.test(message.event)) {
	    events.push('linePresence');
	    if (filterRegex.lineTelephony.test(message.event)) events.push('lineTelephony');
	  } else if (filterRegex.presence.test(message.event)) {
	    events.push('presence');
	    if (filterRegex.telephony.test(message.event)) events.push('telephony');
	  }
	  // dispatch the message in redux manner
	  this.store.dispatch({
	    type: this.actions.notification,
	    eventTypes: events,
	    payload: message
	  });
	  // emit the messages as events
	  events.forEach(function (event) {
	    _utils.emit.call(_this, _subscriptionEvents.subscriptionEventTypes.notification, _subscriptionEvents.subscriptionEvents[event], message);
	  });
	}
	function init() {
	  var _this2 = this;
	
	  var platform = this[symbols.platform];
	  this[symbols.subscription] = this[symbols.sdk].createSubscription();
	  var ownerId = platform.auth().data().owner_id;
	  var cacheKey = null;
	  if (typeof localStorage !== 'undefined') {
	    cacheKey = this.prefix + '-sub-' + ownerId;
	    var cachedSubscription = localStorage.getItem(cacheKey);
	    if (cachedSubscription) {
	      try {
	        this.base.setSubscription(JSON.parse(cachedSubscription));
	      } catch (e) {
	        /* do nothing */
	      }
	    }
	  }
	
	  this.base.setEventFilters(this.filters);
	
	  this.base.on(this.base.events.notification, function (message) {
	    messageHandler.call(_this2, message);
	  });
	  this.base.on(this.base.events.removeSuccess, function () {
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.notSubscribed,
	      subscription: null
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	  });
	  this.base.on(this.base.events.removeError, function () {
	    // TODO
	  });
	  this.base.on(this.base.events.renewSuccess, function () {
	    if (cacheKey) {
	      localStorage.setItem(cacheKey, (0, _stringify2.default)(_this2.base.subscription()));
	    }
	    var oldStatus = _this2.status;
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.subscribed,
	      subscription: _this2.base.subscription()
	    });
	    if (oldStatus !== _this2.status) {
	      _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	    }
	  });
	  this.base.on(this.base.events.renewError, function (error) {
	    // TODO handle 429
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.notSubscribed,
	      subscription: null
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	    _this2.base.reset().setEventFilters(_this2.filters).register().catch(function (e) {});
	  });
	  this.base.on(this.base.events.subscribeSuccess, function () {
	    if (cacheKey) {
	      localStorage.setItem(cacheKey, (0, _stringify2.default)(_this2.base.subscription()));
	    }
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.subscribed,
	      subscription: _this2.base.subscription()
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	  });
	  this.base.on(this.base.events.subscribeError, function (error) {
	    // TODO
	    // handle 429
	    // handle subscription limit
	  });
	
	  if (this.filters.length) {
	    this.base.register().catch(function () {/* do nothing */});
	  }
	}
	
	var Subscription = function (_RcModule) {
	  (0, _inherits3.default)(Subscription, _RcModule);
	
	  function Subscription(options) {
	    var _this4 = this;
	
	    (0, _classCallCheck3.default)(this, Subscription);
	
	    var _this3 = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Subscription).call(this, (0, _extends3.default)({}, options, {
	      registerStoreHandler: function registerStoreHandler(handler) {
	        options.registerStoreHandler(function (store) {
	          // set store to self first
	          handler(store);
	
	          // update store with cachedFilters
	          _this3.store.dispatch({
	            type: _this3.actions.updateFilters,
	            filters: _this3.filters
	          });
	
	          _this3[symbols.filterCache] = null;
	        });
	      },
	      actions: _subscriptionActions2.default
	    })));
	
	    var auth = options.auth;
	    var platform = options.platform;
	    var sdk = options.sdk;
	
	    _this3[symbols.auth] = auth;
	    _this3[symbols.platform] = platform;
	    _this3[symbols.sdk] = sdk;
	    _this3[symbols.subscription] = null;
	
	    // caches filters before redux store is created
	    _this3[symbols.filterCache] = [];
	
	    auth.on(auth.events.loggedIn, function () {
	      init.call(_this3);
	    });
	
	    auth.on(auth.events.loggedOut, function () {
	      if (_this3.base) {
	        _this3.reset();
	      }
	    });
	
	    // platform.on(platform.events.loginSuccess, () => {
	    //   this::init();
	    // });
	    // platform.on(platform.events.logoutSuccess, async () => {
	    //   if (this.base) {
	    //     await this.reset();
	    //   }
	    //   this[symbols.subscription] = null;
	    // });
	
	    auth.addBeforeLogoutHandler((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	      return _regenerator2.default.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return _this3.reset();
	
	            case 2:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this4);
	    })));
	
	    // (async () => {
	    //   if (await platform.loggedIn()) {
	    //     this::init();
	    //   }
	    // })();
	    return _this3;
	  }
	
	  (0, _createClass3.default)(Subscription, [{
	    key: 'subscribe',
	    value: function subscribe(event) {
	      // TODO normalized error
	      if (!_enum2.default.hasValue.call(_subscriptionEvents.subscriptionEvents, event)) {
	        throw new Error('event is not recognized');
	      }
	
	      if (this.filters.indexOf(event) === -1) {
	        var newFilters = this.filters.slice();
	        newFilters.push(event);
	        if (this.base) {
	          this.base.setEventFilters(newFilters);
	          this.store.dispatch({
	            type: this.actions.updateFilters,
	            filters: newFilters
	          });
	          this.base.register().catch(function () {/* do nothing */});
	        } else {
	          this[symbols.filterCache] = newFilters;
	        }
	      }
	    }
	  }, {
	    key: 'unsubscribe',
	    value: function unsubscribe(event) {
	      // TODO normalized error
	      if (!_enum2.default.hasValue.call(_subscriptionEvents.subscriptionEvents, event)) {
	        throw new Error('event is not recognized');
	      }
	      var idx = this.filters.indexOf(event);
	      if (this.filters.indexOf(event) > -1) {
	        var newFilters = this.filters.slice();
	        newFilters.splice(idx, 1);
	        if (this.base) {
	          this.base.setEventFilters(newFilters);
	          this.store.dispatch({
	            type: this.actions.updateFilters,
	            filters: newFilters
	          });
	          if (newFilters.length) {
	            this.base.register().catch(function () {/* do nothing */});
	          } else {
	            this.base.remove();
	          }
	        } else {
	          this[symbols.filterCache] = newFilters;
	        }
	      }
	    }
	  }, {
	    key: 'reset',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	        var oldStatus;
	        return _regenerator2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.prev = 0;
	
	                if (!this.base) {
	                  _context2.next = 9;
	                  break;
	                }
	
	                if (!(this.status === _subscriptionStatus2.default.subscribed)) {
	                  _context2.next = 7;
	                  break;
	                }
	
	                _context2.next = 5;
	                return this.base.remove();
	
	              case 5:
	                _context2.next = 9;
	                break;
	
	              case 7:
	                _context2.next = 9;
	                return this.base.reset();
	
	              case 9:
	                _context2.next = 13;
	                break;
	
	              case 11:
	                _context2.prev = 11;
	                _context2.t0 = _context2['catch'](0);
	
	              case 13:
	                this[symbols.subscription] = null;
	                oldStatus = this.status;
	
	                this.store.dispatch({
	                  type: this.actions.updateStatus,
	                  status: _subscriptionStatus2.default.notSubscribed,
	                  subscription: null
	                });
	                if (oldStatus !== this.status) {
	                  _utils.emit.call(this, _subscriptionEvents.subscriptionEventTypes.statusChanged, this.status);
	                }
	
	              case 17:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this, [[0, 11]]);
	      }));
	
	      function reset() {
	        return ref.apply(this, arguments);
	      }
	
	      return reset;
	    }()
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _subscriptionReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'status',
	    get: function get() {
	      return this.state.status;
	    }
	  }, {
	    key: 'filters',
	    get: function get() {
	      return this[symbols.filterCache] || this.state.filters;
	    }
	  }, {
	    key: 'base',
	    get: function get() {
	      return this[symbols.subscription];
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _subscriptionEvents.subscriptionEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _subscriptionEvents.subscriptionEventTypes;
	    }
	  }]);
	  return Subscription;
	}(_rcModule2.default);
	
	exports.default = Subscription;

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(194), __esModule: true };

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(8)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['updateFilters', 'notification', 'updateStatus'], 'subscription');

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getSubscriptionReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _subscriptionActions = __webpack_require__(195);
	
	var _subscriptionActions2 = _interopRequireDefault(_subscriptionActions);
	
	var _subscriptionEvents = __webpack_require__(197);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  cacheKey: null,
	  filters: [],
	  status: _subscriptionEvents.subscriptionEvents.pending
	};
	
	function getSubscriptionReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_subscriptionActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	      case actions.updateStatus:
	        return (0, _assign2.default)({}, state, {
	          status: action.status,
	          subscription: actions.subscription
	        });
	
	      case actions.updateFilters:
	        return (0, _assign2.default)({}, state, {
	          filters: action.filters.slice()
	        });
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.subscriptionEventTypes = exports.subscriptionEvents = undefined;
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _subscriptionStatus = __webpack_require__(198);
	
	var _subscriptionStatus2 = _interopRequireDefault(_subscriptionStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinition = (0, _extends3.default)({
	  message: '/restapi/v1.0/account/~/extension/~/message-store',
	  presence: '/restapi/v1.0/account/~/extension/~/presence',
	  telephony: '/restapi/v1.0/account/~/extension/~/presence?detailedTelephonyState=true',
	  line: '/restapi/v1.0/account/~/extension/~/presence/line',
	  linePresence: '/restapi/v1.0/account/~/extension/~/presence/line/presence',
	  lineTelephony: '/restapi/v1.0/account/~/extension/~/presence/line/presence?detailedTelephonyState=true'
	}, _subscriptionStatus2.default);
	
	var subscriptionEvents = exports.subscriptionEvents = new _enum2.default(eventDefinition);
	
	var eventTypeDefinition = {
	  notification: 'NOTIFICATION',
	  statusChanged: 'STATUS_CHANGED'
	};
	
	var subscriptionEventTypes = exports.subscriptionEventTypes = new _enum2.default(eventTypeDefinition);

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  pending: 'PENDING',
	  subscribed: 'SUBSCRIBED',
	  notSubscribed: 'NOT_SUBSCRIBED'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	// const initialState = {
	//   test: true,
	// };
	
	// function getUserSettingsReducer(prefix) {
	//   return (state, action) => {
	//     if (typeof state === 'undefined') return Object.assign({}, initialState);
	//     if (!action) return state;
	//     switch (action.type) {
	//       default:
	//         return state;
	//     }
	//   };
	// }
	
	/**
	 * @function
	 * @param {String} dataType
	 * @param {function} loadFunction - async loader function returning a promise
	 * @return {Promise}
	 * @description Generic data loading logic with events
	 */
	
	var loadData = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(dataType, loadFunction) {
	    var payload;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            this.store.dispatch({
	              type: this.actions['load' + dataType]
	            });
	            this.emit(_userEvents.userEvents['load' + dataType]);
	            _context.prev = 2;
	            _context.next = 5;
	            return loadFunction.call(this);
	
	          case 5:
	            payload = _context.sent;
	
	            this.store.dispatch({
	              type: this.actions['load' + dataType + 'Success'],
	              payload: payload
	            });
	            _utils.emit.call(this, _userEvents.userEventTypes.userInfoChanged, _userEvents.userEvents['load' + dataType + 'Success']);
	            _context.next = 15;
	            break;
	
	          case 10:
	            _context.prev = 10;
	            _context.t0 = _context['catch'](2);
	
	            this.store.dispatch({
	              type: this.actions['load' + dataType + 'Failed']
	            });
	            this.emit(_userEvents.userEvents['load' + dataType + 'Failed']);
	            throw _context.t0;
	
	          case 15:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this, [[2, 10]]);
	  }));
	  return function loadData(_x, _x2) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @return {Promise<Object>}
	 * @description Fetch account info and extract the data
	 */
	
	
	var extractAccountInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return this[symbols.api].account().loadAccount();
	
	          case 2:
	            _context2.t0 = _context2.sent;
	            return _context2.abrupt('return', (0, _utils.extractData)(_context2.t0));
	
	          case 4:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function extractAccountInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadAccountInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	    return _regenerator2.default.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.next = 2;
	            return loadData.call(this, 'AccountInfo', extractAccountInfo);
	
	          case 2:
	            return _context3.abrupt('return', _context3.sent);
	
	          case 3:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	  return function loadAccountInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractExtensionInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	    return _regenerator2.default.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.next = 2;
	            return this[symbols.api].extension().loadExtensionInfo();
	
	          case 2:
	            _context4.t0 = _context4.sent;
	            return _context4.abrupt('return', (0, _utils.extractData)(_context4.t0));
	
	          case 4:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this);
	  }));
	  return function extractExtensionInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadExtensionInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	    return _regenerator2.default.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return loadData.call(this, 'ExtensionInfo', extractExtensionInfo);
	
	          case 2:
	            return _context5.abrupt('return', _context5.sent);
	
	          case 3:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this);
	  }));
	  return function loadExtensionInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractDialingPlans = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
	    var _this = this;
	
	    return _regenerator2.default.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            _context6.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this[symbols.api].account().listDialingPlans(options);
	            });
	
	          case 2:
	            _context6.t0 = _context6.sent;
	            return _context6.abrupt('return', (0, _utils.extractData)(_context6.t0));
	
	          case 4:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this);
	  }));
	  return function extractDialingPlans() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadDialingPlans = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7() {
	    return _regenerator2.default.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            _context7.next = 2;
	            return loadData.call(this, 'DialingPlans', extractDialingPlans);
	
	          case 2:
	            return _context7.abrupt('return', _context7.sent);
	
	          case 3:
	          case 'end':
	            return _context7.stop();
	        }
	      }
	    }, _callee7, this);
	  }));
	  return function loadDialingPlans() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractPhoneNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8() {
	    var _this2 = this;
	
	    return _regenerator2.default.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            _context8.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this2[symbols.api].extension().listExtensionPhoneNumbers(options);
	            });
	
	          case 2:
	            _context8.t0 = _context8.sent;
	            return _context8.abrupt('return', (0, _utils.extractData)(_context8.t0));
	
	          case 4:
	          case 'end':
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this);
	  }));
	  return function extractPhoneNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadPhoneNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9() {
	    return _regenerator2.default.wrap(function _callee9$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            _context9.next = 2;
	            return loadData.call(this, 'PhoneNumbers', extractPhoneNumbers);
	
	          case 2:
	            return _context9.abrupt('return', _context9.sent);
	
	          case 3:
	          case 'end':
	            return _context9.stop();
	        }
	      }
	    }, _callee9, this);
	  }));
	  return function loadPhoneNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractForwardingNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
	    var _this3 = this;
	
	    return _regenerator2.default.wrap(function _callee10$(_context10) {
	      while (1) {
	        switch (_context10.prev = _context10.next) {
	          case 0:
	            _context10.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this3[symbols.api].forwardingNumbers().listExtensionForwardingNumbers(options);
	            });
	
	          case 2:
	            _context10.t0 = _context10.sent;
	            return _context10.abrupt('return', (0, _utils.extractData)(_context10.t0));
	
	          case 4:
	          case 'end':
	            return _context10.stop();
	        }
	      }
	    }, _callee10, this);
	  }));
	  return function extractForwardingNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadForwardingNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11() {
	    return _regenerator2.default.wrap(function _callee11$(_context11) {
	      while (1) {
	        switch (_context11.prev = _context11.next) {
	          case 0:
	            _context11.next = 2;
	            return loadData.call(this, 'ForwardingNumbers', extractForwardingNumbers);
	
	          case 2:
	            return _context11.abrupt('return', _context11.sent);
	
	          case 3:
	          case 'end':
	            return _context11.stop();
	        }
	      }
	    }, _callee11, this);
	  }));
	  return function loadForwardingNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractBlockedNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12() {
	    var _this4 = this;
	
	    return _regenerator2.default.wrap(function _callee12$(_context12) {
	      while (1) {
	        switch (_context12.prev = _context12.next) {
	          case 0:
	            _context12.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this4[symbols.api].blockedNumbers().listBlockedNumbers(options);
	            });
	
	          case 2:
	            _context12.t0 = _context12.sent;
	            return _context12.abrupt('return', (0, _utils.extractData)(_context12.t0));
	
	          case 4:
	          case 'end':
	            return _context12.stop();
	        }
	      }
	    }, _callee12, this);
	  }));
	  return function extractBlockedNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadBlockedNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
	    return _regenerator2.default.wrap(function _callee13$(_context13) {
	      while (1) {
	        switch (_context13.prev = _context13.next) {
	          case 0:
	            _context13.next = 2;
	            return loadData.call(this, 'BlockedNumbers', extractBlockedNumbers);
	
	          case 2:
	            return _context13.abrupt('return', _context13.sent);
	
	          case 3:
	          case 'end':
	            return _context13.stop();
	        }
	      }
	    }, _callee13, this);
	  }));
	  return function loadBlockedNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @return {Promise}
	 */
	
	
	var loadInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14() {
	    return _regenerator2.default.wrap(function _callee14$(_context14) {
	      while (1) {
	        switch (_context14.prev = _context14.next) {
	          case 0:
	            _context14.prev = 0;
	            _context14.next = 3;
	            return _promise2.default.all([loadAccountInfo.call(this), loadExtensionInfo.call(this), loadDialingPlans.call(this), loadPhoneNumbers.call(this), loadForwardingNumbers.call(this), loadBlockedNumbers.call(this)]);
	
	          case 3:
	            _context14.next = 8;
	            break;
	
	          case 5:
	            _context14.prev = 5;
	            _context14.t0 = _context14['catch'](0);
	
	            // TODO send error out
	            console.log(_context14.t0);
	
	          case 8:
	          case 'end':
	            return _context14.stop();
	        }
	      }
	    }, _callee14, this, [[0, 5]]);
	  }));
	  return function loadInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @class User
	 * @extends RcModule
	 * @default
	 * @export
	 */
	
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _utils = __webpack_require__(191);
	
	var _userActions = __webpack_require__(200);
	
	var _userActions2 = _interopRequireDefault(_userActions);
	
	var _userReducer = __webpack_require__(201);
	
	var _userReducer2 = _interopRequireDefault(_userReducer);
	
	var _userEvents = __webpack_require__(202);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['api', 'platform', 'settings']);
	var User = function (_RcModule) {
	  (0, _inherits3.default)(User, _RcModule);
	
	  /**
	   * @function
	   * @param {Object} options
	   */
	
	  function User(options) {
	    var _this6 = this;
	
	    (0, _classCallCheck3.default)(this, User);
	
	    var _this5 = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(User).call(this, (0, _extends3.default)({}, options, {
	      actions: _userActions2.default
	    })));
	
	    var api = options.api;
	    var platform = options.platform;
	    var settings = options.settings;
	
	    _this5[symbols.api] = api;
	    _this5[symbols.platform] = platform;
	    _this5[symbols.settings] = settings;
	
	    // settings.registerReducer('user', getUserSettingsReducer());
	
	    // load info on login
	    platform.on(platform.events.loginSuccess, function () {
	      loadInfo.call(_this5);
	    });
	    // unload info on logout
	    platform.on(platform.events.logoutSuccess, function () {
	      _this5.store.dispatch({
	        type: _this5.actions.clearUserInfo
	      });
	      // this.emit(userEvents.userInfoCleared);
	    });
	
	    // load info if already logged in
	    (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15() {
	      return _regenerator2.default.wrap(function _callee15$(_context15) {
	        while (1) {
	          switch (_context15.prev = _context15.next) {
	            case 0:
	              _context15.next = 2;
	              return platform.loggedIn();
	
	            case 2:
	              if (!_context15.sent) {
	                _context15.next = 5;
	                break;
	              }
	
	              _context15.next = 5;
	              return loadInfo.call(_this5);
	
	            case 5:
	            case 'end':
	              return _context15.stop();
	          }
	        }
	      }, _callee15, _this6);
	    }))();
	
	    /**
	     * TODO:
	     *   1. Dialing Plan Checking
	     */
	    return _this5;
	  }
	
	  (0, _createClass3.default)(User, [{
	    key: 'reducer',
	    get: function get() {
	      return (0, _userReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _userEvents.userEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _userEvents.userEventTypes;
	    }
	  }, {
	    key: 'directNumbers',
	    get: function get() {
	      return this.state.phoneNumbers.filter(function (n) {
	        return n.usageType === 'DirectNumber';
	      });
	    }
	  }, {
	    key: 'mainCompanyNumber',
	    get: function get() {
	      return this.state.phoneNumbers.find(function (n) {
	        return n.usageType === 'MainCompanyNumber';
	      });
	    }
	  }, {
	    key: 'dialingPlans',
	    get: function get() {
	      return this.state.dialingPlans;
	    }
	  }, {
	    key: 'extensionNumber',
	    get: function get() {
	      return this.state.extensionInfo.extensionNumber;
	    }
	  }, {
	    key: 'smsNumbers',
	    get: function get() {
	      return this.state.phoneNumbers.filter(function (n) {
	        return n.features.indexOf('SmsSender') > -1;
	      });
	    }
	  }]);
	  return User;
	}(_rcModule2.default);
	
	exports.default = User;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['clearUserInfo', 'loadAccountInfo', 'loadAccountInfoSuccess', 'loadAccountInfoFailed', 'loadExtensionInfo', 'loadExtensionInfoSuccess', 'loadExtensionInfoFailed', 'loadDialingPlans', 'loadDialingPlansSuccess', 'loadDialingPlansFailed', 'loadPhoneNumbers', 'loadPhoneNumbersSuccess', 'loadPhoneNumbersFailed', 'loadForwardingNumbers', 'loadForwardingNumbersSuccess', 'loadForwardingNumbersFailed', 'loadBlockedNumbers', 'loadBlockedNumbersSuccess', 'loadBlockedNumbersFailed'], 'user');

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getUserReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _userActions = __webpack_require__(200);
	
	var _userActions2 = _interopRequireDefault(_userActions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  accountInfo: null,
	  accountInfoLoading: false,
	  accountInfoError: null,
	
	  extensionInfo: null,
	  extensionInfoLoading: false,
	  extensionInfoError: null,
	
	  dialingPlans: [],
	  dialingPlansLoading: false,
	  dialingPlansError: null,
	
	  phoneNumbers: [],
	  phoneNumbersLoading: false,
	  phoneNumbersError: null,
	
	  forwardingNumbers: [],
	  forwardingNumbersLoading: false,
	  forwardingNumbersError: null,
	
	  blockedNumbers: [],
	  blockedNumbersLoading: false,
	  blockedNumbersError: null
	};
	
	function getUserReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_userActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      // account info
	      case actions.loadAccountInfo:
	        return (0, _assign2.default)({}, state, {
	          accountInfoLoading: true
	        });
	      case actions.loadAccountInfoSuccess:
	        return (0, _assign2.default)({}, state, {
	          accountInfo: action.payload,
	          accountInfoLoading: false,
	          accountInfoError: null
	        });
	      case actions.loadAccountInfoFailed:
	        return (0, _assign2.default)({}, state, {
	          accountInfoLoading: false,
	          accountInfoError: action.error
	        });
	
	      // extension info
	      case actions.loadExtensionInfo:
	        return (0, _assign2.default)({}, state, {
	          extensionInfoLoading: true
	        });
	      case actions.loadExtensionInfoSuccess:
	        return (0, _assign2.default)({}, state, {
	          extensionInfo: action.payload,
	          extensionInfoLoading: false,
	          extensionInfoError: null
	        });
	      case actions.loadExtensionInfoFailed:
	        return (0, _assign2.default)({}, state, {
	          extensionInfoLoading: false,
	          extensionInfoError: action.error
	        });
	
	      // dialing plans
	      case actions.loadDialingPlans:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: true
	        });
	      case actions.loadDialingPlansSuccess:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: false,
	          dialingPlans: action.payload
	        });
	      case action.loadDialingPlansFailed:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: false,
	          dialingPlansError: action.error
	        });
	
	      // phone numbers
	      case actions.loadPhoneNumbers:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: true
	        });
	      case actions.loadPhoneNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: false,
	          phoneNumbers: action.payload
	        });
	      case action.loadPhoneNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: false,
	          phoneNumbersError: action.error
	        });
	
	      // forwarding numbers
	      case actions.loadForwardingNumbers:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: true
	        });
	      case actions.loadForwardingNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: false,
	          forwardingNumbers: action.payload
	        });
	      case action.loadForwardingNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: false,
	          forwardingNumbersError: action.error
	        });
	
	      // blocked numbers
	      case actions.loadBlockedNumbers:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: true
	        });
	      case actions.loadBlockedNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: false,
	          blockedNumbers: action.payload
	        });
	      case action.loadBlockedNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: false,
	          blockedNumbersError: action.error
	        });
	
	      case action.clearUserInfo:
	        return (0, _assign2.default)({}, initialState);
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.userEventTypes = exports.userEvents = undefined;
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinitions = {
	  userInfoLoaded: 'USER_INFO_LOADED',
	  userInfoCleared: 'USER_INFO_CLEARED',
	
	  loadAccountInfo: 'LOAD_ACCOUNT_INFO',
	  loadAccountInfoSuccess: 'LOAD_ACCOUNT_INFO_SUCCESS',
	  loadAccountInfoFailed: 'LOAD_ACCOUNT_INFO_FAILED',
	
	  loadExtensionInfo: 'LOAD_EXTENSION_INFO',
	  loadExtensionInfoSuccess: 'LOAD_EXTENSION_INFO_SUCCESS',
	  loadExtensionInfoFailed: 'LOAD_EXTENSION_INFO_FAILED',
	
	  loadDialingPlans: 'LOAD_DIALING_PLANS',
	  loadDialingPlansSuccess: 'LOAD_DIALING_PLANS_SUCCESS',
	  loadDialingPlansFailed: 'LOAD_DIALING_PLANS_FAILED',
	
	  loadPhoneNumbers: 'LOAD_PHONE_NUMBERS',
	  loadPhoneNumbersSuccess: 'LOAD_PHONE_NUMBERS_SUCCESS',
	  loadPhoneNumbersFailed: 'LOAD_PHONE_NUMBERS_FAILED',
	
	  loadForwardingNumbers: 'LOAD_FORWARDING_NUMBERS',
	  loadForwardingNumbersSuccess: 'LOAD_FORWARDING_NUMBERS_SUCCESS',
	  loadForwardingNumbersFailed: 'LOAD_FORWARDING_NUMBERS_FAILED',
	
	  loadBlockedNumbers: 'LOAD_BLOCKED_NUMBERS',
	  loadBlockedNumbersSuccess: 'LOAD_BLOCKED_NUMBERS_SUCCESS',
	  loadBlockedNumbersFailed: 'LOAD_BLOCKED_NUMBERS_FAILED'
	};
	
	var userEvents = exports.userEvents = new _enum2.default(eventDefinitions);
	
	var eventTypeDefinitions = {
	  userInfoChanged: 'USER_INFO_CHANGED'
	};
	
	var userEventTypes = exports.userEventTypes = new _enum2.default(eventTypeDefinitions);

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var initPhoneInstance = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	    var info;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return this[symbols.platform].post('/client-info/sip-provision', {
	              sipInfo: [{ transport: 'WSS' }]
	            }).then(function (res) {
	              return res.json();
	            });
	
	          case 2:
	            info = _context.sent;
	            return _context.abrupt('return', new _ringcentralWebPhone2.default(info, {
	              logLevel: 0,
	              audioHelper: {
	                enabled: false
	              }
	            }));
	
	          case 4:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	  return function initPhoneInstance() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var record = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            if (flag) {
	              _context2.next = 6;
	              break;
	            }
	
	            _context2.next = 3;
	            return this.currentSession.stopRecord();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.stopRecord
	              }
	            });
	            _context2.next = 9;
	            break;
	
	          case 6:
	            _context2.next = 8;
	            return this.currentSession.startRecord();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.record
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function record(_x) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var mute = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            if (flag) {
	              _context3.next = 6;
	              break;
	            }
	
	            _context3.next = 3;
	            return this.currentSession.unmute();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.unmute
	              }
	            });
	            _context3.next = 9;
	            break;
	
	          case 6:
	            _context3.next = 8;
	            return this.currentSession.mute();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.mute
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	  return function mute(_x3) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var hold = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            if (flag) {
	              _context4.next = 6;
	              break;
	            }
	
	            _context4.next = 3;
	            return this.currentSession.unhold();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.unhold
	              }
	            });
	            _context4.next = 9;
	            break;
	
	          case 6:
	            _context4.next = 8;
	            return this.currentSession.hold();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.hold
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this);
	  }));
	  return function hold(_x5) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var park = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	    return _regenerator2.default.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return this.currentSession.park();
	
	          case 2:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.park
	              }
	            });
	
	          case 3:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this);
	  }));
	  return function park() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var transfer = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(number) {
	    return _regenerator2.default.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            this.checkSession();
	            _context6.next = 3;
	            return this.currentSession.transfer(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.transfer,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this);
	  }));
	  return function transfer(_x7) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var flip = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(number) {
	    return _regenerator2.default.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            this.checkSession();
	            _context7.next = 3;
	            return this.currentSession.flip(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.flip,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context7.stop();
	        }
	      }
	    }, _callee7, this);
	  }));
	  return function flip(_x8) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var dtmf = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(number) {
	    return _regenerator2.default.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            this.checkSession();
	            _context8.next = 3;
	            return this.currentSession.dtmf(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.dtmf,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this);
	  }));
	  return function dtmf(_x9) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var operations = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(name) {
	    var actions,
	        _actions$name,
	        _len,
	        args,
	        _key,
	        _args9 = arguments;
	
	    return _regenerator2.default.wrap(function _callee9$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            actions = { record: record, mute: mute, hold: hold, park: park, transfer: transfer, flip: flip, dtmf: dtmf };
	
	            this.checkSession();
	            _context9.prev = 2;
	
	            for (_len = _args9.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	              args[_key - 1] = _args9[_key];
	            }
	
	            _context9.next = 6;
	            return (_actions$name = actions[name]).call.apply(_actions$name, [this].concat(args));
	
	          case 6:
	            _context9.next = 12;
	            break;
	
	          case 8:
	            _context9.prev = 8;
	            _context9.t0 = _context9['catch'](2);
	
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.error,
	                error: _context9.t0
	              }
	            });
	            // TODO: needed?
	            throw _context9.t0;
	
	          case 12:
	          case 'end':
	            return _context9.stop();
	        }
	      }
	    }, _callee9, this, [[2, 8]]);
	  }));
	  return function operations(_x10, _x11) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _webphoneActions = __webpack_require__(204);
	
	var _webphoneActions2 = _interopRequireDefault(_webphoneActions);
	
	var _callActions = __webpack_require__(205);
	
	var _callActions2 = _interopRequireDefault(_callActions);
	
	var _webphoneReducer = __webpack_require__(206);
	
	var _webphoneReducer2 = _interopRequireDefault(_webphoneReducer);
	
	var _eventEmitter = __webpack_require__(137);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _ringcentralWebPhone = __webpack_require__(210);
	
	var _ringcentralWebPhone2 = _interopRequireDefault(_ringcentralWebPhone);
	
	var _webphoneStatus = __webpack_require__(207);
	
	var _webphoneStatus2 = _interopRequireDefault(_webphoneStatus);
	
	var _callStatus = __webpack_require__(209);
	
	var _callStatus2 = _interopRequireDefault(_callStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['api', 'platform', 'emitter', 'settings', 'phoneInstance']);
	
	var ENUMS = new _enum2.default({
	  webphoneStatus: _webphoneStatus2.default,
	  callStatus: _callStatus2.default
	});
	
	var Webphone = function (_RcModule) {
	  (0, _inherits3.default)(Webphone, _RcModule);
	
	  function Webphone(options) {
	    var _this2 = this;
	
	    (0, _classCallCheck3.default)(this, Webphone);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Webphone).call(this, (0, _extends3.default)({}, options, {
	      actions: _webphoneActions2.default
	    })));
	
	    var api = options.api;
	    var platform = options.platform;
	    var settings = options.settings;
	
	    _this[symbols.api] = api;
	    _this[symbols.platform] = platform;
	    _this[symbols.emitter] = new _eventEmitter2.default();
	    _this[symbols.settings] = settings;
	
	    _this.currentSession = null;
	    _this.isRegistered = false;
	
	    // TODO: commented out until setting module completed
	    // settings.registerReducer('webphone', getWebphoneReducer())
	
	    platform.on(platform.events.loginSuccess, (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
	      return _regenerator2.default.wrap(function _callee10$(_context10) {
	        while (1) {
	          switch (_context10.prev = _context10.next) {
	            case 0:
	              _context10.next = 2;
	              return initPhoneInstance.call(_this);
	
	            case 2:
	              _this[symbols.phoneInstance] = _context10.sent;
	
	              _this[symbols.phoneInstance].userAgent.on('registered', function () {
	                // sip will fire multiple registered events, only dispatch one register action to state.
	                // TODO: is this isRegistered state needed to be store as instance variable
	                //       or just check store state
	                if (!_this.isRegistered) {
	                  _this.store.dispatch({
	                    type: _this.actions.registerSuccess
	                  });
	                }
	                _this.isRegistered = _this[symbols.phoneInstance].userAgent.isRegistered();
	              });
	              _this[symbols.phoneInstance].userAgent.on('unregistered', function () {
	                _this.isRegistered = _this[symbols.phoneInstance].userAgent.isRegistered();
	                _this.store.dispatch({
	                  type: _this.actions.unregister,
	                  operation: {
	                    type: _callActions2.default.clear
	                  }
	                });
	              });
	              _this[symbols.phoneInstance].userAgent.on('registrationFailed', function (error) {
	                _this.store.dispatch({
	                  type: _this.actions.registerError,
	                  error: error
	                });
	              });
	              _this[symbols.phoneInstance].userAgent.on('invite', function (session) {
	                _this.currentSession = session;
	                _this.listenSessionEvents();
	                console.log(session);
	                _this.store.dispatch({
	                  type: _this.actions.callIncoming,
	                  payload: {
	                    remoteIdentity: session.remoteIdentity,
	                    localIdentity: session.localIdentity
	                  }
	                });
	              });
	
	            case 7:
	            case 'end':
	              return _context10.stop();
	          }
	        }
	      }, _callee10, _this2);
	    })));
	    return _this;
	  }
	
	  (0, _createClass3.default)(Webphone, [{
	    key: 'call',
	
	
	    /**
	     * Make a phone call, this method should be called in registerSuccess state
	     * @param {string} toNumber
	     * @param {string} [fromNumber]
	     * @return {Session}
	     */
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11(_ref) {
	        var toNumber = _ref.toNumber;
	        var fromNumber = _ref.fromNumber;
	        var media = _ref.media;
	        return _regenerator2.default.wrap(function _callee11$(_context11) {
	          while (1) {
	            switch (_context11.prev = _context11.next) {
	              case 0:
	                if (this[symbols.phoneInstance]) {
	                  _context11.next = 2;
	                  break;
	                }
	
	                throw Error('not registered');
	
	              case 2:
	                this.store.dispatch({
	                  type: this.actions.call,
	                  payload: {
	                    toNumber: toNumber,
	                    fromNumber: fromNumber
	                  }
	                });
	                this.currentSession = this[symbols.phoneInstance].userAgent.invite(toNumber, {
	                  media: {
	                    render: media
	                  }
	                });
	                this.listenSessionEvents();
	                _context11.prev = 5;
	                _context11.next = 8;
	                return this.currentSession;
	
	              case 8:
	                _context11.next = 14;
	                break;
	
	              case 10:
	                _context11.prev = 10;
	                _context11.t0 = _context11['catch'](5);
	
	                console.error(_context11.t0);
	                this.store.dispatch({
	                  type: this.actions.callError,
	                  error: _context11.t0
	                });
	
	              case 14:
	                return _context11.abrupt('return', this.currentSession);
	
	              case 15:
	              case 'end':
	                return _context11.stop();
	            }
	          }
	        }, _callee11, this, [[5, 10]]);
	      }));
	
	      function call(_x12) {
	        return ref.apply(this, arguments);
	      }
	
	      return call;
	    }()
	
	    /**
	     * Accept a phone call, this method should be called when call is incoming
	     * @param {Object} media, see https://github.com/ringcentral/ringcentral-web-phone#accepting-incoming-call
	     * @return {Promise}
	     */
	
	  }, {
	    key: 'accept',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12(media) {
	        return _regenerator2.default.wrap(function _callee12$(_context12) {
	          while (1) {
	            switch (_context12.prev = _context12.next) {
	              case 0:
	                this.checkSession();
	                _context12.prev = 1;
	                _context12.next = 4;
	                return this.currentSession.accept(media);
	
	              case 4:
	                _context12.next = 9;
	                break;
	
	              case 6:
	                _context12.prev = 6;
	                _context12.t0 = _context12['catch'](1);
	
	                // TODO
	                console.error(_context12.t0);
	
	              case 9:
	              case 'end':
	                return _context12.stop();
	            }
	          }
	        }, _callee12, this, [[1, 6]]);
	      }));
	
	      function accept(_x13) {
	        return ref.apply(this, arguments);
	      }
	
	      return accept;
	    }()
	  }, {
	    key: 'bye',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
	        return _regenerator2.default.wrap(function _callee13$(_context13) {
	          while (1) {
	            switch (_context13.prev = _context13.next) {
	              case 0:
	                this.checkSession();
	                _context13.prev = 1;
	                _context13.next = 4;
	                return this.currentSession.terminate();
	
	              case 4:
	                _context13.next = 9;
	                break;
	
	              case 6:
	                _context13.prev = 6;
	                _context13.t0 = _context13['catch'](1);
	
	                // TODO
	                console.error(_context13.t0);
	
	              case 9:
	              case 'end':
	                return _context13.stop();
	            }
	          }
	        }, _callee13, this, [[1, 6]]);
	      }));
	
	      function bye() {
	        return ref.apply(this, arguments);
	      }
	
	      return bye;
	    }()
	  }, {
	    key: 'record',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14(flag) {
	        return _regenerator2.default.wrap(function _callee14$(_context14) {
	          while (1) {
	            switch (_context14.prev = _context14.next) {
	              case 0:
	                operations.call(this, 'record', flag);
	
	              case 1:
	              case 'end':
	                return _context14.stop();
	            }
	          }
	        }, _callee14, this);
	      }));
	
	      function record(_x14) {
	        return ref.apply(this, arguments);
	      }
	
	      return record;
	    }()
	  }, {
	    key: 'mute',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15(flag) {
	        return _regenerator2.default.wrap(function _callee15$(_context15) {
	          while (1) {
	            switch (_context15.prev = _context15.next) {
	              case 0:
	                operations.call(this, 'mute', flag);
	
	              case 1:
	              case 'end':
	                return _context15.stop();
	            }
	          }
	        }, _callee15, this);
	      }));
	
	      function mute(_x15) {
	        return ref.apply(this, arguments);
	      }
	
	      return mute;
	    }()
	  }, {
	    key: 'hold',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee16(flag) {
	        return _regenerator2.default.wrap(function _callee16$(_context16) {
	          while (1) {
	            switch (_context16.prev = _context16.next) {
	              case 0:
	                operations.call(this, 'hold', flag);
	
	              case 1:
	              case 'end':
	                return _context16.stop();
	            }
	          }
	        }, _callee16, this);
	      }));
	
	      function hold(_x16) {
	        return ref.apply(this, arguments);
	      }
	
	      return hold;
	    }()
	  }, {
	    key: 'park',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee17(flag) {
	        return _regenerator2.default.wrap(function _callee17$(_context17) {
	          while (1) {
	            switch (_context17.prev = _context17.next) {
	              case 0:
	                operations.call(this, 'park', flag);
	
	              case 1:
	              case 'end':
	                return _context17.stop();
	            }
	          }
	        }, _callee17, this);
	      }));
	
	      function park(_x17) {
	        return ref.apply(this, arguments);
	      }
	
	      return park;
	    }()
	  }, {
	    key: 'transfer',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee18(number) {
	        return _regenerator2.default.wrap(function _callee18$(_context18) {
	          while (1) {
	            switch (_context18.prev = _context18.next) {
	              case 0:
	                operations.call(this, 'transfer', number);
	
	              case 1:
	              case 'end':
	                return _context18.stop();
	            }
	          }
	        }, _callee18, this);
	      }));
	
	      function transfer(_x18) {
	        return ref.apply(this, arguments);
	      }
	
	      return transfer;
	    }()
	  }, {
	    key: 'flip',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee19(number) {
	        return _regenerator2.default.wrap(function _callee19$(_context19) {
	          while (1) {
	            switch (_context19.prev = _context19.next) {
	              case 0:
	                operations.call(this, 'flip', number);
	
	              case 1:
	              case 'end':
	                return _context19.stop();
	            }
	          }
	        }, _callee19, this);
	      }));
	
	      function flip(_x19) {
	        return ref.apply(this, arguments);
	      }
	
	      return flip;
	    }()
	  }, {
	    key: 'dtmf',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee20(number) {
	        return _regenerator2.default.wrap(function _callee20$(_context20) {
	          while (1) {
	            switch (_context20.prev = _context20.next) {
	              case 0:
	                operations.call(this, 'dtmf', number);
	
	              case 1:
	              case 'end':
	                return _context20.stop();
	            }
	          }
	        }, _callee20, this);
	      }));
	
	      function dtmf(_x20) {
	        return ref.apply(this, arguments);
	      }
	
	      return dtmf;
	    }()
	  }, {
	    key: 'checkSession',
	    value: function checkSession() {
	      if (!this.currentSession) {
	        this.store.dispatch({
	          type: this.actions.sessionError
	        });
	        throw Error('No active session');
	      }
	    }
	
	    /**
	     * Internal method for listen session events
	     */
	
	  }, {
	    key: 'listenSessionEvents',
	    value: function listenSessionEvents() {
	      var _this3 = this;
	
	      this.currentSession.on('accepted', function (response) {
	        console.log(response);
	        // accepted event for outbound call will returne a incomingResponse
	        if (response.data) {
	          _this3.store.dispatch({
	            type: _this3.actions.callConnect,
	            payload: {
	              remoteIdentity: response.to,
	              localIdentity: response.from
	            }
	          });
	          // accepted event for inbound call will only contain a row sip data
	        } else {
	          _this3.store.dispatch({
	            type: _this3.actions.callAccept
	          });
	        }
	      });
	      // all situation about call terminated except 'call cancel'
	      this.currentSession.on('terminated', function (response, cause) {
	        console.log(response);
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd,
	          error: cause
	        });
	        _this3.currentSession = null;
	      });
	      // when we call out and cancel the phone call
	      this.currentSession.on('cancel', function (response, cause) {
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd,
	          error: cause
	        });
	        _this3.currentSession = null;
	      });
	      // should not need
	      this.currentSession.on('bye', function (response) {
	        console.log(response);
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd
	        });
	        _this3.currentSession = null;
	      });
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _webphoneReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'enums',
	    get: function get() {
	      return ENUMS;
	    }
	  }]);
	  return Webphone;
	}(_rcModule2.default);
	
	exports.default = Webphone;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['register', 'registerSuccess', 'registerError', 'unregister',
	
	// outbound call
	'call', 'callConnect',
	// inbound call
	'callAccept', 'callIncoming', 'callEnd', 'callError', 'callOperation',
	// no active session
	'sessionError']);

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap([
	// operational error
	'error',
	// unregister, clear operational state
	'clear',
	// operation
	'flip', 'record', 'stopRecord', 'hold', 'unhold', 'mute', 'unmute', 'park', 'transfer', 'forward', 'dtmf']);

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _webphoneActions = __webpack_require__(204);
	
	var _webphoneActions2 = _interopRequireDefault(_webphoneActions);
	
	var _webphoneStatus = __webpack_require__(207);
	
	var _webphoneStatus2 = _interopRequireDefault(_webphoneStatus);
	
	var _callReducer = __webpack_require__(208);
	
	var _callReducer2 = _interopRequireDefault(_callReducer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  status: _webphoneStatus2.default.preRegister,
	  // assign from UI
	  toNumber: '',
	  fromNumber: '',
	  // sip info return from sip server
	  remoteIdentity: null,
	  localIdentity: null,
	  operation: (0, _callReducer2.default)(),
	  error: null
	};
	
	function getReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_webphoneActions2.default, prefix);
	
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      case actions.registerSuccess:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.registerSuccessed
	        });
	      case actions.registerError:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.registerFailed,
	          error: action.error
	        });
	      case actions.unregister:
	        return initialState;
	      case actions.call:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnecting,
	          toNumber: action.payload.toNumber,
	          fromNumber: action.payload.fromNumber
	        });
	      case actions.callIncoming:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callIncoming,
	          remoteIdentity: action.payload.remoteIdentity,
	          localIdentity: action.payload.localIdentity
	        });
	      // TODO: update fromNumber, toNumber
	      case actions.callConnect:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnected,
	          remoteIdentity: action.payload.remoteIdentity,
	          localIdentity: action.payload.localIdentity
	        });
	      case actions.callAccept:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnected
	        });
	      case actions.callEnd:
	        return (0, _assign2.default)({}, initialState, {
	          status: _webphoneStatus2.default.registerSuccessed,
	          error: action.error
	        });
	      case actions.callError:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callFailed,
	          error: action.error
	        });
	      case actions.callOperation:
	        return (0, _assign2.default)({}, state, {
	          operation: (0, _callReducer2.default)(state.operation, action.operation)
	        });
	      case actions.sessionError:
	        return (0, _assign2.default)({}, initialState, {
	          error: action.error
	        });
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  // For registering
	  preRegister: 'PRE_REGISTER',
	  registerSuccessed: 'REGISTER_SUCCESSED',
	  registerFailed: 'REGISTER_FAILED',
	  // For callout and active call
	  callConnecting: 'CALL_CONNECTING',
	  callConnected: 'CALL_CONNECTED',
	  callFailed: 'CALL_FAILED',
	  // For incoming call
	  callIncoming: 'CALL_INCOMING'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = function (state, action) {
	  if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	  if (!action) return state;
	  switch (action.type) {
	
	    case _callActions2.default.error:
	      return (0, _assign2.default)({}, state, {
	        error: action.error
	      });
	    case _callActions2.default.clear:
	      return (0, _assign2.default)({}, initialState);
	    case _callActions2.default.record:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.recording) ? state.status : state.status.concat(_callStatus2.default.recording)
	      });
	    case _callActions2.default.stopRecord:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.recording)
	      });
	    case _callActions2.default.mute:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.muted) ? state.status : state.status.concat(_callStatus2.default.muted)
	      });
	    case _callActions2.default.unmute:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.muted)
	      });
	    case _callActions2.default.hold:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.holding) ? state.status : state.status.concat(_callStatus2.default.holding),
	        disabled: ['park', 'record']
	      });
	    case _callActions2.default.unhold:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.holding),
	        disabled: []
	      });
	    case _callActions2.default.park:
	      // https://en.wikipedia.org/wiki/Call_parking
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.parker) ? state.status : state.status.concat(_callStatus2.default.parker)
	      });
	    case _callActions2.default.transfer:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.transfered) ? state.status : state.status.concat(_callStatus2.default.transfered),
	        transferTaget: action.payload.number
	      });
	    case _callActions2.default.flip:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.flip) ? state.status : state.status.concat(_callStatus2.default.flip),
	        flipTarget: action.payload.number
	      });
	    case _callActions2.default.dtmf:
	      // TODO: clarify park action
	      return (0, _assign2.default)({}, state, {
	        status: state.status.concat(_callStatus2.default.parked),
	        dtmfNumber: action.payload.number
	      });
	
	    default:
	      return state;
	  }
	};
	
	var _callActions = __webpack_require__(205);
	
	var _callActions2 = _interopRequireDefault(_callActions);
	
	var _callStatus = __webpack_require__(209);
	
	var _callStatus2 = _interopRequireDefault(_callStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function contain(arr, ele) {
	  return arr.indexOf(ele) > -1;
	}
	
	function remove(arr, ele) {
	  if (contain(arr, ele)) {
	    arr.splice(arr.indexOf(ele), 1);
	  }
	  return arr;
	}
	
	var initialState = {
	  // operations which is enable
	  status: [],
	  // some operations will disable another, such as 'hold'
	  disabled: [],
	  // some operations have infomation need to be stored
	  transferTaget: null,
	  flipTarget: null,
	  dtmfNumber: null,
	  // operation error
	  error: null
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  flip: 'FLIPED',
	  recording: 'RECORDING',
	  holding: 'HOLDING',
	  muted: 'MUTED',
	  parked: 'PARKED',
	  transfered: 'TRANSFERED',
	  forwarded: 'FOWARDED'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(211)], __WEBPACK_AMD_DEFINE_RESULT__ = function(SIP) {
	            return factory(SIP);
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === 'object') {
	        module.exports = factory(require('sip.js'));
	        module.exports.default = module.exports; //ES6
	    } else {
	        root.RingCentral = root.RingCentral || {};
	        root.RingCentral.WebPhone = factory(root.SIP);
	    }
	}(this, function(SIP) {
	
	    var messages = {
	        park: {reqid: 1, command: 'callpark'},
	        startRecord: {reqid: 2, command: 'startcallrecord'},
	        stopRecord: {reqid: 3, command: 'stopcallrecord'},
	        flip: {reqid: 3, command: 'callflip', target: ''},
	        monitor: {reqid: 4, command: 'monitor'},
	        barge: {reqid: 5, command: 'barge'},
	        whisper: {reqid: 6, command: 'whisper'},
	        takeover: {reqid: 7, command: 'takeover'}
	    };
	
	    var responseTimeout = 10000;
	
	    function uuid() {
	        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
	            return v.toString(16);
	        });
	    }
	
	    function delay(ms) {
	        return new Promise(function(resolve, reject) {
	            setTimeout(resolve, ms);
	        });
	    }
	
	    function extend(dst, src) {
	        src = src || {};
	        dst = dst || {};
	        Object.keys(src).forEach(function(k) {
	            dst[k] = src[k];
	        });
	        return dst;
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @param options
	     * @constructor
	     */
	    function AudioHelper(options) {
	
	        options = options || {};
	
	        this._enabled = !!options.enabled;
	        this._incoming = options.incoming || '../audio/incoming.ogg';
	        this._outgoing = options.outgoing || '../audio/outgoing.ogg';
	        this._audio = {};
	
	    }
	
	    AudioHelper.prototype._playSound = function(url, val, volume) {
	
	        if (!this._enabled) return this;
	
	        if (!this._audio[url]) {
	            if (val) {
	                this._audio[url] = new Audio();
	                this._audio[url].src = url;
	                this._audio[url].loop = true;
	                this._audio[url].volume = volume;
	                this._audio[url].play();
	            }
	        } else {
	            if (val) {
	                this._audio[url].currentTime = 0;
	                this._audio[url].play();
	            } else {
	                this._audio[url].pause();
	            }
	        }
	
	        return this;
	
	    };
	
	    AudioHelper.prototype.playIncoming = function(val) {
	        return this._playSound(this._incoming, val, 0.5);
	    };
	
	    AudioHelper.prototype.playOutgoing = function(val) {
	        return this._playSound(this._outgoing, val, 1);
	    };
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @param {object} regData
	     * @param {object} [options]
	     * @param {string} [options.uuid]
	     * @param {string} [options.appKey]
	     * @param {string} [options.appName]
	     * @param {string} [options.appVersion]
	     * @param {string} [options.audioHelper]
	     * @param {string} [options.onSession] fired each time UserAgent starts working with session
	     * @constructor
	     */
	    function WebPhone(regData, options) {
	
	        regData = regData || {};
	        options = options || {};
	
	        this.sipInfo = regData.sipInfo[0] || regData.sipInfo;
	        this.sipFlags = regData.sipFlags;
	
	        var id = options.uuid || localStorage.getItem('rc-webPhone-uuid') || uuid(); //TODO Make configurable
	        localStorage.setItem('rc-webPhone-uuid', id);
	
	        this.endpointHeader = 'P-rc-endpoint-id: ' + id;
	
	        var configuration = {
	            uri: 'sip:' + this.sipInfo.username + '@' + this.sipInfo.domain,
	            wsServers: this.sipInfo.outboundProxy && this.sipInfo.transport
	                ? this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxy
	                : this.sipInfo.wsServers,
	            authorizationUser: this.sipInfo.authorizationId,
	            password: this.sipInfo.password,
	            traceSip: true,
	            stunServers: this.sipInfo.stunServers || ['stun:74.125.194.127:19302'], //FIXME Hardcoded?
	            turnServers: [],
	            log: {
	                level: options.logLevel || 1 //FIXME LOG LEVEL 3
	            },
	            domain: this.sipInfo.domain,
	            autostart: true,
	            register: true,
	            iceGatheringTimeout: this.sipInfo.iceGatheringTimeout || 3000
	        };
	
	        this.appKey = options.appKey;
	        this.appName = options.appName;
	        this.appVersion = options.appVersion;
	        this.userAgentHeader = 'RC-User-Agent: ' +
	                               (options.appName ? (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' : '') +
	                               'RCWEBPHONE/' + WebPhone.version;
	
	        this.clientIdHeader = 'Client-id:' + options.appKey;
	
	        this.userAgent = new SIP.UA(configuration).register({
	            extraHeaders: [
	                this.endpointHeader,
	                this.userAgentHeader,
	                this.clientIdHeader
	            ]
	        });
	
	        this.userAgent.endpointHeader = this.endpointHeader;
	        this.userAgent.userAgentHeader = this.userAgentHeader;
	        this.userAgent.clientIdHeader = this.clientIdHeader;
	        this.userAgent.sipInfo = this.sipInfo;
	
	        this.userAgent.__invite = this.userAgent.invite;
	        this.userAgent.invite = invite;
	
	        this.userAgent.on('invite', function(session) {
	            this.userAgent.audioHelper.playIncoming(true);
	            patchSession(session);
	        }.bind(this));
	
	        this.userAgent.audioHelper = new AudioHelper(options.audioHelper);
	
	        this.userAgent.onSession = options.onSession || null;
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    WebPhone.version = '0.3.1';
	    WebPhone.uuid = uuid;
	    WebPhone.delay = delay;
	    WebPhone.extend = extend;
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    function patchSession(session) {
	
	        if (session.__patched) return session;
	
	        session.__patched = true;
	
	        session.__sendRequest = session.sendRequest;
	        session.__receiveRequest = session.receiveRequest;
	        session.__receiveInviteResponse = session.receiveInviteResponse;
	        session.__receiveResponse = session.receiveResponse;
	        session.__accept = session.accept;
	        session.__hold = session.hold;
	        session.__unhold = session.unhold;
	        session.__dtmf = session.dtmf;
	
	        session.sendRequest = sendRequest;
	        session.receiveRequest = receiveRequest;
	        session.receiveInviteResponse = receiveInviteResponse;
	        session.receiveResponse = receiveResponse;
	        session.accept = accept;
	        session.hold = hold;
	        session.unhold = unhold;
	        session.dtmf = dtmf;
	
	        session.blindTransfer = blindTransfer;
	        session.transfer = transfer;
	        session.park = park;
	        session.forward = forward;
	        session.startRecord = startRecord;
	        session.stopRecord = stopRecord;
	        session.flip = flip;
	
	        session.on('replaced', patchSession);
	        // session.on('connecting', onConnecting);
	
	        // Audio
	        session.on('accepted', stopPlaying);
	        session.on('rejected', stopPlaying);
	        session.on('bye', stopPlaying);
	        session.on('terminated', stopPlaying);
	        session.on('cancel', stopPlaying);
	        session.on('failed', stopPlaying);
	        session.on('replaced', stopPlaying);
	        session.mediaHandler.on('iceConnectionCompleted', stopPlaying);
	        session.mediaHandler.on('iceConnectionFailed', stopPlaying);
	
	        function stopPlaying() {
	            session.ua.audioHelper.playOutgoing(false);
	            session.ua.audioHelper.playIncoming(false);
	            session.removeListener('accepted', stopPlaying);
	            session.removeListener('rejected', stopPlaying);
	            session.removeListener('bye', stopPlaying);
	            session.removeListener('terminated', stopPlaying);
	            session.removeListener('cancel', stopPlaying);
	            session.removeListener('failed', stopPlaying);
	            session.removeListener('replaced', stopPlaying);
	            session.mediaHandler.removeListener('iceConnectionCompleted', stopPlaying);
	            session.mediaHandler.removeListener('iceConnectionFailed', stopPlaying);
	        }
	
	        if (session.ua.onSession) session.ua.onSession(session);
	
	        return session;
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {object} command
	     * @param {object} [options]
	     * @return {Promise}
	     */
	    function sendReceive(session, command, options) {
	
	        options = options || {};
	
	        extend(command, options);
	
	        var cseq = null;
	
	        return new Promise(function(resolve, reject) {
	
	            session.sendRequest(SIP.C.INFO, {
	                body: JSON.stringify({
	                    request: command
	                }),
	                extraHeaders: [
	                    "Content-Type: application/json;charset=utf-8",
	                    session.ua.userAgentHeader,
	                    session.ua.endpointHeader,
	                    session.ua.clientIdHeader
	                ],
	                receiveResponse: function(response) {
	                    var timeout = null;
	                    if (response.status_code === 200) {
	                        cseq = response.cseq;
	                        var onInfo = function(request) {
	                            if (response.cseq === cseq) {
	
	                                var body = request && request.body || '{}';
	                                var obj;
	
	                                try {
	                                    obj = JSON.parse(body);
	                                } catch (e) {
	                                    obj = {};
	                                }
	
	                                if (obj.response && obj.response.command === command.command) {
	                                    if (obj.response.result) {
	                                        if (obj.response.result.code == 0) {
	                                            return resolve(obj.response.result);
	                                        } else {
	                                            return reject(obj.response.result);
	                                        }
	                                    }
	                                }
	                                timeout && clearTimeout(timeout);
	                                session.removeListener('RC_SIP_INFO', onInfo);
	                                resolve(null); //FIXME What to resolve
	                            }
	                        };
	
	                        timeout = setTimeout(function() {
	                            reject(new Error('Timeout: no reply'));
	                            session.removeListener('RC_SIP_INFO', onInfo);
	                        }, responseTimeout);
	                        session.on('RC_SIP_INFO', onInfo);
	                    }
	                    else {
	                        reject(new Error('The INFO response status code is: ' + response.status_code + ' (waiting for 200)'));
	                    }
	                }
	            });
	
	        });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    function sendRequest(type, config) {
	        if (type == SIP.C.PRACK) {
	            type = SIP.C.ACK;
	        }
	        return this.__sendRequest(type, config);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * Fired each time a provisional (100-199) response is received.
	     * Early media is supported by SIP.js library
	     * But in case it is sent without 100rel support we play it manually
	     * STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported
	     *
	     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1072388
	     * @param {SIP.Session} session
	     * @param response
	     * @param {funciton} cb
	     */
	    function patch100rel(session, response, cb) {
	
	        //Early media is supported by SIP.js library
	        //But in case it is sent without 100rel support we play it manually
	        //STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported
	        if (session.status !== SIP.Session.C.STATUS_EARLY_MEDIA && response.status_code === 183 && typeof(response.body) === 'string' && response.body.indexOf('\n') !== -1) {
	            if (!response.hasHeader('require')) response.setHeader('require', '100rel');
	        }
	
	        return cb.call(session, response);
	
	    }
	
	    /**
	     * @this {SIP.Session}
	     * @param response
	     * @return {*}
	     */
	    function receiveInviteResponse(response) {
	        return patch100rel(this, response, this.__receiveInviteResponse);
	    }
	
	    /**
	     * @this {SIP.Session}
	     * @param response
	     * @return {*}
	     */
	    function receiveResponse(response) {
	        return patch100rel(this, response, this.__receiveResponse);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {boolean} flag
	     * @return {Promise}
	     */
	    function setRecord(session, flag) {
	
	        var message = !!flag
	            ? messages.startRecord
	            : messages.stopRecord;
	
	        if ((session.__onRecord && !flag) || (!session.__onRecord && flag)) {
	            return sendReceive(session, message)
	                .then(function(data) {
	                    session.__onRecord = !!flag;
	                    return data;
	                });
	        }
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {boolean} flag
	     * @return {Promise}
	     */
	    function setHold(session, flag) {
	        return new Promise(function(resolve, reject) {
	
	            var options = {
	                eventHandlers: {
	                    succeeded: resolve,
	                    failed: reject
	                }
	            };
	
	            if (flag) {
	                session.__hold(options);
	            } else {
	                session.__unhold(options);
	            }
	
	        });
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.UA}
	     * @param number
	     * @param options
	     * @return {SIP.Session}
	     */
	    function invite(number, options) {
	
	        var ua = this;
	
	        options = options || {};
	        options.extraHeaders = options.extraHeaders || [];
	
	        options.extraHeaders.push(ua.userAgentHeader);
	        options.extraHeaders.push(ua.endpointHeader);
	        options.extraHeaders.push(ua.clientIdHeader);
	
	        options.extraHeaders.push('P-Asserted-Identity: sip:' + (options.fromNumber || ua.sipInfo.username) + '@' + ua.sipInfo.domain); //FIXME Phone Number
	
	        //FIXME Backend should know it already
	        if (options.homeCountryId) { options.extraHeaders.push('P-rc-country-id: ' + options.homeCountryId); }
	
	        options.media = options.media || {};
	        options.media.constraints = options.media.constraints || {audio: true, video: false};
	
	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};
	
	        ua.audioHelper.playOutgoing(true);
	
	        return patchSession(ua.__invite(number, options));
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param request
	     * @return {*}
	     */
	    function receiveRequest(request) {
	        var session = this;
	        switch (request.method) {
	            case SIP.C.INFO:
	                session.emit('RC_SIP_INFO', request);
	                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case
	                if (session.status === SIP.Session.C.STATUS_CONFIRMED || session.status === SIP.Session.C.STATUS_WAITING_FOR_ACK) {
	                    var contentType = request.getHeader('content-type');
	                    if (contentType.match(/^application\/json/i)) {
	                        request.reply(200);
	                        return session;
	                    }
	                }
	                break;
	            //Refresh invite should not be rejected with 488
	            case SIP.C.INVITE:
	                if (session.status === SIP.Session.C.STATUS_CONFIRMED) {
	                    if (request.call_id && session.dialog && session.dialog.id && request.call_id == session.dialog.id.call_id) {
	                        //TODO: check that SDP did not change
	                        session.logger.log('re-INVITE received');
	                        var localSDP = session.mediaHandler.peerConnection.localDescription.sdp;
	                        request.reply(200, null, ['Contact: ' + session.contact], localSDP, function() {
	                            session.status = SIP.Session.C.STATUS_WAITING_FOR_ACK;
	                            session.setInvite2xxTimer(request, localSDP);
	                            session.setACKTimer();
	                        });
	                        return session;
	                    }
	                    //else will be rejected with 488 by SIP.js
	                }
	                break;
	            //We need to analize NOTIFY messages sometimes, so we fire an event
	            case SIP.C.NOTIFY:
	                session.emit('RC_SIP_NOTIFY', request);
	                break;
	        }
	        return session.__receiveRequest.apply(session, arguments);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {object} options
	     * @return {Promise}
	     */
	    function accept(options) {
	
	        var session = this;
	
	        options = options || {};
	        options.extraHeaders = options.extraHeaders || [];
	
	        options.extraHeaders.push(session.ua.userAgentHeader);
	        options.extraHeaders.push(session.ua.endpointHeader);
	        options.extraHeaders.push(session.ua.clientIdHeader);
	
	        options.media = options.media || {};
	        options.media.constraints = options.media.constraints || {audio: true, video: false};
	
	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};
	
	        return new Promise(function(resolve, reject) {
	
	            function onAnswered() {
	                resolve(session);
	                session.removeListener('failed', onFail);
	            }
	
	            function onFail(e) {
	                reject(e);
	                session.removeListener('accepted', onAnswered);
	            }
	
	            //TODO More events?
	            session.once('accepted', onAnswered);
	            session.once('failed', onFail);
	
	            session.__accept(options);
	
	        });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @param {string} dtmf
	     * @param {number} duration
	     * @return {Promise}
	     */
	    function dtmf(dtmf, duration) {
	        var session = this;
	        duration = parseInt(duration) || 1000;
	        var peer = session.mediaHandler.peerConnection;
	        var stream = session.getLocalStreams()[0];
	        var dtmfSender = peer.createDTMFSender(stream.getAudioTracks()[0]);
	        if (dtmfSender !== undefined && dtmfSender.canInsertDTMF) {
	            return dtmfSender.insertDTMF(dtmf, duration);
	        }
	        throw new Error('Send DTMF failed: ' + (!dtmfSender ? 'no sender' : (!dtmfSender.canInsertDTMF ? 'can\'t insert DTMF' : 'Unknown')));
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @return {Promise}
	     */
	    function hold() {
	        return setHold(this, true);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @return {Promise}
	     */
	    function unhold() {
	        return setHold(this, false);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @param {string} target
	     * @param {object} options
	     * @return {Promise}
	     */
	    function blindTransfer(target, options) {
	
	        options = options || {};
	
	        var session = this;
	        var extraHeaders = options.extraHeaders || [];
	        var originalTarget = target;
	
	        return new Promise(function(resolve, reject) {
	            //Blind Transfer is taken from SIP.js source
	
	            // Check Session Status
	            if (session.status !== SIP.Session.C.STATUS_CONFIRMED) {
	                throw new SIP.Exceptions.InvalidStateError(session.status);
	            }
	
	            // normalizeTarget allows instances of SIP.URI to pass through unaltered,
	            // so try to make one ahead of time
	            try {
	                target = SIP.Grammar.parse(target, 'Refer_To').uri || target;
	            } catch (e) {
	                session.logger.debug(".refer() cannot parse Refer_To from", target);
	                session.logger.debug("...falling through to normalizeTarget()");
	            }
	
	            // Check target validity
	            target = session.ua.normalizeTarget(target);
	            if (!target) {
	                throw new TypeError('Invalid target: ' + originalTarget);
	            }
	
	            extraHeaders.push('Contact: ' + session.contact);
	            extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	            extraHeaders.push('Refer-To: ' + target);
	            extraHeaders.push(session.ua.userAgentHeader);
	            extraHeaders.push(session.ua.endpointHeader);
	            extraHeaders.push(session.ua.clientIdHeader);
	
	            // Send the request
	            session.sendRequest(SIP.C.REFER, {
	                extraHeaders: extraHeaders,
	                body: options.body,
	                receiveResponse: function(response) {
	                    var timeout = null;
	                    if (response.status_code === 202) {
	                        var callId = response.call_id;
	
	                        var onNotify = function(request) {
	                            if (request.call_id === callId) {
	                                var body = request && request.body || '';
	                                switch (true) {
	                                    case /1[0-9]{2}/.test(body):
	                                        request.reply(200);
	                                        break;
	                                    case /2[0-9]{2}/.test(body):
	                                        session.terminate();
	                                        clearTimeout(timeout);
	                                        session.removeListener('RC_SIP_NOTIFY', onNotify);
	                                        resolve();
	                                        break;
	                                    default:
	                                        reject(body);
	                                        break;
	                                }
	                            }
	                        };
	
	                        timeout = setTimeout(function() {
	                            reject(new Error('Timeout: no reply'));
	                            session.removeListener('RC_SIP_NOTIFY', onNotify);
	                        }, responseTimeout);
	                        session.on('RC_SIP_NOTIFY', onNotify);
	                    }
	                    else {
	                        reject(new Error('The response status code is: ' + response.status_code + ' (waiting for 202)'));
	                    }
	                }
	            });
	
	        });
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {string} target
	     * @param {object} options
	     * @return {Promise}
	     */
	    function transfer(target, options) {
	
	        var session = this;
	
	        return (session.isOnHold() ? Promise.resolve(null) : session.hold())
	            .then(function() { return delay(300); })
	            .then(function() {
	                return session.blindTransfer(target, options);
	            });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {string} target
	     * @param {object} acceptOptions
	     * @param {object} [transferOptions]
	     * @return {Promise}
	     */
	    function forward(target, acceptOptions, transferOptions) {
	
	        var interval = null,
	            session = this;
	
	        return session.accept(acceptOptions)
	            .then(function() {
	
	                return new Promise(function(resolve, reject) {
	                    interval = setInterval(function() {
	                        if (session.status === 12) {
	                            clearInterval(interval);
	                            session.mute();
	                            setTimeout(function() {
	                                resolve(session.transfer(target, transferOptions));
	                            }, 700);
	                        }
	                    }, 50);
	                });
	
	            });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function startRecord() {
	        return setRecord(this, true);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function stopRecord() {
	        return setRecord(this, false);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param target
	     * @return {Promise}
	     */
	    function flip(target) {
	        return sendReceive(this, messages.flip, {target: target});
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function park() {
	        return sendReceive(this, messages.park);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    return WebPhone;
	
	}));

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = __webpack_require__(212)(__webpack_require__(245));


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name SIP
	 * @namespace
	 */
	"use strict";
	
	module.exports = function (environment) {
	
	var pkg = __webpack_require__(213);
	
	var SIP = Object.defineProperties({}, {
	  version: {
	    get: function(){ return pkg.version; }
	  },
	  name: {
	    get: function(){ return pkg.title; }
	  }
	});
	
	__webpack_require__(214)(SIP, environment);
	SIP.LoggerFactory = __webpack_require__(215)(environment.console);
	SIP.EventEmitter = __webpack_require__(216)(environment.console);
	SIP.C = __webpack_require__(218)(SIP.name, SIP.version);
	SIP.Exceptions = __webpack_require__(219);
	SIP.Timers = __webpack_require__(220)(environment.timers);
	SIP.Transport = environment.Transport(SIP, environment.WebSocket);
	__webpack_require__(221)(SIP);
	__webpack_require__(222)(SIP);
	__webpack_require__(223)(SIP);
	__webpack_require__(224)(SIP);
	__webpack_require__(225)(SIP);
	__webpack_require__(226)(SIP);
	__webpack_require__(228)(SIP);
	__webpack_require__(229)(SIP);
	SIP.MediaHandler = __webpack_require__(230)(SIP.EventEmitter);
	__webpack_require__(231)(SIP);
	__webpack_require__(232)(SIP);
	__webpack_require__(233)(SIP, environment);
	__webpack_require__(235)(SIP);
	SIP.WebRTC = __webpack_require__(236)(SIP, environment);
	__webpack_require__(239)(SIP, environment);
	SIP.Hacks = __webpack_require__(240)(SIP);
	__webpack_require__(241)(SIP);
	SIP.DigestAuthentication = __webpack_require__(242)(SIP.Utils);
	SIP.Grammar = __webpack_require__(243)(SIP);
	
	return SIP;
	};


/***/ },
/* 213 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				"sip.js@0.7.5",
				"/Users/howard.zhang/Sites/ringcentral-js-integration-commons/node_modules/ringcentral-web-phone"
			]
		],
		"_from": "sip.js@0.7.5",
		"_id": "sip.js@0.7.5",
		"_inCache": true,
		"_installable": true,
		"_location": "/sip.js",
		"_nodeVersion": "4.4.3",
		"_npmOperationalInternal": {
			"host": "packages-12-west.internal.npmjs.com",
			"tmp": "tmp/sip.js-0.7.5.tgz_1461594418690_0.5839933124370873"
		},
		"_npmUser": {
			"email": "1212jtraceur@gmail.com",
			"name": "josephfrazier"
		},
		"_npmVersion": "2.15.1",
		"_phantomChildren": {},
		"_requested": {
			"name": "sip.js",
			"raw": "sip.js@0.7.5",
			"rawSpec": "0.7.5",
			"scope": null,
			"spec": "0.7.5",
			"type": "version"
		},
		"_requiredBy": [
			"/ringcentral-web-phone"
		],
		"_resolved": "https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz",
		"_shasum": "86ace7051594f91b4551bdb8120a16c44962d3a2",
		"_shrinkwrap": null,
		"_spec": "sip.js@0.7.5",
		"_where": "/Users/howard.zhang/Sites/ringcentral-js-integration-commons/node_modules/ringcentral-web-phone",
		"author": {
			"email": "developer@onsip.com",
			"name": "OnSIP",
			"url": "http://sipjs.com/authors/"
		},
		"browser": {
			"./src/environment.js": "./src/environment_browser.js"
		},
		"bugs": {
			"url": "https://github.com/onsip/SIP.js/issues"
		},
		"contributors": [
			{
				"url": "https://github.com/onsip/SIP.js/blob/master/THANKS.md"
			}
		],
		"dependencies": {
			"promiscuous": "^0.6.0",
			"ws": "^0.6.4"
		},
		"description": "A simple, intuitive, and powerful JavaScript signaling library",
		"devDependencies": {
			"beefy": "^2.1.5",
			"browserify": "^4.1.8",
			"grunt": "~0.4.0",
			"grunt-browserify": "^4.0.1",
			"grunt-cli": "~0.1.6",
			"grunt-contrib-copy": "^0.5.0",
			"grunt-contrib-jasmine": "^0.9.2",
			"grunt-contrib-jshint": ">0.5.0",
			"grunt-contrib-uglify": "~0.2.0",
			"grunt-peg": "~1.3.1",
			"grunt-trimtrailingspaces": "^0.4.0",
			"pegjs": "^0.8.0"
		},
		"directories": {},
		"dist": {
			"shasum": "86ace7051594f91b4551bdb8120a16c44962d3a2",
			"tarball": "https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz"
		},
		"engines": {
			"node": ">=0.8"
		},
		"gitHead": "bae44bd0359f4d70ded309a32361f04a04e78d6e",
		"homepage": "http://sipjs.com",
		"keywords": [
			"sip",
			"websocket",
			"webrtc",
			"library",
			"javascript"
		],
		"license": "MIT",
		"main": "src/index.js",
		"maintainers": [
			{
				"email": "eric.green@onsip.com",
				"name": "egreen_onsip"
			},
			{
				"email": "james@onsip.com",
				"name": "james-criscuolo"
			},
			{
				"email": "1212jtraceur@gmail.com",
				"name": "josephfrazier"
			}
		],
		"name": "sip.js",
		"optionalDependencies": {
			"promiscuous": "^0.6.0"
		},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/onsip/SIP.js.git"
		},
		"scripts": {
			"build": "grunt build",
			"prepublish": "cd src/Grammar && mkdir -p dist && pegjs --extra-options-file peg.json src/Grammar.pegjs dist/Grammar.js",
			"repl": "beefy test/repl.js --open",
			"test": "grunt travis --verbose"
		},
		"title": "SIP.js",
		"version": "0.7.5"
	};

/***/ },
/* 214 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Utils
	 */
	
	module.exports = function (SIP, environment) {
	var Utils;
	
	Utils= {
	
	  Promise: environment.Promise,
	
	  defer: function defer () {
	    var deferred = {};
	    deferred.promise = new Utils.Promise(function (resolve, reject) {
	      deferred.resolve = resolve;
	      deferred.reject = reject;
	    });
	    return deferred;
	  },
	
	  promisify: function promisify (object, methodName, callbacksFirst) {
	    var oldMethod = object[methodName];
	    return function promisifiedMethod (arg, onSuccess, onFailure) {
	      return new Utils.Promise(function (resolve, reject) {
	        var oldArgs = [arg, resolve, reject];
	        if (callbacksFirst) {
	          oldArgs = [resolve, reject, arg];
	        }
	        oldMethod.apply(object, oldArgs);
	      }).then(onSuccess, onFailure);
	    };
	  },
	
	  augment: function (object, constructor, args, override) {
	    var idx, proto;
	
	    // Add public properties from constructor's prototype onto object
	    proto = constructor.prototype;
	    for (idx in proto) {
	      if (override || object[idx] === undefined) {
	        object[idx] = proto[idx];
	      }
	    }
	
	    // Construct the object as though it were just created by constructor
	    constructor.apply(object, args);
	  },
	
	  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {
	    if (isDeprecated && options[loser]) {
	      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');
	    }
	
	    if (options[winner] && options[loser]) {
	      logger.warn(winner + ' overriding ' + loser);
	    }
	
	    options[winner] = options[winner] || options[loser] || defaultValue;
	  },
	
	  str_utf8_length: function(string) {
	    return encodeURIComponent(string).replace(/%[A-F\d]{2}/g, 'U').length;
	  },
	
	  generateFakeSDP: function(body) {
	    if (!body) {
	      return;
	    }
	
	    var start = body.indexOf('o=');
	    var end = body.indexOf('\r\n', start);
	
	    return 'v=0\r\n' + body.slice(start, end) + '\r\ns=-\r\nt=0 0\r\nc=IN IP4 0.0.0.0';
	  },
	
	  isFunction: function(fn) {
	    if (fn !== undefined) {
	      return Object.prototype.toString.call(fn) === '[object Function]';
	    } else {
	      return false;
	    }
	  },
	
	  isDecimal: function (num) {
	    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));
	  },
	
	  createRandomToken: function(size, base) {
	    var i, r,
	      token = '';
	
	    base = base || 32;
	
	    for( i=0; i < size; i++ ) {
	      r = Math.random() * base|0;
	      token += r.toString(base);
	    }
	
	    return token;
	  },
	
	  newTag: function() {
	    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);
	  },
	
	  // http://stackoverflow.com/users/109538/broofa
	  newUUID: function() {
	    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
	      return v.toString(16);
	    });
	
	    return UUID;
	  },
	
	  hostType: function(host) {
	    if (!host) {
	      return;
	    } else {
	      host = SIP.Grammar.parse(host,'host');
	      if (host !== -1) {
	        return host.host_type;
	      }
	    }
	  },
	
	  /**
	  * Normalize SIP URI.
	  * NOTE: It does not allow a SIP URI without username.
	  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
	  * Detects the domain part (if given) and properly hex-escapes the user portion.
	  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
	  * @private
	  * @param {String} target
	  * @param {String} [domain]
	  */
	  normalizeTarget: function(target, domain) {
	    var uri, target_array, target_user, target_domain;
	
	    // If no target is given then raise an error.
	    if (!target) {
	      return;
	    // If a SIP.URI instance is given then return it.
	    } else if (target instanceof SIP.URI) {
	      return target;
	
	    // If a string is given split it by '@':
	    // - Last fragment is the desired domain.
	    // - Otherwise append the given domain argument.
	    } else if (typeof target === 'string') {
	      target_array = target.split('@');
	
	      switch(target_array.length) {
	        case 1:
	          if (!domain) {
	            return;
	          }
	          target_user = target;
	          target_domain = domain;
	          break;
	        case 2:
	          target_user = target_array[0];
	          target_domain = target_array[1];
	          break;
	        default:
	          target_user = target_array.slice(0, target_array.length-1).join('@');
	          target_domain = target_array[target_array.length-1];
	      }
	
	      // Remove the URI scheme (if present).
	      target_user = target_user.replace(/^(sips?|tel):/i, '');
	
	      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
	      if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(target_user)) {
	        target_user = target_user.replace(/[\-\.\(\)]/g, '');
	      }
	
	      // Build the complete SIP URI.
	      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;
	
	      // Finally parse the resulting URI.
	      if (uri = SIP.URI.parse(target)) {
	        return uri;
	      } else {
	        return;
	      }
	    } else {
	      return;
	    }
	  },
	
	  /**
	  * Hex-escape a SIP URI user.
	  * @private
	  * @param {String} user
	  */
	  escapeUser: function(user) {
	    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
	    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');
	  },
	
	  headerize: function(string) {
	    var exceptions = {
	      'Call-Id': 'Call-ID',
	      'Cseq': 'CSeq',
	      'Min-Se': 'Min-SE',
	      'Rack': 'RAck',
	      'Rseq': 'RSeq',
	      'Www-Authenticate': 'WWW-Authenticate'
	      },
	      name = string.toLowerCase().replace(/_/g,'-').split('-'),
	      hname = '',
	      parts = name.length, part;
	
	    for (part = 0; part < parts; part++) {
	      if (part !== 0) {
	        hname +='-';
	      }
	      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);
	    }
	    if (exceptions[hname]) {
	      hname = exceptions[hname];
	    }
	    return hname;
	  },
	
	  sipErrorCause: function(status_code) {
	    var cause;
	
	    for (cause in SIP.C.SIP_ERROR_CAUSES) {
	      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {
	        return SIP.C.causes[cause];
	      }
	    }
	
	    return SIP.C.causes.SIP_FAILURE_CODE;
	  },
	
	  getReasonPhrase: function getReasonPhrase (code, specific) {
	    return specific || SIP.C.REASON_PHRASE[code] || '';
	  },
	
	  getReasonHeaderValue: function getReasonHeaderValue (code, reason) {
	    reason = SIP.Utils.getReasonPhrase(code, reason);
	    return 'SIP ;cause=' + code + ' ;text="' + reason + '"';
	  },
	
	  getCancelReason: function getCancelReason (code, reason) {
	    if (code && code < 200 || code > 699) {
	      throw new TypeError('Invalid status_code: ' + code);
	    } else if (code) {
	      return SIP.Utils.getReasonHeaderValue(code, reason);
	    }
	  },
	
	  buildStatusLine: function buildStatusLine (code, reason) {
	    code = code || null;
	    reason = reason || null;
	
	    // Validate code and reason values
	    if (!code || (code < 100 || code > 699)) {
	      throw new TypeError('Invalid status_code: '+ code);
	    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
	      throw new TypeError('Invalid reason_phrase: '+ reason);
	    }
	
	    reason = Utils.getReasonPhrase(code, reason);
	
	    return 'SIP/2.0 ' + code + ' ' + reason + '\r\n';
	  },
	
	  /**
	  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)
	  * @private
	  */
	  getRandomTestNetIP: function() {
	    function getOctet(from,to) {
	      return Math.floor(Math.random()*(to-from+1)+from);
	    }
	    return '192.0.2.' + getOctet(1, 254);
	  },
	
	  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info
	  calculateMD5: function(string) {
	    function RotateLeft(lValue, iShiftBits) {
	      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
	    }
	
	    function AddUnsigned(lX,lY) {
	      var lX4,lY4,lX8,lY8,lResult;
	      lX8 = (lX & 0x80000000);
	      lY8 = (lY & 0x80000000);
	      lX4 = (lX & 0x40000000);
	      lY4 = (lY & 0x40000000);
	      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
	      if (lX4 & lY4) {
	        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
	      }
	      if (lX4 | lY4) {
	        if (lResult & 0x40000000) {
	          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
	        } else {
	          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
	        }
	      } else {
	        return (lResult ^ lX8 ^ lY8);
	      }
	    }
	
	    function F(x,y,z) {
	      return (x & y) | ((~x) & z);
	    }
	
	    function G(x,y,z) {
	      return (x & z) | (y & (~z));
	    }
	
	    function H(x,y,z) {
	      return (x ^ y ^ z);
	    }
	
	    function I(x,y,z) {
	      return (y ^ (x | (~z)));
	    }
	
	    function FF(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function GG(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function HH(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function II(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function ConvertToWordArray(string) {
	      var lWordCount;
	      var lMessageLength = string.length;
	      var lNumberOfWords_temp1=lMessageLength + 8;
	      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
	      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
	      var lWordArray=Array(lNumberOfWords-1);
	      var lBytePosition = 0;
	      var lByteCount = 0;
	      while ( lByteCount < lMessageLength ) {
	        lWordCount = (lByteCount-(lByteCount % 4))/4;
	        lBytePosition = (lByteCount % 4)*8;
	        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
	        lByteCount++;
	      }
	      lWordCount = (lByteCount-(lByteCount % 4))/4;
	      lBytePosition = (lByteCount % 4)*8;
	      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
	      lWordArray[lNumberOfWords-2] = lMessageLength<<3;
	      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
	      return lWordArray;
	    }
	
	    function WordToHex(lValue) {
	      var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
	      for (lCount = 0;lCount<=3;lCount++) {
	        lByte = (lValue>>>(lCount*8)) & 255;
	        WordToHexValue_temp = "0" + lByte.toString(16);
	        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
	      }
	      return WordToHexValue;
	    }
	
	    function Utf8Encode(string) {
	      string = string.replace(/\r\n/g,"\n");
	      var utftext = "";
	
	      for (var n = 0; n < string.length; n++) {
	        var c = string.charCodeAt(n);
	
	        if (c < 128) {
	          utftext += String.fromCharCode(c);
	        }
	        else if((c > 127) && (c < 2048)) {
	          utftext += String.fromCharCode((c >> 6) | 192);
	          utftext += String.fromCharCode((c & 63) | 128);
	        }
	        else {
	          utftext += String.fromCharCode((c >> 12) | 224);
	          utftext += String.fromCharCode(((c >> 6) & 63) | 128);
	          utftext += String.fromCharCode((c & 63) | 128);
	        }
	      }
	      return utftext;
	    }
	
	    var x=[];
	    var k,AA,BB,CC,DD,a,b,c,d;
	    var S11=7, S12=12, S13=17, S14=22;
	    var S21=5, S22=9 , S23=14, S24=20;
	    var S31=4, S32=11, S33=16, S34=23;
	    var S41=6, S42=10, S43=15, S44=21;
	
	    string = Utf8Encode(string);
	
	    x = ConvertToWordArray(string);
	
	    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;
	
	    for (k=0;k<x.length;k+=16) {
	      AA=a; BB=b; CC=c; DD=d;
	      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);
	      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
	      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
	      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
	      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
	      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
	      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
	      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
	      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
	      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
	      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
	      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
	      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
	      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
	      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
	      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
	      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
	      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
	      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
	      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);
	      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
	      d=GG(d,a,b,c,x[k+10],S22,0x2441453);
	      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
	      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
	      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
	      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
	      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
	      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
	      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
	      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
	      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
	      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
	      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
	      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
	      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
	      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
	      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
	      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
	      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
	      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
	      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
	      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);
	      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
	      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
	      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
	      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
	      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
	      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
	      a=II(a,b,c,d,x[k+0], S41,0xF4292244);
	      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
	      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
	      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
	      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
	      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
	      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
	      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
	      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
	      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
	      c=II(c,d,a,b,x[k+6], S43,0xA3014314);
	      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
	      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
	      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
	      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
	      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
	      a=AddUnsigned(a,AA);
	      b=AddUnsigned(b,BB);
	      c=AddUnsigned(c,CC);
	      d=AddUnsigned(d,DD);
	    }
	
	    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);
	
	    return temp.toLowerCase();
	  }
	};
	
	SIP.Utils = Utils;
	};


/***/ },
/* 215 */
/***/ function(module, exports) {

	"use strict";
	var levels = {
	  'error': 0,
	  'warn': 1,
	  'log': 2,
	  'debug': 3
	};
	
	module.exports = function (console) {
	
	var LoggerFactory = function () {
	  var logger,
	    level = 2,
	    builtinEnabled = true,
	    connector = null;
	
	    this.loggers = {};
	
	    logger = this.getLogger('sip.loggerfactory');
	
	
	  Object.defineProperties(this, {
	    builtinEnabled: {
	      get: function(){ return builtinEnabled; },
	      set: function(value){
	        if (typeof value === 'boolean') {
	          builtinEnabled = value;
	        } else {
	          logger.error('invalid "builtinEnabled" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    },
	
	    level: {
	      get: function() {return level; },
	      set: function(value) {
	        if (value >= 0 && value <=3) {
	          level = value;
	        } else if (value > 3) {
	          level = 3;
	        } else if (levels.hasOwnProperty(value)) {
	          level = levels[value];
	        } else {
	          logger.error('invalid "level" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    },
	
	    connector: {
	      get: function() {return connector; },
	      set: function(value){
	        if(value === null || value === "" || value === undefined) {
	          connector = null;
	        } else if (typeof value === 'function') {
	          connector = value;
	        } else {
	          logger.error('invalid "connector" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    }
	  });
	};
	
	LoggerFactory.prototype.print = function(target, category, label, content) {
	  if (typeof content === 'string') {
	    var prefix = [new Date(), category];
	    if (label) {
	      prefix.push(label);
	    }
	    content = prefix.concat(content).join(' | ');
	  }
	  target.call(console, content);
	};
	
	function Logger (logger, category, label) {
	  this.logger = logger;
	  this.category = category;
	  this.label = label;
	}
	
	Object.keys(levels).forEach(function (targetName) {
	  Logger.prototype[targetName] = function (content) {
	    this.logger[targetName](this.category, this.label, content);
	  };
	
	  LoggerFactory.prototype[targetName] = function (category, label, content) {
	    if (this.level >= levels[targetName]) {
	      if (this.builtinEnabled) {
	        this.print(console[targetName], category, label, content);
	      }
	
	      if (this.connector) {
	        this.connector(targetName, category, label, content);
	      }
	    }
	  };
	});
	
	LoggerFactory.prototype.getLogger = function(category, label) {
	  var logger;
	
	  if (label && this.level === 3) {
	    return new Logger(this, category, label);
	  } else if (this.loggers[category]) {
	    return this.loggers[category];
	  } else {
	    logger = new Logger(this, category);
	    this.loggers[category] = logger;
	    return logger;
	  }
	};
	
	return LoggerFactory;
	};


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var NodeEventEmitter = __webpack_require__(217).EventEmitter;
	
	module.exports = function (console) {
	
	// Don't use `new SIP.EventEmitter()` for inheriting.
	// Use Object.create(SIP.EventEmitter.prototoype);
	function EventEmitter () {
	  NodeEventEmitter.call(this);
	}
	
	EventEmitter.prototype = Object.create(NodeEventEmitter.prototype, {
	  constructor: {
	    value: EventEmitter,
	    enumerable: false,
	    writable: true,
	    configurable: true
	  }
	});
	
	EventEmitter.prototype.off = function off (eventName, listener) {
	  var warning = '';
	  warning += 'SIP.EventEmitter#off is deprecated and may be removed in future SIP.js versions.\n';
	  warning += 'Please use removeListener or removeAllListeners instead.\n';
	  warning += 'See here for more details:\n';
	  warning += 'http://nodejs.org/api/events.html#events_emitter_removelistener_event_listener';
	  console.warn(warning);
	
	  if (arguments.length < 2) {
	    return this.removeAllListeners.apply(this, arguments);
	  } else {
	    return this.removeListener(eventName, listener);
	  }
	};
	
	return EventEmitter;
	
	};


/***/ },
/* 217 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 218 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Constants
	 */
	
	/**
	 * SIP Constants.
	 * @augments SIP
	 */
	
	module.exports = function (name, version) {
	return {
	  USER_AGENT: name +'/'+ version,
	
	  // SIP scheme
	  SIP:  'sip',
	  SIPS: 'sips',
	
	  // End and Failure causes
	  causes: {
	    // Generic error causes
	    CONNECTION_ERROR:         'Connection Error',
	    REQUEST_TIMEOUT:          'Request Timeout',
	    SIP_FAILURE_CODE:         'SIP Failure Code',
	    INTERNAL_ERROR:           'Internal Error',
	
	    // SIP error causes
	    BUSY:                     'Busy',
	    REJECTED:                 'Rejected',
	    REDIRECTED:               'Redirected',
	    UNAVAILABLE:              'Unavailable',
	    NOT_FOUND:                'Not Found',
	    ADDRESS_INCOMPLETE:       'Address Incomplete',
	    INCOMPATIBLE_SDP:         'Incompatible SDP',
	    AUTHENTICATION_ERROR:     'Authentication Error',
	    DIALOG_ERROR:             'Dialog Error',
	
	    // Session error causes
	    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',
	    WEBRTC_ERROR:             'WebRTC Error',
	    CANCELED:                 'Canceled',
	    NO_ANSWER:                'No Answer',
	    EXPIRES:                  'Expires',
	    NO_ACK:                   'No ACK',
	    NO_PRACK:                 'No PRACK',
	    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
	    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',
	    RTP_TIMEOUT:              'RTP Timeout'
	  },
	
	  supported: {
	    UNSUPPORTED:        'none',
	    SUPPORTED:          'supported',
	    REQUIRED:           'required'
	  },
	
	  SIP_ERROR_CAUSES: {
	    REDIRECTED: [300,301,302,305,380],
	    BUSY: [486,600],
	    REJECTED: [403,603],
	    NOT_FOUND: [404,604],
	    UNAVAILABLE: [480,410,408,430],
	    ADDRESS_INCOMPLETE: [484],
	    INCOMPATIBLE_SDP: [488,606],
	    AUTHENTICATION_ERROR:[401,407]
	  },
	
	  // SIP Methods
	  ACK:        'ACK',
	  BYE:        'BYE',
	  CANCEL:     'CANCEL',
	  INFO:       'INFO',
	  INVITE:     'INVITE',
	  MESSAGE:    'MESSAGE',
	  NOTIFY:     'NOTIFY',
	  OPTIONS:    'OPTIONS',
	  REGISTER:   'REGISTER',
	  UPDATE:     'UPDATE',
	  SUBSCRIBE:  'SUBSCRIBE',
	  REFER:      'REFER',
	  PRACK:      'PRACK',
	
	  /* SIP Response Reasons
	   * DOC: http://www.iana.org/assignments/sip-parameters
	   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
	   */
	  REASON_PHRASE: {
	    100: 'Trying',
	    180: 'Ringing',
	    181: 'Call Is Being Forwarded',
	    182: 'Queued',
	    183: 'Session Progress',
	    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199
	    200: 'OK',
	    202: 'Accepted',  // RFC 3265
	    204: 'No Notification',  //RFC 5839
	    300: 'Multiple Choices',
	    301: 'Moved Permanently',
	    302: 'Moved Temporarily',
	    305: 'Use Proxy',
	    380: 'Alternative Service',
	    400: 'Bad Request',
	    401: 'Unauthorized',
	    402: 'Payment Required',
	    403: 'Forbidden',
	    404: 'Not Found',
	    405: 'Method Not Allowed',
	    406: 'Not Acceptable',
	    407: 'Proxy Authentication Required',
	    408: 'Request Timeout',
	    410: 'Gone',
	    412: 'Conditional Request Failed',  // RFC 3903
	    413: 'Request Entity Too Large',
	    414: 'Request-URI Too Long',
	    415: 'Unsupported Media Type',
	    416: 'Unsupported URI Scheme',
	    417: 'Unknown Resource-Priority',  // RFC 4412
	    420: 'Bad Extension',
	    421: 'Extension Required',
	    422: 'Session Interval Too Small',  // RFC 4028
	    423: 'Interval Too Brief',
	    428: 'Use Identity Header',  // RFC 4474
	    429: 'Provide Referrer Identity',  // RFC 3892
	    430: 'Flow Failed',  // RFC 5626
	    433: 'Anonymity Disallowed',  // RFC 5079
	    436: 'Bad Identity-Info',  // RFC 4474
	    437: 'Unsupported Certificate',  // RFC 4744
	    438: 'Invalid Identity Header',  // RFC 4744
	    439: 'First Hop Lacks Outbound Support',  // RFC 5626
	    440: 'Max-Breadth Exceeded',  // RFC 5393
	    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events
	    470: 'Consent Needed',  // RFC 5360
	    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.
	    480: 'Temporarily Unavailable',
	    481: 'Call/Transaction Does Not Exist',
	    482: 'Loop Detected',
	    483: 'Too Many Hops',
	    484: 'Address Incomplete',
	    485: 'Ambiguous',
	    486: 'Busy Here',
	    487: 'Request Terminated',
	    488: 'Not Acceptable Here',
	    489: 'Bad Event',  // RFC 3265
	    491: 'Request Pending',
	    493: 'Undecipherable',
	    494: 'Security Agreement Required',  // RFC 3329
	    500: 'Internal Server Error',
	    501: 'Not Implemented',
	    502: 'Bad Gateway',
	    503: 'Service Unavailable',
	    504: 'Server Time-out',
	    505: 'Version Not Supported',
	    513: 'Message Too Large',
	    580: 'Precondition Failure',  // RFC 3312
	    600: 'Busy Everywhere',
	    603: 'Decline',
	    604: 'Does Not Exist Anywhere',
	    606: 'Not Acceptable'
	  },
	
	  /* SIP Option Tags
	   * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4
	   */
	  OPTION_TAGS: {
	    '100rel':                   true,  // RFC 3262
	    199:                        true,  // RFC 6228
	    answermode:                 true,  // RFC 5373
	    'early-session':            true,  // RFC 3959
	    eventlist:                  true,  // RFC 4662
	    explicitsub:                true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
	    'from-change':              true,  // RFC 4916
	    'geolocation-http':         true,  // RFC 6442
	    'geolocation-sip':          true,  // RFC 6442
	    gin:                        true,  // RFC 6140
	    gruu:                       true,  // RFC 5627
	    histinfo:                   true,  // RFC 7044
	    ice:                        true,  // RFC 5768
	    join:                       true,  // RFC 3911
	    'multiple-refer':           true,  // RFC 5368
	    norefersub:                 true,  // RFC 4488
	    nosub:                      true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
	    outbound:                   true,  // RFC 5626
	    path:                       true,  // RFC 3327
	    policy:                     true,  // RFC 6794
	    precondition:               true,  // RFC 3312
	    pref:                       true,  // RFC 3840
	    privacy:                    true,  // RFC 3323
	    'recipient-list-invite':    true,  // RFC 5366
	    'recipient-list-message':   true,  // RFC 5365
	    'recipient-list-subscribe': true,  // RFC 5367
	    replaces:                   true,  // RFC 3891
	    'resource-priority':        true,  // RFC 4412
	    'sdp-anat':                 true,  // RFC 4092
	    'sec-agree':                true,  // RFC 3329
	    tdialog:                    true,  // RFC 4538
	    timer:                      true,  // RFC 4028
	    uui:                        true   // RFC 7433
	  }
	};
	};


/***/ },
/* 219 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Exceptions
	 */
	
	/**
	 * SIP Exceptions.
	 * @augments SIP
	 */
	module.exports = {
	  ConfigurationError: (function(){
	    var exception = function(parameter, value) {
	      this.code = 1;
	      this.name = 'CONFIGURATION_ERROR';
	      this.parameter = parameter;
	      this.value = value;
	      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter "'+ this.parameter +'"';
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  InvalidStateError: (function(){
	    var exception = function(status) {
	      this.code = 2;
	      this.name = 'INVALID_STATE_ERROR';
	      this.status = status;
	      this.message = 'Invalid status: ' + status;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  NotSupportedError: (function(){
	    var exception = function(message) {
	      this.code = 3;
	      this.name = 'NOT_SUPPORTED_ERROR';
	      this.message = message;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  GetDescriptionError: (function(){
	    var exception = function(message) {
	      this.code = 4;
	      this.name = 'GET_DESCRIPTION_ERROR';
	      this.message = message;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }())
	};


/***/ },
/* 220 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP TIMERS
	 */
	
	/**
	 * @augments SIP
	 */
	var
	  T1 = 500,
	  T2 = 4000,
	  T4 = 5000;
	module.exports = function (timers) {
	  var Timers = {
	    T1: T1,
	    T2: T2,
	    T4: T4,
	    TIMER_B: 64 * T1,
	    TIMER_D: 0  * T1,
	    TIMER_F: 64 * T1,
	    TIMER_H: 64 * T1,
	    TIMER_I: 0  * T1,
	    TIMER_J: 0  * T1,
	    TIMER_K: 0  * T4,
	    TIMER_L: 64 * T1,
	    TIMER_M: 64 * T1,
	    TIMER_N: 64 * T1,
	    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1
	  };
	
	  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']
	  .forEach(function (name) {
	    // can't just use timers[name].bind(timers) since it bypasses jasmine's
	    // clock-mocking
	    Timers[name] = function () {
	      return timers[name].apply(timers, arguments);
	    };
	  });
	
	  return Timers;
	};


/***/ },
/* 221 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Message Parser
	 */
	
	/**
	 * Extract and parse every header of a SIP message.
	 * @augments SIP
	 * @namespace
	 */
	module.exports = function (SIP) {
	var Parser;
	
	function getHeader(data, headerStart) {
	  var
	    // 'start' position of the header.
	    start = headerStart,
	    // 'end' position of the header.
	    end = 0,
	    // 'partial end' position of the header.
	    partialEnd = 0;
	
	  //End of message.
	  if (data.substring(start, start + 2).match(/(^\r\n)/)) {
	    return -2;
	  }
	
	  while(end === 0) {
	    // Partial End of Header.
	    partialEnd = data.indexOf('\r\n', start);
	
	    // 'indexOf' returns -1 if the value to be found never occurs.
	    if (partialEnd === -1) {
	      return partialEnd;
	    }
	
	    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
	      // Not the end of the message. Continue from the next position.
	      start = partialEnd + 2;
	    } else {
	      end = partialEnd;
	    }
	  }
	
	  return end;
	}
	
	function parseHeader(message, data, headerStart, headerEnd) {
	  var header, idx, length, parsed,
	    hcolonIndex = data.indexOf(':', headerStart),
	    headerName = data.substring(headerStart, hcolonIndex).trim(),
	    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
	
	  // If header-field is well-known, parse it.
	  switch(headerName.toLowerCase()) {
	    case 'via':
	    case 'v':
	      message.addHeader('via', headerValue);
	      if(message.getHeaders('via').length === 1) {
	        parsed = message.parseHeader('Via');
	        if(parsed) {
	          message.via = parsed;
	          message.via_branch = parsed.branch;
	        }
	      } else {
	        parsed = 0;
	      }
	      break;
	    case 'from':
	    case 'f':
	      message.setHeader('from', headerValue);
	      parsed = message.parseHeader('from');
	      if(parsed) {
	        message.from = parsed;
	        message.from_tag = parsed.getParam('tag');
	      }
	      break;
	    case 'to':
	    case 't':
	      message.setHeader('to', headerValue);
	      parsed = message.parseHeader('to');
	      if(parsed) {
	        message.to = parsed;
	        message.to_tag = parsed.getParam('tag');
	      }
	      break;
	    case 'record-route':
	      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');
	
	      if (parsed === -1) {
	        parsed = undefined;
	        break;
	      }
	
	      length = parsed.length;
	      for (idx = 0; idx < length; idx++) {
	        header = parsed[idx];
	        message.addHeader('record-route', headerValue.substring(header.position, header.offset));
	        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;
	      }
	      break;
	    case 'call-id':
	    case 'i':
	      message.setHeader('call-id', headerValue);
	      parsed = message.parseHeader('call-id');
	      if(parsed) {
	        message.call_id = headerValue;
	      }
	      break;
	    case 'contact':
	    case 'm':
	      parsed = SIP.Grammar.parse(headerValue, 'Contact');
	
	      if (parsed === -1) {
	        parsed = undefined;
	        break;
	      }
	
	      length = parsed.length;
	      for (idx = 0; idx < length; idx++) {
	        header = parsed[idx];
	        message.addHeader('contact', headerValue.substring(header.position, header.offset));
	        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;
	      }
	      break;
	    case 'content-length':
	    case 'l':
	      message.setHeader('content-length', headerValue);
	      parsed = message.parseHeader('content-length');
	      break;
	    case 'content-type':
	    case 'c':
	      message.setHeader('content-type', headerValue);
	      parsed = message.parseHeader('content-type');
	      break;
	    case 'cseq':
	      message.setHeader('cseq', headerValue);
	      parsed = message.parseHeader('cseq');
	      if(parsed) {
	        message.cseq = parsed.value;
	      }
	      if(message instanceof SIP.IncomingResponse) {
	        message.method = parsed.method;
	      }
	      break;
	    case 'max-forwards':
	      message.setHeader('max-forwards', headerValue);
	      parsed = message.parseHeader('max-forwards');
	      break;
	    case 'www-authenticate':
	      message.setHeader('www-authenticate', headerValue);
	      parsed = message.parseHeader('www-authenticate');
	      break;
	    case 'proxy-authenticate':
	      message.setHeader('proxy-authenticate', headerValue);
	      parsed = message.parseHeader('proxy-authenticate');
	      break;
	    case 'refer-to':
	    case 'r':
	      message.setHeader('refer-to', headerValue);
	      parsed = message.parseHeader('refer-to');
	      if (parsed) {
	        message.refer_to = parsed;
	      }
	      break;
	    default:
	      // Do not parse this header.
	      message.setHeader(headerName, headerValue);
	      parsed = 0;
	  }
	
	  if (parsed === undefined) {
	    return {
	      error: 'error parsing header "'+ headerName +'"'
	    };
	  } else {
	    return true;
	  }
	}
	
	/** Parse SIP Message
	 * @function
	 * @param {String} message SIP message.
	 * @param {Object} logger object.
	 * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}
	 */
	Parser = {};
	Parser.parseMessage = function(data, ua) {
	  var message, firstLine, contentLength, bodyStart, parsed,
	    headerStart = 0,
	    headerEnd = data.indexOf('\r\n'),
	    logger = ua.getLogger('sip.parser');
	
	  if(headerEnd === -1) {
	    logger.warn('no CRLF found, not a SIP message, discarded');
	    return;
	  }
	
	  // Parse first line. Check if it is a Request or a Reply.
	  firstLine = data.substring(0, headerEnd);
	  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');
	
	  if(parsed === -1) {
	    logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
	    return;
	  } else if(!parsed.status_code) {
	    message = new SIP.IncomingRequest(ua);
	    message.method = parsed.method;
	    message.ruri = parsed.uri;
	  } else {
	    message = new SIP.IncomingResponse(ua);
	    message.status_code = parsed.status_code;
	    message.reason_phrase = parsed.reason_phrase;
	  }
	
	  message.data = data;
	  headerStart = headerEnd + 2;
	
	  /* Loop over every line in data. Detect the end of each header and parse
	  * it or simply add to the headers collection.
	  */
	  while(true) {
	    headerEnd = getHeader(data, headerStart);
	
	    // The SIP message has normally finished.
	    if(headerEnd === -2) {
	      bodyStart = headerStart + 2;
	      break;
	    }
	    // data.indexOf returned -1 due to a malformed message.
	    else if(headerEnd === -1) {
	      logger.error('malformed message');
	      return;
	    }
	
	    parsed = parseHeader(message, data, headerStart, headerEnd);
	
	    if(parsed !== true) {
	      logger.error(parsed.error);
	      return;
	    }
	
	    headerStart = headerEnd + 2;
	  }
	
	  /* RFC3261 18.3.
	   * If there are additional bytes in the transport packet
	   * beyond the end of the body, they MUST be discarded.
	   */
	  if(message.hasHeader('content-length')) {
	    contentLength = message.getHeader('content-length');
	    message.body = data.substr(bodyStart, contentLength);
	  } else {
	    message.body = data.substring(bodyStart);
	  }
	
	  return message;
	};
	
	SIP.Parser = Parser;
	};


/***/ },
/* 222 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Message
	 */
	
	module.exports = function (SIP) {
	var
	  OutgoingRequest,
	  IncomingMessage,
	  IncomingRequest,
	  IncomingResponse;
	
	function getSupportedHeader (request) {
	  var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags;
	  var optionTags = [];
	  var optionTagSet = {};
	
	  if (request.method === SIP.C.REGISTER) {
	    optionTags.push('path', 'gruu');
	  } else if (request.method === SIP.C.INVITE &&
	             (request.ua.contact.pub_gruu || request.ua.contact.temp_gruu)) {
	    optionTags.push('gruu');
	  }
	
	  if (request.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {
	    optionTags.push('100rel');
	  }
	  if (request.ua.configuration.replaces === SIP.C.supported.SUPPORTED) {
	    optionTags.push('replaces');
	  }
	
	  optionTags.push('outbound');
	
	  optionTags = optionTags.concat(request.ua.configuration.extraSupported);
	
	  optionTags = optionTags.filter(function(optionTag) {
	    var registered = SIP.C.OPTION_TAGS[optionTag];
	    var unique = !optionTagSet[optionTag];
	    optionTagSet[optionTag] = true;
	    return (registered || allowUnregistered) && unique;
	  });
	
	  return 'Supported: ' + optionTags.join(', ') + '\r\n';
	}
	
	/**
	 * @augments SIP
	 * @class Class for outgoing SIP request.
	 * @param {String} method request method
	 * @param {String} ruri request uri
	 * @param {SIP.UA} ua
	 * @param {Object} params parameters that will have priority over ua.configuration parameters:
	 * <br>
	 *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set
	 * @param {Object} [headers] extra headers
	 * @param {String} [body]
	 */
	OutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {
	  var
	    to,
	    from,
	    call_id,
	    cseq,
	    to_uri,
	    from_uri;
	
	  params = params || {};
	
	  // Mandatory parameters check
	  if(!method || !ruri || !ua) {
	    return null;
	  }
	
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.ua = ua;
	  this.headers = {};
	  this.method = method;
	  this.ruri = ruri;
	  this.body = body;
	  this.extraHeaders = (extraHeaders || []).slice();
	  this.statusCode = params.status_code;
	  this.reasonPhrase = params.reason_phrase;
	
	  // Fill the Common SIP Request Headers
	
	  // Route
	  if (params.route_set) {
	    this.setHeader('route', params.route_set);
	  } else if (ua.configuration.usePreloadedRoute){
	    this.setHeader('route', ua.transport.server.sip_uri);
	  }
	
	  // Via
	  // Empty Via header. Will be filled by the client transaction.
	  this.setHeader('via', '');
	
	  // Max-Forwards
	  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);
	
	  // To
	  to_uri = params.to_uri || ruri;
	  to = (params.to_displayName || params.to_displayName === 0) ? '"' + params.to_displayName + '" ' : '';
	  to += '<' + (to_uri && to_uri.toRaw ? to_uri.toRaw() : to_uri) + '>';
	  to += params.to_tag ? ';tag=' + params.to_tag : '';
	  this.to = new SIP.NameAddrHeader.parse(to);
	  this.setHeader('to', to);
	
	  // From
	  from_uri = params.from_uri || ua.configuration.uri;
	  if (params.from_displayName || params.from_displayName === 0) {
	    from = '"' + params.from_displayName + '" ';
	  } else if (ua.configuration.displayName) {
	    from = '"' + ua.configuration.displayName + '" ';
	  } else {
	    from = '';
	  }
	  from += '<' + (from_uri && from_uri.toRaw ? from_uri.toRaw() : from_uri) + '>;tag=';
	  from += params.from_tag || SIP.Utils.newTag();
	  this.from = new SIP.NameAddrHeader.parse(from);
	  this.setHeader('from', from);
	
	  // Call-ID
	  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));
	  this.call_id = call_id;
	  this.setHeader('call-id', call_id);
	
	  // CSeq
	  cseq = params.cseq || Math.floor(Math.random() * 10000);
	  this.cseq = cseq;
	  this.setHeader('cseq', cseq + ' ' + method);
	};
	
	OutgoingRequest.prototype = {
	  /**
	   * Replace the the given header by the given value.
	   * @param {String} name header name
	   * @param {String | Array} value header value
	   */
	  setHeader: function(name, value) {
	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
	  },
	
	  /**
	   * Get the value of the given header name at the given position.
	   * @param {String} name header name
	   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.
	   */
	  getHeader: function(name) {
	    var regexp, idx,
	      length = this.extraHeaders.length,
	      header = this.headers[SIP.Utils.headerize(name)];
	
	    if(header) {
	      if(header[0]) {
	        return header[0];
	      }
	    } else {
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        header = this.extraHeaders[idx];
	        if (regexp.test(header)) {
	          return header.substring(header.indexOf(':')+1).trim();
	        }
	      }
	    }
	
	    return;
	  },
	
	  /**
	   * Get the header/s of the given name.
	   * @param {String} name header name
	   * @returns {Array} Array with all the headers of the specified name.
	   */
	  getHeaders: function(name) {
	    var idx, length, regexp,
	      header = this.headers[SIP.Utils.headerize(name)],
	      result = [];
	
	    if(header) {
	      length = header.length;
	      for (idx = 0; idx < length; idx++) {
	        result.push(header[idx]);
	      }
	      return result;
	    } else {
	      length = this.extraHeaders.length;
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        header = this.extraHeaders[idx];
	        if (regexp.test(header)) {
	          result.push(header.substring(header.indexOf(':')+1).trim());
	        }
	      }
	      return result;
	    }
	  },
	
	  /**
	   * Verify the existence of the given header.
	   * @param {String} name header name
	   * @returns {boolean} true if header with given name exists, false otherwise
	   */
	  hasHeader: function(name) {
	    var regexp, idx,
	      length = this.extraHeaders.length;
	
	    if (this.headers[SIP.Utils.headerize(name)]) {
	      return true;
	    } else {
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        if (regexp.test(this.extraHeaders[idx])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  },
	
	  toString: function() {
	    var msg = '', header, length, idx;
	
	    msg += this.method + ' ' + (this.ruri.toRaw ? this.ruri.toRaw() : this.ruri) + ' SIP/2.0\r\n';
	
	    for (header in this.headers) {
	      length = this.headers[header].length;
	      for (idx = 0; idx < length; idx++) {
	        msg += header + ': ' + this.headers[header][idx] + '\r\n';
	      }
	    }
	
	    length = this.extraHeaders.length;
	    for (idx = 0; idx < length; idx++) {
	      msg += this.extraHeaders[idx].trim() +'\r\n';
	    }
	
	    msg += getSupportedHeader(this);
	    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	
	    if(this.body) {
	      length = SIP.Utils.str_utf8_length(this.body);
	      msg += 'Content-Length: ' + length + '\r\n\r\n';
	      msg += this.body;
	    } else {
	      msg += 'Content-Length: 0\r\n\r\n';
	    }
	
	    return msg;
	  }
	};
	
	/**
	 * @augments SIP
	 * @class Class for incoming SIP message.
	 */
	IncomingMessage = function(){
	  this.data = null;
	  this.headers = null;
	  this.method =  null;
	  this.via = null;
	  this.via_branch = null;
	  this.call_id = null;
	  this.cseq = null;
	  this.from = null;
	  this.from_tag = null;
	  this.to = null;
	  this.to_tag = null;
	  this.body = null;
	};
	
	IncomingMessage.prototype = {
	  /**
	  * Insert a header of the given name and value into the last position of the
	  * header array.
	  * @param {String} name header name
	  * @param {String} value header value
	  */
	  addHeader: function(name, value) {
	    var header = { raw: value };
	
	    name = SIP.Utils.headerize(name);
	
	    if(this.headers[name]) {
	      this.headers[name].push(header);
	    } else {
	      this.headers[name] = [header];
	    }
	  },
	
	  /**
	   * Get the value of the given header name at the given position.
	   * @param {String} name header name
	   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.
	   */
	  getHeader: function(name) {
	    var header = this.headers[SIP.Utils.headerize(name)];
	
	    if(header) {
	      if(header[0]) {
	        return header[0].raw;
	      }
	    } else {
	      return;
	    }
	  },
	
	  /**
	   * Get the header/s of the given name.
	   * @param {String} name header name
	   * @returns {Array} Array with all the headers of the specified name.
	   */
	  getHeaders: function(name) {
	    var idx, length,
	      header = this.headers[SIP.Utils.headerize(name)],
	      result = [];
	
	    if(!header) {
	      return [];
	    }
	
	    length = header.length;
	    for (idx = 0; idx < length; idx++) {
	      result.push(header[idx].raw);
	    }
	
	    return result;
	  },
	
	  /**
	   * Verify the existence of the given header.
	   * @param {String} name header name
	   * @returns {boolean} true if header with given name exists, false otherwise
	   */
	  hasHeader: function(name) {
	    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;
	  },
	
	  /**
	  * Parse the given header on the given index.
	  * @param {String} name header name
	  * @param {Number} [idx=0] header index
	  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
	  */
	  parseHeader: function(name, idx) {
	    var header, value, parsed;
	
	    name = SIP.Utils.headerize(name);
	
	    idx = idx || 0;
	
	    if(!this.headers[name]) {
	      this.logger.log('header "' + name + '" not present');
	      return;
	    } else if(idx >= this.headers[name].length) {
	      this.logger.log('not so many "' + name + '" headers present');
	      return;
	    }
	
	    header = this.headers[name][idx];
	    value = header.raw;
	
	    if(header.parsed) {
	      return header.parsed;
	    }
	
	    //substitute '-' by '_' for grammar rule matching.
	    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));
	
	    if(parsed === -1) {
	      this.headers[name].splice(idx, 1); //delete from headers
	      this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
	      return;
	    } else {
	      header.parsed = parsed;
	      return parsed;
	    }
	  },
	
	  /**
	   * Message Header attribute selector. Alias of parseHeader.
	   * @param {String} name header name
	   * @param {Number} [idx=0] header index
	   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
	   *
	   * @example
	   * message.s('via',3).port
	   */
	  s: function(name, idx) {
	    return this.parseHeader(name, idx);
	  },
	
	  /**
	  * Replace the value of the given header by the value.
	  * @param {String} name header name
	  * @param {String} value header value
	  */
	  setHeader: function(name, value) {
	    var header = { raw: value };
	    this.headers[SIP.Utils.headerize(name)] = [header];
	  },
	
	  toString: function() {
	    return this.data;
	  }
	};
	
	/**
	 * @augments IncomingMessage
	 * @class Class for incoming SIP request.
	 */
	IncomingRequest = function(ua) {
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.ua = ua;
	  this.headers = {};
	  this.ruri = null;
	  this.transport = null;
	  this.server_transaction = null;
	};
	IncomingRequest.prototype = new IncomingMessage();
	
	/**
	* Stateful reply.
	* @param {Number} code status code
	* @param {String} reason reason phrase
	* @param {Object} headers extra headers
	* @param {String} body body
	* @param {Function} [onSuccess] onSuccess callback
	* @param {Function} [onFailure] onFailure callback
	*/
	IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {
	  var rr, vias, length, idx, response,
	    to = this.getHeader('To'),
	    r = 0,
	    v = 0;
	
	  response = SIP.Utils.buildStatusLine(code, reason);
	  extraHeaders = (extraHeaders || []).slice();
	
	  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {
	    rr = this.getHeaders('record-route');
	    length = rr.length;
	
	    for(r; r < length; r++) {
	      response += 'Record-Route: ' + rr[r] + '\r\n';
	    }
	  }
	
	  vias = this.getHeaders('via');
	  length = vias.length;
	
	  for(v; v < length; v++) {
	    response += 'Via: ' + vias[v] + '\r\n';
	  }
	
	  if(!this.to_tag && code > 100) {
	    to += ';tag=' + SIP.Utils.newTag();
	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
	    to += ';tag=' + this.to_tag;
	  }
	
	  response += 'To: ' + to + '\r\n';
	  response += 'From: ' + this.getHeader('From') + '\r\n';
	  response += 'Call-ID: ' + this.call_id + '\r\n';
	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
	
	  length = extraHeaders.length;
	  for (idx = 0; idx < length; idx++) {
	    response += extraHeaders[idx].trim() +'\r\n';
	  }
	
	  response += getSupportedHeader(this);
	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	
	  if(body) {
	    length = SIP.Utils.str_utf8_length(body);
	    response += 'Content-Type: application/sdp\r\n';
	    response += 'Content-Length: ' + length + '\r\n\r\n';
	    response += body;
	  } else {
	    response += 'Content-Length: ' + 0 + '\r\n\r\n';
	  }
	
	  this.server_transaction.receiveResponse(code, response).then(onSuccess, onFailure);
	
	  return response;
	};
	
	/**
	* Stateless reply.
	* @param {Number} code status code
	* @param {String} reason reason phrase
	*/
	IncomingRequest.prototype.reply_sl = function(code, reason) {
	  var to, response,
	    v = 0,
	    vias = this.getHeaders('via'),
	    length = vias.length;
	
	  response = SIP.Utils.buildStatusLine(code, reason);
	
	  for(v; v < length; v++) {
	    response += 'Via: ' + vias[v] + '\r\n';
	  }
	
	  to = this.getHeader('To');
	
	  if(!this.to_tag && code > 100) {
	    to += ';tag=' + SIP.Utils.newTag();
	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
	    to += ';tag=' + this.to_tag;
	  }
	
	  response += 'To: ' + to + '\r\n';
	  response += 'From: ' + this.getHeader('From') + '\r\n';
	  response += 'Call-ID: ' + this.call_id + '\r\n';
	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	  response += 'Content-Length: ' + 0 + '\r\n\r\n';
	
	  this.transport.send(response);
	};
	
	
	/**
	 * @augments IncomingMessage
	 * @class Class for incoming SIP response.
	 */
	IncomingResponse = function(ua) {
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.headers = {};
	  this.status_code = null;
	  this.reason_phrase = null;
	};
	IncomingResponse.prototype = new IncomingMessage();
	
	SIP.OutgoingRequest = OutgoingRequest;
	SIP.IncomingRequest = IncomingRequest;
	SIP.IncomingResponse = IncomingResponse;
	};


/***/ },
/* 223 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP URI
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP URI.
	 *
	 * @param {String} [scheme]
	 * @param {String} [user]
	 * @param {String} host
	 * @param {String} [port]
	 * @param {Object} [parameters]
	 * @param {Object} [headers]
	 *
	 */
	module.exports = function (SIP) {
	var URI;
	
	URI = function(scheme, user, host, port, parameters, headers) {
	  var param, header, raw, normal;
	
	  // Checks
	  if(!host) {
	    throw new TypeError('missing or invalid "host" parameter');
	  }
	
	  // Initialize parameters
	  scheme = scheme || SIP.C.SIP;
	  this.parameters = {};
	  this.headers = {};
	
	  for (param in parameters) {
	    this.setParam(param, parameters[param]);
	  }
	
	  for (header in headers) {
	    this.setHeader(header, headers[header]);
	  }
	
	  // Raw URI
	  raw = {
	    scheme: scheme,
	    user: user,
	    host: host,
	    port: port
	  };
	
	  // Normalized URI
	  normal = {
	    scheme: scheme.toLowerCase(),
	    user: user,
	    host: host.toLowerCase(),
	    port: port
	  };
	
	  Object.defineProperties(this, {
	    _normal: {
	      get: function() { return normal; }
	    },
	
	    _raw: {
	      get: function() { return raw; }
	    },
	
	    scheme: {
	      get: function() { return normal.scheme; },
	      set: function(value) {
	        raw.scheme = value;
	        normal.scheme = value.toLowerCase();
	      }
	    },
	
	    user: {
	      get: function() { return normal.user; },
	      set: function(value) {
	        normal.user = raw.user = value;
	      }
	    },
	
	    host: {
	      get: function() { return normal.host; },
	      set: function(value) {
	        raw.host = value;
	        normal.host = value.toLowerCase();
	      }
	    },
	
	    aor: {
	      get: function() { return normal.user + '@' + normal.host; }
	    },
	
	    port: {
	      get: function() { return normal.port; },
	      set: function(value) {
	        normal.port = raw.port = value === 0 ? value : (parseInt(value,10) || null);
	      }
	    }
	  });
	};
	
	URI.prototype = {
	  setParam: function(key, value) {
	    if(key) {
	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();
	    }
	  },
	
	  getParam: function(key) {
	    if(key) {
	      return this.parameters[key.toLowerCase()];
	    }
	  },
	
	  hasParam: function(key) {
	    if(key) {
	      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
	    }
	  },
	
	  deleteParam: function(parameter) {
	    var value;
	    parameter = parameter.toLowerCase();
	    if (this.parameters.hasOwnProperty(parameter)) {
	      value = this.parameters[parameter];
	      delete this.parameters[parameter];
	      return value;
	    }
	  },
	
	  clearParams: function() {
	    this.parameters = {};
	  },
	
	  setHeader: function(name, value) {
	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
	  },
	
	  getHeader: function(name) {
	    if(name) {
	      return this.headers[SIP.Utils.headerize(name)];
	    }
	  },
	
	  hasHeader: function(name) {
	    if(name) {
	      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;
	    }
	  },
	
	  deleteHeader: function(header) {
	    var value;
	    header = SIP.Utils.headerize(header);
	    if(this.headers.hasOwnProperty(header)) {
	      value = this.headers[header];
	      delete this.headers[header];
	      return value;
	    }
	  },
	
	  clearHeaders: function() {
	    this.headers = {};
	  },
	
	  clone: function() {
	    return new URI(
	      this._raw.scheme,
	      this._raw.user,
	      this._raw.host,
	      this._raw.port,
	      JSON.parse(JSON.stringify(this.parameters)),
	      JSON.parse(JSON.stringify(this.headers)));
	  },
	
	  toRaw: function() {
	    return this._toString(this._raw);
	  },
	
	  toString: function() {
	    return this._toString(this._normal);
	  },
	
	  _toString: function(uri) {
	    var header, parameter, idx, uriString, headers = [];
	
	    uriString  = uri.scheme + ':';
	    // add slashes if it's not a sip(s) URI
	    if (!uri.scheme.toLowerCase().match("^sips?$")) {
	      uriString += "//";
	    }
	    if (uri.user) {
	      uriString += SIP.Utils.escapeUser(uri.user) + '@';
	    }
	    uriString += uri.host;
	    if (uri.port || uri.port === 0) {
	      uriString += ':' + uri.port;
	    }
	
	    for (parameter in this.parameters) {
	      uriString += ';' + parameter;
	
	      if (this.parameters[parameter] !== null) {
	        uriString += '='+ this.parameters[parameter];
	      }
	    }
	
	    for(header in this.headers) {
	      for(idx in this.headers[header]) {
	        headers.push(header + '=' + this.headers[header][idx]);
	      }
	    }
	
	    if (headers.length > 0) {
	      uriString += '?' + headers.join('&');
	    }
	
	    return uriString;
	  }
	};
	
	
	/**
	  * Parse the given string and returns a SIP.URI instance or undefined if
	  * it is an invalid URI.
	  * @public
	  * @param {String} uri
	  */
	URI.parse = function(uri) {
	  uri = SIP.Grammar.parse(uri,'SIP_URI');
	
	  if (uri !== -1) {
	    return uri;
	  } else {
	    return undefined;
	  }
	};
	
	SIP.URI = URI;
	};


/***/ },
/* 224 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP NameAddrHeader
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a Name Address SIP header.
	 *
	 * @param {SIP.URI} uri
	 * @param {String} [displayName]
	 * @param {Object} [parameters]
	 *
	 */
	module.exports = function (SIP) {
	var NameAddrHeader;
	
	NameAddrHeader = function(uri, displayName, parameters) {
	  var param;
	
	  // Checks
	  if(!uri || !(uri instanceof SIP.URI)) {
	    throw new TypeError('missing or invalid "uri" parameter');
	  }
	
	  // Initialize parameters
	  this.uri = uri;
	  this.parameters = {};
	
	  for (param in parameters) {
	    this.setParam(param, parameters[param]);
	  }
	
	  Object.defineProperties(this, {
	    friendlyName: {
	      get: function() { return this.displayName || uri.aor; }
	    },
	
	    displayName: {
	      get: function() { return displayName; },
	      set: function(value) {
	        displayName = (value === 0) ? '0' : value;
	      }
	    }
	  });
	};
	NameAddrHeader.prototype = {
	  setParam: function (key, value) {
	    if(key) {
	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();
	    }
	  },
	  getParam: SIP.URI.prototype.getParam,
	  hasParam: SIP.URI.prototype.hasParam,
	  deleteParam: SIP.URI.prototype.deleteParam,
	  clearParams: SIP.URI.prototype.clearParams,
	
	  clone: function() {
	    return new NameAddrHeader(
	      this.uri.clone(),
	      this.displayName,
	      JSON.parse(JSON.stringify(this.parameters)));
	  },
	
	  toString: function() {
	    var body, parameter;
	
	    body  = (this.displayName || this.displayName === 0) ? '"' + this.displayName + '" ' : '';
	    body += '<' + this.uri.toString() + '>';
	
	    for (parameter in this.parameters) {
	      body += ';' + parameter;
	
	      if (this.parameters[parameter] !== null) {
	        body += '='+ this.parameters[parameter];
	      }
	    }
	
	    return body;
	  }
	};
	
	
	/**
	  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if
	  * it is an invalid NameAddrHeader.
	  * @public
	  * @param {String} name_addr_header
	  */
	NameAddrHeader.parse = function(name_addr_header) {
	  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');
	
	  if (name_addr_header !== -1) {
	    return name_addr_header;
	  } else {
	    return undefined;
	  }
	};
	
	SIP.NameAddrHeader = NameAddrHeader;
	};


/***/ },
/* 225 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Transactions
	 */
	
	/**
	 * SIP Transactions module.
	 * @augments SIP
	 */
	module.exports = function (SIP) {
	var
	  C = {
	    // Transaction states
	    STATUS_TRYING:     1,
	    STATUS_PROCEEDING: 2,
	    STATUS_CALLING:    3,
	    STATUS_ACCEPTED:   4,
	    STATUS_COMPLETED:  5,
	    STATUS_TERMINATED: 6,
	    STATUS_CONFIRMED:  7,
	
	    // Transaction types
	    NON_INVITE_CLIENT: 'nict',
	    NON_INVITE_SERVER: 'nist',
	    INVITE_CLIENT: 'ict',
	    INVITE_SERVER: 'ist'
	  };
	
	function buildViaHeader (request_sender, transport, id) {
	  var via;
	  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);
	  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;
	  if (request_sender.ua.configuration.forceRport) {
	    via += ';rport';
	  }
	  return via;
	}
	
	/**
	* @augments SIP.Transactions
	* @class Non Invite Client Transaction
	* @param {SIP.RequestSender} request_sender
	* @param {SIP.OutgoingRequest} request
	* @param {SIP.Transport} transport
	*/
	var NonInviteClientTransaction = function(request_sender, request, transport) {
	  var via;
	
	  this.type = C.NON_INVITE_CLIENT;
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	
	  this.request_sender.ua.newTransaction(this);
	};
	NonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	NonInviteClientTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	NonInviteClientTransaction.prototype.send = function() {
	  var tr = this;
	
	  this.stateChanged(C.STATUS_TRYING);
	  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);
	
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	NonInviteClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.F);
	  SIP.Timers.clearTimeout(this.K);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	  this.request_sender.onTransportError();
	};
	
	NonInviteClientTransaction.prototype.timer_F = function() {
	  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	  this.request_sender.onRequestTimeout();
	};
	
	NonInviteClientTransaction.prototype.timer_K = function() {
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	};
	
	NonInviteClientTransaction.prototype.receiveResponse = function(response) {
	  var
	    tr = this,
	    status_code = response.status_code;
	
	  if(status_code < 200) {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        SIP.Timers.clearTimeout(this.F);
	
	        if(status_code === 408) {
	          this.request_sender.onRequestTimeout();
	        } else {
	          this.request_sender.receiveResponse(response);
	        }
	
	        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);
	        break;
	      case C.STATUS_COMPLETED:
	        break;
	    }
	  }
	};
	
	
	
	/**
	* @augments SIP.Transactions
	* @class Invite Client Transaction
	* @param {SIP.RequestSender} request_sender
	* @param {SIP.OutgoingRequest} request
	* @param {SIP.Transport} transport
	*/
	var InviteClientTransaction = function(request_sender, request, transport) {
	  var via,
	    tr = this;
	
	  this.type = C.INVITE_CLIENT;
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	
	  this.request_sender.ua.newTransaction(this);
	
	  // Add the cancel property to the request.
	  //Will be called from the request instance, not the transaction itself.
	  this.request.cancel = function(reason) {
	    tr.cancel_request(tr, reason);
	  };
	};
	InviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	InviteClientTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	InviteClientTransaction.prototype.send = function() {
	  var tr = this;
	  this.stateChanged(C.STATUS_CALLING);
	  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);
	
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	InviteClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.B);
	  SIP.Timers.clearTimeout(this.D);
	  SIP.Timers.clearTimeout(this.M);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	
	  if (this.state !== C.STATUS_ACCEPTED) {
	    this.request_sender.onTransportError();
	  }
	};
	
	// RFC 6026 7.2
	InviteClientTransaction.prototype.timer_M = function() {
	  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);
	
	  if(this.state === C.STATUS_ACCEPTED) {
	    SIP.Timers.clearTimeout(this.B);
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.request_sender.ua.destroyTransaction(this);
	  }
	};
	
	// RFC 3261 17.1.1
	InviteClientTransaction.prototype.timer_B = function() {
	  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);
	  if(this.state === C.STATUS_CALLING) {
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.request_sender.ua.destroyTransaction(this);
	    this.request_sender.onRequestTimeout();
	  }
	};
	
	InviteClientTransaction.prototype.timer_D = function() {
	  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.B);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	};
	
	InviteClientTransaction.prototype.sendACK = function(response) {
	  var tr = this;
	
	  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\r\n';
	  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\r\n';
	
	  if(this.request.headers['Route']) {
	    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\r\n';
	  }
	
	  this.ack += 'To: ' + response.getHeader('to') + '\r\n';
	  this.ack += 'From: ' + this.request.headers['From'].toString() + '\r\n';
	  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\r\n';
	  this.ack += 'Content-Length: 0\r\n';
	  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];
	  this.ack += ' ACK\r\n\r\n';
	
	  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);
	
	  this.transport.send(this.ack);
	};
	
	InviteClientTransaction.prototype.cancel_request = function(tr, reason) {
	  var request = tr.request;
	
	  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\r\n';
	  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\r\n';
	
	  if(this.request.headers['Route']) {
	    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\r\n';
	  }
	
	  this.cancel += 'To: ' + request.headers['To'].toString() + '\r\n';
	  this.cancel += 'From: ' + request.headers['From'].toString() + '\r\n';
	  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\r\n';
	  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +
	  ' CANCEL\r\n';
	
	  if(reason) {
	    this.cancel += 'Reason: ' + reason + '\r\n';
	  }
	
	  this.cancel += 'Content-Length: 0\r\n\r\n';
	
	  // Send only if a provisional response (>100) has been received.
	  if(this.state === C.STATUS_PROCEEDING) {
	    this.transport.send(this.cancel);
	  }
	};
	
	InviteClientTransaction.prototype.receiveResponse = function(response) {
	  var
	  tr = this,
	  status_code = response.status_code;
	
	  if(status_code >= 100 && status_code <= 199) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        this.request_sender.receiveResponse(response);
	        if(this.cancel) {
	          this.transport.send(this.cancel);
	        }
	        break;
	      case C.STATUS_PROCEEDING:
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else if(status_code >= 200 && status_code <= 299) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_ACCEPTED);
	        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);
	        this.request_sender.receiveResponse(response);
	        break;
	      case C.STATUS_ACCEPTED:
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else if(status_code >= 300 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        this.sendACK(response);
	        this.request_sender.receiveResponse(response);
	        break;
	      case C.STATUS_COMPLETED:
	        this.sendACK(response);
	        break;
	    }
	  }
	};
	
	
	/**
	 * @augments SIP.Transactions
	 * @class ACK Client Transaction
	 * @param {SIP.RequestSender} request_sender
	 * @param {SIP.OutgoingRequest} request
	 * @param {SIP.Transport} transport
	 */
	var AckClientTransaction = function(request_sender, request, transport) {
	  var via;
	
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	};
	AckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	AckClientTransaction.prototype.send = function() {
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	AckClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);
	  this.request_sender.onTransportError();
	};
	
	
	/**
	* @augments SIP.Transactions
	* @class Non Invite Server Transaction
	* @param {SIP.IncomingRequest} request
	* @param {SIP.UA} ua
	*/
	var NonInviteServerTransaction = function(request, ua) {
	  this.type = C.NON_INVITE_SERVER;
	  this.id = request.via_branch;
	  this.request = request;
	  this.transport = request.transport;
	  this.ua = ua;
	  this.last_response = '';
	  request.server_transaction = this;
	
	  this.logger = ua.getLogger('sip.transaction.nist', this.id);
	
	  this.state = C.STATUS_TRYING;
	
	  ua.newTransaction(this);
	};
	NonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	NonInviteServerTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	NonInviteServerTransaction.prototype.timer_J = function() {
	  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	NonInviteServerTransaction.prototype.onTransportError = function() {
	  if (!this.transportError) {
	    this.transportError = true;
	
	    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);
	
	    SIP.Timers.clearTimeout(this.J);
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	NonInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
	  var tr = this;
	  var deferred = SIP.Utils.defer();
	
	  if(status_code === 100) {
	    /* RFC 4320 4.1
	     * 'A SIP element MUST NOT
	     * send any provisional response with a
	     * Status-Code other than 100 to a non-INVITE request.'
	     */
	    switch(this.state) {
	      case C.STATUS_TRYING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        if(!this.transport.send(response))  {
	          this.onTransportError();
	        }
	        break;
	      case C.STATUS_PROCEEDING:
	        this.last_response = response;
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          deferred.resolve();
	        }
	        break;
	    }
	  } else if(status_code >= 200 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        this.last_response = response;
	        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          deferred.resolve();
	        }
	        break;
	      case C.STATUS_COMPLETED:
	        break;
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	* @augments SIP.Transactions
	* @class Invite Server Transaction
	* @param {SIP.IncomingRequest} request
	* @param {SIP.UA} ua
	*/
	var InviteServerTransaction = function(request, ua) {
	  this.type = C.INVITE_SERVER;
	  this.id = request.via_branch;
	  this.request = request;
	  this.transport = request.transport;
	  this.ua = ua;
	  this.last_response = '';
	  request.server_transaction = this;
	
	  this.logger = ua.getLogger('sip.transaction.ist', this.id);
	
	  this.state = C.STATUS_PROCEEDING;
	
	  ua.newTransaction(this);
	
	  this.resendProvisionalTimer = null;
	
	  request.reply(100);
	};
	InviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	InviteServerTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	InviteServerTransaction.prototype.timer_H = function() {
	  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);
	
	  if(this.state === C.STATUS_COMPLETED) {
	    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');
	  }
	
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	InviteServerTransaction.prototype.timer_I = function() {
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	// RFC 6026 7.1
	InviteServerTransaction.prototype.timer_L = function() {
	  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);
	
	  if(this.state === C.STATUS_ACCEPTED) {
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	InviteServerTransaction.prototype.onTransportError = function() {
	  if (!this.transportError) {
	    this.transportError = true;
	
	    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);
	
	    if (this.resendProvisionalTimer !== null) {
	      SIP.Timers.clearInterval(this.resendProvisionalTimer);
	      this.resendProvisionalTimer = null;
	    }
	
	    SIP.Timers.clearTimeout(this.L);
	    SIP.Timers.clearTimeout(this.H);
	    SIP.Timers.clearTimeout(this.I);
	
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	InviteServerTransaction.prototype.resend_provisional = function() {
	  if(!this.transport.send(this.last_response)) {
	    this.onTransportError();
	  }
	};
	
	// INVITE Server Transaction RFC 3261 17.2.1
	InviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
	  var tr = this;
	  var deferred = SIP.Utils.defer();
	
	  if(status_code >= 100 && status_code <= 199) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	        }
	        this.last_response = response;
	        break;
	    }
	  }
	
	  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {
	    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.
	    if(this.resendProvisionalTimer === null) {
	      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),
	        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);
	    }
	  } else if(status_code >= 200 && status_code <= 299) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_ACCEPTED);
	        this.last_response = response;
	        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);
	
	        if (this.resendProvisionalTimer !== null) {
	          SIP.Timers.clearInterval(this.resendProvisionalTimer);
	          this.resendProvisionalTimer = null;
	        }
	        /* falls through */
	        case C.STATUS_ACCEPTED:
	          // Note that this point will be reached for proceeding tr.state also.
	          if(!this.transport.send(response)) {
	            this.onTransportError();
	            deferred.reject();
	          } else {
	            deferred.resolve();
	          }
	          break;
	    }
	  } else if(status_code >= 300 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        if (this.resendProvisionalTimer !== null) {
	          SIP.Timers.clearInterval(this.resendProvisionalTimer);
	          this.resendProvisionalTimer = null;
	        }
	
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          this.stateChanged(C.STATUS_COMPLETED);
	          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);
	          deferred.resolve();
	        }
	        break;
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	 * @function
	 * @param {SIP.UA} ua
	 * @param {SIP.IncomingRequest} request
	 *
	 * @return {boolean}
	 * INVITE:
	 *  _true_ if retransmission
	 *  _false_ new request
	 *
	 * ACK:
	 *  _true_  ACK to non2xx response
	 *  _false_ ACK must be passed to TU (accepted state)
	 *          ACK to 2xx response
	 *
	 * CANCEL:
	 *  _true_  no matching invite transaction
	 *  _false_ matching invite transaction and no final response sent
	 *
	 * OTHER:
	 *  _true_  retransmission
	 *  _false_ new request
	 */
	var checkTransaction = function(ua, request) {
	  var tr;
	
	  switch(request.method) {
	    case SIP.C.INVITE:
	      tr = ua.transactions.ist[request.via_branch];
	      if(tr) {
	        switch(tr.state) {
	          case C.STATUS_PROCEEDING:
	            tr.transport.send(tr.last_response);
	            break;
	
	            // RFC 6026 7.1 Invite retransmission
	            //received while in C.STATUS_ACCEPTED state. Absorb it.
	          case C.STATUS_ACCEPTED:
	            break;
	        }
	        return true;
	      }
	      break;
	    case SIP.C.ACK:
	      tr = ua.transactions.ist[request.via_branch];
	
	      // RFC 6026 7.1
	      if(tr) {
	        if(tr.state === C.STATUS_ACCEPTED) {
	          return false;
	        } else if(tr.state === C.STATUS_COMPLETED) {
	          tr.state = C.STATUS_CONFIRMED;
	          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);
	          return true;
	        }
	      }
	
	      // ACK to 2XX Response.
	      else {
	        return false;
	      }
	      break;
	    case SIP.C.CANCEL:
	      tr = ua.transactions.ist[request.via_branch];
	      if(tr) {
	        request.reply_sl(200);
	        if(tr.state === C.STATUS_PROCEEDING) {
	          return false;
	        } else {
	          return true;
	        }
	      } else {
	        request.reply_sl(481);
	        return true;
	      }
	      break;
	    default:
	
	      // Non-INVITE Server Transaction RFC 3261 17.2.2
	      tr = ua.transactions.nist[request.via_branch];
	      if(tr) {
	        switch(tr.state) {
	          case C.STATUS_TRYING:
	            break;
	          case C.STATUS_PROCEEDING:
	          case C.STATUS_COMPLETED:
	            tr.transport.send(tr.last_response);
	            break;
	        }
	        return true;
	      }
	      break;
	  }
	};
	
	SIP.Transactions = {
	  C: C,
	  checkTransaction: checkTransaction,
	  NonInviteClientTransaction: NonInviteClientTransaction,
	  InviteClientTransaction: InviteClientTransaction,
	  AckClientTransaction: AckClientTransaction,
	  NonInviteServerTransaction: NonInviteServerTransaction,
	  InviteServerTransaction: InviteServerTransaction
	};
	
	};


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileoverview SIP Dialog
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP dialog.
	 * @param {SIP.RTCSession} owner
	 * @param {SIP.IncomingRequest|SIP.IncomingResponse} message
	 * @param {Enum} type UAC / UAS
	 * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED
	 */
	module.exports = function (SIP) {
	
	var RequestSender = __webpack_require__(227)(SIP);
	
	var Dialog,
	  C = {
	    // Dialog states
	    STATUS_EARLY:       1,
	    STATUS_CONFIRMED:   2
	  };
	
	// RFC 3261 12.1
	Dialog = function(owner, message, type, state) {
	  var contact;
	
	  this.uac_pending_reply = false;
	  this.uas_pending_reply = false;
	
	  if(!message.hasHeader('contact')) {
	    return {
	      error: 'unable to create a Dialog without Contact header field'
	    };
	  }
	
	  if(message instanceof SIP.IncomingResponse) {
	    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;
	  } else {
	    // Create confirmed dialog if state is not defined
	    state = state || C.STATUS_CONFIRMED;
	  }
	
	  contact = message.parseHeader('contact');
	
	  // RFC 3261 12.1.1
	  if(type === 'UAS') {
	    this.id = {
	      call_id: message.call_id,
	      local_tag: message.to_tag,
	      remote_tag: message.from_tag,
	      toString: function() {
	        return this.call_id + this.local_tag + this.remote_tag;
	      }
	    };
	    this.state = state;
	    this.remote_seqnum = message.cseq;
	    this.local_uri = message.parseHeader('to').uri;
	    this.remote_uri = message.parseHeader('from').uri;
	    this.remote_target = contact.uri;
	    this.route_set = message.getHeaders('record-route');
	    this.invite_seqnum = message.cseq;
	    this.local_seqnum = message.cseq;
	  }
	  // RFC 3261 12.1.2
	  else if(type === 'UAC') {
	    this.id = {
	      call_id: message.call_id,
	      local_tag: message.from_tag,
	      remote_tag: message.to_tag,
	      toString: function() {
	        return this.call_id + this.local_tag + this.remote_tag;
	      }
	    };
	    this.state = state;
	    this.invite_seqnum = message.cseq;
	    this.local_seqnum = message.cseq;
	    this.local_uri = message.parseHeader('from').uri;
	    this.pracked = [];
	    this.remote_uri = message.parseHeader('to').uri;
	    this.remote_target = contact.uri;
	    this.route_set = message.getHeaders('record-route').reverse();
	
	    //RENDERBODY
	    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {
	      this.mediaHandler = owner.mediaHandlerFactory(owner);
	    }
	  }
	
	  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());
	  this.owner = owner;
	  owner.ua.dialogs[this.id.toString()] = this;
	  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));
	  owner.emit('dialog', this);
	};
	
	Dialog.prototype = {
	  /**
	   * @param {SIP.IncomingMessage} message
	   * @param {Enum} UAC/UAS
	   */
	  update: function(message, type) {
	    this.state = C.STATUS_CONFIRMED;
	
	    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');
	
	    if(type === 'UAC') {
	      // RFC 3261 13.2.2.4
	      this.route_set = message.getHeaders('record-route').reverse();
	    }
	  },
	
	  terminate: function() {
	    this.logger.log('dialog ' + this.id.toString() + ' deleted');
	    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {
	      this.mediaHandler.peerConnection.close();
	    }
	    delete this.owner.ua.dialogs[this.id.toString()];
	  },
	
	  /**
	  * @param {String} method request method
	  * @param {Object} extraHeaders extra headers
	  * @returns {SIP.OutgoingRequest}
	  */
	
	  // RFC 3261 12.2.1.1
	  createRequest: function(method, extraHeaders, body) {
	    var cseq, request;
	    extraHeaders = (extraHeaders || []).slice();
	
	    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }
	
	    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;
	
	    request = new SIP.OutgoingRequest(
	      method,
	      this.remote_target,
	      this.owner.ua, {
	        'cseq': cseq,
	        'call_id': this.id.call_id,
	        'from_uri': this.local_uri,
	        'from_tag': this.id.local_tag,
	        'to_uri': this.remote_uri,
	        'to_tag': this.id.remote_tag,
	        'route_set': this.route_set
	      }, extraHeaders, body);
	
	    request.dialog = this;
	
	    return request;
	  },
	
	  /**
	  * @param {SIP.IncomingRequest} request
	  * @returns {Boolean}
	  */
	
	  // RFC 3261 12.2.2
	  checkInDialogRequest: function(request) {
	    var self = this;
	
	    if(!this.remote_seqnum) {
	      this.remote_seqnum = request.cseq;
	    } else if(request.cseq < this.remote_seqnum) {
	        //Do not try to reply to an ACK request.
	        if (request.method !== SIP.C.ACK) {
	          request.reply(500);
	        }
	        if (request.cseq === this.invite_seqnum) {
	          return true;
	        }
	        return false;
	    } else if(request.cseq > this.remote_seqnum) {
	      this.remote_seqnum = request.cseq;
	    }
	
	    switch(request.method) {
	      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-
	      case SIP.C.INVITE:
	        if (this.uac_pending_reply === true) {
	          request.reply(491);
	        } else if (this.uas_pending_reply === true) {
	          var retryAfter = (Math.random() * 10 | 0) + 1;
	          request.reply(500, null, ['Retry-After:' + retryAfter]);
	          return false;
	        } else {
	          this.uas_pending_reply = true;
	          request.server_transaction.on('stateChanged', function stateChanged(){
	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
	                this.state === SIP.Transactions.C.STATUS_COMPLETED ||
	                this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	
	              this.removeListener('stateChanged', stateChanged);
	              self.uas_pending_reply = false;
	
	              if (self.uac_pending_reply === false) {
	                self.owner.onReadyToReinvite();
	              }
	            }
	          });
	        }
	
	        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted
	        if(request.hasHeader('contact')) {
	          request.server_transaction.on('stateChanged', function(){
	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {
	              self.remote_target = request.parseHeader('contact').uri;
	            }
	          });
	        }
	        break;
	      case SIP.C.NOTIFY:
	        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted
	        if(request.hasHeader('contact')) {
	          request.server_transaction.on('stateChanged', function(){
	            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {
	              self.remote_target = request.parseHeader('contact').uri;
	            }
	          });
	        }
	        break;
	    }
	
	    return true;
	  },
	
	  sendRequest: function(applicant, method, options) {
	    options = options || {};
	
	    var
	      extraHeaders = (options.extraHeaders || []).slice(),
	      body = options.body || null,
	      request = this.createRequest(method, extraHeaders, body),
	      request_sender = new RequestSender(this, applicant, request);
	
	    request_sender.send();
	
	    return request;
	  },
	
	  /**
	  * @param {SIP.IncomingRequest} request
	  */
	  receiveRequest: function(request) {
	    //Check in-dialog request
	    if(!this.checkInDialogRequest(request)) {
	      return;
	    }
	
	    this.owner.receiveRequest(request);
	  }
	};
	
	Dialog.C = C;
	SIP.Dialog = Dialog;
	};


/***/ },
/* 227 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview In-Dialog Request Sender
	 */
	
	/**
	 * @augments SIP.Dialog
	 * @class Class creating an In-dialog request sender.
	 * @param {SIP.Dialog} dialog
	 * @param {Object} applicant
	 * @param {SIP.OutgoingRequest} request
	 */
	/**
	 * @fileoverview in-Dialog Request Sender
	 */
	
	module.exports = function (SIP) {
	var RequestSender;
	
	RequestSender = function(dialog, applicant, request) {
	
	  this.dialog = dialog;
	  this.applicant = applicant;
	  this.request = request;
	
	  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.
	  this.reattempt = false;
	  this.reattemptTimer = null;
	};
	
	RequestSender.prototype = {
	  send: function() {
	    var self = this,
	      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);
	
	      request_sender.send();
	
	    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-
	    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
	      this.dialog.uac_pending_reply = true;
	      request_sender.clientTransaction.on('stateChanged', function stateChanged(){
	        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
	            this.state === SIP.Transactions.C.STATUS_COMPLETED ||
	            this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	
	          this.removeListener('stateChanged', stateChanged);
	          self.dialog.uac_pending_reply = false;
	
	          if (self.dialog.uas_pending_reply === false) {
	            self.dialog.owner.onReadyToReinvite();
	          }
	        }
	      });
	    }
	  },
	
	  onRequestTimeout: function() {
	    this.applicant.onRequestTimeout();
	  },
	
	  onTransportError: function() {
	    this.applicant.onTransportError();
	  },
	
	  receiveResponse: function(response) {
	    var self = this;
	
	    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.
	    if (response.status_code === 408 || response.status_code === 481) {
	      this.applicant.onDialogError(response);
	    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {
	      if (this.reattempt) {
	        this.applicant.receiveResponse(response);
	      } else {
	        this.request.cseq.value = this.dialog.local_seqnum += 1;
	        this.reattemptTimer = SIP.Timers.setTimeout(
	          function() {
	            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {
	              self.reattempt = true;
	              self.request_sender.send();
	            }
	          },
	          this.getReattemptTimeout()
	        );
	      }
	    } else {
	      this.applicant.receiveResponse(response);
	    }
	  }
	};
	
	return RequestSender;
	};


/***/ },
/* 228 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview Request Sender
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a request sender.
	 * @param {Object} applicant
	 * @param {SIP.UA} ua
	 */
	module.exports = function (SIP) {
	var RequestSender;
	
	RequestSender = function(applicant, ua) {
	  this.logger = ua.getLogger('sip.requestsender');
	  this.ua = ua;
	  this.applicant = applicant;
	  this.method = applicant.request.method;
	  this.request = applicant.request;
	  this.credentials = null;
	  this.challenged = false;
	  this.staled = false;
	
	  // If ua is in closing process or even closed just allow sending Bye and ACK
	  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {
	    this.onTransportError();
	  }
	};
	
	/**
	* Create the client transaction and send the message.
	*/
	RequestSender.prototype = {
	  send: function() {
	    switch(this.method) {
	      case "INVITE":
	        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);
	        break;
	      case "ACK":
	        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);
	        break;
	      default:
	        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);
	    }
	    this.clientTransaction.send();
	
	    return this.clientTransaction;
	  },
	
	  /**
	  * Callback fired when receiving a request timeout error from the client transaction.
	  * To be re-defined by the applicant.
	  * @event
	  */
	  onRequestTimeout: function() {
	    this.applicant.onRequestTimeout();
	  },
	
	  /**
	  * Callback fired when receiving a transport error from the client transaction.
	  * To be re-defined by the applicant.
	  * @event
	  */
	  onTransportError: function() {
	    this.applicant.onTransportError();
	  },
	
	  /**
	  * Called from client transaction when receiving a correct response to the request.
	  * Authenticate request if needed or pass the response back to the applicant.
	  * @param {SIP.IncomingResponse} response
	  */
	  receiveResponse: function(response) {
	    var cseq, challenge, authorization_header_name,
	      status_code = response.status_code;
	
	    /*
	    * Authentication
	    * Authenticate once. _challenged_ flag used to avoid infinite authentications.
	    */
	    if (status_code === 401 || status_code === 407) {
	
	      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
	      if (response.status_code === 401) {
	        challenge = response.parseHeader('www-authenticate');
	        authorization_header_name = 'authorization';
	      } else {
	        challenge = response.parseHeader('proxy-authenticate');
	        authorization_header_name = 'proxy-authorization';
	      }
	
	      // Verify it seems a valid challenge.
	      if (! challenge) {
	        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');
	        this.applicant.receiveResponse(response);
	        return;
	      }
	
	      if (!this.challenged || (!this.staled && challenge.stale === true)) {
	        if (!this.credentials) {
	          this.credentials = this.ua.configuration.authenticationFactory(this.ua);
	        }
	
	        // Verify that the challenge is really valid.
	        if (!this.credentials.authenticate(this.request, challenge)) {
	          this.applicant.receiveResponse(response);
	          return;
	        }
	        this.challenged = true;
	
	        if (challenge.stale) {
	          this.staled = true;
	        }
	
	        if (response.method === SIP.C.REGISTER) {
	          cseq = this.applicant.cseq += 1;
	        } else if (this.request.dialog){
	          cseq = this.request.dialog.local_seqnum += 1;
	        } else {
	          cseq = this.request.cseq + 1;
	          this.request.cseq = cseq;
	        }
	        this.request.setHeader('cseq', cseq +' '+ this.method);
	
	        this.request.setHeader(authorization_header_name, this.credentials.toString());
	        this.send();
	      } else {
	        this.applicant.receiveResponse(response);
	      }
	    } else {
	      this.applicant.receiveResponse(response);
	    }
	  }
	};
	
	SIP.RequestSender = RequestSender;
	};


/***/ },
/* 229 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	
	var RegisterContext;
	
	RegisterContext = function (ua) {
	  var params = {},
	      regId = 1;
	
	  this.registrar = ua.configuration.registrarServer;
	  this.expires = ua.configuration.registerExpires;
	
	
	  // Contact header
	  this.contact = ua.contact.toString();
	
	  if(regId) {
	    this.contact += ';reg-id='+ regId;
	    this.contact += ';+sip.instance="<urn:uuid:'+ ua.configuration.instanceId+'>"';
	  }
	
	  // Call-ID and CSeq values RFC3261 10.2
	  this.call_id = SIP.Utils.createRandomToken(22);
	  this.cseq = 80;
	
	  this.to_uri = ua.configuration.uri;
	
	  params.to_uri = this.to_uri;
	  params.to_displayName = ua.configuration.displayName;
	  params.call_id = this.call_id;
	  params.cseq = this.cseq;
	
	  // Extends ClientContext
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);
	
	  this.registrationTimer = null;
	  this.registrationExpiredTimer = null;
	
	  // Set status
	  this.registered = false;
	
	  this.logger = ua.getLogger('sip.registercontext');
	};
	
	RegisterContext.prototype = {
	  register: function (options) {
	    var self = this, extraHeaders;
	
	    // Handle Options
	    this.options = options || {};
	    extraHeaders = (this.options.extraHeaders || []).slice();
	    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);
	    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	
	    // Save original extraHeaders to be used in .close
	    this.closeHeaders = this.options.closeWithHeaders ?
	      (this.options.extraHeaders || []).slice() : [];
	
	    this.receiveResponse = function(response) {
	      var contact, expires,
	        contacts = response.getHeaders('contact').length,
	        cause;
	
	      // Discard responses to older REGISTER/un-REGISTER requests.
	      if(response.cseq !== this.cseq) {
	        return;
	      }
	
	      // Clear registration timer
	      if (this.registrationTimer !== null) {
	        SIP.Timers.clearTimeout(this.registrationTimer);
	        this.registrationTimer = null;
	      }
	
	      switch(true) {
	        case /^1[0-9]{2}$/.test(response.status_code):
	          this.emit('progress', response);
	          break;
	        case /^2[0-9]{2}$/.test(response.status_code):
	          this.emit('accepted', response);
	
	          if(response.hasHeader('expires')) {
	            expires = response.getHeader('expires');
	          }
	
	          if (this.registrationExpiredTimer !== null) {
	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	            this.registrationExpiredTimer = null;
	          }
	
	          // Search the Contact pointing to us and update the expires value accordingly.
	          if (!contacts) {
	            this.logger.warn('no Contact header in response to REGISTER, response ignored');
	            break;
	          }
	
	          while(contacts--) {
	            contact = response.parseHeader('contact', contacts);
	            if(contact.uri.user === this.ua.contact.uri.user) {
	              expires = contact.getParam('expires');
	              break;
	            } else {
	              contact = null;
	            }
	          }
	
	          if (!contact) {
	            this.logger.warn('no Contact header pointing to us, response ignored');
	            break;
	          }
	
	          if(!expires) {
	            expires = this.expires;
	          }
	
	          // Re-Register before the expiration interval has elapsed.
	          // For that, decrease the expires value. ie: 3 seconds
	          this.registrationTimer = SIP.Timers.setTimeout(function() {
	            self.registrationTimer = null;
	            self.register(self.options);
	          }, (expires * 1000) - 3000);
	          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {
	            self.logger.warn('registration expired');
	            if (self.registered) {
	              self.unregistered(null, SIP.C.causes.EXPIRES);
	            }
	          }, expires * 1000);
	
	          //Save gruu values
	          if (contact.hasParam('temp-gruu')) {
	            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/"/g,''));
	          }
	          if (contact.hasParam('pub-gruu')) {
	            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/"/g,''));
	          }
	
	          this.registered = true;
	          this.emit('registered', response || null);
	          break;
	        // Interval too brief RFC3261 10.2.8
	        case /^423$/.test(response.status_code):
	          if(response.hasHeader('min-expires')) {
	            // Increase our registration interval to the suggested minimum
	            this.expires = response.getHeader('min-expires');
	            // Attempt the registration again immediately
	            this.register(this.options);
	          } else { //This response MUST contain a Min-Expires header field
	            this.logger.warn('423 response received for REGISTER without Min-Expires');
	            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);
	          }
	          break;
	        default:
	          cause = SIP.Utils.sipErrorCause(response.status_code);
	          this.registrationFailure(response, cause);
	      }
	    };
	
	    this.onRequestTimeout = function() {
	      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);
	    };
	
	    this.onTransportError = function() {
	      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);
	    };
	
	    this.cseq++;
	    this.request.cseq = this.cseq;
	    this.request.setHeader('cseq', this.cseq + ' REGISTER');
	    this.request.extraHeaders = extraHeaders;
	    this.send();
	  },
	
	  registrationFailure: function (response, cause) {
	    this.emit('failed', response || null, cause || null);
	  },
	
	  onTransportClosed: function() {
	    this.registered_before = this.registered;
	    if (this.registrationTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationTimer);
	      this.registrationTimer = null;
	    }
	
	    if (this.registrationExpiredTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	      this.registrationExpiredTimer = null;
	    }
	
	    if(this.registered) {
	      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onTransportConnected: function() {
	    this.register(this.options);
	  },
	
	  close: function() {
	    var options = {
	      all: false,
	      extraHeaders: this.closeHeaders
	    };
	
	    this.registered_before = this.registered;
	    this.unregister(options);
	  },
	
	  unregister: function(options) {
	    var extraHeaders;
	
	    options = options || {};
	
	    if(!this.registered && !options.all) {
	      this.logger.warn('already unregistered');
	      return;
	    }
	
	    extraHeaders = (options.extraHeaders || []).slice();
	
	    this.registered = false;
	
	    // Clear the registration timer.
	    if (this.registrationTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationTimer);
	      this.registrationTimer = null;
	    }
	
	    if(options.all) {
	      extraHeaders.push('Contact: *');
	      extraHeaders.push('Expires: 0');
	    } else {
	      extraHeaders.push('Contact: '+ this.contact + ';expires=0');
	    }
	
	
	    this.receiveResponse = function(response) {
	      var cause;
	
	      switch(true) {
	        case /^1[0-9]{2}$/.test(response.status_code):
	          this.emit('progress', response);
	          break;
	        case /^2[0-9]{2}$/.test(response.status_code):
	          this.emit('accepted', response);
	          if (this.registrationExpiredTimer !== null) {
	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	            this.registrationExpiredTimer = null;
	          }
	          this.unregistered(response);
	          break;
	        default:
	          cause = SIP.Utils.sipErrorCause(response.status_code);
	          this.unregistered(response,cause);
	      }
	    };
	
	    this.onRequestTimeout = function() {
	      // Not actually unregistered...
	      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);
	    };
	
	    this.onTransportError = function() {
	      // Not actually unregistered...
	      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
	    };
	
	    this.cseq++;
	    this.request.cseq = this.cseq;
	    this.request.setHeader('cseq', this.cseq + ' REGISTER');
	    this.request.extraHeaders = extraHeaders;
	
	    this.send();
	  },
	
	  unregistered: function(response, cause) {
	    this.registered = false;
	    this.emit('unregistered', response || null, cause || null);
	  }
	
	};
	
	
	SIP.RegisterContext = RegisterContext;
	};


/***/ },
/* 230 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaHandler
	 */
	
	/* MediaHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 */
	module.exports = function (EventEmitter) {
	var MediaHandler = function(session, options) {
	  // keep jshint happy
	  session = session;
	  options = options;
	};
	
	MediaHandler.prototype = Object.create(EventEmitter.prototype, {
	  isReady: {value: function isReady () {}},
	
	  close: {value: function close () {}},
	
	  /**
	   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.
	   */
	  getDescription: {value: function getDescription (mediaHint) {
	    // keep jshint happy
	    mediaHint = mediaHint;
	  }},
	
	  /**
	  * Message reception.
	  * @param {String} type
	  * @param {String} description
	  */
	  setDescription: {value: function setDescription (description) {
	    // keep jshint happy
	    description = description;
	  }}
	});
	
	return MediaHandler;
	};


/***/ },
/* 231 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	var ClientContext;
	
	ClientContext = function (ua, method, target, options) {
	  var originalTarget = target;
	
	  // Validate arguments
	  if (target === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  this.ua = ua;
	  this.logger = ua.getLogger('sip.clientcontext');
	  this.method = method;
	  target = ua.normalizeTarget(target);
	  if (!target) {
	    throw new TypeError('Invalid target: ' + originalTarget);
	  }
	
	  /* Options
	   * - extraHeaders
	   * - params
	   * - contentType
	   * - body
	   */
	  options = Object.create(options || Object.prototype);
	  options.extraHeaders = (options.extraHeaders || []).slice();
	
	  if (options.contentType) {
	    this.contentType = options.contentType;
	    options.extraHeaders.push('Content-Type: ' + this.contentType);
	  }
	
	  // Build the request
	  this.request = new SIP.OutgoingRequest(this.method,
	                                         target,
	                                         this.ua,
	                                         options.params,
	                                         options.extraHeaders);
	  if (options.body) {
	    this.body = options.body;
	    this.request.body = this.body;
	  }
	
	  /* Set other properties from the request */
	  this.localIdentity = this.request.from;
	  this.remoteIdentity = this.request.to;
	
	  this.data = {};
	};
	ClientContext.prototype = Object.create(SIP.EventEmitter.prototype);
	
	ClientContext.prototype.send = function () {
	  (new SIP.RequestSender(this, this.ua)).send();
	  return this;
	};
	
	ClientContext.prototype.cancel = function (options) {
	  options = options || {};
	
	  var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
	  this.request.cancel(cancel_reason);
	
	  this.emit('cancel');
	};
	
	ClientContext.prototype.receiveResponse = function (response) {
	  var cause = SIP.Utils.getReasonPhrase(response.status_code);
	
	  switch(true) {
	    case /^1[0-9]{2}$/.test(response.status_code):
	      this.emit('progress', response, cause);
	      break;
	
	    case /^2[0-9]{2}$/.test(response.status_code):
	      if(this.ua.applicants[this]) {
	        delete this.ua.applicants[this];
	      }
	      this.emit('accepted', response, cause);
	      break;
	
	    default:
	      if(this.ua.applicants[this]) {
	        delete this.ua.applicants[this];
	      }
	      this.emit('rejected', response, cause);
	      this.emit('failed', response, cause);
	      break;
	  }
	
	};
	
	ClientContext.prototype.onRequestTimeout = function () {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	};
	
	ClientContext.prototype.onTransportError = function () {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	};
	
	SIP.ClientContext = ClientContext;
	};


/***/ },
/* 232 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	var ServerContext;
	
	ServerContext = function (ua, request) {
	  this.ua = ua;
	  this.logger = ua.getLogger('sip.servercontext');
	  this.request = request;
	  if (request.method === SIP.C.INVITE) {
	    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);
	  } else {
	    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);
	  }
	
	  if (request.body) {
	    this.body = request.body;
	  }
	  if (request.hasHeader('Content-Type')) {
	    this.contentType = request.getHeader('Content-Type');
	  }
	  this.method = request.method;
	
	  this.data = {};
	
	  this.localIdentity = request.to;
	  this.remoteIdentity = request.from;
	};
	
	ServerContext.prototype = Object.create(SIP.EventEmitter.prototype);
	
	ServerContext.prototype.progress = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 180);
	  options.minCode = 100;
	  options.maxCode = 199;
	  options.events = ['progress'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.accept = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 200);
	  options.minCode = 200;
	  options.maxCode = 299;
	  options.events = ['accepted'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.reject = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 480);
	  options.minCode = 300;
	  options.maxCode = 699;
	  options.events = ['rejected', 'failed'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.reply = function (options) {
	  options = options || {}; // This is okay, so long as we treat options as read-only in this method
	  var
	    statusCode = options.statusCode || 100,
	    minCode = options.minCode || 100,
	    maxCode = options.maxCode || 699,
	    reasonPhrase = SIP.Utils.getReasonPhrase(statusCode, options.reasonPhrase),
	    extraHeaders = options.extraHeaders || [],
	    body = options.body,
	    events = options.events || [],
	    response;
	
	  if (statusCode < minCode || statusCode > maxCode) {
	    throw new TypeError('Invalid statusCode: ' + statusCode);
	  }
	  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	  events.forEach(function (event) {
	    this.emit(event, response, reasonPhrase);
	  }, this);
	
	  return this;
	};
	
	ServerContext.prototype.onRequestTimeout = function () {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	};
	
	ServerContext.prototype.onTransportError = function () {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	};
	
	SIP.ServerContext = ServerContext;
	};


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function (SIP, environment) {
	
	var DTMF = __webpack_require__(234)(SIP);
	
	var Session, InviteServerContext, InviteClientContext,
	 C = {
	    //Session states
	    STATUS_NULL:                        0,
	    STATUS_INVITE_SENT:                 1,
	    STATUS_1XX_RECEIVED:                2,
	    STATUS_INVITE_RECEIVED:             3,
	    STATUS_WAITING_FOR_ANSWER:          4,
	    STATUS_ANSWERED:                    5,
	    STATUS_WAITING_FOR_PRACK:           6,
	    STATUS_WAITING_FOR_ACK:             7,
	    STATUS_CANCELED:                    8,
	    STATUS_TERMINATED:                  9,
	    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,
	    STATUS_EARLY_MEDIA:                11,
	    STATUS_CONFIRMED:                  12
	  };
	
	/*
	 * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]
	 *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)
	 */
	Session = function (mediaHandlerFactory) {
	  this.status = C.STATUS_NULL;
	  this.dialog = null;
	  this.earlyDialogs = {};
	  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;
	  // this.mediaHandler gets set by ICC/ISC constructors
	  this.hasOffer = false;
	  this.hasAnswer = false;
	
	  // Session Timers
	  this.timers = {
	    ackTimer: null,
	    expiresTimer: null,
	    invite2xxTimer: null,
	    userNoAnswerTimer: null,
	    rel1xxTimer: null,
	    prackTimer: null
	  };
	
	  // Session info
	  this.startTime = null;
	  this.endTime = null;
	  this.tones = null;
	
	  // Mute/Hold state
	  this.local_hold = false;
	  this.remote_hold = false;
	
	  this.pending_actions = {
	    actions: [],
	
	    length: function() {
	      return this.actions.length;
	    },
	
	    isPending: function(name){
	      var
	      idx = 0,
	      length = this.actions.length;
	
	      for (idx; idx<length; idx++) {
	        if (this.actions[idx].name === name) {
	          return true;
	        }
	      }
	      return false;
	    },
	
	    shift: function() {
	      return this.actions.shift();
	    },
	
	    push: function(name) {
	      this.actions.push({
	        name: name
	      });
	    },
	
	    pop: function(name) {
	      var
	      idx = 0,
	      length = this.actions.length;
	
	      for (idx; idx<length; idx++) {
	        if (this.actions[idx].name === name) {
	          this.actions.splice(idx,1);
	          length --;
	          idx--;
	        }
	      }
	    }
	   };
	
	  this.early_sdp = null;
	  this.rel100 = SIP.C.supported.UNSUPPORTED;
	};
	
	Session.prototype = {
	  dtmf: function(tones, options) {
	    var tone, dtmfs = [],
	        self = this;
	
	    options = options || {};
	
	    if (tones === undefined) {
	      throw new TypeError('Not enough arguments');
	    }
	
	    // Check Session Status
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    // Check tones
	    if ((typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {
	      throw new TypeError('Invalid tones: '+ tones);
	    }
	
	    tones = tones.toString().split('');
	
	    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }
	
	    if (this.tones) {
	      // Tones are already queued, just add to the queue
	      this.tones =  this.tones.concat(dtmfs);
	      return this;
	    }
	
	    var sendDTMF = function () {
	      var dtmf, timeout;
	
	      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {
	        // Stop sending DTMF
	        self.tones = null;
	        return this;
	      }
	
	      dtmf = self.tones.shift();
	
	      if (tone === ',') {
	        timeout = 2000;
	      } else {
	        dtmf.on('failed', function(){self.tones = null;});
	        dtmf.send(options);
	        timeout = dtmf.duration + dtmf.interToneGap;
	      }
	
	      // Set timeout for the next tone
	      SIP.Timers.setTimeout(sendDTMF, timeout);
	    };
	
	    this.tones = dtmfs;
	    sendDTMF();
	    return this;
	  },
	
	  bye: function(options) {
	    options = Object.create(options || Object.prototype);
	    var statusCode = options.statusCode;
	
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED) {
	      this.logger.error('Error: Attempted to send BYE in a terminated session.');
	      return this;
	    }
	
	    this.logger.log('terminating Session');
	
	    if (statusCode && (statusCode < 200 || statusCode >= 700)) {
	      throw new TypeError('Invalid statusCode: '+ statusCode);
	    }
	
	    options.receiveResponse = function () {};
	
	    return this.
	      sendRequest(SIP.C.BYE, options).
	      terminated();
	  },
	
	  refer: function(target, options) {
	    options = options || {};
	    var extraHeaders = (options.extraHeaders || []).slice(),
	        withReplaces =
	          target instanceof SIP.InviteServerContext ||
	          target instanceof SIP.InviteClientContext,
	        originalTarget = target;
	
	    if (target === undefined) {
	      throw new TypeError('Not enough arguments');
	    }
	
	    // Check Session Status
	    if (this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    // transform `target` so that it can be a Refer-To header value
	    if (withReplaces) {
	      //Attended Transfer
	      // B.transfer(C)
	      target = '"' + target.remoteIdentity.friendlyName + '" ' +
	        '<' + target.dialog.remote_target.toString() +
	        '?Replaces=' + target.dialog.id.call_id +
	        '%3Bto-tag%3D' + target.dialog.id.remote_tag +
	        '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';
	    } else {
	      //Blind Transfer
	      // normalizeTarget allows instances of SIP.URI to pass through unaltered,
	      // so try to make one ahead of time
	      try {
	        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;
	      } catch (e) {
	        this.logger.debug(".refer() cannot parse Refer_To from", target);
	        this.logger.debug("...falling through to normalizeTarget()");
	      }
	
	      // Check target validity
	      target = this.ua.normalizeTarget(target);
	      if (!target) {
	        throw new TypeError('Invalid target: ' + originalTarget);
	      }
	    }
	
	    extraHeaders.push('Contact: '+ this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	    extraHeaders.push('Refer-To: '+ target);
	
	    // Send the request
	    this.sendRequest(SIP.C.REFER, {
	      extraHeaders: extraHeaders,
	      body: options.body,
	      receiveResponse: function (response) {
	        if ( ! /^2[0-9]{2}$/.test(response.status_code) ) {
	          return;
	        }
	        // hang up only if we transferred to a SIP address
	        if (withReplaces || (target.scheme && target.scheme.match("^sips?$"))) {
	          this.terminate();
	        }
	      }.bind(this)
	    });
	    return this;
	  },
	
	  followRefer: function followRefer (callback) {
	    return function referListener (callback, request) {
	      // open non-SIP URIs if possible and keep session open
	      var referTo = request.parseHeader('refer-to');
	      var target = referTo.uri;
	      if (!target.scheme.match("^sips?$")) {
	        var targetString = target.toString();
	        if (typeof environment.open === "function") {
	          environment.open(targetString);
	        } else {
	          this.logger.warn("referred to non-SIP URI but `open` isn't in the environment: " + targetString);
	        }
	        return;
	      }
	
	      var extraHeaders = [];
	
	      /* Copy the Replaces query into a Replaces header */
	      /* TODO - make sure we don't copy a poorly formatted header? */
	      var replaces = target.getHeader('Replaces');
	      if (replaces !== undefined) {
	        extraHeaders.push('Replaces: ' + decodeURIComponent(replaces));
	      }
	
	      // don't embed headers into Request-URI of INVITE
	      target.clearHeaders();
	
	      /*
	        Harmless race condition.  Both sides of REFER
	        may send a BYE, but in the end the dialogs are destroyed.
	      */
	      var getReferMedia = this.mediaHandler.getReferMedia;
	      var mediaHint = getReferMedia ? getReferMedia.call(this.mediaHandler) : this.mediaHint;
	
	      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);
	
	      var referSession = this.ua.invite(target, {
	        media: mediaHint,
	        params: {
	          to_displayName: referTo.friendlyName
	        },
	        extraHeaders: extraHeaders
	      });
	
	      callback.call(this, request, referSession);
	
	      this.terminate();
	    }.bind(this, callback);
	  },
	
	  sendRequest: function(method,options) {
	    options = options || {};
	    var self = this;
	
	    var request = new SIP.OutgoingRequest(
	      method,
	      this.dialog.remote_target,
	      this.ua,
	      {
	        cseq: options.cseq || (this.dialog.local_seqnum += 1),
	        call_id: this.dialog.id.call_id,
	        from_uri: this.dialog.local_uri,
	        from_tag: this.dialog.id.local_tag,
	        to_uri: this.dialog.remote_uri,
	        to_tag: this.dialog.id.remote_tag,
	        route_set: this.dialog.route_set,
	        statusCode: options.statusCode,
	        reasonPhrase: options.reasonPhrase
	      },
	      options.extraHeaders || [],
	      options.body
	    );
	
	    new SIP.RequestSender({
	      request: request,
	      onRequestTimeout: function() {
	        self.onRequestTimeout();
	      },
	      onTransportError: function() {
	        self.onTransportError();
	      },
	      receiveResponse: options.receiveResponse || function(response) {
	        self.receiveNonInviteResponse(response);
	      }
	    }, this.ua).send();
	
	    // Emit the request event
	    this.emit(method.toLowerCase(), request);
	
	    return this;
	  },
	
	  close: function() {
	    var idx;
	
	    if(this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    this.logger.log('closing INVITE session ' + this.id);
	
	    // 1st Step. Terminate media.
	    if (this.mediaHandler){
	      this.mediaHandler.close();
	    }
	
	    // 2nd Step. Terminate signaling.
	
	    // Clear session timers
	    for(idx in this.timers) {
	      SIP.Timers.clearTimeout(this.timers[idx]);
	    }
	
	    // Terminate dialogs
	
	    // Terminate confirmed dialog
	    if(this.dialog) {
	      this.dialog.terminate();
	      delete this.dialog;
	    }
	
	    // Terminate early dialogs
	    for(idx in this.earlyDialogs) {
	      this.earlyDialogs[idx].terminate();
	      delete this.earlyDialogs[idx];
	    }
	
	    this.status = C.STATUS_TERMINATED;
	
	    delete this.ua.sessions[this.id];
	    return this;
	  },
	
	  createDialog: function(message, type, early) {
	    var dialog, early_dialog,
	      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],
	      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],
	      id = message.call_id + local_tag + remote_tag;
	
	    early_dialog = this.earlyDialogs[id];
	
	    // Early Dialog
	    if (early) {
	      if (early_dialog) {
	        return true;
	      } else {
	        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);
	
	        // Dialog has been successfully created.
	        if(early_dialog.error) {
	          this.logger.error(early_dialog.error);
	          this.failed(message, SIP.C.causes.INTERNAL_ERROR);
	          return false;
	        } else {
	          this.earlyDialogs[id] = early_dialog;
	          return true;
	        }
	      }
	    }
	    // Confirmed Dialog
	    else {
	      // In case the dialog is in _early_ state, update it
	      if (early_dialog) {
	        early_dialog.update(message, type);
	        this.dialog = early_dialog;
	        delete this.earlyDialogs[id];
	        for (var dia in this.earlyDialogs) {
	          this.earlyDialogs[dia].terminate();
	          delete this.earlyDialogs[dia];
	        }
	        return true;
	      }
	
	      // Otherwise, create a _confirmed_ dialog
	      dialog = new SIP.Dialog(this, message, type);
	
	      if(dialog.error) {
	        this.logger.error(dialog.error);
	        this.failed(message, SIP.C.causes.INTERNAL_ERROR);
	        return false;
	      } else {
	        this.to_tag = message.to_tag;
	        this.dialog = dialog;
	        return true;
	      }
	    }
	  },
	
	  /**
	  * Check if Session is ready for a re-INVITE
	  *
	  * @returns {Boolean}
	  */
	  isReadyToReinvite: function() {
	    return this.mediaHandler.isReady() &&
	      !this.dialog.uac_pending_reply &&
	      !this.dialog.uas_pending_reply;
	  },
	
	  /**
	   * Mute
	   */
	  mute: function(options) {
	    var ret = this.mediaHandler.mute(options);
	    if (ret) {
	      this.onmute(ret);
	    }
	  },
	
	  /**
	   * Unmute
	   */
	  unmute: function(options) {
	    var ret = this.mediaHandler.unmute(options);
	    if (ret) {
	      this.onunmute(ret);
	    }
	  },
	
	  /**
	   * Hold
	   */
	  hold: function(options) {
	
	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.mediaHandler.hold();
	
	    // Check if RTCSession is ready to send a reINVITE
	    if (!this.isReadyToReinvite()) {
	      /* If there is a pending 'unhold' action, cancel it and don't queue this one
	       * Else, if there isn't any 'hold' action, add this one to the queue
	       * Else, if there is already a 'hold' action, skip
	       */
	      if (this.pending_actions.isPending('unhold')) {
	        this.pending_actions.pop('unhold');
	      } else if (!this.pending_actions.isPending('hold')) {
	        this.pending_actions.push('hold');
	      }
	      return;
	    } else if (this.local_hold === true) {
	        return;
	    }
	
	    this.onhold('local');
	
	    options = options || {};
	    options.mangle = function(body){
	
	      // Don't receive media
	      // TODO - This will break for media streams with different directions.
	      if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(body)) {
	        body = body.replace(/(m=[^\r]*\r\n)/g, '$1a=sendonly\r\n');
	      } else {
	        body = body.replace(/a=sendrecv\r\n/g, 'a=sendonly\r\n');
	        body = body.replace(/a=recvonly\r\n/g, 'a=inactive\r\n');
	      }
	
	      return body;
	    };
	
	    this.sendReinvite(options);
	  },
	
	  /**
	   * Unhold
	   */
	  unhold: function(options) {
	
	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.mediaHandler.unhold();
	
	    if (!this.isReadyToReinvite()) {
	      /* If there is a pending 'hold' action, cancel it and don't queue this one
	       * Else, if there isn't any 'unhold' action, add this one to the queue
	       * Else, if there is already a 'unhold' action, skip
	       */
	      if (this.pending_actions.isPending('hold')) {
	        this.pending_actions.pop('hold');
	      } else if (!this.pending_actions.isPending('unhold')) {
	        this.pending_actions.push('unhold');
	      }
	      return;
	    } else if (this.local_hold === false) {
	      return;
	    }
	
	    this.onunhold('local');
	
	    this.sendReinvite(options);
	  },
	
	  /**
	   * isOnHold
	   */
	  isOnHold: function() {
	    return {
	      local: this.local_hold,
	      remote: this.remote_hold
	    };
	  },
	
	  /**
	   * In dialog INVITE Reception
	   * @private
	   */
	  receiveReinvite: function(request) {
	    var self = this;
	
	    if (!request.body) {
	      return;
	    }
	
	    if (request.getHeader('Content-Type') !== 'application/sdp') {
	      this.logger.warn('invalid Content-Type');
	      request.reply(415);
	      return;
	    }
	
	    this.mediaHandler.setDescription(request.body)
	    .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
	    .then(function(body) {
	      request.reply(200, null, ['Contact: ' + self.contact], body,
	        function() {
	          self.status = C.STATUS_WAITING_FOR_ACK;
	          self.setInvite2xxTimer(request, body);
	          self.setACKTimer();
	
	          // Are we holding?
	          var hold = (/a=(sendonly|inactive)/).test(request.body);
	
	          if (self.remote_hold && !hold) {
	            self.onunhold('remote');
	          } else if (!self.remote_hold && hold) {
	            self.onhold('remote');
	          }
	        });
	    })
	    .catch(function onFailure (e) {
	      var statusCode;
	      if (e instanceof SIP.Exceptions.GetDescriptionError) {
	        statusCode = 500;
	      } else {
	        self.logger.error(e);
	        statusCode = 488;
	      }
	      request.reply(statusCode);
	    });
	  },
	
	  sendReinvite: function(options) {
	    options = options || {};
	
	    var
	      self = this,
	      extraHeaders = (options.extraHeaders || []).slice(),
	      eventHandlers = options.eventHandlers || {},
	      mangle = options.mangle || null,
	      succeeded;
	
	    if (eventHandlers.succeeded) {
	      succeeded = eventHandlers.succeeded;
	    }
	    this.reinviteSucceeded = function(){
	      SIP.Timers.clearTimeout(self.timers.ackTimer);
	      SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
	      self.status = C.STATUS_CONFIRMED;
	      succeeded && succeeded.apply(this, arguments);
	    };
	    if (eventHandlers.failed) {
	      this.reinviteFailed = eventHandlers.failed;
	    } else {
	      this.reinviteFailed = function(){};
	    }
	
	    extraHeaders.push('Contact: ' + this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	    extraHeaders.push('Content-Type: application/sdp');
	
	    this.receiveResponse = this.receiveReinviteResponse;
	    //REVISIT
	    this.mediaHandler.getDescription(self.mediaHint)
	    .then(mangle)
	    .then(
	      function(body){
	        self.dialog.sendRequest(self, SIP.C.INVITE, {
	          extraHeaders: extraHeaders,
	          body: body
	        });
	      },
	      function() {
	        if (self.isReadyToReinvite()) {
	          self.onReadyToReinvite();
	        }
	        self.reinviteFailed();
	      }
	    );
	  },
	
	  receiveRequest: function (request) {
	    switch (request.method) {
	      case SIP.C.BYE:
	        request.reply(200);
	        if(this.status === C.STATUS_CONFIRMED) {
	          this.emit('bye', request);
	          this.terminated(request, SIP.C.causes.BYE);
	        }
	        break;
	      case SIP.C.INVITE:
	        if(this.status === C.STATUS_CONFIRMED) {
	          this.logger.log('re-INVITE received');
	          this.receiveReinvite(request);
	        }
	        break;
	      case SIP.C.INFO:
	        if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {
	          var body, tone, duration,
	              contentType = request.getHeader('content-type'),
	              reg_tone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/,
	              reg_duration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
	
	          if (contentType) {
	            if (contentType.match(/^application\/dtmf-relay/i)) {
	              if (request.body) {
	                body = request.body.split('\r\n', 2);
	                if (body.length === 2) {
	                  if (reg_tone.test(body[0])) {
	                    tone = body[0].replace(reg_tone,"$2");
	                  }
	                  if (reg_duration.test(body[1])) {
	                    duration = parseInt(body[1].replace(reg_duration,"$2"), 10);
	                  }
	                }
	              }
	
	              new DTMF(this, tone, {duration: duration}).init_incoming(request);
	            } else {
	              request.reply(415, null, ["Accept: application/dtmf-relay"]);
	            }
	          }
	        }
	        break;
	      case SIP.C.REFER:
	        if(this.status ===  C.STATUS_CONFIRMED) {
	          this.logger.log('REFER received');
	          var hasReferListener = this.listeners('refer').length,
	              notifyBody;
	
	          if (hasReferListener) {
	            request.reply(202, 'Accepted');
	            notifyBody = 'SIP/2.0 100 Trying';
	
	            this.sendRequest(SIP.C.NOTIFY, {
	              extraHeaders:[
	                'Event: refer',
	                'Subscription-State: terminated',
	                'Content-Type: message/sipfrag'
	              ],
	              body: notifyBody,
	              receiveResponse: function() {}
	            });
	
	            this.emit('refer', request);
	          } else {
	            // RFC 3515.2.4.2: 'the UA MAY decline the request.'
	            request.reply(603, 'Declined');
	          }
	        }
	        break;
	      case SIP.C.NOTIFY:
	        request.reply(200, 'OK');
	        this.emit('notify', request);
	        break;
	    }
	  },
	
	  /**
	   * Reception of Response for in-dialog INVITE
	   * @private
	   */
	  receiveReinviteResponse: function(response) {
	    var self = this,
	        contentType = response.getHeader('Content-Type');
	
	    if (this.status === C.STATUS_TERMINATED) {
	      return;
	    }
	
	    switch(true) {
	      case /^1[0-9]{2}$/.test(response.status_code):
	        break;
	      case /^2[0-9]{2}$/.test(response.status_code):
	        this.status = C.STATUS_CONFIRMED;
	
	        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});
	
	        if(!response.body) {
	          this.reinviteFailed();
	          break;
	        } else if (contentType !== 'application/sdp') {
	          this.reinviteFailed();
	          break;
	        }
	
	        //REVISIT
	        this.mediaHandler.setDescription(response.body)
	        .then(
	          function onSuccess () {
	            self.reinviteSucceeded();
	          },
	          function onFailure () {
	            self.reinviteFailed();
	          }
	        );
	        break;
	      default:
	        this.reinviteFailed();
	    }
	  },
	
	  acceptAndTerminate: function(response, status_code, reason_phrase) {
	    var extraHeaders = [];
	
	    if (status_code) {
	      extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));
	    }
	
	    // An error on dialog creation will fire 'failed' event
	    if (this.dialog || this.createDialog(response, 'UAC')) {
	      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
	      this.sendRequest(SIP.C.BYE, {
	        extraHeaders: extraHeaders
	      });
	    }
	
	    return this;
	  },
	
	  /**
	   * RFC3261 13.3.1.4
	   * Response retransmissions cannot be accomplished by transaction layer
	   *  since it is destroyed when receiving the first 2xx answer
	   */
	  setInvite2xxTimer: function(request, body) {
	    var self = this,
	        timeout = SIP.Timers.T1;
	
	    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {
	      if (self.status !== C.STATUS_WAITING_FOR_ACK) {
	        return;
	      }
	
	      self.logger.log('no ACK received, attempting to retransmit OK');
	
	      request.reply(200, null, ['Contact: ' + self.contact], body);
	
	      timeout = Math.min(timeout * 2, SIP.Timers.T2);
	
	      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);
	    }, timeout);
	  },
	
	  /**
	   * RFC3261 14.2
	   * If a UAS generates a 2xx response and never receives an ACK,
	   *  it SHOULD generate a BYE to terminate the dialog.
	   */
	  setACKTimer: function() {
	    var self = this;
	
	    this.timers.ackTimer = SIP.Timers.setTimeout(function() {
	      if(self.status === C.STATUS_WAITING_FOR_ACK) {
	        self.logger.log('no ACK received for an extended period of time, terminating the call');
	        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
	        self.sendRequest(SIP.C.BYE);
	        self.terminated(null, SIP.C.causes.NO_ACK);
	      }
	    }, SIP.Timers.TIMER_H);
	  },
	
	  /*
	   * @private
	   */
	  onReadyToReinvite: function() {
	    var action = this.pending_actions.shift();
	
	    if (!action || !this[action.name]) {
	      return;
	    }
	
	    this[action.name]();
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  },
	
	  onDialogError: function(response) {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(response, SIP.C.causes.DIALOG_ERROR);
	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
	    }
	  },
	
	  /**
	   * @private
	   */
	  onhold: function(originator) {
	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;
	    this.emit('hold', { originator: originator });
	  },
	
	  /**
	   * @private
	   */
	  onunhold: function(originator) {
	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;
	    this.emit('unhold', { originator: originator });
	  },
	
	  /*
	   * @private
	   */
	  onmute: function(options) {
	    this.emit('muted', {
	      audio: options.audio,
	      video: options.video
	    });
	  },
	
	  /*
	   * @private
	   */
	  onunmute: function(options) {
	    this.emit('unmuted', {
	      audio: options.audio,
	      video: options.video
	    });
	  },
	
	  failed: function(response, cause) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	    this.emit('failed', response || null, cause || null);
	    return this;
	  },
	
	  rejected: function(response, cause) {
	    this.emit('rejected',
	      response || null,
	      cause || null
	    );
	    return this;
	  },
	
	  canceled: function() {
	    this.emit('cancel');
	    return this;
	  },
	
	  accepted: function(response, cause) {
	    cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);
	
	    this.startTime = new Date();
	
	    if (this.replacee) {
	      this.replacee.emit('replaced', this);
	      this.replacee.terminate();
	    }
	    this.emit('accepted', response, cause);
	    return this;
	  },
	
	  terminated: function(message, cause) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    this.endTime = new Date();
	
	    this.close();
	    this.emit('terminated',
	      message || null,
	      cause || null
	    );
	    return this;
	  },
	
	  connecting: function(request) {
	    this.emit('connecting', { request: request });
	    return this;
	  }
	};
	
	Session.desugar = function desugar(options) {
	  if (environment.HTMLMediaElement && options instanceof environment.HTMLMediaElement) {
	    options = {
	      media: {
	        constraints: {
	          audio: true,
	          video: options.tagName === 'VIDEO'
	        },
	        render: {
	          remote: options
	        }
	      }
	    };
	  }
	  return options || {};
	};
	
	
	Session.C = C;
	SIP.Session = Session;
	
	
	InviteServerContext = function(ua, request) {
	  var expires,
	    self = this,
	    contentType = request.getHeader('Content-Type'),
	    contentDisp = request.parseHeader('Content-Disposition');
	
	  // Check body and content type
	  if ((!contentDisp && contentType !== 'application/sdp') || (contentDisp && contentDisp.type === 'render')) {
	    this.renderbody = request.body;
	    this.rendertype = contentType;
	  } else if (contentType !== 'application/sdp' && (contentDisp && contentDisp.type === 'session')) {
	    request.reply(415);
	    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it
	    return;
	  }
	
	  //TODO: move this into media handler
	  SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);
	  SIP.Hacks.AllBrowsers.maskDtls(request);
	
	  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);
	  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);
	
	  this.status = C.STATUS_INVITE_RECEIVED;
	  this.from_tag = request.from_tag;
	  this.id = request.call_id + this.from_tag;
	  this.request = request;
	  this.contact = this.ua.contact.toString();
	
	  this.receiveNonInviteResponse = function () {}; // intentional no-op
	
	  this.logger = ua.getLogger('sip.inviteservercontext', this.id);
	
	  //Save the session into the ua sessions collection.
	  this.ua.sessions[this.id] = this;
	
	  //Get the Expires header value if exists
	  if(request.hasHeader('expires')) {
	    expires = request.getHeader('expires') * 1000;
	  }
	
	  //Set 100rel if necessary
	  function set100rel(h,c) {
	    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {
	      self.rel100 = c;
	    }
	  }
	  set100rel('require', SIP.C.supported.REQUIRED);
	  set100rel('supported', SIP.C.supported.SUPPORTED);
	
	  /* Set the to_tag before
	   * replying a response code that will create a dialog.
	   */
	  request.to_tag = SIP.Utils.newTag();
	
	  // An error on dialog creation will fire 'failed' event
	  if(!this.createDialog(request, 'UAS', true)) {
	    request.reply(500, 'Missing Contact header field');
	    return;
	  }
	
	  //Initialize Media Session
	  this.mediaHandler = this.mediaHandlerFactory(this, {
	    RTCConstraints: {"optional": [{'DtlsSrtpKeyAgreement': 'true'}]}
	  });
	
	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
	  }
	
	  function fireNewSession() {
	    var options = {extraHeaders: ['Contact: ' + self.contact]};
	
	    if (self.rel100 !== SIP.C.supported.REQUIRED) {
	      self.progress(options);
	    }
	    self.status = C.STATUS_WAITING_FOR_ANSWER;
	
	    // Set userNoAnswerTimer
	    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {
	      request.reply(408);
	      self.failed(request, SIP.C.causes.NO_ANSWER);
	      self.terminated(request, SIP.C.causes.NO_ANSWER);
	    }, self.ua.configuration.noAnswerTimeout);
	
	    /* Set expiresTimer
	     * RFC3261 13.3.1
	     */
	    if (expires) {
	      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {
	        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {
	          request.reply(487);
	          self.failed(request, SIP.C.causes.EXPIRES);
	          self.terminated(request, SIP.C.causes.EXPIRES);
	        }
	      }, expires);
	    }
	
	    self.emit('invite',request);
	  }
	
	  if (!request.body || this.renderbody) {
	    SIP.Timers.setTimeout(fireNewSession, 0);
	  } else {
	    this.hasOffer = true;
	    this.mediaHandler.setDescription(request.body)
	    .then(
	      fireNewSession,
	      function onFailure (e) {
	        self.logger.warn('invalid SDP');
	        self.logger.warn(e);
	        request.reply(488);
	      }
	    );
	  }
	};
	
	InviteServerContext.prototype = {
	  reject: function(options) {
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.logger.log('rejecting RTCSession');
	
	    SIP.ServerContext.prototype.reject.call(this, options);
	    return this.terminated();
	  },
	
	  terminate: function(options) {
	    options = options || {};
	
	    var
	    extraHeaders = (options.extraHeaders || []).slice(),
	    body = options.body,
	    dialog,
	    self = this;
	
	    if (this.status === C.STATUS_WAITING_FOR_ACK &&
	       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
	      dialog = this.dialog;
	
	      this.receiveRequest = function(request) {
	        if (request.method === SIP.C.ACK) {
	          this.request(SIP.C.BYE, {
	            extraHeaders: extraHeaders,
	            body: body
	          });
	          dialog.terminate();
	        }
	      };
	
	      this.request.server_transaction.on('stateChanged', function(){
	        if (this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	          this.request = new SIP.OutgoingRequest(
	            SIP.C.BYE,
	            this.dialog.remote_target,
	            this.ua,
	            {
	              'cseq': this.dialog.local_seqnum+=1,
	              'call_id': this.dialog.id.call_id,
	              'from_uri': this.dialog.local_uri,
	              'from_tag': this.dialog.id.local_tag,
	              'to_uri': this.dialog.remote_uri,
	              'to_tag': this.dialog.id.remote_tag,
	              'route_set': this.dialog.route_set
	            },
	            extraHeaders,
	            body
	          );
	
	          new SIP.RequestSender(
	            {
	              request: this.request,
	              onRequestTimeout: function() {
	                self.onRequestTimeout();
	              },
	              onTransportError: function() {
	                self.onTransportError();
	              },
	              receiveResponse: function() {
	                return;
	              }
	            },
	            this.ua
	          ).send();
	          dialog.terminate();
	        }
	      });
	
	      this.emit('bye', this.request);
	      this.terminated();
	
	      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)
	      this.dialog = dialog;
	
	      // Restore the dialog into 'ua' so the ACK can reach 'this' session
	      this.ua.dialogs[dialog.id.toString()] = dialog;
	
	    } else if (this.status === C.STATUS_CONFIRMED) {
	      this.bye(options);
	    } else {
	      this.reject(options);
	    }
	
	    return this;
	  },
	
	  /*
	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	   */
	  progress: function (options) {
	    options = options || {};
	    var
	      statusCode = options.statusCode || 180,
	      reasonPhrase = options.reasonPhrase,
	      extraHeaders = (options.extraHeaders || []).slice(),
	      iceServers,
	      stunServers = options.stunServers || null,
	      turnServers = options.turnServers || null,
	      body = options.body,
	      response;
	
	    if (statusCode < 100 || statusCode > 199) {
	      throw new TypeError('Invalid statusCode: ' + statusCode);
	    }
	
	    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    if (stunServers || turnServers) {
	      if (stunServers) {
	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid stunServers: '+ stunServers);
	        } else {
	          this.stunServers = iceServers;
	        }
	      }
	
	      if (turnServers) {
	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid turnServers: '+ turnServers);
	        } else {
	          this.turnServers = iceServers;
	        }
	      }
	
	      this.mediaHandler.updateIceServers({
	        stunServers: this.stunServers,
	        turnServers: this.turnServers
	      });
	    }
	
	    function do100rel() {
	      /* jshint validthis: true */
	      statusCode = options.statusCode || 183;
	
	      // Set status and add extra headers
	      this.status = C.STATUS_WAITING_FOR_PRACK;
	      extraHeaders.push('Contact: '+ this.contact);
	      extraHeaders.push('Require: 100rel');
	      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));
	
	      // Save media hint for later (referred sessions)
	      this.mediaHint = options.media;
	
	      // Get the session description to add to preaccept with
	      this.mediaHandler.getDescription(options.media)
	      .then(
	        function onSuccess (body) {
	          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
	            return;
	          }
	
	          this.early_sdp = body;
	          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;
	
	          // Retransmit until we get a response or we time out (see prackTimer below)
	          var timeout = SIP.Timers.T1;
	          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {
	            this.request.reply(statusCode, null, extraHeaders, body);
	            timeout *= 2;
	            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);
	          }.bind(this), timeout);
	
	          // Timeout and reject INVITE if no response
	          this.timers.prackTimer = SIP.Timers.setTimeout(function () {
	            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {
	              return;
	            }
	
	            this.logger.log('no PRACK received, rejecting the call');
	            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	            this.request.reply(504);
	            this.terminated(null, SIP.C.causes.NO_PRACK);
	          }.bind(this), SIP.Timers.T1 * 64);
	
	          // Send the initial response
	          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	          this.emit('progress', response, reasonPhrase);
	        }.bind(this),
	
	        function onFailure () {
	          this.request.reply(480);
	          this.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          this.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	        }.bind(this)
	      );
	    } // end do100rel
	
	    function normalReply() {
	      /* jshint validthis:true */
	      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	      this.emit('progress', response, reasonPhrase);
	    }
	
	    if (options.statusCode !== 100 &&
	        (this.rel100 === SIP.C.supported.REQUIRED ||
	         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||
	         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {
	      do100rel.apply(this);
	    } else {
	      normalReply.apply(this);
	    }
	    return this;
	  },
	
	  /*
	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	   */
	  accept: function(options) {
	    options = Object.create(Session.desugar(options));
	    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
	    this.mediaHint = options.media;
	
	    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21
	    var
	      //idx, length, hasAudio, hasVideo,
	      self = this,
	      request = this.request,
	      extraHeaders = (options.extraHeaders || []).slice(),
	    //mediaStream = options.mediaStream || null,
	      iceServers,
	      stunServers = options.stunServers || null,
	      turnServers = options.turnServers || null,
	      sdpCreationSucceeded = function(body) {
	        var
	          response,
	          // run for reply success callback
	          replySucceeded = function() {
	            self.status = C.STATUS_WAITING_FOR_ACK;
	
	            self.setInvite2xxTimer(request, body);
	            self.setACKTimer();
	          },
	
	          // run for reply failure callback
	          replyFailed = function() {
	            self.failed(null, SIP.C.causes.CONNECTION_ERROR);
	            self.terminated(null, SIP.C.causes.CONNECTION_ERROR);
	          };
	
	        // Chrome might call onaddstream before accept() is called, which means
	        // mediaHandler.render() was called without a renderHint, so we need to
	        // re-render now that mediaHint.render has been set.
	        //
	        // Chrome seems to be in the right regarding this, see
	        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream
	        self.mediaHandler.render();
	
	        extraHeaders.push('Contact: ' + self.contact);
	        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	
	        if(!self.hasOffer) {
	          self.hasOffer = true;
	        } else {
	          self.hasAnswer = true;
	        }
	        response = request.reply(200, null, extraHeaders,
	                      body,
	                      replySucceeded,
	                      replyFailed
	                     );
	        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail
	          self.accepted(response, SIP.Utils.getReasonPhrase(200));
	        }
	      },
	
	      sdpCreationFailed = function() {
	        if (self.status === C.STATUS_TERMINATED) {
	          return;
	        }
	        // TODO - fail out on error
	        self.request.reply(480);
	        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
	        self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	        self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	      };
	
	    // Check Session Status
	    if (this.status === C.STATUS_WAITING_FOR_PRACK) {
	      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;
	      return this;
	    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {
	      this.status = C.STATUS_ANSWERED;
	    } else if (this.status !== C.STATUS_EARLY_MEDIA) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    if ((stunServers || turnServers) &&
	        (this.status !== C.STATUS_EARLY_MEDIA && this.status !== C.STATUS_ANSWERED_WAITING_FOR_PRACK)) {
	      if (stunServers) {
	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid stunServers: '+ stunServers);
	        } else {
	          this.stunServers = iceServers;
	        }
	      }
	
	      if (turnServers) {
	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid turnServers: '+ turnServers);
	        } else {
	          this.turnServers = iceServers;
	        }
	      }
	
	      this.mediaHandler.updateIceServers({
	        stunServers: this.stunServers,
	        turnServers: this.turnServers
	      });
	    }
	
	    // An error on dialog creation will fire 'failed' event
	    if(!this.createDialog(request, 'UAS')) {
	      request.reply(500, 'Missing Contact header field');
	      return this;
	    }
	
	    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);
	
	    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21
	    /*
	    length = this.getRemoteStreams().length;
	
	    for (idx = 0; idx < length; idx++) {
	      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {
	        hasVideo = true;
	      }
	      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {
	        hasAudio = true;
	      }
	    }
	
	    if (!hasAudio && this.mediaConstraints.audio === true) {
	      this.mediaConstraints.audio = false;
	      if (mediaStream) {
	        length = mediaStream.getAudioTracks().length;
	        for (idx = 0; idx < length; idx++) {
	          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);
	        }
	      }
	    }
	
	    if (!hasVideo && this.mediaConstraints.video === true) {
	      this.mediaConstraints.video = false;
	      if (mediaStream) {
	        length = mediaStream.getVideoTracks().length;
	        for (idx = 0; idx < length; idx++) {
	          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);
	        }
	      }
	    }
	    */
	
	    if (this.status === C.STATUS_EARLY_MEDIA) {
	      sdpCreationSucceeded();
	    } else {
	      this.mediaHandler.getDescription(self.mediaHint)
	      .then(
	        sdpCreationSucceeded,
	        sdpCreationFailed
	      );
	    }
	
	    return this;
	  },
	
	  receiveRequest: function(request) {
	
	    // ISC RECEIVE REQUEST
	
	    function confirmSession() {
	      /* jshint validthis:true */
	      var contentType;
	
	      SIP.Timers.clearTimeout(this.timers.ackTimer);
	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
	      this.status = C.STATUS_CONFIRMED;
	      this.unmute();
	
	      // TODO - this logic assumes Content-Disposition defaults
	      contentType = request.getHeader('Content-Type');
	      if (contentType !== 'application/sdp') {
	        this.renderbody = request.body;
	        this.rendertype = contentType;
	      }
	    }
	
	    switch(request.method) {
	    case SIP.C.CANCEL:
	      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
	       * was in progress and that the UAC MAY continue with the session established by
	       * any 2xx response, or MAY terminate with BYE. SIP does continue with the
	       * established session. So the CANCEL is processed only if the session is not yet
	       * established.
	       */
	
	      /*
	       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the
	       *request opening the session.
	       */
	      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||
	         this.status === C.STATUS_WAITING_FOR_PRACK ||
	         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||
	         this.status === C.STATUS_EARLY_MEDIA ||
	         this.status === C.STATUS_ANSWERED) {
	
	        this.status = C.STATUS_CANCELED;
	        this.request.reply(487);
	        this.canceled(request);
	        this.rejected(request, SIP.C.causes.CANCELED);
	        this.failed(request, SIP.C.causes.CANCELED);
	        this.terminated(request, SIP.C.causes.CANCELED);
	      }
	      break;
	    case SIP.C.ACK:
	      if(this.status === C.STATUS_WAITING_FOR_ACK) {
	        if (!this.hasAnswer) {
	          if(request.body && request.getHeader('content-type') === 'application/sdp') {
	            // ACK contains answer to an INVITE w/o SDP negotiation
	            SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);
	            SIP.Hacks.AllBrowsers.maskDtls(request);
	
	            this.hasAnswer = true;
	            this.mediaHandler.setDescription(request.body)
	            .then(
	              confirmSession.bind(this),
	              function onFailure (e) {
	                this.logger.warn(e);
	                this.terminate({
	                  statusCode: '488',
	                  reasonPhrase: 'Bad Media Description'
	                });
	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }.bind(this)
	            );
	          } else if (this.early_sdp) {
	            confirmSession.apply(this);
	          } else {
	            //TODO: Pass to mediahandler
	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	          }
	        } else {
	          confirmSession.apply(this);
	        }
	      }
	      break;
	    case SIP.C.PRACK:
	      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	        //localMedia = session.mediaHandler.localMedia;
	        if(!this.hasAnswer) {
	          if(request.body && request.getHeader('content-type') === 'application/sdp') {
	            this.hasAnswer = true;
	            this.mediaHandler.setDescription(request.body)
	            .then(
	              function onSuccess () {
	                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	                SIP.Timers.clearTimeout(this.timers.prackTimer);
	                request.reply(200);
	                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	                  this.status = C.STATUS_EARLY_MEDIA;
	                  this.accept();
	                }
	                this.status = C.STATUS_EARLY_MEDIA;
	                //REVISIT
	                this.mute();
	              }.bind(this),
	              function onFailure (e) {
	                //TODO: Send to media handler
	                this.logger.warn(e);
	                this.terminate({
	                  statusCode: '488',
	                  reasonPhrase: 'Bad Media Description'
	                });
	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }.bind(this)
	            );
	          } else {
	            this.terminate({
	              statusCode: '488',
	              reasonPhrase: 'Bad Media Description'
	            });
	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	          }
	        } else {
	          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	          SIP.Timers.clearTimeout(this.timers.prackTimer);
	          request.reply(200);
	
	          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	            this.status = C.STATUS_EARLY_MEDIA;
	            this.accept();
	          }
	          this.status = C.STATUS_EARLY_MEDIA;
	          //REVISIT
	          this.mute();
	        }
	      } else if(this.status === C.STATUS_EARLY_MEDIA) {
	        request.reply(200);
	      }
	      break;
	    default:
	      Session.prototype.receiveRequest.apply(this, [request]);
	      break;
	    }
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  }
	
	};
	
	SIP.InviteServerContext = InviteServerContext;
	
	InviteClientContext = function(ua, target, options) {
	  options = Object.create(Session.desugar(options));
	  options.params = Object.create(options.params || Object.prototype);
	
	  var iceServers,
	    extraHeaders = (options.extraHeaders || []).slice(),
	    stunServers = options.stunServers || null,
	    turnServers = options.turnServers || null,
	    mediaHandlerFactory = options.mediaHandlerFactory || ua.configuration.mediaHandlerFactory,
	    isMediaSupported = mediaHandlerFactory.isSupported;
	
	  // Check WebRTC support
	  if (isMediaSupported && !isMediaSupported()) {
	    throw new SIP.Exceptions.NotSupportedError('Media not supported');
	  }
	
	  this.RTCConstraints = options.RTCConstraints || {};
	  this.inviteWithoutSdp = options.inviteWithoutSdp || false;
	
	  // Set anonymous property
	  this.anonymous = options.anonymous || false;
	
	  // Custom data to be sent either in INVITE or in ACK
	  this.renderbody = options.renderbody || null;
	  this.rendertype = options.rendertype || 'text/plain';
	
	  options.params.from_tag = this.from_tag;
	
	  /* Do not add ;ob in initial forming dialog requests if the registration over
	   *  the current connection got a GRUU URI.
	   */
	  this.contact = ua.contact.toString({
	    anonymous: this.anonymous,
	    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu
	  });
	
	  if (this.anonymous) {
	    options.params.from_displayName = 'Anonymous';
	    options.params.from_uri = 'sip:anonymous@anonymous.invalid';
	
	    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());
	    extraHeaders.push('Privacy: id');
	  }
	  extraHeaders.push('Contact: '+ this.contact);
	  extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	  if (!this.inviteWithoutSdp) {
	    extraHeaders.push('Content-Type: application/sdp');
	  } else if (this.renderbody) {
	    extraHeaders.push('Content-Type: ' + this.rendertype);
	    extraHeaders.push('Content-Disposition: render;handling=optional');
	  }
	
	  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {
	    extraHeaders.push('Require: 100rel');
	  }
	  if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {
	    extraHeaders.push('Require: replaces');
	  }
	
	  options.extraHeaders = extraHeaders;
	
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);
	  SIP.Utils.augment(this, SIP.Session, [mediaHandlerFactory]);
	
	  // Check Session Status
	  if (this.status !== C.STATUS_NULL) {
	    throw new SIP.Exceptions.InvalidStateError(this.status);
	  }
	
	  // Session parameter initialization
	  this.from_tag = SIP.Utils.newTag();
	
	  // OutgoingSession specific parameters
	  this.isCanceled = false;
	  this.received_100 = false;
	
	  this.method = SIP.C.INVITE;
	
	  this.receiveNonInviteResponse = this.receiveResponse;
	  this.receiveResponse = this.receiveInviteResponse;
	
	  this.logger = ua.getLogger('sip.inviteclientcontext');
	
	  if (stunServers) {
	    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	    if (!iceServers) {
	      throw new TypeError('Invalid stunServers: '+ stunServers);
	    } else {
	      this.stunServers = iceServers;
	    }
	  }
	
	  if (turnServers) {
	    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	    if (!iceServers) {
	      throw new TypeError('Invalid turnServers: '+ turnServers);
	    } else {
	      this.turnServers = iceServers;
	    }
	  }
	
	  ua.applicants[this] = this;
	
	  this.id = this.request.call_id + this.from_tag;
	
	  //Initialize Media Session
	  this.mediaHandler = this.mediaHandlerFactory(this, {
	    RTCConstraints: this.RTCConstraints,
	    stunServers: this.stunServers,
	    turnServers: this.turnServers
	  });
	
	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
	  }
	
	  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
	  this.mediaHint = options.media;
	};
	
	InviteClientContext.prototype = {
	  invite: function () {
	    var self = this;
	
	    //Save the session into the ua sessions collection.
	    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway
	    this.ua.sessions[this.id] = this;
	
	    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level
	    // and hand sip.js a stream as the mediaHint
	    if (this.inviteWithoutSdp) {
	      //just send an invite with no sdp...
	      this.request.body = self.renderbody;
	      this.status = C.STATUS_INVITE_SENT;
	      this.send();
	    } else {
	      this.mediaHandler.getDescription(self.mediaHint)
	      .then(
	        function onSuccess(offer) {
	          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {
	            return;
	          }
	          self.hasOffer = true;
	          self.request.body = offer;
	          self.status = C.STATUS_INVITE_SENT;
	          self.send();
	        },
	        function onFailure() {
	          if (self.status === C.STATUS_TERMINATED) {
	            return;
	          }
	          // TODO...fail out
	          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
	          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	        }
	      );
	    }
	
	    return this;
	  },
	
	  receiveInviteResponse: function(response) {
	    var cause, //localMedia,
	      session = this,
	      id = response.call_id + response.from_tag + response.to_tag,
	      extraHeaders = [],
	      options = {};
	
	    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {
	      return;
	    }
	
	    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {
	      if (id !== this.dialog.id.toString() ) {
	        if (!this.createDialog(response, 'UAC', true)) {
	          return;
	        }
	        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,
	                                          {
	                                            body: SIP.Utils.generateFakeSDP(response.body)
	                                          });
	        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);
	
	        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable
	         * leg (due to peerConnection limitations) has been answered first. If your forking
	         * proxy does not hang up all unanswered branches on the first branch answered, remove this.
	         */
	        if(this.status !== C.STATUS_CONFIRMED) {
	          this.failed(response, SIP.C.causes.WEBRTC_ERROR);
	          this.terminated(response, SIP.C.causes.WEBRTC_ERROR);
	        }
	        return;
	      } else if (this.status === C.STATUS_CONFIRMED) {
	        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
	        return;
	      } else if (!this.hasAnswer) {
	        // invite w/o sdp is waiting for callback
	        //an invite with sdp must go on, and hasAnswer is true
	        return;
	      }
	    }
	
	    if (this.dialog && response.status_code < 200) {
	      /*
	        Early media has been set up with at least one other different branch,
	        but a final 2xx response hasn't been received
	      */
	      if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	          (this.dialog.pracked[this.dialog.pracked.length-1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0)) {
	        return;
	      }
	
	      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {
	        return;
	      }
	
	      if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	          (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
	        return;
	      }
	
	      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
	
	      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
	        extraHeaders: extraHeaders,
	        body: SIP.Utils.generateFakeSDP(response.body)
	      });
	      return;
	    }
	
	    // Proceed to cancellation if the user requested.
	    if(this.isCanceled) {
	      if(response.status_code >= 100 && response.status_code < 200) {
	        this.request.cancel(this.cancelReason);
	        this.canceled(null);
	      } else if(response.status_code >= 200 && response.status_code < 299) {
	        this.acceptAndTerminate(response);
	        this.emit('bye', this.request);
	      } else if (response.status_code >= 300) {
	        cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;
	        this.rejected(response, cause);
	        this.failed(response, cause);
	        this.terminated(response, cause);
	      }
	      return;
	    }
	
	    switch(true) {
	      case /^100$/.test(response.status_code):
	        this.received_100 = true;
	        this.emit('progress', response);
	        break;
	      case (/^1[0-9]{2}$/.test(response.status_code)):
	        // Do nothing with 1xx responses without To tag.
	        if(!response.to_tag) {
	          this.logger.warn('1xx response received without to tag');
	          break;
	        }
	
	        // Create Early Dialog if 1XX comes with contact
	        if(response.hasHeader('contact')) {
	          // An error on dialog creation will fire 'failed' event
	          if (!this.createDialog(response, 'UAC', true)) {
	            break;
	          }
	        }
	
	        this.status = C.STATUS_1XX_RECEIVED;
	
	        if(response.hasHeader('require') &&
	           response.getHeader('require').indexOf('100rel') !== -1) {
	
	          // Do nothing if this.dialog is already confirmed
	          if (this.dialog || !this.earlyDialogs[id]) {
	            break;
	          }
	
	          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
	            return;
	          }
	
	          SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);
	          SIP.Hacks.AllBrowsers.maskDtls(response);
	
	          if (!response.body) {
	            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
	            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
	              extraHeaders: extraHeaders
	            });
	            this.emit('progress', response);
	
	          } else if (this.hasOffer) {
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.hasAnswer = true;
	            this.dialog.pracked.push(response.getHeader('rseq'));
	
	            this.mediaHandler.setDescription(response.body)
	            .then(
	              function onSuccess () {
	                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	
	                session.sendRequest(SIP.C.PRACK, {
	                  extraHeaders: extraHeaders,
	                  receiveResponse: function() {}
	                });
	                session.status = C.STATUS_EARLY_MEDIA;
	                session.mute();
	                session.emit('progress', response);
	                /*
	                if (session.status === C.STATUS_EARLY_MEDIA) {
	                  localMedia = session.mediaHandler.localMedia;
	                  if (localMedia.getAudioTracks().length > 0) {
	                    localMedia.getAudioTracks()[0].enabled = false;
	                  }
	                  if (localMedia.getVideoTracks().length > 0) {
	                    localMedia.getVideoTracks()[0].enabled = false;
	                  }
	                }*/
	              },
	              function onFailure (e) {
	                session.logger.warn(e);
	                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
	                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }
	            );
	          } else {
	            var earlyDialog = this.earlyDialogs[id];
	            var earlyMedia = earlyDialog.mediaHandler;
	
	            earlyDialog.pracked.push(response.getHeader('rseq'));
	
	            earlyMedia.setDescription(response.body)
	            .then(earlyMedia.getDescription.bind(earlyMedia, session.mediaHint))
	            .then(function onSuccess(sdp) {
	              extraHeaders.push('Content-Type: application/sdp');
	              extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	              earlyDialog.sendRequest(session, SIP.C.PRACK, {
	                extraHeaders: extraHeaders,
	                body: sdp
	              });
	              session.status = C.STATUS_EARLY_MEDIA;
	              session.emit('progress', response);
	            })
	            .catch(function onFailure(e) {
	              if (e instanceof SIP.Exceptions.GetDescriptionError) {
	                earlyDialog.pracked.push(response.getHeader('rseq'));
	                if (session.status === C.STATUS_TERMINATED) {
	                  return;
	                }
	                // TODO - fail out on error
	                // session.failed(gum error);
	                session.failed(null, SIP.C.causes.WEBRTC_ERROR);
	                session.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	              } else {
	                earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1);
	                // Could not set remote description
	                session.logger.warn('invalid SDP');
	                session.logger.warn(e);
	              }
	            });
	          }
	        } else {
	          this.emit('progress', response);
	        }
	        break;
	      case /^2[0-9]{2}$/.test(response.status_code):
	        var cseq = this.request.cseq + ' ' + this.request.method;
	        if (cseq !== response.getHeader('cseq')) {
	          break;
	        }
	
	        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {
	          this.status = C.STATUS_CONFIRMED;
	          this.unmute();
	          /*localMedia = this.mediaHandler.localMedia;
	          if (localMedia.getAudioTracks().length > 0) {
	            localMedia.getAudioTracks()[0].enabled = true;
	          }
	          if (localMedia.getVideoTracks().length > 0) {
	            localMedia.getVideoTracks()[0].enabled = true;
	          }*/
	          options = {};
	          if (this.renderbody) {
	            extraHeaders.push('Content-Type: ' + this.rendertype);
	            options.extraHeaders = extraHeaders;
	            options.body = this.renderbody;
	          }
	          options.cseq = response.cseq;
	          this.sendRequest(SIP.C.ACK, options);
	          this.accepted(response);
	          break;
	        }
	        // Do nothing if this.dialog is already confirmed
	        if (this.dialog) {
	          break;
	        }
	
	        SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);
	        SIP.Hacks.AllBrowsers.maskDtls(response);
	
	        // This is an invite without sdp
	        if (!this.hasOffer) {
	          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {
	            //REVISIT
	            this.hasOffer = true;
	            this.hasAnswer = true;
	            this.mediaHandler = this.earlyDialogs[id].mediaHandler;
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.status = C.STATUS_CONFIRMED;
	            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});
	
	            this.unmute();
	            /*
	            localMedia = session.mediaHandler.localMedia;
	            if (localMedia.getAudioTracks().length > 0) {
	              localMedia.getAudioTracks()[0].enabled = true;
	            }
	            if (localMedia.getVideoTracks().length > 0) {
	              localMedia.getVideoTracks()[0].enabled = true;
	            }*/
	            this.accepted(response);
	          } else {
	            if(!response.body) {
	              this.acceptAndTerminate(response, 400, 'Missing session description');
	              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              break;
	            }
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.hasOffer = true;
	            this.mediaHandler.setDescription(response.body)
	            .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
	            .then(function onSuccess(sdp) {
	              //var localMedia;
	              if(session.isCanceled || session.status === C.STATUS_TERMINATED) {
	                return;
	              }
	
	              sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);
	
	              session.status = C.STATUS_CONFIRMED;
	              session.hasAnswer = true;
	
	              session.unmute();
	              /*localMedia = session.mediaHandler.localMedia;
	              if (localMedia.getAudioTracks().length > 0) {
	                localMedia.getAudioTracks()[0].enabled = true;
	              }
	              if (localMedia.getVideoTracks().length > 0) {
	                localMedia.getVideoTracks()[0].enabled = true;
	              }*/
	              session.sendRequest(SIP.C.ACK,{
	                body: sdp,
	                extraHeaders:['Content-Type: application/sdp'],
	                cseq:response.cseq
	              });
	              session.accepted(response);
	            })
	            .catch(function onFailure(e) {
	              if (e instanceof SIP.Exceptions.GetDescriptionError) {
	                // TODO do something here
	                session.logger.warn("there was a problem");
	              } else {
	                session.logger.warn('invalid SDP');
	                session.logger.warn(e);
	                response.reply(488);
	              }
	            });
	          }
	        } else if (this.hasAnswer){
	          if (this.renderbody) {
	            extraHeaders.push('Content-Type: ' + session.rendertype);
	            options.extraHeaders = extraHeaders;
	            options.body = this.renderbody;
	          }
	          this.sendRequest(SIP.C.ACK, options);
	        } else {
	          if(!response.body) {
	            this.acceptAndTerminate(response, 400, 'Missing session description');
	            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            break;
	          }
	          if (!this.createDialog(response, 'UAC')) {
	            break;
	          }
	          this.hasAnswer = true;
	          this.mediaHandler.setDescription(response.body)
	          .then(
	            function onSuccess () {
	              var options = {};//,localMedia;
	              session.status = C.STATUS_CONFIRMED;
	              session.unmute();
	              /*localMedia = session.mediaHandler.localMedia;
	              if (localMedia.getAudioTracks().length > 0) {
	                localMedia.getAudioTracks()[0].enabled = true;
	              }
	              if (localMedia.getVideoTracks().length > 0) {
	                localMedia.getVideoTracks()[0].enabled = true;
	              }*/
	              if (session.renderbody) {
	                extraHeaders.push('Content-Type: ' + session.rendertype);
	                options.extraHeaders = extraHeaders;
	                options.body = session.renderbody;
	              }
	              options.cseq = response.cseq;
	              session.sendRequest(SIP.C.ACK, options);
	              session.accepted(response);
	            },
	            function onFailure (e) {
	              session.logger.warn(e);
	              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
	              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            }
	          );
	        }
	        break;
	      default:
	        cause = SIP.Utils.sipErrorCause(response.status_code);
	        this.rejected(response, cause);
	        this.failed(response, cause);
	        this.terminated(response, cause);
	    }
	  },
	
	  cancel: function(options) {
	    options = options || {};
	
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.logger.log('canceling RTCSession');
	
	    var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
	
	    // Check Session Status
	    if (this.status === C.STATUS_NULL ||
	        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {
	      this.isCanceled = true;
	      this.cancelReason = cancel_reason;
	    } else if (this.status === C.STATUS_INVITE_SENT ||
	               this.status === C.STATUS_1XX_RECEIVED ||
	               this.status === C.STATUS_EARLY_MEDIA) {
	      this.request.cancel(cancel_reason);
	    }
	
	    return this.canceled();
	  },
	
	  terminate: function(options) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {
	      this.bye(options);
	    } else {
	      this.cancel(options);
	    }
	
	    return this;
	  },
	
	  receiveRequest: function(request) {
	    // ICC RECEIVE REQUEST
	
	    // Reject CANCELs
	    if (request.method === SIP.C.CANCEL) {
	      // TODO; make this a switch when it gets added
	    }
	
	    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {
	      SIP.Timers.clearTimeout(this.timers.ackTimer);
	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
	      this.status = C.STATUS_CONFIRMED;
	      this.unmute();
	
	      this.accepted();
	    }
	
	    return Session.prototype.receiveRequest.apply(this, [request]);
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  }
	
	};
	
	SIP.InviteClientContext = InviteClientContext;
	
	};


/***/ },
/* 234 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview DTMF
	 */
	
	/**
	 * @class DTMF
	 * @param {SIP.Session} session
	 */
	module.exports = function (SIP) {
	
	var DTMF,
	  C = {
	    MIN_DURATION:            70,
	    MAX_DURATION:            6000,
	    DEFAULT_DURATION:        100,
	    MIN_INTER_TONE_GAP:      50,
	    DEFAULT_INTER_TONE_GAP:  500
	  };
	
	DTMF = function(session, tone, options) {
	  var duration, interToneGap;
	
	  if (tone === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);
	  this.owner = session;
	  this.direction = null;
	
	  options = options || {};
	  duration = options.duration || null;
	  interToneGap = options.interToneGap || null;
	
	  // Check tone type
	  if (typeof tone === 'string' ) {
	    tone = tone.toUpperCase();
	  } else if (typeof tone === 'number') {
	    tone = tone.toString();
	  } else {
	    throw new TypeError('Invalid tone: '+ tone);
	  }
	
	  // Check tone value
	  if (!tone.match(/^[0-9A-D#*]$/)) {
	    throw new TypeError('Invalid tone: '+ tone);
	  } else {
	    this.tone = tone;
	  }
	
	  // Check duration
	  if (duration && !SIP.Utils.isDecimal(duration)) {
	    throw new TypeError('Invalid tone duration: '+ duration);
	  } else if (!duration) {
	    duration = DTMF.C.DEFAULT_DURATION;
	  } else if (duration < DTMF.C.MIN_DURATION) {
	    this.logger.warn('"duration" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');
	    duration = DTMF.C.MIN_DURATION;
	  } else if (duration > DTMF.C.MAX_DURATION) {
	    this.logger.warn('"duration" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');
	    duration = DTMF.C.MAX_DURATION;
	  } else {
	    duration = Math.abs(duration);
	  }
	  this.duration = duration;
	
	  // Check interToneGap
	  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {
	    throw new TypeError('Invalid interToneGap: '+ interToneGap);
	  } else if (!interToneGap) {
	    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;
	  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {
	    this.logger.warn('"interToneGap" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');
	    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;
	  } else {
	    interToneGap = Math.abs(interToneGap);
	  }
	  this.interToneGap = interToneGap;
	};
	DTMF.prototype = Object.create(SIP.EventEmitter.prototype);
	
	
	DTMF.prototype.send = function(options) {
	  var extraHeaders, body;
	
	  this.direction = 'outgoing';
	
	  // Check RTCSession Status
	  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&
	    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {
	    throw new SIP.Exceptions.InvalidStateError(this.owner.status);
	  }
	
	  // Get DTMF options
	  options = options || {};
	  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
	
	  extraHeaders.push('Content-Type: application/dtmf-relay');
	
	  body = "Signal= " + this.tone + "\r\n";
	  body += "Duration= " + this.duration;
	
	  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {
	    extraHeaders: extraHeaders,
	    body: body
	  });
	
	  this.owner.emit('dtmf', this.request, this);
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.receiveResponse = function(response) {
	  var cause;
	
	  switch(true) {
	    case /^1[0-9]{2}$/.test(response.status_code):
	      // Ignore provisional responses.
	      break;
	
	    case /^2[0-9]{2}$/.test(response.status_code):
	      this.emit('succeeded', {
	        originator: 'remote',
	        response: response
	      });
	      break;
	
	    default:
	      cause = SIP.Utils.sipErrorCause(response.status_code);
	      this.emit('failed', response, cause);
	      break;
	  }
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onRequestTimeout = function() {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	  this.owner.onRequestTimeout();
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onTransportError = function() {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	  this.owner.onTransportError();
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onDialogError = function(response) {
	  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);
	  this.owner.onDialogError(response);
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.init_incoming = function(request) {
	  this.direction = 'incoming';
	  this.request = request;
	
	  request.reply(200);
	
	  if (!this.tone || !this.duration) {
	    this.logger.warn('invalid INFO DTMF received, discarded');
	  } else {
	    this.owner.emit('dtmf', request, this);
	  }
	};
	
	DTMF.C = C;
	return DTMF;
	};


/***/ },
/* 235 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP Subscription.
	 */
	module.exports = function (SIP) {
	SIP.Subscription = function (ua, target, event, options) {
	  options = Object.create(options || Object.prototype);
	  this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();
	
	  this.id = null;
	  this.state = 'init';
	
	  if (!event) {
	    throw new TypeError('Event necessary to create a subscription.');
	  } else {
	    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?
	    //The check may need to/should probably occur on the other side,
	    this.event = event;
	  }
	
	  if(typeof options.expires !== 'number'){
	    ua.logger.warn('expires must be a number. Using default of 3600.');
	    this.expires = 3600;
	  } else {
	    this.expires = options.expires;
	  }
	
	  options.extraHeaders.push('Event: ' + this.event);
	  options.extraHeaders.push('Expires: ' + this.expires);
	
	  if (options.body) {
	    this.body = options.body;
	  }
	
	  this.contact = ua.contact.toString();
	
	  options.extraHeaders.push('Contact: '+ this.contact);
	  options.extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);
	
	  this.logger = ua.getLogger('sip.subscription');
	
	  this.dialog = null;
	  this.timers = {N: null, sub_duration: null};
	  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];
	};
	
	SIP.Subscription.prototype = {
	  subscribe: function() {
	    var sub = this;
	
	     //these states point to an existing subscription, no subscribe is necessary
	    if (this.state === 'active') {
	      this.refresh();
	      return this;
	    } else if (this.state === 'notify_wait') {
	      return this;
	    }
	
	    SIP.Timers.clearTimeout(this.timers.sub_duration);
	    SIP.Timers.clearTimeout(this.timers.N);
	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
	
	    this.send();
	
	    this.state = 'notify_wait';
	
	    return this;
	  },
	
	  refresh: function () {
	    if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {
	      return;
	    }
	
	    this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {
	      extraHeaders: this.extraHeaders,
	      body: this.body
	    });
	  },
	
	  receiveResponse: function(response) {
	    var expires, sub = this,
	        cause = SIP.Utils.getReasonPhrase(response.status_code);
	
	    if ((this.state === 'notify_wait' && response.status_code >= 300) ||
	        (this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1)) {
	      this.failed(response, null);
	    } else if (/^2[0-9]{2}$/.test(response.status_code)){
	      expires = response.getHeader('Expires');
	      SIP.Timers.clearTimeout(this.timers.N);
	
	      if (this.createConfirmedDialog(response,'UAC')) {
	        this.id = this.dialog.id.toString();
	        this.ua.subscriptions[this.id] = this;
	        this.emit('accepted', response, cause);
	        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?
	      }
	
	      if (expires && expires <= this.expires) {
	        // Preserve new expires value for subsequent requests
	        this.expires = expires;
	        this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);
	      } else {
	        if (!expires) {
	          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');
	          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);
	        } else {
	          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');
	          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);
	        }
	      }
	    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx
	  },
	
	  unsubscribe: function() {
	    var extraHeaders = [], sub = this;
	
	    this.state = 'terminated';
	
	    extraHeaders.push('Event: ' + this.event);
	    extraHeaders.push('Expires: 0');
	
	    extraHeaders.push('Contact: '+ this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	
	    //makes sure expires isn't set, and other typical resubscribe behavior
	    this.receiveResponse = function(){};
	
	    this.dialog.sendRequest(this, this.method, {
	      extraHeaders: extraHeaders,
	      body: this.body
	    });
	
	    SIP.Timers.clearTimeout(this.timers.sub_duration);
	    SIP.Timers.clearTimeout(this.timers.N);
	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
	  },
	
	  /**
	  * @private
	  */
	  timer_fire: function(){
	    if (this.state === 'terminated') {
	      this.terminateDialog();
	      SIP.Timers.clearTimeout(this.timers.N);
	      SIP.Timers.clearTimeout(this.timers.sub_duration);
	
	      delete this.ua.subscriptions[this.id];
	    } else if (this.state === 'pending' || this.state === 'notify_wait') {
	      this.close();
	    } else {
	      this.refresh();
	    }
	  },
	
	  /**
	  * @private
	  */
	  close: function() {
	    if(this.state !== 'notify_wait' && this.state !== 'terminated') {
	      this.unsubscribe();
	    }
	  },
	
	  /**
	  * @private
	  */
	  createConfirmedDialog: function(message, type) {
	    var dialog;
	
	    this.terminateDialog();
	    dialog = new SIP.Dialog(this, message, type);
	
	    if(!dialog.error) {
	      this.dialog = dialog;
	      return true;
	    }
	    // Dialog not created due to an error
	    else {
	      return false;
	    }
	  },
	
	  /**
	  * @private
	  */
	  terminateDialog: function() {
	    if(this.dialog) {
	      delete this.ua.subscriptions[this.id];
	      this.dialog.terminate();
	      delete this.dialog;
	    }
	  },
	
	  /**
	  * @private
	  */
	  receiveRequest: function(request) {
	    var sub_state, sub = this;
	
	    function setExpiresTimeout() {
	      if (sub_state.expires) {
	        SIP.Timers.clearTimeout(sub.timers.sub_duration);
	        sub_state.expires = Math.min(sub.expires,
	                                     Math.max(sub_state.expires, 0));
	        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub),
	                                                    sub_state.expires * 900);
	      }
	    }
	
	    if (!this.matchEvent(request)) { //checks event and subscription_state headers
	      request.reply(489);
	      return;
	    }
	
	    sub_state = request.parseHeader('Subscription-State');
	
	    request.reply(200, SIP.C.REASON_200);
	
	    SIP.Timers.clearTimeout(this.timers.N);
	
	    this.emit('notify', {request: request});
	
	    // if we've set state to terminated, no further processing should take place
	    // and we are only interested in cleaning up after the appropriate NOTIFY
	    if (this.state === 'terminated') {
	      if (sub_state.state === 'terminated') {
	        this.terminateDialog();
	        SIP.Timers.clearTimeout(this.timers.N);
	        SIP.Timers.clearTimeout(this.timers.sub_duration);
	
	        delete this.ua.subscriptions[this.id];
	      }
	      return;
	    }
	
	    switch (sub_state.state) {
	      case 'active':
	        this.state = 'active';
	        setExpiresTimeout();
	        break;
	      case 'pending':
	        if (this.state === 'notify_wait') {
	          setExpiresTimeout();
	        }
	        this.state = 'pending';
	        break;
	      case 'terminated':
	        SIP.Timers.clearTimeout(this.timers.sub_duration);
	        if (sub_state.reason) {
	          this.logger.log('terminating subscription with reason '+ sub_state.reason);
	          switch (sub_state.reason) {
	            case 'deactivated':
	            case 'timeout':
	              this.subscribe();
	              return;
	            case 'probation':
	            case 'giveup':
	              if(sub_state.params && sub_state.params['retry-after']) {
	                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);
	              } else {
	                this.subscribe();
	              }
	              return;
	            case 'rejected':
	            case 'noresource':
	            case 'invariant':
	              break;
	          }
	        }
	        this.close();
	        break;
	    }
	  },
	
	  failed: function(response, cause) {
	    this.close();
	    this.emit('failed', response, cause);
	    return this;
	  },
	
	  onDialogError: function(response) {
	    this.failed(response, SIP.C.causes.DIALOG_ERROR);
	  },
	
	  /**
	  * @private
	  */
	  matchEvent: function(request) {
	    var event;
	
	    // Check mandatory header Event
	    if (!request.hasHeader('Event')) {
	      this.logger.warn('missing Event header');
	      return false;
	    }
	    // Check mandatory header Subscription-State
	    if (!request.hasHeader('Subscription-State')) {
	      this.logger.warn('missing Subscription-State header');
	      return false;
	    }
	
	    // Check whether the event in NOTIFY matches the event in SUBSCRIBE
	    event = request.parseHeader('event').event;
	
	    if (this.event !== event) {
	      this.logger.warn('event match failed');
	      request.reply(481, 'Event Match Failed');
	      return false;
	    } else {
	      return true;
	    }
	  }
	};
	};


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileoverview WebRTC
	 */
	
	module.exports = function (SIP, environment) {
	var WebRTC;
	
	WebRTC = {};
	
	WebRTC.MediaHandler = __webpack_require__(237)(SIP);
	WebRTC.MediaStreamManager = __webpack_require__(238)(SIP, environment);
	
	var _isSupported;
	
	WebRTC.isSupported = function () {
	  if (_isSupported !== undefined) {
	    return _isSupported;
	  }
	
	  WebRTC.MediaStream = environment.MediaStream;
	  WebRTC.getUserMedia = environment.getUserMedia;
	  WebRTC.RTCPeerConnection = environment.RTCPeerConnection;
	  WebRTC.RTCSessionDescription = environment.RTCSessionDescription;
	
	  if (WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {
	    if (WebRTC.getUserMedia) {
	      WebRTC.getUserMedia = SIP.Utils.promisify(environment, 'getUserMedia');
	    }
	    _isSupported = true;
	  }
	  else {
	    _isSupported = false;
	  }
	  return _isSupported;
	};
	
	return WebRTC;
	};


/***/ },
/* 237 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaHandler
	 */
	
	/* MediaHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]
	 *        The MediaStreamManager to acquire/release streams from/to.
	 *        If not provided, a default MediaStreamManager will be used.
	 */
	module.exports = function (SIP) {
	
	var MediaHandler = function(session, options) {
	  options = options || {};
	
	  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);
	  this.session = session;
	  this.localMedia = null;
	  this.ready = true;
	  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);
	  this.audioMuted = false;
	  this.videoMuted = false;
	
	  // old init() from here on
	  var servers = this.prepareIceServers(options.stunServers, options.turnServers);
	  this.RTCConstraints = options.RTCConstraints || {};
	
	  this.initPeerConnection(servers, this.RTCConstraints);
	
	  function selfEmit(mh, event) {
	    if (mh.mediaStreamManager.on) {
	      mh.mediaStreamManager.on(event, function () {
	        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));
	      });
	    }
	  }
	
	  selfEmit(this, 'userMediaRequest');
	  selfEmit(this, 'userMedia');
	  selfEmit(this, 'userMediaFailed');
	};
	
	MediaHandler.defaultFactory = function defaultFactory (session, options) {
	  return new MediaHandler(session, options);
	};
	MediaHandler.defaultFactory.isSupported = function () {
	  return SIP.WebRTC.isSupported();
	};
	
	MediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {
	// Functions the session can use
	  isReady: {writable: true, value: function isReady () {
	    return this.ready;
	  }},
	
	  close: {writable: true, value: function close () {
	    this.logger.log('closing PeerConnection');
	    this._remoteStreams = [];
	    // have to check signalingState since this.close() gets called multiple times
	    // TODO figure out why that happens
	    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {
	      this.peerConnection.close();
	
	      if(this.localMedia) {
	        this.mediaStreamManager.release(this.localMedia);
	      }
	    }
	  }},
	
	  /**
	   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]
	   *        the MediaStream (or the constraints describing it) to be used for the session
	   */
	  getDescription: {writable: true, value: function getDescription (mediaHint) {
	    var self = this;
	    var acquire = self.mediaStreamManager.acquire;
	    if (acquire.length > 1) {
	      acquire = SIP.Utils.promisify(this.mediaStreamManager, 'acquire', true);
	    }
	    mediaHint = mediaHint || {};
	    if (mediaHint.dataChannel === true) {
	      mediaHint.dataChannel = {};
	    }
	    this.mediaHint = mediaHint;
	
	    /*
	     * 1. acquire streams (skip if MediaStreams passed in)
	     * 2. addStreams
	     * 3. createOffer/createAnswer
	     */
	
	    var streamPromise;
	    if (self.localMedia) {
	      self.logger.log('already have local media');
	      streamPromise = SIP.Utils.Promise.resolve(self.localMedia);
	    }
	    else {
	      self.logger.log('acquiring local media');
	      streamPromise = acquire.call(self.mediaStreamManager, mediaHint)
	        .then(function acquireSucceeded(streams) {
	          self.logger.log('acquired local media streams');
	          self.localMedia = streams;
	          self.session.connecting();
	          return streams;
	        }, function acquireFailed(err) {
	          self.logger.error('unable to acquire streams');
	          self.logger.error(err);
	          self.session.connecting();
	          throw err;
	        })
	        .then(this.addStreams.bind(this))
	      ;
	    }
	
	    return streamPromise
	      .then(function streamAdditionSucceeded() {
	        if (self.hasOffer('remote')) {
	          self.peerConnection.ondatachannel = function (evt) {
	            self.dataChannel = evt.channel;
	            self.emit('dataChannel', self.dataChannel);
	          };
	        } else if (mediaHint.dataChannel &&
	                   self.peerConnection.createDataChannel) {
	          self.dataChannel = self.peerConnection.createDataChannel(
	            'sipjs',
	            mediaHint.dataChannel
	          );
	          self.emit('dataChannel', self.dataChannel);
	        }
	
	        self.render();
	        return self.createOfferOrAnswer(self.RTCConstraints);
	      })
	    ;
	  }},
	
	  /**
	  * Message reception.
	  * @param {String} type
	  * @param {String} sdp
	  */
	  setDescription: {writable: true, value: function setDescription (sdp) {
	    var rawDescription = {
	      type: this.hasOffer('local') ? 'answer' : 'offer',
	      sdp: sdp
	    };
	
	    this.emit('setDescription', rawDescription);
	
	    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);
	    return SIP.Utils.promisify(this.peerConnection, 'setRemoteDescription')(description);
	  }},
	
	  /**
	   * If the Session associated with this MediaHandler were to be referred,
	   * what mediaHint should be provided to the UA's invite method?
	   */
	  getReferMedia: {writable: true, value: function getReferMedia () {
	    function hasTracks (trackGetter, stream) {
	      return stream[trackGetter]().length > 0;
	    }
	
	    function bothHaveTracks (trackGetter) {
	      /* jshint validthis:true */
	      return this.getLocalStreams().some(hasTracks.bind(null, trackGetter)) &&
	             this.getRemoteStreams().some(hasTracks.bind(null, trackGetter));
	    }
	
	    return {
	      constraints: {
	        audio: bothHaveTracks.call(this, 'getAudioTracks'),
	        video: bothHaveTracks.call(this, 'getVideoTracks')
	      }
	    };
	  }},
	
	  updateIceServers: {writeable:true, value: function (options) {
	    var servers = this.prepareIceServers(options.stunServers, options.turnServers);
	    this.RTCConstraints = options.RTCConstraints || this.RTCConstraints;
	
	    this.initPeerConnection(servers, this.RTCConstraints);
	
	    /* once updateIce is implemented correctly, this is better than above
	    //no op if browser does not support this
	    if (!this.peerConnection.updateIce) {
	      return;
	    }
	
	    this.peerConnection.updateIce({'iceServers': servers}, this.RTCConstraints);
	    */
	  }},
	
	// Functions the session can use, but only because it's convenient for the application
	  isMuted: {writable: true, value: function isMuted () {
	    return {
	      audio: this.audioMuted,
	      video: this.videoMuted
	    };
	  }},
	
	  mute: {writable: true, value: function mute (options) {
	    if (this.getLocalStreams().length === 0) {
	      return;
	    }
	
	    options = options || {
	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
	      video: this.getLocalStreams()[0].getVideoTracks().length > 0
	    };
	
	    var audioMuted = false,
	        videoMuted = false;
	
	    if (options.audio && !this.audioMuted) {
	      audioMuted = true;
	      this.audioMuted = true;
	      this.toggleMuteAudio(true);
	    }
	
	    if (options.video && !this.videoMuted) {
	      videoMuted = true;
	      this.videoMuted = true;
	      this.toggleMuteVideo(true);
	    }
	
	    //REVISIT
	    if (audioMuted || videoMuted) {
	      return {
	        audio: audioMuted,
	        video: videoMuted
	      };
	      /*this.session.onmute({
	        audio: audioMuted,
	        video: videoMuted
	      });*/
	    }
	  }},
	
	  unmute: {writable: true, value: function unmute (options) {
	    if (this.getLocalStreams().length === 0) {
	      return;
	    }
	
	    options = options || {
	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
	      video: this.getLocalStreams()[0].getVideoTracks().length > 0
	    };
	
	    var audioUnMuted = false,
	        videoUnMuted = false;
	
	    if (options.audio && this.audioMuted) {
	      audioUnMuted = true;
	      this.audioMuted = false;
	      this.toggleMuteAudio(false);
	    }
	
	    if (options.video && this.videoMuted) {
	      videoUnMuted = true;
	      this.videoMuted = false;
	      this.toggleMuteVideo(false);
	    }
	
	    //REVISIT
	    if (audioUnMuted || videoUnMuted) {
	      return {
	        audio: audioUnMuted,
	        video: videoUnMuted
	      };
	      /*this.session.onunmute({
	        audio: audioUnMuted,
	        video: videoUnMuted
	      });*/
	    }
	  }},
	
	  hold: {writable: true, value: function hold () {
	    this.toggleMuteAudio(true);
	    this.toggleMuteVideo(true);
	  }},
	
	  unhold: {writable: true, value: function unhold () {
	    if (!this.audioMuted) {
	      this.toggleMuteAudio(false);
	    }
	
	    if (!this.videoMuted) {
	      this.toggleMuteVideo(false);
	    }
	  }},
	
	// Functions the application can use, but not the session
	  getLocalStreams: {writable: true, value: function getLocalStreams () {
	    var pc = this.peerConnection;
	    if (pc && pc.signalingState === 'closed') {
	      this.logger.warn('peerConnection is closed, getLocalStreams returning []');
	      return [];
	    }
	    return (pc.getLocalStreams && pc.getLocalStreams()) ||
	      pc.localStreams || [];
	  }},
	
	  getRemoteStreams: {writable: true, value: function getRemoteStreams () {
	    var pc = this.peerConnection;
	    if (pc && pc.signalingState === 'closed') {
	      this.logger.warn('peerConnection is closed, getRemoteStreams returning this._remoteStreams');
	      return this._remoteStreams;
	    }
	    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||
	      pc.remoteStreams || [];
	  }},
	
	  render: {writable: true, value: function render (renderHint) {
	    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);
	    if (!renderHint) {
	      return false;
	    }
	    var streamGetters = {
	      local: 'getLocalStreams',
	      remote: 'getRemoteStreams'
	    };
	    Object.keys(streamGetters).forEach(function (loc) {
	      var streamGetter = streamGetters[loc];
	      var streams = this[streamGetter]();
	      SIP.WebRTC.MediaStreamManager.render(streams, renderHint[loc]);
	    }.bind(this));
	  }},
	
	// Internal functions
	  hasOffer: {writable: true, value: function hasOffer (where) {
	    var offerState = 'have-' + where + '-offer';
	    return this.peerConnection.signalingState === offerState;
	    // TODO consider signalingStates with 'pranswer'?
	  }},
	
	  prepareIceServers: {writable: true, value: function prepareIceServers (stunServers, turnServers) {
	    var servers = [],
	      config = this.session.ua.configuration;
	
	    stunServers = stunServers || config.stunServers;
	    turnServers = turnServers || config.turnServers;
	
	    [].concat(stunServers).forEach(function (server) {
	      servers.push({'urls': server});
	    });
	
	    [].concat(turnServers).forEach(function (server) {
	      servers.push({
	        'urls': server.urls,
	        'username': server.username,
	        'credential': server.password
	      });
	    });
	
	    return servers;
	  }},
	
	  initPeerConnection: {writable: true, value: function initPeerConnection(servers, RTCConstraints) {
	    var self = this,
	      config = this.session.ua.configuration;
	
	    this.onIceCompleted = SIP.Utils.defer();
	    this.onIceCompleted.promise.then(function(pc) {
	      self.emit('iceGatheringComplete', pc);
	      if (self.iceCheckingTimer) {
	        SIP.Timers.clearTimeout(self.iceCheckingTimer);
	        self.iceCheckingTimer = null;
	      }
	    });
	
	    if (this.peerConnection) {
	      this.peerConnection.close();
	    }
	
	    this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers}, RTCConstraints);
	
	    // Firefox (35.0.1) sometimes throws on calls to peerConnection.getRemoteStreams
	    // even if peerConnection.onaddstream was just called. In order to make
	    // MediaHandler.prototype.getRemoteStreams work, keep track of them manually
	    this._remoteStreams = [];
	
	    this.peerConnection.onaddstream = function(e) {
	      self.logger.log('stream added: '+ e.stream.id);
	      self._remoteStreams.push(e.stream);
	      self.render();
	      self.emit('addStream', e);
	    };
	
	    this.peerConnection.onremovestream = function(e) {
	      self.logger.log('stream removed: '+ e.stream.id);
	    };
	
	    this.startIceCheckingTimer = function () {
	      if (!self.iceCheckingTimer) {
	        self.iceCheckingTimer = SIP.Timers.setTimeout(function() {
	          self.logger.log('RTCIceChecking Timeout Triggered after '+config.iceCheckingTimeout+' milliseconds');
	          self.onIceCompleted.resolve(this);
	        }.bind(this.peerConnection), config.iceCheckingTimeout);
	      }
	    };
	
	    this.peerConnection.onicecandidate = function(e) {
	      self.emit('iceCandidate', e);
	      if (e.candidate) {
	        self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));
	        self.startIceCheckingTimer();
	      } else {
	        self.onIceCompleted.resolve(this);
	      }
	    };
	
	    this.peerConnection.onicegatheringstatechange = function () {
	      self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);
	      if (this.iceGatheringState === 'gathering') {
	        self.emit('iceGathering', this);
	      }
	      if (this.iceGatheringState === 'complete') {
	        self.onIceCompleted.resolve(this);
	      }
	    };
	
	    this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case
	      var stateEvent;
	
	      if (this.iceConnectionState === 'checking') {
	        self.startIceCheckingTimer();
	      }
	
	      switch (this.iceConnectionState) {
	      case 'new':
	        stateEvent = 'iceConnection';
	        break;
	      case 'checking':
	        stateEvent = 'iceConnectionChecking';
	        break;
	      case 'connected':
	        stateEvent = 'iceConnectionConnected';
	        break;
	      case 'completed':
	        stateEvent = 'iceConnectionCompleted';
	        break;
	      case 'failed':
	        stateEvent = 'iceConnectionFailed';
	        break;
	      case 'disconnected':
	        stateEvent = 'iceConnectionDisconnected';
	        break;
	      case 'closed':
	        stateEvent = 'iceConnectionClosed';
	        break;
	      default:
	        self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);
	        return;
	      }
	      self.emit(stateEvent, this);
	
	      //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated
	      //normal calls switch from failed to connected in some cases, so checking for failed and terminated
	      /*if (this.iceConnectionState === 'failed') {
	        self.session.terminate({
	        cause: SIP.C.causes.RTP_TIMEOUT,
	        status_code: 200,
	        reason_phrase: SIP.C.causes.RTP_TIMEOUT
	      });
	      } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {
	      self.onIceCompleted(this);
	      }*/
	    };
	
	    this.peerConnection.onstatechange = function() {
	      self.logger.log('PeerConnection state changed to "'+ this.readyState +'"');
	    };
	  }},
	
	  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (constraints) {
	    var self = this;
	    var methodName;
	    var pc = self.peerConnection;
	
	    self.ready = false;
	    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';
	
	    return SIP.Utils.promisify(pc, methodName, true)(constraints)
	      .then(SIP.Utils.promisify(pc, 'setLocalDescription'))
	      .then(function onSetLocalDescriptionSuccess() {
	        var deferred = SIP.Utils.defer();
	        if (pc.iceGatheringState === 'complete' && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed')) {
	          deferred.resolve();
	        } else {
	          self.onIceCompleted.promise.then(deferred.resolve);
	        }
	        return deferred.promise;
	      })
	      .then(function readySuccess () {
	        var sdp = pc.localDescription.sdp;
	
	        sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);
	        sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);
	
	        var sdpWrapper = {
	          type: methodName === 'createOffer' ? 'offer' : 'answer',
	          sdp: sdp
	        };
	
	        self.emit('getDescription', sdpWrapper);
	
	        self.ready = true;
	        return sdpWrapper.sdp;
	      })
	      .catch(function methodFailed (e) {
	        self.logger.error(e);
	        self.ready = true;
	        throw new SIP.Exceptions.GetDescriptionError(e);
	      })
	    ;
	  }},
	
	  addStreams: {writable: true, value: function addStreams (streams) {
	    try {
	      streams = [].concat(streams);
	      streams.forEach(function (stream) {
	        this.peerConnection.addStream(stream);
	      }, this);
	    } catch(e) {
	      this.logger.error('error adding stream');
	      this.logger.error(e);
	      return SIP.Utils.Promise.reject(e);
	    }
	
	    return SIP.Utils.Promise.resolve();
	  }},
	
	  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {
	    this.getLocalStreams().forEach(function (stream) {
	      stream[trackGetter]().forEach(function (track) {
	        track.enabled = !mute;
	      });
	    });
	  }},
	
	  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {
	    this.toggleMuteHelper('getAudioTracks', mute);
	  }},
	
	  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {
	    this.toggleMuteHelper('getVideoTracks', mute);
	  }}
	});
	
	// Return since it will be assigned to a variable.
	return MediaHandler;
	};


/***/ },
/* 238 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaStreamManager
	 */
	
	/* MediaStreamManager
	 * @class Manages the acquisition and release of MediaStreams.
	 * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()
	 */
	module.exports = function (SIP, environment) {
	
	// Default MediaStreamManager provides single-use streams created with getUserMedia
	var MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {
	  if (!SIP.WebRTC.isSupported()) {
	    throw new SIP.Exceptions.NotSupportedError('Media not supported');
	  }
	
	  this.mediaHint = defaultMediaHint || {
	    constraints: {audio: true, video: true}
	  };
	
	  // map of streams to acquisition manner:
	  // true -> passed in as mediaHint.stream
	  // false -> getUserMedia
	  this.acquisitions = {};
	};
	MediaStreamManager.streamId = function (stream) {
	  return stream.getAudioTracks().concat(stream.getVideoTracks())
	    .map(function trackId (track) {
	      return track.id;
	    })
	    .join('');
	};
	
	/**
	 * @param {(Array of) MediaStream} streams - The streams to render
	 *
	 * @param {(Array of) HTMLMediaElement} elements
	 *        - The <audio>/<video> element(s) that should render the streams
	 *
	 * Each stream in streams renders to the corresponding element in elements,
	 * wrapping around elements if needed.
	 */
	MediaStreamManager.render = function render (streams, elements) {
	  if (!elements) {
	    return false;
	  }
	  if (Array.isArray(elements) && !elements.length) {
	    throw new TypeError('elements must not be empty');
	  }
	
	  function attachMediaStream(element, stream) {
	    if (typeof element.src !== 'undefined') {
	      environment.revokeObjectURL(element.src);
	      element.src = environment.createObjectURL(stream);
	    } else if (typeof (element.srcObject || element.mozSrcObject) !== 'undefined') {
	      element.srcObject = element.mozSrcObject = stream;
	    } else {
	      return false;
	    }
	
	    return true;
	  }
	
	  function ensureMediaPlaying (mediaElement) {
	    var interval = 100;
	    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {
	      if (mediaElement.paused) {
	        mediaElement.play();
	      }
	      else {
	        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);
	      }
	    }, interval);
	  }
	
	  function attachAndPlay (elements, stream, index) {
	    if (typeof elements === 'function') {
	      elements = elements();
	    }
	    var element = elements[index % elements.length];
	    (environment.attachMediaStream || attachMediaStream)(element, stream);
	    ensureMediaPlaying(element);
	  }
	
	  // [].concat "casts" `elements` into an array
	  // so forEach works even if `elements` was a single element
	  elements = [].concat(elements);
	  [].concat(streams).forEach(attachAndPlay.bind(null, elements));
	};
	
	MediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {
	  'acquire': {writable: true, value: function acquire (mediaHint) {
	    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;
	
	    var saveSuccess = function (isHintStream, streams) {
	      streams = [].concat(streams);
	      streams.forEach(function (stream) {
	        var streamId = MediaStreamManager.streamId(stream);
	        this.acquisitions[streamId] = !!isHintStream;
	      }, this);
	      return SIP.Utils.Promise.resolve(streams);
	    }.bind(this);
	
	    if (mediaHint.stream) {
	      return saveSuccess(true, mediaHint.stream);
	    } else {
	      // Fallback to audio/video enabled if no mediaHint can be found.
	      var constraints = mediaHint.constraints ||
	        (this.mediaHint && this.mediaHint.constraints) ||
	        {audio: true, video: true};
	
	      var deferred = SIP.Utils.defer();
	
	      /*
	       * Make the call asynchronous, so that ICCs have a chance
	       * to define callbacks to `userMediaRequest`
	       */
	      SIP.Timers.setTimeout(function () {
	        this.emit('userMediaRequest', constraints);
	
	        var emitThenCall = function (eventName, callback) {
	          var callbackArgs = Array.prototype.slice.call(arguments, 2);
	          // Emit with all of the arguments from the real callback.
	          var newArgs = [eventName].concat(callbackArgs);
	
	          this.emit.apply(this, newArgs);
	
	          return callback.apply(null, callbackArgs);
	        }.bind(this);
	
	        if (constraints.audio || constraints.video) {
	          deferred.resolve(
	            SIP.WebRTC.getUserMedia(constraints)
	            .then(
	              emitThenCall.bind(this, 'userMedia', saveSuccess.bind(null, false)),
	              emitThenCall.bind(this, 'userMediaFailed', function(e){throw e;})
	            )
	          );
	        } else {
	          // Local streams were explicitly excluded.
	          deferred.resolve([]);
	        }
	      }.bind(this), 0);
	
	      return deferred.promise;
	    }
	  }},
	
	  'release': {writable: true, value: function release (streams) {
	    streams = [].concat(streams);
	    streams.forEach(function (stream) {
	      var streamId = MediaStreamManager.streamId(stream);
	      if (this.acquisitions[streamId] === false) {
	        stream.getTracks().forEach(function (track) {
	          track.stop();
	        });
	      }
	      delete this.acquisitions[streamId];
	    }, this);
	  }},
	});
	
	// Return since it will be assigned to a variable.
	return MediaStreamManager;
	};


/***/ },
/* 239 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * @augments SIP
	 * @class Class creating a SIP User Agent.
	 * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]
	 *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.
	 *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.
	 *
	 * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	 */
	module.exports = function (SIP, environment) {
	var UA,
	  C = {
	    // UA status codes
	    STATUS_INIT:                0,
	    STATUS_STARTING:            1,
	    STATUS_READY:               2,
	    STATUS_USER_CLOSED:         3,
	    STATUS_NOT_READY:           4,
	
	    // UA error codes
	    CONFIGURATION_ERROR:  1,
	    NETWORK_ERROR:        2,
	
	    ALLOWED_METHODS: [
	      'ACK',
	      'CANCEL',
	      'INVITE',
	      'MESSAGE',
	      'BYE',
	      'OPTIONS',
	      'INFO',
	      'NOTIFY',
	      'REFER'
	    ],
	
	    ACCEPTED_BODY_TYPES: [
	      'application/sdp',
	      'application/dtmf-relay'
	    ],
	
	    MAX_FORWARDS: 70,
	    TAG_LENGTH: 10
	  };
	
	UA = function(configuration) {
	  var self = this;
	
	  // Helper function for forwarding events
	  function selfEmit(type) {
	    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments
	    return self.emit.bind(self, type);
	  }
	
	  // Set Accepted Body Types
	  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();
	
	  this.log = new SIP.LoggerFactory();
	  this.logger = this.getLogger('sip.ua');
	
	  this.cache = {
	    credentials: {}
	  };
	
	  this.configuration = {};
	  this.dialogs = {};
	
	  //User actions outside any session/dialog (MESSAGE)
	  this.applicants = {};
	
	  this.data = {};
	  this.sessions = {};
	  this.subscriptions = {};
	  this.transport = null;
	  this.contact = null;
	  this.status = C.STATUS_INIT;
	  this.error = null;
	  this.transactions = {
	    nist: {},
	    nict: {},
	    ist: {},
	    ict: {}
	  };
	
	  this.transportRecoverAttempts = 0;
	  this.transportRecoveryTimer = null;
	
	  Object.defineProperties(this, {
	    transactionsCount: {
	      get: function() {
	        var type,
	          transactions = ['nist','nict','ist','ict'],
	          count = 0;
	
	        for (type in transactions) {
	          count += Object.keys(this.transactions[transactions[type]]).length;
	        }
	
	        return count;
	      }
	    },
	
	    nictTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['nict']).length;
	      }
	    },
	
	    nistTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['nist']).length;
	      }
	    },
	
	    ictTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['ict']).length;
	      }
	    },
	
	    istTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['ist']).length;
	      }
	    }
	  });
	
	  /**
	   * Load configuration
	   *
	   * @throws {SIP.Exceptions.ConfigurationError}
	   * @throws {TypeError}
	   */
	
	  if(configuration === undefined) {
	    configuration = {};
	  } else if (typeof configuration === 'string' || configuration instanceof String) {
	    configuration = {
	      uri: configuration
	    };
	  }
	
	  // Apply log configuration if present
	  if (configuration.log) {
	    if (configuration.log.hasOwnProperty('builtinEnabled')) {
	      this.log.builtinEnabled = configuration.log.builtinEnabled;
	    }
	
	    if (configuration.log.hasOwnProperty('level')) {
	      this.log.level = configuration.log.level;
	    }
	
	    if (configuration.log.hasOwnProperty('connector')) {
	      this.log.connector = configuration.log.connector;
	    }
	  }
	
	  try {
	    this.loadConfig(configuration);
	  } catch(e) {
	    this.status = C.STATUS_NOT_READY;
	    this.error = C.CONFIGURATION_ERROR;
	    throw e;
	  }
	
	  // Initialize registerContext
	  this.registerContext = new SIP.RegisterContext(this);
	  this.registerContext.on('failed', selfEmit('registrationFailed'));
	  this.registerContext.on('registered', selfEmit('registered'));
	  this.registerContext.on('unregistered', selfEmit('unregistered'));
	
	  if(this.configuration.autostart) {
	    this.start();
	  }
	
	  if (typeof environment.addEventListener === 'function') {
	    // Google Chrome Packaged Apps don't allow 'unload' listeners:
	    // unload is not available in packaged apps
	    if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {
	      environment.addEventListener('unload', this.stop.bind(this));
	    }
	  }
	};
	UA.prototype = Object.create(SIP.EventEmitter.prototype);
	
	//=================
	//  High Level API
	//=================
	
	UA.prototype.register = function(options) {
	  this.configuration.register = true;
	  this.registerContext.register(options);
	
	  return this;
	};
	
	/**
	 * Unregister.
	 *
	 * @param {Boolean} [all] unregister all user bindings.
	 *
	 */
	UA.prototype.unregister = function(options) {
	  this.configuration.register = false;
	
	  var context = this.registerContext;
	  this.afterConnected(context.unregister.bind(context, options));
	
	  return this;
	};
	
	UA.prototype.isRegistered = function() {
	  return this.registerContext.registered;
	};
	
	/**
	 * Connection state.
	 * @param {Boolean}
	 */
	UA.prototype.isConnected = function() {
	  return this.transport ? this.transport.connected : false;
	};
	
	UA.prototype.afterConnected = function afterConnected (callback) {
	  if (this.isConnected()) {
	    callback();
	  } else {
	    this.once('connected', callback);
	  }
	};
	
	/**
	 * Make an outgoing call.
	 *
	 * @param {String} target
	 * @param {Object} views
	 * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	 *
	 * @throws {TypeError}
	 *
	 */
	UA.prototype.invite = function(target, options) {
	  var context = new SIP.InviteClientContext(this, target, options);
	
	  this.afterConnected(context.invite.bind(context));
	  return context;
	};
	
	UA.prototype.subscribe = function(target, event, options) {
	  var sub = new SIP.Subscription(this, target, event, options);
	
	  this.afterConnected(sub.subscribe.bind(sub));
	  return sub;
	};
	
	/**
	 * Send a message.
	 *
	 * @param {String} target
	 * @param {String} body
	 * @param {Object} [options]
	 *
	 * @throws {TypeError}
	 *
	 */
	UA.prototype.message = function(target, body, options) {
	  if (body === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  // There is no Message module, so it is okay that the UA handles defaults here.
	  options = Object.create(options || Object.prototype);
	  options.contentType || (options.contentType = 'text/plain');
	  options.body = body;
	
	  return this.request(SIP.C.MESSAGE, target, options);
	};
	
	UA.prototype.request = function (method, target, options) {
	  var req = new SIP.ClientContext(this, method, target, options);
	
	  this.afterConnected(req.send.bind(req));
	  return req;
	};
	
	/**
	 * Gracefully close.
	 *
	 */
	UA.prototype.stop = function() {
	  var session, subscription, applicant,
	    ua = this;
	
	  function transactionsListener() {
	    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {
	        ua.removeListener('transactionDestroyed', transactionsListener);
	        ua.transport.disconnect();
	    }
	  }
	
	  this.logger.log('user requested closure...');
	
	  if(this.status === C.STATUS_USER_CLOSED) {
	    this.logger.warn('UA already closed');
	    return this;
	  }
	
	  // Clear transportRecoveryTimer
	  SIP.Timers.clearTimeout(this.transportRecoveryTimer);
	
	  // Close registerContext
	  this.logger.log('closing registerContext');
	  this.registerContext.close();
	
	  // Run  _terminate_ on every Session
	  for(session in this.sessions) {
	    this.logger.log('closing session ' + session);
	    this.sessions[session].terminate();
	  }
	
	  //Run _close_ on every Subscription
	  for(subscription in this.subscriptions) {
	    this.logger.log('unsubscribing from subscription ' + subscription);
	    this.subscriptions[subscription].close();
	  }
	
	  // Run  _close_ on every applicant
	  for(applicant in this.applicants) {
	    this.applicants[applicant].close();
	  }
	
	  this.status = C.STATUS_USER_CLOSED;
	
	  /*
	   * If the remaining transactions are all INVITE transactions, there is no need to
	   * wait anymore because every session has already been closed by this method.
	   * - locally originated sessions where terminated (CANCEL or BYE)
	   * - remotely originated sessions where rejected (4XX) or terminated (BYE)
	   * Remaining INVITE transactions belong tho sessions that where answered. This are in
	   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]
	   */
	  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {
	    this.transport.disconnect();
	  } else {
	    this.on('transactionDestroyed', transactionsListener);
	  }
	
	  return this;
	};
	
	/**
	 * Connect to the WS server if status = STATUS_INIT.
	 * Resume UA after being closed.
	 *
	 */
	UA.prototype.start = function() {
	  var server;
	
	  this.logger.log('user requested startup...');
	  if (this.status === C.STATUS_INIT) {
	    server = this.getNextWsServer();
	    this.status = C.STATUS_STARTING;
	    new SIP.Transport(this, server);
	  } else if(this.status === C.STATUS_USER_CLOSED) {
	    this.logger.log('resuming');
	    this.status = C.STATUS_READY;
	    this.transport.connect();
	  } else if (this.status === C.STATUS_STARTING) {
	    this.logger.log('UA is in STARTING status, not opening new connection');
	  } else if (this.status === C.STATUS_READY) {
	    this.logger.log('UA is in READY status, not resuming');
	  } else {
	    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');
	  }
	
	  return this;
	};
	
	/**
	 * Normalize a string into a valid SIP request URI
	 *
	 * @param {String} target
	 *
	 * @returns {SIP.URI|undefined}
	 */
	UA.prototype.normalizeTarget = function(target) {
	  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);
	};
	
	
	//===============================
	//  Private (For internal use)
	//===============================
	
	UA.prototype.saveCredentials = function(credentials) {
	  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};
	  this.cache.credentials[credentials.realm][credentials.uri] = credentials;
	
	  return this;
	};
	
	UA.prototype.getCredentials = function(request) {
	  var realm, credentials;
	
	  realm = request.ruri.host;
	
	  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {
	    credentials = this.cache.credentials[realm][request.ruri];
	    credentials.method = request.method;
	  }
	
	  return credentials;
	};
	
	UA.prototype.getLogger = function(category, label) {
	  return this.log.getLogger(category, label);
	};
	
	
	//==============================
	// Event Handlers
	//==============================
	
	/**
	 * Transport Close event
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportClosed = function(transport) {
	  // Run _onTransportError_ callback on every client transaction using _transport_
	  var type, idx, length,
	    client_transactions = ['nict', 'ict', 'nist', 'ist'];
	
	  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;
	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);
	
	  length = client_transactions.length;
	  for (type = 0; type < length; type++) {
	    for(idx in this.transactions[client_transactions[type]]) {
	      this.transactions[client_transactions[type]][idx].onTransportError();
	    }
	  }
	
	  // Close sessions if GRUU is not being used
	  if (!this.contact.pub_gruu) {
	    this.closeSessionsOnTransportError();
	  }
	
	};
	
	/**
	 * Unrecoverable transport event.
	 * Connection reattempt logic has been done and didn't success.
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportError = function(transport) {
	  var server;
	
	  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);
	
	  // Close sessions.
	  //Mark this transport as 'down'
	  transport.server.status = SIP.Transport.C.STATUS_ERROR;
	
	  this.emit('disconnected', {
	    transport: transport
	  });
	
	  // try the next transport if the UA isn't closed
	  if(this.status === C.STATUS_USER_CLOSED) {
	    return;
	  }
	
	  server = this.getNextWsServer();
	
	  if(server) {
	    new SIP.Transport(this, server);
	  }else {
	    this.closeSessionsOnTransportError();
	    if (!this.error || this.error !== C.NETWORK_ERROR) {
	      this.status = C.STATUS_NOT_READY;
	      this.error = C.NETWORK_ERROR;
	    }
	    // Transport Recovery process
	    this.recoverTransport();
	  }
	};
	
	/**
	 * Transport connection event.
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportConnected = function(transport) {
	  this.transport = transport;
	
	  // Reset transport recovery counter
	  this.transportRecoverAttempts = 0;
	
	  transport.server.status = SIP.Transport.C.STATUS_READY;
	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);
	
	  if(this.status === C.STATUS_USER_CLOSED) {
	    return;
	  }
	
	  this.status = C.STATUS_READY;
	  this.error = null;
	
	  if(this.configuration.register) {
	    this.configuration.authenticationFactory.initialize().then(function () {
	      this.registerContext.onTransportConnected();
	    }.bind(this));
	  }
	
	  this.emit('connected', {
	    transport: transport
	  });
	};
	
	
	/**
	 * Transport connecting event
	 * @private
	 * @param {SIP.Transport} transport.
	 * #param {Integer} attempts.
	 */
	  UA.prototype.onTransportConnecting = function(transport, attempts) {
	    this.emit('connecting', {
	      transport: transport,
	      attempts: attempts
	    });
	  };
	
	
	/**
	 * new Transaction
	 * @private
	 * @param {SIP.Transaction} transaction.
	 */
	UA.prototype.newTransaction = function(transaction) {
	  this.transactions[transaction.type][transaction.id] = transaction;
	  this.emit('newTransaction', {transaction: transaction});
	};
	
	
	/**
	 * destroy Transaction
	 * @private
	 * @param {SIP.Transaction} transaction.
	 */
	UA.prototype.destroyTransaction = function(transaction) {
	  delete this.transactions[transaction.type][transaction.id];
	  this.emit('transactionDestroyed', {
	    transaction: transaction
	  });
	};
	
	
	//=========================
	// receiveRequest
	//=========================
	
	/**
	 * Request reception
	 * @private
	 * @param {SIP.IncomingRequest} request.
	 */
	UA.prototype.receiveRequest = function(request) {
	  var dialog, session, message,
	    method = request.method,
	    transaction,
	    replaces,
	    replacedDialog,
	    self = this;
	
	  function ruriMatches (uri) {
	    return uri && uri.user === request.ruri.user;
	  }
	
	  // Check that request URI points to us
	  if(!(ruriMatches(this.configuration.uri) ||
	       ruriMatches(this.contact.uri) ||
	       ruriMatches(this.contact.pub_gruu) ||
	       ruriMatches(this.contact.temp_gruu))) {
	    this.logger.warn('Request-URI does not point to us');
	    if (request.method !== SIP.C.ACK) {
	      request.reply_sl(404);
	    }
	    return;
	  }
	
	  // Check request URI scheme
	  if(request.ruri.scheme === SIP.C.SIPS) {
	    request.reply_sl(416);
	    return;
	  }
	
	  // Check transaction
	  if(SIP.Transactions.checkTransaction(this, request)) {
	    return;
	  }
	
	  /* RFC3261 12.2.2
	   * Requests that do not change in any way the state of a dialog may be
	   * received within a dialog (for example, an OPTIONS request).
	   * They are processed as if they had been received outside the dialog.
	   */
	  if(method === SIP.C.OPTIONS) {
	    new SIP.Transactions.NonInviteServerTransaction(request, this);
	    request.reply(200, null, [
	      'Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString(),
	      'Accept: '+ C.ACCEPTED_BODY_TYPES
	    ]);
	  } else if (method === SIP.C.MESSAGE) {
	    message = new SIP.ServerContext(this, request);
	    message.body = request.body;
	    message.content_type = request.getHeader('Content-Type') || 'text/plain';
	
	    request.reply(200, null);
	    this.emit('message', message);
	  } else if (method !== SIP.C.INVITE &&
	             method !== SIP.C.ACK) {
	    // Let those methods pass through to normal processing for now.
	    transaction = new SIP.ServerContext(this, request);
	  }
	
	  // Initial Request
	  if(!request.to_tag) {
	    switch(method) {
	      case SIP.C.INVITE:
	        replaces =
	          this.configuration.replaces !== SIP.C.supported.UNSUPPORTED &&
	          request.parseHeader('replaces');
	
	        if (replaces) {
	          replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];
	
	          if (!replacedDialog) {
	            //Replaced header without a matching dialog, reject
	            request.reply_sl(481, null);
	            return;
	          } else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {
	            request.reply_sl(603, null);
	            return;
	          } else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {
	            request.reply_sl(486, null);
	            return;
	          }
	        }
	
	        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;
	        if(!isMediaSupported || isMediaSupported()) {
	          session = new SIP.InviteServerContext(this, request);
	          session.replacee = replacedDialog && replacedDialog.owner;
	          session.on('invite', function() {
	            self.emit('invite', this);
	          });
	        } else {
	          this.logger.warn('INVITE received but WebRTC is not supported');
	          request.reply(488);
	        }
	        break;
	      case SIP.C.BYE:
	        // Out of dialog BYE received
	        request.reply(481);
	        break;
	      case SIP.C.CANCEL:
	        session = this.findSession(request);
	        if(session) {
	          session.receiveRequest(request);
	        } else {
	          this.logger.warn('received CANCEL request for a non existent session');
	        }
	        break;
	      case SIP.C.ACK:
	        /* Absorb it.
	         * ACK request without a corresponding Invite Transaction
	         * and without To tag.
	         */
	        break;
	      default:
	        request.reply(405);
	        break;
	    }
	  }
	  // In-dialog request
	  else {
	    dialog = this.findDialog(request);
	
	    if(dialog) {
	      if (method === SIP.C.INVITE) {
	        new SIP.Transactions.InviteServerTransaction(request, this);
	      }
	      dialog.receiveRequest(request);
	    } else if (method === SIP.C.NOTIFY) {
	      session = this.findSession(request);
	      if(session) {
	        session.receiveRequest(request);
	      } else {
	        this.logger.warn('received NOTIFY request for a non existent session');
	        request.reply(481, 'Subscription does not exist');
	      }
	    }
	    /* RFC3261 12.2.2
	     * Request with to tag, but no matching dialog found.
	     * Exception: ACK for an Invite request for which a dialog has not
	     * been created.
	     */
	    else {
	      if(method !== SIP.C.ACK) {
	        request.reply(481);
	      }
	    }
	  }
	};
	
	//=================
	// Utils
	//=================
	
	/**
	 * Get the session to which the request belongs to, if any.
	 * @private
	 * @param {SIP.IncomingRequest} request.
	 * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}
	 */
	UA.prototype.findSession = function(request) {
	  return this.sessions[request.call_id + request.from_tag] ||
	          this.sessions[request.call_id + request.to_tag] ||
	          null;
	};
	
	/**
	 * Get the dialog to which the request belongs to, if any.
	 * @private
	 * @param {SIP.IncomingRequest}
	 * @returns {SIP.Dialog|null}
	 */
	UA.prototype.findDialog = function(request) {
	  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||
	          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||
	          null;
	};
	
	/**
	 * Retrieve the next server to which connect.
	 * @private
	 * @returns {Object} ws_server
	 */
	UA.prototype.getNextWsServer = function() {
	  // Order servers by weight
	  var idx, length, ws_server,
	    candidates = [];
	
	  length = this.configuration.wsServers.length;
	  for (idx = 0; idx < length; idx++) {
	    ws_server = this.configuration.wsServers[idx];
	
	    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {
	      continue;
	    } else if (candidates.length === 0) {
	      candidates.push(ws_server);
	    } else if (ws_server.weight > candidates[0].weight) {
	      candidates = [ws_server];
	    } else if (ws_server.weight === candidates[0].weight) {
	      candidates.push(ws_server);
	    }
	  }
	
	  idx = Math.floor(Math.random() * candidates.length);
	
	  return candidates[idx];
	};
	
	/**
	 * Close all sessions on transport error.
	 * @private
	 */
	UA.prototype.closeSessionsOnTransportError = function() {
	  var idx;
	
	  // Run _transportError_ for every Session
	  for(idx in this.sessions) {
	    this.sessions[idx].onTransportError();
	  }
	  // Call registerContext _onTransportClosed_
	  this.registerContext.onTransportClosed();
	};
	
	UA.prototype.recoverTransport = function(ua) {
	  var idx, length, k, nextRetry, count, server;
	
	  ua = ua || this;
	  count = ua.transportRecoverAttempts;
	
	  length = ua.configuration.wsServers.length;
	  for (idx = 0; idx < length; idx++) {
	    ua.configuration.wsServers[idx].status = 0;
	  }
	
	  server = ua.getNextWsServer();
	
	  k = Math.floor((Math.random() * Math.pow(2,count)) +1);
	  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;
	
	  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {
	    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');
	    nextRetry = ua.configuration.connectionRecoveryMinInterval;
	    count = 0;
	  }
	
	  this.logger.log('next connection attempt in '+ nextRetry +' seconds');
	
	  this.transportRecoveryTimer = SIP.Timers.setTimeout(
	    function(){
	      ua.transportRecoverAttempts = count + 1;
	      new SIP.Transport(ua, server);
	    }, nextRetry * 1000);
	};
	
	function checkAuthenticationFactory (authenticationFactory) {
	  if (!(authenticationFactory instanceof Function)) {
	    return;
	  }
	  if (!authenticationFactory.initialize) {
	    authenticationFactory.initialize = function initialize () {
	      return SIP.Utils.Promise.resolve();
	    };
	  }
	  return authenticationFactory;
	}
	
	/**
	 * Configuration load.
	 * @private
	 * returns {Boolean}
	 */
	UA.prototype.loadConfig = function(configuration) {
	  // Settings and default values
	  var parameter, value, checked_value, hostportParams, registrarServer,
	    settings = {
	      /* Host address
	      * Value to be set in Via sent_by and host part of Contact FQDN
	      */
	      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',
	
	      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),
	      wsServers: [{
	        scheme: 'WSS',
	        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',
	        status: 0,
	        weight: 0,
	        ws_uri: 'wss://edge.sip.onsip.com'
	      }],
	
	      // Password
	      password: null,
	
	      // Registration parameters
	      registerExpires: 600,
	      register: true,
	      registrarServer: null,
	
	      // Transport related parameters
	      wsServerMaxReconnection: 3,
	      wsServerReconnectionTimeout: 4,
	
	      connectionRecoveryMinInterval: 2,
	      connectionRecoveryMaxInterval: 30,
	
	      keepAliveInterval: 0,
	
	      extraSupported: [],
	
	      usePreloadedRoute: false,
	
	      //string to be inserted into User-Agent request header
	      userAgentString: SIP.C.USER_AGENT,
	
	      // Session parameters
	      iceCheckingTimeout: 5000,
	      noAnswerTimeout: 60,
	      stunServers: ['stun:stun.l.google.com:19302'],
	      turnServers: [],
	
	      // Logging parameters
	      traceSip: false,
	
	      // Hacks
	      hackViaTcp: false,
	      hackIpInContact: false,
	      hackWssInTransport: false,
	      hackAllowUnregisteredOptionTags: false,
	
	      contactTransport: 'ws',
	      forceRport: false,
	
	      //autostarting
	      autostart: true,
	
	      //Reliable Provisional Responses
	      rel100: SIP.C.supported.UNSUPPORTED,
	
	      // Replaces header (RFC 3891)
	      // http://tools.ietf.org/html/rfc3891
	      replaces: SIP.C.supported.UNSUPPORTED,
	
	      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory,
	
	      authenticationFactory: checkAuthenticationFactory(function authenticationFactory (ua) {
	        return new SIP.DigestAuthentication(ua);
	      })
	    };
	
	  // Pre-Configuration
	  function aliasUnderscored (parameter, logger) {
	    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {
	      return m[0] + '_' + m[1].toLowerCase();
	    });
	
	    if (parameter === underscored) {
	      return;
	    }
	
	    var hasParameter = configuration.hasOwnProperty(parameter);
	    if (configuration.hasOwnProperty(underscored)) {
	      logger.warn(underscored + ' is deprecated, please use ' + parameter);
	      if (hasParameter) {
	        logger.warn(parameter + ' overriding ' + underscored);
	      }
	    }
	
	    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];
	  }
	
	  // Check Mandatory parameters
	  for(parameter in UA.configuration_check.mandatory) {
	    aliasUnderscored(parameter, this.logger);
	    if(!configuration.hasOwnProperty(parameter)) {
	      throw new SIP.Exceptions.ConfigurationError(parameter);
	    } else {
	      value = configuration[parameter];
	      checked_value = UA.configuration_check.mandatory[parameter](value);
	      if (checked_value !== undefined) {
	        settings[parameter] = checked_value;
	      } else {
	        throw new SIP.Exceptions.ConfigurationError(parameter, value);
	      }
	    }
	  }
	
	  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);
	
	  var emptyArraysAllowed = ['stunServers', 'turnServers'];
	
	  // Check Optional parameters
	  for(parameter in UA.configuration_check.optional) {
	    aliasUnderscored(parameter, this.logger);
	    if(configuration.hasOwnProperty(parameter)) {
	      value = configuration[parameter];
	
	      // If the parameter value is an empty array, but shouldn't be, apply its default value.
	      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }
	
	      // If the parameter value is null, empty string, or undefined then apply its default value.
	      if(value === null || value === "" || value === undefined) { continue; }
	      // If it's a number with NaN value then also apply its default value.
	      // NOTE: JS does not allow "value === NaN", the following does the work:
	      else if(typeof(value) === 'number' && isNaN(value)) { continue; }
	
	      checked_value = UA.configuration_check.optional[parameter](value);
	      if (checked_value !== undefined) {
	        settings[parameter] = checked_value;
	      } else {
	        throw new SIP.Exceptions.ConfigurationError(parameter, value);
	      }
	    }
	  }
	
	  // Sanity Checks
	
	  // Connection recovery intervals
	  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {
	    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);
	  }
	
	  // Post Configuration Process
	
	  // Allow passing 0 number as displayName.
	  if (settings.displayName === 0) {
	    settings.displayName = '0';
	  }
	
	  // Instance-id for GRUU
	  if (!settings.instanceId) {
	    settings.instanceId = SIP.Utils.newUUID();
	  }
	
	  // sipjsId instance parameter. Static random tag of length 5
	  settings.sipjsId = SIP.Utils.createRandomToken(5);
	
	  // String containing settings.uri without scheme and user.
	  hostportParams = settings.uri.clone();
	  hostportParams.user = null;
	  settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');
	
	  /* Check whether authorizationUser is explicitly defined.
	   * Take 'settings.uri.user' value if not.
	   */
	  if (!settings.authorizationUser) {
	    settings.authorizationUser = settings.uri.user;
	  }
	
	  /* If no 'registrarServer' is set use the 'uri' value without user portion. */
	  if (!settings.registrarServer) {
	    registrarServer = settings.uri.clone();
	    registrarServer.user = null;
	    settings.registrarServer = registrarServer;
	  }
	
	  // User noAnswerTimeout
	  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;
	
	  // Via Host
	  if (settings.hackIpInContact) {
	    if (typeof settings.hackIpInContact === 'boolean') {
	      settings.viaHost = SIP.Utils.getRandomTestNetIP();
	    }
	    else if (typeof settings.hackIpInContact === 'string') {
	      settings.viaHost = settings.hackIpInContact;
	    }
	  }
	
	  // Contact transport parameter
	  if (settings.hackWssInTransport) {
	    settings.contactTransport = 'wss';
	  }
	
	  this.contact = {
	    pub_gruu: null,
	    temp_gruu: null,
	    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: settings.contactTransport}),
	    toString: function(options){
	      options = options || {};
	
	      var
	        anonymous = options.anonymous || null,
	        outbound = options.outbound || null,
	        contact = '<';
	
	      if (anonymous) {
	        contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport='+settings.contactTransport)).toString();
	      } else {
	        contact += (this.pub_gruu || this.uri).toString();
	      }
	
	      if (outbound) {
	        contact += ';ob';
	      }
	
	      contact += '>';
	
	      return contact;
	    }
	  };
	
	  // media overrides mediaConstraints
	  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);
	
	  // Fill the value of the configuration_skeleton
	  for(parameter in settings) {
	    UA.configuration_skeleton[parameter].value = settings[parameter];
	  }
	
	  Object.defineProperties(this.configuration, UA.configuration_skeleton);
	
	  // Clean UA.configuration_skeleton
	  for(parameter in settings) {
	    UA.configuration_skeleton[parameter].value = '';
	  }
	
	  this.logger.log('configuration parameters after validation:');
	  for(parameter in settings) {
	    switch(parameter) {
	      case 'uri':
	      case 'registrarServer':
	      case 'mediaHandlerFactory':
	        this.logger.log('· ' + parameter + ': ' + settings[parameter]);
	        break;
	      case 'password':
	        this.logger.log('· ' + parameter + ': ' + 'NOT SHOWN');
	        break;
	      default:
	        this.logger.log('· ' + parameter + ': ' + JSON.stringify(settings[parameter]));
	    }
	  }
	
	  return;
	};
	
	/**
	 * Configuration Object skeleton.
	 * @private
	 */
	UA.configuration_skeleton = (function() {
	  var idx,  parameter,
	    skeleton = {},
	    parameters = [
	      // Internal parameters
	      "sipjsId",
	      "hostportParams",
	
	      // Optional user configurable parameters
	      "uri",
	      "wsServers",
	      "authorizationUser",
	      "connectionRecoveryMaxInterval",
	      "connectionRecoveryMinInterval",
	      "keepAliveInterval",
	      "extraSupported",
	      "displayName",
	      "hackViaTcp", // false.
	      "hackIpInContact", //false
	      "hackWssInTransport", //false
	      "hackAllowUnregisteredOptionTags", //false
	      "contactTransport", // 'ws'
	      "forceRport", // false
	      "iceCheckingTimeout",
	      "instanceId",
	      "noAnswerTimeout", // 30 seconds.
	      "password",
	      "registerExpires", // 600 seconds.
	      "registrarServer",
	      "reliable",
	      "rel100",
	      "replaces",
	      "userAgentString", //SIP.C.USER_AGENT
	      "autostart",
	      "stunServers",
	      "traceSip",
	      "turnServers",
	      "usePreloadedRoute",
	      "wsServerMaxReconnection",
	      "wsServerReconnectionTimeout",
	      "mediaHandlerFactory",
	      "media",
	      "mediaConstraints",
	      "authenticationFactory",
	
	      // Post-configuration generated parameters
	      "via_core_value",
	      "viaHost"
	    ];
	
	  for(idx in parameters) {
	    parameter = parameters[idx];
	    skeleton[parameter] = {
	      value: '',
	      writable: false,
	      configurable: false
	    };
	  }
	
	  skeleton['register'] = {
	    value: '',
	    writable: true,
	    configurable: false
	  };
	
	  return skeleton;
	}());
	
	/**
	 * Configuration checker.
	 * @private
	 * @return {Boolean}
	 */
	UA.configuration_check = {
	  mandatory: {
	  },
	
	  optional: {
	
	    uri: function(uri) {
	      var parsed;
	
	      if (!(/^sip:/i).test(uri)) {
	        uri = SIP.C.SIP + ':' + uri;
	      }
	      parsed = SIP.URI.parse(uri);
	
	      if(!parsed) {
	        return;
	      } else if(!parsed.user) {
	        return;
	      } else {
	        return parsed;
	      }
	    },
	
	    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid
	    wsServers: function(wsServers) {
	      var idx, length, url;
	
	      /* Allow defining wsServers parameter as:
	       *  String: "host"
	       *  Array of Strings: ["host1", "host2"]
	       *  Array of Objects: [{ws_uri:"host1", weight:1}, {ws_uri:"host2", weight:0}]
	       *  Array of Objects and Strings: [{ws_uri:"host1"}, "host2"]
	       */
	      if (typeof wsServers === 'string') {
	        wsServers = [{ws_uri: wsServers}];
	      } else if (wsServers instanceof Array) {
	        length = wsServers.length;
	        for (idx = 0; idx < length; idx++) {
	          if (typeof wsServers[idx] === 'string'){
	            wsServers[idx] = {ws_uri: wsServers[idx]};
	          }
	        }
	      } else {
	        return;
	      }
	
	      if (wsServers.length === 0) {
	        return false;
	      }
	
	      length = wsServers.length;
	      for (idx = 0; idx < length; idx++) {
	        if (!wsServers[idx].ws_uri) {
	          return;
	        }
	        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {
	          return;
	        }
	
	        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');
	
	        if(url === -1) {
	          return;
	        } else if(['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {
	          return;
	        } else {
	          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';
	
	          if (!wsServers[idx].weight) {
	            wsServers[idx].weight = 0;
	          }
	
	          wsServers[idx].status = 0;
	          wsServers[idx].scheme = url.scheme.toUpperCase();
	        }
	      }
	      return wsServers;
	    },
	
	    authorizationUser: function(authorizationUser) {
	      if(SIP.Grammar.parse('"'+ authorizationUser +'"', 'quoted_string') === -1) {
	        return;
	      } else {
	        return authorizationUser;
	      }
	    },
	
	    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {
	      var value;
	      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {
	        value = Number(connectionRecoveryMaxInterval);
	        if(value > 0) {
	          return value;
	        }
	      }
	    },
	
	    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {
	      var value;
	      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {
	        value = Number(connectionRecoveryMinInterval);
	        if(value > 0) {
	          return value;
	        }
	      }
	    },
	
	    displayName: function(displayName) {
	      if(SIP.Grammar.parse('"' + displayName + '"', 'displayName') === -1) {
	        return;
	      } else {
	        return displayName;
	      }
	    },
	
	    hackViaTcp: function(hackViaTcp) {
	      if (typeof hackViaTcp === 'boolean') {
	        return hackViaTcp;
	      }
	    },
	
	    hackIpInContact: function(hackIpInContact) {
	      if (typeof hackIpInContact === 'boolean') {
	        return hackIpInContact;
	      }
	      else if (typeof hackIpInContact === 'string' && SIP.Grammar.parse(hackIpInContact, 'host') !== -1) {
	        return hackIpInContact;
	      }
	    },
	
	    iceCheckingTimeout: function(iceCheckingTimeout) {
	      if(SIP.Utils.isDecimal(iceCheckingTimeout)) {
	        return Math.max(500, iceCheckingTimeout);
	      }
	    },
	
	    hackWssInTransport: function(hackWssInTransport) {
	      if (typeof hackWssInTransport === 'boolean') {
	        return hackWssInTransport;
	      }
	    },
	
	    hackAllowUnregisteredOptionTags: function(hackAllowUnregisteredOptionTags) {
	      if (typeof hackAllowUnregisteredOptionTags === 'boolean') {
	        return hackAllowUnregisteredOptionTags;
	      }
	    },
	
	    contactTransport: function(contactTransport) {
	      if (typeof contactTransport === 'string') {
	        return contactTransport;
	      }
	    },
	
	    forceRport: function(forceRport) {
	      if (typeof forceRport === 'boolean') {
	        return forceRport;
	      }
	    },
	
	    instanceId: function(instanceId) {
	      if(typeof instanceId !== 'string') {
	        return;
	      }
	
	      if ((/^uuid:/i.test(instanceId))) {
	        instanceId = instanceId.substr(5);
	      }
	
	      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {
	        return;
	      } else {
	        return instanceId;
	      }
	    },
	
	    keepAliveInterval: function(keepAliveInterval) {
	      var value;
	      if (SIP.Utils.isDecimal(keepAliveInterval)) {
	        value = Number(keepAliveInterval);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    extraSupported: function(optionTags) {
	      var idx, length;
	
	      if (!(optionTags instanceof Array)) {
	        return;
	      }
	
	      length = optionTags.length;
	      for (idx = 0; idx < length; idx++) {
	        if (typeof optionTags[idx] !== 'string') {
	          return;
	        }
	      }
	
	      return optionTags;
	    },
	
	    noAnswerTimeout: function(noAnswerTimeout) {
	      var value;
	      if (SIP.Utils.isDecimal(noAnswerTimeout)) {
	        value = Number(noAnswerTimeout);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    password: function(password) {
	      return String(password);
	    },
	
	    rel100: function(rel100) {
	      if(rel100 === SIP.C.supported.REQUIRED) {
	        return SIP.C.supported.REQUIRED;
	      } else if (rel100 === SIP.C.supported.SUPPORTED) {
	        return SIP.C.supported.SUPPORTED;
	      } else  {
	        return SIP.C.supported.UNSUPPORTED;
	      }
	    },
	
	    replaces: function(replaces) {
	      if(replaces === SIP.C.supported.REQUIRED) {
	        return SIP.C.supported.REQUIRED;
	      } else if (replaces === SIP.C.supported.SUPPORTED) {
	        return SIP.C.supported.SUPPORTED;
	      } else  {
	        return SIP.C.supported.UNSUPPORTED;
	      }
	    },
	
	    register: function(register) {
	      if (typeof register === 'boolean') {
	        return register;
	      }
	    },
	
	    registerExpires: function(registerExpires) {
	      var value;
	      if (SIP.Utils.isDecimal(registerExpires)) {
	        value = Number(registerExpires);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    registrarServer: function(registrarServer) {
	      var parsed;
	
	      if(typeof registrarServer !== 'string') {
	        return;
	      }
	
	      if (!/^sip:/i.test(registrarServer)) {
	        registrarServer = SIP.C.SIP + ':' + registrarServer;
	      }
	      parsed = SIP.URI.parse(registrarServer);
	
	      if(!parsed) {
	        return;
	      } else if(parsed.user) {
	        return;
	      } else {
	        return parsed;
	      }
	    },
	
	    stunServers: function(stunServers) {
	      var idx, length, stun_server;
	
	      if (typeof stunServers === 'string') {
	        stunServers = [stunServers];
	      } else if (!(stunServers instanceof Array)) {
	        return;
	      }
	
	      length = stunServers.length;
	      for (idx = 0; idx < length; idx++) {
	        stun_server = stunServers[idx];
	        if (!(/^stuns?:/.test(stun_server))) {
	          stun_server = 'stun:' + stun_server;
	        }
	
	        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {
	          return;
	        } else {
	          stunServers[idx] = stun_server;
	        }
	      }
	      return stunServers;
	    },
	
	    traceSip: function(traceSip) {
	      if (typeof traceSip === 'boolean') {
	        return traceSip;
	      }
	    },
	
	    turnServers: function(turnServers) {
	      var idx, jdx, length, turn_server, num_turn_server_urls, url;
	
	      if (turnServers instanceof Array) {
	        // Do nothing
	      } else {
	        turnServers = [turnServers];
	      }
	
	      length = turnServers.length;
	      for (idx = 0; idx < length; idx++) {
	        turn_server = turnServers[idx];
	        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.
	        if (turn_server.server) {
	          turn_server.urls = [turn_server.server];
	        }
	
	        if (!turn_server.urls || !turn_server.username || !turn_server.password) {
	          return;
	        }
	
	        if (turn_server.urls instanceof Array) {
	          num_turn_server_urls = turn_server.urls.length;
	        } else {
	          turn_server.urls = [turn_server.urls];
	          num_turn_server_urls = 1;
	        }
	
	        for (jdx = 0; jdx < num_turn_server_urls; jdx++) {
	          url = turn_server.urls[jdx];
	
	          if (!(/^turns?:/.test(url))) {
	            url = 'turn:' + url;
	          }
	
	          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {
	            return;
	          }
	        }
	      }
	      return turnServers;
	    },
	
	    userAgentString: function(userAgentString) {
	      if (typeof userAgentString === 'string') {
	        return userAgentString;
	      }
	    },
	
	    usePreloadedRoute: function(usePreloadedRoute) {
	      if (typeof usePreloadedRoute === 'boolean') {
	        return usePreloadedRoute;
	      }
	    },
	
	    wsServerMaxReconnection: function(wsServerMaxReconnection) {
	      var value;
	      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {
	        value = Number(wsServerMaxReconnection);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {
	      var value;
	      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {
	        value = Number(wsServerReconnectionTimeout);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    autostart: function(autostart) {
	      if (typeof autostart === 'boolean') {
	        return autostart;
	      }
	    },
	
	    mediaHandlerFactory: function(mediaHandlerFactory) {
	      if (mediaHandlerFactory instanceof Function) {
	        var promisifiedFactory = function promisifiedFactory () {
	          var mediaHandler = mediaHandlerFactory.apply(this, arguments);
	
	          function patchMethod (methodName) {
	            var method = mediaHandler[methodName];
	            if (method.length > 1) {
	              var callbacksFirst = methodName === 'getDescription';
	              mediaHandler[methodName] = SIP.Utils.promisify(mediaHandler, methodName, callbacksFirst);
	            }
	          }
	
	          patchMethod('getDescription');
	          patchMethod('setDescription');
	
	          return mediaHandler;
	        };
	
	        promisifiedFactory.isSupported = mediaHandlerFactory.isSupported;
	        return promisifiedFactory;
	      }
	    },
	
	    authenticationFactory: checkAuthenticationFactory
	  }
	};
	
	UA.C = C;
	SIP.UA = UA;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 240 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Hacks - This file contains all of the things we
	 * wish we didn't have to do, just for interop.  It is similar to
	 * Utils, which provides actually useful and relevant functions for
	 * a SIP library. Methods in this file are grouped by vendor, so
	 * as to most easily track when particular hacks may not be necessary anymore.
	 */
	
	module.exports = function (SIP) {
	
	//keep to quiet jshint, and remain consistent with other files
	SIP = SIP;
	
	var Hacks = {
	  AllBrowsers: {
	    maskDtls: function (message) {
	      if (message.body) {
	        message.body = message.body.replace(/ UDP\/TLS\/RTP\/SAVP/gmi, " RTP/SAVP");
	      }
	    },
	    unmaskDtls: function (sdp) {
	      /**
	       * Chrome does not handle DTLS correctly (Canaray does, but not production)
	       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)
	       *
	       * UPDATE: May 21, 2014
	       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES
	       *
	       * UPDATE: 2014-09-24
	       * Opera now supports DTLS by default as well.
	       *
	       **/
	      return sdp.replace(/ RTP\/SAVP/gmi, " UDP/TLS/RTP/SAVP");
	    }
	  },
	  Firefox: {
	    /* Condition to detect if hacks are applicable */
	    isFirefox: function () {
	      return typeof mozRTCPeerConnection !== 'undefined';
	    },
	
	    cannotHandleExtraWhitespace: function (message) {
	      if (this.isFirefox() && message.body) {
	        message.body = message.body.replace(/ \r\n/g, "\r\n");
	      }
	    },
	
	    hasMissingCLineInSDP: function (sdp) {
	      /*
	       * This is a Firefox hack to insert valid sdp when getDescription is
	       * called with the constraint offerToReceiveVideo = false.
	       * We search for either a c-line at the top of the sdp above all
	       * m-lines. If that does not exist then we search for a c-line
	       * beneath each m-line. If it is missing a c-line, we insert
	       * a fake c-line with the ip address 0.0.0.0. This is then valid
	       * sdp and no media will be sent for that m-line.
	       *
	       * Valid SDP is:
	       * m=
	       * i=
	       * c=
	       */
	      var insertAt, mlines;
	      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {
	
	        // Find all m= lines
	        mlines = sdp.match(/m=.*\r\n.*/g);
	        for (var i=0; i<mlines.length; i++) {
	
	          // If it has an i= line, check if the next line is the c= line
	          if (mlines[i].toString().search(/i=.*/) >= 0) {
	            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;
	            if (sdp.substr(insertAt,2)!=='c=') {
	              sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
	            }
	
	          // else add the C line if it's missing
	          } else if (mlines[i].toString().search(/c=.*/) < 0) {
	            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;
	            sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
	          }
	        }
	      }
	      return sdp;
	    },
	  },
	
	  Chrome: {
	    needsExplicitlyInactiveSDP: function (sdp) {
	      var sub, index;
	
	      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending
	        index = sdp.indexOf('m=video 0');
	        if (index !== -1) {
	          sub = sdp.substr(index);
	          sub = sub.replace(/\r\nc=IN IP4.*\r\n$/,
	                            '\r\nc=IN IP4 0.0.0.0\r\na=inactive\r\n');
	          return sdp.substr(0, index) + sub;
	        }
	      }
	      return sdp;
	    },
	
	    getsConfusedAboutGUM: function (session) {
	      if (session.mediaHandler) {
	        session.mediaHandler.close();
	      }
	    }
	  }
	};
	return Hacks;
	};

/***/ },
/* 241 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Incoming SIP Message Sanity Check
	 */
	
	/**
	 * SIP message sanity check.
	 * @augments SIP
	 * @function
	 * @param {SIP.IncomingMessage} message
	 * @param {SIP.UA} ua
	 * @param {SIP.Transport} transport
	 * @returns {Boolean}
	 */
	module.exports = function (SIP) {
	var sanityCheck,
	 logger,
	 message, ua, transport,
	 requests = [],
	 responses = [],
	 all = [];
	
	// Reply
	function reply(status_code) {
	  var to,
	    response = SIP.Utils.buildStatusLine(status_code),
	    vias = message.getHeaders('via'),
	    length = vias.length,
	    idx = 0;
	
	  for(idx; idx < length; idx++) {
	    response += "Via: " + vias[idx] + "\r\n";
	  }
	
	  to = message.getHeader('To');
	
	  if(!message.to_tag) {
	    to += ';tag=' + SIP.Utils.newTag();
	  }
	
	  response += "To: " + to + "\r\n";
	  response += "From: " + message.getHeader('From') + "\r\n";
	  response += "Call-ID: " + message.call_id + "\r\n";
	  response += "CSeq: " + message.cseq + " " + message.method + "\r\n";
	  response += "\r\n";
	
	  transport.send(response);
	}
	
	/*
	 * Sanity Check for incoming Messages
	 *
	 * Requests:
	 *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
	 *  - _rfc3261_16_3_4_ Receive a Request already sent by us
	 *   Does not look at via sent-by but at sipjsId, which is inserted as
	 *   a prefix in all initial requests generated by the ua
	 *  - _rfc3261_18_3_request_ Body Content-Length
	 *  - _rfc3261_8_2_2_2_ Merged Requests
	 *
	 * Responses:
	 *  - _rfc3261_8_1_3_3_ Multiple Via headers
	 *  - _rfc3261_18_1_2_ sent-by mismatch
	 *  - _rfc3261_18_3_response_ Body Content-Length
	 *
	 * All:
	 *  - Minimum headers in a SIP message
	 */
	
	// Sanity Check functions for requests
	function rfc3261_8_2_2_1() {
	  if(!message.ruri || message.ruri.scheme !== 'sip') {
	    reply(416);
	    return false;
	  }
	}
	
	function rfc3261_16_3_4() {
	  if(!message.to_tag) {
	    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {
	      reply(482);
	      return false;
	    }
	  }
	}
	
	function rfc3261_18_3_request() {
	  var len = SIP.Utils.str_utf8_length(message.body),
	  contentLength = message.getHeader('content-length');
	
	  if(len < contentLength) {
	    reply(400);
	    return false;
	  }
	}
	
	function rfc3261_8_2_2_2() {
	  var tr, idx,
	    fromTag = message.from_tag,
	    call_id = message.call_id,
	    cseq = message.cseq;
	
	  if(!message.to_tag) {
	    if(message.method === SIP.C.INVITE) {
	      tr = ua.transactions.ist[message.via_branch];
	      if(tr) {
	        return;
	      } else {
	        for(idx in ua.transactions.ist) {
	          tr = ua.transactions.ist[idx];
	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
	            reply(482);
	            return false;
	          }
	        }
	      }
	    } else {
	      tr = ua.transactions.nist[message.via_branch];
	      if(tr) {
	        return;
	      } else {
	        for(idx in ua.transactions.nist) {
	          tr = ua.transactions.nist[idx];
	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
	            reply(482);
	            return false;
	          }
	        }
	      }
	    }
	  }
	}
	
	// Sanity Check functions for responses
	function rfc3261_8_1_3_3() {
	  if(message.getHeaders('via').length > 1) {
	    logger.warn('More than one Via header field present in the response. Dropping the response');
	    return false;
	  }
	}
	
	function rfc3261_18_1_2() {
	  var viaHost = ua.configuration.viaHost;
	  if(message.via.host !== viaHost || message.via.port !== undefined) {
	    logger.warn('Via sent-by in the response does not match UA Via host value. Dropping the response');
	    return false;
	  }
	}
	
	function rfc3261_18_3_response() {
	  var
	    len = SIP.Utils.str_utf8_length(message.body),
	    contentLength = message.getHeader('content-length');
	
	    if(len < contentLength) {
	      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');
	      return false;
	    }
	}
	
	// Sanity Check functions for requests and responses
	function minimumHeaders() {
	  var
	    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],
	    idx = mandatoryHeaders.length;
	
	  while(idx--) {
	    if(!message.hasHeader(mandatoryHeaders[idx])) {
	      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');
	      return false;
	    }
	  }
	}
	
	requests.push(rfc3261_8_2_2_1);
	requests.push(rfc3261_16_3_4);
	requests.push(rfc3261_18_3_request);
	requests.push(rfc3261_8_2_2_2);
	
	responses.push(rfc3261_8_1_3_3);
	responses.push(rfc3261_18_1_2);
	responses.push(rfc3261_18_3_response);
	
	all.push(minimumHeaders);
	
	sanityCheck = function(m, u, t) {
	  var len, pass;
	
	  message = m;
	  ua = u;
	  transport = t;
	
	  logger = ua.getLogger('sip.sanitycheck');
	
	  len = all.length;
	  while(len--) {
	    pass = all[len](message);
	    if(pass === false) {
	      return false;
	    }
	  }
	
	  if(message instanceof SIP.IncomingRequest) {
	    len = requests.length;
	    while(len--) {
	      pass = requests[len](message);
	      if(pass === false) {
	        return false;
	      }
	    }
	  }
	
	  else if(message instanceof SIP.IncomingResponse) {
	    len = responses.length;
	    while(len--) {
	      pass = responses[len](message);
	      if(pass === false) {
	        return false;
	      }
	    }
	  }
	
	  //Everything is OK
	  return true;
	};
	
	SIP.sanityCheck = sanityCheck;
	};


/***/ },
/* 242 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview SIP Digest Authentication
	 */
	
	/**
	 * SIP Digest Authentication.
	 * @augments SIP.
	 * @function Digest Authentication
	 * @param {SIP.UA} ua
	 */
	module.exports = function (Utils) {
	var DigestAuthentication;
	
	DigestAuthentication = function(ua) {
	  this.logger = ua.getLogger('sipjs.digestauthentication');
	  this.username = ua.configuration.authorizationUser;
	  this.password = ua.configuration.password;
	  this.cnonce = null;
	  this.nc = 0;
	  this.ncHex = '00000000';
	  this.response = null;
	};
	
	
	/**
	* Performs Digest authentication given a SIP request and the challenge
	* received in a response to that request.
	* Returns true if credentials were successfully generated, false otherwise.
	*
	* @param {SIP.OutgoingRequest} request
	* @param {Object} challenge
	*/
	DigestAuthentication.prototype.authenticate = function(request, challenge) {
	  // Inspect and validate the challenge.
	
	  this.algorithm = challenge.algorithm;
	  this.realm = challenge.realm;
	  this.nonce = challenge.nonce;
	  this.opaque = challenge.opaque;
	  this.stale = challenge.stale;
	
	  if (this.algorithm) {
	    if (this.algorithm !== 'MD5') {
	      this.logger.warn('challenge with Digest algorithm different than "MD5", authentication aborted');
	      return false;
	    }
	  } else {
	    this.algorithm = 'MD5';
	  }
	
	  if (! this.realm) {
	    this.logger.warn('challenge without Digest realm, authentication aborted');
	    return false;
	  }
	
	  if (! this.nonce) {
	    this.logger.warn('challenge without Digest nonce, authentication aborted');
	    return false;
	  }
	
	  // 'qop' can contain a list of values (Array). Let's choose just one.
	  if (challenge.qop) {
	    if (challenge.qop.indexOf('auth') > -1) {
	      this.qop = 'auth';
	    } else if (challenge.qop.indexOf('auth-int') > -1) {
	      this.qop = 'auth-int';
	    } else {
	      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
	      this.logger.warn('challenge without Digest qop different than "auth" or "auth-int", authentication aborted');
	      return false;
	    }
	  } else {
	    this.qop = null;
	  }
	
	  // Fill other attributes.
	
	  this.method = request.method;
	  this.uri = request.ruri;
	  this.cnonce = Utils.createRandomToken(12);
	  this.nc += 1;
	  this.updateNcHex();
	
	  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
	  if (this.nc === 4294967296) {
	    this.nc = 1;
	    this.ncHex = '00000001';
	  }
	
	  // Calculate the Digest "response" value.
	  this.calculateResponse();
	
	  return true;
	};
	
	
	/**
	* Generate Digest 'response' value.
	* @private
	*/
	DigestAuthentication.prototype.calculateResponse = function() {
	  var ha1, ha2;
	
	  // HA1 = MD5(A1) = MD5(username:realm:password)
	  ha1 = Utils.calculateMD5(this.username + ":" + this.realm + ":" + this.password);
	
	  if (this.qop === 'auth') {
	    // HA2 = MD5(A2) = MD5(method:digestURI)
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
	
	  } else if (this.qop === 'auth-int') {
	    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri + ":" + Utils.calculateMD5(this.body ? this.body : ""));
	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
	
	  } else if (this.qop === null) {
	    // HA2 = MD5(A2) = MD5(method:digestURI)
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
	    // response = MD5(HA1:nonce:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + ha2);
	  }
	};
	
	
	/**
	* Return the Proxy-Authorization or WWW-Authorization header value.
	*/
	DigestAuthentication.prototype.toString = function() {
	  var auth_params = [];
	
	  if (! this.response) {
	    throw new Error('response field does not exist, cannot generate Authorization header');
	  }
	
	  auth_params.push('algorithm=' + this.algorithm);
	  auth_params.push('username="' + this.username + '"');
	  auth_params.push('realm="' + this.realm + '"');
	  auth_params.push('nonce="' + this.nonce + '"');
	  auth_params.push('uri="' + this.uri + '"');
	  auth_params.push('response="' + this.response + '"');
	  if (this.opaque) {
	    auth_params.push('opaque="' + this.opaque + '"');
	  }
	  if (this.qop) {
	    auth_params.push('qop=' + this.qop);
	    auth_params.push('cnonce="' + this.cnonce + '"');
	    auth_params.push('nc=' + this.ncHex);
	  }
	
	  return 'Digest ' + auth_params.join(', ');
	};
	
	
	/**
	* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
	* @private
	*/
	DigestAuthentication.prototype.updateNcHex = function() {
	  var hex = Number(this.nc).toString(16);
	  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;
	};
	
	return DigestAuthentication;
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Grammar = __webpack_require__(244);
	
	module.exports = function (SIP) {
	
	return {
	  parse: function parseCustom (input, startRule) {
	    var options = {startRule: startRule, SIP: SIP};
	    try {
	      Grammar.parse(input, options);
	    } catch (e) {
	      options.data = -1;
	    }
	    return options.data;
	  }
	};
	
	};


/***/ },
/* 244 */
/***/ function(module, exports) {

	module.exports = (function() {
	  /*
	   * Generated by PEG.js 0.8.0.
	   *
	   * http://pegjs.majda.cz/
	   */
	
	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }
	
	  function SyntaxError(message, expected, found, offset, line, column) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.offset   = offset;
	    this.line     = line;
	    this.column   = column;
	
	    this.name     = "SyntaxError";
	  }
	
	  peg$subclass(SyntaxError, Error);
	
	  function parse(input) {
	    var options = arguments.length > 1 ? arguments[1] : {},
	
	        peg$FAILED = {},
	
	        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 185, Supported: 190, Require: 181, Via: 193, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Min_SE: 212, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, Replaces: 178, Session_Expires: 209, stun_URI: 216, To: 191, turn_URI: 223, uuid: 226, WWW_Authenticate: 208, challenge: 157 },
	        peg$startRuleIndex   = 118,
	
	        peg$consts = [
	          "\r\n",
	          { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
	          /^[0-9]/,
	          { type: "class", value: "[0-9]", description: "[0-9]" },
	          /^[a-zA-Z]/,
	          { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
	          /^[0-9a-fA-F]/,
	          { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
	          /^[\0-\xFF]/,
	          { type: "class", value: "[\\0-\\xFF]", description: "[\\0-\\xFF]" },
	          /^["]/,
	          { type: "class", value: "[\"]", description: "[\"]" },
	          " ",
	          { type: "literal", value: " ", description: "\" \"" },
	          "\t",
	          { type: "literal", value: "\t", description: "\"\\t\"" },
	          /^[a-zA-Z0-9]/,
	          { type: "class", value: "[a-zA-Z0-9]", description: "[a-zA-Z0-9]" },
	          ";",
	          { type: "literal", value: ";", description: "\";\"" },
	          "/",
	          { type: "literal", value: "/", description: "\"/\"" },
	          "?",
	          { type: "literal", value: "?", description: "\"?\"" },
	          ":",
	          { type: "literal", value: ":", description: "\":\"" },
	          "@",
	          { type: "literal", value: "@", description: "\"@\"" },
	          "&",
	          { type: "literal", value: "&", description: "\"&\"" },
	          "=",
	          { type: "literal", value: "=", description: "\"=\"" },
	          "+",
	          { type: "literal", value: "+", description: "\"+\"" },
	          "$",
	          { type: "literal", value: "$", description: "\"$\"" },
	          ",",
	          { type: "literal", value: ",", description: "\",\"" },
	          "-",
	          { type: "literal", value: "-", description: "\"-\"" },
	          "_",
	          { type: "literal", value: "_", description: "\"_\"" },
	          ".",
	          { type: "literal", value: ".", description: "\".\"" },
	          "!",
	          { type: "literal", value: "!", description: "\"!\"" },
	          "~",
	          { type: "literal", value: "~", description: "\"~\"" },
	          "*",
	          { type: "literal", value: "*", description: "\"*\"" },
	          "'",
	          { type: "literal", value: "'", description: "\"'\"" },
	          "(",
	          { type: "literal", value: "(", description: "\"(\"" },
	          ")",
	          { type: "literal", value: ")", description: "\")\"" },
	          peg$FAILED,
	          "%",
	          { type: "literal", value: "%", description: "\"%\"" },
	          null,
	          [],
	          function() {return " "; },
	          function() {return ':'; },
	          /^[!-~]/,
	          { type: "class", value: "[!-~]", description: "[!-~]" },
	          /^[\x80-\uFFFF]/,
	          { type: "class", value: "[\\x80-\\uFFFF]", description: "[\\x80-\\uFFFF]" },
	          /^[\x80-\xBF]/,
	          { type: "class", value: "[\\x80-\\xBF]", description: "[\\x80-\\xBF]" },
	          /^[a-f]/,
	          { type: "class", value: "[a-f]", description: "[a-f]" },
	          "`",
	          { type: "literal", value: "`", description: "\"`\"" },
	          "<",
	          { type: "literal", value: "<", description: "\"<\"" },
	          ">",
	          { type: "literal", value: ">", description: "\">\"" },
	          "\\",
	          { type: "literal", value: "\\", description: "\"\\\\\"" },
	          "[",
	          { type: "literal", value: "[", description: "\"[\"" },
	          "]",
	          { type: "literal", value: "]", description: "\"]\"" },
	          "{",
	          { type: "literal", value: "{", description: "\"{\"" },
	          "}",
	          { type: "literal", value: "}", description: "\"}\"" },
	          function() {return "*"; },
	          function() {return "/"; },
	          function() {return "="; },
	          function() {return "("; },
	          function() {return ")"; },
	          function() {return ">"; },
	          function() {return "<"; },
	          function() {return ","; },
	          function() {return ";"; },
	          function() {return ":"; },
	          function() {return "\""; },
	          /^[!-']/,
	          { type: "class", value: "[!-']", description: "[!-']" },
	          /^[*-[]/,
	          { type: "class", value: "[*-[]", description: "[*-[]" },
	          /^[\]-~]/,
	          { type: "class", value: "[\\]-~]", description: "[\\]-~]" },
	          function(contents) {
	                                  return contents; },
	          /^[#-[]/,
	          { type: "class", value: "[#-[]", description: "[#-[]" },
	          /^[\0-\t]/,
	          { type: "class", value: "[\\0-\\t]", description: "[\\0-\\t]" },
	          /^[\x0B-\f]/,
	          { type: "class", value: "[\\x0B-\\f]", description: "[\\x0B-\\f]" },
	          /^[\x0E-]/,
	          { type: "class", value: "[\\x0E-]", description: "[\\x0E-]" },
	          function() {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                },
	          function() {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                  delete options.data.uri_params;
	
	                                  if (options.startRule === 'SIP_URI') { options.data = options.data.uri;}
	                                },
	          "sips",
	          { type: "literal", value: "sips", description: "\"sips\"" },
	          "sip",
	          { type: "literal", value: "sip", description: "\"sip\"" },
	          function(uri_scheme) {
	                              options.data.scheme = uri_scheme; },
	          function() {
	                              options.data.user = decodeURIComponent(text().slice(0, -1));},
	          function() {
	                              options.data.password = text(); },
	          function() {
	                              options.data.host = text();
	                              return options.data.host; },
	          function() {
	                            options.data.host_type = 'domain';
	                            return text(); },
	          /^[a-zA-Z0-9_\-]/,
	          { type: "class", value: "[a-zA-Z0-9_\\-]", description: "[a-zA-Z0-9_\\-]" },
	          /^[a-zA-Z0-9\-]/,
	          { type: "class", value: "[a-zA-Z0-9\\-]", description: "[a-zA-Z0-9\\-]" },
	          function() {
	                              options.data.host_type = 'IPv6';
	                              return text(); },
	          "::",
	          { type: "literal", value: "::", description: "\"::\"" },
	          function() {
	                            options.data.host_type = 'IPv6';
	                            return text(); },
	          function() {
	                              options.data.host_type = 'IPv4';
	                              return text(); },
	          "25",
	          { type: "literal", value: "25", description: "\"25\"" },
	          /^[0-5]/,
	          { type: "class", value: "[0-5]", description: "[0-5]" },
	          "2",
	          { type: "literal", value: "2", description: "\"2\"" },
	          /^[0-4]/,
	          { type: "class", value: "[0-4]", description: "[0-4]" },
	          "1",
	          { type: "literal", value: "1", description: "\"1\"" },
	          /^[1-9]/,
	          { type: "class", value: "[1-9]", description: "[1-9]" },
	          function(port) {
	                              port = parseInt(port.join(''));
	                              options.data.port = port;
	                              return port; },
	          "transport=",
	          { type: "literal", value: "transport=", description: "\"transport=\"" },
	          "udp",
	          { type: "literal", value: "udp", description: "\"udp\"" },
	          "tcp",
	          { type: "literal", value: "tcp", description: "\"tcp\"" },
	          "sctp",
	          { type: "literal", value: "sctp", description: "\"sctp\"" },
	          "tls",
	          { type: "literal", value: "tls", description: "\"tls\"" },
	          function(transport) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['transport'] = transport.toLowerCase(); },
	          "user=",
	          { type: "literal", value: "user=", description: "\"user=\"" },
	          "phone",
	          { type: "literal", value: "phone", description: "\"phone\"" },
	          "ip",
	          { type: "literal", value: "ip", description: "\"ip\"" },
	          function(user) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['user'] = user.toLowerCase(); },
	          "method=",
	          { type: "literal", value: "method=", description: "\"method=\"" },
	          function(method) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['method'] = method; },
	          "ttl=",
	          { type: "literal", value: "ttl=", description: "\"ttl=\"" },
	          function(ttl) {
	                                if(!options.data.params) options.data.params={};
	                                options.data.params['ttl'] = ttl; },
	          "maddr=",
	          { type: "literal", value: "maddr=", description: "\"maddr=\"" },
	          function(maddr) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['maddr'] = maddr; },
	          "lr",
	          { type: "literal", value: "lr", description: "\"lr\"" },
	          function() {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['lr'] = undefined; },
	          function(param, value) {
	                                if(!options.data.uri_params) options.data.uri_params = {};
	                                if (value === null){
	                                  value = undefined;
	                                }
	                                else {
	                                  value = value[1];
	                                }
	                                options.data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},
	          function(hname, hvalue) {
	                                hname = hname.join('').toLowerCase();
	                                hvalue = hvalue.join('');
	                                if(!options.data.uri_headers) options.data.uri_headers = {};
	                                if (!options.data.uri_headers[hname]) {
	                                  options.data.uri_headers[hname] = [hvalue];
	                                } else {
	                                  options.data.uri_headers[hname].push(hvalue);
	                                }},
	          function() {
	                                // lots of tests fail if this isn't guarded...
	                                if (options.startRule === 'Refer_To') {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                  delete options.data.uri_params;
	                                }
	                              },
	          "//",
	          { type: "literal", value: "//", description: "\"//\"" },
	          function() {
	                              options.data.scheme= text(); },
	          { type: "literal", value: "SIP", description: "\"SIP\"" },
	          function() {
	                              options.data.sip_version = text(); },
	          "INVITE",
	          { type: "literal", value: "INVITE", description: "\"INVITE\"" },
	          "ACK",
	          { type: "literal", value: "ACK", description: "\"ACK\"" },
	          "VXACH",
	          { type: "literal", value: "VXACH", description: "\"VXACH\"" },
	          "OPTIONS",
	          { type: "literal", value: "OPTIONS", description: "\"OPTIONS\"" },
	          "BYE",
	          { type: "literal", value: "BYE", description: "\"BYE\"" },
	          "CANCEL",
	          { type: "literal", value: "CANCEL", description: "\"CANCEL\"" },
	          "REGISTER",
	          { type: "literal", value: "REGISTER", description: "\"REGISTER\"" },
	          "SUBSCRIBE",
	          { type: "literal", value: "SUBSCRIBE", description: "\"SUBSCRIBE\"" },
	          "NOTIFY",
	          { type: "literal", value: "NOTIFY", description: "\"NOTIFY\"" },
	          "REFER",
	          { type: "literal", value: "REFER", description: "\"REFER\"" },
	          function() {
	
	                              options.data.method = text();
	                              return options.data.method; },
	          function(status_code) {
	                            options.data.status_code = parseInt(status_code.join('')); },
	          function() {
	                            options.data.reason_phrase = text(); },
	          function() {
	                        options.data = text(); },
	          function() {
	                                  var idx, length;
	                                  length = options.data.multi_header.length;
	                                  for (idx = 0; idx < length; idx++) {
	                                    if (options.data.multi_header[idx].parsed === null) {
	                                      options.data = null;
	                                      break;
	                                    }
	                                  }
	                                  if (options.data !== null) {
	                                    options.data = options.data.multi_header;
	                                  } else {
	                                    options.data = -1;
	                                  }},
	          function() {
	                                  var header;
	                                  if(!options.data.multi_header) options.data.multi_header = [];
	                                  try {
	                                    header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                                    delete options.data.uri;
	                                    delete options.data.displayName;
	                                    delete options.data.params;
	                                  } catch(e) {
	                                    header = null;
	                                  }
	                                  options.data.multi_header.push( { 'position': peg$currPos,
	                                                            'offset': offset(),
	                                                            'parsed': header
	                                                          });},
	          function(displayName) {
	                                  displayName = text().trim();
	                                  if (displayName[0] === '\"') {
	                                    displayName = displayName.substring(1, displayName.length-1);
	                                  }
	                                  options.data.displayName = displayName; },
	          "q",
	          { type: "literal", value: "q", description: "\"q\"" },
	          function(q) {
	                                  if(!options.data.params) options.data.params = {};
	                                  options.data.params['q'] = q; },
	          "expires",
	          { type: "literal", value: "expires", description: "\"expires\"" },
	          function(expires) {
	                                  if(!options.data.params) options.data.params = {};
	                                  options.data.params['expires'] = expires; },
	          function(delta_seconds) {
	                                  return parseInt(delta_seconds.join('')); },
	          "0",
	          { type: "literal", value: "0", description: "\"0\"" },
	          function() {
	                                  return parseFloat(text()); },
	          function(param, value) {
	                                  if(!options.data.params) options.data.params = {};
	                                  if (value === null){
	                                    value = undefined;
	                                  }
	                                  else {
	                                    value = value[1];
	                                  }
	                                  options.data.params[param.toLowerCase()] = value;},
	          "render",
	          { type: "literal", value: "render", description: "\"render\"" },
	          "session",
	          { type: "literal", value: "session", description: "\"session\"" },
	          "icon",
	          { type: "literal", value: "icon", description: "\"icon\"" },
	          "alert",
	          { type: "literal", value: "alert", description: "\"alert\"" },
	          function() {
	                                      if (options.startRule === 'Content_Disposition') {
	                                        options.data.type = text().toLowerCase();
	                                      }
	                                    },
	          "handling",
	          { type: "literal", value: "handling", description: "\"handling\"" },
	          "optional",
	          { type: "literal", value: "optional", description: "\"optional\"" },
	          "required",
	          { type: "literal", value: "required", description: "\"required\"" },
	          function(length) {
	                                  options.data = parseInt(length.join('')); },
	          function() {
	                                  options.data = text(); },
	          "text",
	          { type: "literal", value: "text", description: "\"text\"" },
	          "image",
	          { type: "literal", value: "image", description: "\"image\"" },
	          "audio",
	          { type: "literal", value: "audio", description: "\"audio\"" },
	          "video",
	          { type: "literal", value: "video", description: "\"video\"" },
	          "application",
	          { type: "literal", value: "application", description: "\"application\"" },
	          "message",
	          { type: "literal", value: "message", description: "\"message\"" },
	          "multipart",
	          { type: "literal", value: "multipart", description: "\"multipart\"" },
	          "x-",
	          { type: "literal", value: "x-", description: "\"x-\"" },
	          function(cseq_value) {
	                            options.data.value=parseInt(cseq_value.join('')); },
	          function(expires) {options.data = expires; },
	          function(event_type) {
	                                 options.data.event = event_type.toLowerCase(); },
	          function() {
	                          var tag = options.data.tag;
	                            options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                            if (tag) {options.data.setParam('tag',tag)}
	                          },
	          "tag",
	          { type: "literal", value: "tag", description: "\"tag\"" },
	          function(tag) {options.data.tag = tag; },
	          function(forwards) {
	                            options.data = parseInt(forwards.join('')); },
	          function(min_expires) {options.data = min_expires; },
	          function() {
	                                  options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                                },
	          "digest",
	          { type: "literal", value: "Digest", description: "\"Digest\"" },
	          "realm",
	          { type: "literal", value: "realm", description: "\"realm\"" },
	          function(realm) { options.data.realm = realm; },
	          "domain",
	          { type: "literal", value: "domain", description: "\"domain\"" },
	          "nonce",
	          { type: "literal", value: "nonce", description: "\"nonce\"" },
	          function(nonce) { options.data.nonce=nonce; },
	          "opaque",
	          { type: "literal", value: "opaque", description: "\"opaque\"" },
	          function(opaque) { options.data.opaque=opaque; },
	          "stale",
	          { type: "literal", value: "stale", description: "\"stale\"" },
	          "true",
	          { type: "literal", value: "true", description: "\"true\"" },
	          function() { options.data.stale=true; },
	          "false",
	          { type: "literal", value: "false", description: "\"false\"" },
	          function() { options.data.stale=false; },
	          "algorithm",
	          { type: "literal", value: "algorithm", description: "\"algorithm\"" },
	          "md5",
	          { type: "literal", value: "MD5", description: "\"MD5\"" },
	          "md5-sess",
	          { type: "literal", value: "MD5-sess", description: "\"MD5-sess\"" },
	          function(algorithm) {
	                                options.data.algorithm=algorithm.toUpperCase(); },
	          "qop",
	          { type: "literal", value: "qop", description: "\"qop\"" },
	          "auth-int",
	          { type: "literal", value: "auth-int", description: "\"auth-int\"" },
	          "auth",
	          { type: "literal", value: "auth", description: "\"auth\"" },
	          function(qop_value) {
	                                  options.data.qop || (options.data.qop=[]);
	                                  options.data.qop.push(qop_value.toLowerCase()); },
	          function(rack_value) {
	                            options.data.value=parseInt(rack_value.join('')); },
	          function() {
	                            var idx, length;
	                            length = options.data.multi_header.length;
	                            for (idx = 0; idx < length; idx++) {
	                              if (options.data.multi_header[idx].parsed === null) {
	                                options.data = null;
	                                break;
	                              }
	                            }
	                            if (options.data !== null) {
	                              options.data = options.data.multi_header;
	                            } else {
	                              options.data = -1;
	                            }},
	          function() {
	                            var header;
	                            if(!options.data.multi_header) options.data.multi_header = [];
	                            try {
	                              header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                              delete options.data.uri;
	                              delete options.data.displayName;
	                              delete options.data.params;
	                            } catch(e) {
	                              header = null;
	                            }
	                            options.data.multi_header.push( { 'position': peg$currPos,
	                                                      'offset': offset(),
	                                                      'parsed': header
	                                                    });},
	          function() {
	                        options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                      },
	          function() {
	                                if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
	                                  options.data = -1;
	                                }
	                              },
	          function() {
	                                options.data = {
	                                  call_id: options.data
	                                };
	                              },
	          "from-tag",
	          { type: "literal", value: "from-tag", description: "\"from-tag\"" },
	          function(from_tag) {
	                                options.data.replaces_from_tag = from_tag;
	                              },
	          "to-tag",
	          { type: "literal", value: "to-tag", description: "\"to-tag\"" },
	          function(to_tag) {
	                                options.data.replaces_to_tag = to_tag;
	                              },
	          "early-only",
	          { type: "literal", value: "early-only", description: "\"early-only\"" },
	          function() {
	                                options.data.early_only = true;
	                              },
	          function(r) {return r;},
	          function(first, rest) { return list(first, rest); },
	          function(value) {
	                          if (options.startRule === 'Require') {
	                            options.data = value || [];
	                          }
	                        },
	          function(rseq_value) {
	                            options.data.value=parseInt(rseq_value.join('')); },
	          "active",
	          { type: "literal", value: "active", description: "\"active\"" },
	          "pending",
	          { type: "literal", value: "pending", description: "\"pending\"" },
	          "terminated",
	          { type: "literal", value: "terminated", description: "\"terminated\"" },
	          function() {
	                                  options.data.state = text(); },
	          "reason",
	          { type: "literal", value: "reason", description: "\"reason\"" },
	          function(reason) {
	                                  if (typeof reason !== 'undefined') options.data.reason = reason; },
	          function(expires) {
	                                  if (typeof expires !== 'undefined') options.data.expires = expires; },
	          "retry_after",
	          { type: "literal", value: "retry_after", description: "\"retry_after\"" },
	          function(retry_after) {
	                                  if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after; },
	          "deactivated",
	          { type: "literal", value: "deactivated", description: "\"deactivated\"" },
	          "probation",
	          { type: "literal", value: "probation", description: "\"probation\"" },
	          "rejected",
	          { type: "literal", value: "rejected", description: "\"rejected\"" },
	          "timeout",
	          { type: "literal", value: "timeout", description: "\"timeout\"" },
	          "giveup",
	          { type: "literal", value: "giveup", description: "\"giveup\"" },
	          "noresource",
	          { type: "literal", value: "noresource", description: "\"noresource\"" },
	          "invariant",
	          { type: "literal", value: "invariant", description: "\"invariant\"" },
	          function(value) {
	                          if (options.startRule === 'Supported') {
	                            options.data = value || [];
	                          }
	                        },
	          function() {
	                        var tag = options.data.tag;
	                          options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                          if (tag) {options.data.setParam('tag',tag)}
	                        },
	          "ttl",
	          { type: "literal", value: "ttl", description: "\"ttl\"" },
	          function(via_ttl_value) {
	                                options.data.ttl = via_ttl_value; },
	          "maddr",
	          { type: "literal", value: "maddr", description: "\"maddr\"" },
	          function(via_maddr) {
	                                options.data.maddr = via_maddr; },
	          "received",
	          { type: "literal", value: "received", description: "\"received\"" },
	          function(via_received) {
	                                options.data.received = via_received; },
	          "branch",
	          { type: "literal", value: "branch", description: "\"branch\"" },
	          function(via_branch) {
	                                options.data.branch = via_branch; },
	          "rport",
	          { type: "literal", value: "rport", description: "\"rport\"" },
	          function() {
	                                if(typeof response_port !== 'undefined')
	                                  options.data.rport = response_port.join(''); },
	          function(via_protocol) {
	                                options.data.protocol = via_protocol; },
	          { type: "literal", value: "UDP", description: "\"UDP\"" },
	          { type: "literal", value: "TCP", description: "\"TCP\"" },
	          { type: "literal", value: "TLS", description: "\"TLS\"" },
	          { type: "literal", value: "SCTP", description: "\"SCTP\"" },
	          function(via_transport) {
	                                options.data.transport = via_transport; },
	          function() {
	                                options.data.host = text(); },
	          function(via_sent_by_port) {
	                                options.data.port = parseInt(via_sent_by_port.join('')); },
	          function(ttl) {
	                                return parseInt(ttl.join('')); },
	          function(deltaSeconds) {
	                                if (options.startRule === 'Session_Expires') {
	                                  options.data.deltaSeconds = deltaSeconds;
	                                }
	                              },
	          "refresher",
	          { type: "literal", value: "refresher", description: "\"refresher\"" },
	          "uas",
	          { type: "literal", value: "uas", description: "\"uas\"" },
	          "uac",
	          { type: "literal", value: "uac", description: "\"uac\"" },
	          function(endpoint) {
	                                if (options.startRule === 'Session_Expires') {
	                                  options.data.refresher = endpoint;
	                                }
	                              },
	          function(deltaSeconds) {
	                                if (options.startRule === 'Min_SE') {
	                                  options.data = deltaSeconds;
	                                }
	                              },
	          "stuns",
	          { type: "literal", value: "stuns", description: "\"stuns\"" },
	          "stun",
	          { type: "literal", value: "stun", description: "\"stun\"" },
	          function(scheme) {
	                                options.data.scheme = scheme; },
	          function(host) {
	                                options.data.host = host; },
	          "?transport=",
	          { type: "literal", value: "?transport=", description: "\"?transport=\"" },
	          "turns",
	          { type: "literal", value: "turns", description: "\"turns\"" },
	          "turn",
	          { type: "literal", value: "turn", description: "\"turn\"" },
	          function() {
	                                options.data.transport = transport; },
	          function() {
	                            options.data = text(); }
	        ],
	
	        peg$bytecode = [
	          peg$decode(". \"\"2 3!"),
	          peg$decode("0\"\"\"1!3#"),
	          peg$decode("0$\"\"1!3%"),
	          peg$decode("0&\"\"1!3'"),
	          peg$decode("7'*# \"7("),
	          peg$decode("0(\"\"1!3)"),
	          peg$decode("0*\"\"1!3+"),
	          peg$decode(".,\"\"2,3-"),
	          peg$decode("..\"\"2.3/"),
	          peg$decode("00\"\"1!31"),
	          peg$decode(".2\"\"2233*\x89 \".4\"\"2435*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("7)*# \"7,"),
	          peg$decode(".F\"\"2F3G*} \".H\"\"2H3I*q \".J\"\"2J3K*e \".L\"\"2L3M*Y \".N\"\"2N3O*M \".P\"\"2P3Q*A \".R\"\"2R3S*5 \".T\"\"2T3U*) \".V\"\"2V3W"),
	          peg$decode("!!.Y\"\"2Y3Z+7$7#+-%7#+#%'#%$## X$\"# X\"# X+! (%"),
	          peg$decode("!! \\7$,#&7$\"+-$7 +#%'\"%$\"# X\"# X*# \" [+@$ \\7$+&$,#&7$\"\"\" X+'%4\"6]\" %$\"# X\"# X"),
	          peg$decode("7.*# \" ["),
	          peg$decode("! \\7'*# \"7(,)&7'*# \"7(\"+A$.8\"\"2839+1%7/+'%4#6^# %$## X$\"# X\"# X"),
	          peg$decode("!! \\72+&$,#&72\"\"\" X+o$ \\! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X,@&! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
	          peg$decode("0_\"\"1!3`*# \"73"),
	          peg$decode("0a\"\"1!3b"),
	          peg$decode("0c\"\"1!3d"),
	          peg$decode("7!*) \"0e\"\"1!3f"),
	          peg$decode("! \\7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x9E$,\x9B&7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
	          peg$decode("! \\7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x92$,\x8F&7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
	          peg$decode(".T\"\"2T3U*\xE3 \".V\"\"2V3W*\xD7 \".i\"\"2i3j*\xCB \".k\"\"2k3l*\xBF \".:\"\"2:3;*\xB3 \".D\"\"2D3E*\xA7 \".2\"\"2233*\x9B \".8\"\"2839*\x8F \".m\"\"2m3n*\x83 \"7&*} \".4\"\"2435*q \".o\"\"2o3p*e \".q\"\"2q3r*Y \".6\"\"2637*M \".>\"\"2>3?*A \".s\"\"2s3t*5 \".u\"\"2u3v*) \"7'*# \"7("),
	          peg$decode("! \\7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v+\u0134$,\u0131&7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v\"\"\" X+! (%"),
	          peg$decode("!7/+A$.P\"\"2P3Q+1%7/+'%4#6w# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.4\"\"2435+1%7/+'%4#6x# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.>\"\"2>3?+1%7/+'%4#6y# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.T\"\"2T3U+1%7/+'%4#6z# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.V\"\"2V3W+1%7/+'%4#6{# %$## X$\"# X\"# X"),
	          peg$decode("!.k\"\"2k3l+1$7/+'%4\"6|\" %$\"# X\"# X"),
	          peg$decode("!7/+7$.i\"\"2i3j+'%4\"6}\" %$\"# X\"# X"),
	          peg$decode("!7/+A$.D\"\"2D3E+1%7/+'%4#6~# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.2\"\"2233+1%7/+'%4#6# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.8\"\"2839+1%7/+'%4#6\x80# %$## X$\"# X\"# X"),
	          peg$decode("!7/+1$7&+'%4\"6\x81\" %$\"# X\"# X"),
	          peg$decode("!7&+1$7/+'%4\"6\x81\" %$\"# X\"# X"),
	          peg$decode("!7=+W$ \\7G*) \"7K*# \"7F,/&7G*) \"7K*# \"7F\"+-%7>+#%'#%$## X$\"# X\"# X"),
	          peg$decode("0\x82\"\"1!3\x83*A \"0\x84\"\"1!3\x85*5 \"0\x86\"\"1!3\x87*) \"73*# \"7."),
	          peg$decode("!!7/+U$7&+K% \\7J*# \"7K,)&7J*# \"7K\"+-%7&+#%'$%$$# X$## X$\"# X\"# X+! (%"),
	          peg$decode("!7/+`$7&+V%! \\7J*# \"7K,)&7J*# \"7K\"+! (%+2%7&+(%4$6\x88$!!%$$# X$## X$\"# X\"# X"),
	          peg$decode("7.*G \".L\"\"2L3M*; \"0\x89\"\"1!3\x8A*/ \"0\x86\"\"1!3\x87*# \"73"),
	          peg$decode("!.m\"\"2m3n+K$0\x8B\"\"1!3\x8C*5 \"0\x8D\"\"1!3\x8E*) \"0\x8F\"\"1!3\x90+#%'\"%$\"# X\"# X"),
	          peg$decode("!7N+Q$.8\"\"2839+A%7O*# \" [+1%7S+'%4$6\x91$ %$$# X$## X$\"# X\"# X"),
	          peg$decode("!7N+k$.8\"\"2839+[%7O*# \" [+K%7S+A%7_+7%7l*# \" [+'%4&6\x92& %$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\x93\"\"1$3\x94*) \"/\x95\"\"1#3\x96+' 4!6\x97!! %"),
	          peg$decode("!7P+b$!.8\"\"2839+-$7R+#%'\"%$\"# X\"# X*# \" [+7%.:\"\"2:3;+'%4#6\x98# %$## X$\"# X\"# X"),
	          peg$decode(" \\7+*) \"7-*# \"7Q+2$,/&7+*) \"7-*# \"7Q\"\"\" X"),
	          peg$decode(".<\"\"2<3=*q \".>\"\"2>3?*e \".@\"\"2@3A*Y \".B\"\"2B3C*M \".D\"\"2D3E*A \".2\"\"2233*5 \".6\"\"2637*) \".4\"\"2435"),
	          peg$decode("! \\7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E,e&7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E\"+& 4!6\x99! %"),
	          peg$decode("!7T+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\x9A! %"),
	          peg$decode("! \\!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X,>&!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X\"+G$7W+=%.J\"\"2J3K*# \" [+'%4#6\x9B# %$## X$\"# X\"# X"),
	          peg$decode(" \\0\x9C\"\"1!3\x9D+,$,)&0\x9C\"\"1!3\x9D\"\"\" X"),
	          peg$decode("!0$\"\"1!3%+A$ \\0\x9E\"\"1!3\x9F,)&0\x9E\"\"1!3\x9F\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!.o\"\"2o3p+A$7Y+7%.q\"\"2q3r+'%4#6\xA0# %$## X$\"# X\"# X"),
	          peg$decode("!!7Z+\xBF$.8\"\"2839+\xAF%7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0838 \"!.\xA1\"\"2\xA13\xA2+\xAF$7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0795 \"!.\xA1\"\"2\xA13\xA2+\x95$7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u070C \"!.\xA1\"\"2\xA13\xA2+{$7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u069D \"!.\xA1\"\"2\xA13\xA2+a$7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X*\u0648 \"!.\xA1\"\"2\xA13\xA2+G$7Z+=%.8\"\"2839+-%7[+#%'$%$$# X$## X$\"# X\"# X*\u060D \"!.\xA1\"\"2\xA13\xA2+-$7[+#%'\"%$\"# X\"# X*\u05EC \"!.\xA1\"\"2\xA13\xA2+-$7Z+#%'\"%$\"# X\"# X*\u05CB \"!7Z+\xA5$.\xA1\"\"2\xA13\xA2+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0538 \"!7Z+\xB6$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x8B%.\xA1\"\"2\xA13\xA2+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0494 \"!7Z+\xC7$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x9C%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+q%.\xA1\"\"2\xA13\xA2+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u03DF \"!7Z+\xD8$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xAD%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x82%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+W%.\xA1\"\"2\xA13\xA2+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0319 \"!7Z+\xE9$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0242 \"!7Z+\u0114$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xE9%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0140 \"!7Z+\u0135$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\u010A%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xDF%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xB4%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x89%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+^%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+3%.\xA1\"\"2\xA13\xA2+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X+& 4!6\xA3! %"),
	          peg$decode("!7#+S$7#*# \" [+C%7#*# \" [+3%7#*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!7Z+=$.8\"\"2839+-%7Z+#%'#%$## X$\"# X\"# X*# \"7\\"),
	          peg$decode("!7]+u$.J\"\"2J3K+e%7]+[%.J\"\"2J3K+K%7]+A%.J\"\"2J3K+1%7]+'%4'6\xA4' %$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!.\xA5\"\"2\xA53\xA6+3$0\xA7\"\"1!3\xA8+#%'\"%$\"# X\"# X*\xA0 \"!.\xA9\"\"2\xA93\xAA+=$0\xAB\"\"1!3\xAC+-%7!+#%'#%$## X$\"# X\"# X*o \"!.\xAD\"\"2\xAD3\xAE+7$7!+-%7!+#%'#%$## X$\"# X\"# X*D \"!0\xAF\"\"1!3\xB0+-$7!+#%'\"%$\"# X\"# X*# \"7!"),
	          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\xB1!! %"),
	          peg$decode(" \\!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X\""),
	          peg$decode("7a*A \"7b*; \"7c*5 \"7d*/ \"7e*) \"7f*# \"7g"),
	          peg$decode("!/\xB2\"\"1*3\xB3+b$/\xB4\"\"1#3\xB5*G \"/\xB6\"\"1#3\xB7*; \"/\xB8\"\"1$3\xB9*/ \"/\xBA\"\"1#3\xBB*# \"76+(%4\"6\xBC\"! %$\"# X\"# X"),
	          peg$decode("!/\xBD\"\"1%3\xBE+J$/\xBF\"\"1%3\xC0*/ \"/\xC1\"\"1\"3\xC2*# \"76+(%4\"6\xC3\"! %$\"# X\"# X"),
	          peg$decode("!/\xC4\"\"1'3\xC5+2$7\x8F+(%4\"6\xC6\"! %$\"# X\"# X"),
	          peg$decode("!/\xC7\"\"1$3\xC8+2$7\xEF+(%4\"6\xC9\"! %$\"# X\"# X"),
	          peg$decode("!/\xCA\"\"1&3\xCB+2$7T+(%4\"6\xCC\"! %$\"# X\"# X"),
	          peg$decode("!/\xCD\"\"1\"3\xCE+R$!.>\"\"2>3?+-$76+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xCF\" %$\"# X\"# X"),
	          peg$decode("!7h+T$!.>\"\"2>3?+-$7i+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xD0\"\"! %$\"# X\"# X"),
	          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
	          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
	          peg$decode("7k*) \"7+*# \"7-"),
	          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".8\"\"2839*A \".<\"\"2<3=*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
	          peg$decode("!.6\"\"2637+u$7m+k% \\!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X,>&!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X\"+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7n+C$.>\"\"2>3?+3%7o+)%4#6\xD1#\"\" %$## X$\"# X\"# X"),
	          peg$decode(" \\7p*) \"7+*# \"7-+2$,/&7p*) \"7+*# \"7-\"\"\" X"),
	          peg$decode(" \\7p*) \"7+*# \"7-,/&7p*) \"7+*# \"7-\""),
	          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".6\"\"2637*A \".8\"\"2839*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
	          peg$decode("7\x90*# \"7r"),
	          peg$decode("!7\x8F+K$7'+A%7s+7%7'+-%7\x84+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7M*# \"7t"),
	          peg$decode("!7+G$.8\"\"2839+7%7u*# \"7x+'%4#6\xD2# %$## X$\"# X\"# X"),
	          peg$decode("!7v*# \"7w+N$!.6\"\"2637+-$7\x83+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!.\xD3\"\"2\xD33\xD4+=$7\x80+3%7w*# \" [+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!.4\"\"2435+-$7{+#%'\"%$\"# X\"# X"),
	          peg$decode("!7z+5$ \\7y,#&7y\"+#%'\"%$\"# X\"# X"),
	          peg$decode("7**) \"7+*# \"7-"),
	          peg$decode("7+*\x8F \"7-*\x89 \".2\"\"2233*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("!7|+k$ \\!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X,>&!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7~,#&7~\"+k$ \\!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode(" \\7~,#&7~\""),
	          peg$decode("7+*w \"7-*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("!7\"+\x8D$ \\7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K,M&7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K\"+'%4\"6\xD5\" %$\"# X\"# X"),
	          peg$decode("7\x81*# \"7\x82"),
	          peg$decode("!!7O+3$.:\"\"2:3;+#%'\"%$\"# X\"# X*# \" [+-$7S+#%'\"%$\"# X\"# X*# \" ["),
	          peg$decode(" \\7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A+\x8C$,\x89&7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A\"\"\" X"),
	          peg$decode(" \\7y,#&7y\""),
	          peg$decode("!/\x95\"\"1#3\xD6+y$.4\"\"2435+i% \\7!+&$,#&7!\"\"\" X+P%.J\"\"2J3K+@% \\7!+&$,#&7!\"\"\" X+'%4%6\xD7% %$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode(".\xD8\"\"2\xD83\xD9"),
	          peg$decode(".\xDA\"\"2\xDA3\xDB"),
	          peg$decode(".\xDC\"\"2\xDC3\xDD"),
	          peg$decode(".\xDE\"\"2\xDE3\xDF"),
	          peg$decode(".\xE0\"\"2\xE03\xE1"),
	          peg$decode(".\xE2\"\"2\xE23\xE3"),
	          peg$decode(".\xE4\"\"2\xE43\xE5"),
	          peg$decode(".\xE6\"\"2\xE63\xE7"),
	          peg$decode(".\xE8\"\"2\xE83\xE9"),
	          peg$decode(".\xEA\"\"2\xEA3\xEB"),
	          peg$decode("!7\x85*S \"7\x86*M \"7\x88*G \"7\x89*A \"7\x8A*; \"7\x8B*5 \"7\x8C*/ \"7\x8D*) \"7\x8E*# \"76+& 4!6\xEC! %"),
	          peg$decode("!7\x84+K$7'+A%7\x91+7%7'+-%7\x93+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!7\x92+' 4!6\xED!! %"),
	          peg$decode("!7!+7$7!+-%7!+#%'#%$## X$\"# X\"# X"),
	          peg$decode("! \\7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(,G&7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(\"+& 4!6\xEE! %"),
	          peg$decode("!7\xB5+_$ \\!7A+-$7\xB5+#%'\"%$\"# X\"# X,8&!7A+-$7\xB5+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!79+R$!.:\"\"2:3;+-$79+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xEF\" %$\"# X\"# X"),
	          peg$decode("!7:*j \"!7\x97+_$ \\!7A+-$7\x97+#%'\"%$\"# X\"# X,8&!7A+-$7\x97+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+& 4!6\xF0! %"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\x9A+#%'\"%$\"# X\"# X,8&!7B+-$7\x9A+#%'\"%$\"# X\"# X\"+'%4\"6\xF1\" %$\"# X\"# X"),
	          peg$decode("!7\x99*# \" [+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!!76+_$ \\!7.+-$76+#%'\"%$\"# X\"# X,8&!7.+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X*# \"7H+' 4!6\xF2!! %"),
	          peg$decode("7\x9B*) \"7\x9C*# \"7\x9F"),
	          peg$decode("!/\xF3\"\"1!3\xF4+<$7<+2%7\x9E+(%4#6\xF5#! %$## X$\"# X\"# X"),
	          peg$decode("!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\xF8#! %$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\xF9!! %"),
	          peg$decode("!.\xFA\"\"2\xFA3\xFB+x$!.J\"\"2J3K+S$7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'$%$$# X$## X$\"# X\"# X*# \" [+'%4\"6\xFC\" %$\"# X\"# X"),
	          peg$decode("!76+N$!7<+-$7\xA0+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xFD\"\"! %$\"# X\"# X"),
	          peg$decode("76*) \"7T*# \"7H"),
	          peg$decode("!7\xA2+_$ \\!7B+-$7\xA3+#%'\"%$\"# X\"# X,8&!7B+-$7\xA3+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!/\xFE\"\"1&3\xFF*G \"/\u0100\"\"1'3\u0101*; \"/\u0102\"\"1$3\u0103*/ \"/\u0104\"\"1%3\u0105*# \"76+& 4!6\u0106! %"),
	          peg$decode("7\xA4*# \"7\x9F"),
	          peg$decode("!/\u0107\"\"1(3\u0108+O$7<+E%/\u0109\"\"1(3\u010A*/ \"/\u010B\"\"1(3\u010C*# \"76+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u010D!! %"),
	          peg$decode("!7\xA8+& 4!6\u010E! %"),
	          peg$decode("!7\xA9+s$7;+i%7\xAE+_% \\!7B+-$7\xAF+#%'\"%$\"# X\"# X,8&!7B+-$7\xAF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xAA*# \"7\xAB"),
	          peg$decode("/\u010F\"\"1$3\u0110*S \"/\u0111\"\"1%3\u0112*G \"/\u0113\"\"1%3\u0114*; \"/\u0115\"\"1%3\u0116*/ \"/\u0117\"\"1+3\u0118*# \"7\xAC"),
	          peg$decode("/\u0119\"\"1'3\u011A*/ \"/\u011B\"\"1)3\u011C*# \"7\xAC"),
	          peg$decode("76*# \"7\xAD"),
	          peg$decode("!/\u011D\"\"1\"3\u011E+-$76+#%'\"%$\"# X\"# X"),
	          peg$decode("7\xAC*# \"76"),
	          peg$decode("!76+7$7<+-%7\xB0+#%'#%$## X$\"# X\"# X"),
	          peg$decode("76*# \"7H"),
	          peg$decode("!7\xB2+7$7.+-%7\x8F+#%'#%$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u011F!! %"),
	          peg$decode("!7\x9D+' 4!6\u0120!! %"),
	          peg$decode("!7\xB5+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u0121\"!!%$\"# X\"# X"),
	          peg$decode("!!77+k$ \\!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X,>&!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xB7+#%'\"%$\"# X\"# X,8&!7B+-$7\xB7+#%'\"%$\"# X\"# X\"+'%4\"6\u0122\" %$\"# X\"# X"),
	          peg$decode("7\xB8*# \"7\x9F"),
	          peg$decode("!/\u0123\"\"1#3\u0124+<$7<+2%76+(%4#6\u0125#! %$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u0126!! %"),
	          peg$decode("!7\x9D+' 4!6\u0127!! %"),
	          peg$decode("! \\7\x99,#&7\x99\"+\x81$7@+w%7M+m%7?+c% \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4%6\u0128% %$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xBD"),
	          peg$decode("!/\u0129\"\"1&3\u012A+s$7.+i%7\xC0+_% \\!7A+-$7\xC0+#%'\"%$\"# X\"# X,8&!7A+-$7\xC0+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X*# \"7\xBE"),
	          peg$decode("!76+s$7.+i%7\xBF+_% \\!7A+-$7\xBF+#%'\"%$\"# X\"# X,8&!7A+-$7\xBF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!76+=$7<+3%76*# \"7H+#%'#%$## X$\"# X\"# X"),
	          peg$decode("7\xC1*G \"7\xC3*A \"7\xC5*; \"7\xC7*5 \"7\xC8*/ \"7\xC9*) \"7\xCA*# \"7\xBF"),
	          peg$decode("!/\u012B\"\"1%3\u012C+7$7<+-%7\xC2+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7I+' 4!6\u012D!! %"),
	          peg$decode("!/\u012E\"\"1&3\u012F+\xA5$7<+\x9B%7D+\x91%7\xC4+\x87% \\! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X,G&! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7t*# \"7w"),
	          peg$decode("!/\u0130\"\"1%3\u0131+7$7<+-%7\xC6+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7I+' 4!6\u0132!! %"),
	          peg$decode("!/\u0133\"\"1&3\u0134+<$7<+2%7I+(%4#6\u0135#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0136\"\"1%3\u0137+_$7<+U%!/\u0138\"\"1$3\u0139+& 4!6\u013A! %*4 \"!/\u013B\"\"1%3\u013C+& 4!6\u013D! %+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!/\u013E\"\"1)3\u013F+T$7<+J%/\u0140\"\"1#3\u0141*/ \"/\u0142\"\"1(3\u0143*# \"76+(%4#6\u0144#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0145\"\"1#3\u0146+\x9E$7<+\x94%7D+\x8A%!7\xCB+k$ \\!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X,>&!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+-%7E+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\u0147\"\"1(3\u0148*/ \"/\u0149\"\"1$3\u014A*# \"76+' 4!6\u014B!! %"),
	          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\xCE+K$7.+A%7\xCE+7%7.+-%7\x8F+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u014C!! %"),
	          peg$decode("!7\xD0+c$ \\!7A+-$7\xD0+#%'\"%$\"# X\"# X,8&!7A+-$7\xD0+#%'\"%$\"# X\"# X\"+'%4\"6\u014D\" %$\"# X\"# X"),
	          peg$decode("!7\x98+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014E\" %$\"# X\"# X"),
	          peg$decode("!7L*T \"7\x98*N \"!7@*# \" [+=$7t+3%7?*# \" [+#%'#%$## X$\"# X\"# X+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014F\" %$\"# X\"# X"),
	          peg$decode("!7\xD3+c$ \\!7B+-$7\xD4+#%'\"%$\"# X\"# X,8&!7B+-$7\xD4+#%'\"%$\"# X\"# X\"+'%4\"6\u0150\" %$\"# X\"# X"),
	          peg$decode("!7\x95+& 4!6\u0151! %"),
	          peg$decode("!/\u0152\"\"1(3\u0153+<$7<+2%76+(%4#6\u0154#! %$## X$\"# X\"# X*j \"!/\u0155\"\"1&3\u0156+<$7<+2%76+(%4#6\u0157#! %$## X$\"# X\"# X*: \"!/\u0158\"\"1*3\u0159+& 4!6\u015A! %*# \"7\x9F"),
	          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u015D!! %"),
	          peg$decode("!7\xD7+_$ \\!7A+-$7\xD7+#%'\"%$\"# X\"# X,8&!7A+-$7\xD7+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\x98+_$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u015E!! %"),
	          peg$decode("!7\xDA+_$ \\!7B+-$7\xDB+#%'\"%$\"# X\"# X,8&!7B+-$7\xDB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!/\u015F\"\"1&3\u0160*; \"/\u0161\"\"1'3\u0162*/ \"/\u0163\"\"1*3\u0164*# \"76+& 4!6\u0165! %"),
	          peg$decode("!/\u0166\"\"1&3\u0167+<$7<+2%7\xDC+(%4#6\u0168#! %$## X$\"# X\"# X*\x83 \"!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\u0169#! %$## X$\"# X\"# X*S \"!/\u016A\"\"1+3\u016B+<$7<+2%7\x9D+(%4#6\u016C#! %$## X$\"# X\"# X*# \"7\x9F"),
	          peg$decode("/\u016D\"\"1+3\u016E*k \"/\u016F\"\"1)3\u0170*_ \"/\u0171\"\"1(3\u0172*S \"/\u0173\"\"1'3\u0174*G \"/\u0175\"\"1&3\u0176*; \"/\u0177\"\"1*3\u0178*/ \"/\u0179\"\"1)3\u017A*# \"76"),
	          peg$decode("71*# \" ["),
	          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u017B!! %"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xE0+#%'\"%$\"# X\"# X,8&!7B+-$7\xE0+#%'\"%$\"# X\"# X\"+'%4\"6\u017C\" %$\"# X\"# X"),
	          peg$decode("7\xB8*# \"7\x9F"),
	          peg$decode("!7\xE2+_$ \\!7A+-$7\xE2+#%'\"%$\"# X\"# X,8&!7A+-$7\xE2+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\xE9+s$7.+i%7\xEC+_% \\!7B+-$7\xE3+#%'\"%$\"# X\"# X,8&!7B+-$7\xE3+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xE4*; \"7\xE5*5 \"7\xE6*/ \"7\xE7*) \"7\xE8*# \"7\x9F"),
	          peg$decode("!/\u017D\"\"1#3\u017E+<$7<+2%7\xEF+(%4#6\u017F#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0180\"\"1%3\u0181+<$7<+2%7T+(%4#6\u0182#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0183\"\"1(3\u0184+B$7<+8%7\\*# \"7Y+(%4#6\u0185#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0186\"\"1&3\u0187+<$7<+2%76+(%4#6\u0188#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0189\"\"1%3\u018A+T$!7<+5$ \\7!,#&7!\"+#%'\"%$\"# X\"# X*# \" [+'%4\"6\u018B\" %$\"# X\"# X"),
	          peg$decode("!7\xEA+K$7;+A%76+7%7;+-%7\xEB+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\x95\"\"1#3\xD6*# \"76+' 4!6\u018C!! %"),
	          peg$decode("!/\xB4\"\"1#3\u018D*G \"/\xB6\"\"1#3\u018E*; \"/\xBA\"\"1#3\u018F*/ \"/\xB8\"\"1$3\u0190*# \"76+' 4!6\u0191!! %"),
	          peg$decode("!7\xED+H$!7C+-$7\xEE+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\u0192! %"),
	          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\u0193!! %"),
	          peg$decode("!!7!+C$7!*# \" [+3%7!*# \" [+#%'#%$## X$\"# X\"# X+' 4!6\u0194!! %"),
	          peg$decode("7\xBD"),
	          peg$decode("!7\x9D+d$ \\!7B+-$7\xF2+#%'\"%$\"# X\"# X,8&!7B+-$7\xF2+#%'\"%$\"# X\"# X\"+(%4\"6\u0195\"!!%$\"# X\"# X"),
	          peg$decode("7\xF3*# \"7\x9F"),
	          peg$decode("!.\u0196\"\"2\u01963\u0197+N$7<+D%.\u0198\"\"2\u01983\u0199*) \".\u019A\"\"2\u019A3\u019B+(%4#6\u019C#! %$## X$\"# X\"# X"),
	          peg$decode("!7\x9D+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u019D\"!!%$\"# X\"# X"),
	          peg$decode("!76+7$70+-%7\xF6+#%'#%$## X$\"# X\"# X"),
	          peg$decode(" \\72*) \"74*# \"7.,/&72*) \"74*# \"7.\""),
	          peg$decode(" \\7%,#&7%\""),
	          peg$decode("!7\xF9+=$.8\"\"2839+-%7\xFA+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!/\u019E\"\"1%3\u019F*) \"/\u01A0\"\"1$3\u01A1+' 4!6\u01A2!! %"),
	          peg$decode("!7\xFB+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\\*) \"7X*# \"7\x82+' 4!6\u01A3!! %"),
	          peg$decode("! \\7\xFD*) \"7-*# \"7\xFE,/&7\xFD*) \"7-*# \"7\xFE\"+! (%"),
	          peg$decode("7\"*S \"7!*M \".F\"\"2F3G*A \".J\"\"2J3K*5 \".H\"\"2H3I*) \".N\"\"2N3O"),
	          peg$decode(".L\"\"2L3M*\x95 \".B\"\"2B3C*\x89 \".<\"\"2<3=*} \".R\"\"2R3S*q \".T\"\"2T3U*e \".V\"\"2V3W*Y \".P\"\"2P3Q*M \".@\"\"2@3A*A \".D\"\"2D3E*5 \".2\"\"2233*) \".>\"\"2>3?"),
	          peg$decode("!7\u0100+h$.8\"\"2839+X%7\xFA+N%!.\u01A4\"\"2\u01A43\u01A5+-$7\xEB+#%'\"%$\"# X\"# X*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\u01A6\"\"1%3\u01A7*) \"/\u01A8\"\"1$3\u01A9+' 4!6\u01A2!! %"),
	          peg$decode("!7\xEB+Q$/\xB4\"\"1#3\xB5*7 \"/\xB6\"\"1#3\xB7*+ \" \\7+,#&7+\"+'%4\"6\u01AA\" %$\"# X\"# X"),
	          peg$decode("!7\u0104+\x8F$.F\"\"2F3G+%7\u0103+u%.F\"\"2F3G+e%7\u0103+[%.F\"\"2F3G+K%7\u0103+A%.F\"\"2F3G+1%7\u0105+'%4)6\u01AB) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!7\u0103+-$7\u0103+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\u0103+7$7\u0103+-%7\u0103+#%'#%$## X$\"# X\"# X")
	        ],
	
	        peg$currPos          = 0,
	        peg$reportedPos      = 0,
	        peg$cachedPos        = 0,
	        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,
	
	        peg$result;
	
	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleIndices)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }
	
	      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
	    }
	
	    function text() {
	      return input.substring(peg$reportedPos, peg$currPos);
	    }
	
	    function offset() {
	      return peg$reportedPos;
	    }
	
	    function line() {
	      return peg$computePosDetails(peg$reportedPos).line;
	    }
	
	    function column() {
	      return peg$computePosDetails(peg$reportedPos).column;
	    }
	
	    function expected(description) {
	      throw peg$buildException(
	        null,
	        [{ type: "other", description: description }],
	        peg$reportedPos
	      );
	    }
	
	    function error(message) {
	      throw peg$buildException(message, null, peg$reportedPos);
	    }
	
	    function peg$computePosDetails(pos) {
	      function advance(details, startPos, endPos) {
	        var p, ch;
	
	        for (p = startPos; p < endPos; p++) {
	          ch = input.charAt(p);
	          if (ch === "\n") {
	            if (!details.seenCR) { details.line++; }
	            details.column = 1;
	            details.seenCR = false;
	          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	            details.line++;
	            details.column = 1;
	            details.seenCR = true;
	          } else {
	            details.column++;
	            details.seenCR = false;
	          }
	        }
	      }
	
	      if (peg$cachedPos !== pos) {
	        if (peg$cachedPos > pos) {
	          peg$cachedPos = 0;
	          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
	        }
	        advance(peg$cachedPosDetails, peg$cachedPos, pos);
	        peg$cachedPos = pos;
	      }
	
	      return peg$cachedPosDetails;
	    }
	
	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }
	
	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }
	
	      peg$maxFailExpected.push(expected);
	    }
	
	    function peg$buildException(message, expected, pos) {
	      function cleanupExpected(expected) {
	        var i = 1;
	
	        expected.sort(function(a, b) {
	          if (a.description < b.description) {
	            return -1;
	          } else if (a.description > b.description) {
	            return 1;
	          } else {
	            return 0;
	          }
	        });
	
	        while (i < expected.length) {
	          if (expected[i - 1] === expected[i]) {
	            expected.splice(i, 1);
	          } else {
	            i++;
	          }
	        }
	      }
	
	      function buildMessage(expected, found) {
	        function stringEscape(s) {
	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
	
	          return s
	            .replace(/\\/g,   '\\\\')
	            .replace(/"/g,    '\\"')
	            .replace(/\x08/g, '\\b')
	            .replace(/\t/g,   '\\t')
	            .replace(/\n/g,   '\\n')
	            .replace(/\f/g,   '\\f')
	            .replace(/\r/g,   '\\r')
	            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
	            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
	            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
	            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
	        }
	
	        var expectedDescs = new Array(expected.length),
	            expectedDesc, foundDesc, i;
	
	        for (i = 0; i < expected.length; i++) {
	          expectedDescs[i] = expected[i].description;
	        }
	
	        expectedDesc = expected.length > 1
	          ? expectedDescs.slice(0, -1).join(", ")
	              + " or "
	              + expectedDescs[expected.length - 1]
	          : expectedDescs[0];
	
	        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	
	        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	      }
	
	      var posDetails = peg$computePosDetails(pos),
	          found      = pos < input.length ? input.charAt(pos) : null;
	
	      if (expected !== null) {
	        cleanupExpected(expected);
	      }
	
	      return new SyntaxError(
	        message !== null ? message : buildMessage(expected, found),
	        expected,
	        found,
	        pos,
	        posDetails.line,
	        posDetails.column
	      );
	    }
	
	    function peg$decode(s) {
	      var bc = new Array(s.length), i;
	
	      for (i = 0; i < s.length; i++) {
	        bc[i] = s.charCodeAt(i) - 32;
	      }
	
	      return bc;
	    }
	
	    function peg$parseRule(index) {
	      var bc    = peg$bytecode[index],
	          ip    = 0,
	          ips   = [],
	          end   = bc.length,
	          ends  = [],
	          stack = [],
	          params, i;
	
	      function protect(object) {
	        return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;
	      }
	
	      while (true) {
	        while (ip < end) {
	          switch (bc[ip]) {
	            case 0:
	              stack.push(protect(peg$consts[bc[ip + 1]]));
	              ip += 2;
	              break;
	
	            case 1:
	              stack.push(peg$currPos);
	              ip++;
	              break;
	
	            case 2:
	              stack.pop();
	              ip++;
	              break;
	
	            case 3:
	              peg$currPos = stack.pop();
	              ip++;
	              break;
	
	            case 4:
	              stack.length -= bc[ip + 1];
	              ip += 2;
	              break;
	
	            case 5:
	              stack.splice(-2, 1);
	              ip++;
	              break;
	
	            case 6:
	              stack[stack.length - 2].push(stack.pop());
	              ip++;
	              break;
	
	            case 7:
	              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
	              ip += 2;
	              break;
	
	            case 8:
	              stack.pop();
	              stack.push(input.substring(stack[stack.length - 1], peg$currPos));
	              ip++;
	              break;
	
	            case 9:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1]) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 10:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1] === peg$FAILED) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 11:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1] !== peg$FAILED) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 12:
	              if (stack[stack.length - 1] !== peg$FAILED) {
	                ends.push(end);
	                ips.push(ip);
	
	                end = ip + 2 + bc[ip + 1];
	                ip += 2;
	              } else {
	                ip += 2 + bc[ip + 1];
	              }
	
	              break;
	
	            case 13:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (input.length > peg$currPos) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 14:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 15:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 16:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 17:
	              stack.push(input.substr(peg$currPos, bc[ip + 1]));
	              peg$currPos += bc[ip + 1];
	              ip += 2;
	              break;
	
	            case 18:
	              stack.push(peg$consts[bc[ip + 1]]);
	              peg$currPos += peg$consts[bc[ip + 1]].length;
	              ip += 2;
	              break;
	
	            case 19:
	              stack.push(peg$FAILED);
	              if (peg$silentFails === 0) {
	                peg$fail(peg$consts[bc[ip + 1]]);
	              }
	              ip += 2;
	              break;
	
	            case 20:
	              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];
	              ip += 2;
	              break;
	
	            case 21:
	              peg$reportedPos = peg$currPos;
	              ip++;
	              break;
	
	            case 22:
	              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
	              for (i = 0; i < bc[ip + 3]; i++) {
	                params[i] = stack[stack.length - 1 - params[i]];
	              }
	
	              stack.splice(
	                stack.length - bc[ip + 2],
	                bc[ip + 2],
	                peg$consts[bc[ip + 1]].apply(null, params)
	              );
	
	              ip += 4 + bc[ip + 3];
	              break;
	
	            case 23:
	              stack.push(peg$parseRule(bc[ip + 1]));
	              ip += 2;
	              break;
	
	            case 24:
	              peg$silentFails++;
	              ip++;
	              break;
	
	            case 25:
	              peg$silentFails--;
	              ip++;
	              break;
	
	            default:
	              throw new Error("Invalid opcode: " + bc[ip] + ".");
	          }
	        }
	
	        if (ends.length > 0) {
	          end = ends.pop();
	          ip = ips.pop();
	        } else {
	          break;
	        }
	      }
	
	      return stack[0];
	    }
	
	
	      options.data = {}; // Object to which header attributes will be assigned during parsing
	
	      function list (first, rest) {
	        return [first].concat(rest);
	      }
	
	
	    peg$result = peg$parseRule(peg$startRuleIndex);
	
	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail({ type: "end", description: "end of input" });
	      }
	
	      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
	    }
	  }
	
	  return {
	    SyntaxError: SyntaxError,
	    parse:       parse
	  };
	})();


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var toplevel = global.window || global;
	
	function getPrefixedProperty (object, name) {
	  if (object == null) {
	    return;
	  }
	  var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
	  var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];
	  for (var i in prefixedNames) {
	    var property = object[prefixedNames[i]];
	    if (property) {
	      return property.bind(object);
	    }
	  }
	}
	
	module.exports = {
	  WebSocket: toplevel.WebSocket,
	  Transport: __webpack_require__(246),
	  open: toplevel.open,
	  Promise: toplevel.Promise,
	  timers: toplevel,
	
	  // Console is not defined in ECMAScript, so just in case...
	  console: toplevel.console || {
	    debug: function () {},
	    log: function () {},
	    warn: function () {},
	    error: function () {}
	  },
	
	  MediaStream: getPrefixedProperty(toplevel, 'MediaStream'),
	  getUserMedia: getPrefixedProperty(toplevel.navigator, 'getUserMedia'),
	  RTCPeerConnection: getPrefixedProperty(toplevel, 'RTCPeerConnection'),
	  RTCSessionDescription: getPrefixedProperty(toplevel, 'RTCSessionDescription'),
	
	  addEventListener: getPrefixedProperty(toplevel, 'addEventListener'),
	  HTMLMediaElement: toplevel.HTMLMediaElement,
	
	  attachMediaStream: toplevel.attachMediaStream,
	  createObjectURL: toplevel.URL && toplevel.URL.createObjectURL,
	  revokeObjectURL: toplevel.URL && toplevel.URL.revokeObjectURL
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 246 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Transport
	 */
	
	/**
	 * @augments SIP
	 * @class Transport
	 * @param {SIP.UA} ua
	 * @param {Object} server ws_server Object
	 */
	module.exports = function (SIP, WebSocket) {
	var Transport,
	  C = {
	    // Transport status codes
	    STATUS_READY:        0,
	    STATUS_DISCONNECTED: 1,
	    STATUS_ERROR:        2
	  };
	
	/**
	 * Compute an amount of time in seconds to wait before sending another
	 * keep-alive.
	 * @returns {Number}
	 */
	function computeKeepAliveTimeout(upperBound) {
	  var lowerBound = upperBound * 0.8;
	  return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);
	}
	
	Transport = function(ua, server) {
	
	  this.logger = ua.getLogger('sip.transport');
	  this.ua = ua;
	  this.ws = null;
	  this.server = server;
	  this.reconnection_attempts = 0;
	  this.closed = false;
	  this.connected = false;
	  this.reconnectTimer = null;
	  this.lastTransportError = {};
	
	  this.keepAliveInterval = ua.configuration.keepAliveInterval;
	  this.keepAliveTimeout = null;
	  this.keepAliveTimer = null;
	
	  this.ua.transport = this;
	
	  // Connect
	  this.connect();
	};
	
	Transport.prototype = {
	  /**
	   * Send a message.
	   * @param {SIP.OutgoingRequest|String} msg
	   * @returns {Boolean}
	   */
	  send: function(msg) {
	    var message = msg.toString();
	
	    if(this.ws && this.ws.readyState === WebSocket.OPEN) {
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('sending WebSocket message:\n\n' + message + '\n');
	      }
	      this.ws.send(message);
	      return true;
	    } else {
	      this.logger.warn('unable to send message, WebSocket is not open');
	      return false;
	    }
	  },
	
	  /**
	   * Send a keep-alive (a double-CRLF sequence).
	   * @private
	   * @returns {Boolean}
	   */
	  sendKeepAlive: function() {
	    if(this.keepAliveTimeout) { return; }
	
	    this.keepAliveTimeout = SIP.Timers.setTimeout(function() {
	      this.ua.emit('keepAliveTimeout');
	    }.bind(this), 10000);
	
	    return this.send('\r\n\r\n');
	  },
	
	  /**
	   * Start sending keep-alives.
	   * @private
	   */
	  startSendingKeepAlives: function() {
	    if (this.keepAliveInterval && !this.keepAliveTimer) {
	      this.keepAliveTimer = SIP.Timers.setTimeout(function() {
	        this.sendKeepAlive();
	        this.keepAliveTimer = null;
	        this.startSendingKeepAlives();
	      }.bind(this), computeKeepAliveTimeout(this.keepAliveInterval));
	    }
	  },
	
	  /**
	   * Stop sending keep-alives.
	   * @private
	   */
	  stopSendingKeepAlives: function() {
	    SIP.Timers.clearTimeout(this.keepAliveTimer);
	    SIP.Timers.clearTimeout(this.keepAliveTimeout);
	    this.keepAliveTimer = null;
	    this.keepAliveTimeout = null;
	  },
	
	  /**
	  * Disconnect socket.
	  */
	  disconnect: function() {
	    if(this.ws) {
	      // Clear reconnectTimer
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	
	      this.stopSendingKeepAlives();
	
	      this.closed = true;
	      this.logger.log('closing WebSocket ' + this.server.ws_uri);
	      this.ws.close();
	    }
	
	    if (this.reconnectTimer !== null) {
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	      this.reconnectTimer = null;
	      this.ua.emit('disconnected', {
	        transport: this,
	        code: this.lastTransportError.code,
	        reason: this.lastTransportError.reason
	      });
	    }
	  },
	
	  /**
	  * Connect socket.
	  */
	  connect: function() {
	    var transport = this;
	
	    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
	      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');
	      return false;
	    }
	
	    if(this.ws) {
	      this.ws.close();
	    }
	
	    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);
	    this.ua.onTransportConnecting(this,
	      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);
	
	    try {
	      this.ws = new WebSocket(this.server.ws_uri, 'sip');
	    } catch(e) {
	      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);
	    }
	
	    this.ws.binaryType = 'arraybuffer';
	
	    this.ws.onopen = function() {
	      transport.onOpen();
	    };
	
	    this.ws.onclose = function(e) {
	      transport.onClose(e);
	    };
	
	    this.ws.onmessage = function(e) {
	      transport.onMessage(e);
	    };
	
	    this.ws.onerror = function(e) {
	      transport.onError(e);
	    };
	  },
	
	  // Transport Event Handlers
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onOpen: function() {
	    this.connected = true;
	
	    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');
	    // Clear reconnectTimer since we are not disconnected
	    if (this.reconnectTimer !== null) {
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	      this.reconnectTimer = null;
	    }
	    // Reset reconnection_attempts
	    this.reconnection_attempts = 0;
	    // Disable closed
	    this.closed = false;
	    // Trigger onTransportConnected callback
	    this.ua.onTransportConnected(this);
	    // Start sending keep-alives
	    this.startSendingKeepAlives();
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onClose: function(e) {
	    var connected_before = this.connected;
	
	    this.lastTransportError.code = e.code;
	    this.lastTransportError.reason = e.reason;
	
	    this.stopSendingKeepAlives();
	
	    if (this.reconnection_attempts > 0) {
	      this.logger.log('Reconnection attempt ' + this.reconnection_attempts + ' failed (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
	      this.reconnect();
	    } else {
	      this.connected = false;
	      this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
	
	      if(e.wasClean === false) {
	        this.logger.warn('WebSocket abrupt disconnection');
	      }
	      // Transport was connected
	      if(connected_before === true) {
	        this.ua.onTransportClosed(this);
	        // Check whether the user requested to close.
	        if(!this.closed) {
	          this.reconnect();
	        } else {
	          this.ua.emit('disconnected', {
	            transport: this,
	            code: this.lastTransportError.code,
	            reason: this.lastTransportError.reason
	          });
	
	        }
	      } else {
	        // This is the first connection attempt
	        //Network error
	        this.ua.onTransportError(this);
	      }
	    }
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onMessage: function(e) {
	    var message, transaction,
	      data = e.data;
	
	    // CRLF Keep Alive response from server. Ignore it.
	    if(data === '\r\n') {
	      SIP.Timers.clearTimeout(this.keepAliveTimeout);
	      this.keepAliveTimeout = null;
	
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket message with CRLF Keep Alive response');
	      }
	
	      return;
	    }
	
	    // WebSocket binary message.
	    else if (typeof data !== 'string') {
	      try {
	        data = String.fromCharCode.apply(null, new Uint8Array(data));
	      } catch(evt) {
	        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');
	        return;
	      }
	
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket binary message:\n\n' + data + '\n');
	      }
	    }
	
	    // WebSocket text message.
	    else {
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket text message:\n\n' + data + '\n');
	      }
	    }
	
	    message = SIP.Parser.parseMessage(data, this.ua);
	
	    if (!message) {
	      return;
	    }
	
	    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {
	      return;
	    }
	
	    // Do some sanity check
	    if(SIP.sanityCheck(message, this.ua, this)) {
	      if(message instanceof SIP.IncomingRequest) {
	        message.transport = this;
	        this.ua.receiveRequest(message);
	      } else if(message instanceof SIP.IncomingResponse) {
	        /* Unike stated in 18.1.2, if a response does not match
	        * any transaction, it is discarded here and no passed to the core
	        * in order to be discarded there.
	        */
	        switch(message.method) {
	          case SIP.C.INVITE:
	            transaction = this.ua.transactions.ict[message.via_branch];
	            if(transaction) {
	              transaction.receiveResponse(message);
	            }
	            break;
	          case SIP.C.ACK:
	            // Just in case ;-)
	            break;
	          default:
	            transaction = this.ua.transactions.nict[message.via_branch];
	            if(transaction) {
	              transaction.receiveResponse(message);
	            }
	            break;
	        }
	      }
	    }
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onError: function(e) {
	    this.logger.warn('WebSocket connection error: ' + JSON.stringify(e));
	  },
	
	  /**
	  * Reconnection attempt logic.
	  * @private
	  */
	  reconnect: function() {
	    var transport = this;
	
	    this.reconnection_attempts += 1;
	
	    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {
	      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);
	      this.ua.onTransportError(this);
	    } else if (this.reconnection_attempts === 1) {
	      this.logger.log('Connection to WebSocket ' + this.server.ws_uri + ' severed, attempting first reconnect');
	      transport.connect();
	    } else {
	      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');
	
	      this.reconnectTimer = SIP.Timers.setTimeout(function() {
	        transport.connect();
	        transport.reconnectTimer = null;
	      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);
	    }
	  }
	};
	
	Transport.C = C;
	return Transport;
	};


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA4MWNmM2M5YThkNGRjMmY5YWMzOCIsIndlYnBhY2s6Ly8vLi9zcmMvcmMtcGhvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2FkZC1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yaW5nY2VudHJhbC9idWlsZC9yaW5nY2VudHJhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwid2VicGFjazovLy8uL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vL3ZlcnR4IChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpbmdjZW50cmFsL34vd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwid2VicGFjazovLy8uL34vcHVibnViL21vZGVybi9kaXN0L3B1Ym51Yi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpbmdjZW50cmFsLWNsaWVudC9idWlsZC9yaW5nY2VudHJhbC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yYy1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9zeW1ib2wtbWFwLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvZW51bS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlZHV4LWhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2V2ZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qva2V5cy9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc2V0dGluZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0hvc3RPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvYnJhbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvYnJhbmQvYnJhbmQtYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9icmFuZC9icmFuZC1yZWR1Y2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2F1dGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2xvZ2luLXN0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3N1YnNjcmlwdGlvbi9zdWJzY3JpcHRpb24tYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1zdGF0dXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvdXNlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLWFjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1hY3Rpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL3dlYnBob25lLXN0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS9jYWxsLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL2NhbGwtc3RhdHVzLmpzIiwid2VicGFjazovLy8uL34vcmluZ2NlbnRyYWwtd2ViLXBob25lL3NyYy9yaW5nY2VudHJhbC13ZWItcGhvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9TSVAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvcGFja2FnZS5qc29uIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvTG9nZ2VyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvQ29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9FeGNlcHRpb25zLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9UaW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU0lQTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVVJJLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9OYW1lQWRkckhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVHJhbnNhY3Rpb25zLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9EaWFsb2dzLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9EaWFsb2cvUmVxdWVzdFNlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvUmVxdWVzdFNlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvUmVnaXN0ZXJDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9NZWRpYUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL0NsaWVudENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1NlcnZlckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1Nlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1Nlc3Npb24vRFRNRi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9XZWJSVEMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYVN0cmVhbU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1VBLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9IYWNrcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU2FuaXR5Q2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL0RpZ2VzdEF1dGhlbnRpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9HcmFtbWFyLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9HcmFtbWFyL2Rpc3QvR3JhbW1hci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvZW52aXJvbm1lbnRfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVHJhbnNwb3J0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLEtBQU0sVUFBVSx1QkFBaEI7O0FBRUEsVUFBUywyQkFBVCxHQUF1QztBQUNyQyxPQUFNLFdBQVcsbUJBQWpCO0FBQ0EsVUFBTyxDQUNMLFVBQUMsRUFBRDtBQUFBLFlBQVEsU0FBUyxHQUFULENBQWEsRUFBYixDQUFSO0FBQUEsSUFESyxFQUVMLFVBQUMsS0FBRDtBQUFBLFlBQVcsU0FBUyxPQUFULENBQWlCO0FBQUEsY0FBTSxHQUFHLEtBQUgsQ0FBTjtBQUFBLE1BQWpCLENBQVg7QUFBQSxJQUZLLENBQVA7QUFJRDs7S0FFb0IsTzs7O0FBQ25CLDBCQU9HO0FBQUEsU0FORCxvQkFNQyxRQU5ELG9CQU1DO0FBQUEsU0FMRCxRQUtDLFFBTEQsUUFLQztBQUFBLFNBSkQsWUFJQyxRQUpELFdBSUM7QUFBQSw0QkFIRCxNQUdDO0FBQUEsU0FIRCxNQUdDLCtCQUhRLElBR1I7QUFBQSxTQUZELFdBRUMsUUFGRCxXQUVD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FB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QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNILHFCQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsVUFBVTs7Ozs7OztBQ3RIdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDLDZCQUFxRDs7Ozs7OztBQzNIdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsU0FBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7O0FDbkZBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOzs7Ozs7OytDQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMEc7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLHNCQUFzQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7QUFDVCx3QkFBdUIsUUFBUTtBQUMvQjs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUVBQWtFLFFBQVE7O0FBRTFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBa0UsUUFBUTtBQUMxRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFFBQVE7O0FBRTdDOztBQUVBLHNCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBLGVBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBLHdDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUErQiwwQkFBMEIsZUFBZTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsT0FBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEIsMEJBQXlCO0FBQ3pCLDRCQUEyQjtBQUMzQix5QkFBd0I7QUFDeEIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsdUJBQXNCLFNBQVM7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXdEO0FBQ3hELHFEQUFvRCxVQUFVO0FBQzlELDZCQUE0QixvQkFBb0IscUJBQXFCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLHFDQUFxQztBQUNoRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVE7QUFDUixPQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQSxPQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLG1FQUFtRTtBQUNwRztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsT0FBTTs7QUFFTjtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsbUVBQW1FO0FBQ3BHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLFNBQVE7QUFDUjtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWOztBQUVBLFNBQVE7QUFDUixPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTJFLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsVUFBVSxlQUFlLGNBQWM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDhGQUE4RjtBQUMvRjs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE2RSxVQUFVLFlBQVksWUFBWTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZLFdBQVcsYUFBYTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLG9GQUFtRixRQUFRO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBc0YsV0FBVztBQUNqRztBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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TUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBMkUsVUFBVSxZQUFZLFlBQVk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWSxVQUFVLFVBQVU7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE2RSxVQUFVLFlBQVksWUFBWSxVQUFVLFVBQVU7QUFDbkk7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsK0VBQStFO0FBQzVGLGNBQWEsOEVBQThFO0FBQzNGLGNBQWEsZ0ZBQWdGO0FBQzdGLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsbUdBQW1HO0FBQ2hILGNBQWEsaUdBQWlHO0FBQzlHLGNBQWE7QUFDYjtBQUNB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2QsTUFBSztBQUNMLGVBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx5Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDNVNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0Esd0NBQXVDLG9CQUFvQixFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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dUJBQXVCLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSx3QkFBdUIsYUFBYSxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0Esd0JBQXVCLGlCQUFpQixFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2pIQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7QUFDSCxxQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOzs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3BRQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUEyRDtBQUMzRDtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVSxrQkFBa0I7QUFDNUIsV0FBVSxvQkFBb0I7QUFDOUIsV0FBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0EsV0FBVSxrQkFBa0I7QUFDNUIsV0FBVSxvQkFBb0I7QUFDOUIsV0FBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxrQkFBa0I7QUFDN0IsWUFBVyxvQkFBb0I7QUFDL0IsWUFBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLG9CQUFvQjtBQUM5QixXQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVSxvQkFBb0I7QUFDOUIsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3pGQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLG9DQUFvQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBOEIsb0RBQW9EOztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQLHNDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFFBQU87O0FBRVA7O0FBRUE7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXdELEVBQUU7QUFDMUQsd0RBQXVELElBQUk7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFvQyxtQkFBbUI7QUFDdkQsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQW9CLEVBQUU7QUFDdEI7QUFDQSxxQkFBb0IsRUFBRTtBQUN0Qjs7QUFFQSxxQ0FBb0MsbUJBQW1COztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHlCQUF5QjtBQUNoRCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIseUJBQXlCO0FBQ2xELElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsOEJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFpRDs7QUFFakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQixjQUFjLCtCQUErQjtBQUNsRSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxxQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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SDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNsdEVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXLFlBQVk7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCLEVBQUU7QUFDcEI7QUFDQTs7QUFFQSxtQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsTEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILHVFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUssbUJBQW1CLEVBQUU7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSyw2Q0FBNkM7QUFDbEQsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBCQUF5QixpQkFBaUI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1R0FBc0csVUFBVTs7QUFFaEg7QUFDQSxrRUFBaUUsVUFBVTtBQUMzRTtBQUNBO0FBQ0EsNERBQTJELFVBQVU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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Q0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLDRCQUE0QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzlqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCLGlCQUFpQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxvQkFBb0I7QUFDL0IsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsY0FBYztBQUN6QixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoicmluZ2NlbnRyYWwtanMtaW50ZWdyYXRpb24tY29tbW9ucy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlJjUGhvbmVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUmNQaG9uZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvblxuICoqLyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgODFjZjNjOWE4ZDRkYzJmOWFjMzhcbiAqKi8iLCJpbXBvcnQgYWRkTW9kdWxlIGZyb20gJy4vbGliL2FkZC1tb2R1bGUnO1xuaW1wb3J0IFJpbmdDZW50cmFsIGZyb20gJ3JpbmdjZW50cmFsJztcbmltcG9ydCBSaW5nQ2VudHJhbENsaWVudCBmcm9tICdyaW5nY2VudHJhbC1jbGllbnQnO1xuXG5pbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi9saWIvcmMtbW9kdWxlJztcblxuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4vbW9kdWxlcy9zZXR0aW5ncyc7XG5pbXBvcnQgQnJhbmQgZnJvbSAnLi9tb2R1bGVzL2JyYW5kJztcbmltcG9ydCBBdXRoIGZyb20gJy4vbW9kdWxlcy9hdXRoJztcbmltcG9ydCBTdWJzY3JpcHRpb24gZnJvbSAnLi9tb2R1bGVzL3N1YnNjcmlwdGlvbic7XG5pbXBvcnQgVXNlciBmcm9tICcuL21vZHVsZXMvdXNlcic7XG5pbXBvcnQgV2VicGhvbmUgZnJvbSAnLi9tb2R1bGVzL3dlYnBob25lJztcbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycywgY3JlYXRlU3RvcmUgfSBmcm9tICdyZWR1eCc7XG5cbmNvbnN0IFJFRFVDRVIgPSBTeW1ib2woKTtcblxuZnVuY3Rpb24gZ2V0U3RvcmVSZWdpc3RlckFuZFJlc29sdmVyKCkge1xuICBjb25zdCBoYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIFtcbiAgICAoZm4pID0+IGhhbmRsZXJzLmFkZChmbiksXG4gICAgKHN0b3JlKSA9PiBoYW5kbGVycy5mb3JFYWNoKGZuID0+IGZuKHN0b3JlKSksXG4gIF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJjUGhvbmUgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZWdpc3RlclN0b3JlSGFuZGxlcixcbiAgICBnZXRTdG9yZSxcbiAgICBzdGF0ZU1hcHBlcixcbiAgICBwcmVmaXggPSAncmMnLFxuICAgIHNka1NldHRpbmdzLFxuICAgIGRlZmF1bHRCcmFuZCxcbiAgfSkge1xuICAgIGxldCByZWdpc3RlciA9IHJlZ2lzdGVyU3RvcmVIYW5kbGVyO1xuICAgIGxldCByZXNvbHZlO1xuICAgIGlmICghcmVnaXN0ZXIpIHtcbiAgICAgIFtyZWdpc3RlciwgcmVzb2x2ZV0gPSBnZXRTdG9yZVJlZ2lzdGVyQW5kUmVzb2x2ZXIoKTtcbiAgICB9XG5cbiAgICBzdXBlcih7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcixcbiAgICB9KTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgnc2RrJywgbmV3IFJpbmdDZW50cmFsKHtcblxuICAgICAgY2FjaGVQcmVmaXg6IGAke3ByZWZpeH0tYCxcbiAgICAgIC4uLnNka1NldHRpbmdzLFxuICAgIH0pKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgncGxhdGZvcm0nLCB0aGlzLnNkay5wbGF0Zm9ybSgpKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgnYXBpJywgbmV3IFJpbmdDZW50cmFsQ2xpZW50KHRoaXMuc2RrKSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ2F1dGgnLCBuZXcgQXV0aCh7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcjogc3RhdGUgPT4gc3RhdGVNYXBwZXIoc3RhdGUpLmF1dGgsXG4gICAgICBwcmVmaXgsXG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3NldHRpbmdzJywgbmV3IFNldHRpbmdzKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyOiBzdGF0ZSA9PiBzdGF0ZU1hcHBlcihzdGF0ZSkuc2V0dGluZ3MsXG4gICAgfSkpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCdkZWZhdWx0QnJhbmQnLCBuZXcgQnJhbmQoe1xuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IHJlZ2lzdGVyLFxuICAgICAgcHJlZml4OiBgJHtwcmVmaXh9LWRlZmF1bHRgLFxuICAgICAgc3RhdGVNYXBwZXI6IHN0YXRlID0+IHN0YXRlTWFwcGVyKHN0YXRlKS5kZWZhdWx0QnJhbmQsXG4gICAgICAuLi5kZWZhdWx0QnJhbmQsXG4gICAgfSkpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCdzdWJzY3JpcHRpb24nLCBuZXcgU3Vic2NyaXB0aW9uKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyOiBzdGF0ZSA9PiBzdGF0ZU1hcHBlcihzdGF0ZSkuc3Vic2NyaXB0aW9uLFxuICAgICAgcHJlZml4LFxuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgc2RrOiB0aGlzLnNkayxcbiAgICAgIGF1dGg6IHRoaXMuYXV0aCxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3VzZXInLCBuZXcgVXNlcih7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcjogc3RhdGUgPT4gc3RhdGVNYXBwZXIoc3RhdGUpLnVzZXIsXG4gICAgICBwcmVmaXgsXG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3dlYnBob25lJywgbmV3IFdlYnBob25lKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyOiAoc3RhdGUpID0+IHN0YXRlTWFwcGVyKHN0YXRlKS53ZWJwaG9uZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuICAgIH0pKTtcblxuICAgIC8vIGNvbWJpbmUgcmVkdWNlcnNcbiAgICB0aGlzW1JFRFVDRVJdID0gY29tYmluZVJlZHVjZXJzKHtcbiAgICAgIGF1dGg6IHRoaXMuYXV0aC5yZWR1Y2VyLFxuICAgICAgZGVmYXVsdEJyYW5kOiB0aGlzLmRlZmF1bHRCcmFuZC5yZWR1Y2VyLFxuICAgICAgc3Vic2NyaXB0aW9uOiB0aGlzLnN1YnNjcmlwdGlvbi5yZWR1Y2VyLFxuICAgICAgdXNlcjogdGhpcy51c2VyLnJlZHVjZXIsXG4gICAgICB3ZWJwaG9uZTogdGhpcy53ZWJwaG9uZS5yZWR1Y2VyLFxuICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MucmVkdWNlcixcbiAgICB9KTtcblxuICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKGdldFN0b3JlKHRoaXMucmVkdWNlcikpO1xuICAgICAgLy8gcmVzb2x2ZShjcmVhdGVTdG9yZSh0aGlzLnJlZHVjZXIpKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIHRoaXNbUkVEVUNFUl07XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3JjLXBob25lLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiKTtcblxudmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX2Fzc2lnbjIuZGVmYXVsdCB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xyXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcclxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXHJcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcclxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xyXG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxyXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcclxuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcclxuICAgICwgaSAgICAgID0gMFxyXG4gICAgLCByZXN1bHQgPSBbXVxyXG4gICAgLCBrZXk7XHJcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xyXG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcclxuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XHJcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXHJcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xyXG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xyXG5tb2R1bGUuZXhwb3J0cyA9IChcclxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xyXG4pLnNwbGl0KCcsJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcclxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcclxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXHJcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcclxuICBPID0gdG9PYmplY3QoTyk7XHJcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XHJcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XHJcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XHJcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxyXG4gICwgZFBzICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJylcclxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXHJcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxyXG4gICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XHJcbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xyXG5cclxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxyXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XHJcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcclxuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKVxyXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcclxuICAgICwgZ3QgICAgID0gJz4nXHJcbiAgICAsIGlmcmFtZURvY3VtZW50O1xyXG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcclxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xyXG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcclxuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xyXG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcclxuICBpZnJhbWVEb2N1bWVudC53cml0ZSgnPHNjcmlwdD5kb2N1bWVudC5GPU9iamVjdDwvc2NyaXB0JyArIGd0KTtcclxuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xyXG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xyXG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcclxuICByZXR1cm4gY3JlYXRlRGljdCgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcclxuICB2YXIgcmVzdWx0O1xyXG4gIGlmKE8gIT09IG51bGwpe1xyXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xyXG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xyXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XHJcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXHJcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcclxuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xyXG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxyXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxyXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xyXG4gIGFuT2JqZWN0KE8pO1xyXG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXHJcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAsIGkgPSAwXHJcbiAgICAsIFA7XHJcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xyXG4gIHJldHVybiBPO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0ICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcclxuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcclxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgTUVUQSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZXG4gICwgJGZhaWxzICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc2hhcmVkICAgICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIHVpZCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCB3a3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCB3a3NEZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fa2V5b2YnKVxuICAsIGVudW1LZXlzICAgICAgID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJylcbiAgLCBpc0FycmF5ICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBfY3JlYXRlICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGdPUE5FeHQgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JylcbiAgLCAkR09QRCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCAkRFAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGtleXMgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QRCAgICAgICAgICAgPSAkR09QRC5mXG4gICwgZFAgICAgICAgICAgICAgPSAkRFAuZlxuICAsIGdPUE4gICAgICAgICAgID0gZ09QTkV4dC5mXG4gICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXG4gICwgJEpTT04gICAgICAgICAgPSBnbG9iYWwuSlNPTlxuICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG4gICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xuICAsIEhJRERFTiAgICAgICAgID0gd2tzKCdfaGlkZGVuJylcbiAgLCBUT19QUklNSVRJVkUgICA9IHdrcygndG9QcmltaXRpdmUnKVxuICAsIGlzRW51bSAgICAgICAgID0ge30ucHJvcGVydHlJc0VudW1lcmFibGVcbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG4gICwgT1BTeW1ib2xzICAgICAgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKVxuICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0W1BST1RPVFlQRV1cbiAgLCBVU0VfTkFUSVZFICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcbiAgLCBRT2JqZWN0ICAgICAgICA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8pJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZih0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgaXQgID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnT1BOKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIElTX09QICA9IGl0ID09PSBPYmplY3RQcm90b1xuICAgICwgbmFtZXMgID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZighVVNFX05BVElWRSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZih0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKHRoaXMgPT09IE9iamVjdFByb3RvKSRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZihERVNDUklQVE9SUyAmJiBzZXR0ZXIpc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7Y29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXR9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiAgID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5Jykpe1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuZm9yKHZhciBzeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3Moc3ltYm9sc1tpKytdKTtcblxuZm9yKHZhciBzeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrc0RlZmluZShzeW1ib2xzW2krK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIGlmKGlzU3ltYm9sKGtleSkpcmV0dXJuIGtleU9mKFN5bWJvbFJlZ2lzdHJ5LCBrZXkpO1xuICAgIHRocm93IFR5cGVFcnJvcihrZXkgKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcbiAgICBpZihpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSlyZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICB2YXIgYXJncyA9IFtpdF1cbiAgICAgICwgaSAgICA9IDFcbiAgICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXHJcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxyXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcclxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXHJcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcclxuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2tleW9mLmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSA4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxyXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcclxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XHJcblxyXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xyXG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcbiAqKiBtb2R1bGUgaWQgPSA4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXHJcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxyXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcclxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcclxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxyXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xyXG5cclxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XHJcbiAgTyA9IHRvSU9iamVjdChPKTtcclxuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XHJcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcclxuICAgIHJldHVybiBnT1BEKE8sIFApO1xyXG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cclxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanNcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qc1xuICoqIG1vZHVsZSBpZCA9IDk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXHJcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc2V0XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlNldDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMTAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGhpZGUgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJylcbiAgLCBzdGVwICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgc2V0U3BlY2llcyAgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgZmFzdEtleSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleVxuICAsIFNJWkUgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsICdmb3JFYWNoJyk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKVxuICAgICAgICAgICwgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZil7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihERVNDUklQVE9SUylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXtcbiAgICBpZihzYWZlICYmIHRhcmdldFtrZXldKXRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpe1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgLCBCUkVBSyAgICAgICA9IHt9XG4gICwgUkVUVVJOICAgICAgPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyAgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gdHlwZW9mIGNvcmVbS0VZXSA9PSAnZnVuY3Rpb24nID8gY29yZVtLRVldIDogZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbWV0YSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBmYWlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lQWxsICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgYW5JbnN0YW5jZSAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGVhY2ggICAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKXtcbiAgdmFyIEJhc2UgID0gZ2xvYmFsW05BTUVdXG4gICAgLCBDICAgICA9IEJhc2VcbiAgICAsIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJ1xuICAgICwgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlXG4gICAgLCBPICAgICA9IHt9O1xuICBpZighREVTQ1JJUFRPUlMgfHwgdHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUsICdfYycpO1xuICAgICAgdGFyZ2V0Ll9jID0gbmV3IEJhc2U7XG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGFyZ2V0W0FEREVSXSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBlYWNoKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04nLnNwbGl0KCcsJyksZnVuY3Rpb24oS0VZKXtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG4gICAgICBpZihLRVkgaW4gcHJvdG8gJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSloaWRlKEMucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsIEtFWSk7XG4gICAgICAgIGlmKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSlyZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKCdzaXplJyBpbiBwcm90bylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGFzYyAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVFlQRSwgJGNyZWF0ZSl7XG4gIHZhciBJU19NQVAgICAgICAgID0gVFlQRSA9PSAxXG4gICAgLCBJU19GSUxURVIgICAgID0gVFlQRSA9PSAyXG4gICAgLCBJU19TT01FICAgICAgID0gVFlQRSA9PSAzXG4gICAgLCBJU19FVkVSWSAgICAgID0gVFlQRSA9PSA0XG4gICAgLCBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2XG4gICAgLCBOT19IT0xFUyAgICAgID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVhcbiAgICAsIGNyZWF0ZSAgICAgICAgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QoJHRoaXMpXG4gICAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAsIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWRcbiAgICAgICwgdmFsLCByZXM7XG4gICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKXtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmKFRZUEUpe1xuICAgICAgICBpZihJU19NQVApcmVzdWx0W2luZGV4XSA9IHJlczsgICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZihyZXMpc3dpdGNoKFRZUEUpe1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYoSVNfRVZFUlkpcmV0dXJuIGZhbHNlOyAgICAgICAgICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCwgbGVuZ3RoKXtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxyXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXHJcbiAgLCBTUEVDSUVTICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcclxuICB2YXIgQztcclxuICBpZihpc0FycmF5KG9yaWdpbmFsKSl7XHJcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XHJcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xyXG4gICAgaWYodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKUMgPSB1bmRlZmluZWQ7XHJcbiAgICBpZihpc09iamVjdChDKSl7XHJcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xyXG4gICAgICBpZihDID09PSBudWxsKUMgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlciwgSVRFUkFUT1Ipe1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZE1vZHVsZShuYW1lLCBtb2R1bGUpIHtcbiAgaWYgKHRoaXM6Ok9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG1vZHVsZSAnJHtuYW1lfScgYWxyZWFkeSBleGlzdHMuLi5gKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gIH0pO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL2FkZC1tb2R1bGUuanNcbiAqKi8iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJlczYtcHJvbWlzZVwiKSwgcmVxdWlyZShcIm5vZGUtZmV0Y2hcIiksIHJlcXVpcmUoXCJwdWJudWJcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoWywgLCBcInB1Ym51YlwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJTREtcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJlczYtcHJvbWlzZVwiKSwgcmVxdWlyZShcIm5vZGUtZmV0Y2hcIiksIHJlcXVpcmUoXCJwdWJudWJcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJpbmdDZW50cmFsXCJdID0gcm9vdFtcIlJpbmdDZW50cmFsXCJdIHx8IHt9LCByb290W1wiUmluZ0NlbnRyYWxcIl1bXCJTREtcIl0gPSBmYWN0b3J5KHJvb3RbdW5kZWZpbmVkXSwgcm9vdFt1bmRlZmluZWRdLCByb290W3VuZGVmaW5lZF0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV81X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9idWlsZC9cIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfVXRpbHMpO1xuXG52YXIgX0NhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9DYWNoZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYWNoZSk7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIEV4dGVybmFscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9FeHRlcm5hbHMpO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfQ2xpZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NsaWVudCk7XG5cbnZhciBfQXBpUmVzcG9uc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9BcGlSZXNwb25zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BcGlSZXNwb25zZSk7XG5cbnZhciBfQ2xpZW50TW9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG52YXIgX0NsaWVudE1vY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2xpZW50TW9jayk7XG5cbnZhciBfTW9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgX01vY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9jayk7XG5cbnZhciBfUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9SZWdpc3RyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWdpc3RyeSk7XG5cbnZhciBfUGxhdGZvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9QbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QbGF0Zm9ybSk7XG5cbnZhciBfQXV0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX0F1dGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXV0aCk7XG5cbnZhciBfUHVibnViRmFjdG9yeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgX1B1Ym51YkZhY3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHVibnViRmFjdG9yeSk7XG5cbnZhciBfU3Vic2NyaXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbnZhciBfU3Vic2NyaXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1YnNjcmlwdGlvbik7XG5cbnZhciBfQ2FjaGVkU3Vic2NyaXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBfQ2FjaGVkU3Vic2NyaXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhY2hlZFN1YnNjcmlwdGlvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTREsgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlIFJpbmdDZW50cmFsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZXJ2ZXJdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNhY2hlUHJlZml4XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcHBTZWNyZXRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFwcEtleV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwTmFtZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwVmVyc2lvbl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHVibnViRmFjdG9yeV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xpZW50XVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU0RLKG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNESyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKCFFeHRlcm5hbHMuZmV0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmF0aXZlIEZldGNoIGlzIG1pc3NpbmcsIHNldCBSaW5nQ2VudHJhbC5TREsuY29yZS5FeHRlcm5hbHMuZmV0Y2ggdG8geW91ciBmYXZvcml0ZSBhbHRlcm5hdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFFeHRlcm5hbHMuUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgUHJvbWlzZSBpcyBtaXNzaW5nLCBzZXQgUmluZ0NlbnRyYWwuU0RLLmNvcmUuRXh0ZXJuYWxzLlByb21pc2UgdG8geW91ciBmYXZvcml0ZSBhbHRlcm5hdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgX0NhY2hlMi5kZWZhdWx0KEV4dGVybmFscy5sb2NhbFN0b3JhZ2UsIG9wdGlvbnMuY2FjaGVQcmVmaXgpO1xuXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IG9wdGlvbnMuY2xpZW50IHx8IG5ldyBfQ2xpZW50Mi5kZWZhdWx0KCk7XG5cbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBuZXcgX1BsYXRmb3JtMi5kZWZhdWx0KHRoaXMuX2NsaWVudCwgdGhpcy5fY2FjaGUsIG9wdGlvbnMuc2VydmVyLCBvcHRpb25zLmFwcEtleSwgb3B0aW9ucy5hcHBTZWNyZXQsIG9wdGlvbnMuYXBwTmFtZSwgb3B0aW9ucy5hcHBWZXJzaW9uLCBTREsudmVyc2lvbik7XG5cbiAgICAgICAgdGhpcy5fcHVibnViRmFjdG9yeSA9IG9wdGlvbnMucHVibnViRmFjdG9yeSB8fCBFeHRlcm5hbHMuUFVCTlVCO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1BsYXRmb3JtfVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLnBsYXRmb3JtID0gZnVuY3Rpb24gcGxhdGZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfU3Vic2NyaXB0aW9uMi5kZWZhdWx0KHRoaXMuX3B1Ym51YkZhY3RvcnksIHRoaXMuX3BsYXRmb3JtKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Q2FjaGVkU3Vic2NyaXB0aW9ufVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLmNyZWF0ZUNhY2hlZFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUNhY2hlZFN1YnNjcmlwdGlvbihjYWNoZUtleSkge1xuICAgICAgICByZXR1cm4gbmV3IF9DYWNoZWRTdWJzY3JpcHRpb24yLmRlZmF1bHQodGhpcy5fcHVibnViRmFjdG9yeSwgdGhpcy5fcGxhdGZvcm0sIHRoaXMuX2NhY2hlLCBjYWNoZUtleSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0NhY2hlfVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24gY2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9O1xuXG4gICAgU0RLLmhhbmRsZUxvZ2luUmVkaXJlY3QgPSBmdW5jdGlvbiBoYW5kbGVMb2dpblJlZGlyZWN0KG9yaWdpbikge1xuICAgICAgICB3aW5kb3cub3BlbmVyLnBvc3RNZXNzYWdlKHsgUkNBdXRob3JpemF0aW9uQ29kZTogd2luZG93LmxvY2F0aW9uLnNlYXJjaCB9LCBvcmlnaW4gfHwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gICAgfTtcblxuICAgIHJldHVybiBTREs7XG59KCk7XG5cblNESy52ZXJzaW9uID0gIHRydWUgPyAoXCIzLjAuMC1yYzFcIikgOiAneC54LngnO1xuU0RLLnNlcnZlciA9IHtcbiAgICBzYW5kYm94OiAnaHR0cHM6Ly9wbGF0Zm9ybS5kZXZ0ZXN0LnJpbmdjZW50cmFsLmNvbScsXG4gICAgcHJvZHVjdGlvbjogJ2h0dHBzOi8vcGxhdGZvcm0ucmluZ2NlbnRyYWwuY29tJ1xufTtcblNESy5jb3JlID0ge1xuICAgIENhY2hlOiBfQ2FjaGUyLmRlZmF1bHQsXG4gICAgRXZlbnRFbWl0dGVyOiBfZXZlbnRzMi5kZWZhdWx0LFxuICAgIFV0aWxzOiBVdGlscyxcbiAgICBFeHRlcm5hbHM6IEV4dGVybmFsc1xufTtcblNESy5odHRwID0ge1xuICAgIENsaWVudDogX0NsaWVudDIuZGVmYXVsdCxcbiAgICBBcGlSZXNwb25zZTogX0FwaVJlc3BvbnNlMi5kZWZhdWx0XG59O1xuU0RLLnBsYXRmb3JtID0ge1xuICAgIEF1dGg6IF9BdXRoMi5kZWZhdWx0LFxuICAgIFBsYXRmb3JtOiBfUGxhdGZvcm0yLmRlZmF1bHRcbn07XG5TREsuc3Vic2NyaXB0aW9uID0ge1xuICAgIFN1YnNjcmlwdGlvbjogX1N1YnNjcmlwdGlvbjIuZGVmYXVsdFxufTtcblNESy5tb2NrcyA9IHtcbiAgICBDbGllbnQ6IF9DbGllbnRNb2NrMi5kZWZhdWx0LFxuICAgIFJlZ2lzdHJ5OiBfUmVnaXN0cnkyLmRlZmF1bHQsXG4gICAgTW9jazogX01vY2syLmRlZmF1bHRcbn07XG5TREsucHVibnViID0ge1xuICAgIFB1Ym51Yk1vY2tGYWN0b3J5OiBfUHVibnViRmFjdG9yeTIuZGVmYXVsdFxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNESztcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgaXRlcmF0b3JTeW1ib2wgPVxuICAgIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50YCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4gU29tZSBtYXkgY29uc2lkZXIgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgdG9vXG4gIC8vIGN1dGVzeSwgYnV0IHRoZXkgYXJlIGN1cm11ZGdlb25zLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgLy8gVGhpcyBpbnZva2UgZnVuY3Rpb24gaXMgd3JpdHRlbiBpbiBhIHN0eWxlIHRoYXQgYXNzdW1lcyBzb21lXG4gICAgLy8gY2FsbGluZyBmdW5jdGlvbiAob3IgUHJvbWlzZSkgd2lsbCBoYW5kbGUgZXhjZXB0aW9ucy5cbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZW5lcmF0b3JbbWV0aG9kXShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudFxuICAgICAgICA/IFByb21pc2UucmVzb2x2ZSh2YWx1ZS5hcmcpLnRoZW4oaW52b2tlTmV4dCwgaW52b2tlVGhyb3cpXG4gICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBpbnZva2VOZXh0ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcIm5leHRcIik7XG4gICAgdmFyIGludm9rZVRocm93ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIHZhciBpbnZva2VSZXR1cm4gPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwicmV0dXJuXCIpO1xuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8XG4gICAgICAgICAgICAgIChtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9zZW50ID0gYXJnO1xuXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSBhcmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgdGhpcy5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMucXVlcnlTdHJpbmdpZnkgPSBxdWVyeVN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2VRdWVyeVN0cmluZyA9IHBhcnNlUXVlcnlTdHJpbmc7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNPYmplY3RPYmplY3QgPSBpc09iamVjdE9iamVjdDtcbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG5leHBvcnRzLmlzTm9kZUpTID0gaXNOb2RlSlM7XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4vKipcbiAqIFRPRE8gUmVwbGFjZSB3aXRoIHNvbWV0aGluZyBiZXR0ZXJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9xdWVyeXN0cmluZy5qc1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5U3RyaW5naWZ5KHBhcmFtZXRlcnMpIHtcblxuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cbiAgICAgICAgdmFyIHYgPSBwYXJhbWV0ZXJzW2tdO1xuXG4gICAgICAgIGlmIChpc0FycmF5KHYpKSB7XG4gICAgICAgICAgICB2LmZvckVhY2goZnVuY3Rpb24gKHZ2KSB7XG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaChlbmNvZGVVUklDb21wb25lbnQoaykgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodnYpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXkucHVzaChlbmNvZGVVUklDb21wb25lbnQoaykgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodikpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJyYXkuam9pbignJicpO1xufVxuXG4vKipcbiAqIFRPRE8gUmVwbGFjZSB3aXRoIHNvbWV0aGluZyBiZXR0ZXJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9xdWVyeXN0cmluZy5qc1xuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5U3RyaW5nXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5U3RyaW5nKSB7XG5cbiAgICB2YXIgYXJnc1BhcnNlZCA9IHt9O1xuXG4gICAgcXVlcnlTdHJpbmcuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcblxuICAgICAgICBhcmcgPSBkZWNvZGVVUklDb21wb25lbnQoYXJnKTtcblxuICAgICAgICBpZiAoYXJnLmluZGV4T2YoJz0nKSA9PSAtMSkge1xuXG4gICAgICAgICAgICBhcmdzUGFyc2VkW2FyZy50cmltKCldID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIHBhaXIgPSBhcmcuc3BsaXQoJz0nKSxcbiAgICAgICAgICAgICAgICBrZXkgPSBwYWlyWzBdLnRyaW0oKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhaXJbMV0udHJpbSgpO1xuXG4gICAgICAgICAgICBpZiAoa2V5IGluIGFyZ3NQYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGFyZ3NQYXJzZWQgJiYgIWlzQXJyYXkoYXJnc1BhcnNlZFtrZXldKSkgYXJnc1BhcnNlZFtrZXldID0gW2FyZ3NQYXJzZWRba2V5XV07XG4gICAgICAgICAgICAgICAgYXJnc1BhcnNlZFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzUGFyc2VkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFyZ3NQYXJzZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEBwYXJhbSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KG9iaikgOiB0eXBlb2Ygb2JqID09PSBcImFycmF5XCI7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgICByZXR1cm4gbyAhPSBudWxsICYmICh0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobykpID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShvKTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RPYmplY3Qobykge1xuICAgIHJldHVybiBpc09iamVjdChvKSA9PT0gdHJ1ZSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcbiAgICB2YXIgY3RvciwgcHJvdDtcblxuICAgIGlmIChpc09iamVjdE9iamVjdChvKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuICAgIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0eXBlb2YgY3RvciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZVxuICAgIHByb3QgPSBjdG9yLnByb3RvdHlwZTtcbiAgICBpZiAoaXNPYmplY3RPYmplY3QocHJvdCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcbiAgICBpZiAocHJvdC5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTW9zdCBsaWtlbHkgYSBwbGFpbiBPYmplY3RcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlSlMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gZGVsYXkodGltZW91dCkge1xuICAgIHJldHVybiBuZXcgX0V4dGVybmFscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICB9KTtcbn1cblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvY2FsU3RvcmFnZSA9IGV4cG9ydHMuUFVCTlVCID0gZXhwb3J0cy5IZWFkZXJzID0gZXhwb3J0cy5SZXNwb25zZSA9IGV4cG9ydHMuUmVxdWVzdCA9IGV4cG9ydHMuZmV0Y2ggPSBleHBvcnRzLlByb21pc2UgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXM2UHJvbWlzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfZXM2UHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lczZQcm9taXNlKTtcblxudmFyIF9ub2RlRmV0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX25vZGVGZXRjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlRmV0Y2gpO1xuXG52YXIgX3B1Ym51YiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfcHVibnViMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3B1Ym51Yik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciByb290ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpcztcIikoKTtcblxudmFyIFByb21pc2UgPSBfZXM2UHJvbWlzZTIuZGVmYXVsdCAmJiBfZXM2UHJvbWlzZTIuZGVmYXVsdC5Qcm9taXNlIHx8IHJvb3QuUHJvbWlzZTtcblxudmFyIGZldGNoID0gX25vZGVGZXRjaDIuZGVmYXVsdCAmJiB0eXBlb2YgX25vZGVGZXRjaDIuZGVmYXVsdCA9PSAnZnVuY3Rpb24nID8gX25vZGVGZXRjaDIuZGVmYXVsdCA6IHJvb3QuZmV0Y2g7XG52YXIgUmVxdWVzdCA9IGZldGNoLlJlcXVlc3QgfHwgcm9vdC5SZXF1ZXN0O1xudmFyIFJlc3BvbnNlID0gZmV0Y2guUmVzcG9uc2UgfHwgcm9vdC5SZXNwb25zZTtcbnZhciBIZWFkZXJzID0gZmV0Y2guSGVhZGVycyB8fCByb290LkhlYWRlcnM7XG5cbnZhciBQVUJOVUIgPSBfcHVibnViMi5kZWZhdWx0IHx8IHJvb3QuUFVCTlVCO1xuXG52YXIgbG9jYWxTdG9yYWdlID0gdHlwZW9mIHJvb3QubG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJyA/IHJvb3QubG9jYWxTdG9yYWdlIDoge307XG5cbmV4cG9ydHMuUHJvbWlzZSA9IFByb21pc2U7XG5leHBvcnRzLmZldGNoID0gZmV0Y2g7XG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbmV4cG9ydHMuUFVCTlVCID0gUFVCTlVCO1xuZXhwb3J0cy5sb2NhbFN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2U7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzVfXztcblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNl9fO1xuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83X187XG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FjaGUoc3RvcmFnZSwgcHJlZml4KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWNoZSk7XG5cbiAgICAgICAgdGhpcy5zZXRQcmVmaXgocHJlZml4KTtcbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgfVxuXG4gICAgQ2FjaGUucHJvdG90eXBlLnNldFByZWZpeCA9IGZ1bmN0aW9uIHNldFByZWZpeChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5fcHJlZml4ID0gcHJlZml4IHx8IENhY2hlLmRlZmF1bHRQcmVmaXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBDYWNoZS5wcm90b3R5cGUuc2V0SXRlbSA9IGZ1bmN0aW9uIHNldEl0ZW0oa2V5LCBkYXRhKSB7XG4gICAgICAgIHRoaXMuX3N0b3JhZ2VbdGhpcy5fcHJlZml4S2V5KGtleSldID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBDYWNoZS5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yYWdlW3RoaXMuX3ByZWZpeEtleShrZXkpXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENhY2hlLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9zdG9yYWdlW3RoaXMuX3ByZWZpeEtleShrZXkpXTtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoaXRlbSk7XG4gICAgfTtcblxuICAgIENhY2hlLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uIGNsZWFuKCkge1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9zdG9yYWdlKSB7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKHRoaXMuX3ByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fc3RvcmFnZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENhY2hlLnByb3RvdHlwZS5fcHJlZml4S2V5ID0gZnVuY3Rpb24gX3ByZWZpeEtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWZpeCArIGtleTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhY2hlO1xufSgpO1xuXG5DYWNoZS5kZWZhdWx0UHJlZml4ID0gJ3JjLSc7XG5leHBvcnRzLmRlZmF1bHQgPSBDYWNoZTtcblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmZpbmRIZWFkZXJOYW1lID0gZmluZEhlYWRlck5hbWU7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9VdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9BcGlSZXNwb25zZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgX0FwaVJlc3BvbnNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FwaVJlc3BvbnNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDbGllbnQgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAgIF9pbmhlcml0cyhDbGllbnQsIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgZnVuY3Rpb24gQ2xpZW50KCkge1xuICAgICAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGllbnQpO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwuYXBwbHkoX0V2ZW50RW1pdHRlciwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIGJlZm9yZVJlcXVlc3Q6ICdiZWZvcmVSZXF1ZXN0JyxcbiAgICAgICAgICAgIHJlcXVlc3RTdWNjZXNzOiAncmVxdWVzdFN1Y2Nlc3MnLFxuICAgICAgICAgICAgcmVxdWVzdEVycm9yOiAncmVxdWVzdEVycm9yJ1xuICAgICAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuICAgIENsaWVudC5wcm90b3R5cGUuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgYXBpUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVzcG9uc2UgPSBuZXcgX0FwaVJlc3BvbnNlMi5kZWZhdWx0KHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gU3RvcCByZXF1ZXN0IGlmIGxpc3RlbmVycyByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMuYmVmb3JlUmVxdWVzdCwgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRSZXNwb25zZShyZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlLl9yZXNwb25zZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlc3BvbnNlLl9pbml0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBpUmVzcG9uc2Uub2soKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaGFzIHVuc3VjY2Vzc2Z1bCBzdGF0dXMnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5yZXF1ZXN0U3VjY2VzcywgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcGlSZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfY29udGV4dC50MC5hcGlSZXNwb25zZSkgX2NvbnRleHQudDAgPSB0aGlzLm1ha2VFcnJvcihfY29udGV4dC50MCwgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLnJlcXVlc3RFcnJvciwgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMSwgMTRdXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBzZW5kUmVxdWVzdChfeCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZW5kUmVxdWVzdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBDbGllbnQucHJvdG90eXBlLl9sb2FkUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfRXh0ZXJuYWxzLmZldGNoLmNhbGwobnVsbCwgcmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9sb2FkUmVzcG9uc2UoX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfbG9hZFJlc3BvbnNlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIHRoZSBKUyBFcnJvciBvYmplY3Qgd2l0aCB0cmFuc2FjdGlvbiBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7RXJyb3J8SUFwaUVycm9yfSBlXG4gICAgICogQHBhcmFtIHtBcGlSZXNwb25zZX0gYXBpUmVzcG9uc2VcbiAgICAgKiBAcmV0dXJuIHtJQXBpRXJyb3J9XG4gICAgICovXG5cblxuICAgIENsaWVudC5wcm90b3R5cGUubWFrZUVycm9yID0gZnVuY3Rpb24gbWFrZUVycm9yKGUsIGFwaVJlc3BvbnNlKSB7XG5cbiAgICAgICAgLy8gV3JhcCBvbmx5IGlmIHJlZ3VsYXIgZXJyb3JcbiAgICAgICAgaWYgKCFlLmhhc093blByb3BlcnR5KCdhcGlSZXNwb25zZScpICYmICFlLmhhc093blByb3BlcnR5KCdvcmlnaW5hbE1lc3NhZ2UnKSkge1xuXG4gICAgICAgICAgICBlLmFwaVJlc3BvbnNlID0gYXBpUmVzcG9uc2U7XG4gICAgICAgICAgICBlLm9yaWdpbmFsTWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICAgICAgICAgIGUubWVzc2FnZSA9IGFwaVJlc3BvbnNlICYmIGFwaVJlc3BvbnNlLmVycm9yKHRydWUpIHx8IGUub3JpZ2luYWxNZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluaXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2luaXQudXJsXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbaW5pdC5ib2R5XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbaW5pdC5tZXRob2RdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtpbml0LnF1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbaW5pdC5oZWFkZXJzXVxuICAgICAqIEByZXR1cm4ge1JlcXVlc3R9XG4gICAgICovXG5cblxuICAgIENsaWVudC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QoaW5pdCkge1xuXG4gICAgICAgIGluaXQgPSBpbml0IHx8IHt9O1xuICAgICAgICBpbml0LmhlYWRlcnMgPSBpbml0LmhlYWRlcnMgfHwge307XG5cbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrc1xuICAgICAgICBpZiAoIWluaXQudXJsKSB0aHJvdyBuZXcgRXJyb3IoJ1VybCBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICBpZiAoIWluaXQubWV0aG9kKSBpbml0Lm1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBpZiAoaW5pdC5tZXRob2QgJiYgQ2xpZW50Ll9hbGxvd2VkTWV0aG9kcy5pbmRleE9mKGluaXQubWV0aG9kLnRvVXBwZXJDYXNlKCkpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgaGFzIHdyb25nIHZhbHVlOiAnICsgaW5pdC5tZXRob2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdHNcbiAgICAgICAgaW5pdC5jcmVkZW50aWFscyA9IGluaXQuY3JlZGVudGlhbHMgfHwgJ2luY2x1ZGUnO1xuICAgICAgICBpbml0Lm1vZGUgPSBpbml0Lm1vZGUgfHwgJ2NvcnMnO1xuXG4gICAgICAgIC8vIEFwcGVuZCBRdWVyeSBTdHJpbmdcbiAgICAgICAgaWYgKGluaXQucXVlcnkpIHtcbiAgICAgICAgICAgIGluaXQudXJsID0gaW5pdC51cmwgKyAoaW5pdC51cmwuaW5kZXhPZignPycpID4gLTEgPyAnJicgOiAnPycpICsgKDAsIF9VdGlscy5xdWVyeVN0cmluZ2lmeSkoaW5pdC5xdWVyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZpbmRIZWFkZXJOYW1lKCdBY2NlcHQnLCBpbml0LmhlYWRlcnMpKSB7XG4gICAgICAgICAgICBpbml0LmhlYWRlcnNbJ0FjY2VwdCddID0gX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9qc29uQ29udGVudFR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXJpYWxpemUgYm9keVxuICAgICAgICBpZiAoKDAsIF9VdGlscy5pc1BsYWluT2JqZWN0KShpbml0LmJvZHkpIHx8ICFpbml0LmJvZHkpIHtcblxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGVhZGVyTmFtZSA9IGZpbmRIZWFkZXJOYW1lKF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fY29udGVudFR5cGUsIGluaXQuaGVhZGVycyk7XG5cbiAgICAgICAgICAgIGlmICghY29udGVudFR5cGVIZWFkZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVIZWFkZXJOYW1lID0gX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9jb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICBpbml0LmhlYWRlcnNbY29udGVudFR5cGVIZWFkZXJOYW1lXSA9IF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fanNvbkNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBpbml0LmhlYWRlcnNbY29udGVudFR5cGVIZWFkZXJOYW1lXTtcblxuICAgICAgICAgICAgLy8gQXNzaWduIGEgbmV3IGVuY29kZWQgYm9keVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9qc29uQ29udGVudFR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShpbml0LmJvZHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250ZW50VHlwZS5pbmRleE9mKF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fdXJsZW5jb2RlZENvbnRlbnRUeXBlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaW5pdC5ib2R5ID0gKDAsIF9VdGlscy5xdWVyeVN0cmluZ2lmeSkoaW5pdC5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIHJlcXVlc3Qgd2l0aCBlbmNvZGVkIGJvZHlcbiAgICAgICAgdmFyIHJlcSA9IG5ldyBfRXh0ZXJuYWxzLlJlcXVlc3QoaW5pdC51cmwsIGluaXQpO1xuXG4gICAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIGJvZHkgYWNjZXNzaWJsZSBkaXJlY3RseSAoZm9yIG1vY2tzKVxuICAgICAgICByZXEub3JpZ2luYWxCb2R5ID0gaW5pdC5ib2R5O1xuXG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfTtcblxuICAgIHJldHVybiBDbGllbnQ7XG59KF9ldmVudHMyLmRlZmF1bHQpO1xuXG5DbGllbnQuX2FsbG93ZWRNZXRob2RzID0gWydHRVQnLCAnUE9TVCcsICdQVVQnLCAnREVMRVRFJywgJ1BBVENIJywgJ09QVElPTlMnLCAnSEVBRCddO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2xpZW50O1xuZnVuY3Rpb24gZmluZEhlYWRlck5hbWUobmFtZSwgaGVhZGVycykge1xuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMpLnJlZHVjZShmdW5jdGlvbiAocmVzLCBrZXkpIHtcbiAgICAgICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICAgICAgaWYgKG5hbWUgPT0ga2V5LnRvTG93ZXJDYXNlKCkpIHJldHVybiBrZXk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgbnVsbCk7XG59XG5cbi8qKlxuICogQG5hbWUgSUFwaUVycm9yXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhY2tcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvcmlnaW5hbE1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7QXBpUmVzcG9uc2V9IGFwaVJlc3BvbnNlXG4gKi9cblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IF9FeHRlcm5hbHMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIF9FeHRlcm5hbHMuUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBcGlSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlVGV4dFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQXBpUmVzcG9uc2UocmVxdWVzdCwgcmVzcG9uc2UsIHJlc3BvbnNlVGV4dCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXBpUmVzcG9uc2UpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7UmVxdWVzdH0gKi9cbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtSZXNwb25zZX0gKi9cbiAgICAgICAgdGhpcy5fcmVzcG9uc2UgPSByZXNwb25zZTtcblxuICAgICAgICB0aGlzLl90ZXh0ID0gcmVzcG9uc2VUZXh0O1xuICAgICAgICB0aGlzLl9qc29uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXVsdGlwYXJ0ID0gW107XG4gICAgfVxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5faXNNdWx0aXBhcnQoKSB8fCB0aGlzLl9pc0pzb24oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlKCkudGV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCB0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2luaXQ7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7UmVzcG9uc2V9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5yZXNwb25zZSA9IGZ1bmN0aW9uIHJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1JlcXVlc3R9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5vayA9IGZ1bmN0aW9uIG9rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2UgJiYgdGhpcy5fcmVzcG9uc2Uub2s7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiB0ZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzSnNvbigpICYmICF0aGlzLl9pc011bHRpcGFydCgpKSB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGlzIG5vdCB0ZXh0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24ganNvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0pzb24oKSkgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBpcyBub3QgSlNPTicpO1xuICAgICAgICBpZiAoIXRoaXMuX2pzb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2pzb24gPSB0aGlzLl90ZXh0ID8gSlNPTi5wYXJzZSh0aGlzLl90ZXh0KSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2pzb247XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBbc2tpcE9LQ2hlY2tdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihza2lwT0tDaGVjaykge1xuXG4gICAgICAgIGlmICh0aGlzLm9rKCkgJiYgIXNraXBPS0NoZWNrKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgbWVzc2FnZSA9ICh0aGlzLl9yZXNwb25zZSAmJiB0aGlzLl9yZXNwb25zZS5zdGF0dXMgPyB0aGlzLl9yZXNwb25zZS5zdGF0dXMgKyAnICcgOiAnJykgKyAodGhpcy5fcmVzcG9uc2UgJiYgdGhpcy5fcmVzcG9uc2Uuc3RhdHVzVGV4dCA/IHRoaXMuX3Jlc3BvbnNlLnN0YXR1c1RleHQgOiAnJyk7XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuanNvbigpLm1lc3NhZ2UpIG1lc3NhZ2UgPSB0aGlzLmpzb24oKS5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKHRoaXMuanNvbigpLmVycm9yX2Rlc2NyaXB0aW9uKSBtZXNzYWdlID0gdGhpcy5qc29uKCkuZXJyb3JfZGVzY3JpcHRpb247XG4gICAgICAgICAgICBpZiAodGhpcy5qc29uKCkuZGVzY3JpcHRpb24pIG1lc3NhZ2UgPSB0aGlzLmpzb24oKS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXBpUmVzcG9uc2VbXX1cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLm11bHRpcGFydCA9IGZ1bmN0aW9uIG11bHRpcGFydCgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzTXVsdGlwYXJ0KCkpIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaXMgbm90IG11bHRpcGFydCcpO1xuXG4gICAgICAgIGlmICghdGhpcy5fbXVsdGlwYXJ0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICAvLyBTdGVwIDEuIFNwbGl0IG11bHRpcGFydCByZXNwb25zZVxuXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMudGV4dCgpO1xuXG4gICAgICAgICAgICBpZiAoIXRleHQpIHRocm93IG5ldyBFcnJvcignTm8gcmVzcG9uc2UgYm9keScpO1xuXG4gICAgICAgICAgICB2YXIgYm91bmRhcnkgPSB0aGlzLl9nZXRDb250ZW50VHlwZSgpLm1hdGNoKC9ib3VuZGFyeT0oW147XSspL2kpWzFdO1xuXG4gICAgICAgICAgICBpZiAoIWJvdW5kYXJ5KSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGJvdW5kYXJ5Jyk7XG5cbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHRleHQudG9TdHJpbmcoKS5zcGxpdChBcGlSZXNwb25zZS5fYm91bmRhcnlTZXBhcmF0b3IgKyBib3VuZGFyeSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0c1swXS50cmltKCkgPT09ICcnKSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRyaW0oKSA9PSBBcGlSZXNwb25zZS5fYm91bmRhcnlTZXBhcmF0b3IpIHBhcnRzLnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IEVycm9yKCdObyBwYXJ0cyBpbiBib2R5Jyk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgMi4gUGFyc2Ugc3RhdHVzIGluZm9cblxuICAgICAgICAgICAgdmFyIHN0YXR1c0luZm8gPSBBcGlSZXNwb25zZS5jcmVhdGUocGFydHMuc2hpZnQoKSwgdGhpcy5fcmVzcG9uc2Uuc3RhdHVzLCB0aGlzLl9yZXNwb25zZS5zdGF0dXNUZXh0KS5qc29uKCk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgMy4gUGFyc2UgYWxsIG90aGVyIHBhcnRzXG5cbiAgICAgICAgICAgIHRoaXMuX211bHRpcGFydCA9IHBhcnRzLm1hcChmdW5jdGlvbiAocGFydCwgaSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHN0YXR1c0luZm8ucmVzcG9uc2VbaV0uc3RhdHVzO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFwaVJlc3BvbnNlLmNyZWF0ZShwYXJ0LCBzdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbXVsdGlwYXJ0O1xuICAgIH07XG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuX2lzQ29udGVudFR5cGUgPSBmdW5jdGlvbiBfaXNDb250ZW50VHlwZShjb250ZW50VHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29udGVudFR5cGUoKS5pbmRleE9mKGNvbnRlbnRUeXBlKSA+IC0xO1xuICAgIH07XG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuX2dldENvbnRlbnRUeXBlID0gZnVuY3Rpb24gX2dldENvbnRlbnRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2UuaGVhZGVycy5nZXQoQXBpUmVzcG9uc2UuX2NvbnRlbnRUeXBlKSB8fCAnJztcbiAgICB9O1xuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pc011bHRpcGFydCA9IGZ1bmN0aW9uIF9pc011bHRpcGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ29udGVudFR5cGUoQXBpUmVzcG9uc2UuX211bHRpcGFydENvbnRlbnRUeXBlKTtcbiAgICB9O1xuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pc1VybEVuY29kZWQgPSBmdW5jdGlvbiBfaXNVcmxFbmNvZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDb250ZW50VHlwZShBcGlSZXNwb25zZS5fdXJsZW5jb2RlZENvbnRlbnRUeXBlKTtcbiAgICB9O1xuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pc0pzb24gPSBmdW5jdGlvbiBfaXNKc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDb250ZW50VHlwZShBcGlSZXNwb25zZS5fanNvbkNvbnRlbnRUeXBlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGlzIHVzZWQgdG8gY3JlYXRlIEFwaVJlc3BvbnNlIG9iamVjdCBmcm9tIHN0cmluZyBwYXJ0cyBvZiBtdWx0aXBhcnQvbWl4ZWQgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGF0dXNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0dXNUZXh0XVxuICAgICAqIEByZXR1cm4ge0FwaVJlc3BvbnNlfVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUodGV4dCwgc3RhdHVzLCBzdGF0dXNUZXh0KSB7XG5cbiAgICAgICAgdGV4dCA9IHRleHQgfHwgJyc7XG4gICAgICAgIHN0YXR1cyA9IHN0YXR1cyB8fCAyMDA7XG4gICAgICAgIHN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8ICdPSyc7XG5cbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyL2csICcnKTtcblxuICAgICAgICB2YXIgaGVhZGVycyA9IG5ldyBfRXh0ZXJuYWxzLkhlYWRlcnMoKSxcbiAgICAgICAgICAgIGhlYWRlcnNBbmRCb2R5ID0gdGV4dC5zcGxpdChBcGlSZXNwb25zZS5fYm9keVNlcGFyYXRvciksXG4gICAgICAgICAgICBoZWFkZXJzVGV4dCA9IGhlYWRlcnNBbmRCb2R5Lmxlbmd0aCA+IDEgPyBoZWFkZXJzQW5kQm9keS5zaGlmdCgpIDogJyc7XG5cbiAgICAgICAgdGV4dCA9IGhlYWRlcnNBbmRCb2R5Lmxlbmd0aCA+IDAgPyBoZWFkZXJzQW5kQm9keS5qb2luKEFwaVJlc3BvbnNlLl9ib2R5U2VwYXJhdG9yKSA6IG51bGw7XG5cbiAgICAgICAgKGhlYWRlcnNUZXh0IHx8ICcnKS5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG5cbiAgICAgICAgICAgIHZhciBzcGxpdCA9IGhlYWRlci50cmltKCkuc3BsaXQoQXBpUmVzcG9uc2UuX2hlYWRlclNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAga2V5ID0gc3BsaXQuc2hpZnQoKS50cmltKCksXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzcGxpdC5qb2luKEFwaVJlc3BvbnNlLl9oZWFkZXJTZXBhcmF0b3IpLnRyaW0oKTtcblxuICAgICAgICAgICAgaWYgKGtleSkgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgQXBpUmVzcG9uc2UobnVsbCwgbmV3IF9FeHRlcm5hbHMuUmVzcG9uc2UodGV4dCA/IHRleHQgOiB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHN0YXR1c1RleHRcbiAgICAgICAgfSksIHRleHQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXBpUmVzcG9uc2U7XG59KCk7XG5cbkFwaVJlc3BvbnNlLl9jb250ZW50VHlwZSA9ICdDb250ZW50LVR5cGUnO1xuQXBpUmVzcG9uc2UuX2pzb25Db250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbkFwaVJlc3BvbnNlLl9tdWx0aXBhcnRDb250ZW50VHlwZSA9ICdtdWx0aXBhcnQvbWl4ZWQnO1xuQXBpUmVzcG9uc2UuX3VybGVuY29kZWRDb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuQXBpUmVzcG9uc2UuX2hlYWRlclNlcGFyYXRvciA9ICc6JztcbkFwaVJlc3BvbnNlLl9ib2R5U2VwYXJhdG9yID0gJ1xcblxcbic7XG5BcGlSZXNwb25zZS5fYm91bmRhcnlTZXBhcmF0b3IgPSAnLS0nO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBpUmVzcG9uc2U7XG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9SZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX1JlZ2lzdHJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZ2lzdHJ5KTtcblxudmFyIF9DbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9DbGllbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2xpZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDbGllbnQgPSBmdW5jdGlvbiAoX0h0dHBDbGllbnQpIHtcbiAgICBfaW5oZXJpdHMoQ2xpZW50LCBfSHR0cENsaWVudCk7XG5cbiAgICBmdW5jdGlvbiBDbGllbnQoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGllbnQpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9IdHRwQ2xpZW50LmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLl9yZWdpc3RyeSA9IG5ldyBfUmVnaXN0cnkyLmRlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIENsaWVudC5wcm90b3R5cGUucmVnaXN0cnkgPSBmdW5jdGlvbiByZWdpc3RyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5O1xuICAgIH07XG5cbiAgICBDbGllbnQucHJvdG90eXBlLl9sb2FkUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgbW9jaztcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2NrID0gdGhpcy5fcmVnaXN0cnkuZmluZChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9jay5nZXRSZXNwb25zZShyZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9sb2FkUmVzcG9uc2UoX3gpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xvYWRSZXNwb25zZTtcbiAgICB9KCk7XG5cbiAgICByZXR1cm4gQ2xpZW50O1xufShfQ2xpZW50Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2xpZW50O1xuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfTW9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgX01vY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9jayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBSZWdpc3RyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWdpc3RyeSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZ2lzdHJ5KTtcblxuICAgICAgICB0aGlzLl9tb2NrcyA9IFtdO1xuICAgIH1cblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobW9jaykge1xuICAgICAgICB0aGlzLl9tb2Nrcy5wdXNoKG1vY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX21vY2tzID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQocmVxdWVzdCkge1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ1JlZ2lzdHJ5IGlzIGxvb2tpbmcgZm9yJywgcmVxdWVzdCk7XG5cbiAgICAgICAgdmFyIG1vY2sgPSB0aGlzLl9tb2Nrcy5zaGlmdCgpO1xuXG4gICAgICAgIGlmICghbW9jaykgdGhyb3cgbmV3IEVycm9yKCdObyBtb2NrIGluIHJlZ2lzdHJ5IGZvciByZXF1ZXN0ICcgKyByZXF1ZXN0Lm1ldGhvZCArICcgJyArIHJlcXVlc3QudXJsKTtcblxuICAgICAgICBpZiAoIW1vY2sudGVzdChyZXF1ZXN0KSkgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyByZXF1ZXN0ICcgKyByZXF1ZXN0Lm1ldGhvZCArICcgJyArIHJlcXVlc3QudXJsICsgJyBmb3IgZXhwZWN0ZWQgbW9jayAnICsgbW9jay5tZXRob2QoKSArICcgJyArIG1vY2sucGF0aCgpKTtcblxuICAgICAgICByZXR1cm4gbW9jaztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLmFwaUNhbGwgPSBmdW5jdGlvbiBhcGlDYWxsKG1ldGhvZCwgcGF0aCwgcmVzcG9uc2UsIHN0YXR1cywgc3RhdHVzVGV4dCwgZGVsYXkpIHtcblxuICAgICAgICB0aGlzLmFkZChuZXcgX01vY2syLmRlZmF1bHQobWV0aG9kLCBwYXRoLCByZXNwb25zZSwgc3RhdHVzLCBzdGF0dXNUZXh0LCBkZWxheSkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuYXV0aGVudGljYXRpb24gPSBmdW5jdGlvbiBhdXRoZW50aWNhdGlvbigpIHtcblxuICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvb2F1dGgvdG9rZW4nLCB7XG4gICAgICAgICAgICAnYWNjZXNzX3Rva2VuJzogJ0FDQ0VTU19UT0tFTicsXG4gICAgICAgICAgICAndG9rZW5fdHlwZSc6ICdiZWFyZXInLFxuICAgICAgICAgICAgJ2V4cGlyZXNfaW4nOiAzNjAwLFxuICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW4nOiAnUkVGUkVTSF9UT0tFTicsXG4gICAgICAgICAgICAncmVmcmVzaF90b2tlbl9leHBpcmVzX2luJzogNjA0ODAsXG4gICAgICAgICAgICAnc2NvcGUnOiAnU01TIFJDTSBGb28gQm9vJyxcbiAgICAgICAgICAgICdleHBpcmVUaW1lJzogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyAzNjAwMDAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24gbG9nb3V0KCkge1xuXG4gICAgICAgIHRoaXMuYXBpQ2FsbCgnUE9TVCcsICcvcmVzdGFwaS9vYXV0aC9yZXZva2UnLCB7fSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5wcmVzZW5jZUxvYWQgPSBmdW5jdGlvbiBwcmVzZW5jZUxvYWQoaWQpIHtcblxuICAgICAgICB0aGlzLmFwaUNhbGwoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vJyArIGlkICsgJy9wcmVzZW5jZScsIHtcbiAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cHM6Ly9wbGF0Zm9ybS5yaW5nY2VudHJhbC5jb20vcmVzdGFwaS92MS4wL2FjY291bnQvMTIzL2V4dGVuc2lvbi9cIiArIGlkICsgXCIvcHJlc2VuY2VcIixcbiAgICAgICAgICAgIFwiZXh0ZW5zaW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHBzOi8vcGxhdGZvcm0ucmluZ2NlbnRyYWwuY29tL3Jlc3RhcGkvdjEuMC9hY2NvdW50LzEyMy9leHRlbnNpb24vXCIgKyBpZCxcbiAgICAgICAgICAgICAgICBcImlkXCI6IGlkLFxuICAgICAgICAgICAgICAgIFwiZXh0ZW5zaW9uTnVtYmVyXCI6IFwiMTAxXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFjdGl2ZUNhbGxzXCI6IFtdLFxuICAgICAgICAgICAgXCJwcmVzZW5jZVN0YXR1c1wiOiBcIkF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgXCJ0ZWxlcGhvbnlTdGF0dXNcIjogXCJSaW5naW5nXCIsXG4gICAgICAgICAgICBcInVzZXJTdGF0dXNcIjogXCJBdmFpbGFibGVcIixcbiAgICAgICAgICAgIFwiZG5kU3RhdHVzXCI6IFwiVGFrZUFsbENhbGxzXCIsXG4gICAgICAgICAgICBcImV4dGVuc2lvbklkXCI6IGlkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuc3Vic2NyaWJlR2VuZXJpYyA9IGZ1bmN0aW9uIHN1YnNjcmliZUdlbmVyaWMoZXhwaXJlc0luKSB7XG5cbiAgICAgICAgZXhwaXJlc0luID0gZXhwaXJlc0luIHx8IDE1ICogNjAgKiA2MDtcblxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgdGhpcy5hcGlDYWxsKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uJywge1xuICAgICAgICAgICAgJ2V2ZW50RmlsdGVycyc6IFsnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UnXSxcbiAgICAgICAgICAgICdleHBpcmF0aW9uVGltZSc6IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgZXhwaXJlc0luICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICdleHBpcmVzSW4nOiBleHBpcmVzSW4sXG4gICAgICAgICAgICAnZGVsaXZlcnlNb2RlJzoge1xuICAgICAgICAgICAgICAgICd0cmFuc3BvcnRUeXBlJzogJ1B1Yk51YicsXG4gICAgICAgICAgICAgICAgJ2VuY3J5cHRpb24nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnYWRkcmVzcyc6ICcxMjNfZm9vJyxcbiAgICAgICAgICAgICAgICAnc3Vic2NyaWJlcktleSc6ICdzdWItYy1mb28nLFxuICAgICAgICAgICAgICAgICdzZWNyZXRLZXknOiAnc2VjLWMtYmFyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpZCc6ICdmb28tYmFyLWJheicsXG4gICAgICAgICAgICAnY3JlYXRpb25UaW1lJzogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdBY3RpdmUnLFxuICAgICAgICAgICAgJ3VyaSc6ICdodHRwczovL3BsYXRmb3JtLnJpbmdjZW50cmFsLmNvbS9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uL2Zvby1iYXItYmF6J1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLnN1YnNjcmliZU9uUHJlc2VuY2UgPSBmdW5jdGlvbiBzdWJzY3JpYmVPblByZXNlbmNlKGlkLCBkZXRhaWxlZCkge1xuXG4gICAgICAgIGlkID0gaWQgfHwgJzEnO1xuXG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAnZXZlbnRGaWx0ZXJzJzogWycvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vJyArIGlkICsgJy9wcmVzZW5jZScgKyAoZGV0YWlsZWQgPyAnP2RldGFpbGVkVGVsZXBob255U3RhdGU9dHJ1ZScgOiAnJyldLFxuICAgICAgICAgICAgJ2V4cGlyYXRpb25UaW1lJzogbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgKyAxNSAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgJ2RlbGl2ZXJ5TW9kZSc6IHtcbiAgICAgICAgICAgICAgICAndHJhbnNwb3J0VHlwZSc6ICdQdWJOdWInLFxuICAgICAgICAgICAgICAgICdlbmNyeXB0aW9uJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnYWRkcmVzcyc6ICcxMjNfZm9vJyxcbiAgICAgICAgICAgICAgICAnc3Vic2NyaWJlcktleSc6ICdzdWItYy1mb28nLFxuICAgICAgICAgICAgICAgICdzZWNyZXRLZXknOiAnc2VjLWMtYmFyJyxcbiAgICAgICAgICAgICAgICAnZW5jcnlwdGlvbkFsZ29yaXRobSc6ICdBRVMnLFxuICAgICAgICAgICAgICAgICdlbmNyeXB0aW9uS2V5JzogJ1ZRd2I2RVZOY1FQQmhFL0pnRloyenc9PSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY3JlYXRpb25UaW1lJzogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgJ2lkJzogJ2Zvby1iYXItYmF6JyxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnQWN0aXZlJyxcbiAgICAgICAgICAgICd1cmknOiAnaHR0cHM6Ly9wbGF0Zm9ybS5yaW5nY2VudHJhbC5jb20vcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbi9mb28tYmFyLWJheidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS50b2tlblJlZnJlc2ggPSBmdW5jdGlvbiB0b2tlblJlZnJlc2goZmFpbHVyZSkge1xuXG4gICAgICAgIGlmICghZmFpbHVyZSkge1xuXG4gICAgICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvb2F1dGgvdG9rZW4nLCB7XG4gICAgICAgICAgICAgICAgJ2FjY2Vzc190b2tlbic6ICdBQ0NFU1NfVE9LRU5fRlJPTV9SRUZSRVNIJyxcbiAgICAgICAgICAgICAgICAndG9rZW5fdHlwZSc6ICdiZWFyZXInLFxuICAgICAgICAgICAgICAgICdleHBpcmVzX2luJzogMzYwMCxcbiAgICAgICAgICAgICAgICAncmVmcmVzaF90b2tlbic6ICdSRUZSRVNIX1RPS0VOX0ZST01fUkVGUkVTSCcsXG4gICAgICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW5fZXhwaXJlc19pbic6IDYwNDgwLFxuICAgICAgICAgICAgICAgICdzY29wZSc6ICdTTVMgUkNNIEZvbyBCb28nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5hcGlDYWxsKCdQT1NUJywgJy9yZXN0YXBpL29hdXRoL3Rva2VuJywge1xuICAgICAgICAgICAgICAgICdtZXNzYWdlJzogJ1dyb25nIHRva2VuJyxcbiAgICAgICAgICAgICAgICAnZXJyb3JfZGVzY3JpcHRpb24nOiAnV3JvbmcgdG9rZW4nLFxuICAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbic6ICdXcm9uZyB0b2tlbidcbiAgICAgICAgICAgIH0sIDQwMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlZ2lzdHJ5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZWdpc3RyeTtcblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfQXBpUmVzcG9uc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9BcGlSZXNwb25zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BcGlSZXNwb25zZSk7XG5cbnZhciBfVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBfRXh0ZXJuYWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBfRXh0ZXJuYWxzLlByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTW9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2NrKG1ldGhvZCwgcGF0aCwganNvbiwgc3RhdHVzLCBzdGF0dXNUZXh0LCBkZWxheSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9jayk7XG5cbiAgICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLl9qc29uID0ganNvbiB8fCB7fTtcbiAgICAgICAgdGhpcy5fZGVsYXkgPSBkZWxheSB8fCAxMDtcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gc3RhdHVzIHx8IDIwMDtcbiAgICAgICAgdGhpcy5fc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgJ09LJztcbiAgICB9XG5cbiAgICBNb2NrLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgfTtcblxuICAgIE1vY2sucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uIG1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZDtcbiAgICB9O1xuXG4gICAgTW9jay5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIHRlc3QocmVxdWVzdCkge1xuXG4gICAgICAgIHJldHVybiByZXF1ZXN0LnVybC5pbmRleE9mKHRoaXMuX3BhdGgpID4gLTEgJiYgcmVxdWVzdC5tZXRob2QudG9VcHBlckNhc2UoKSA9PSB0aGlzLl9tZXRob2Q7XG4gICAgfTtcblxuICAgIE1vY2sucHJvdG90eXBlLmdldFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX1V0aWxzLmRlbGF5KSh0aGlzLl9kZWxheSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCB0aGlzLmNyZWF0ZVJlc3BvbnNlKHRoaXMuX2pzb24pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRSZXNwb25zZShfeCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRSZXNwb25zZTtcbiAgICB9KCk7XG5cbiAgICBNb2NrLnByb3RvdHlwZS5jcmVhdGVSZXNwb25zZSA9IGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlKGpzb24sIGluaXQpIHtcblxuICAgICAgICBpbml0ID0gaW5pdCB8fCB7fTtcblxuICAgICAgICBpbml0LnN0YXR1cyA9IGluaXQuc3RhdHVzIHx8IHRoaXMuX3N0YXR1cztcbiAgICAgICAgaW5pdC5zdGF0dXNUZXh0ID0gaW5pdC5zdGF0dXNUZXh0IHx8IHRoaXMuX3N0YXR1c1RleHQ7XG5cbiAgICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KGpzb24pLFxuICAgICAgICAgICAgcmVzID0gbmV3IF9FeHRlcm5hbHMuUmVzcG9uc2Uoc3RyLCBpbml0KTtcblxuICAgICAgICByZXMuaGVhZGVycy5zZXQoX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9jb250ZW50VHlwZSwgX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9qc29uQ29udGVudFR5cGUpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHJldHVybiBNb2NrO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNb2NrO1xuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfQXV0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX0F1dGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXV0aCk7XG5cbnZhciBfVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBfRXh0ZXJuYWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBfRXh0ZXJuYWxzLlByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBQbGF0Zm9ybSA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKFBsYXRmb3JtLCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIGZ1bmN0aW9uIFBsYXRmb3JtKGNsaWVudCwgY2FjaGUsIHNlcnZlciwgYXBwS2V5LCBhcHBTZWNyZXQsIGFwcE5hbWUsIGFwcFZlcnNpb24sIHNka1ZlcnNpb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXRmb3JtKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIGJlZm9yZUxvZ2luOiAnYmVmb3JlTG9naW4nLFxuICAgICAgICAgICAgbG9naW5TdWNjZXNzOiAnbG9naW5TdWNjZXNzJyxcbiAgICAgICAgICAgIGxvZ2luRXJyb3I6ICdsb2dpbkVycm9yJyxcbiAgICAgICAgICAgIGJlZm9yZVJlZnJlc2g6ICdiZWZvcmVSZWZyZXNoJyxcbiAgICAgICAgICAgIHJlZnJlc2hTdWNjZXNzOiAncmVmcmVzaFN1Y2Nlc3MnLFxuICAgICAgICAgICAgcmVmcmVzaEVycm9yOiAncmVmcmVzaEVycm9yJyxcbiAgICAgICAgICAgIGJlZm9yZUxvZ291dDogJ2JlZm9yZUxvZ291dCcsXG4gICAgICAgICAgICBsb2dvdXRTdWNjZXNzOiAnbG9nb3V0U3VjY2VzcycsXG4gICAgICAgICAgICBsb2dvdXRFcnJvcjogJ2xvZ291dEVycm9yJ1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgX3RoaXMuX3NlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgX3RoaXMuX2FwcEtleSA9IGFwcEtleTtcbiAgICAgICAgX3RoaXMuX2FwcFNlY3JldCA9IGFwcFNlY3JldDtcblxuICAgICAgICAvKiogQHR5cGUge0NhY2hlfSAqL1xuICAgICAgICBfdGhpcy5fY2FjaGUgPSBjYWNoZTtcblxuICAgICAgICAvKiogQHR5cGUge0NsaWVudH0gKi9cbiAgICAgICAgX3RoaXMuX2NsaWVudCA9IGNsaWVudDtcblxuICAgICAgICAvKiogQHR5cGUge1Byb21pc2U8QXBpUmVzcG9uc2U+fSAqL1xuICAgICAgICBfdGhpcy5fcmVmcmVzaFByb21pc2UgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLl9hdXRoID0gbmV3IF9BdXRoMi5kZWZhdWx0KF90aGlzLl9jYWNoZSwgUGxhdGZvcm0uX2NhY2hlSWQpO1xuXG4gICAgICAgIF90aGlzLl91c2VyQWdlbnQgPSAoYXBwTmFtZSA/IGFwcE5hbWUgKyAoYXBwVmVyc2lvbiA/ICcvJyArIGFwcFZlcnNpb24gOiAnJykgKyAnICcgOiAnJykgKyAnUkNKU1NESy8nICsgc2RrVmVyc2lvbjtcblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXV0aH1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbiBhdXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0aDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Q2xpZW50fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuY2xpZW50ID0gZnVuY3Rpb24gY2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFkZFNlcnZlcl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWRkTWV0aG9kXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWRkVG9rZW5dXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuY3JlYXRlVXJsID0gZnVuY3Rpb24gY3JlYXRlVXJsKHBhdGgsIG9wdGlvbnMpIHtcblxuICAgICAgICBwYXRoID0gcGF0aCB8fCAnJztcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGJ1aWx0VXJsID0gJycsXG4gICAgICAgICAgICBoYXNIdHRwID0gcGF0aC5pbmRleE9mKCdodHRwOi8vJykgIT0gLTEgfHwgcGF0aC5pbmRleE9mKCdodHRwczovLycpICE9IC0xO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFkZFNlcnZlciAmJiAhaGFzSHR0cCkgYnVpbHRVcmwgKz0gdGhpcy5fc2VydmVyO1xuXG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoUGxhdGZvcm0uX3VybFByZWZpeCkgPT0gLTEgJiYgIWhhc0h0dHApIGJ1aWx0VXJsICs9IFBsYXRmb3JtLl91cmxQcmVmaXggKyAnLycgKyBQbGF0Zm9ybS5fYXBpVmVyc2lvbjtcblxuICAgICAgICBidWlsdFVybCArPSBwYXRoO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFkZE1ldGhvZCB8fCBvcHRpb25zLmFkZFRva2VuKSBidWlsdFVybCArPSBwYXRoLmluZGV4T2YoJz8nKSA+IC0xID8gJyYnIDogJz8nO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFkZE1ldGhvZCkgYnVpbHRVcmwgKz0gJ19tZXRob2Q9JyArIG9wdGlvbnMuYWRkTWV0aG9kO1xuICAgICAgICBpZiAob3B0aW9ucy5hZGRUb2tlbikgYnVpbHRVcmwgKz0gKG9wdGlvbnMuYWRkTWV0aG9kID8gJyYnIDogJycpICsgJ2FjY2Vzc190b2tlbj0nICsgdGhpcy5fYXV0aC5hY2Nlc3NUb2tlbigpO1xuXG4gICAgICAgIHJldHVybiBidWlsdFVybDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucmVkaXJlY3RVcmlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zdGF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJyYW5kSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5kaXNwbGF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucHJvbXB0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmxvZ2luVXJsID0gZnVuY3Rpb24gbG9naW5Vcmwob3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVVybChQbGF0Zm9ybS5fYXV0aG9yaXplRW5kcG9pbnQgKyAnPycgKyAoMCwgX1V0aWxzLnF1ZXJ5U3RyaW5naWZ5KSh7XG4gICAgICAgICAgICAncmVzcG9uc2VfdHlwZSc6ICdjb2RlJyxcbiAgICAgICAgICAgICdyZWRpcmVjdF91cmknOiBvcHRpb25zLnJlZGlyZWN0VXJpIHx8ICcnLFxuICAgICAgICAgICAgJ2NsaWVudF9pZCc6IHRoaXMuX2FwcEtleSxcbiAgICAgICAgICAgICdzdGF0ZSc6IG9wdGlvbnMuc3RhdGUgfHwgJycsXG4gICAgICAgICAgICAnYnJhbmRfaWQnOiBvcHRpb25zLmJyYW5kSWQgfHwgJycsXG4gICAgICAgICAgICAnZGlzcGxheSc6IG9wdGlvbnMuZGlzcGxheSB8fCAnJyxcbiAgICAgICAgICAgICdwcm9tcHQnOiBvcHRpb25zLnByb21wdCB8fCAnJ1xuICAgICAgICB9KSwgeyBhZGRTZXJ2ZXI6IHRydWUgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5wYXJzZUxvZ2luUmVkaXJlY3RVcmwgPSBmdW5jdGlvbiBwYXJzZUxvZ2luUmVkaXJlY3RVcmwodXJsKSB7XG5cbiAgICAgICAgdmFyIHFzID0gKDAsIF9VdGlscy5wYXJzZVF1ZXJ5U3RyaW5nKSh1cmwuc3BsaXQoJz8nKS5yZXZlcnNlKClbMF0pLFxuICAgICAgICAgICAgZXJyb3IgPSBxcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCBxcy5lcnJvcjtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGUuZXJyb3IgPSBxcy5lcnJvcjtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBoYW5kbGUgMy1sZWdnZWQgT0F1dGhcbiAgICAgKlxuICAgICAqIEF0dGVudGlvbiEgVGhpcyBpcyBhbiBleHBlcmltZW50YWwgbWV0aG9kIGFuZCBpdCdzIHNpZ25hdHVyZSBhbmQgYmVoYXZpb3IgbWF5IGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubG9naW5dIGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9naW4oKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vcmlnaW5dXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb3BlcnR5XSBuYW1lIG9mIHdpbmRvdy5wb3N0TWVzc2FnZSdzIGV2ZW50IGRhdGEgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGFyZ2V0XSB0YXJnZXQgZm9yIHdpbmRvdy5vcGVuKClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmxcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUubG9naW5XaW5kb3cgPSBmdW5jdGlvbiBsb2dpbldpbmRvdyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgX0V4dGVybmFscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgaWYgKCEoMCwgX1V0aWxzLmlzQnJvd3NlcikoKSkgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBvbmx5IGluIGJyb3dzZXInKTtcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVybCkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIG1hbmRhdG9yeSBVUkwgcGFyYW1ldGVyJyk7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLnVybCB8fCA0MDA7XG4gICAgICAgICAgICBvcHRpb25zLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCA0MDA7XG4gICAgICAgICAgICBvcHRpb25zLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IDYwMDtcbiAgICAgICAgICAgIG9wdGlvbnMub3JpZ2luID0gb3B0aW9ucy5vcmlnaW4gfHwgd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgICAgIG9wdGlvbnMucHJvcGVydHkgPSBvcHRpb25zLnByb3BlcnR5IHx8ICdSQ0F1dGhvcml6YXRpb25Db2RlJztcbiAgICAgICAgICAgIG9wdGlvbnMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgJ19ibGFuayc7XG5cbiAgICAgICAgICAgIHZhciBkdWFsU2NyZWVuTGVmdCA9IHdpbmRvdy5zY3JlZW5MZWZ0ICE9IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5MZWZ0IDogc2NyZWVuLmxlZnQ7XG4gICAgICAgICAgICB2YXIgZHVhbFNjcmVlblRvcCA9IHdpbmRvdy5zY3JlZW5Ub3AgIT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlblRvcCA6IHNjcmVlbi50b3A7XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoID8gd2luZG93LmlubmVyV2lkdGggOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggOiBzY3JlZW4ud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ID8gd2luZG93LmlubmVySGVpZ2h0IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiBzY3JlZW4uaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHdpZHRoIC8gMiAtIG9wdGlvbnMud2lkdGggLyAyICsgZHVhbFNjcmVlbkxlZnQ7XG4gICAgICAgICAgICB2YXIgdG9wID0gaGVpZ2h0IC8gMiAtIG9wdGlvbnMuaGVpZ2h0IC8gMiArIGR1YWxTY3JlZW5Ub3A7XG4gICAgICAgICAgICB2YXIgd2luID0gd2luZG93Lm9wZW4ob3B0aW9ucy51cmwsICdfYmxhbmsnLCBvcHRpb25zLnRhcmdldCA9PSAnX2JsYW5rJyA/ICdzY3JvbGxiYXJzPXllcywgc3RhdHVzPXllcywgd2lkdGg9JyArIG9wdGlvbnMud2lkdGggKyAnLCBoZWlnaHQ9JyArIG9wdGlvbnMuaGVpZ2h0ICsgJywgbGVmdD0nICsgbGVmdCArICcsIHRvcD0nICsgdG9wIDogJycpO1xuXG4gICAgICAgICAgICBpZiAod2luZG93LmZvY3VzKSB3aW4uZm9jdXMoKTtcblxuICAgICAgICAgICAgdmFyIGV2ZW50TWV0aG9kID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAnYXR0YWNoRXZlbnQnO1xuICAgICAgICAgICAgdmFyIGV2ZW50UmVtb3ZlTWV0aG9kID0gZXZlbnRNZXRob2QgPT0gJ2FkZEV2ZW50TGlzdGVuZXInID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2RldGFjaEV2ZW50JztcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRXZlbnQgPSBldmVudE1ldGhvZCA9PSAnYWRkRXZlbnRMaXN0ZW5lcicgPyAnbWVzc2FnZScgOiAnb25tZXNzYWdlJztcblxuICAgICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBldmVudExpc3RlbmVyKGUpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiAhPSBvcHRpb25zLm9yaWdpbikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghZS5kYXRhIHx8ICFlLmRhdGFbb3B0aW9ucy5wcm9wZXJ0eV0pIHJldHVybjsgLy8ga2VlcCB3YWl0aW5nXG5cbiAgICAgICAgICAgICAgICB3aW4uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB3aW5kb3dbZXZlbnRSZW1vdmVNZXRob2RdKG1lc3NhZ2VFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2dpbk9wdGlvbnMgPSBfdGhpczIucGFyc2VMb2dpblJlZGlyZWN0VXJsKGUuZGF0YVtvcHRpb25zLnByb3BlcnR5XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2dpbk9wdGlvbnMuY29kZSkgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRob3JpemF0aW9uIGNvZGUnKTtcblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGxvZ2luT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2luZG93W2V2ZW50TWV0aG9kXShtZXNzYWdlRXZlbnQsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5sb2dnZWRJbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUxvZ2dlZEluKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwgNl1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvZ2dlZEluKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2dnZWRJbjtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51c2VybmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZXh0ZW5zaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY29kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlZGlyZWN0VXJpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZW5kcG9pbnRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlbWVtYmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYWNjZXNzVG9rZW5UdGxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZWZyZXNoVG9rZW5UdGxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGJvZHksIGFwaVJlc3BvbnNlLCBqc29uO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmJlZm9yZUxvZ2luKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSB7fTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNvZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LmdyYW50X3R5cGUgPSAncGFzc3dvcmQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LnVzZXJuYW1lID0gb3B0aW9ucy51c2VybmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5wYXNzd29yZCA9IG9wdGlvbnMucGFzc3dvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuZXh0ZW5zaW9uID0gb3B0aW9ucy5leHRlbnNpb24gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmNvZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LmdyYW50X3R5cGUgPSAnYXV0aG9yaXphdGlvbl9jb2RlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5jb2RlID0gb3B0aW9ucy5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LnJlZGlyZWN0X3VyaSA9IG9wdGlvbnMucmVkaXJlY3RVcmk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYm9keS5jbGllbnRfaWQgPSB0aGlzLmdldENyZWRlbnRpYWxzKCkua2V5OyAvLyBub3QgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5kcG9pbnRJZCkgYm9keS5lbmRwb2ludF9pZCA9IG9wdGlvbnMuZW5kcG9pbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hY2Nlc3NUb2tlblR0bCkgYm9keS5hY2Nlc3NUb2tlblR0bCA9IG9wdGlvbnMuYWNjZXNzVG9rZW5UdGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVmcmVzaFRva2VuVHRsKSBib2R5LnJlZnJlc2hUb2tlblR0bCA9IG9wdGlvbnMucmVmcmVzaFRva2VuVHRsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5SZXF1ZXN0KFBsYXRmb3JtLl90b2tlbkVuZHBvaW50LCBib2R5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSBhcGlSZXNwb25zZS5qc29uKCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGguc2V0RGF0YShqc29uKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5sb2dpblN1Y2Nlc3MsIGFwaVJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGFwaVJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmxvZ2luRXJyb3IsIF9jb250ZXh0Mi50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDIudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCAxN11dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvZ2luKF94KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2dpbjtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLl9yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgICAgIHZhciByZXMsIGpzb247XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmJlZm9yZVJlZnJlc2gpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX1V0aWxzLmRlbGF5KShQbGF0Zm9ybS5fcmVmcmVzaERlbGF5TXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F1dGgucmVmcmVzaFRva2VuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZnJlc2ggdG9rZW4gaXMgbWlzc2luZycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F1dGgucmVmcmVzaFRva2VuVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmcmVzaCB0b2tlbiBoYXMgZXhwaXJlZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5SZXF1ZXN0KFBsYXRmb3JtLl90b2tlbkVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ3JhbnRfdHlwZVwiOiBcInJlZnJlc2hfdG9rZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWZyZXNoX3Rva2VuXCI6IHRoaXMuX2F1dGgucmVmcmVzaFRva2VuKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWNjZXNzX3Rva2VuX3R0bFwiOiB0aGlzLl9hdXRoLmRhdGEoKS5leHBpcmVzX2luICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWZyZXNoX3Rva2VuX3R0bFwiOiB0aGlzLl9hdXRoLmRhdGEoKS5yZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW4gKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IHJlcy5qc29uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY2xpZW50Lm1ha2VFcnJvcihuZXcgRXJyb3IoJ01hbGZvcm1lZCBPQXV0aCByZXNwb25zZScpLCByZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aC5zZXREYXRhKGpzb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLnJlZnJlc2hTdWNjZXNzLCByZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSB0aGlzLl9jbGllbnQubWFrZUVycm9yKF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoUGxhdGZvcm0uX2NsZWFyQ2FjaGVPblJlZnJlc2hFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5yZWZyZXNoRXJyb3IsIF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDMudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMywgdGhpcywgW1swLCAxOV1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9yZWZyZXNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3JlZnJlc2g7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JlZnJlc2hQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fcmVmcmVzaFByb21pc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAyO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoUHJvbWlzZSA9IHRoaXMuX3JlZnJlc2goKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzLl9yZWZyZXNoUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9yZWZyZXNoUHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMik7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDQudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1syLCA3XV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZnJlc2g7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjUgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmJlZm9yZUxvZ291dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuUmVxdWVzdChQbGF0Zm9ybS5fcmV2b2tlRW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMuX2F1dGguYWNjZXNzVG9rZW4oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ1LnNlbnQ7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNsZWFuKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMubG9nb3V0U3VjY2VzcywgcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHJlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgwKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmxvZ291dEVycm9yLCBfY29udGV4dDUudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ1LnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTUsIHRoaXMsIFtbMCwgMTBdXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2dvdXQ7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEF1dGhDaGVja11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlcXVlc3Q+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuaW5mbGF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmNiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5za2lwQXV0aENoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTG9nZ2VkSW4oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldCgnWC1Vc2VyLUFnZW50JywgdGhpcy5fdXNlckFnZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdDbGllbnQtSWQnLCB0aGlzLl9hcHBLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCB0aGlzLl9hdXRoSGVhZGVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVxdWVzdC51cmwgPSB0aGlzLmNyZWF0ZVVybChyZXF1ZXN0LnVybCwge2FkZFNlcnZlcjogdHJ1ZX0pOyAvL0ZJWE1FIFNwZWMgcHJldmVudHMgdGhpcy4uLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluZmxhdGVSZXF1ZXN0KF94MiwgX3gzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmZsYXRlUmVxdWVzdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmNyA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlUmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ny5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcudDAgPSBfY29udGV4dDdbXCJjYXRjaFwiXSgwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFfY29udGV4dDcudDAuYXBpUmVzcG9uc2UgfHwgIV9jb250ZXh0Ny50MC5hcGlSZXNwb25zZS5yZXNwb25zZSgpIHx8IF9jb250ZXh0Ny50MC5hcGlSZXNwb25zZS5yZXNwb25zZSgpLnN0YXR1cyAhPSA0MDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0Ny50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGguY2FuY2VsQWNjZXNzVG9rZW4oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ3LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMsIFtbMCwgOV1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KF94NCwgX3g1KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZW5kUmVxdWVzdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmFsIHB1cnBvc2UgZnVuY3Rpb24gdG8gc2VuZCBhbnl0aGluZyB0byBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuYm9keV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWV0aG9kXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5xdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjggPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9GSVhNRSBodHRwczovL2dpdGh1Yi5jb20vYml0aW5uL25vZGUtZmV0Y2gvaXNzdWVzLzQzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB0aGlzLmNyZWF0ZVVybChvcHRpb25zLnVybCwgeyBhZGRTZXJ2ZXI6IHRydWUgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QodGhpcy5fY2xpZW50LmNyZWF0ZVJlcXVlc3Qob3B0aW9ucyksIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ4LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlOCwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBzZW5kKF94Nikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWY4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VuZDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtxdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjkgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOSh1cmwsIHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ5LnByZXYgPSBfY29udGV4dDkubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ5LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXQoX3g4LCBfeDksIF94MTApIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmOS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3F1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjEwID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKHVybCwgYm9keSwgcXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDEwLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTEwLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHBvc3QoX3gxMSwgX3gxMiwgX3gxMywgX3gxNCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbYm9keV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3F1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMTEgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEodXJsLCBib2R5LCBxdWVyeSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnUFVUJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQxMS5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUxMSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBwdXQoX3gxNSwgX3gxNiwgX3gxNywgX3gxOCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB1dDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtxdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjEyID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEyKHVybCwgcXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTIkKF9jb250ZXh0MTIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDEyLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9kZWxldGUoX3gxOSwgX3gyMCwgX3gyMSkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9kZWxldGU7XG4gICAgfSgpO1xuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLl90b2tlblJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMTMgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMocGF0aCwgYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMyQoX2NvbnRleHQxMykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMy5wcmV2ID0gX2NvbnRleHQxMy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwQXV0aENoZWNrOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmFzaWMgJyArIHRoaXMuX2FwaUtleSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDEzLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTEzLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF90b2tlblJlcXVlc3QoX3gyMiwgX3gyMykge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90b2tlblJlcXVlc3Q7XG4gICAgfSgpO1xuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmVuc3VyZUxvZ2dlZEluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjE0ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNCQoX2NvbnRleHQxNCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNC5wcmV2ID0gX2NvbnRleHQxNC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0FjY2Vzc1Rva2VuVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDE0LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTE0LCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVuc3VyZUxvZ2dlZEluKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVuc3VyZUxvZ2dlZEluO1xuICAgIH0oKTtcblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5faXNBY2Nlc3NUb2tlblZhbGlkID0gZnVuY3Rpb24gX2lzQWNjZXNzVG9rZW5WYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGguYWNjZXNzVG9rZW5WYWxpZCgpO1xuICAgIH07XG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuX2FwaUtleSA9IGZ1bmN0aW9uIF9hcGlLZXkoKSB7XG4gICAgICAgIHZhciBhcGlLZXkgPSB0aGlzLl9hcHBLZXkgKyAnOicgKyB0aGlzLl9hcHBTZWNyZXQ7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYnRvYSA9PSAnZnVuY3Rpb24nID8gYnRvYShhcGlLZXkpIDogbmV3IEJ1ZmZlcihhcGlLZXkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9O1xuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLl9hdXRoSGVhZGVyID0gZnVuY3Rpb24gX2F1dGhIZWFkZXIoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX2F1dGguYWNjZXNzVG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGgudG9rZW5UeXBlKCkgKyAodG9rZW4gPyAnICcgKyB0b2tlbiA6ICcnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBsYXRmb3JtO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuUGxhdGZvcm0uX3VybFByZWZpeCA9ICcvcmVzdGFwaSc7XG5QbGF0Zm9ybS5fYXBpVmVyc2lvbiA9ICd2MS4wJztcblBsYXRmb3JtLl90b2tlbkVuZHBvaW50ID0gJy9yZXN0YXBpL29hdXRoL3Rva2VuJztcblBsYXRmb3JtLl9yZXZva2VFbmRwb2ludCA9ICcvcmVzdGFwaS9vYXV0aC9yZXZva2UnO1xuUGxhdGZvcm0uX2F1dGhvcml6ZUVuZHBvaW50ID0gJy9yZXN0YXBpL29hdXRoL2F1dGhvcml6ZSc7XG5QbGF0Zm9ybS5fcmVmcmVzaERlbGF5TXMgPSAxMDA7XG5QbGF0Zm9ybS5fY2FjaGVJZCA9ICdwbGF0Zm9ybSc7XG5QbGF0Zm9ybS5fY2xlYXJDYWNoZU9uUmVmcmVzaEVycm9yID0gZmFsc2U7XG5leHBvcnRzLmRlZmF1bHQgPSBQbGF0Zm9ybTtcblxuLyoqKi8gfSxcbi8qIDE2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQXV0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRoKGNhY2hlLCBjYWNoZUlkKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdXRoKTtcblxuICAgICAgICAvKiogQHR5cGUge0NhY2hlfSAqL1xuICAgICAgICB0aGlzLl9jYWNoZSA9IGNhY2hlO1xuICAgICAgICB0aGlzLl9jYWNoZUlkID0gY2FjaGVJZDtcbiAgICB9IC8vIDEgbWludXRlXG5cblxuICAgIEF1dGgucHJvdG90eXBlLmFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gYWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKS5hY2Nlc3NfdG9rZW47XG4gICAgfTtcblxuICAgIEF1dGgucHJvdG90eXBlLnJlZnJlc2hUb2tlbiA9IGZ1bmN0aW9uIHJlZnJlc2hUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpLnJlZnJlc2hfdG9rZW47XG4gICAgfTtcblxuICAgIEF1dGgucHJvdG90eXBlLnRva2VuVHlwZSA9IGZ1bmN0aW9uIHRva2VuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpLnRva2VuX3R5cGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3t0b2tlbl90eXBlOiBzdHJpbmcsIGFjY2Vzc190b2tlbjogc3RyaW5nLCBleHBpcmVzX2luOiBudW1iZXIsIHJlZnJlc2hfdG9rZW46IHN0cmluZywgcmVmcmVzaF90b2tlbl9leHBpcmVzX2luOiBudW1iZXJ9fVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gZGF0YSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZ2V0SXRlbSh0aGlzLl9jYWNoZUlkKSB8fCB7XG4gICAgICAgICAgICB0b2tlbl90eXBlOiAnJyxcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogJycsXG4gICAgICAgICAgICBleHBpcmVzX2luOiAwLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogJycsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW46IDBcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld0RhdGFcbiAgICAgKiBAcmV0dXJuIHtBdXRofVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShuZXdEYXRhKSB7XG5cbiAgICAgICAgbmV3RGF0YSA9IG5ld0RhdGEgfHwge307XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEoKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhuZXdEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IG5ld0RhdGFba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGF0YS5leHBpcmVfdGltZSA9IERhdGUubm93KCkgKyBkYXRhLmV4cGlyZXNfaW4gKiAxMDAwO1xuICAgICAgICBkYXRhLnJlZnJlc2hfdG9rZW5fZXhwaXJlX3RpbWUgPSBEYXRlLm5vdygpICsgZGF0YS5yZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW4gKiAxMDAwO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlLnNldEl0ZW0odGhpcy5fY2FjaGVJZCwgZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGEgdmFsaWQgKG5vdCBleHBpcmVkKSBhY2Nlc3MgdG9rZW5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5hY2Nlc3NUb2tlblZhbGlkID0gZnVuY3Rpb24gYWNjZXNzVG9rZW5WYWxpZCgpIHtcblxuICAgICAgICB2YXIgYXV0aERhdGEgPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgcmV0dXJuIGF1dGhEYXRhLnRva2VuX3R5cGUgPT09IEF1dGguZm9yY2VkVG9rZW5UeXBlIHx8IGF1dGhEYXRhLmV4cGlyZV90aW1lIC0gQXV0aC5yZWZyZXNoSGFuZGljYXBNcyA+IERhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGEgdmFsaWQgKG5vdCBleHBpcmVkKSBhY2Nlc3MgdG9rZW5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5yZWZyZXNoVG9rZW5WYWxpZCA9IGZ1bmN0aW9uIHJlZnJlc2hUb2tlblZhbGlkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKS5yZWZyZXNoX3Rva2VuX2V4cGlyZV90aW1lID4gRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXV0aH1cbiAgICAgKi9cblxuXG4gICAgQXV0aC5wcm90b3R5cGUuY2FuY2VsQWNjZXNzVG9rZW4gPSBmdW5jdGlvbiBjYW5jZWxBY2Nlc3NUb2tlbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogJycsXG4gICAgICAgICAgICBleHBpcmVzX2luOiAwXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIGEgc3BlY2lhbCBhdXRoZW50aWNhdGlvbiBtb2RlIHVzZWQgaW4gU2VydmljZSBXZWJcbiAgICAgKiBAcmV0dXJuIHtBdXRofVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5mb3JjZUF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gZm9yY2VBdXRoZW50aWNhdGlvbigpIHtcblxuICAgICAgICB0aGlzLnNldERhdGEoe1xuICAgICAgICAgICAgdG9rZW5fdHlwZTogQXV0aC5mb3JjZWRUb2tlblR5cGUsXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46ICcnLFxuICAgICAgICAgICAgZXhwaXJlc19pbjogMCxcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46ICcnLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbl9leHBpcmVzX2luOiAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXV0aDtcbn0oKTtcblxuLy9leHBvcnQgaW50ZXJmYWNlIElBdXRoRGF0YSB7XG4vLyAgICByZW1lbWJlcj86Ym9vbGVhbjtcbi8vICAgIHRva2VuX3R5cGU/OnN0cmluZztcbi8vICAgIGFjY2Vzc190b2tlbj86c3RyaW5nO1xuLy8gICAgZXhwaXJlc19pbj86bnVtYmVyOyAvLyBhY3R1YWxseSBpdCdzIHN0cmluZ1xuLy8gICAgZXhwaXJlX3RpbWU/Om51bWJlcjtcbi8vICAgIHJlZnJlc2hfdG9rZW4/OnN0cmluZztcbi8vICAgIHJlZnJlc2hfdG9rZW5fZXhwaXJlc19pbj86bnVtYmVyOyAvLyBhY3R1YWxseSBpdCdzIHN0cmluZ1xuLy8gICAgcmVmcmVzaF90b2tlbl9leHBpcmVfdGltZT86bnVtYmVyO1xuLy8gICAgc2NvcGU/OnN0cmluZztcbi8vfVxuXG5cbkF1dGgucmVmcmVzaEhhbmRpY2FwTXMgPSA2MCAqIDEwMDA7XG5BdXRoLmZvcmNlZFRva2VuVHlwZSA9ICdmb3JjZWQnO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXV0aDtcblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1B1Ym51Yk1vY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIF9QdWJudWJNb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1B1Ym51Yk1vY2spO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQdWJudWJNb2NrRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdWJudWJNb2NrRmFjdG9yeSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFB1Ym51Yk1vY2tGYWN0b3J5KTtcblxuICAgICAgICB0aGlzLmNyeXB0b19vYmogPSBfRXh0ZXJuYWxzLlBVQk5VQi5jcnlwdG9fb2JqO1xuICAgIH1cblxuICAgIFB1Ym51Yk1vY2tGYWN0b3J5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1B1Ym51Yk1vY2syLmRlZmF1bHQob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBQdWJudWJNb2NrRmFjdG9yeTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUHVibnViTW9ja0ZhY3Rvcnk7XG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUHVibnViTW9jayA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKFB1Ym51Yk1vY2ssIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgZnVuY3Rpb24gUHVibnViTW9jayhvcHRpb25zKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdWJudWJNb2NrKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBfdGhpcy5jcnlwdG9fb2JqID0gX0V4dGVybmFscy5QVUJOVUIuY3J5cHRvX29iajtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFB1Ym51Yk1vY2sucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9O1xuXG4gICAgUHVibnViTW9jay5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiByZWFkeSgpIHt9O1xuXG4gICAgUHVibnViTW9jay5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vbignbWVzc2FnZS0nICsgb3B0aW9ucy5jaGFubmVsLCBvcHRpb25zLm1lc3NhZ2UpO1xuICAgIH07XG5cbiAgICBQdWJudWJNb2NrLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ21lc3NhZ2UtJyArIG9wdGlvbnMuY2hhbm5lbCk7XG4gICAgfTtcblxuICAgIFB1Ym51Yk1vY2sucHJvdG90eXBlLnJlY2VpdmVNZXNzYWdlID0gZnVuY3Rpb24gcmVjZWl2ZU1lc3NhZ2UobXNnLCBjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZS0nICsgY2hhbm5lbCwgbXNnLCAnZW52JywgY2hhbm5lbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBQdWJudWJNb2NrO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUHVibnViTW9jaztcblxuLyoqKi8gfSxcbi8qIDE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoU3Vic2NyaXB0aW9uLCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihwdWJudWJGYWN0b3J5LCBwbGF0Zm9ybSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic2NyaXB0aW9uKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbjogJ25vdGlmaWNhdGlvbicsXG4gICAgICAgICAgICByZW1vdmVTdWNjZXNzOiAncmVtb3ZlU3VjY2VzcycsXG4gICAgICAgICAgICByZW1vdmVFcnJvcjogJ3JlbW92ZUVycm9yJyxcbiAgICAgICAgICAgIHJlbmV3U3VjY2VzczogJ3JlbmV3U3VjY2VzcycsXG4gICAgICAgICAgICByZW5ld0Vycm9yOiAncmVuZXdFcnJvcicsXG4gICAgICAgICAgICBzdWJzY3JpYmVTdWNjZXNzOiAnc3Vic2NyaWJlU3VjY2VzcycsXG4gICAgICAgICAgICBzdWJzY3JpYmVFcnJvcjogJ3N1YnNjcmliZUVycm9yJ1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgX3RoaXMuX3B1Ym51YkZhY3RvcnkgPSBwdWJudWJGYWN0b3J5O1xuICAgICAgICBfdGhpcy5fcGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgX3RoaXMuX3B1Ym51YiA9IG51bGw7XG4gICAgICAgIF90aGlzLl9wdWJudWJMYXN0Q2hhbm5lbCA9IG51bGw7XG4gICAgICAgIF90aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbiA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc3Vic2NyaWJlZCA9IGZ1bmN0aW9uIHN1YnNjcmliZWQoKSB7XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9uKCk7XG5cbiAgICAgICAgcmV0dXJuICEhKHN1YnNjcmlwdGlvbi5pZCAmJiBzdWJzY3JpcHRpb24uZGVsaXZlcnlNb2RlICYmIHN1YnNjcmlwdGlvbi5kZWxpdmVyeU1vZGUuc3Vic2NyaWJlcktleSAmJiBzdWJzY3JpcHRpb24uZGVsaXZlcnlNb2RlLmFkZHJlc3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFsaXZlID0gZnVuY3Rpb24gYWxpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZWQoKSAmJiBEYXRlLm5vdygpIDwgdGhpcy5leHBpcmF0aW9uVGltZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmV4cGlyZWQgPSBmdW5jdGlvbiBleHBpcmVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZCgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICF0aGlzLnN1YnNjcmliZWQoKSB8fCBEYXRlLm5vdygpID4gdGhpcy5zdWJzY3JpcHRpb24oKS5leHBpcmF0aW9uVGltZTtcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5leHBpcmF0aW9uVGltZSA9IGZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5zdWJzY3JpcHRpb24oKS5leHBpcmF0aW9uVGltZSB8fCAwKS5nZXRUaW1lKCkgLSBTdWJzY3JpcHRpb24uX3JlbmV3SGFuZGljYXBNcztcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5zZXRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG5cbiAgICAgICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlQXRQdWJudWIoKTtcbiAgICAgICAgdGhpcy5fc2V0VGltZW91dCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIHN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbiB8fCB7fTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciB1cGRhdGVzIHN1YnNjcmlwdGlvbiBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgb25lXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFsaXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmV3KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyO1xuICAgIH0oKTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZXZlbnRGaWx0ZXJzID0gZnVuY3Rpb24gZXZlbnRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb24oKS5ldmVudEZpbHRlcnMgfHwgW107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50c1xuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGRFdmVudEZpbHRlcnMgPSBmdW5jdGlvbiBhZGRFdmVudEZpbHRlcnMoZXZlbnRzKSB7XG4gICAgICAgIHRoaXMuc2V0RXZlbnRGaWx0ZXJzKHRoaXMuZXZlbnRGaWx0ZXJzKCkuY29uY2F0KGV2ZW50cykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnRzXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnNldEV2ZW50RmlsdGVycyA9IGZ1bmN0aW9uIHNldEV2ZW50RmlsdGVycyhldmVudHMpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5ldmVudEZpbHRlcnMgPSBldmVudHM7XG4gICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGpzb247XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEZpbHRlcnMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50cyBhcmUgdW5kZWZpbmVkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtLnBvc3QoJy9zdWJzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RmlsdGVyczogdGhpcy5fZ2V0RnVsbEV2ZW50RmlsdGVycygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpdmVyeU1vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydFR5cGU6ICdQdWJOdWInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IHJlc3BvbnNlLmpzb24oKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdWJzY3JpcHRpb24oanNvbikuZW1pdCh0aGlzLmV2ZW50cy5zdWJzY3JpYmVTdWNjZXNzLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgncmV0dXJuJywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyWydjYXRjaCddKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSB0aGlzLl9wbGF0Zm9ybS5jbGllbnQoKS5tYWtlRXJyb3IoX2NvbnRleHQyLnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKS5lbWl0KHRoaXMuZXZlbnRzLnN1YnNjcmliZUVycm9yLCBfY29udGV4dDIudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQyLnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzAsIDEyXV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW5ldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGpzb247XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1YnNjcmlwdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRGaWx0ZXJzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudHMgYXJlIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybS5wdXQoJy9zdWJzY3JpcHRpb24vJyArIHRoaXMuc3Vic2NyaXB0aW9uKCkuaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRGaWx0ZXJzOiB0aGlzLl9nZXRGdWxsRXZlbnRGaWx0ZXJzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IHJlc3BvbnNlLmpzb24oKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdWJzY3JpcHRpb24oanNvbikuZW1pdCh0aGlzLmV2ZW50cy5yZW5ld1N1Y2Nlc3MsIHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCdyZXR1cm4nLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbJ2NhdGNoJ10oMCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IHRoaXMuX3BsYXRmb3JtLmNsaWVudCgpLm1ha2VFcnJvcihfY29udGV4dDMudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpLmVtaXQodGhpcy5ldmVudHMucmVuZXdFcnJvciwgX2NvbnRleHQzLnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0My50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMywgdGhpcywgW1swLCAxNF1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmV3KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZXc7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3Vic2NyaXB0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtLmRlbGV0ZSgnL3N1YnNjcmlwdGlvbi8nICsgdGhpcy5zdWJzY3JpcHRpb24oKS5pZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0NC5zZW50O1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCkuZW1pdCh0aGlzLmV2ZW50cy5yZW1vdmVTdWNjZXNzLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgncmV0dXJuJywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0WydjYXRjaCddKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQudDAgPSB0aGlzLl9wbGF0Zm9ybS5jbGllbnQoKS5tYWtlRXJyb3IoX2NvbnRleHQ0LnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5yZW1vdmVFcnJvciwgX2NvbnRleHQ0LnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0NC50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1swLCAxMF1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbW92ZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVzdWJzY3JpYmUgPSBmdW5jdGlvbiByZXN1YnNjcmliZSgpIHtcbiAgICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLmV2ZW50RmlsdGVycygpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpLnNldEV2ZW50RmlsdGVycyhmaWx0ZXJzKS5zdWJzY3JpYmUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHN1YnNjcmlwdGlvbiBhbmQgZGlzY29ubmVjdCBmcm9tIFBVQk5VQlxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyBzdWJzY3JpcHRpb24gYXQgY2xpZW50IHNpZGUgYnV0IGJhY2tlbmQgaXMgbm90IG5vdGlmaWVkXG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWQoKSAmJiB0aGlzLl9wdWJudWIpIHRoaXMuX3B1Ym51Yi51bnN1YnNjcmliZSh7IGNoYW5uZWw6IHRoaXMuc3Vic2NyaXB0aW9uKCkuZGVsaXZlcnlNb2RlLmFkZHJlc3MgfSk7XG4gICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3NldFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIF9zZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fZ2V0RnVsbEV2ZW50RmlsdGVycyA9IGZ1bmN0aW9uIF9nZXRGdWxsRXZlbnRGaWx0ZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudEZpbHRlcnMoKS5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9wbGF0Zm9ybS5jcmVhdGVVcmwoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fc2V0VGltZW91dCA9IGZ1bmN0aW9uIF9zZXRUaW1lb3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgICAgICBpZiAoIXRoaXMuYWxpdmUoKSkgdGhyb3cgbmV3IEVycm9yKCdTdWJzY3JpcHRpb24gaXMgbm90IGFsaXZlJyk7XG5cbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKF90aGlzMy5hbGl2ZSgpKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChfdGhpczMuZXhwaXJlZCgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpczMucmVuZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgU3Vic2NyaXB0aW9uLl9wb2xsSW50ZXJ2YWwpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fZGVjcnlwdCA9IGZ1bmN0aW9uIF9kZWNyeXB0KG1lc3NhZ2UpIHtcblxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZCgpKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1YnNjcmlwdGlvbicpO1xuXG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbigpLmRlbGl2ZXJ5TW9kZS5lbmNyeXB0aW9uS2V5KSB7XG5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9wdWJudWJGYWN0b3J5LmNyeXB0b19vYmouZGVjcnlwdChtZXNzYWdlLCB0aGlzLnN1YnNjcmlwdGlvbigpLmRlbGl2ZXJ5TW9kZS5lbmNyeXB0aW9uS2V5LCB7XG4gICAgICAgICAgICAgICAgZW5jcnlwdEtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAga2V5RW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICAgICAgICAgIGtleUxlbmd0aDogMTI4LFxuICAgICAgICAgICAgICAgIG1vZGU6ICdlY2InXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9ub3RpZnkgPSBmdW5jdGlvbiBfbm90aWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLm5vdGlmaWNhdGlvbiwgdGhpcy5fZGVjcnlwdChtZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9zdWJzY3JpYmVBdFB1Ym51YiA9IGZ1bmN0aW9uIF9zdWJzY3JpYmVBdFB1Ym51YigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuYWxpdmUoKSkgdGhyb3cgbmV3IEVycm9yKCdTdWJzY3JpcHRpb24gaXMgbm90IGFsaXZlJyk7XG5cbiAgICAgICAgdmFyIGRlbGl2ZXJ5TW9kZSA9IHRoaXMuc3Vic2NyaXB0aW9uKCkuZGVsaXZlcnlNb2RlO1xuXG4gICAgICAgIGlmICh0aGlzLl9wdWJudWIpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3B1Ym51Ykxhc3RDaGFubmVsID09IGRlbGl2ZXJ5TW9kZS5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byB1cGRhdGUsIGtlZXAgbGlzdGVuaW5nIHRvIHNhbWUgY2hhbm5lbFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9wdWJudWJMYXN0Q2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gc3Vic2NyaWJlIHRvIG5ldyBjaGFubmVsXG4gICAgICAgICAgICAgICAgdGhpcy5fcHVibnViLnVuc3Vic2NyaWJlKHsgY2hhbm5lbDogdGhpcy5fcHVibnViTGFzdENoYW5uZWwgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlLWluaXQgZm9yIG5ldyBkYXRhXG4gICAgICAgICAgICB0aGlzLl9wdWJudWIgPSB0aGlzLl9wdWJudWIuaW5pdCh7XG4gICAgICAgICAgICAgICAgc3NsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZV9rZXk6IGRlbGl2ZXJ5TW9kZS5zdWJzY3JpYmVyS2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gSW5pdCBmcm9tIHNjcmF0Y2hcbiAgICAgICAgICAgIHRoaXMuX3B1Ym51YiA9IHRoaXMuX3B1Ym51YkZhY3RvcnkuaW5pdCh7XG4gICAgICAgICAgICAgICAgc3NsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZV9rZXk6IGRlbGl2ZXJ5TW9kZS5zdWJzY3JpYmVyS2V5XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fcHVibnViLnJlYWR5KCk7IC8vVE9ETyBUaGlzIG1heSBiZSBub3QgbmVlZGVkIGFueW1vcmVcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3B1Ym51Ykxhc3RDaGFubmVsID0gZGVsaXZlcnlNb2RlLmFkZHJlc3M7XG5cbiAgICAgICAgdGhpcy5fcHVibnViLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBjaGFubmVsOiBkZWxpdmVyeU1vZGUuYWRkcmVzcyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuX25vdGlmeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY29ubmVjdDogZnVuY3Rpb24gY29ubmVjdCgpIHt9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuLy9leHBvcnQgaW50ZXJmYWNlIElTdWJzY3JpcHRpb24ge1xuLy8gICAgaWQ/OnN0cmluZztcbi8vICAgIHVyaT86IHN0cmluZztcbi8vICAgIGV2ZW50RmlsdGVycz86c3RyaW5nW107XG4vLyAgICBleHBpcmF0aW9uVGltZT86c3RyaW5nOyAvLyAyMDE0LTAzLTEyVDE5OjU0OjM1LjYxM1pcbi8vICAgIGV4cGlyZXNJbj86bnVtYmVyO1xuLy8gICAgZGVsaXZlcnlNb2RlPzoge1xuLy8gICAgICAgIHRyYW5zcG9ydFR5cGU/OnN0cmluZztcbi8vICAgICAgICBlbmNyeXB0aW9uPzpib29sZWFuO1xuLy8gICAgICAgIGFkZHJlc3M/OnN0cmluZztcbi8vICAgICAgICBzdWJzY3JpYmVyS2V5PzpzdHJpbmc7XG4vLyAgICAgICAgZW5jcnlwdGlvbktleT86c3RyaW5nO1xuLy8gICAgICAgIHNlY3JldEtleT86c3RyaW5nO1xuLy8gICAgfTtcbi8vICAgIGNyZWF0aW9uVGltZT86c3RyaW5nOyAvLyAyMDE0LTAzLTEyVDE5OjU0OjM1LjYxM1pcbi8vICAgIHN0YXR1cz86c3RyaW5nOyAvLyBBY3RpdmVcbi8vfVxuXG5cblN1YnNjcmlwdGlvbi5fcmVuZXdIYW5kaWNhcE1zID0gMiAqIDYwICogMTAwMDtcblN1YnNjcmlwdGlvbi5fcG9sbEludGVydmFsID0gMTAgKiAxMDAwO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3Vic2NyaXB0aW9uO1xuXG4vKioqLyB9LFxuLyogMjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9TdWJzY3JpcHRpb24yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbnZhciBfU3Vic2NyaXB0aW9uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1YnNjcmlwdGlvbjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDYWNoZWRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoX1N1YnNjcmlwdGlvbikge1xuICAgIF9pbmhlcml0cyhDYWNoZWRTdWJzY3JpcHRpb24sIF9TdWJzY3JpcHRpb24pO1xuXG4gICAgZnVuY3Rpb24gQ2FjaGVkU3Vic2NyaXB0aW9uKHB1Ym51YkZhY3RvcnksIHBsYXRmb3JtLCBjYWNoZSwgY2FjaGVLZXkpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhY2hlZFN1YnNjcmlwdGlvbik7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtDYWNoZX0gKi9cblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3Vic2NyaXB0aW9uLmNhbGwodGhpcywgcHVibnViRmFjdG9yeSwgcGxhdGZvcm0pKTtcblxuICAgICAgICBfdGhpcy5fY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgX3RoaXMuX2NhY2hlS2V5ID0gY2FjaGVLZXk7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIENhY2hlZFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gc3Vic2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZ2V0SXRlbSh0aGlzLl9jYWNoZUtleSkgfHwge307XG4gICAgfTtcblxuICAgIENhY2hlZFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3NldFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIF9zZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5zZXRJdGVtKHRoaXMuX2NhY2hlS2V5LCBzdWJzY3JpcHRpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgcHJlLWRlZmluZWQgZXZlbnRGaWx0ZXJzIGluIGNhY2hlIGFuZCBpZiBub3QgLS0gdXNlcyBwcm92aWRlZCBhcyBkZWZhdWx0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50c1xuICAgICAqIEByZXR1cm4ge0NhY2hlZFN1YnNjcmlwdGlvbn1cbiAgICAgKi9cblxuXG4gICAgQ2FjaGVkU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShldmVudHMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuZXZlbnRGaWx0ZXJzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNldEV2ZW50RmlsdGVycyhldmVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBDYWNoZWRTdWJzY3JpcHRpb247XG59KF9TdWJzY3JpcHRpb24zLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYWNoZWRTdWJzY3JpcHRpb247XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpbmdjZW50cmFsLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JpbmdjZW50cmFsL2J1aWxkL3JpbmdjZW50cmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMTIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG59ICgpKVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gY2FjaGVkU2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgcm9vdFBhcmVudCA9IHt9XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gU2FmYXJpIDUtNyBsYWNrcyBzdXBwb3J0IGZvciBjaGFuZ2luZyB0aGUgYE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3JgIHByb3BlcnR5XG4gKiAgICAgb24gb2JqZWN0cy5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIGZ1bmN0aW9uIEJhciAoKSB7fVxuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgYXJyLmNvbnN0cnVjdG9yID0gQmFyXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgYXJyLmNvbnN0cnVjdG9yID09PSBCYXIgJiYgLy8gY29uc3RydWN0b3IgY2FuIGJlIHNldFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAvLyBBdm9pZCBnb2luZyB0aHJvdWdoIGFuIEFyZ3VtZW50c0FkYXB0b3JUcmFtcG9saW5lIGluIHRoZSBjb21tb24gY2FzZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZylcbiAgfVxuXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMsIGFyZylcbiAgfVxuXG4gIC8vIFNsaWdodGx5IGxlc3MgY29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoaXMsIGFyZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiAndXRmOCcpXG4gIH1cblxuICAvLyBVbnVzdWFsLlxuICByZXR1cm4gZnJvbU9iamVjdCh0aGlzLCBhcmcpXG59XG5cbmZ1bmN0aW9uIGZyb21OdW1iZXIgKHRoYXQsIGxlbmd0aCkge1xuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGxlbmd0aCkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgLy8gQXNzdW1wdGlvbjogYnl0ZUxlbmd0aCgpIHJldHVybiB2YWx1ZSBpcyBhbHdheXMgPCBrTWF4TGVuZ3RoLlxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBmcm9tQnVmZmVyKHRoYXQsIG9iamVjdClcblxuICBpZiAoaXNBcnJheShvYmplY3QpKSByZXR1cm4gZnJvbUFycmF5KHRoYXQsIG9iamVjdClcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChvYmplY3QuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tVHlwZWRBcnJheSh0aGF0LCBvYmplY3QpXG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCBvYmplY3QpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9iamVjdC5sZW5ndGgpIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iamVjdClcblxuICByZXR1cm4gZnJvbUpzb25PYmplY3QodGhhdCwgb2JqZWN0KVxufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyICh0aGF0LCBidWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYnVmZmVyLmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGJ1ZmZlci5jb3B5KHRoYXQsIDAsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRHVwbGljYXRlIG9mIGZyb21BcnJheSgpIHRvIGtlZXAgZnJvbUFycmF5KCkgbW9ub21vcnBoaWMuXG5mdW5jdGlvbiBmcm9tVHlwZWRBcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgLy8gVHJ1bmNhdGluZyB0aGUgZWxlbWVudHMgaXMgcHJvYmFibHkgbm90IHdoYXQgcGVvcGxlIGV4cGVjdCBmcm9tIHR5cGVkXG4gIC8vIGFycmF5cyB3aXRoIEJZVEVTX1BFUl9FTEVNRU5UID4gMSBidXQgaXQncyBjb21wYXRpYmxlIHdpdGggdGhlIGJlaGF2aW9yXG4gIC8vIG9mIHRoZSBvbGQgQnVmZmVyIGNvbnN0cnVjdG9yLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBhcnJheS5ieXRlTGVuZ3RoXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShhcnJheSkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tVHlwZWRBcnJheSh0aGF0LCBuZXcgVWludDhBcnJheShhcnJheSkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIERlc2VyaWFsaXplIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsxLDIsMywuLi5dIH0gaW50byBhIEJ1ZmZlciBvYmplY3QuXG4vLyBSZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyIGZvciBpbnB1dHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZSBzcGVjLlxuZnVuY3Rpb24gZnJvbUpzb25PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICB2YXIgYXJyYXlcbiAgdmFyIGxlbmd0aCA9IDBcblxuICBpZiAob2JqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqZWN0LmRhdGEpKSB7XG4gICAgYXJyYXkgPSBvYmplY3QuZGF0YVxuICAgIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgfVxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxufSBlbHNlIHtcbiAgLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbiAgQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbiAgQnVmZmVyLnByb3RvdHlwZS5wYXJlbnQgPSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gYWxsb2NhdGUgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhhdC5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgZnJvbVBvb2wgPSBsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSA+Pj4gMVxuICBpZiAoZnJvbVBvb2wpIHRoYXQucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKSByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIHZhciBpID0gMFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgYnJlYWtcblxuICAgICsraVxuICB9XG5cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHN0cmluZyA9ICcnICsgc3RyaW5nXG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAvLyBEZXByZWNhdGVkXG4gICAgICBjYXNlICdyYXcnOlxuICAgICAgY2FzZSAncmF3cyc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCB8IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID09PSBJbmZpbml0eSA/IHRoaXMubGVuZ3RoIDogZW5kIHwgMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gMFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0KSB7XG4gIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgYnl0ZU9mZnNldCA+Pj0gMFxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG4gIGlmIChieXRlT2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm4gLTFcblxuICAvLyBOZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoICsgYnl0ZU9mZnNldCwgMClcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xIC8vIHNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nIGFsd2F5cyBmYWlsc1xuICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0KSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAodmFyIGkgPSAwOyBieXRlT2Zmc2V0ICsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltieXRlT2Zmc2V0ICsgaV0gPT09IHZhbFtmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleF0pIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWwubGVuZ3RoKSByZXR1cm4gYnl0ZU9mZnNldCArIGZvdW5kSW5kZXhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbi8vIGBnZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmluZGV4T2YgPSBCUC5pbmRleE9mXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcbiAgYXJyLnJlYWRVSW50QkUgPSBCUC5yZWFkVUludEJFXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludExFID0gQlAucmVhZEludExFXG4gIGFyci5yZWFkSW50QkUgPSBCUC5yZWFkSW50QkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50TEUgPSBCUC53cml0ZVVJbnRMRVxuICBhcnIud3JpdGVVSW50QkUgPSBCUC53cml0ZVVJbnRCRVxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50TEUgPSBCUC53cml0ZUludExFXG4gIGFyci53cml0ZUludEJFID0gQlAud3JpdGVJbnRCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYnVmZmVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Jhc2U2NC1qcy9saWIvYjY0LmpzXG4gKiogbW9kdWxlIGlkID0gMTIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2llZWU3NTQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaXNhcnJheS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pha2VhcmNoaWJhbGQvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgMy4yLjFcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc01heWJlVGhlbmFibGUoeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheSkge1xuICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5ID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9IDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQ7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbjtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2xpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW5dID0gY2FsbGJhY2s7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArIDFdID0gYXJnO1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArPSAyO1xuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPT09IDIpIHtcbiAgICAgICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgICAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4obGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwKGFzYXBGbikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBhc2FwRm47XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyB8fCB7fTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbiAgICAvLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyBub2RlXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCkge1xuICAgICAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB2ZXJ0eFxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcihsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB3ZWIgd29ya2VyXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2goKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW47IGkrPTIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldO1xuICAgICAgICB2YXIgYXJnID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2krMV07XG5cbiAgICAgICAgY2FsbGJhY2soYXJnKTtcblxuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXR0ZW1wdFZlcnR4KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHIgPSByZXF1aXJlO1xuICAgICAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoO1xuICAgIC8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG4gICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc05vZGUpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc1dvcmtlcikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0eCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR0aGVuJCR0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcztcblxuICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmIChjaGlsZFtsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tzdGF0ZSAtIDFdO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbigpe1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHN0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdGhlbiQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSR0aGVuJCR0aGVuO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJHJlc29sdmUob2JqZWN0KSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygxNik7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKCkge31cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICAgPSB2b2lkIDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCA9IDE7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEICA9IDI7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IgPSBuZXcgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4ocHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3IgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgICAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgICAgIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuKSB7XG4gICAgICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgIHRoZW4gPT09IGxpYiRlczYkcHJvbWlzZSR0aGVuJCRkZWZhdWx0ICYmXG4gICAgICAgICAgY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGVuID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc2VsZkZ1bGZpbGxtZW50KCkpO1xuICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4odmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICAgICAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICAgICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cblxuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRDtcblxuICAgICAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEXSAgPSBvblJlamVjdGlvbjtcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gsIHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgICAgIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCkge1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICB2YXIgaGFzQ2FsbGJhY2sgPSBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgICAgIHZhbHVlLCBlcnJvciwgc3VjY2VlZGVkLCBmYWlsZWQ7XG5cbiAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICB2YWx1ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAvLyBub29wXG4gICAgICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpe1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGlkID0gMDtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRuZXh0SWQoKSB7XG4gICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaWQrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gICAgICBwcm9taXNlW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaWQrKztcbiAgICAgIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbChlbnRyaWVzKSB7XG4gICAgICByZXR1cm4gbmV3IGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0KHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbDtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRyYWNlKGVudHJpZXMpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICBpZiAoIWxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJHJlamVjdChyZWFzb24pIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRyZWplY3Q7XG5cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2U7XG4gICAgLyoqXG4gICAgICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gICAgICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICAgICAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gICAgICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgVGVybWlub2xvZ3lcbiAgICAgIC0tLS0tLS0tLS0tXG5cbiAgICAgIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gICAgICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gICAgICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgICAgIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgICAgIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gICAgICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gICAgICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gICAgICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICAgICAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gICAgICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gICAgICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgICAgIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgICAgIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgICAgIEJhc2ljIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIGBgYGpzXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBvbiBzdWNjZXNzXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgICAgIC8vIG9uIGZhaWx1cmVcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gICAgICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgICAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICAgICAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgICAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQGNsYXNzIFByb21pc2VcbiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgICB0aGlzW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbmV4dElkKCk7XG4gICAgICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wICE9PSByZXNvbHZlcikge1xuICAgICAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgICAgdGhpcyBpbnN0YW5jZW9mIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlID8gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuYWxsID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJhY2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlc29sdmUgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlamVjdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcjtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0QXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwO1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9hc2FwID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXA7XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UsXG5cbiAgICAvKipcbiAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBDaGFpbmluZ1xuICAgICAgLS0tLS0tLS1cblxuICAgICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgICB9KTtcblxuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgICAgfSk7XG4gICAgICBgYGBcbiAgICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFzc2ltaWxhdGlvblxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBTaW1wbGUgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcblxuICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG5cbiAgICAgIH1cblxuICAgICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kQXV0aG9yKCkuXG4gICAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgdGhlblxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgIHRoZW46IGxpYiRlczYkcHJvbWlzZSR0aGVuJCRkZWZhdWx0LFxuXG4gICAgLyoqXG4gICAgICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gICAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3luY2hyb25vdXNcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmRBdXRob3IoKTtcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9XG5cbiAgICAgIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCBjYXRjaFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3I7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmICghdGhpcy5wcm9taXNlW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0ICAgICA9IGlucHV0O1xuICAgICAgICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgICB0aGlzLl9lbnVtZXJhdGUoKTtcbiAgICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdCh0aGlzLnByb21pc2UsIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCR2YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoICA9IHRoaXMubGVuZ3RoO1xuICAgICAgdmFyIGlucHV0ICAgPSB0aGlzLl9pbnB1dDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5LCBpKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgICB2YXIgcmVzb2x2ZSA9IGMucmVzb2x2ZTtcblxuICAgICAgaWYgKHJlc29sdmUgPT09IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQpIHtcbiAgICAgICAgdmFyIHRoZW4gPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKGVudHJ5KTtcblxuICAgICAgICBpZiAodGhlbiA9PT0gbGliJGVzNiRwcm9taXNlJHRoZW4kJGRlZmF1bHQgJiZcbiAgICAgICAgICAgIGVudHJ5Ll9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQpIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIHRoZW4pO1xuICAgICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24ocmVzb2x2ZSkgeyByZXNvbHZlKGVudHJ5KTsgfSksIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZShlbnRyeSksIGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbihwcm9taXNlLCBpKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkcG9seWZpbGwoKSB7XG4gICAgICB2YXIgbG9jYWw7XG5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxvY2FsID0gZ2xvYmFsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgICAgIGlmIChQICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSkgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9jYWwuUHJvbWlzZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0O1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRwb2x5ZmlsbDtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlID0ge1xuICAgICAgJ1Byb21pc2UnOiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCxcbiAgICAgICdwb2x5ZmlsbCc6IGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdFxuICAgIH07XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lOnRydWUgbW9kdWxlOnRydWUgd2luZG93OiB0cnVlICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTsgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGVbJ2V4cG9ydHMnXSkge1xuICAgICAgbW9kdWxlWydleHBvcnRzJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzWydFUzZQcm9taXNlJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCgpO1xufSkuY2FsbCh0aGlzKTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogKGlnbm9yZWQpICovXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiB2ZXJ0eCAoaWdub3JlZClcbiAqKiBtb2R1bGUgaWQgPSAxMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcImRlZmluZSBjYW5ub3QgYmUgdXNlZCBpbmRpcmVjdFwiKTsgfTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9hbWQtZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge31cblxuICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgfSwgdGhpcylcblxuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgICB9LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICAgIHZhciBsaXN0ID0gdGhpcy5tYXBbbmFtZV1cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgIGxpc3QgPSBbXVxuICAgICAgdGhpcy5tYXBbbmFtZV0gPSBsaXN0XG4gICAgfVxuICAgIGxpc3QucHVzaCh2YWx1ZSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgICByZXR1cm4gdmFsdWVzID8gdmFsdWVzWzBdIDogbnVsbFxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSB8fCBbXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IFtub3JtYWxpemVWYWx1ZSh2YWx1ZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLm1hcCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLm1hcFtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpXG4gICAgICB9LCB0aGlzKVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgICByZXR1cm4gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpXG4gICAgcmV0dXJuIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAvLyBPbmx5IHN1cHBvcnQgQXJyYXlCdWZmZXJzIGZvciBQT1NUIG1ldGhvZC5cbiAgICAgICAgLy8gUmVjZWl2aW5nIEFycmF5QnVmZmVycyBoYXBwZW5zIHZpYSBCbG9icywgaW5zdGVhZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZCA6IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ11cblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIHJldHVybiAobWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEpID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcbiAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBpbnB1dFxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBoZWFkZXJzKHhocikge1xuICAgIHZhciBoZWFkID0gbmV3IEhlYWRlcnMoKVxuICAgIHZhciBwYWlycyA9ICh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpLnRyaW0oKS5zcGxpdCgnXFxuJylcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgdmFyIHNwbGl0ID0gaGVhZGVyLnRyaW0oKS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gc3BsaXQuc2hpZnQoKS50cmltKClcbiAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJzonKS50cmltKClcbiAgICAgIGhlYWQuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICByZXR1cm4gaGVhZFxuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dFxuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgPyBvcHRpb25zLmhlYWRlcnMgOiBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVyc1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZVxuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0XG4gICAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgJiYgIWluaXQpIHtcbiAgICAgICAgcmVxdWVzdCA9IGlucHV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICBmdW5jdGlvbiByZXNwb25zZVVSTCgpIHtcbiAgICAgICAgaWYgKCdyZXNwb25zZVVSTCcgaW4geGhyKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVVSTFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgc2VjdXJpdHkgd2FybmluZ3Mgb24gZ2V0UmVzcG9uc2VIZWFkZXIgd2hlbiBub3QgYWxsb3dlZCBieSBDT1JTXG4gICAgICAgIGlmICgvXlgtUmVxdWVzdC1VUkw6L20udGVzdCh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMpID8gMjA0IDogeGhyLnN0YXR1c1xuICAgICAgICBpZiAoc3RhdHVzIDwgMTAwIHx8IHN0YXR1cyA+IDU5OSkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVycyh4aHIpLFxuICAgICAgICAgIHVybDogcmVzcG9uc2VVUkwoKVxuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfVxuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgICB9KVxuICB9XG4gIHNlbGYuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yaW5nY2VudHJhbC9+L3doYXR3Zy1mZXRjaC9mZXRjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohIDMuMTUuMiAvIG1vZGVybiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUFVCTlVCXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlBVQk5VQlwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBnbG9iYWxzICdNb2Rlcm4nICovXG5cdC8qIGVzbGludCBjdXJseTogMCwgY2FtZWxjYXNlOiAwLCBkb3Qtbm90YXRpb246IDAgKi9cblxuXHR2YXIgcGFja2FnZUpTT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHR2YXIgcHViTnViQ29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBjcnlwdG9fb2JqID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIENyeXB0b0pTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIFdTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuXHQvKipcblx0ICogVVRJTCBMT0NBTFNcblx0ICovXG5cdHZhciBQTlNESyA9ICdQdWJOdWItSlMtJyArICdNb2Rlcm4nICsgJy8nICsgcGFja2FnZUpTT04udmVyc2lvbjtcblxuXHQvKipcblx0ICogTE9DQUwgU1RPUkFHRVxuXHQgKi9cblx0dmFyIGRiID0gKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgbHMgPSB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhbFN0b3JhZ2U7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGlmIChscykgcmV0dXJuIGxzLmdldEl0ZW0oa2V5KTtcblx0ICAgICAgICBpZiAoZG9jdW1lbnQuY29va2llLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHJldHVybiBudWxsO1xuXHQgICAgICAgIHJldHVybiAoKGRvY3VtZW50LmNvb2tpZSB8fCAnJykubWF0Y2goXG5cdCAgICAgICAgICAgIFJlZ0V4cChrZXkgKyAnPShbXjtdKyknKVxuXHQgICAgICAgICAgKSB8fCBbXSlbMV0gfHwgbnVsbDtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBpZiAobHMpIHJldHVybiBscy5zZXRJdGVtKGtleSwgdmFsdWUpICYmIDA7XG5cdCAgICAgICAgZG9jdW1lbnQuY29va2llID0ga2V5ICsgJz0nICsgdmFsdWUgK1xuXHQgICAgICAgICAgJzsgZXhwaXJlcz1UaHUsIDEgQXVnIDIwMzAgMjA6MDA6MDAgVVRDOyBwYXRoPS8nO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0fSkoKTtcblxuXG5cdC8qKlxuXHQgKiBDT1JTIFhIUiBSZXF1ZXN0XG5cdCAqID09PT09PT09PT09PT09PT1cblx0ICogIHhkcih7XG5cdCAqICAgICB1cmwgICAgIDogWydodHRwOi8vd3d3LmJsYWguY29tL3VybCddLFxuXHQgKiAgICAgc3VjY2VzcyA6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7fSxcblx0ICogICAgIGZhaWwgICAgOiBmdW5jdGlvbigpIHt9XG5cdCAqICB9KTtcblx0ICovXG5cdGZ1bmN0aW9uIHhkcihzZXR1cCkge1xuXHQgIHZhciB4aHI7XG5cdCAgdmFyIHRpbWVyO1xuXHQgIHZhciBjb21wbGV0ZSA9IDA7XG5cdCAgdmFyIGxvYWRlZCA9IDA7XG5cdCAgdmFyIGFzeW5jID0gdHJ1ZTsgLyogZG8gbm90IGFsbG93IHN5bmMgb3BlcmF0aW9ucyBpbiBtb2Rlcm4gYnVpbGRzICovXG5cdCAgdmFyIHhocnRtZSA9IHNldHVwLnRpbWVvdXQgfHwgcHViTnViQ29yZS5ERUZfVElNRU9VVDtcblx0ICB2YXIgZGF0YSA9IHNldHVwLmRhdGEgfHwge307XG5cdCAgdmFyIGZhaWwgPSBzZXR1cC5mYWlsIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgIHZhciBzdWNjZXNzID0gc2V0dXAuc3VjY2VzcyB8fCBmdW5jdGlvbiAoKSB7fTtcblxuXHQgIHZhciBkb25lID0gZnVuY3Rpb24gKGZhaWxlZCwgcmVzcG9uc2UpIHtcblx0ICAgIGlmIChjb21wbGV0ZSkgcmV0dXJuO1xuXHQgICAgY29tcGxldGUgPSAxO1xuXG5cdCAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG5cdCAgICBpZiAoeGhyKSB7XG5cdCAgICAgIHhoci5vbmVycm9yID0geGhyLm9ubG9hZCA9IG51bGw7XG5cdCAgICAgIGlmICh4aHIuYWJvcnQpIHhoci5hYm9ydCgpO1xuXHQgICAgICB4aHIgPSBudWxsO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZmFpbGVkKSBmYWlsKHJlc3BvbnNlKTtcblx0ICB9O1xuXG5cdCAgdmFyIGZpbmlzaGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGxvYWRlZCkgcmV0dXJuO1xuXHQgICAgdmFyIHJlc3BvbnNlO1xuXHQgICAgbG9hZGVkID0gMTtcblxuXHQgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuXHQgICAgdHJ5IHtcblx0ICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuXHQgICAgfSBjYXRjaCAocikge1xuXHQgICAgICByZXR1cm4gZG9uZSgxKTtcblx0ICAgIH1cblxuXHQgICAgc3VjY2VzcyhyZXNwb25zZSk7XG5cdCAgfTtcblxuXHQgIHRpbWVyID0gcHViTnViQ29yZS50aW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgIGRvbmUoMSk7XG5cdCAgfSwgeGhydG1lKTtcblxuXHQgIC8vIFNlbmRcblx0ICB0cnkge1xuXHQgICAgeGhyID0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgICBuZXcgWERvbWFpblJlcXVlc3QoKSB8fFxuXHQgICAgICBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHQgICAgeGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgZG9uZSgxLCB4aHIucmVzcG9uc2VUZXh0IHx8IHsgZXJyb3I6ICdOZXR3b3JrIENvbm5lY3Rpb24gRXJyb3InIH0pO1xuXHQgICAgfTtcblx0ICAgIHhoci5vbmxvYWQgPSB4aHIub25sb2FkZW5kID0gZmluaXNoZWQ7XG5cblx0ICAgIGRhdGEucG5zZGsgPSBQTlNESztcblx0ICAgIHZhciB1cmwgPSBwdWJOdWJDb3JlLmJ1aWxkX3VybChzZXR1cC51cmwsIGRhdGEpO1xuXHQgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgYXN5bmMpO1xuXHQgICAgaWYgKGFzeW5jKSB4aHIudGltZW91dCA9IHhocnRtZTtcblx0ICAgIHhoci5zZW5kKCk7XG5cdCAgfSBjYXRjaCAoZWVlKSB7XG5cdCAgICBkb25lKDEsIHsgZXJyb3I6ICdYSFIgRmFpbGVkJywgc3RhY2t0cmFjZTogZWVlIH0pO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiAnZG9uZSdcblx0ICByZXR1cm4gZG9uZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCSU5EXG5cdCAqID09PT1cblx0ICogYmluZCggJ2tleWRvd24nLCBzZWFyY2goJ2EnKVswXSwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHQgKiAgICAgLi4uXG5cdCAqIH0gKTtcblx0ICovXG5cdGZ1bmN0aW9uIGJpbmQodHlwZSwgZWwsIGZ1bikge1xuXHQgIHB1Yk51YkNvcmUuZWFjaCh0eXBlLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChldHlwZSkge1xuXHQgICAgdmFyIHJhcGZ1biA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGlmICghZSkgZSA9IHdpbmRvdy5ldmVudDtcblx0ICAgICAgaWYgKCFmdW4oZSkpIHtcblx0ICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cdCAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHQgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikgZWwuYWRkRXZlbnRMaXN0ZW5lcihldHlwZSwgcmFwZnVuLCBmYWxzZSk7XG5cdCAgICBlbHNlIGlmIChlbC5hdHRhY2hFdmVudCkgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV0eXBlLCByYXBmdW4pO1xuXHQgICAgZWxzZSBlbFsnb24nICsgZXR5cGVdID0gcmFwZnVuO1xuXHQgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVSUk9SXG5cdCAqID09PVxuXHQgKiBlcnJvcignbWVzc2FnZScpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuXHQgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXHR9XG5cblx0LyoqXG5cdCAqIEVWRU5UU1xuXHQgKiA9PT09PT1cblx0ICogUFVCTlVCLmV2ZW50cy5iaW5kKCAneW91LXN0ZXBwZWQtb24tZmxvd2VyJywgZnVuY3Rpb24obWVzc2FnZSkge1xuXHQgKiAgICAgLy8gRG8gU3R1ZmYgd2l0aCBtZXNzYWdlXG5cdCAqIH0gKTtcblx0ICpcblx0ICogUFVCTlVCLmV2ZW50cy5maXJlKCAneW91LXN0ZXBwZWQtb24tZmxvd2VyJywgXCJtZXNzYWdlLWRhdGFcIiApO1xuXHQgKiBQVUJOVUIuZXZlbnRzLmZpcmUoICd5b3Utc3RlcHBlZC1vbi1mbG93ZXInLCB7bWVzc2FnZTpcImRhdGFcIn0gKTtcblx0ICogUFVCTlVCLmV2ZW50cy5maXJlKCAneW91LXN0ZXBwZWQtb24tZmxvd2VyJywgWzEsMiwzXSApO1xuXHQgKlxuXHQgKi9cblx0dmFyIGV2ZW50cyA9IHtcblx0ICBsaXN0OiB7fSxcblx0ICB1bmJpbmQ6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICBldmVudHMubGlzdFtuYW1lXSA9IFtdO1xuXHQgIH0sXG5cdCAgYmluZDogZnVuY3Rpb24gKG5hbWUsIGZ1bikge1xuXHQgICAgKGV2ZW50cy5saXN0W25hbWVdID0gZXZlbnRzLmxpc3RbbmFtZV0gfHwgW10pLnB1c2goZnVuKTtcblx0ICB9LFxuXHQgIGZpcmU6IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG5cdCAgICBwdWJOdWJDb3JlLmVhY2goXG5cdCAgICAgIGV2ZW50cy5saXN0W25hbWVdIHx8IFtdLFxuXHQgICAgICBmdW5jdGlvbiAoZnVuKSB7XG5cdCAgICAgICAgZnVuKGRhdGEpO1xuXHQgICAgICB9XG5cdCAgICApO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQVRUUlxuXHQgKiA9PT09XG5cdCAqIHZhciBhdHRyaWJ1dGUgPSBhdHRyKCBub2RlLCAnYXR0cmlidXRlJyApO1xuXHQgKi9cblx0ZnVuY3Rpb24gYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdCAgaWYgKHZhbHVlKSBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcblx0ICBlbHNlIHJldHVybiBub2RlICYmIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogJFxuXHQgKiA9XG5cdCAqIHZhciBkaXYgPSAkKCdkaXZpZCcpO1xuXHQgKi9cblx0ZnVuY3Rpb24gJChpZCkge1xuXHQgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBTRUFSQ0hcblx0ICogPT09PT09XG5cdCAqIHZhciBlbGVtZW50cyA9IHNlYXJjaCgnYSBkaXYgc3BhbicpO1xuXHQgKi9cblx0ZnVuY3Rpb24gc2VhcmNoKGVsZW1lbnRzLCBzdGFydCkge1xuXHQgIHZhciBsaXN0ID0gW107XG5cdCAgcHViTnViQ29yZS5lYWNoKGVsZW1lbnRzLnNwbGl0KC9cXHMrLyksIGZ1bmN0aW9uIChlbCkge1xuXHQgICAgcHViTnViQ29yZS5lYWNoKChzdGFydCB8fCBkb2N1bWVudCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZWwpLCBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICBsaXN0LnB1c2gobm9kZSk7XG5cdCAgICB9KTtcblx0ICB9KTtcblx0ICByZXR1cm4gbGlzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDU1Ncblx0ICogPT09XG5cdCAqIHZhciBvYmogPSBjcmVhdGUoJ2RpdicpO1xuXHQgKi9cblx0ZnVuY3Rpb24gY3NzKGVsZW1lbnQsIHN0eWxlcykge1xuXHQgIGZvciAodmFyIHN0eWxlIGluIHN0eWxlcykgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpXG5cdCAgICB0cnkge1xuXHQgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlXSA9IHN0eWxlc1tzdHlsZV0gKyAoXG5cdCAgICAgICAgICAnfHdpZHRofGhlaWdodHx0b3B8bGVmdHwnLmluZGV4T2Yoc3R5bGUpID4gMCAmJlxuXHQgICAgICAgICAgdHlwZW9mIHN0eWxlc1tzdHlsZV0gPT09ICdudW1iZXInXG5cdCAgICAgICAgICAgID8gJ3B4JyA6ICcnXG5cdCAgICAgICAgKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIENSRUFURVxuXHQgKiA9PT09PT1cblx0ICogdmFyIG9iaiA9IGNyZWF0ZSgnZGl2Jyk7XG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGUoZWxlbWVudCkge1xuXHQgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnQpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBnZXRfaG1hY19TSEEyNTYoZGF0YSwga2V5KSB7XG5cdCAgdmFyIGhhc2ggPSBDcnlwdG9KU1snSG1hY1NIQTI1NiddKGRhdGEsIGtleSk7XG5cdCAgcmV0dXJuIGhhc2gudG9TdHJpbmcoQ3J5cHRvSlNbJ2VuYyddWydCYXNlNjQnXSk7XG5cdH1cblxuXHQvKiA9LT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09LT0gKi9cblx0LyogPS09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS09ICovXG5cdC8qID0tPT09PT09PT09PT09PT09PT09PT09PT09PSAgICAgUFVCTlVCICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT0tPSAqL1xuXHQvKiA9LT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09LT0gKi9cblx0LyogPS09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS09ICovXG5cblx0ZnVuY3Rpb24gQ1JFQVRFX1BVQk5VQihzZXR1cCkge1xuXHQgIHNldHVwLmRiID0gZGI7XG5cdCAgc2V0dXAueGRyID0geGRyO1xuXHQgIHNldHVwLmVycm9yID0gc2V0dXAuZXJyb3IgfHwgZXJyb3I7XG5cdCAgc2V0dXAuaG1hY19TSEEyNTYgPSBnZXRfaG1hY19TSEEyNTY7XG5cdCAgc2V0dXAuY3J5cHRvX29iaiA9IGNyeXB0b19vYmooKTtcblx0ICBzZXR1cC5XUyA9IFdTO1xuXHQgIHNldHVwLnBhcmFtcyA9IHsgcG5zZGs6IFBOU0RLIH07XG5cblx0ICB2YXIgU0VMRiA9IGZ1bmN0aW9uIChzZXR1cCkge1xuXHQgICAgcmV0dXJuIENSRUFURV9QVUJOVUIoc2V0dXApO1xuXHQgIH07XG5cblx0ICB2YXIgUE4gPSBwdWJOdWJDb3JlLlBOX0FQSShzZXR1cCk7XG5cdCAgZm9yICh2YXIgcHJvcCBpbiBQTikge1xuXHQgICAgaWYgKFBOLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdCAgICAgIFNFTEZbcHJvcF0gPSBQTltwcm9wXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBTRUxGLmluaXQgPSBTRUxGO1xuXHQgIFNFTEYuJCA9ICQ7XG5cdCAgU0VMRi5hdHRyID0gYXR0cjtcblx0ICBTRUxGLnNlYXJjaCA9IHNlYXJjaDtcblx0ICBTRUxGLmJpbmQgPSBiaW5kO1xuXHQgIFNFTEYuY3NzID0gY3NzO1xuXHQgIFNFTEYuY3JlYXRlID0gY3JlYXRlO1xuXHQgIFNFTEYuY3J5cHRvX29iaiA9IGNyeXB0b19vYmooKTtcblx0ICBTRUxGLldTID0gV1M7XG5cdCAgU0VMRi5QTm1lc3NhZ2UgPSBwdWJOdWJDb3JlLlBObWVzc2FnZTtcblx0ICBTRUxGLnN1cHBsYW50ID0gcHViTnViQ29yZS5zdXBwbGFudDtcblxuXHQgIGlmICh0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIGJpbmQoJ2JlZm9yZXVubG9hZCcsIHdpbmRvdywgZnVuY3Rpb24gKCkge1xuXHQgICAgICBTRUxGWydlYWNoLWNoYW5uZWwnXShmdW5jdGlvbiAoY2gpIHtcblx0ICAgICAgICBTRUxGWydMRUFWRSddKGNoLm5hbWUsIDEpO1xuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBTRUxGLnJlYWR5KCk7XG5cblx0ICAvLyBSZXR1cm4gd2l0aG91dCBUZXN0aW5nXG5cdCAgaWYgKHNldHVwLm5vdGVzdCkgcmV0dXJuIFNFTEY7XG5cblx0ICBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICBiaW5kKCdvZmZsaW5lJywgd2luZG93LCBTRUxGWydvZmZsaW5lJ10pO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgYmluZCgnb2ZmbGluZScsIGRvY3VtZW50LCBTRUxGWydvZmZsaW5lJ10pO1xuXHQgIH1cblxuXHQgIHJldHVybiBTRUxGO1xuXHR9XG5cblx0Q1JFQVRFX1BVQk5VQi5pbml0ID0gQ1JFQVRFX1BVQk5VQjtcblx0Q1JFQVRFX1BVQk5VQi5zZWN1cmUgPSBDUkVBVEVfUFVCTlVCO1xuXHRDUkVBVEVfUFVCTlVCLmNyeXB0b19vYmogPSBjcnlwdG9fb2JqKCk7XG5cdENSRUFURV9QVUJOVUIuV1MgPSBXUztcblx0Q1JFQVRFX1BVQk5VQi5kYiA9IGRiO1xuXHRDUkVBVEVfUFVCTlVCLlBObWVzc2FnZSA9IHB1Yk51YkNvcmUuUE5tZXNzYWdlO1xuXHRDUkVBVEVfUFVCTlVCLnV1aWQgPSBwdWJOdWJDb3JlLnV1aWQ7XG5cblx0Q1JFQVRFX1BVQk5VQi5jc3MgPSBjc3M7XG5cdENSRUFURV9QVUJOVUIuJCA9ICQ7XG5cdENSRUFURV9QVUJOVUIuY3JlYXRlID0gJDtcblx0Q1JFQVRFX1BVQk5VQi5iaW5kID0gYmluZDtcblx0Q1JFQVRFX1BVQk5VQi5zZWFyY2ggPSBzZWFyY2g7XG5cdENSRUFURV9QVUJOVUIuYXR0ciA9IGF0dHI7XG5cdENSRUFURV9QVUJOVUIuZXZlbnRzID0gZXZlbnRzO1xuXG5cdENSRUFURV9QVUJOVUIubWFwID0gcHViTnViQ29yZS5tYXA7XG5cdENSRUFURV9QVUJOVUIuZWFjaCA9IHB1Yk51YkNvcmUuZWFjaDtcblx0Q1JFQVRFX1BVQk5VQi5ncmVwID0gcHViTnViQ29yZS5ncmVwO1xuXHRDUkVBVEVfUFVCTlVCLnN1cHBsYW50ID0gcHViTnViQ29yZS5zdXBwbGFudDtcblx0Q1JFQVRFX1BVQk5VQi5ub3cgPSBwdWJOdWJDb3JlLm5vdztcblx0Q1JFQVRFX1BVQk5VQi51bmlxdWUgPSBwdWJOdWJDb3JlLnVuaXF1ZTtcblx0Q1JFQVRFX1BVQk5VQi51cGRhdGVyID0gcHViTnViQ29yZS51cGRhdGVyO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQ1JFQVRFX1BVQk5VQjtcblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdFx0XCJuYW1lXCI6IFwicHVibnViXCIsXG5cdFx0XCJwcmVmZXJHbG9iYWxcIjogZmFsc2UsXG5cdFx0XCJ2ZXJzaW9uXCI6IFwiMy4xNS4yXCIsXG5cdFx0XCJhdXRob3JcIjogXCJQdWJOdWIgPHN1cHBvcnRAcHVibnViLmNvbT5cIixcblx0XHRcImRlc2NyaXB0aW9uXCI6IFwiUHVibGlzaCAmIFN1YnNjcmliZSBSZWFsLXRpbWUgTWVzc2FnaW5nIHdpdGggUHViTnViXCIsXG5cdFx0XCJjb250cmlidXRvcnNcIjogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIm5hbWVcIjogXCJTdGVwaGVuIEJsdW1cIixcblx0XHRcdFx0XCJlbWFpbFwiOiBcInN0ZXBoZW5AcHVibnViLmNvbVwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcImJpblwiOiB7fSxcblx0XHRcInNjcmlwdHNcIjoge1xuXHRcdFx0XCJ0ZXN0XCI6IFwiZ3J1bnQgdGVzdCAtLWZvcmNlXCJcblx0XHR9LFxuXHRcdFwibWFpblwiOiBcIi4vbm9kZS5qcy9wdWJudWIuanNcIixcblx0XHRcImJyb3dzZXJcIjogXCIuL21vZGVybi9kaXN0L3B1Ym51Yi5qc1wiLFxuXHRcdFwicmVwb3NpdG9yeVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcdFwidXJsXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9wdWJudWIvamF2YXNjcmlwdC5naXRcIlxuXHRcdH0sXG5cdFx0XCJrZXl3b3Jkc1wiOiBbXG5cdFx0XHRcImNsb3VkXCIsXG5cdFx0XHRcInB1Ymxpc2hcIixcblx0XHRcdFwic3Vic2NyaWJlXCIsXG5cdFx0XHRcIndlYnNvY2tldHNcIixcblx0XHRcdFwiY29tZXRcIixcblx0XHRcdFwiYm9zaFwiLFxuXHRcdFx0XCJ4bXBwXCIsXG5cdFx0XHRcInJlYWwtdGltZVwiLFxuXHRcdFx0XCJtZXNzYWdpbmdcIlxuXHRcdF0sXG5cdFx0XCJkZXBlbmRlbmNpZXNcIjoge1xuXHRcdFx0XCJhZ2VudGtlZXBhbGl2ZVwiOiBcIn4wLjJcIixcblx0XHRcdFwibG9kYXNoXCI6IFwiXjQuMS4wXCJcblx0XHR9LFxuXHRcdFwibm9BbmFseXplXCI6IGZhbHNlLFxuXHRcdFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcdFwiY2hhaVwiOiBcIl4zLjUuMFwiLFxuXHRcdFx0XCJlc2xpbnRcIjogXCIyLjQuMFwiLFxuXHRcdFx0XCJlc2xpbnQtY29uZmlnLWFpcmJuYlwiOiBcIl42LjAuMlwiLFxuXHRcdFx0XCJlc2xpbnQtcGx1Z2luLWZsb3d0eXBlXCI6IFwiXjIuMS4wXCIsXG5cdFx0XHRcImVzbGludC1wbHVnaW4tbW9jaGFcIjogXCJeMi4wLjBcIixcblx0XHRcdFwiZXNsaW50LXBsdWdpbi1yZWFjdFwiOiBcIl40LjEuMFwiLFxuXHRcdFx0XCJmbG93LWJpblwiOiBcIl4wLjIyLjBcIixcblx0XHRcdFwiZ3J1bnRcIjogXCJeMC40LjVcIixcblx0XHRcdFwiZ3J1bnQtY29udHJpYi1jbGVhblwiOiBcIl4xLjAuMFwiLFxuXHRcdFx0XCJncnVudC1jb250cmliLWNvcHlcIjogXCJeMC44LjJcIixcblx0XHRcdFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJeMC4xMS4xXCIsXG5cdFx0XHRcImdydW50LWVudlwiOiBcIl4wLjQuNFwiLFxuXHRcdFx0XCJncnVudC1lc2xpbnRcIjogXCJeMTguMC4wXCIsXG5cdFx0XHRcImdydW50LWZsb3dcIjogXCJeMS4wLjNcIixcblx0XHRcdFwiZ3J1bnQta2FybWFcIjogXCJeMC4xMi4xXCIsXG5cdFx0XHRcImdydW50LW1vY2hhLWlzdGFuYnVsXCI6IFwiXjMuMC4xXCIsXG5cdFx0XHRcImdydW50LXRleHQtcmVwbGFjZVwiOiBcIl4wLjQuMFwiLFxuXHRcdFx0XCJncnVudC13ZWJwYWNrXCI6IFwiXjEuMC4xMVwiLFxuXHRcdFx0XCJpbXBvcnRzLWxvYWRlclwiOiBcIl4wLjYuNVwiLFxuXHRcdFx0XCJpc3BhcnRhXCI6IFwiXjQuMC4wXCIsXG5cdFx0XHRcImpzb24tbG9hZGVyXCI6IFwiXjAuNS40XCIsXG5cdFx0XHRcImthcm1hXCI6IFwiXjAuMTMuMjFcIixcblx0XHRcdFwia2FybWEtY2hhaVwiOiBcIl4wLjEuMFwiLFxuXHRcdFx0XCJrYXJtYS1tb2NoYVwiOiBcIl4wLjIuMVwiLFxuXHRcdFx0XCJrYXJtYS1waGFudG9tanMtbGF1bmNoZXJcIjogXCJeMS4wLjBcIixcblx0XHRcdFwia2FybWEtc3BlYy1yZXBvcnRlclwiOiBcIjAuMC4yNFwiLFxuXHRcdFx0XCJsb2FkLWdydW50LXRhc2tzXCI6IFwiXjMuNC4wXCIsXG5cdFx0XHRcIm1vY2hhXCI6IFwiXjIuNC41XCIsXG5cdFx0XHRcIm5vY2tcIjogXCJeMS4xLjBcIixcblx0XHRcdFwibm9kZS11dWlkXCI6IFwiXjEuNC43XCIsXG5cdFx0XHRcIm5vZGV1bml0XCI6IFwiXjAuOS4wXCIsXG5cdFx0XHRcInBoYW50b21qcy1wcmVidWlsdFwiOiBcIl4yLjEuNFwiLFxuXHRcdFx0XCJwcm94eXF1aXJlXCI6IFwiXjEuNy40XCIsXG5cdFx0XHRcInNpbm9uXCI6IFwiXjEuMTcuMlwiLFxuXHRcdFx0XCJ1Z2xpZnktanNcIjogXCJeMi42LjFcIixcblx0XHRcdFwidW5kZXJzY29yZVwiOiBcIl4xLjcuMFwiLFxuXHRcdFx0XCJ3ZWJwYWNrXCI6IFwiXjEuMTIuMTNcIixcblx0XHRcdFwid2VicGFjay1kZXYtc2VydmVyXCI6IFwiXjEuMTQuMVwiXG5cdFx0fSxcblx0XHRcImJ1bmRsZURlcGVuZGVuY2llc1wiOiBbXSxcblx0XHRcImxpY2Vuc2VcIjogXCJNSVRcIixcblx0XHRcImVuZ2luZVwiOiB7XG5cdFx0XHRcIm5vZGVcIjogXCI+PTAuOFwiXG5cdFx0fSxcblx0XHRcImZpbGVzXCI6IFtcblx0XHRcdFwiY29yZVwiLFxuXHRcdFx0XCJub2RlLmpzXCIsXG5cdFx0XHRcIm1vZGVyblwiLFxuXHRcdFx0XCJDSEFOR0VMT0dcIixcblx0XHRcdFwiRlVUVVJFLm1kXCIsXG5cdFx0XHRcIkxJQ0VOU0VcIixcblx0XHRcdFwiUkVBRE1FLm1kXCJcblx0XHRdXG5cdH07XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBlc2xpbnQgY2FtZWxjYXNlOiAwLCBuby11c2UtYmVmb3JlLWRlZmluZTogMCwgbm8tdW51c2VkLWV4cHJlc3Npb25zOiAwICAqL1xuXHQvKiBlc2xpbnQgZXFlcWVxOiAwLCBvbmUtdmFyOiAwICovXG5cdC8qIGVzbGludCBuby1yZWRlY2xhcmU6IDAgKi9cblx0LyogZXNsaW50IGd1YXJkLWZvci1pbjogMCAqL1xuXHQvKiBlc2xpbnQgYmxvY2stc2NvcGVkLXZhcjogMCBzcGFjZS1yZXR1cm4tdGhyb3ctY2FzZTogMCwgbm8tdW51c2VkLXZhcnM6IDAgKi9cblxuXHR2YXIgcGFja2FnZUpTT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHR2YXIgZGVmYXVsdENvbmZpZ3VyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdHZhciBOT1cgPSAxO1xuXHR2YXIgUkVBRFkgPSBmYWxzZTtcblx0dmFyIFJFQURZX0JVRkZFUiA9IFtdO1xuXHR2YXIgUFJFU0VOQ0VfU1VGRklYID0gJy1wbnByZXMnO1xuXHR2YXIgREVGX1dJTkRPV0lORyA9IDEwOyAvLyBNSUxMSVNFQ09ORFMuXG5cdHZhciBERUZfVElNRU9VVCA9IDE1MDAwOyAvLyBNSUxMSVNFQ09ORFMuXG5cdHZhciBERUZfU1VCX1RJTUVPVVQgPSAzMTA7IC8vIFNFQ09ORFMuXG5cdHZhciBERUZfS0VFUEFMSVZFID0gNjA7IC8vIFNFQ09ORFMgKEZPUiBUSU1FU1lOQykuXG5cdHZhciBTRUNPTkQgPSAxMDAwOyAvLyBBIFRIT1VTQU5EIE1JTExJU0VDT05EUy5cblx0dmFyIFBSRVNFTkNFX0hCX1RIUkVTSE9MRCA9IDU7XG5cdHZhciBQUkVTRU5DRV9IQl9ERUZBVUxUID0gMzA7XG5cdHZhciBTREtfVkVSID0gcGFja2FnZUpTT04udmVyc2lvbjtcblxuXHQvKipcblx0ICogVVRJTElUSUVTXG5cdCAqL1xuXHRmdW5jdGlvbiB1bmlxdWUoKSB7XG5cdCAgcmV0dXJuICd4JyArICsrTk9XICsgJycgKyAoK25ldyBEYXRlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBORVhUT1JJR0lOXG5cdCAqID09PT09PT09PT1cblx0ICogdmFyIG5leHRfb3JpZ2luID0gbmV4dG9yaWdpbigpO1xuXHQgKi9cblx0dmFyIG5leHRvcmlnaW4gPSAoZnVuY3Rpb24gKCkge1xuXHQgIHZhciBtYXggPSAyMDtcblx0ICB2YXIgb3JpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcblx0ICByZXR1cm4gZnVuY3Rpb24gKG9yaWdpbiwgZmFpbG92ZXIpIHtcblx0ICAgIHJldHVybiBvcmlnaW4uaW5kZXhPZigncHVic3ViLicpID4gMFxuXHQgICAgICAmJiBvcmlnaW4ucmVwbGFjZShcblx0ICAgICAgICAncHVic3ViJywgJ3BzJyArIChcblx0ICAgICAgICAgIGZhaWxvdmVyID8gdXRpbHMuZ2VuZXJhdGVVVUlEKCkuc3BsaXQoJy0nKVswXSA6XG5cdCAgICAgICAgICAgICgrK29yaSA8IG1heCA/IG9yaSA6IG9yaSA9IDEpXG5cdCAgICAgICAgKSkgfHwgb3JpZ2luO1xuXHQgIH07XG5cdH0pKCk7XG5cblxuXHQvKipcblx0ICogR2VuZXJhdGUgU3Vic2NyaXB0aW9uIENoYW5uZWwgTGlzdFxuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIGdlbmVyYXRlX2NoYW5uZWxfbGlzdChjaGFubmVsc19vYmplY3QpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuZXJhdGVfY2hhbm5lbF9saXN0KGNoYW5uZWxzLCBub3ByZXNlbmNlKSB7XG5cdCAgdmFyIGxpc3QgPSBbXTtcblx0ICB1dGlscy5lYWNoKGNoYW5uZWxzLCBmdW5jdGlvbiAoY2hhbm5lbCwgc3RhdHVzKSB7XG5cdCAgICBpZiAobm9wcmVzZW5jZSkge1xuXHQgICAgICBpZiAoY2hhbm5lbC5zZWFyY2goJy1wbnByZXMnKSA8IDApIHtcblx0ICAgICAgICBpZiAoc3RhdHVzLnN1YnNjcmliZWQpIGxpc3QucHVzaChjaGFubmVsKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHN0YXR1cy5zdWJzY3JpYmVkKSBsaXN0LnB1c2goY2hhbm5lbCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGxpc3Quc29ydCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIFN1YnNjcmlwdGlvbiBDaGFubmVsIEdyb3VwcyBMaXN0XG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KGNoYW5uZWxzX2dyb3VwcyBvYmplY3QpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KGNoYW5uZWxfZ3JvdXBzLCBub3ByZXNlbmNlKSB7XG5cdCAgdmFyIGxpc3QgPSBbXTtcblx0ICB1dGlscy5lYWNoKGNoYW5uZWxfZ3JvdXBzLCBmdW5jdGlvbiAoY2hhbm5lbF9ncm91cCwgc3RhdHVzKSB7XG5cdCAgICBpZiAobm9wcmVzZW5jZSkge1xuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cC5zZWFyY2goJy1wbnByZXMnKSA8IDApIHtcblx0ICAgICAgICBpZiAoc3RhdHVzLnN1YnNjcmliZWQpIGxpc3QucHVzaChjaGFubmVsX2dyb3VwKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHN0YXR1cy5zdWJzY3JpYmVkKSBsaXN0LnB1c2goY2hhbm5lbF9ncm91cCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGxpc3Quc29ydCgpO1xuXHR9XG5cblx0Ly8gUFVCTlVCIFJFQURZIFRPIENPTk5FQ1Rcblx0ZnVuY3Rpb24gcmVhZHkoKSB7XG5cdCAgaWYgKFJFQURZKSByZXR1cm47XG5cdCAgUkVBRFkgPSAxO1xuXHQgIHV0aWxzLmVhY2goUkVBRFlfQlVGRkVSLCBmdW5jdGlvbiAoY29ubmVjdCkge1xuXHQgICAgY29ubmVjdCgpO1xuXHQgIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gUE5tZXNzYWdlKGFyZ3MpIHtcblx0ICB2YXIgbXNnID0gYXJncyB8fCB7IGFwbnM6IHt9IH07XG5cblx0ICBtc2dbJ2dldFB1Ym51Yk1lc3NhZ2UnXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBtID0ge307XG5cblx0ICAgIGlmIChPYmplY3Qua2V5cyhtc2dbJ2FwbnMnXSkubGVuZ3RoKSB7XG5cdCAgICAgIG1bJ3BuX2FwbnMnXSA9IHtcblx0ICAgICAgICBhcHM6IHtcblx0ICAgICAgICAgIGFsZXJ0OiBtc2dbJ2FwbnMnXVsnYWxlcnQnXSxcblx0ICAgICAgICAgIGJhZGdlOiBtc2dbJ2FwbnMnXVsnYmFkZ2UnXVxuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgICAgZm9yICh2YXIgayBpbiBtc2dbJ2FwbnMnXSkge1xuXHQgICAgICAgIG1bJ3BuX2FwbnMnXVtrXSA9IG1zZ1snYXBucyddW2tdO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBleGNsdWRlMSA9IFsnYmFkZ2UnLCAnYWxlcnQnXTtcblx0ICAgICAgZm9yICh2YXIgayBpbiBleGNsdWRlMSkge1xuXHQgICAgICAgIGRlbGV0ZSBtWydwbl9hcG5zJ11bZXhjbHVkZTFba11dO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChtc2dbJ2djbSddKSB7XG5cdCAgICAgIG1bJ3BuX2djbSddID0ge1xuXHQgICAgICAgIGRhdGE6IG1zZ1snZ2NtJ11cblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgayBpbiBtc2cpIHtcblx0ICAgICAgbVtrXSA9IG1zZ1trXTtcblx0ICAgIH1cblx0ICAgIHZhciBleGNsdWRlID0gWydhcG5zJywgJ2djbScsICdwdWJsaXNoJywgJ2NoYW5uZWwnLCAnY2FsbGJhY2snLCAnZXJyb3InXTtcblx0ICAgIGZvciAodmFyIGsgaW4gZXhjbHVkZSkge1xuXHQgICAgICBkZWxldGUgbVtleGNsdWRlW2tdXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG07XG5cdCAgfTtcblx0ICBtc2dbJ3B1Ymxpc2gnXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBtID0gbXNnLmdldFB1Ym51Yk1lc3NhZ2UoKTtcblxuXHQgICAgaWYgKG1zZ1sncHVibnViJ10gJiYgbXNnWydjaGFubmVsJ10pIHtcblx0ICAgICAgbXNnWydwdWJudWInXS5wdWJsaXNoKHtcblx0ICAgICAgICBtZXNzYWdlOiBtLFxuXHQgICAgICAgIGNoYW5uZWw6IG1zZ1snY2hhbm5lbCddLFxuXHQgICAgICAgIGNhbGxiYWNrOiBtc2dbJ2NhbGxiYWNrJ10sXG5cdCAgICAgICAgZXJyb3I6IG1zZ1snZXJyb3InXVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIHJldHVybiBtc2c7XG5cdH1cblxuXHRmdW5jdGlvbiBQTl9BUEkoc2V0dXApIHtcblx0ICB2YXIgU1VCX1dJTkRPV0lORyA9ICtzZXR1cFsnd2luZG93aW5nJ10gfHwgREVGX1dJTkRPV0lORztcblx0ICB2YXIgU1VCX1RJTUVPVVQgPSAoK3NldHVwWyd0aW1lb3V0J10gfHwgREVGX1NVQl9USU1FT1VUKSAqIFNFQ09ORDtcblx0ICB2YXIgS0VFUEFMSVZFID0gKCtzZXR1cFsna2VlcGFsaXZlJ10gfHwgREVGX0tFRVBBTElWRSkgKiBTRUNPTkQ7XG5cdCAgdmFyIFRJTUVfQ0hFQ0sgPSBzZXR1cFsndGltZWNoZWNrJ10gfHwgMDtcblx0ICB2YXIgTk9MRUFWRSA9IHNldHVwWydub2xlYXZlJ10gfHwgMDtcblx0ICB2YXIgUFVCTElTSF9LRVkgPSBzZXR1cFsncHVibGlzaF9rZXknXTtcblx0ICB2YXIgU1VCU0NSSUJFX0tFWSA9IHNldHVwWydzdWJzY3JpYmVfa2V5J107XG5cdCAgdmFyIEFVVEhfS0VZID0gc2V0dXBbJ2F1dGhfa2V5J10gfHwgJyc7XG5cdCAgdmFyIFNFQ1JFVF9LRVkgPSBzZXR1cFsnc2VjcmV0X2tleSddIHx8ICcnO1xuXHQgIHZhciBobWFjX1NIQTI1NiA9IHNldHVwWydobWFjX1NIQTI1NiddO1xuXHQgIHZhciBTU0wgPSBzZXR1cFsnc3NsJ10gPyAncycgOiAnJztcblx0ICB2YXIgT1JJR0lOID0gJ2h0dHAnICsgU1NMICsgJzovLycgKyAoc2V0dXBbJ29yaWdpbiddIHx8ICdwdWJzdWIucHVibnViLmNvbScpO1xuXHQgIHZhciBTVERfT1JJR0lOID0gbmV4dG9yaWdpbihPUklHSU4pO1xuXHQgIHZhciBTVUJfT1JJR0lOID0gbmV4dG9yaWdpbihPUklHSU4pO1xuXHQgIHZhciBDT05ORUNUID0gZnVuY3Rpb24gKCkge1xuXHQgIH07XG5cdCAgdmFyIFBVQl9RVUVVRSA9IFtdO1xuXHQgIHZhciBDTE9BSyA9IHRydWU7XG5cdCAgdmFyIFRJTUVfRFJJRlQgPSAwO1xuXHQgIHZhciBTVUJfQ0FMTEJBQ0sgPSAwO1xuXHQgIHZhciBTVUJfQ0hBTk5FTCA9IDA7XG5cdCAgdmFyIFNVQl9SRUNFSVZFUiA9IDA7XG5cdCAgdmFyIFNVQl9SRVNUT1JFID0gc2V0dXBbJ3Jlc3RvcmUnXSB8fCAwO1xuXHQgIHZhciBTVUJfQlVGRl9XQUlUID0gMDtcblx0ICB2YXIgVElNRVRPS0VOID0gMDtcblx0ICB2YXIgUkVTVU1FRCA9IGZhbHNlO1xuXHQgIHZhciBDSEFOTkVMUyA9IHt9O1xuXHQgIHZhciBDSEFOTkVMX0dST1VQUyA9IHt9O1xuXHQgIHZhciBTVUJfRVJST1IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgfTtcblx0ICB2YXIgU1RBVEUgPSB7fTtcblx0ICB2YXIgUFJFU0VOQ0VfSEJfVElNRU9VVCA9IG51bGw7XG5cdCAgdmFyIFBSRVNFTkNFX0hCID0gdmFsaWRhdGVfcHJlc2VuY2VfaGVhcnRiZWF0KFxuXHQgICAgc2V0dXBbJ2hlYXJ0YmVhdCddIHx8IHNldHVwWydwbmV4cGlyZXMnXSB8fCAwLCBzZXR1cFsnZXJyb3InXVxuXHQgICk7XG5cdCAgdmFyIFBSRVNFTkNFX0hCX0lOVEVSVkFMID0gc2V0dXBbJ2hlYXJ0YmVhdF9pbnRlcnZhbCddIHx8IChQUkVTRU5DRV9IQiAvIDIpIC0gMTtcblx0ICB2YXIgUFJFU0VOQ0VfSEJfUlVOTklORyA9IGZhbHNlO1xuXHQgIHZhciBOT19XQUlUX0ZPUl9QRU5ESU5HID0gc2V0dXBbJ25vX3dhaXRfZm9yX3BlbmRpbmcnXTtcblx0ICB2YXIgQ09NUEFUSUJMRV8zNSA9IHNldHVwWydjb21wYXRpYmxlXzMuNSddIHx8IGZhbHNlO1xuXHQgIHZhciB4ZHIgPSBzZXR1cFsneGRyJ107XG5cdCAgdmFyIHBhcmFtcyA9IHNldHVwWydwYXJhbXMnXSB8fCB7fTtcblx0ICB2YXIgZXJyb3IgPSBzZXR1cFsnZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICB2YXIgX2lzX29ubGluZSA9IHNldHVwWydfaXNfb25saW5lJ10gfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMTt9O1xuXHQgIHZhciBqc29ucF9jYiA9IHNldHVwWydqc29ucF9jYiddIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XG5cdCAgdmFyIGRiID0gc2V0dXBbJ2RiJ10gfHwgeyBnZXQ6IGZ1bmN0aW9uICgpIHt9LCBzZXQ6IGZ1bmN0aW9uICgpIHt9IH07XG5cdCAgdmFyIENJUEhFUl9LRVkgPSBzZXR1cFsnY2lwaGVyX2tleSddO1xuXHQgIHZhciBVVUlEID0gc2V0dXBbJ3V1aWQnXSB8fCAoIXNldHVwWyd1bmlxdWVfdXVpZCddICYmIGRiICYmIGRiWydnZXQnXShTVUJTQ1JJQkVfS0VZICsgJ3V1aWQnKSB8fCAnJyk7XG5cdCAgdmFyIFVTRV9JTlNUQU5DRUlEID0gc2V0dXBbJ2luc3RhbmNlX2lkJ10gfHwgZmFsc2U7XG5cdCAgdmFyIElOU1RBTkNFSUQgPSAnJztcblx0ICB2YXIgc2h1dGRvd24gPSBzZXR1cFsnc2h1dGRvd24nXTtcblx0ICB2YXIgdXNlX3NlbmRfYmVhY29uID0gKHR5cGVvZiBzZXR1cFsndXNlX3NlbmRfYmVhY29uJ10gIT0gJ3VuZGVmaW5lZCcpID8gc2V0dXBbJ3VzZV9zZW5kX2JlYWNvbiddIDogdHJ1ZTtcblx0ICB2YXIgc2VuZEJlYWNvbiA9ICh1c2Vfc2VuZF9iZWFjb24pID8gc2V0dXBbJ3NlbmRCZWFjb24nXSA6IG51bGw7XG5cdCAgdmFyIF9wb2xsX3RpbWVyO1xuXHQgIHZhciBfcG9sbF90aW1lcjI7XG5cblx0ICBpZiAoUFJFU0VOQ0VfSEIgPT09IDIpIFBSRVNFTkNFX0hCX0lOVEVSVkFMID0gMTtcblxuXHQgIHZhciBjcnlwdG9fb2JqID0gc2V0dXBbJ2NyeXB0b19vYmonXSB8fCB7XG5cdCAgICBlbmNyeXB0OiBmdW5jdGlvbiAoYSwga2V5KSB7XG5cdCAgICAgIHJldHVybiBhO1xuXHQgICAgfSxcblx0ICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChiLCBrZXkpIHtcblx0ICAgICAgcmV0dXJuIGI7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIF9nZXRfdXJsX3BhcmFtcyhkYXRhKSB7XG5cdCAgICBpZiAoIWRhdGEpIGRhdGEgPSB7fTtcblx0ICAgIHV0aWxzLmVhY2gocGFyYW1zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgICAgICBpZiAoIShrZXkgaW4gZGF0YSkpIGRhdGFba2V5XSA9IHZhbHVlO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfb2JqZWN0X3RvX2tleV9saXN0KG8pIHtcblx0ICAgIHZhciBsID0gW107XG5cdCAgICB1dGlscy5lYWNoKG8sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdCAgICAgIGwucHVzaChrZXkpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gbDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfb2JqZWN0X3RvX2tleV9saXN0X3NvcnRlZChvKSB7XG5cdCAgICByZXR1cm4gX29iamVjdF90b19rZXlfbGlzdChvKS5zb3J0KCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX2dldF9wYW1fc2lnbl9pbnB1dF9mcm9tX3BhcmFtcyhwYXJhbXMpIHtcblx0ICAgIHZhciBzaSA9ICcnO1xuXHQgICAgdmFyIGwgPSBfb2JqZWN0X3RvX2tleV9saXN0X3NvcnRlZChwYXJhbXMpO1xuXG5cdCAgICBmb3IgKHZhciBpIGluIGwpIHtcblx0ICAgICAgdmFyIGsgPSBsW2ldO1xuXHQgICAgICBzaSArPSBrICsgJz0nICsgdXRpbHMucGFtRW5jb2RlKHBhcmFtc1trXSk7XG5cdCAgICAgIGlmIChpICE9IGwubGVuZ3RoIC0gMSkgc2kgKz0gJyYnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHNpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHZhbGlkYXRlX3ByZXNlbmNlX2hlYXJ0YmVhdChoZWFydGJlYXQsIGN1cl9oZWFydGJlYXQsIGVycm9yKSB7XG5cdCAgICB2YXIgZXJyID0gZmFsc2U7XG5cblx0ICAgIGlmICh0eXBlb2YgaGVhcnRiZWF0ID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgICByZXR1cm4gY3VyX2hlYXJ0YmVhdDtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBoZWFydGJlYXQgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIGlmIChoZWFydGJlYXQgPiBQUkVTRU5DRV9IQl9USFJFU0hPTEQgfHwgaGVhcnRiZWF0ID09IDApIHtcblx0ICAgICAgICBlcnIgPSBmYWxzZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBlcnIgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFydGJlYXQgPT09ICdib29sZWFuJykge1xuXHQgICAgICBpZiAoIWhlYXJ0YmVhdCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBQUkVTRU5DRV9IQl9ERUZBVUxUO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBlcnIgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZXJyKSB7XG5cdCAgICAgIGVycm9yICYmIGVycm9yKCdQcmVzZW5jZSBIZWFydGJlYXQgdmFsdWUgaW52YWxpZC4gVmFsaWQgcmFuZ2UgKCB4ID4gJyArIFBSRVNFTkNFX0hCX1RIUkVTSE9MRCArICcgb3IgeCA9IDApLiBDdXJyZW50IFZhbHVlIDogJyArIChjdXJfaGVhcnRiZWF0IHx8IFBSRVNFTkNFX0hCX1RIUkVTSE9MRCkpO1xuXHQgICAgICByZXR1cm4gY3VyX2hlYXJ0YmVhdCB8fCBQUkVTRU5DRV9IQl9USFJFU0hPTEQ7XG5cdCAgICB9IGVsc2UgcmV0dXJuIGhlYXJ0YmVhdDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBlbmNyeXB0KGlucHV0LCBrZXkpIHtcblx0ICAgIHJldHVybiBjcnlwdG9fb2JqWydlbmNyeXB0J10oaW5wdXQsIGtleSB8fCBDSVBIRVJfS0VZKSB8fCBpbnB1dDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkZWNyeXB0KGlucHV0LCBrZXkpIHtcblx0ICAgIHJldHVybiBjcnlwdG9fb2JqWydkZWNyeXB0J10oaW5wdXQsIGtleSB8fCBDSVBIRVJfS0VZKSB8fFxuXHQgICAgICBjcnlwdG9fb2JqWydkZWNyeXB0J10oaW5wdXQsIENJUEhFUl9LRVkpIHx8XG5cdCAgICAgIGlucHV0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGVycm9yX2NvbW1vbihtZXNzYWdlLCBjYWxsYmFjaykge1xuXHQgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soeyBlcnJvcjogbWVzc2FnZSB8fCAnZXJyb3Igb2NjdXJyZWQnIH0pO1xuXHQgICAgZXJyb3IgJiYgZXJyb3IobWVzc2FnZSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX3ByZXNlbmNlX2hlYXJ0YmVhdCgpIHtcblx0ICAgIGNsZWFyVGltZW91dChQUkVTRU5DRV9IQl9USU1FT1VUKTtcblxuXHQgICAgaWYgKCFQUkVTRU5DRV9IQl9JTlRFUlZBTCB8fCBQUkVTRU5DRV9IQl9JTlRFUlZBTCA+PSA1MDAgfHxcblx0ICAgICAgUFJFU0VOQ0VfSEJfSU5URVJWQUwgPCAxIHx8XG5cdCAgICAgICghZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTLCB0cnVlKS5sZW5ndGggJiYgIWdlbmVyYXRlX2NoYW5uZWxfZ3JvdXBfbGlzdChDSEFOTkVMX0dST1VQUywgdHJ1ZSkubGVuZ3RoKSkge1xuXHQgICAgICBQUkVTRU5DRV9IQl9SVU5OSU5HID0gZmFsc2U7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgUFJFU0VOQ0VfSEJfUlVOTklORyA9IHRydWU7XG5cdCAgICBTRUxGWydwcmVzZW5jZV9oZWFydGJlYXQnXSh7XG5cdCAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAocikge1xuXHQgICAgICAgIFBSRVNFTkNFX0hCX1RJTUVPVVQgPSB1dGlscy50aW1lb3V0KF9wcmVzZW5jZV9oZWFydGJlYXQsIChQUkVTRU5DRV9IQl9JTlRFUlZBTCkgKiBTRUNPTkQpO1xuXHQgICAgICB9LFxuXHQgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBlcnJvciAmJiBlcnJvcignUHJlc2VuY2UgSGVhcnRiZWF0IHVuYWJsZSB0byByZWFjaCBQdWJudWIgc2VydmVycy4nICsgSlNPTi5zdHJpbmdpZnkoZSkpO1xuXHQgICAgICAgIFBSRVNFTkNFX0hCX1RJTUVPVVQgPSB1dGlscy50aW1lb3V0KF9wcmVzZW5jZV9oZWFydGJlYXQsIChQUkVTRU5DRV9IQl9JTlRFUlZBTCkgKiBTRUNPTkQpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzdGFydF9wcmVzZW5jZV9oZWFydGJlYXQoKSB7XG5cdCAgICAhUFJFU0VOQ0VfSEJfUlVOTklORyAmJiBfcHJlc2VuY2VfaGVhcnRiZWF0KCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcHVibGlzaChuZXh0KSB7XG5cdCAgICBpZiAoTk9fV0FJVF9GT1JfUEVORElORykge1xuXHQgICAgICBpZiAoIVBVQl9RVUVVRS5sZW5ndGgpIHJldHVybjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChuZXh0KSBQVUJfUVVFVUUuc2VuZGluZyA9IDA7XG5cdCAgICAgIGlmIChQVUJfUVVFVUUuc2VuZGluZyB8fCAhUFVCX1FVRVVFLmxlbmd0aCkgcmV0dXJuO1xuXHQgICAgICBQVUJfUVVFVUUuc2VuZGluZyA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHhkcihQVUJfUVVFVUUuc2hpZnQoKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZWFjaF9jaGFubmVsX2dyb3VwKGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgY291bnQgPSAwO1xuXG5cdCAgICB1dGlscy5lYWNoKGdlbmVyYXRlX2NoYW5uZWxfZ3JvdXBfbGlzdChDSEFOTkVMX0dST1VQUyksIGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgIHZhciBjaGFuZyA9IENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdO1xuXG5cdCAgICAgIGlmICghY2hhbmcpIHJldHVybjtcblxuXHQgICAgICBjb3VudCsrO1xuXHQgICAgICAoY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge1xuXHQgICAgICB9KShjaGFuZyk7XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIGNvdW50O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGVhY2hfY2hhbm5lbChjYWxsYmFjaykge1xuXHQgICAgdmFyIGNvdW50ID0gMDtcblxuXHQgICAgdXRpbHMuZWFjaChnZW5lcmF0ZV9jaGFubmVsX2xpc3QoQ0hBTk5FTFMpLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICB2YXIgY2hhbiA9IENIQU5ORUxTW2NoYW5uZWxdO1xuXG5cdCAgICAgIGlmICghY2hhbikgcmV0dXJuO1xuXG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICAgIChjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIH0pKGNoYW4pO1xuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiBjb3VudDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKSB7XG5cdCAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09ICdvYmplY3QnKSB7XG5cdCAgICAgIGlmIChyZXNwb25zZVsnZXJyb3InXSkge1xuXHQgICAgICAgIHZhciBjYWxsYmFja19kYXRhID0ge307XG5cblx0ICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSkge1xuXHQgICAgICAgICAgY2FsbGJhY2tfZGF0YVsnbWVzc2FnZSddID0gcmVzcG9uc2VbJ21lc3NhZ2UnXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAocmVzcG9uc2VbJ3BheWxvYWQnXSkge1xuXHQgICAgICAgICAgY2FsbGJhY2tfZGF0YVsncGF5bG9hZCddID0gcmVzcG9uc2VbJ3BheWxvYWQnXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBlcnIgJiYgZXJyKGNhbGxiYWNrX2RhdGEpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAocmVzcG9uc2VbJ3BheWxvYWQnXSkge1xuXHQgICAgICAgIGlmIChyZXNwb25zZVsnbmV4dF9wYWdlJ10pIHtcblx0ICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlWydwYXlsb2FkJ10sIHJlc3BvbnNlWyduZXh0X3BhZ2UnXSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlWydwYXlsb2FkJ10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpIHtcblx0ICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT0gJ29iamVjdCcgJiYgcmVzcG9uc2VbJ2Vycm9yJ10pIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrX2RhdGEgPSB7fTtcblxuXHQgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSkge1xuXHQgICAgICAgIGNhbGxiYWNrX2RhdGFbJ21lc3NhZ2UnXSA9IHJlc3BvbnNlWydtZXNzYWdlJ107XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAocmVzcG9uc2VbJ3BheWxvYWQnXSkge1xuXHQgICAgICAgIGNhbGxiYWNrX2RhdGFbJ3BheWxvYWQnXSA9IHJlc3BvbnNlWydwYXlsb2FkJ107XG5cdCAgICAgIH1cblxuXHQgICAgICBlcnIgJiYgZXJyKGNhbGxiYWNrX2RhdGEpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBlcnIgJiYgZXJyKHJlc3BvbnNlKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBDUihhcmdzLCBjYWxsYmFjaywgdXJsMSwgZGF0YSkge1xuXHQgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBjYWxsYmFjaztcblx0ICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGVycm9yO1xuXHQgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblxuXHQgICAgZGF0YSA9IGRhdGEgfHwge307XG5cblx0ICAgIGlmICghZGF0YVsnYXV0aCddKSB7XG5cdCAgICAgIGRhdGFbJ2F1dGgnXSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICB9XG5cblx0ICAgIHZhciB1cmwgPSBbXG5cdCAgICAgIFNURF9PUklHSU4sICd2MScsICdjaGFubmVsLXJlZ2lzdHJhdGlvbicsXG5cdCAgICAgICdzdWIta2V5JywgU1VCU0NSSUJFX0tFWVxuXHQgICAgXTtcblxuXHQgICAgdXJsLnB1c2guYXBwbHkodXJsLCB1cmwxKTtcblxuXHQgICAgaWYgKGpzb25wKSBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cblx0ICAgIHhkcih7XG5cdCAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpLFxuXHQgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgfSxcblx0ICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgfSxcblx0ICAgICAgdXJsOiB1cmxcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIC8vIEFubm91bmNlIExlYXZlIEV2ZW50XG5cdCAgdmFyIFNFTEYgPSB7XG5cdCAgICBMRUFWRTogZnVuY3Rpb24gKGNoYW5uZWwsIGJsb2NraW5nLCBhdXRoX2tleSwgY2FsbGJhY2ssIGVycm9yKSB7XG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBhdXRoX2tleSB8fCBBVVRIX0tFWSB9O1xuXHQgICAgICB2YXIgb3JpZ2luID0gbmV4dG9yaWdpbihPUklHSU4pO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGVycm9yIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgdXJsO1xuXHQgICAgICB2YXIgcGFyYW1zO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICAgIC8vIFByZXZlbnQgTGVhdmluZyBhIFByZXNlbmNlIENoYW5uZWxcblx0ICAgICAgaWYgKGNoYW5uZWwuaW5kZXhPZihQUkVTRU5DRV9TVUZGSVgpID4gMCkgcmV0dXJuIHRydWU7XG5cblxuXHQgICAgICBpZiAoQ09NUEFUSUJMRV8zNSkge1xuXHQgICAgICAgIGlmICghU1NMKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgaWYgKGpzb25wID09ICcwJykgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKE5PTEVBVkUpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHVybCA9IFtcblx0ICAgICAgICBvcmlnaW4sICd2MicsICdwcmVzZW5jZScsICdzdWJfa2V5Jyxcblx0ICAgICAgICBTVUJTQ1JJQkVfS0VZLCAnY2hhbm5lbCcsIHV0aWxzLmVuY29kZShjaGFubmVsKSwgJ2xlYXZlJ1xuXHQgICAgICBdO1xuXG5cdCAgICAgIHBhcmFtcyA9IF9nZXRfdXJsX3BhcmFtcyhkYXRhKTtcblxuXG5cdCAgICAgIGlmIChzZW5kQmVhY29uKSB7XG5cdCAgICAgICAgdmFyIHVybF9zdHJpbmcgPSB1dGlscy5idWlsZFVSTCh1cmwsIHBhcmFtcyk7XG5cdCAgICAgICAgaWYgKHNlbmRCZWFjb24odXJsX3N0cmluZykpIHtcblx0ICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHsgc3RhdHVzOiAyMDAsIGFjdGlvbjogJ2xlYXZlJywgbWVzc2FnZTogJ09LJywgc2VydmljZTogJ1ByZXNlbmNlJyB9KTtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBibG9ja2luZzogYmxvY2tpbmcgfHwgU1NMLFxuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBwYXJhbXMsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogdXJsXG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0sXG5cblx0ICAgIExFQVZFX0dST1VQOiBmdW5jdGlvbiAoY2hhbm5lbF9ncm91cCwgYmxvY2tpbmcsIGF1dGhfa2V5LCBjYWxsYmFjaywgZXJyb3IpIHtcblx0ICAgICAgdmFyIGRhdGEgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IGF1dGhfa2V5IHx8IEFVVEhfS0VZIH07XG5cdCAgICAgIHZhciBvcmlnaW4gPSBuZXh0b3JpZ2luKE9SSUdJTik7XG5cdCAgICAgIHZhciB1cmw7XG5cdCAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgZXJyID0gZXJyb3IgfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cblx0ICAgICAgLy8gUHJldmVudCBMZWF2aW5nIGEgUHJlc2VuY2UgQ2hhbm5lbCBHcm91cFxuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cC5pbmRleE9mKFBSRVNFTkNFX1NVRkZJWCkgPiAwKSByZXR1cm4gdHJ1ZTtcblxuXHQgICAgICBpZiAoQ09NUEFUSUJMRV8zNSkge1xuXHQgICAgICAgIGlmICghU1NMKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgaWYgKGpzb25wID09ICcwJykgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKE5PTEVBVkUpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXAgJiYgY2hhbm5lbF9ncm91cC5sZW5ndGggPiAwKSBkYXRhWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3VwO1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICB1cmwgPSBbXG5cdCAgICAgICAgb3JpZ2luLCAndjInLCAncHJlc2VuY2UnLCAnc3ViX2tleScsXG5cdCAgICAgICAgU1VCU0NSSUJFX0tFWSwgJ2NoYW5uZWwnLCB1dGlscy5lbmNvZGUoJywnKSwgJ2xlYXZlJ1xuXHQgICAgICBdO1xuXG5cdCAgICAgIHBhcmFtcyA9IF9nZXRfdXJsX3BhcmFtcyhkYXRhKTtcblxuXHQgICAgICBpZiAoc2VuZEJlYWNvbikge1xuXHQgICAgICAgIHZhciB1cmxfc3RyaW5nID0gdXRpbHMuYnVpbGRVUkwodXJsLCBwYXJhbXMpO1xuXHQgICAgICAgIGlmIChzZW5kQmVhY29uKHVybF9zdHJpbmcpKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh7IHN0YXR1czogMjAwLCBhY3Rpb246ICdsZWF2ZScsIG1lc3NhZ2U6ICdPSycsIHNlcnZpY2U6ICdQcmVzZW5jZScgfSk7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGJsb2NraW5nOiBibG9ja2luZyB8fCBTU0wsXG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IHBhcmFtcyxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSxcblxuXHQgICAgc2V0X3Jlc3VtZWQ6IGZ1bmN0aW9uIChyZXN1bWVkKSB7XG5cdCAgICAgIFJFU1VNRUQgPSByZXN1bWVkO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X2NpcGhlcl9rZXk6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIENJUEhFUl9LRVk7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRfY2lwaGVyX2tleTogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICBDSVBIRVJfS0VZID0ga2V5O1xuXHQgICAgfSxcblxuXHQgICAgcmF3X2VuY3J5cHQ6IGZ1bmN0aW9uIChpbnB1dCwga2V5KSB7XG5cdCAgICAgIHJldHVybiBlbmNyeXB0KGlucHV0LCBrZXkpO1xuXHQgICAgfSxcblxuXHQgICAgcmF3X2RlY3J5cHQ6IGZ1bmN0aW9uIChpbnB1dCwga2V5KSB7XG5cdCAgICAgIHJldHVybiBkZWNyeXB0KGlucHV0LCBrZXkpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X2hlYXJ0YmVhdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gUFJFU0VOQ0VfSEI7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRfaGVhcnRiZWF0OiBmdW5jdGlvbiAoaGVhcnRiZWF0LCBoZWFydGJlYXRfaW50ZXJ2YWwpIHtcblx0ICAgICAgUFJFU0VOQ0VfSEIgPSB2YWxpZGF0ZV9wcmVzZW5jZV9oZWFydGJlYXQoaGVhcnRiZWF0LCBQUkVTRU5DRV9IQiwgZXJyb3IpO1xuXHQgICAgICBQUkVTRU5DRV9IQl9JTlRFUlZBTCA9IGhlYXJ0YmVhdF9pbnRlcnZhbCB8fCAoUFJFU0VOQ0VfSEIgLyAyKSAtIDE7XG5cdCAgICAgIGlmIChQUkVTRU5DRV9IQiA9PSAyKSB7XG5cdCAgICAgICAgUFJFU0VOQ0VfSEJfSU5URVJWQUwgPSAxO1xuXHQgICAgICB9XG5cdCAgICAgIENPTk5FQ1QoKTtcblx0ICAgICAgX3ByZXNlbmNlX2hlYXJ0YmVhdCgpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X2hlYXJ0YmVhdF9pbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gUFJFU0VOQ0VfSEJfSU5URVJWQUw7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRfaGVhcnRiZWF0X2ludGVydmFsOiBmdW5jdGlvbiAoaGVhcnRiZWF0X2ludGVydmFsKSB7XG5cdCAgICAgIFBSRVNFTkNFX0hCX0lOVEVSVkFMID0gaGVhcnRiZWF0X2ludGVydmFsO1xuXHQgICAgICBfcHJlc2VuY2VfaGVhcnRiZWF0KCk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRfdmVyc2lvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gU0RLX1ZFUjtcblx0ICAgIH0sXG5cblx0ICAgIGdldEdjbU1lc3NhZ2VPYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkYXRhOiBvYmpcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEFwbnNNZXNzYWdlT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHZhciB4ID0ge1xuXHQgICAgICAgIGFwczogeyBiYWRnZTogMSwgYWxlcnQ6ICcnIH1cblx0ICAgICAgfTtcblx0ICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcblx0ICAgICAgICBrW3hdID0gb2JqW2tdO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB4O1xuXHQgICAgfSxcblxuXHQgICAgX2FkZF9wYXJhbTogZnVuY3Rpb24gKGtleSwgdmFsKSB7XG5cdCAgICAgIHBhcmFtc1trZXldID0gdmFsO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBuc19jaCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXTtcblx0ICAgICAgdmFyIGNoYW5uZWxzID0gYXJnc1snY2hhbm5lbHMnXSB8fCBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBjbG9hayA9IGFyZ3NbJ2Nsb2FrJ107XG5cdCAgICAgIHZhciBuYW1lc3BhY2U7XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwO1xuXHQgICAgICB2YXIgdXJsID0gW107XG5cdCAgICAgIHZhciBkYXRhID0ge307XG5cdCAgICAgIHZhciBtb2RlID0gYXJnc1snbW9kZSddIHx8ICdhZGQnO1xuXG5cblx0ICAgICAgaWYgKG5zX2NoKSB7XG5cdCAgICAgICAgdmFyIG5zX2NoX2EgPSBuc19jaC5zcGxpdCgnOicpO1xuXG5cdCAgICAgICAgaWYgKG5zX2NoX2EubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgbmFtZXNwYWNlID0gKG5zX2NoX2FbMF0gPT09ICcqJykgPyBudWxsIDogbnNfY2hfYVswXTtcblxuXHQgICAgICAgICAgY2hhbm5lbF9ncm91cCA9IG5zX2NoX2FbMV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGNoYW5uZWxfZ3JvdXAgPSBuc19jaF9hWzBdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIG5hbWVzcGFjZSAmJiB1cmwucHVzaCgnbmFtZXNwYWNlJykgJiYgdXJsLnB1c2godXRpbHMuZW5jb2RlKG5hbWVzcGFjZSkpO1xuXG5cdCAgICAgIHVybC5wdXNoKCdjaGFubmVsLWdyb3VwJyk7XG5cblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXAgJiYgY2hhbm5lbF9ncm91cCAhPT0gJyonKSB7XG5cdCAgICAgICAgdXJsLnB1c2goY2hhbm5lbF9ncm91cCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY2hhbm5lbHMpIHtcblx0ICAgICAgICBpZiAodXRpbHMuaXNBcnJheShjaGFubmVscykpIHtcblx0ICAgICAgICAgIGNoYW5uZWxzID0gY2hhbm5lbHMuam9pbignLCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBkYXRhW21vZGVdID0gY2hhbm5lbHM7XG5cdCAgICAgICAgZGF0YVsnY2xvYWsnXSA9IChDTE9BSykgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChtb2RlID09PSAncmVtb3ZlJykgdXJsLnB1c2goJ3JlbW92ZScpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBjbG9hayAhPSAndW5kZWZpbmVkJykgZGF0YVsnY2xvYWsnXSA9IChjbG9haykgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG5cdCAgICAgIENSKGFyZ3MsIGNhbGxiYWNrLCB1cmwsIGRhdGEpO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9saXN0X2dyb3VwczogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBuYW1lc3BhY2U7XG5cblx0ICAgICAgbmFtZXNwYWNlID0gYXJnc1snbmFtZXNwYWNlJ10gfHwgYXJnc1snbnMnXSB8fCBhcmdzWydjaGFubmVsX2dyb3VwJ10gfHwgbnVsbDtcblx0ICAgICAgaWYgKG5hbWVzcGFjZSkge1xuXHQgICAgICAgIGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSA9IG5hbWVzcGFjZSArICc6Kic7XG5cdCAgICAgIH1cblxuXHQgICAgICBTRUxGWydjaGFubmVsX2dyb3VwJ10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9saXN0X2NoYW5uZWxzOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsX2dyb3VwJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsIEdyb3VwJyk7XG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX3JlbW92ZV9jaGFubmVsOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsX2dyb3VwJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsIEdyb3VwJyk7XG5cdCAgICAgIGlmICghYXJnc1snY2hhbm5lbCddICYmICFhcmdzWydjaGFubmVscyddKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCcpO1xuXG5cdCAgICAgIGFyZ3NbJ21vZGUnXSA9ICdyZW1vdmUnO1xuXHQgICAgICBTRUxGWydjaGFubmVsX2dyb3VwJ10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9yZW1vdmVfZ3JvdXA6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBpZiAoIWFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwgR3JvdXAnKTtcblx0ICAgICAgaWYgKGFyZ3NbJ2NoYW5uZWwnXSkgcmV0dXJuIGVycm9yKCdVc2UgY2hhbm5lbF9ncm91cF9yZW1vdmVfY2hhbm5lbCBpZiB5b3Ugd2FudCB0byByZW1vdmUgYSBjaGFubmVsIGZyb20gYSBncm91cC4nKTtcblxuXHQgICAgICBhcmdzWydtb2RlJ10gPSAncmVtb3ZlJztcblx0ICAgICAgU0VMRlsnY2hhbm5lbF9ncm91cCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfYWRkX2NoYW5uZWw6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBpZiAoIWFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwgR3JvdXAnKTtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsJ10gJiYgIWFyZ3NbJ2NoYW5uZWxzJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsJyk7XG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX2Nsb2FrOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKHR5cGVvZiBhcmdzWydjbG9hayddID09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgY2FsbGJhY2soQ0xPQUspO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBDTE9BSyA9IGFyZ3NbJ2Nsb2FrJ107XG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX2xpc3RfbmFtZXNwYWNlczogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciB1cmwgPSBbJ25hbWVzcGFjZSddO1xuXHQgICAgICBDUihhcmdzLCBjYWxsYmFjaywgdXJsKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfcmVtb3ZlX25hbWVzcGFjZTogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciB1cmwgPSBbJ25hbWVzcGFjZScsIGFyZ3NbJ25hbWVzcGFjZSddLCAncmVtb3ZlJ107XG5cdCAgICAgIENSKGFyZ3MsIGNhbGxiYWNrLCB1cmwpO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuaGlzdG9yeSh7XG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdF9jaGFubmVsJyxcblx0ICAgICBsaW1pdCAgICA6IDEwMCxcblx0ICAgICBjYWxsYmFjayA6IGZ1bmN0aW9uKGhpc3RvcnkpIHsgfVxuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBoaXN0b3J5OiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBjYWxsYmFjaztcblx0ICAgICAgdmFyIGNvdW50ID0gYXJnc1snY291bnQnXSB8fCBhcmdzWydsaW1pdCddIHx8IDEwMDtcblx0ICAgICAgdmFyIHJldmVyc2UgPSBhcmdzWydyZXZlcnNlJ10gfHwgJ2ZhbHNlJztcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBjaXBoZXJfa2V5ID0gYXJnc1snY2lwaGVyX2tleSddO1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBzdGFydCA9IGFyZ3NbJ3N0YXJ0J107XG5cdCAgICAgIHZhciBlbmQgPSBhcmdzWydlbmQnXTtcblx0ICAgICAgdmFyIGluY2x1ZGVfdG9rZW4gPSBhcmdzWydpbmNsdWRlX3Rva2VuJ107XG5cdCAgICAgIHZhciBzdHJpbmdfbXNnX3Rva2VuID0gYXJnc1snc3RyaW5nX21lc3NhZ2VfdG9rZW4nXSB8fCBmYWxzZTtcblx0ICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgQ2hhbm5lbFxuXHQgICAgICBpZiAoIWNoYW5uZWwgJiYgIWNoYW5uZWxfZ3JvdXApIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsJyk7XG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgcGFyYW1zWydzdHJpbmd0b2tlbiddID0gJ3RydWUnO1xuXHQgICAgICBwYXJhbXNbJ2NvdW50J10gPSBjb3VudDtcblx0ICAgICAgcGFyYW1zWydyZXZlcnNlJ10gPSByZXZlcnNlO1xuXHQgICAgICBwYXJhbXNbJ2F1dGgnXSA9IGF1dGhfa2V5O1xuXG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgcGFyYW1zWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3VwO1xuXHQgICAgICAgIGlmICghY2hhbm5lbCkge1xuXHQgICAgICAgICAgY2hhbm5lbCA9ICcsJztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGpzb25wKSBwYXJhbXNbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgaWYgKHN0YXJ0KSBwYXJhbXNbJ3N0YXJ0J10gPSBzdGFydDtcblx0ICAgICAgaWYgKGVuZCkgcGFyYW1zWydlbmQnXSA9IGVuZDtcblx0ICAgICAgaWYgKGluY2x1ZGVfdG9rZW4pIHBhcmFtc1snaW5jbHVkZV90b2tlbiddID0gJ3RydWUnO1xuXHQgICAgICBpZiAoc3RyaW5nX21zZ190b2tlbikgcGFyYW1zWydzdHJpbmdfbWVzc2FnZV90b2tlbiddID0gJ3RydWUnO1xuXG5cdCAgICAgIC8vIFNlbmQgTWVzc2FnZVxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMocGFyYW1zKSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT0gJ29iamVjdCcgJiYgcmVzcG9uc2VbJ2Vycm9yJ10pIHtcblx0ICAgICAgICAgICAgZXJyKHsgbWVzc2FnZTogcmVzcG9uc2VbJ21lc3NhZ2UnXSwgcGF5bG9hZDogcmVzcG9uc2VbJ3BheWxvYWQnXSB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gcmVzcG9uc2VbMF07XG5cdCAgICAgICAgICB2YXIgZGVjcnlwdGVkX21lc3NhZ2VzID0gW107XG5cdCAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IG1lc3NhZ2VzLmxlbmd0aDsgYSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpbmNsdWRlX3Rva2VuKSB7XG5cdCAgICAgICAgICAgICAgdmFyIG5ld19tZXNzYWdlID0gZGVjcnlwdChtZXNzYWdlc1thXVsnbWVzc2FnZSddLCBjaXBoZXJfa2V5KTtcblx0ICAgICAgICAgICAgICB2YXIgdGltZXRva2VuID0gbWVzc2FnZXNbYV1bJ3RpbWV0b2tlbiddO1xuXHQgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBkZWNyeXB0ZWRfbWVzc2FnZXNbJ3B1c2gnXSh7IG1lc3NhZ2U6IEpTT05bJ3BhcnNlJ10obmV3X21lc3NhZ2UpLCB0aW1ldG9rZW46IHRpbWV0b2tlbiB9KTtcblx0ICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICBkZWNyeXB0ZWRfbWVzc2FnZXNbJ3B1c2gnXSgoeyBtZXNzYWdlOiBuZXdfbWVzc2FnZSwgdGltZXRva2VuOiB0aW1ldG9rZW4gfSkpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICB2YXIgbmV3X21lc3NhZ2UgPSBkZWNyeXB0KG1lc3NhZ2VzW2FdLCBjaXBoZXJfa2V5KTtcblx0ICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZGVjcnlwdGVkX21lc3NhZ2VzWydwdXNoJ10oSlNPTlsncGFyc2UnXShuZXdfbWVzc2FnZSkpO1xuXHQgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIGRlY3J5cHRlZF9tZXNzYWdlc1sncHVzaCddKChuZXdfbWVzc2FnZSkpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgY2FsbGJhY2soW2RlY3J5cHRlZF9tZXNzYWdlcywgcmVzcG9uc2VbMV0sIHJlc3BvbnNlWzJdXSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MicsICdoaXN0b3J5JywgJ3N1Yi1rZXknLFxuXHQgICAgICAgICAgU1VCU0NSSUJFX0tFWSwgJ2NoYW5uZWwnLCB1dGlscy5lbmNvZGUoY2hhbm5lbClcblx0ICAgICAgICBdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIucmVwbGF5KHtcblx0ICAgICBzb3VyY2UgICAgICA6ICdteV9jaGFubmVsJyxcblx0ICAgICBkZXN0aW5hdGlvbiA6ICduZXdfY2hhbm5lbCdcblx0ICAgICB9KTtcblx0ICAgICAqL1xuXHQgICAgcmVwbGF5OiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIHNvdXJjZSA9IGFyZ3NbJ3NvdXJjZSddO1xuXHQgICAgICB2YXIgZGVzdGluYXRpb24gPSBhcmdzWydkZXN0aW5hdGlvbiddO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgc3RvcCA9IGFyZ3NbJ3N0b3AnXTtcblx0ICAgICAgdmFyIHN0YXJ0ID0gYXJnc1snc3RhcnQnXTtcblx0ICAgICAgdmFyIGVuZCA9IGFyZ3NbJ2VuZCddO1xuXHQgICAgICB2YXIgcmV2ZXJzZSA9IGFyZ3NbJ3JldmVyc2UnXTtcblx0ICAgICAgdmFyIGxpbWl0ID0gYXJnc1snbGltaXQnXTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIGRhdGEgPSB7fTtcblx0ICAgICAgdmFyIHVybDtcblxuXHQgICAgICAvLyBDaGVjayBVc2VyIElucHV0XG5cdCAgICAgIGlmICghc291cmNlKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU291cmNlIENoYW5uZWwnKTtcblx0ICAgICAgaWYgKCFkZXN0aW5hdGlvbikgcmV0dXJuIGVycm9yKCdNaXNzaW5nIERlc3RpbmF0aW9uIENoYW5uZWwnKTtcblx0ICAgICAgaWYgKCFQVUJMSVNIX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFB1Ymxpc2ggS2V5Jyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICAvLyBTZXR1cCBVUkwgUGFyYW1zXG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgaWYgKHN0b3ApIGRhdGFbJ3N0b3AnXSA9ICdhbGwnO1xuXHQgICAgICBpZiAocmV2ZXJzZSkgZGF0YVsncmV2ZXJzZSddID0gJ3RydWUnO1xuXHQgICAgICBpZiAoc3RhcnQpIGRhdGFbJ3N0YXJ0J10gPSBzdGFydDtcblx0ICAgICAgaWYgKGVuZCkgZGF0YVsnZW5kJ10gPSBlbmQ7XG5cdCAgICAgIGlmIChsaW1pdCkgZGF0YVsnY291bnQnXSA9IGxpbWl0O1xuXG5cdCAgICAgIGRhdGFbJ2F1dGgnXSA9IGF1dGhfa2V5O1xuXG5cdCAgICAgIC8vIENvbXBvc2UgVVJMIFBhcnRzXG5cdCAgICAgIHVybCA9IFtcblx0ICAgICAgICBTVERfT1JJR0lOLCAndjEnLCAncmVwbGF5Jyxcblx0ICAgICAgICBQVUJMSVNIX0tFWSwgU1VCU0NSSUJFX0tFWSxcblx0ICAgICAgICBzb3VyY2UsIGRlc3RpbmF0aW9uXG5cdCAgICAgIF07XG5cblx0ICAgICAgLy8gU3RhcnQgKG9yIFN0b3ApIFJlcGxheSFcblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKFswLCAnRGlzY29ubmVjdGVkJ10pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiB1cmwsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuYXV0aCgnQUpGTEtBSlNES0xBJyk7XG5cdCAgICAgKi9cblx0ICAgIGF1dGg6IGZ1bmN0aW9uIChhdXRoKSB7XG5cdCAgICAgIEFVVEhfS0VZID0gYXV0aDtcblx0ICAgICAgQ09OTkVDVCgpO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIudGltZShmdW5jdGlvbih0aW1lKXsgfSk7XG5cdCAgICAgKi9cblx0ICAgIHRpbWU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBBVVRIX0tFWSB9O1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgdXJsOiBbU1REX09SSUdJTiwgJ3RpbWUnLCBqc29ucF0sXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZVswXSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBjYWxsYmFjaygwKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIucHVibGlzaCh7XG5cdCAgICAgY2hhbm5lbCA6ICdteV9jaGF0X2NoYW5uZWwnLFxuXHQgICAgIG1lc3NhZ2UgOiAnaGVsbG8hJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBwdWJsaXNoOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIG1zZyA9IGFyZ3NbJ21lc3NhZ2UnXTtcblx0ICAgICAgaWYgKCFtc2cpIHJldHVybiBlcnJvcignTWlzc2luZyBNZXNzYWdlJyk7XG5cblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXSB8fCBtc2dbJ2NhbGxiYWNrJ10gfHwgYXJnc1snc3VjY2VzcyddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXSB8fCBtc2dbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIG1ldGEgPSBhcmdzWydtZXRhJ10gfHwgYXJnc1snbWV0YWRhdGEnXTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIGNpcGhlcl9rZXkgPSBhcmdzWydjaXBoZXJfa2V5J107XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IG1zZ1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIHBvc3QgPSBhcmdzWydwb3N0J10gfHwgZmFsc2U7XG5cdCAgICAgIHZhciBzdG9yZSA9ICgnc3RvcmVfaW5faGlzdG9yeScgaW4gYXJncykgPyBhcmdzWydzdG9yZV9pbl9oaXN0b3J5J10gOiB0cnVlO1xuXHQgICAgICB2YXIgcmVwbGljYXRlID0gKCdyZXBsaWNhdGUnIGluIGFyZ3MpID8gYXJnc1sncmVwbGljYXRlJ10gOiB0cnVlO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgYWRkX21zZyA9ICdwdXNoJztcblx0ICAgICAgdmFyIHBhcmFtcztcblx0ICAgICAgdmFyIHVybDtcblxuXHQgICAgICBpZiAoYXJnc1sncHJlcGVuZCddKSBhZGRfbXNnID0gJ3Vuc2hpZnQnO1xuXG5cdCAgICAgIGlmICghY2hhbm5lbCkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblx0ICAgICAgaWYgKCFQVUJMSVNIX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFB1Ymxpc2ggS2V5Jyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICBpZiAobXNnWydnZXRQdWJudWJNZXNzYWdlJ10pIHtcblx0ICAgICAgICBtc2cgPSBtc2dbJ2dldFB1Ym51Yk1lc3NhZ2UnXSgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gSWYgdHJ5aW5nIHRvIHNlbmQgT2JqZWN0XG5cdCAgICAgIG1zZyA9IEpTT05bJ3N0cmluZ2lmeSddKGVuY3J5cHQobXNnLCBjaXBoZXJfa2V5KSk7XG5cblx0ICAgICAgLy8gQ3JlYXRlIFVSTFxuXHQgICAgICB1cmwgPSBbXG5cdCAgICAgICAgU1REX09SSUdJTiwgJ3B1Ymxpc2gnLFxuXHQgICAgICAgIFBVQkxJU0hfS0VZLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgIDAsIHV0aWxzLmVuY29kZShjaGFubmVsKSxcblx0ICAgICAgICBqc29ucCwgdXRpbHMuZW5jb2RlKG1zZylcblx0ICAgICAgXTtcblxuXHQgICAgICBwYXJhbXMgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IGF1dGhfa2V5IH07XG5cblx0ICAgICAgaWYgKG1ldGEgJiYgdHlwZW9mIG1ldGEgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgcGFyYW1zWydtZXRhJ10gPSBKU09OLnN0cmluZ2lmeShtZXRhKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghc3RvcmUpIHBhcmFtc1snc3RvcmUnXSA9ICcwJztcblx0ICAgICAgaWYgKCFyZXBsaWNhdGUpIHBhcmFtc1snbm9yZXAnXSA9ICd0cnVlJztcblxuXHQgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIHBhcmFtc1snaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICAvLyBRdWV1ZSBNZXNzYWdlIFNlbmRcblx0ICAgICAgUFVCX1FVRVVFW2FkZF9tc2ddKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgdXJsOiB1cmwsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKHBhcmFtcyksXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgICAgcHVibGlzaCgxKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgICBwdWJsaXNoKDEpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgbW9kZTogKHBvc3QpID8gJ1BPU1QnIDogJ0dFVCdcblx0ICAgICAgfSk7XG5cblx0ICAgICAgLy8gU2VuZCBNZXNzYWdlXG5cdCAgICAgIHB1Ymxpc2goKTtcblx0ICAgIH0sXG5cblx0ICAgIGZpcmU6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBhcmdzLnN0b3JlX2luX2hpc3RvcnkgPSBmYWxzZTtcblx0ICAgICAgYXJncy5yZXBsaWNhdGUgPSBmYWxzZTtcblx0ICAgICAgU0VMRlsncHVibGlzaCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLnVuc3Vic2NyaWJlKHsgY2hhbm5lbCA6ICdteV9jaGF0JyB9KTtcblx0ICAgICAqL1xuXHQgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2hhbm5lbEFyZyA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxHcm91cEFyZyA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cblx0ICAgICAgaWYgKCFjaGFubmVsQXJnICYmICFjaGFubmVsR3JvdXBBcmcpIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsIG9yIENoYW5uZWwgR3JvdXAnKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXG5cdCAgICAgIGlmIChjaGFubmVsQXJnKSB7XG5cdCAgICAgICAgdmFyIGNoYW5uZWxzID0gdXRpbHMuaXNBcnJheShjaGFubmVsQXJnKSA/IGNoYW5uZWxBcmcgOiAoJycgKyBjaGFubmVsQXJnKS5zcGxpdCgnLCcpO1xuXHQgICAgICAgIHZhciBleGlzdGluZ0NoYW5uZWxzID0gW107XG5cdCAgICAgICAgdmFyIHByZXNlbmNlQ2hhbm5lbHMgPSBbXTtcblxuXHQgICAgICAgIHV0aWxzLmVhY2goY2hhbm5lbHMsIGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgICBpZiAoQ0hBTk5FTFNbY2hhbm5lbF0pIGV4aXN0aW5nQ2hhbm5lbHMucHVzaChjaGFubmVsKTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIC8vIGlmIHdlIGRvIG5vdCBoYXZlIGFueSBjaGFubmVscyB0byB1bnN1YnNjcmliZSBmcm9tLCB0cmlnZ2VyIGEgY2FsbGJhY2suXG5cdCAgICAgICAgaWYgKGV4aXN0aW5nQ2hhbm5lbHMubGVuZ3RoID09IDApIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKHsgYWN0aW9uOiAnbGVhdmUnIH0pO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFByZXBhcmUgcHJlc2VuY2UgY2hhbm5lbHNcblx0ICAgICAgICB1dGlscy5lYWNoKGV4aXN0aW5nQ2hhbm5lbHMsIGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgICBwcmVzZW5jZUNoYW5uZWxzLnB1c2goY2hhbm5lbCArIFBSRVNFTkNFX1NVRkZJWCk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICB1dGlscy5lYWNoKGV4aXN0aW5nQ2hhbm5lbHMuY29uY2F0KHByZXNlbmNlQ2hhbm5lbHMpLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgaWYgKGNoYW5uZWwgaW4gQ0hBTk5FTFMpIGRlbGV0ZSBDSEFOTkVMU1tjaGFubmVsXTtcblx0ICAgICAgICAgIGlmIChjaGFubmVsIGluIFNUQVRFKSBkZWxldGUgU1RBVEVbY2hhbm5lbF07XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBpZiAoQ0hBTk5FTFMubGVuZ3RoID09PSAwICYmIENIQU5ORUxfR1JPVVBTLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgVElNRVRPS0VOID0gMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgQ0JfQ0FMTEVEID0gdHJ1ZTtcblx0ICAgICAgICBpZiAoUkVBRFkpIHtcblx0ICAgICAgICAgIENCX0NBTExFRCA9IFNFTEZbJ0xFQVZFJ10oZXhpc3RpbmdDaGFubmVscy5qb2luKCcsJyksIDAsIGF1dGhfa2V5LCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFDQl9DQUxMRUQpIGNhbGxiYWNrKHsgYWN0aW9uOiAnbGVhdmUnIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGNoYW5uZWxHcm91cEFyZykge1xuXHQgICAgICAgIHZhciBjaGFubmVsR3JvdXBzID0gdXRpbHMuaXNBcnJheShjaGFubmVsR3JvdXBBcmcpID8gY2hhbm5lbEdyb3VwQXJnIDogKCcnICsgY2hhbm5lbEdyb3VwQXJnKS5zcGxpdCgnLCcpO1xuXHQgICAgICAgIHZhciBleGlzdGluZ0NoYW5uZWxHcm91cHMgPSBbXTtcblx0ICAgICAgICB2YXIgcHJlc2VuY2VDaGFubmVsR3JvdXBzID0gW107XG5cblx0ICAgICAgICB1dGlscy5lYWNoKGNoYW5uZWxHcm91cHMsIGZ1bmN0aW9uIChjaGFubmVsR3JvdXApIHtcblx0ICAgICAgICAgIGlmIChDSEFOTkVMX0dST1VQU1tjaGFubmVsR3JvdXBdKSBleGlzdGluZ0NoYW5uZWxHcm91cHMucHVzaChjaGFubmVsR3JvdXApO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLy8gaWYgd2UgZG8gbm90IGhhdmUgYW55IGNoYW5uZWwgZ3JvdXBzIHRvIHVuc3Vic2NyaWJlIGZyb20sIHRyaWdnZXIgYSBjYWxsYmFjay5cblx0ICAgICAgICBpZiAoZXhpc3RpbmdDaGFubmVsR3JvdXBzLmxlbmd0aCA9PSAwKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayh7IGFjdGlvbjogJ2xlYXZlJyB9KTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBQcmVwYXJlIHByZXNlbmNlIGNoYW5uZWxzXG5cdCAgICAgICAgdXRpbHMuZWFjaChleGlzdGluZ0NoYW5uZWxHcm91cHMsIGZ1bmN0aW9uIChjaGFubmVsR3JvdXApIHtcblx0ICAgICAgICAgIHByZXNlbmNlQ2hhbm5lbEdyb3Vwcy5wdXNoKGNoYW5uZWxHcm91cCArIFBSRVNFTkNFX1NVRkZJWCk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICB1dGlscy5lYWNoKGV4aXN0aW5nQ2hhbm5lbEdyb3Vwcy5jb25jYXQocHJlc2VuY2VDaGFubmVsR3JvdXBzKSwgZnVuY3Rpb24gKGNoYW5uZWxHcm91cCkge1xuXHQgICAgICAgICAgaWYgKGNoYW5uZWxHcm91cCBpbiBDSEFOTkVMX0dST1VQUykgZGVsZXRlIENIQU5ORUxfR1JPVVBTW2NoYW5uZWxHcm91cF07XG5cdCAgICAgICAgICBpZiAoY2hhbm5lbEdyb3VwIGluIFNUQVRFKSBkZWxldGUgU1RBVEVbY2hhbm5lbEdyb3VwXTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGlmIChDSEFOTkVMUy5sZW5ndGggPT09IDAgJiYgQ0hBTk5FTF9HUk9VUFMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICBUSU1FVE9LRU4gPSAwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBDQl9DQUxMRUQgPSB0cnVlO1xuXHQgICAgICAgIGlmIChSRUFEWSkge1xuXHQgICAgICAgICAgQ0JfQ0FMTEVEID0gU0VMRlsnTEVBVkVfR1JPVVAnXShleGlzdGluZ0NoYW5uZWxHcm91cHMuam9pbignLCcpLCAwLCBhdXRoX2tleSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghQ0JfQ0FMTEVEKSBjYWxsYmFjayh7IGFjdGlvbjogJ2xlYXZlJyB9KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIFJlc2V0IENvbm5lY3Rpb24gaWYgQ291bnQgTGVzc1xuXHQgICAgICBDT05ORUNUKCk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5zdWJzY3JpYmUoe1xuXHQgICAgIGNoYW5uZWwgIDogJ215X2NoYXQnXG5cdCAgICAgY2FsbGJhY2sgOiBmdW5jdGlvbihtZXNzYWdlKSB7IH1cblx0ICAgICB9KTtcblx0ICAgICAqL1xuXHQgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwID0gYXJnc1snY2hhbm5lbF9ncm91cCddO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBhcmdzWydjYWxsYmFjayddO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBhcmdzWydtZXNzYWdlJ107XG5cdCAgICAgIHZhciBjb25uZWN0ID0gYXJnc1snY29ubmVjdCddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgcmVjb25uZWN0ID0gYXJnc1sncmVjb25uZWN0J10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBkaXNjb25uZWN0ID0gYXJnc1snZGlzY29ubmVjdCddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgU1VCX0VSUk9SID0gYXJnc1snZXJyb3InXSB8fCBTVUJfRVJST1IgfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBpZGxlY2IgPSBhcmdzWydpZGxlJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBwcmVzZW5jZSA9IGFyZ3NbJ3ByZXNlbmNlJ10gfHwgMDtcblx0ICAgICAgdmFyIG5vaGVyZXN5bmMgPSBhcmdzWydub2hlcmVzeW5jJ10gfHwgMDtcblx0ICAgICAgdmFyIGJhY2tmaWxsID0gYXJnc1snYmFja2ZpbGwnXSB8fCAwO1xuXHQgICAgICB2YXIgdGltZXRva2VuID0gYXJnc1sndGltZXRva2VuJ10gfHwgMDtcblx0ICAgICAgdmFyIHN1Yl90aW1lb3V0ID0gYXJnc1sndGltZW91dCddIHx8IFNVQl9USU1FT1VUO1xuXHQgICAgICB2YXIgd2luZG93aW5nID0gYXJnc1snd2luZG93aW5nJ10gfHwgU1VCX1dJTkRPV0lORztcblx0ICAgICAgdmFyIHN0YXRlID0gYXJnc1snc3RhdGUnXTtcblx0ICAgICAgdmFyIGhlYXJ0YmVhdCA9IGFyZ3NbJ2hlYXJ0YmVhdCddIHx8IGFyZ3NbJ3BuZXhwaXJlcyddO1xuXHQgICAgICB2YXIgaGVhcnRiZWF0X2ludGVydmFsID0gYXJnc1snaGVhcnRiZWF0X2ludGVydmFsJ107XG5cdCAgICAgIHZhciByZXN0b3JlID0gYXJnc1sncmVzdG9yZSddIHx8IFNVQl9SRVNUT1JFO1xuXG5cdCAgICAgIEFVVEhfS0VZID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblxuXHQgICAgICAvLyBSZXN0b3JlIEVuYWJsZWQ/XG5cdCAgICAgIFNVQl9SRVNUT1JFID0gcmVzdG9yZTtcblxuXHQgICAgICAvLyBBbHdheXMgUmVzZXQgdGhlIFRUXG5cdCAgICAgIFRJTUVUT0tFTiA9IHRpbWV0b2tlbjtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFjaGFubmVsICYmICFjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgaWYgKGhlYXJ0YmVhdCB8fCBoZWFydGJlYXQgPT09IDAgfHwgaGVhcnRiZWF0X2ludGVydmFsIHx8IGhlYXJ0YmVhdF9pbnRlcnZhbCA9PT0gMCkge1xuXHQgICAgICAgIFNFTEZbJ3NldF9oZWFydGJlYXQnXShoZWFydGJlYXQsIGhlYXJ0YmVhdF9pbnRlcnZhbCk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBTZXR1cCBDaGFubmVsKHMpXG5cdCAgICAgIGlmIChjaGFubmVsKSB7XG5cdCAgICAgICAgdXRpbHMuZWFjaCgoY2hhbm5lbC5qb2luID8gY2hhbm5lbC5qb2luKCcsJykgOiAnJyArIGNoYW5uZWwpLnNwbGl0KCcsJyksXG5cdCAgICAgICAgICBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBDSEFOTkVMU1tjaGFubmVsXSB8fCB7fTtcblxuXHQgICAgICAgICAgICAvLyBTdG9yZSBDaGFubmVsIFN0YXRlXG5cdCAgICAgICAgICAgIENIQU5ORUxTW1NVQl9DSEFOTkVMID0gY2hhbm5lbF0gPSB7XG5cdCAgICAgICAgICAgICAgbmFtZTogY2hhbm5lbCxcblx0ICAgICAgICAgICAgICBjb25uZWN0ZWQ6IHNldHRpbmdzLmNvbm5lY3RlZCxcblx0ICAgICAgICAgICAgICBkaXNjb25uZWN0ZWQ6IHNldHRpbmdzLmRpc2Nvbm5lY3RlZCxcblx0ICAgICAgICAgICAgICBzdWJzY3JpYmVkOiAxLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBTVUJfQ0FMTEJBQ0sgPSBjYWxsYmFjayxcblx0ICAgICAgICAgICAgICBjaXBoZXJfa2V5OiBhcmdzWydjaXBoZXJfa2V5J10sXG5cdCAgICAgICAgICAgICAgY29ubmVjdDogY29ubmVjdCxcblx0ICAgICAgICAgICAgICBkaXNjb25uZWN0OiBkaXNjb25uZWN0LFxuXHQgICAgICAgICAgICAgIHJlY29ubmVjdDogcmVjb25uZWN0XG5cdCAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgaWYgKGNoYW5uZWwgaW4gc3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgIFNUQVRFW2NoYW5uZWxdID0gc3RhdGVbY2hhbm5lbF07XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIFNUQVRFW2NoYW5uZWxdID0gc3RhdGU7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUHJlc2VuY2UgRW5hYmxlZD9cblx0ICAgICAgICAgICAgaWYgKCFwcmVzZW5jZSkgcmV0dXJuO1xuXG5cdCAgICAgICAgICAgIC8vIFN1YnNjcmliZSBQcmVzZW5jZSBDaGFubmVsXG5cdCAgICAgICAgICAgIFNFTEZbJ3N1YnNjcmliZSddKHtcblx0ICAgICAgICAgICAgICBjaGFubmVsOiBjaGFubmVsICsgUFJFU0VOQ0VfU1VGRklYLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBwcmVzZW5jZSxcblx0ICAgICAgICAgICAgICByZXN0b3JlOiByZXN0b3JlXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIC8vIFByZXNlbmNlIFN1YnNjcmliZWQ/XG5cdCAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zdWJzY3JpYmVkKSByZXR1cm47XG5cblx0ICAgICAgICAgICAgLy8gU2VlIFdobydzIEhlcmUgTm93P1xuXHQgICAgICAgICAgICBpZiAobm9oZXJlc3luYykgcmV0dXJuO1xuXHQgICAgICAgICAgICBTRUxGWydoZXJlX25vdyddKHtcblx0ICAgICAgICAgICAgICBjaGFubmVsOiBjaGFubmVsLFxuXHQgICAgICAgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyh7IHV1aWQ6IFVVSUQsIGF1dGg6IEFVVEhfS0VZIH0pLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoaGVyZSkge1xuXHQgICAgICAgICAgICAgICAgdXRpbHMuZWFjaCgndXVpZHMnIGluIGhlcmUgPyBoZXJlWyd1dWlkcyddIDogW10sIGZ1bmN0aW9uICh1aWQpIHtcblx0ICAgICAgICAgICAgICAgICAgcHJlc2VuY2Uoe1xuXHQgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2pvaW4nLFxuXHQgICAgICAgICAgICAgICAgICAgIHV1aWQ6IHVpZCxcblx0ICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IE1hdGguZmxvb3IodXRpbHMucm5vdygpIC8gMTAwMCksXG5cdCAgICAgICAgICAgICAgICAgICAgb2NjdXBhbmN5OiBoZXJlWydvY2N1cGFuY3knXSB8fCAxXG5cdCAgICAgICAgICAgICAgICAgIH0sIGhlcmUsIGNoYW5uZWwpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gU2V0dXAgQ2hhbm5lbCBHcm91cHNcblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgICB1dGlscy5lYWNoKChjaGFubmVsX2dyb3VwLmpvaW4gPyBjaGFubmVsX2dyb3VwLmpvaW4oJywnKSA6ICcnICsgY2hhbm5lbF9ncm91cCkuc3BsaXQoJywnKSxcblx0ICAgICAgICAgIGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdIHx8IHt9O1xuXG5cdCAgICAgICAgICAgIENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdID0ge1xuXHQgICAgICAgICAgICAgIG5hbWU6IGNoYW5uZWxfZ3JvdXAsXG5cdCAgICAgICAgICAgICAgY29ubmVjdGVkOiBzZXR0aW5ncy5jb25uZWN0ZWQsXG5cdCAgICAgICAgICAgICAgZGlzY29ubmVjdGVkOiBzZXR0aW5ncy5kaXNjb25uZWN0ZWQsXG5cdCAgICAgICAgICAgICAgc3Vic2NyaWJlZDogMSxcblx0ICAgICAgICAgICAgICBjYWxsYmFjazogU1VCX0NBTExCQUNLID0gY2FsbGJhY2ssXG5cdCAgICAgICAgICAgICAgY2lwaGVyX2tleTogYXJnc1snY2lwaGVyX2tleSddLFxuXHQgICAgICAgICAgICAgIGNvbm5lY3Q6IGNvbm5lY3QsXG5cdCAgICAgICAgICAgICAgZGlzY29ubmVjdDogZGlzY29ubmVjdCxcblx0ICAgICAgICAgICAgICByZWNvbm5lY3Q6IHJlY29ubmVjdFxuXHQgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIC8vIFByZXNlbmNlIEVuYWJsZWQ/XG5cdCAgICAgICAgICAgIGlmICghcHJlc2VuY2UpIHJldHVybjtcblxuXHQgICAgICAgICAgICAvLyBTdWJzY3JpYmUgUHJlc2VuY2UgQ2hhbm5lbFxuXHQgICAgICAgICAgICBTRUxGWydzdWJzY3JpYmUnXSh7XG5cdCAgICAgICAgICAgICAgY2hhbm5lbF9ncm91cDogY2hhbm5lbF9ncm91cCArIFBSRVNFTkNFX1NVRkZJWCxcblx0ICAgICAgICAgICAgICBjYWxsYmFjazogcHJlc2VuY2UsXG5cdCAgICAgICAgICAgICAgcmVzdG9yZTogcmVzdG9yZSxcblx0ICAgICAgICAgICAgICBhdXRoX2tleTogQVVUSF9LRVlcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgLy8gUHJlc2VuY2UgU3Vic2NyaWJlZD9cblx0ICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN1YnNjcmliZWQpIHJldHVybjtcblxuXHQgICAgICAgICAgICAvLyBTZWUgV2hvJ3MgSGVyZSBOb3c/XG5cdCAgICAgICAgICAgIGlmIChub2hlcmVzeW5jKSByZXR1cm47XG5cdCAgICAgICAgICAgIFNFTEZbJ2hlcmVfbm93J10oe1xuXHQgICAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXA6IGNoYW5uZWxfZ3JvdXAsXG5cdCAgICAgICAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKHsgdXVpZDogVVVJRCwgYXV0aDogQVVUSF9LRVkgfSksXG5cdCAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChoZXJlKSB7XG5cdCAgICAgICAgICAgICAgICB1dGlscy5lYWNoKCd1dWlkcycgaW4gaGVyZSA/IGhlcmVbJ3V1aWRzJ10gOiBbXSwgZnVuY3Rpb24gKHVpZCkge1xuXHQgICAgICAgICAgICAgICAgICBwcmVzZW5jZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnam9pbicsXG5cdCAgICAgICAgICAgICAgICAgICAgdXVpZDogdWlkLFxuXHQgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogTWF0aC5mbG9vcih1dGlscy5ybm93KCkgLyAxMDAwKSxcblx0ICAgICAgICAgICAgICAgICAgICBvY2N1cGFuY3k6IGhlcmVbJ29jY3VwYW5jeSddIHx8IDFcblx0ICAgICAgICAgICAgICAgICAgfSwgaGVyZSwgY2hhbm5lbF9ncm91cCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXG5cdCAgICAgIC8vIFRlc3QgTmV0d29yayBDb25uZWN0aW9uXG5cdCAgICAgIGZ1bmN0aW9uIF90ZXN0X2Nvbm5lY3Rpb24oc3VjY2Vzcykge1xuXHQgICAgICAgIGlmIChzdWNjZXNzKSB7XG5cdCAgICAgICAgICAvLyBCZWdpbiBOZXh0IFNvY2tldCBDb25uZWN0aW9uXG5cdCAgICAgICAgICB1dGlscy50aW1lb3V0KENPTk5FQ1QsIHdpbmRvd2luZyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIE5ldyBPcmlnaW4gb24gRmFpbGVkIENvbm5lY3Rpb25cblx0ICAgICAgICAgIFNURF9PUklHSU4gPSBuZXh0b3JpZ2luKE9SSUdJTiwgMSk7XG5cdCAgICAgICAgICBTVUJfT1JJR0lOID0gbmV4dG9yaWdpbihPUklHSU4sIDEpO1xuXG5cdCAgICAgICAgICAvLyBSZS10ZXN0IENvbm5lY3Rpb25cblx0ICAgICAgICAgIHV0aWxzLnRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBTRUxGWyd0aW1lJ10oX3Rlc3RfY29ubmVjdGlvbik7XG5cdCAgICAgICAgICB9LCBTRUNPTkQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIERpc2Nvbm5lY3QgJiBSZWNvbm5lY3Rcblx0ICAgICAgICBlYWNoX2NoYW5uZWwoZnVuY3Rpb24gKGNoYW5uZWwpIHtcblx0ICAgICAgICAgIC8vIFJlY29ubmVjdFxuXHQgICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgY2hhbm5lbC5kaXNjb25uZWN0ZWQpIHtcblx0ICAgICAgICAgICAgY2hhbm5lbC5kaXNjb25uZWN0ZWQgPSAwO1xuXHQgICAgICAgICAgICByZXR1cm4gY2hhbm5lbC5yZWNvbm5lY3QoY2hhbm5lbC5uYW1lKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgLy8gRGlzY29ubmVjdFxuXHQgICAgICAgICAgaWYgKCFzdWNjZXNzICYmICFjaGFubmVsLmRpc2Nvbm5lY3RlZCkge1xuXHQgICAgICAgICAgICBjaGFubmVsLmRpc2Nvbm5lY3RlZCA9IDE7XG5cdCAgICAgICAgICAgIGNoYW5uZWwuZGlzY29ubmVjdChjaGFubmVsLm5hbWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLy8gRGlzY29ubmVjdCAmIFJlY29ubmVjdCBmb3IgY2hhbm5lbCBncm91cHNcblx0ICAgICAgICBlYWNoX2NoYW5uZWxfZ3JvdXAoZnVuY3Rpb24gKGNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgICAgIC8vIFJlY29ubmVjdFxuXHQgICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgY2hhbm5lbF9ncm91cC5kaXNjb25uZWN0ZWQpIHtcblx0ICAgICAgICAgICAgY2hhbm5lbF9ncm91cC5kaXNjb25uZWN0ZWQgPSAwO1xuXHQgICAgICAgICAgICByZXR1cm4gY2hhbm5lbF9ncm91cC5yZWNvbm5lY3QoY2hhbm5lbF9ncm91cC5uYW1lKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgLy8gRGlzY29ubmVjdFxuXHQgICAgICAgICAgaWYgKCFzdWNjZXNzICYmICFjaGFubmVsX2dyb3VwLmRpc2Nvbm5lY3RlZCkge1xuXHQgICAgICAgICAgICBjaGFubmVsX2dyb3VwLmRpc2Nvbm5lY3RlZCA9IDE7XG5cdCAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXAuZGlzY29ubmVjdChjaGFubmVsX2dyb3VwLm5hbWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gRXZlbnRlZCBTdWJzY3JpYmVcblx0ICAgICAgZnVuY3Rpb24gX2Nvbm5lY3QoKSB7XG5cdCAgICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgICB2YXIgY2hhbm5lbHMgPSBnZW5lcmF0ZV9jaGFubmVsX2xpc3QoQ0hBTk5FTFMpLmpvaW4oJywnKTtcblx0ICAgICAgICB2YXIgY2hhbm5lbF9ncm91cHMgPSBnZW5lcmF0ZV9jaGFubmVsX2dyb3VwX2xpc3QoQ0hBTk5FTF9HUk9VUFMpLmpvaW4oJywnKTtcblxuXHQgICAgICAgIC8vIFN0b3AgQ29ubmVjdGlvblxuXHQgICAgICAgIGlmICghY2hhbm5lbHMgJiYgIWNoYW5uZWxfZ3JvdXBzKSByZXR1cm47XG5cblx0ICAgICAgICBpZiAoIWNoYW5uZWxzKSBjaGFubmVscyA9ICcsJztcblxuXHQgICAgICAgIC8vIENvbm5lY3QgdG8gUHViTnViIFN1YnNjcmliZSBTZXJ2ZXJzXG5cdCAgICAgICAgX3Jlc2V0X29mZmxpbmUoKTtcblxuXHQgICAgICAgIHZhciBkYXRhID0gX2dldF91cmxfcGFyYW1zKHsgdXVpZDogVVVJRCwgYXV0aDogQVVUSF9LRVkgfSk7XG5cblx0ICAgICAgICBpZiAoY2hhbm5lbF9ncm91cHMpIHtcblx0ICAgICAgICAgIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXBzO1xuXHQgICAgICAgIH1cblxuXG5cdCAgICAgICAgdmFyIHN0ID0gSlNPTi5zdHJpbmdpZnkoU1RBVEUpO1xuXHQgICAgICAgIGlmIChzdC5sZW5ndGggPiAyKSBkYXRhWydzdGF0ZSddID0gSlNPTi5zdHJpbmdpZnkoU1RBVEUpO1xuXG5cdCAgICAgICAgaWYgKFBSRVNFTkNFX0hCKSBkYXRhWydoZWFydGJlYXQnXSA9IFBSRVNFTkNFX0hCO1xuXG5cdCAgICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgICAgc3RhcnRfcHJlc2VuY2VfaGVhcnRiZWF0KCk7XG5cdCAgICAgICAgU1VCX1JFQ0VJVkVSID0geGRyKHtcblx0ICAgICAgICAgIHRpbWVvdXQ6IHN1Yl90aW1lb3V0LFxuXHQgICAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZVsnZXJyb3InXSAmJiByZXNwb25zZVsnc2VydmljZSddKSB7XG5cdCAgICAgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgU1VCX0VSUk9SKTtcblx0ICAgICAgICAgICAgICBfdGVzdF9jb25uZWN0aW9uKGZhbHNlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBTRUxGWyd0aW1lJ10oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcblx0ICAgICAgICAgICAgICAgICFzdWNjZXNzICYmIChfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBTVUJfRVJST1IpKTtcblx0ICAgICAgICAgICAgICAgIF90ZXN0X2Nvbm5lY3Rpb24oc3VjY2Vzcyk7XG5cdCAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgICAgU1VCX09SSUdJTiwgJ3N1YnNjcmliZScsXG5cdCAgICAgICAgICAgIFNVQlNDUklCRV9LRVksIHV0aWxzLmVuY29kZShjaGFubmVscyksXG5cdCAgICAgICAgICAgIGpzb25wLCBUSU1FVE9LRU5cblx0ICAgICAgICAgIF0sXG5cdCAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAobWVzc2FnZXMpIHtcblx0ICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEVycm9yc1xuXHQgICAgICAgICAgICBpZiAoIW1lc3NhZ2VzIHx8ICh0eXBlb2YgbWVzc2FnZXMgPT0gJ29iamVjdCcgJiYgJ2Vycm9yJyBpbiBtZXNzYWdlcyAmJiBtZXNzYWdlc1snZXJyb3InXSkpIHtcblx0ICAgICAgICAgICAgICBTVUJfRVJST1IobWVzc2FnZXMpO1xuXHQgICAgICAgICAgICAgIHJldHVybiB1dGlscy50aW1lb3V0KENPTk5FQ1QsIFNFQ09ORCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBVc2VyIElkbGUgQ2FsbGJhY2tcblx0ICAgICAgICAgICAgaWRsZWNiKG1lc3NhZ2VzWzFdKTtcblxuXHQgICAgICAgICAgICAvLyBSZXN0b3JlIFByZXZpb3VzIENvbm5lY3Rpb24gUG9pbnQgaWYgTmVlZGVkXG5cdCAgICAgICAgICAgIFRJTUVUT0tFTiA9ICFUSU1FVE9LRU4gJiYgU1VCX1JFU1RPUkUgJiYgZGJbJ2dldCddKFNVQlNDUklCRV9LRVkpIHx8IG1lc3NhZ2VzWzFdO1xuXG5cdCAgICAgICAgICAgIC8qXG5cdCAgICAgICAgICAgICAvLyBDb25uZWN0XG5cdCAgICAgICAgICAgICBlYWNoX2NoYW5uZWxfcmVnaXN0cnkoZnVuY3Rpb24ocmVnaXN0cnkpe1xuXHQgICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5LmNvbm5lY3RlZCkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgcmVnaXN0cnkuY29ubmVjdGVkID0gMTtcblx0ICAgICAgICAgICAgIHJlZ2lzdHJ5LmNvbm5lY3QoY2hhbm5lbC5uYW1lKTtcblx0ICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblxuXHQgICAgICAgICAgICAvLyBDb25uZWN0XG5cdCAgICAgICAgICAgIGVhY2hfY2hhbm5lbChmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgICAgIGlmIChjaGFubmVsLmNvbm5lY3RlZCkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgIGNoYW5uZWwuY29ubmVjdGVkID0gMTtcblx0ICAgICAgICAgICAgICBjaGFubmVsLmNvbm5lY3QoY2hhbm5lbC5uYW1lKTtcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgLy8gQ29ubmVjdCBmb3IgY2hhbm5lbCBncm91cHNcblx0ICAgICAgICAgICAgZWFjaF9jaGFubmVsX2dyb3VwKGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgICAgICAgaWYgKGNoYW5uZWxfZ3JvdXAuY29ubmVjdGVkKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgY2hhbm5lbF9ncm91cC5jb25uZWN0ZWQgPSAxO1xuXHQgICAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXAuY29ubmVjdChjaGFubmVsX2dyb3VwLm5hbWUpO1xuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBpZiAoUkVTVU1FRCAmJiAhU1VCX1JFU1RPUkUpIHtcblx0ICAgICAgICAgICAgICBUSU1FVE9LRU4gPSAwO1xuXHQgICAgICAgICAgICAgIFJFU1VNRUQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAvLyBVcGRhdGUgU2F2ZWQgVGltZXRva2VuXG5cdCAgICAgICAgICAgICAgZGJbJ3NldCddKFNVQlNDUklCRV9LRVksIDApO1xuXHQgICAgICAgICAgICAgIHV0aWxzLnRpbWVvdXQoX2Nvbm5lY3QsIHdpbmRvd2luZyk7XG5cdCAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW52b2tlIE1lbW9yeSBDYXRjaHVwIGFuZCBSZWNlaXZlIFVwIHRvIDEwMFxuXHQgICAgICAgICAgICAvLyBQcmV2aW91cyBNZXNzYWdlcyBmcm9tIHRoZSBRdWV1ZS5cblx0ICAgICAgICAgICAgaWYgKGJhY2tmaWxsKSB7XG5cdCAgICAgICAgICAgICAgVElNRVRPS0VOID0gMTAwMDA7XG5cdCAgICAgICAgICAgICAgYmFja2ZpbGwgPSAwO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gVXBkYXRlIFNhdmVkIFRpbWV0b2tlblxuXHQgICAgICAgICAgICBkYlsnc2V0J10oU1VCU0NSSUJFX0tFWSwgbWVzc2FnZXNbMV0pO1xuXG5cdCAgICAgICAgICAgIC8vIFJvdXRlIENoYW5uZWwgPC0tLT4gQ2FsbGJhY2sgZm9yIE1lc3NhZ2Vcblx0ICAgICAgICAgICAgdmFyIG5leHRfY2FsbGJhY2sgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgIHZhciBjaGFubmVscyA9ICcnO1xuXHQgICAgICAgICAgICAgIHZhciBjaGFubmVsczIgPSAnJztcblxuXHQgICAgICAgICAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPiAzKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFubmVscyA9IG1lc3NhZ2VzWzNdO1xuXHQgICAgICAgICAgICAgICAgY2hhbm5lbHMyID0gbWVzc2FnZXNbMl07XG5cdCAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlcy5sZW5ndGggPiAyKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFubmVscyA9IG1lc3NhZ2VzWzJdO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBjaGFubmVscyA9IHV0aWxzLm1hcChcblx0ICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTKSwgZnVuY3Rpb24gKGNoYW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMubWFwKFxuXHQgICAgICAgICAgICAgICAgICAgICAgQXJyYXkobWVzc2FnZXNbMF0ubGVuZ3RoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCcpLnNwbGl0KCcsJyksXG5cdCAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJywnKTtcblx0ICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICB2YXIgbGlzdCA9IGNoYW5uZWxzLnNwbGl0KCcsJyk7XG5cdCAgICAgICAgICAgICAgdmFyIGxpc3QyID0gKGNoYW5uZWxzMikgPyBjaGFubmVsczIuc3BsaXQoJywnKSA6IFtdO1xuXG5cdCAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gbGlzdC5zaGlmdCgpIHx8IFNVQl9DSEFOTkVMO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwyID0gbGlzdDIuc2hpZnQoKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIGNob2JqID0ge307XG5cblx0ICAgICAgICAgICAgICAgIGlmIChjaGFubmVsMikge1xuXHQgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbCAmJiBjaGFubmVsLmluZGV4T2YoJy1wbnByZXMnKSA+PSAwXG5cdCAgICAgICAgICAgICAgICAgICAgJiYgY2hhbm5lbDIuaW5kZXhPZignLXBucHJlcycpIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwyICs9ICctcG5wcmVzJztcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICBjaG9iaiA9IENIQU5ORUxfR1JPVVBTW2NoYW5uZWwyXSB8fCBDSEFOTkVMU1tjaGFubmVsMl0gfHwgeyBjYWxsYmFjazogZnVuY3Rpb24gKCkge30gfTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgIGNob2JqID0gQ0hBTk5FTFNbY2hhbm5lbF07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciByID0gW1xuXHQgICAgICAgICAgICAgICAgICBjaG9ialxuXHQgICAgICAgICAgICAgICAgICAgIC5jYWxsYmFjayB8fCBTVUJfQ0FMTEJBQ0ssXG5cdCAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3BsaXQoUFJFU0VOQ0VfU1VGRklYKVswXVxuXHQgICAgICAgICAgICAgICAgXTtcblx0ICAgICAgICAgICAgICAgIGNoYW5uZWwyICYmIHIucHVzaChjaGFubmVsMi5zcGxpdChQUkVTRU5DRV9TVUZGSVgpWzBdKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByO1xuXHQgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pKCk7XG5cblx0ICAgICAgICAgICAgdmFyIGxhdGVuY3kgPSBkZXRlY3RfbGF0ZW5jeSgrbWVzc2FnZXNbMV0pO1xuXHQgICAgICAgICAgICB1dGlscy5lYWNoKG1lc3NhZ2VzWzBdLCBmdW5jdGlvbiAobXNnKSB7XG5cdCAgICAgICAgICAgICAgdmFyIG5leHQgPSBuZXh0X2NhbGxiYWNrKCk7XG5cdCAgICAgICAgICAgICAgdmFyIGRlY3J5cHRlZF9tc2cgPSBkZWNyeXB0KG1zZyxcblx0ICAgICAgICAgICAgICAgIChDSEFOTkVMU1tuZXh0WzFdXSkgPyBDSEFOTkVMU1tuZXh0WzFdXVsnY2lwaGVyX2tleSddIDogbnVsbCk7XG5cdCAgICAgICAgICAgICAgbmV4dFswXSAmJiBuZXh0WzBdKGRlY3J5cHRlZF9tc2csIG1lc3NhZ2VzLCBuZXh0WzJdIHx8IG5leHRbMV0sIGxhdGVuY3ksIG5leHRbMV0pO1xuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICB1dGlscy50aW1lb3V0KF9jb25uZWN0LCB3aW5kb3dpbmcpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgQ09OTkVDVCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBfcmVzZXRfb2ZmbGluZSgpO1xuXHQgICAgICAgIHV0aWxzLnRpbWVvdXQoX2Nvbm5lY3QsIHdpbmRvd2luZyk7XG5cdCAgICAgIH07XG5cblx0ICAgICAgLy8gUmVkdWNlIFN0YXR1cyBGbGlja2VyXG5cdCAgICAgIGlmICghUkVBRFkpIHJldHVybiBSRUFEWV9CVUZGRVIucHVzaChDT05ORUNUKTtcblxuXHQgICAgICAvLyBDb25uZWN0IE5vd1xuXHQgICAgICBDT05ORUNUKCk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5oZXJlX25vdyh7IGNoYW5uZWwgOiAnbXlfY2hhdCcsIGNhbGxiYWNrIDogZnVuIH0pO1xuXHQgICAgICovXG5cdCAgICBoZXJlX25vdzogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBkZWJ1ZyA9IGFyZ3NbJ2RlYnVnJ107XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciB1dWlkcyA9ICgndXVpZHMnIGluIGFyZ3MpID8gYXJnc1sndXVpZHMnXSA6IHRydWU7XG5cdCAgICAgIHZhciBzdGF0ZSA9IGFyZ3NbJ3N0YXRlJ107XG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBhdXRoX2tleSB9O1xuXG5cdCAgICAgIGlmICghdXVpZHMpIGRhdGFbJ2Rpc2FibGVfdXVpZHMnXSA9IDE7XG5cdCAgICAgIGlmIChzdGF0ZSkgZGF0YVsnc3RhdGUnXSA9IDE7XG5cblx0ICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBDaGFubmVsXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgdmFyIHVybCA9IFtcblx0ICAgICAgICBTVERfT1JJR0lOLCAndjInLCAncHJlc2VuY2UnLFxuXHQgICAgICAgICdzdWJfa2V5JywgU1VCU0NSSUJFX0tFWVxuXHQgICAgICBdO1xuXG5cdCAgICAgIGNoYW5uZWwgJiYgdXJsLnB1c2goJ2NoYW5uZWwnKSAmJiB1cmwucHVzaCh1dGlscy5lbmNvZGUoY2hhbm5lbCkpO1xuXG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIHtcblx0ICAgICAgICBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cCkge1xuXHQgICAgICAgIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXA7XG5cdCAgICAgICAgIWNoYW5uZWwgJiYgdXJsLnB1c2goJ2NoYW5uZWwnKSAmJiB1cmwucHVzaCgnLCcpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZGVidWc6IGRlYnVnLFxuXHQgICAgICAgIHVybDogdXJsXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuY3VycmVudF9jaGFubmVsc19ieV91dWlkKHsgY2hhbm5lbCA6ICdteV9jaGF0JywgY2FsbGJhY2sgOiBmdW4gfSk7XG5cdCAgICAgKi9cblx0ICAgIHdoZXJlX25vdzogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgdXVpZCA9IGFyZ3NbJ3V1aWQnXSB8fCBVVUlEO1xuXHQgICAgICB2YXIgZGF0YSA9IHsgYXV0aDogYXV0aF9rZXkgfTtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENhbGxiYWNrJyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjInLCAncHJlc2VuY2UnLFxuXHQgICAgICAgICAgJ3N1Yl9rZXknLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgICAgJ3V1aWQnLCB1dGlscy5lbmNvZGUodXVpZClcblx0ICAgICAgICBdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgc3RhdGU6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGNhbGxiYWNrIHx8IGZ1bmN0aW9uIChyKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciBzdGF0ZSA9IGFyZ3NbJ3N0YXRlJ107XG5cdCAgICAgIHZhciB1dWlkID0gYXJnc1sndXVpZCddIHx8IFVVSUQ7XG5cdCAgICAgIHZhciBjaGFubmVsID0gYXJnc1snY2hhbm5lbCddO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIHVybDtcblx0ICAgICAgdmFyIGRhdGEgPSBfZ2V0X3VybF9wYXJhbXMoeyBhdXRoOiBhdXRoX2tleSB9KTtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXHQgICAgICBpZiAoIXV1aWQpIHJldHVybiBlcnJvcignTWlzc2luZyBVVUlEJyk7XG5cdCAgICAgIGlmICghY2hhbm5lbCAmJiAhY2hhbm5lbF9ncm91cCkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9ICd1bmRlZmluZWQnXG5cdCAgICAgICAgJiYgQ0hBTk5FTFNbY2hhbm5lbF0gJiYgQ0hBTk5FTFNbY2hhbm5lbF0uc3Vic2NyaWJlZCkge1xuXHQgICAgICAgIGlmIChzdGF0ZSkgU1RBVEVbY2hhbm5lbF0gPSBzdGF0ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbF9ncm91cCAhPSAndW5kZWZpbmVkJ1xuXHQgICAgICAgICYmIENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdXG5cdCAgICAgICAgJiYgQ0hBTk5FTF9HUk9VUFNbY2hhbm5lbF9ncm91cF0uc3Vic2NyaWJlZFxuXHQgICAgICApIHtcblx0ICAgICAgICBpZiAoc3RhdGUpIFNUQVRFW2NoYW5uZWxfZ3JvdXBdID0gc3RhdGU7XG5cdCAgICAgICAgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cDtcblxuXHQgICAgICAgIGlmICghY2hhbm5lbCkge1xuXHQgICAgICAgICAgY2hhbm5lbCA9ICcsJztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBkYXRhWydzdGF0ZSddID0gSlNPTi5zdHJpbmdpZnkoc3RhdGUpO1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICBpZiAoc3RhdGUpIHtcblx0ICAgICAgICB1cmwgPSBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjInLCAncHJlc2VuY2UnLFxuXHQgICAgICAgICAgJ3N1Yi1rZXknLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgICAgJ2NoYW5uZWwnLCBjaGFubmVsLFxuXHQgICAgICAgICAgJ3V1aWQnLCB1dWlkLCAnZGF0YSdcblx0ICAgICAgICBdO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHVybCA9IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MicsICdwcmVzZW5jZScsXG5cdCAgICAgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVksXG5cdCAgICAgICAgICAnY2hhbm5lbCcsIGNoYW5uZWwsXG5cdCAgICAgICAgICAndXVpZCcsIHV0aWxzLmVuY29kZSh1dWlkKVxuXHQgICAgICAgIF07XG5cdCAgICAgIH1cblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogdXJsXG5cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5ncmFudCh7XG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdCcsXG5cdCAgICAgY2FsbGJhY2sgOiBmdW4sXG5cdCAgICAgZXJyb3IgICAgOiBmdW4sXG5cdCAgICAgdHRsICAgICAgOiAyNCAqIDYwLCAvLyBNaW51dGVzXG5cdCAgICAgcmVhZCAgICAgOiB0cnVlLFxuXHQgICAgIHdyaXRlICAgIDogdHJ1ZSxcblx0ICAgICBhdXRoX2tleSA6ICczeTh1aWFqZGtseXRvd3NqJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBncmFudDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXSB8fCBhcmdzWydjaGFubmVscyddO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIHR0bCA9IGFyZ3NbJ3R0bCddO1xuXHQgICAgICB2YXIgciA9IChhcmdzWydyZWFkJ10pID8gJzEnIDogJzAnO1xuXHQgICAgICB2YXIgdyA9IChhcmdzWyd3cml0ZSddKSA/ICcxJyA6ICcwJztcblx0ICAgICAgdmFyIG0gPSAoYXJnc1snbWFuYWdlJ10pID8gJzEnIDogJzAnO1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IGFyZ3NbJ2F1dGhfa2V5cyddO1xuXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cdCAgICAgIGlmICghUFVCTElTSF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBQdWJsaXNoIEtleScpO1xuXHQgICAgICBpZiAoIVNFQ1JFVF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTZWNyZXQgS2V5Jyk7XG5cblx0ICAgICAgdmFyIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcblx0ICAgICAgdmFyIHNpZ25faW5wdXQgPSBTVUJTQ1JJQkVfS0VZICsgJ1xcbicgKyBQVUJMSVNIX0tFWSArICdcXG4nICsgJ2dyYW50JyArICdcXG4nO1xuXG5cdCAgICAgIHZhciBkYXRhID0geyB3OiB3LCByOiByLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9O1xuXG5cdCAgICAgIGlmIChhcmdzWydtYW5hZ2UnXSkge1xuXHQgICAgICAgIGRhdGFbJ20nXSA9IG07XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoY2hhbm5lbCkpIHtcblx0ICAgICAgICBjaGFubmVsID0gY2hhbm5lbFsnam9pbiddKCcsJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoYXV0aF9rZXkpKSB7XG5cdCAgICAgICAgYXV0aF9rZXkgPSBhdXRoX2tleVsnam9pbiddKCcsJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9ICd1bmRlZmluZWQnICYmIGNoYW5uZWwgIT0gbnVsbCAmJiBjaGFubmVsLmxlbmd0aCA+IDApIGRhdGFbJ2NoYW5uZWwnXSA9IGNoYW5uZWw7XG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbF9ncm91cCAhPSAndW5kZWZpbmVkJyAmJiBjaGFubmVsX2dyb3VwICE9IG51bGwgJiYgY2hhbm5lbF9ncm91cC5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0dGwgfHwgdHRsID09PSAwKSBkYXRhWyd0dGwnXSA9IHR0bDtcblxuXHQgICAgICBpZiAoYXV0aF9rZXkpIGRhdGFbJ2F1dGgnXSA9IGF1dGhfa2V5O1xuXG5cdCAgICAgIGRhdGEgPSBfZ2V0X3VybF9wYXJhbXMoZGF0YSk7XG5cblx0ICAgICAgaWYgKCFhdXRoX2tleSkgZGVsZXRlIGRhdGFbJ2F1dGgnXTtcblxuXHQgICAgICBzaWduX2lucHV0ICs9IF9nZXRfcGFtX3NpZ25faW5wdXRfZnJvbV9wYXJhbXMoZGF0YSk7XG5cblx0ICAgICAgdmFyIHNpZ25hdHVyZSA9IGhtYWNfU0hBMjU2KHNpZ25faW5wdXQsIFNFQ1JFVF9LRVkpO1xuXG5cdCAgICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS5yZXBsYWNlKC9cXCsvZywgJy0nKTtcblx0ICAgICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xuXG5cdCAgICAgIGRhdGFbJ3NpZ25hdHVyZSddID0gc2lnbmF0dXJlO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogW1xuXHQgICAgICAgICAgU1REX09SSUdJTiwgJ3YxJywgJ2F1dGgnLCAnZ3JhbnQnLFxuXHQgICAgICAgICAgJ3N1Yi1rZXknLCBTVUJTQ1JJQkVfS0VZXG5cdCAgICAgICAgXVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLm1vYmlsZV9nd19wcm92aXNpb24gKHtcblx0ICAgICBkZXZpY2VfaWQ6ICdBNjU1RkJBOTkzMUFCJyxcblx0ICAgICBvcCAgICAgICA6ICdhZGQnIHwgJ3JlbW92ZScsXG5cdCAgICAgZ3dfdHlwZSAgOiAnYXBucycgfCAnZ2NtJyxcblx0ICAgICBjaGFubmVsICA6ICdteV9jaGF0Jyxcblx0ICAgICBjYWxsYmFjayA6IGZ1bixcblx0ICAgICBlcnJvciAgICA6IGZ1bixcblx0ICAgICB9KTtcblx0ICAgICAqL1xuXG5cdCAgICBtb2JpbGVfZ3dfcHJvdmlzaW9uOiBmdW5jdGlvbiAoYXJncykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBvcCA9IGFyZ3NbJ29wJ107XG5cdCAgICAgIHZhciBnd190eXBlID0gYXJnc1snZ3dfdHlwZSddO1xuXHQgICAgICB2YXIgZGV2aWNlX2lkID0gYXJnc1snZGV2aWNlX2lkJ107XG5cdCAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgIHZhciB1cmw7XG5cblx0ICAgICAgaWYgKCFkZXZpY2VfaWQpIHJldHVybiBlcnJvcignTWlzc2luZyBEZXZpY2UgSUQgKGRldmljZV9pZCknKTtcblx0ICAgICAgaWYgKCFnd190eXBlKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgR1cgVHlwZSAoZ3dfdHlwZTogZ2NtIG9yIGFwbnMpJyk7XG5cdCAgICAgIGlmICghb3ApIHJldHVybiBlcnJvcignTWlzc2luZyBHVyBPcGVyYXRpb24gKG9wOiBhZGQgb3IgcmVtb3ZlKScpO1xuXHQgICAgICBpZiAoIWNoYW5uZWwpIHJldHVybiBlcnJvcignTWlzc2luZyBndyBkZXN0aW5hdGlvbiBDaGFubmVsIChjaGFubmVsKScpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgLy8gQ3JlYXRlIFVSTFxuXHQgICAgICB1cmwgPSBbXG5cdCAgICAgICAgU1REX09SSUdJTiwgJ3YxL3B1c2gvc3ViLWtleScsXG5cdCAgICAgICAgU1VCU0NSSUJFX0tFWSwgJ2RldmljZXMnLCBkZXZpY2VfaWRcblx0ICAgICAgXTtcblxuXHQgICAgICBwYXJhbXMgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IGF1dGhfa2V5LCB0eXBlOiBnd190eXBlIH07XG5cblx0ICAgICAgaWYgKG9wID09ICdhZGQnKSB7XG5cdCAgICAgICAgcGFyYW1zWydhZGQnXSA9IGNoYW5uZWw7XG5cdCAgICAgIH0gZWxzZSBpZiAob3AgPT0gJ3JlbW92ZScpIHtcblx0ICAgICAgICBwYXJhbXNbJ3JlbW92ZSddID0gY2hhbm5lbDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgcGFyYW1zWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IHBhcmFtcyxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5hdWRpdCh7XG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdCcsXG5cdCAgICAgY2FsbGJhY2sgOiBmdW4sXG5cdCAgICAgZXJyb3IgICAgOiBmdW4sXG5cdCAgICAgcmVhZCAgICAgOiB0cnVlLFxuXHQgICAgIHdyaXRlICAgIDogdHJ1ZSxcblx0ICAgICBhdXRoX2tleSA6ICczeTh1aWFqZGtseXRvd3NqJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBhdWRpdDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J107XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cblx0ICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBDaGFubmVsXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cdCAgICAgIGlmICghUFVCTElTSF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBQdWJsaXNoIEtleScpO1xuXHQgICAgICBpZiAoIVNFQ1JFVF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTZWNyZXQgS2V5Jyk7XG5cblx0ICAgICAgdmFyIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcblx0ICAgICAgdmFyIHNpZ25faW5wdXQgPSBTVUJTQ1JJQkVfS0VZICsgJ1xcbicgKyBQVUJMSVNIX0tFWSArICdcXG4nICsgJ2F1ZGl0JyArICdcXG4nO1xuXG5cdCAgICAgIHZhciBkYXRhID0geyB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9O1xuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbCAhPSAndW5kZWZpbmVkJyAmJiBjaGFubmVsICE9IG51bGwgJiYgY2hhbm5lbC5sZW5ndGggPiAwKSBkYXRhWydjaGFubmVsJ10gPSBjaGFubmVsO1xuXHQgICAgICBpZiAodHlwZW9mIGNoYW5uZWxfZ3JvdXAgIT0gJ3VuZGVmaW5lZCcgJiYgY2hhbm5lbF9ncm91cCAhPSBudWxsICYmIGNoYW5uZWxfZ3JvdXAubGVuZ3RoID4gMCkge1xuXHQgICAgICAgIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGF1dGhfa2V5KSBkYXRhWydhdXRoJ10gPSBhdXRoX2tleTtcblxuXHQgICAgICBkYXRhID0gX2dldF91cmxfcGFyYW1zKGRhdGEpO1xuXG5cdCAgICAgIGlmICghYXV0aF9rZXkpIGRlbGV0ZSBkYXRhWydhdXRoJ107XG5cblx0ICAgICAgc2lnbl9pbnB1dCArPSBfZ2V0X3BhbV9zaWduX2lucHV0X2Zyb21fcGFyYW1zKGRhdGEpO1xuXG5cdCAgICAgIHZhciBzaWduYXR1cmUgPSBobWFjX1NIQTI1NihzaWduX2lucHV0LCBTRUNSRVRfS0VZKTtcblxuXHQgICAgICBzaWduYXR1cmUgPSBzaWduYXR1cmUucmVwbGFjZSgvXFwrL2csICctJyk7XG5cdCAgICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcblxuXHQgICAgICBkYXRhWydzaWduYXR1cmUnXSA9IHNpZ25hdHVyZTtcblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogZGF0YSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjEnLCAnYXV0aCcsICdhdWRpdCcsXG5cdCAgICAgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVlcblx0ICAgICAgICBdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIucmV2b2tlKHtcblx0ICAgICBjaGFubmVsICA6ICdteV9jaGF0Jyxcblx0ICAgICBjYWxsYmFjayA6IGZ1bixcblx0ICAgICBlcnJvciAgICA6IGZ1bixcblx0ICAgICBhdXRoX2tleSA6ICczeTh1aWFqZGtseXRvd3NqJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICByZXZva2U6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBhcmdzWydyZWFkJ10gPSBmYWxzZTtcblx0ICAgICAgYXJnc1snd3JpdGUnXSA9IGZhbHNlO1xuXHQgICAgICBTRUxGWydncmFudCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIHNldF91dWlkOiBmdW5jdGlvbiAodXVpZCkge1xuXHQgICAgICBVVUlEID0gdXVpZDtcblx0ICAgICAgQ09OTkVDVCgpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X3V1aWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIFVVSUQ7XG5cdCAgICB9LFxuXG5cdCAgICBpc0FycmF5OiBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgIHJldHVybiB1dGlscy5pc0FycmF5KGFyZyk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRfc3Vic2NyaWJlZF9jaGFubmVsczogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTLCB0cnVlKTtcblx0ICAgIH0sXG5cblx0ICAgIHByZXNlbmNlX2hlYXJ0YmVhdDogZnVuY3Rpb24gKGFyZ3MpIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBBVVRIX0tFWSB9O1xuXG5cdCAgICAgIHZhciBzdCA9IEpTT05bJ3N0cmluZ2lmeSddKFNUQVRFKTtcblx0ICAgICAgaWYgKHN0Lmxlbmd0aCA+IDIpIGRhdGFbJ3N0YXRlJ10gPSBKU09OWydzdHJpbmdpZnknXShTVEFURSk7XG5cblx0ICAgICAgaWYgKFBSRVNFTkNFX0hCID4gMCAmJiBQUkVTRU5DRV9IQiA8IDMyMCkgZGF0YVsnaGVhcnRiZWF0J10gPSBQUkVTRU5DRV9IQjtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGNoYW5uZWxzID0gdXRpbHMuZW5jb2RlKGdlbmVyYXRlX2NoYW5uZWxfbGlzdChDSEFOTkVMUywgdHJ1ZSlbJ2pvaW4nXSgnLCcpKTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXBzID0gZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KENIQU5ORUxfR1JPVVBTLCB0cnVlKVsnam9pbiddKCcsJyk7XG5cblx0ICAgICAgaWYgKCFjaGFubmVscykgY2hhbm5lbHMgPSAnLCc7XG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwcykgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cHM7XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MicsICdwcmVzZW5jZScsXG5cdCAgICAgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVksXG5cdCAgICAgICAgICAnY2hhbm5lbCcsIGNoYW5uZWxzLFxuXHQgICAgICAgICAgJ2hlYXJ0YmVhdCdcblx0ICAgICAgICBdLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIHN0b3BfdGltZXJzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGNsZWFyVGltZW91dChfcG9sbF90aW1lcik7XG5cdCAgICAgIGNsZWFyVGltZW91dChfcG9sbF90aW1lcjIpO1xuXHQgICAgICBjbGVhclRpbWVvdXQoUFJFU0VOQ0VfSEJfVElNRU9VVCk7XG5cdCAgICB9LFxuXG5cdCAgICBzaHV0ZG93bjogZnVuY3Rpb24gKCkge1xuXHQgICAgICBTRUxGWydzdG9wX3RpbWVycyddKCk7XG5cdCAgICAgIHNodXRkb3duICYmIHNodXRkb3duKCk7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBFeHBvc2UgUFVCTlVCIEZ1bmN0aW9uc1xuXHQgICAgeGRyOiB4ZHIsXG5cdCAgICByZWFkeTogcmVhZHksXG5cdCAgICBkYjogZGIsXG5cdCAgICB1dWlkOiB1dGlscy5nZW5lcmF0ZVVVSUQsXG5cdCAgICBtYXA6IHV0aWxzLm1hcCxcblx0ICAgIGVhY2g6IHV0aWxzLmVhY2gsXG5cdCAgICAnZWFjaC1jaGFubmVsJzogZWFjaF9jaGFubmVsLFxuXHQgICAgZ3JlcDogdXRpbHMuZ3JlcCxcblx0ICAgIG9mZmxpbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgX3Jlc2V0X29mZmxpbmUoMSwgeyBtZXNzYWdlOiAnT2ZmbGluZS4gUGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yayBzZXR0aW5ncy4nIH0pO1xuXHQgICAgfSxcblx0ICAgIHN1cHBsYW50OiB1dGlscy5zdXBwbGFudCxcblx0ICAgIG5vdzogdXRpbHMucm5vdyxcblx0ICAgIHVuaXF1ZTogdW5pcXVlLFxuXHQgICAgdXBkYXRlcjogdXRpbHMudXBkYXRlclxuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBfcG9sbF9vbmxpbmUoKSB7XG5cdCAgICBfaXNfb25saW5lKCkgfHwgX3Jlc2V0X29mZmxpbmUoMSwgeyBlcnJvcjogJ09mZmxpbmUuIFBsZWFzZSBjaGVjayB5b3VyIG5ldHdvcmsgc2V0dGluZ3MuJyB9KTtcblx0ICAgIF9wb2xsX3RpbWVyICYmIGNsZWFyVGltZW91dChfcG9sbF90aW1lcik7XG5cdCAgICBfcG9sbF90aW1lciA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lLCBTRUNPTkQpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9wb2xsX29ubGluZTIoKSB7XG5cdCAgICBpZiAoIVRJTUVfQ0hFQ0spIHJldHVybjtcblx0ICAgIFNFTEZbJ3RpbWUnXShmdW5jdGlvbiAoc3VjY2Vzcykge1xuXHQgICAgICBkZXRlY3RfdGltZV9kZXRsYShmdW5jdGlvbiAoKSB7XG5cdCAgICAgIH0sIHN1Y2Nlc3MpO1xuXHQgICAgICBzdWNjZXNzIHx8IF9yZXNldF9vZmZsaW5lKDEsIHtcblx0ICAgICAgICBlcnJvcjogJ0hlYXJ0YmVhdCBmYWlsZWQgdG8gY29ubmVjdCB0byBQdWJudWIgU2VydmVycy4nICtcblx0ICAgICAgICAnUGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yayBzZXR0aW5ncy4nXG5cdCAgICAgIH0pO1xuXHQgICAgICBfcG9sbF90aW1lcjIgJiYgY2xlYXJUaW1lb3V0KF9wb2xsX3RpbWVyMik7XG5cdCAgICAgIF9wb2xsX3RpbWVyMiA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lMiwgS0VFUEFMSVZFKTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9yZXNldF9vZmZsaW5lKGVyciwgbXNnKSB7XG5cdCAgICBTVUJfUkVDRUlWRVIgJiYgU1VCX1JFQ0VJVkVSKGVyciwgbXNnKTtcblx0ICAgIFNVQl9SRUNFSVZFUiA9IG51bGw7XG5cblx0ICAgIGNsZWFyVGltZW91dChfcG9sbF90aW1lcik7XG5cdCAgICBjbGVhclRpbWVvdXQoX3BvbGxfdGltZXIyKTtcblx0ICB9XG5cblx0ICBpZiAoIVVVSUQpIFVVSUQgPSBTRUxGWyd1dWlkJ10oKTtcblx0ICBpZiAoIUlOU1RBTkNFSUQpIElOU1RBTkNFSUQgPSBTRUxGWyd1dWlkJ10oKTtcblx0ICBkYlsnc2V0J10oU1VCU0NSSUJFX0tFWSArICd1dWlkJywgVVVJRCk7XG5cblx0ICBfcG9sbF90aW1lciA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lLCBTRUNPTkQpO1xuXHQgIF9wb2xsX3RpbWVyMiA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lMiwgS0VFUEFMSVZFKTtcblx0ICBQUkVTRU5DRV9IQl9USU1FT1VUID0gdXRpbHMudGltZW91dChcblx0ICAgIHN0YXJ0X3ByZXNlbmNlX2hlYXJ0YmVhdCxcblx0ICAgIChQUkVTRU5DRV9IQl9JTlRFUlZBTCAtIDMpICogU0VDT05EXG5cdCAgKTtcblxuXHQgIC8vIERldGVjdCBBZ2Ugb2YgTWVzc2FnZVxuXHQgIGZ1bmN0aW9uIGRldGVjdF9sYXRlbmN5KHR0KSB7XG5cdCAgICB2YXIgYWRqdXN0ZWRfdGltZSA9IHV0aWxzLnJub3coKSAtIFRJTUVfRFJJRlQ7XG5cdCAgICByZXR1cm4gYWRqdXN0ZWRfdGltZSAtIHR0IC8gMTAwMDA7XG5cdCAgfVxuXG5cdCAgZGV0ZWN0X3RpbWVfZGV0bGEoKTtcblx0ICBmdW5jdGlvbiBkZXRlY3RfdGltZV9kZXRsYShjYiwgdGltZSkge1xuXHQgICAgdmFyIHN0aW1lID0gdXRpbHMucm5vdygpO1xuXG5cdCAgICB0aW1lICYmIGNhbGN1bGF0ZSh0aW1lKSB8fCBTRUxGWyd0aW1lJ10oY2FsY3VsYXRlKTtcblxuXHQgICAgZnVuY3Rpb24gY2FsY3VsYXRlKHRpbWUpIHtcblx0ICAgICAgaWYgKCF0aW1lKSByZXR1cm47XG5cdCAgICAgIHZhciBwdGltZSA9IHRpbWUgLyAxMDAwMDtcblx0ICAgICAgdmFyIGxhdGVuY3kgPSAodXRpbHMucm5vdygpIC0gc3RpbWUpIC8gMjtcblx0ICAgICAgVElNRV9EUklGVCA9IHV0aWxzLnJub3coKSAtIChwdGltZSArIGxhdGVuY3kpO1xuXHQgICAgICBjYiAmJiBjYihUSU1FX0RSSUZUKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gU0VMRjtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIFBOX0FQSTogUE5fQVBJLFxuXHQgIHVuaXF1ZTogdW5pcXVlLFxuXHQgIFBObWVzc2FnZTogUE5tZXNzYWdlLFxuXHQgIERFRl9USU1FT1VUOiBERUZfVElNRU9VVCxcblx0ICB0aW1lb3V0OiB1dGlscy50aW1lb3V0LFxuXHQgIGJ1aWxkX3VybDogdXRpbHMuYnVpbGRVUkwsXG5cdCAgZWFjaDogdXRpbHMuZWFjaCxcblx0ICB1dWlkOiB1dGlscy5nZW5lcmF0ZVVVSUQsXG5cdCAgVVJMQklUOiBkZWZhdWx0Q29uZmlndXJhdGlvbi5VUkxCSVQsXG5cdCAgZ3JlcDogdXRpbHMuZ3JlcCxcblx0ICBzdXBwbGFudDogdXRpbHMuc3VwcGxhbnQsXG5cdCAgbm93OiB1dGlscy5ybm93LFxuXHQgIHVwZGF0ZXI6IHV0aWxzLnVwZGF0ZXIsXG5cdCAgbWFwOiB1dGlscy5tYXBcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdFx0XCJQQVJBTVNCSVRcIjogXCImXCIsXG5cdFx0XCJVUkxCSVRcIjogXCIvXCJcblx0fTtcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IDAsIGJsb2NrLXNjb3BlZC12YXI6IDAsIG5vLXJlZGVjbGFyZTogMCwgZ3VhcmQtZm9yLWluOiAwICovXG5cblx0dmFyIGRlZmF1bHRDb25maWd1cmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIFJFUEwgPSAveyhbXFx3XFwtXSspfS9nO1xuXG5cdGZ1bmN0aW9uIHJub3coKSB7XG5cdCAgcmV0dXJuICtuZXcgRGF0ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG5cdCAgcmV0dXJuICEhYXJnICYmIHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnICYmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkoYXJnKSB8fCB0eXBlb2YoYXJnLmxlbmd0aCkgPT09ICdudW1iZXInKTtcblx0ICAvLyByZXR1cm4gISFhcmcgJiYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheShhcmcpIHx8IHR5cGVvZihhcmcubGVuZ3RoKSA9PT0gXCJudW1iZXJcIilcblx0fVxuXG5cdC8qKlxuXHQgKiBFQUNIXG5cdCAqID09PT1cblx0ICogZWFjaCggWzEsMiwzXSwgZnVuY3Rpb24oaXRlbSkgeyB9IClcblx0ICovXG5cdGZ1bmN0aW9uIGVhY2gobywgZikge1xuXHQgIGlmICghbyB8fCAhZikge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIGlmIChpc0FycmF5KG8pKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IG8ubGVuZ3RoOyBpIDwgbDspIHtcblx0ICAgICAgZi5jYWxsKG9baV0sIG9baV0sIGkrKyk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGZvciAodmFyIGkgaW4gbykge1xuXHQgICAgICBvLmhhc093blByb3BlcnR5ICYmXG5cdCAgICAgIG8uaGFzT3duUHJvcGVydHkoaSkgJiZcblx0ICAgICAgZi5jYWxsKG9baV0sIGksIG9baV0pO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFTkNPREVcblx0ICogPT09PT09XG5cdCAqIHZhciBlbmNvZGVkX2RhdGEgPSBlbmNvZGUoJ3BhdGgnKTtcblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShwYXRoKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQocGF0aCk7IH1cblxuXHQvKipcblx0ICogQnVpbGQgVXJsXG5cdCAqID09PT09PT1cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIGJ1aWxkVVJMKHVybENvbXBvbmVudHMsIHVybFBhcmFtcykge1xuXHQgIHZhciB1cmwgPSB1cmxDb21wb25lbnRzLmpvaW4oZGVmYXVsdENvbmZpZ3VyYXRpb24uVVJMQklUKTtcblx0ICB2YXIgcGFyYW1zID0gW107XG5cblx0ICBpZiAoIXVybFBhcmFtcykgcmV0dXJuIHVybDtcblxuXHQgIGVhY2godXJsUGFyYW1zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgICAgdmFyIHZhbHVlU3RyID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpID8gSlNPTlsnc3RyaW5naWZ5J10odmFsdWUpIDogdmFsdWU7XG5cdCAgICAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgICB2YWx1ZSAhPT0gbnVsbCAmJiBlbmNvZGUodmFsdWVTdHIpLmxlbmd0aCA+IDBcblx0ICAgICkgJiYgcGFyYW1zLnB1c2goa2V5ICsgJz0nICsgZW5jb2RlKHZhbHVlU3RyKSk7XG5cdCAgfSk7XG5cblx0ICB1cmwgKz0gJz8nICsgcGFyYW1zLmpvaW4oZGVmYXVsdENvbmZpZ3VyYXRpb24uUEFSQU1TQklUKTtcblx0ICByZXR1cm4gdXJsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVQREFURVJcblx0ICogPT09PT09PVxuXHQgKiB2YXIgdGltZXN0YW1wID0gdW5pcXVlKCk7XG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGVyKGZ1biwgcmF0ZSkge1xuXHQgIHZhciB0aW1lb3V0O1xuXHQgIHZhciBsYXN0ID0gMDtcblx0ICB2YXIgcnVubml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGxhc3QgKyByYXRlID4gcm5vdygpKSB7XG5cdCAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0ICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocnVubml0LCByYXRlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxhc3QgPSBybm93KCk7XG5cdCAgICAgIGZ1bigpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICByZXR1cm4gcnVubml0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdSRVBcblx0ICogPT09PVxuXHQgKiB2YXIgbGlzdCA9IGdyZXAoIFsxLDIsM10sIGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gJSAyIH0gKVxuXHQgKi9cblx0ZnVuY3Rpb24gZ3JlcChsaXN0LCBmdW4pIHtcblx0ICB2YXIgZmluID0gW107XG5cdCAgZWFjaChsaXN0IHx8IFtdLCBmdW5jdGlvbiAobCkge1xuXHQgICAgZnVuKGwpICYmIGZpbi5wdXNoKGwpO1xuXHQgIH0pO1xuXHQgIHJldHVybiBmaW47XG5cdH1cblxuXHQvKipcblx0ICogU1VQUExBTlRcblx0ICogPT09PT09PT1cblx0ICogdmFyIHRleHQgPSBzdXBwbGFudCggJ0hlbGxvIHtuYW1lfSEnLCB7IG5hbWUgOiAnSm9obicgfSApXG5cdCAqL1xuXHRmdW5jdGlvbiBzdXBwbGFudChzdHIsIHZhbHVlcykge1xuXHQgIHJldHVybiBzdHIucmVwbGFjZShSRVBMLCBmdW5jdGlvbiAoXywgbWF0Y2gpIHtcblx0ICAgIHJldHVybiB2YWx1ZXNbbWF0Y2hdIHx8IF87XG5cdCAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogdGltZW91dFxuXHQgKiA9PT09PT09XG5cdCAqIHRpbWVvdXQoIGZ1bmN0aW9uKCl7fSwgMTAwICk7XG5cdCAqL1xuXHRmdW5jdGlvbiB0aW1lb3V0KGZ1biwgd2FpdCkge1xuXHQgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICByZXR1cm4gc2V0VGltZW91dChmdW4sIHdhaXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIHV1aWRcblx0ICogPT09PVxuXHQgKiB2YXIgbXlfdXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKGNhbGxiYWNrKSB7XG5cdCAgdmFyIHUgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csXG5cdCAgICBmdW5jdGlvbiAoYykge1xuXHQgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG5cdCAgICAgIHZhciB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcblx0ICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuXHQgICAgfSk7XG5cdCAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayh1KTtcblx0ICByZXR1cm4gdTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNQVBcblx0ICogPT09XG5cdCAqIHZhciBsaXN0ID0gbWFwKCBbMSwyLDNdLCBmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtICsgMSB9IClcblx0ICovXG5cdGZ1bmN0aW9uIG1hcChsaXN0LCBmdW4pIHtcblx0ICB2YXIgZmluID0gW107XG5cdCAgZWFjaChsaXN0IHx8IFtdLCBmdW5jdGlvbiAoaywgdikge1xuXHQgICAgZmluLnB1c2goZnVuKGssIHYpKTtcblx0ICB9KTtcblx0ICByZXR1cm4gZmluO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBwYW1FbmNvZGUoc3RyKSB7XG5cdCAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKn5dL2csIGZ1bmN0aW9uIChjKSB7XG5cdCAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHQgIH0pO1xuXHR9XG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBidWlsZFVSTDogYnVpbGRVUkwsXG5cdCAgZW5jb2RlOiBlbmNvZGUsXG5cdCAgZWFjaDogZWFjaCxcblx0ICB1cGRhdGVyOiB1cGRhdGVyLFxuXHQgIHJub3c6IHJub3csXG5cdCAgaXNBcnJheTogaXNBcnJheSxcblx0ICBtYXA6IG1hcCxcblx0ICBwYW1FbmNvZGU6IHBhbUVuY29kZSxcblx0ICBnZW5lcmF0ZVVVSUQ6IGdlbmVyYXRlVVVJRCxcblx0ICB0aW1lb3V0OiB0aW1lb3V0LFxuXHQgIHN1cHBsYW50OiBzdXBwbGFudCxcblx0ICBncmVwOiBncmVwXG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIGVzbGludCBjYW1lbGNhc2U6IDAgZXFlcWVxOiAwICovXG5cblx0dmFyIENyeXB0b0pTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuXHRmdW5jdGlvbiBjcnlwdG9fb2JqKCkge1xuXHQgIGZ1bmN0aW9uIFNIQTI1NihzKSB7XG5cdCAgICByZXR1cm4gQ3J5cHRvSlNbJ1NIQTI1NiddKHMpWyd0b1N0cmluZyddKENyeXB0b0pTWydlbmMnXVsnSGV4J10pO1xuXHQgIH1cblxuXHQgIHZhciBpdiA9ICcwMTIzNDU2Nzg5MDEyMzQ1JztcblxuXHQgIHZhciBhbGxvd2VkS2V5RW5jb2RpbmdzID0gWydoZXgnLCAndXRmOCcsICdiYXNlNjQnLCAnYmluYXJ5J107XG5cdCAgdmFyIGFsbG93ZWRLZXlMZW5ndGhzID0gWzEyOCwgMjU2XTtcblx0ICB2YXIgYWxsb3dlZE1vZGVzID0gWydlY2InLCAnY2JjJ107XG5cblx0ICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdCAgICBlbmNyeXB0S2V5OiB0cnVlLFxuXHQgICAga2V5RW5jb2Rpbmc6ICd1dGY4Jyxcblx0ICAgIGtleUxlbmd0aDogMjU2LFxuXHQgICAgbW9kZTogJ2NiYydcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gcGFyc2Vfb3B0aW9ucyhvcHRpb25zKSB7XG5cdCAgICAvLyBEZWZhdWx0c1xuXHQgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgICBpZiAoIW9wdGlvbnNbJ2hhc093blByb3BlcnR5J10oJ2VuY3J5cHRLZXknKSkgb3B0aW9uc1snZW5jcnlwdEtleSddID0gZGVmYXVsdE9wdGlvbnNbJ2VuY3J5cHRLZXknXTtcblx0ICAgIGlmICghb3B0aW9uc1snaGFzT3duUHJvcGVydHknXSgna2V5RW5jb2RpbmcnKSkgb3B0aW9uc1sna2V5RW5jb2RpbmcnXSA9IGRlZmF1bHRPcHRpb25zWydrZXlFbmNvZGluZyddO1xuXHQgICAgaWYgKCFvcHRpb25zWydoYXNPd25Qcm9wZXJ0eSddKCdrZXlMZW5ndGgnKSkgb3B0aW9uc1sna2V5TGVuZ3RoJ10gPSBkZWZhdWx0T3B0aW9uc1sna2V5TGVuZ3RoJ107XG5cdCAgICBpZiAoIW9wdGlvbnNbJ2hhc093blByb3BlcnR5J10oJ21vZGUnKSkgb3B0aW9uc1snbW9kZSddID0gZGVmYXVsdE9wdGlvbnNbJ21vZGUnXTtcblxuXHQgICAgLy8gVmFsaWRhdGlvblxuXHQgICAgaWYgKGFsbG93ZWRLZXlFbmNvZGluZ3NbJ2luZGV4T2YnXShvcHRpb25zWydrZXlFbmNvZGluZyddWyd0b0xvd2VyQ2FzZSddKCkpID09IC0xKSBvcHRpb25zWydrZXlFbmNvZGluZyddID0gZGVmYXVsdE9wdGlvbnNbJ2tleUVuY29kaW5nJ107XG5cdCAgICBpZiAoYWxsb3dlZEtleUxlbmd0aHNbJ2luZGV4T2YnXShwYXJzZUludChvcHRpb25zWydrZXlMZW5ndGgnXSwgMTApKSA9PSAtMSkgb3B0aW9uc1sna2V5TGVuZ3RoJ10gPSBkZWZhdWx0T3B0aW9uc1sna2V5TGVuZ3RoJ107XG5cdCAgICBpZiAoYWxsb3dlZE1vZGVzWydpbmRleE9mJ10ob3B0aW9uc1snbW9kZSddWyd0b0xvd2VyQ2FzZSddKCkpID09IC0xKSBvcHRpb25zWydtb2RlJ10gPSBkZWZhdWx0T3B0aW9uc1snbW9kZSddO1xuXG5cdCAgICByZXR1cm4gb3B0aW9ucztcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkZWNvZGVfa2V5KGtleSwgb3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnNbJ2tleUVuY29kaW5nJ10gPT09ICdiYXNlNjQnKSB7XG5cdCAgICAgIHJldHVybiBDcnlwdG9KU1snZW5jJ11bJ0Jhc2U2NCddWydwYXJzZSddKGtleSk7XG5cdCAgICB9IGVsc2UgaWYgKG9wdGlvbnNbJ2tleUVuY29kaW5nJ10gPT09ICdoZXgnKSB7XG5cdCAgICAgIHJldHVybiBDcnlwdG9KU1snZW5jJ11bJ0hleCddWydwYXJzZSddKGtleSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4ga2V5O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdldF9wYWRkZWRfa2V5KGtleSwgb3B0aW9ucykge1xuXHQgICAga2V5ID0gZGVjb2RlX2tleShrZXksIG9wdGlvbnMpO1xuXHQgICAgaWYgKG9wdGlvbnNbJ2VuY3J5cHRLZXknXSkge1xuXHQgICAgICByZXR1cm4gQ3J5cHRvSlNbJ2VuYyddWydVdGY4J11bJ3BhcnNlJ10oU0hBMjU2KGtleSlbJ3NsaWNlJ10oMCwgMzIpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBrZXk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZ2V0X21vZGUob3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnNbJ21vZGUnXSA9PT0gJ2VjYicpIHtcblx0ICAgICAgcmV0dXJuIENyeXB0b0pTWydtb2RlJ11bJ0VDQiddO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIENyeXB0b0pTWydtb2RlJ11bJ0NCQyddO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdldF9pdihvcHRpb25zKSB7XG5cdCAgICByZXR1cm4gKG9wdGlvbnNbJ21vZGUnXSA9PT0gJ2NiYycpID8gQ3J5cHRvSlNbJ2VuYyddWydVdGY4J11bJ3BhcnNlJ10oaXYpIDogbnVsbDtcblx0ICB9XG5cblx0ICByZXR1cm4ge1xuXHQgICAgZW5jcnlwdDogZnVuY3Rpb24gKGRhdGEsIGtleSwgb3B0aW9ucykge1xuXHQgICAgICBpZiAoIWtleSkgcmV0dXJuIGRhdGE7XG5cdCAgICAgIG9wdGlvbnMgPSBwYXJzZV9vcHRpb25zKG9wdGlvbnMpO1xuXHQgICAgICB2YXIgaXYgPSBnZXRfaXYob3B0aW9ucyk7XG5cdCAgICAgIHZhciBtb2RlID0gZ2V0X21vZGUob3B0aW9ucyk7XG5cdCAgICAgIHZhciBjaXBoZXJfa2V5ID0gZ2V0X3BhZGRlZF9rZXkoa2V5LCBvcHRpb25zKTtcblx0ICAgICAgdmFyIGhleF9tZXNzYWdlID0gSlNPTlsnc3RyaW5naWZ5J10oZGF0YSk7XG5cdCAgICAgIHZhciBlbmNyeXB0ZWRIZXhBcnJheSA9IENyeXB0b0pTWydBRVMnXVsnZW5jcnlwdCddKGhleF9tZXNzYWdlLCBjaXBoZXJfa2V5LCB7IGl2OiBpdiwgbW9kZTogbW9kZSB9KVsnY2lwaGVydGV4dCddO1xuXHQgICAgICB2YXIgYmFzZV82NF9lbmNyeXB0ZWQgPSBlbmNyeXB0ZWRIZXhBcnJheVsndG9TdHJpbmcnXShDcnlwdG9KU1snZW5jJ11bJ0Jhc2U2NCddKTtcblx0ICAgICAgcmV0dXJuIGJhc2VfNjRfZW5jcnlwdGVkIHx8IGRhdGE7XG5cdCAgICB9LFxuXG5cdCAgICBkZWNyeXB0OiBmdW5jdGlvbiAoZGF0YSwga2V5LCBvcHRpb25zKSB7XG5cdCAgICAgIGlmICgha2V5KSByZXR1cm4gZGF0YTtcblx0ICAgICAgb3B0aW9ucyA9IHBhcnNlX29wdGlvbnMob3B0aW9ucyk7XG5cdCAgICAgIHZhciBpdiA9IGdldF9pdihvcHRpb25zKTtcblx0ICAgICAgdmFyIG1vZGUgPSBnZXRfbW9kZShvcHRpb25zKTtcblx0ICAgICAgdmFyIGNpcGhlcl9rZXkgPSBnZXRfcGFkZGVkX2tleShrZXksIG9wdGlvbnMpO1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHZhciBiaW5hcnlfZW5jID0gQ3J5cHRvSlNbJ2VuYyddWydCYXNlNjQnXVsncGFyc2UnXShkYXRhKTtcblx0ICAgICAgICB2YXIganNvbl9wbGFpbiA9IENyeXB0b0pTWydBRVMnXVsnZGVjcnlwdCddKHsgY2lwaGVydGV4dDogYmluYXJ5X2VuYyB9LCBjaXBoZXJfa2V5LCB7IGl2OiBpdiwgbW9kZTogbW9kZSB9KVsndG9TdHJpbmcnXShDcnlwdG9KU1snZW5jJ11bJ1V0ZjgnXSk7XG5cdCAgICAgICAgdmFyIHBsYWludGV4dCA9IEpTT05bJ3BhcnNlJ10oanNvbl9wbGFpbik7XG5cdCAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBjcnlwdG9fb2JqO1xuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKlxuXHQgQ3J5cHRvSlMgdjMuMS4yXG5cdCBjb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcblx0IChjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHQgY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuXHQgKi9cblx0dmFyIENyeXB0b0pTPUNyeXB0b0pTfHxmdW5jdGlvbihoLHMpe3ZhciBmPXt9LGc9Zi5saWI9e30scT1mdW5jdGlvbigpe30sbT1nLkJhc2U9e2V4dGVuZDpmdW5jdGlvbihhKXtxLnByb3RvdHlwZT10aGlzO3ZhciBjPW5ldyBxO2EmJmMubWl4SW4oYSk7Yy5oYXNPd25Qcm9wZXJ0eShcImluaXRcIil8fChjLmluaXQ9ZnVuY3Rpb24oKXtjLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pO2MuaW5pdC5wcm90b3R5cGU9YztjLiRzdXBlcj10aGlzO3JldHVybiBjfSxjcmVhdGU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmV4dGVuZCgpO2EuaW5pdC5hcHBseShhLGFyZ3VtZW50cyk7cmV0dXJuIGF9LGluaXQ6ZnVuY3Rpb24oKXt9LG1peEluOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYyBpbiBhKWEuaGFzT3duUHJvcGVydHkoYykmJih0aGlzW2NdPWFbY10pO2EuaGFzT3duUHJvcGVydHkoXCJ0b1N0cmluZ1wiKSYmKHRoaXMudG9TdHJpbmc9YS50b1N0cmluZyl9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpfX0sXG5cdCAgICByPWcuV29yZEFycmF5PW0uZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGEsYyl7YT10aGlzLndvcmRzPWF8fFtdO3RoaXMuc2lnQnl0ZXM9YyE9cz9jOjQqYS5sZW5ndGh9LHRvU3RyaW5nOmZ1bmN0aW9uKGEpe3JldHVybihhfHxrKS5zdHJpbmdpZnkodGhpcyl9LGNvbmNhdDpmdW5jdGlvbihhKXt2YXIgYz10aGlzLndvcmRzLGQ9YS53b3JkcyxiPXRoaXMuc2lnQnl0ZXM7YT1hLnNpZ0J5dGVzO3RoaXMuY2xhbXAoKTtpZihiJTQpZm9yKHZhciBlPTA7ZTxhO2UrKyljW2IrZT4+PjJdfD0oZFtlPj4+Ml0+Pj4yNC04KihlJTQpJjI1NSk8PDI0LTgqKChiK2UpJTQpO2Vsc2UgaWYoNjU1MzU8ZC5sZW5ndGgpZm9yKGU9MDtlPGE7ZSs9NCljW2IrZT4+PjJdPWRbZT4+PjJdO2Vsc2UgYy5wdXNoLmFwcGx5KGMsZCk7dGhpcy5zaWdCeXRlcys9YTtyZXR1cm4gdGhpc30sY2xhbXA6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLndvcmRzLGM9dGhpcy5zaWdCeXRlczthW2M+Pj4yXSY9NDI5NDk2NzI5NTw8XG5cdCAgICAgIDMyLTgqKGMlNCk7YS5sZW5ndGg9aC5jZWlsKGMvNCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGE9bS5jbG9uZS5jYWxsKHRoaXMpO2Eud29yZHM9dGhpcy53b3Jkcy5zbGljZSgwKTtyZXR1cm4gYX0scmFuZG9tOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1bXSxkPTA7ZDxhO2QrPTQpYy5wdXNoKDQyOTQ5NjcyOTYqaC5yYW5kb20oKXwwKTtyZXR1cm4gbmV3IHIuaW5pdChjLGEpfX0pLGw9Zi5lbmM9e30saz1sLkhleD17c3RyaW5naWZ5OmZ1bmN0aW9uKGEpe3ZhciBjPWEud29yZHM7YT1hLnNpZ0J5dGVzO2Zvcih2YXIgZD1bXSxiPTA7YjxhO2IrKyl7dmFyIGU9Y1tiPj4+Ml0+Pj4yNC04KihiJTQpJjI1NTtkLnB1c2goKGU+Pj40KS50b1N0cmluZygxNikpO2QucHVzaCgoZSYxNSkudG9TdHJpbmcoMTYpKX1yZXR1cm4gZC5qb2luKFwiXCIpfSxwYXJzZTpmdW5jdGlvbihhKXtmb3IodmFyIGM9YS5sZW5ndGgsZD1bXSxiPTA7YjxjO2IrPTIpZFtiPj4+M118PXBhcnNlSW50KGEuc3Vic3RyKGIsXG5cdCAgICAgICAgMiksMTYpPDwyNC00KihiJTgpO3JldHVybiBuZXcgci5pbml0KGQsYy8yKX19LG49bC5MYXRpbjE9e3N0cmluZ2lmeTpmdW5jdGlvbihhKXt2YXIgYz1hLndvcmRzO2E9YS5zaWdCeXRlcztmb3IodmFyIGQ9W10sYj0wO2I8YTtiKyspZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY1tiPj4+Ml0+Pj4yNC04KihiJTQpJjI1NSkpO3JldHVybiBkLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1hLmxlbmd0aCxkPVtdLGI9MDtiPGM7YisrKWRbYj4+PjJdfD0oYS5jaGFyQ29kZUF0KGIpJjI1NSk8PDI0LTgqKGIlNCk7cmV0dXJuIG5ldyByLmluaXQoZCxjKX19LGo9bC5VdGY4PXtzdHJpbmdpZnk6ZnVuY3Rpb24oYSl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKG4uc3RyaW5naWZ5KGEpKSl9Y2F0Y2goYyl7dGhyb3cgRXJyb3IoXCJNYWxmb3JtZWQgVVRGLTggZGF0YVwiKTt9fSxwYXJzZTpmdW5jdGlvbihhKXtyZXR1cm4gbi5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYSkpKX19LFxuXHQgICAgdT1nLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG09bS5leHRlbmQoe3Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fZGF0YT1uZXcgci5pbml0O3RoaXMuX25EYXRhQnl0ZXM9MH0sX2FwcGVuZDpmdW5jdGlvbihhKXtcInN0cmluZ1wiPT10eXBlb2YgYSYmKGE9ai5wYXJzZShhKSk7dGhpcy5fZGF0YS5jb25jYXQoYSk7dGhpcy5fbkRhdGFCeXRlcys9YS5zaWdCeXRlc30sX3Byb2Nlc3M6ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5fZGF0YSxkPWMud29yZHMsYj1jLnNpZ0J5dGVzLGU9dGhpcy5ibG9ja1NpemUsZj1iLyg0KmUpLGY9YT9oLmNlaWwoZik6aC5tYXgoKGZ8MCktdGhpcy5fbWluQnVmZmVyU2l6ZSwwKTthPWYqZTtiPWgubWluKDQqYSxiKTtpZihhKXtmb3IodmFyIGc9MDtnPGE7Zys9ZSl0aGlzLl9kb1Byb2Nlc3NCbG9jayhkLGcpO2c9ZC5zcGxpY2UoMCxhKTtjLnNpZ0J5dGVzLT1ifXJldHVybiBuZXcgci5pbml0KGcsYil9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGE9bS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICBhLl9kYXRhPXRoaXMuX2RhdGEuY2xvbmUoKTtyZXR1cm4gYX0sX21pbkJ1ZmZlclNpemU6MH0pO2cuSGFzaGVyPXUuZXh0ZW5kKHtjZmc6bS5leHRlbmQoKSxpbml0OmZ1bmN0aW9uKGEpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChhKTt0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7dS5yZXNldC5jYWxsKHRoaXMpO3RoaXMuX2RvUmVzZXQoKX0sdXBkYXRlOmZ1bmN0aW9uKGEpe3RoaXMuX2FwcGVuZChhKTt0aGlzLl9wcm9jZXNzKCk7cmV0dXJuIHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKGEpe2EmJnRoaXMuX2FwcGVuZChhKTtyZXR1cm4gdGhpcy5fZG9GaW5hbGl6ZSgpfSxibG9ja1NpemU6MTYsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYyxkKXtyZXR1cm4obmV3IGEuaW5pdChkKSkuZmluYWxpemUoYyl9fSxfY3JlYXRlSG1hY0hlbHBlcjpmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYyxkKXtyZXR1cm4obmV3IHQuSE1BQy5pbml0KGEsXG5cdCAgICBkKSkuZmluYWxpemUoYyl9fX0pO3ZhciB0PWYuYWxnbz17fTtyZXR1cm4gZn0oTWF0aCk7XG5cblx0Ly8gU0hBMjU2XG5cdChmdW5jdGlvbihoKXtmb3IodmFyIHM9Q3J5cHRvSlMsZj1zLmxpYixnPWYuV29yZEFycmF5LHE9Zi5IYXNoZXIsZj1zLmFsZ28sbT1bXSxyPVtdLGw9ZnVuY3Rpb24oYSl7cmV0dXJuIDQyOTQ5NjcyOTYqKGEtKGF8MCkpfDB9LGs9MixuPTA7NjQ+bjspe3ZhciBqO2E6e2o9aztmb3IodmFyIHU9aC5zcXJ0KGopLHQ9Mjt0PD11O3QrKylpZighKGoldCkpe2o9ITE7YnJlYWsgYX1qPSEwfWomJig4Pm4mJihtW25dPWwoaC5wb3coaywwLjUpKSkscltuXT1sKGgucG93KGssMS8zKSksbisrKTtrKyt9dmFyIGE9W10sZj1mLlNIQTI1Nj1xLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBnLmluaXQobS5zbGljZSgwKSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihjLGQpe2Zvcih2YXIgYj10aGlzLl9oYXNoLndvcmRzLGU9YlswXSxmPWJbMV0sZz1iWzJdLGo9YlszXSxoPWJbNF0sbT1iWzVdLG49Yls2XSxxPWJbN10scD0wOzY0PnA7cCsrKXtpZigxNj5wKWFbcF09XG5cdCAgY1tkK3BdfDA7ZWxzZXt2YXIgaz1hW3AtMTVdLGw9YVtwLTJdO2FbcF09KChrPDwyNXxrPj4+NyleKGs8PDE0fGs+Pj4xOCleaz4+PjMpK2FbcC03XSsoKGw8PDE1fGw+Pj4xNyleKGw8PDEzfGw+Pj4xOSlebD4+PjEwKSthW3AtMTZdfWs9cSsoKGg8PDI2fGg+Pj42KV4oaDw8MjF8aD4+PjExKV4oaDw8N3xoPj4+MjUpKSsoaCZtXn5oJm4pK3JbcF0rYVtwXTtsPSgoZTw8MzB8ZT4+PjIpXihlPDwxOXxlPj4+MTMpXihlPDwxMHxlPj4+MjIpKSsoZSZmXmUmZ15mJmcpO3E9bjtuPW07bT1oO2g9aitrfDA7aj1nO2c9ZjtmPWU7ZT1rK2x8MH1iWzBdPWJbMF0rZXwwO2JbMV09YlsxXStmfDA7YlsyXT1iWzJdK2d8MDtiWzNdPWJbM10ranwwO2JbNF09Yls0XStofDA7Yls1XT1iWzVdK218MDtiWzZdPWJbNl0rbnwwO2JbN109Yls3XStxfDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fZGF0YSxkPWEud29yZHMsYj04KnRoaXMuX25EYXRhQnl0ZXMsZT04KmEuc2lnQnl0ZXM7XG5cdCAgZFtlPj4+NV18PTEyODw8MjQtZSUzMjtkWyhlKzY0Pj4+OTw8NCkrMTRdPWguZmxvb3IoYi80Mjk0OTY3Mjk2KTtkWyhlKzY0Pj4+OTw8NCkrMTVdPWI7YS5zaWdCeXRlcz00KmQubGVuZ3RoO3RoaXMuX3Byb2Nlc3MoKTtyZXR1cm4gdGhpcy5faGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgYT1xLmNsb25lLmNhbGwodGhpcyk7YS5faGFzaD10aGlzLl9oYXNoLmNsb25lKCk7cmV0dXJuIGF9fSk7cy5TSEEyNTY9cS5fY3JlYXRlSGVscGVyKGYpO3MuSG1hY1NIQTI1Nj1xLl9jcmVhdGVIbWFjSGVscGVyKGYpfSkoTWF0aCk7XG5cblx0Ly8gSE1BQyBTSEEyNTZcblx0KGZ1bmN0aW9uKCl7dmFyIGg9Q3J5cHRvSlMscz1oLmVuYy5VdGY4O2guYWxnby5ITUFDPWgubGliLkJhc2UuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGYsZyl7Zj10aGlzLl9oYXNoZXI9bmV3IGYuaW5pdDtcInN0cmluZ1wiPT10eXBlb2YgZyYmKGc9cy5wYXJzZShnKSk7dmFyIGg9Zi5ibG9ja1NpemUsbT00Kmg7Zy5zaWdCeXRlcz5tJiYoZz1mLmZpbmFsaXplKGcpKTtnLmNsYW1wKCk7Zm9yKHZhciByPXRoaXMuX29LZXk9Zy5jbG9uZSgpLGw9dGhpcy5faUtleT1nLmNsb25lKCksaz1yLndvcmRzLG49bC53b3JkcyxqPTA7ajxoO2orKylrW2pdXj0xNTQ5NTU2ODI4LG5bal1ePTkwOTUyMjQ4NjtyLnNpZ0J5dGVzPWwuc2lnQnl0ZXM9bTt0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7dmFyIGY9dGhpcy5faGFzaGVyO2YucmVzZXQoKTtmLnVwZGF0ZSh0aGlzLl9pS2V5KX0sdXBkYXRlOmZ1bmN0aW9uKGYpe3RoaXMuX2hhc2hlci51cGRhdGUoZik7cmV0dXJuIHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKGYpe3ZhciBnPVxuXHQgIHRoaXMuX2hhc2hlcjtmPWcuZmluYWxpemUoZik7Zy5yZXNldCgpO3JldHVybiBnLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoZikpfX0pfSkoKTtcblxuXHQvLyBCYXNlNjRcblx0KGZ1bmN0aW9uKCl7dmFyIHU9Q3J5cHRvSlMscD11LmxpYi5Xb3JkQXJyYXk7dS5lbmMuQmFzZTY0PXtzdHJpbmdpZnk6ZnVuY3Rpb24oZCl7dmFyIGw9ZC53b3JkcyxwPWQuc2lnQnl0ZXMsdD10aGlzLl9tYXA7ZC5jbGFtcCgpO2Q9W107Zm9yKHZhciByPTA7cjxwO3IrPTMpZm9yKHZhciB3PShsW3I+Pj4yXT4+PjI0LTgqKHIlNCkmMjU1KTw8MTZ8KGxbcisxPj4+Ml0+Pj4yNC04KigocisxKSU0KSYyNTUpPDw4fGxbcisyPj4+Ml0+Pj4yNC04KigocisyKSU0KSYyNTUsdj0wOzQ+diYmciswLjc1KnY8cDt2KyspZC5wdXNoKHQuY2hhckF0KHc+Pj42KigzLXYpJjYzKSk7aWYobD10LmNoYXJBdCg2NCkpZm9yKDtkLmxlbmd0aCU0OylkLnB1c2gobCk7cmV0dXJuIGQuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24oZCl7dmFyIGw9ZC5sZW5ndGgscz10aGlzLl9tYXAsdD1zLmNoYXJBdCg2NCk7dCYmKHQ9ZC5pbmRleE9mKHQpLC0xIT10JiYobD10KSk7Zm9yKHZhciB0PVtdLHI9MCx3PTA7dzxcblx0bDt3KyspaWYodyU0KXt2YXIgdj1zLmluZGV4T2YoZC5jaGFyQXQody0xKSk8PDIqKHclNCksYj1zLmluZGV4T2YoZC5jaGFyQXQodykpPj4+Ni0yKih3JTQpO3Rbcj4+PjJdfD0odnxiKTw8MjQtOCoociU0KTtyKyt9cmV0dXJuIHAuY3JlYXRlKHQscil9LF9tYXA6XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwifX0pKCk7XG5cblx0Ly8gQmxvY2tDaXBoZXJcblx0KGZ1bmN0aW9uKHUpe2Z1bmN0aW9uIHAoYixuLGEsYyxlLGosayl7Yj1iKyhuJmF8fm4mYykrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZ1bmN0aW9uIGQoYixuLGEsYyxlLGosayl7Yj1iKyhuJmN8YSZ+YykrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZ1bmN0aW9uIGwoYixuLGEsYyxlLGosayl7Yj1iKyhuXmFeYykrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZ1bmN0aW9uIHMoYixuLGEsYyxlLGosayl7Yj1iKyhhXihufH5jKSkrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZvcih2YXIgdD1DcnlwdG9KUyxyPXQubGliLHc9ci5Xb3JkQXJyYXksdj1yLkhhc2hlcixyPXQuYWxnbyxiPVtdLHg9MDs2ND54O3grKyliW3hdPTQyOTQ5NjcyOTYqdS5hYnModS5zaW4oeCsxKSl8MDtyPXIuTUQ1PXYuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IHcuaW5pdChbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4XSl9LFxuXHQgIF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihxLG4pe2Zvcih2YXIgYT0wOzE2PmE7YSsrKXt2YXIgYz1uK2EsZT1xW2NdO3FbY109KGU8PDh8ZT4+PjI0KSYxNjcxMTkzNXwoZTw8MjR8ZT4+PjgpJjQyNzgyNTUzNjB9dmFyIGE9dGhpcy5faGFzaC53b3JkcyxjPXFbbiswXSxlPXFbbisxXSxqPXFbbisyXSxrPXFbbiszXSx6PXFbbis0XSxyPXFbbis1XSx0PXFbbis2XSx3PXFbbis3XSx2PXFbbis4XSxBPXFbbis5XSxCPXFbbisxMF0sQz1xW24rMTFdLHU9cVtuKzEyXSxEPXFbbisxM10sRT1xW24rMTRdLHg9cVtuKzE1XSxmPWFbMF0sbT1hWzFdLGc9YVsyXSxoPWFbM10sZj1wKGYsbSxnLGgsYyw3LGJbMF0pLGg9cChoLGYsbSxnLGUsMTIsYlsxXSksZz1wKGcsaCxmLG0saiwxNyxiWzJdKSxtPXAobSxnLGgsZixrLDIyLGJbM10pLGY9cChmLG0sZyxoLHosNyxiWzRdKSxoPXAoaCxmLG0sZyxyLDEyLGJbNV0pLGc9cChnLGgsZixtLHQsMTcsYls2XSksbT1wKG0sZyxoLGYsdywyMixiWzddKSxcblx0ICAgIGY9cChmLG0sZyxoLHYsNyxiWzhdKSxoPXAoaCxmLG0sZyxBLDEyLGJbOV0pLGc9cChnLGgsZixtLEIsMTcsYlsxMF0pLG09cChtLGcsaCxmLEMsMjIsYlsxMV0pLGY9cChmLG0sZyxoLHUsNyxiWzEyXSksaD1wKGgsZixtLGcsRCwxMixiWzEzXSksZz1wKGcsaCxmLG0sRSwxNyxiWzE0XSksbT1wKG0sZyxoLGYseCwyMixiWzE1XSksZj1kKGYsbSxnLGgsZSw1LGJbMTZdKSxoPWQoaCxmLG0sZyx0LDksYlsxN10pLGc9ZChnLGgsZixtLEMsMTQsYlsxOF0pLG09ZChtLGcsaCxmLGMsMjAsYlsxOV0pLGY9ZChmLG0sZyxoLHIsNSxiWzIwXSksaD1kKGgsZixtLGcsQiw5LGJbMjFdKSxnPWQoZyxoLGYsbSx4LDE0LGJbMjJdKSxtPWQobSxnLGgsZix6LDIwLGJbMjNdKSxmPWQoZixtLGcsaCxBLDUsYlsyNF0pLGg9ZChoLGYsbSxnLEUsOSxiWzI1XSksZz1kKGcsaCxmLG0saywxNCxiWzI2XSksbT1kKG0sZyxoLGYsdiwyMCxiWzI3XSksZj1kKGYsbSxnLGgsRCw1LGJbMjhdKSxoPWQoaCxmLFxuXHQgICAgICBtLGcsaiw5LGJbMjldKSxnPWQoZyxoLGYsbSx3LDE0LGJbMzBdKSxtPWQobSxnLGgsZix1LDIwLGJbMzFdKSxmPWwoZixtLGcsaCxyLDQsYlszMl0pLGg9bChoLGYsbSxnLHYsMTEsYlszM10pLGc9bChnLGgsZixtLEMsMTYsYlszNF0pLG09bChtLGcsaCxmLEUsMjMsYlszNV0pLGY9bChmLG0sZyxoLGUsNCxiWzM2XSksaD1sKGgsZixtLGcseiwxMSxiWzM3XSksZz1sKGcsaCxmLG0sdywxNixiWzM4XSksbT1sKG0sZyxoLGYsQiwyMyxiWzM5XSksZj1sKGYsbSxnLGgsRCw0LGJbNDBdKSxoPWwoaCxmLG0sZyxjLDExLGJbNDFdKSxnPWwoZyxoLGYsbSxrLDE2LGJbNDJdKSxtPWwobSxnLGgsZix0LDIzLGJbNDNdKSxmPWwoZixtLGcsaCxBLDQsYls0NF0pLGg9bChoLGYsbSxnLHUsMTEsYls0NV0pLGc9bChnLGgsZixtLHgsMTYsYls0Nl0pLG09bChtLGcsaCxmLGosMjMsYls0N10pLGY9cyhmLG0sZyxoLGMsNixiWzQ4XSksaD1zKGgsZixtLGcsdywxMCxiWzQ5XSksZz1zKGcsaCxmLG0sXG5cdCAgICAgIEUsMTUsYls1MF0pLG09cyhtLGcsaCxmLHIsMjEsYls1MV0pLGY9cyhmLG0sZyxoLHUsNixiWzUyXSksaD1zKGgsZixtLGcsaywxMCxiWzUzXSksZz1zKGcsaCxmLG0sQiwxNSxiWzU0XSksbT1zKG0sZyxoLGYsZSwyMSxiWzU1XSksZj1zKGYsbSxnLGgsdiw2LGJbNTZdKSxoPXMoaCxmLG0sZyx4LDEwLGJbNTddKSxnPXMoZyxoLGYsbSx0LDE1LGJbNThdKSxtPXMobSxnLGgsZixELDIxLGJbNTldKSxmPXMoZixtLGcsaCx6LDYsYls2MF0pLGg9cyhoLGYsbSxnLEMsMTAsYls2MV0pLGc9cyhnLGgsZixtLGosMTUsYls2Ml0pLG09cyhtLGcsaCxmLEEsMjEsYls2M10pO2FbMF09YVswXStmfDA7YVsxXT1hWzFdK218MDthWzJdPWFbMl0rZ3wwO2FbM109YVszXStofDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5fZGF0YSxuPWIud29yZHMsYT04KnRoaXMuX25EYXRhQnl0ZXMsYz04KmIuc2lnQnl0ZXM7bltjPj4+NV18PTEyODw8MjQtYyUzMjt2YXIgZT11LmZsb29yKGEvXG5cdCAgICA0Mjk0OTY3Mjk2KTtuWyhjKzY0Pj4+OTw8NCkrMTVdPShlPDw4fGU+Pj4yNCkmMTY3MTE5MzV8KGU8PDI0fGU+Pj44KSY0Mjc4MjU1MzYwO25bKGMrNjQ+Pj45PDw0KSsxNF09KGE8PDh8YT4+PjI0KSYxNjcxMTkzNXwoYTw8MjR8YT4+PjgpJjQyNzgyNTUzNjA7Yi5zaWdCeXRlcz00KihuLmxlbmd0aCsxKTt0aGlzLl9wcm9jZXNzKCk7Yj10aGlzLl9oYXNoO249Yi53b3Jkcztmb3IoYT0wOzQ+YTthKyspYz1uW2FdLG5bYV09KGM8PDh8Yz4+PjI0KSYxNjcxMTkzNXwoYzw8MjR8Yz4+PjgpJjQyNzgyNTUzNjA7cmV0dXJuIGJ9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGI9di5jbG9uZS5jYWxsKHRoaXMpO2IuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpO3JldHVybiBifX0pO3QuTUQ1PXYuX2NyZWF0ZUhlbHBlcihyKTt0LkhtYWNNRDU9di5fY3JlYXRlSG1hY0hlbHBlcihyKX0pKE1hdGgpO1xuXHQoZnVuY3Rpb24oKXt2YXIgdT1DcnlwdG9KUyxwPXUubGliLGQ9cC5CYXNlLGw9cC5Xb3JkQXJyYXkscD11LmFsZ28scz1wLkV2cEtERj1kLmV4dGVuZCh7Y2ZnOmQuZXh0ZW5kKHtrZXlTaXplOjQsaGFzaGVyOnAuTUQ1LGl0ZXJhdGlvbnM6MX0pLGluaXQ6ZnVuY3Rpb24oZCl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKGQpfSxjb21wdXRlOmZ1bmN0aW9uKGQscil7Zm9yKHZhciBwPXRoaXMuY2ZnLHM9cC5oYXNoZXIuY3JlYXRlKCksYj1sLmNyZWF0ZSgpLHU9Yi53b3JkcyxxPXAua2V5U2l6ZSxwPXAuaXRlcmF0aW9uczt1Lmxlbmd0aDxxOyl7biYmcy51cGRhdGUobik7dmFyIG49cy51cGRhdGUoZCkuZmluYWxpemUocik7cy5yZXNldCgpO2Zvcih2YXIgYT0xO2E8cDthKyspbj1zLmZpbmFsaXplKG4pLHMucmVzZXQoKTtiLmNvbmNhdChuKX1iLnNpZ0J5dGVzPTQqcTtyZXR1cm4gYn19KTt1LkV2cEtERj1mdW5jdGlvbihkLGwscCl7cmV0dXJuIHMuY3JlYXRlKHApLmNvbXB1dGUoZCxcblx0ICBsKX19KSgpO1xuXG5cdC8vIENpcGhlclxuXHRDcnlwdG9KUy5saWIuQ2lwaGVyfHxmdW5jdGlvbih1KXt2YXIgcD1DcnlwdG9KUyxkPXAubGliLGw9ZC5CYXNlLHM9ZC5Xb3JkQXJyYXksdD1kLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0scj1wLmVuYy5CYXNlNjQsdz1wLmFsZ28uRXZwS0RGLHY9ZC5DaXBoZXI9dC5leHRlbmQoe2NmZzpsLmV4dGVuZCgpLGNyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbihlLGEpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSxlLGEpfSxjcmVhdGVEZWNyeXB0b3I6ZnVuY3Rpb24oZSxhKXtyZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fREVDX1hGT1JNX01PREUsZSxhKX0saW5pdDpmdW5jdGlvbihlLGEsYil7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKGIpO3RoaXMuX3hmb3JtTW9kZT1lO3RoaXMuX2tleT1hO3RoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXt0LnJlc2V0LmNhbGwodGhpcyk7dGhpcy5fZG9SZXNldCgpfSxwcm9jZXNzOmZ1bmN0aW9uKGUpe3RoaXMuX2FwcGVuZChlKTtyZXR1cm4gdGhpcy5fcHJvY2VzcygpfSxcblx0ICBmaW5hbGl6ZTpmdW5jdGlvbihlKXtlJiZ0aGlzLl9hcHBlbmQoZSk7cmV0dXJuIHRoaXMuX2RvRmluYWxpemUoKX0sa2V5U2l6ZTo0LGl2U2l6ZTo0LF9FTkNfWEZPUk1fTU9ERToxLF9ERUNfWEZPUk1fTU9ERToyLF9jcmVhdGVIZWxwZXI6ZnVuY3Rpb24oZSl7cmV0dXJue2VuY3J5cHQ6ZnVuY3Rpb24oYixrLGQpe3JldHVybihcInN0cmluZ1wiPT10eXBlb2Ygaz9jOmEpLmVuY3J5cHQoZSxiLGssZCl9LGRlY3J5cHQ6ZnVuY3Rpb24oYixrLGQpe3JldHVybihcInN0cmluZ1wiPT10eXBlb2Ygaz9jOmEpLmRlY3J5cHQoZSxiLGssZCl9fX19KTtkLlN0cmVhbUNpcGhlcj12LmV4dGVuZCh7X2RvRmluYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvY2VzcyghMCl9LGJsb2NrU2l6ZToxfSk7dmFyIGI9cC5tb2RlPXt9LHg9ZnVuY3Rpb24oZSxhLGIpe3ZhciBjPXRoaXMuX2l2O2M/dGhpcy5faXY9dTpjPXRoaXMuX3ByZXZCbG9jaztmb3IodmFyIGQ9MDtkPGI7ZCsrKWVbYStkXV49XG5cdCAgY1tkXX0scT0oZC5CbG9ja0NpcGhlck1vZGU9bC5leHRlbmQoe2NyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbihlLGEpe3JldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoZSxhKX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKGUsYSl7cmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShlLGEpfSxpbml0OmZ1bmN0aW9uKGUsYSl7dGhpcy5fY2lwaGVyPWU7dGhpcy5faXY9YX19KSkuZXh0ZW5kKCk7cS5FbmNyeXB0b3I9cS5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLGEpe3ZhciBiPXRoaXMuX2NpcGhlcixjPWIuYmxvY2tTaXplO3guY2FsbCh0aGlzLGUsYSxjKTtiLmVuY3J5cHRCbG9jayhlLGEpO3RoaXMuX3ByZXZCbG9jaz1lLnNsaWNlKGEsYStjKX19KTtxLkRlY3J5cHRvcj1xLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsYSl7dmFyIGI9dGhpcy5fY2lwaGVyLGM9Yi5ibG9ja1NpemUsZD1lLnNsaWNlKGEsYStjKTtiLmRlY3J5cHRCbG9jayhlLGEpO3guY2FsbCh0aGlzLFxuXHQgIGUsYSxjKTt0aGlzLl9wcmV2QmxvY2s9ZH19KTtiPWIuQ0JDPXE7cT0ocC5wYWQ9e30pLlBrY3M3PXtwYWQ6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9NCpiLGM9Yy1hLnNpZ0J5dGVzJWMsZD1jPDwyNHxjPDwxNnxjPDw4fGMsbD1bXSxuPTA7bjxjO24rPTQpbC5wdXNoKGQpO2M9cy5jcmVhdGUobCxjKTthLmNvbmNhdChjKX0sdW5wYWQ6ZnVuY3Rpb24oYSl7YS5zaWdCeXRlcy09YS53b3Jkc1thLnNpZ0J5dGVzLTE+Pj4yXSYyNTV9fTtkLkJsb2NrQ2lwaGVyPXYuZXh0ZW5kKHtjZmc6di5jZmcuZXh0ZW5kKHttb2RlOmIscGFkZGluZzpxfSkscmVzZXQ6ZnVuY3Rpb24oKXt2LnJlc2V0LmNhbGwodGhpcyk7dmFyIGE9dGhpcy5jZmcsYj1hLml2LGE9YS5tb2RlO2lmKHRoaXMuX3hmb3JtTW9kZT09dGhpcy5fRU5DX1hGT1JNX01PREUpdmFyIGM9YS5jcmVhdGVFbmNyeXB0b3I7ZWxzZSBjPWEuY3JlYXRlRGVjcnlwdG9yLHRoaXMuX21pbkJ1ZmZlclNpemU9MTt0aGlzLl9tb2RlPWMuY2FsbChhLFxuXHQgIHRoaXMsYiYmYi53b3Jkcyl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihhLGIpe3RoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKGEsYil9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jZmcucGFkZGluZztpZih0aGlzLl94Zm9ybU1vZGU9PXRoaXMuX0VOQ19YRk9STV9NT0RFKXthLnBhZCh0aGlzLl9kYXRhLHRoaXMuYmxvY2tTaXplKTt2YXIgYj10aGlzLl9wcm9jZXNzKCEwKX1lbHNlIGI9dGhpcy5fcHJvY2VzcyghMCksYS51bnBhZChiKTtyZXR1cm4gYn0sYmxvY2tTaXplOjR9KTt2YXIgbj1kLkNpcGhlclBhcmFtcz1sLmV4dGVuZCh7aW5pdDpmdW5jdGlvbihhKXt0aGlzLm1peEluKGEpfSx0b1N0cmluZzpmdW5jdGlvbihhKXtyZXR1cm4oYXx8dGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKX19KSxiPShwLmZvcm1hdD17fSkuT3BlblNTTD17c3RyaW5naWZ5OmZ1bmN0aW9uKGEpe3ZhciBiPWEuY2lwaGVydGV4dDthPWEuc2FsdDtyZXR1cm4oYT9zLmNyZWF0ZShbMTM5ODg5MzY4NCxcblx0ICAxNzAxMDc2ODMxXSkuY29uY2F0KGEpLmNvbmNhdChiKTpiKS50b1N0cmluZyhyKX0scGFyc2U6ZnVuY3Rpb24oYSl7YT1yLnBhcnNlKGEpO3ZhciBiPWEud29yZHM7aWYoMTM5ODg5MzY4ND09YlswXSYmMTcwMTA3NjgzMT09YlsxXSl7dmFyIGM9cy5jcmVhdGUoYi5zbGljZSgyLDQpKTtiLnNwbGljZSgwLDQpO2Euc2lnQnl0ZXMtPTE2fXJldHVybiBuLmNyZWF0ZSh7Y2lwaGVydGV4dDphLHNhbHQ6Y30pfX0sYT1kLlNlcmlhbGl6YWJsZUNpcGhlcj1sLmV4dGVuZCh7Y2ZnOmwuZXh0ZW5kKHtmb3JtYXQ6Yn0pLGVuY3J5cHQ6ZnVuY3Rpb24oYSxiLGMsZCl7ZD10aGlzLmNmZy5leHRlbmQoZCk7dmFyIGw9YS5jcmVhdGVFbmNyeXB0b3IoYyxkKTtiPWwuZmluYWxpemUoYik7bD1sLmNmZztyZXR1cm4gbi5jcmVhdGUoe2NpcGhlcnRleHQ6YixrZXk6YyxpdjpsLml2LGFsZ29yaXRobTphLG1vZGU6bC5tb2RlLHBhZGRpbmc6bC5wYWRkaW5nLGJsb2NrU2l6ZTphLmJsb2NrU2l6ZSxmb3JtYXR0ZXI6ZC5mb3JtYXR9KX0sXG5cdCAgZGVjcnlwdDpmdW5jdGlvbihhLGIsYyxkKXtkPXRoaXMuY2ZnLmV4dGVuZChkKTtiPXRoaXMuX3BhcnNlKGIsZC5mb3JtYXQpO3JldHVybiBhLmNyZWF0ZURlY3J5cHRvcihjLGQpLmZpbmFsaXplKGIuY2lwaGVydGV4dCl9LF9wYXJzZTpmdW5jdGlvbihhLGIpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhP2IucGFyc2UoYSx0aGlzKTphfX0pLHA9KHAua2RmPXt9KS5PcGVuU1NMPXtleGVjdXRlOmZ1bmN0aW9uKGEsYixjLGQpe2R8fChkPXMucmFuZG9tKDgpKTthPXcuY3JlYXRlKHtrZXlTaXplOmIrY30pLmNvbXB1dGUoYSxkKTtjPXMuY3JlYXRlKGEud29yZHMuc2xpY2UoYiksNCpjKTthLnNpZ0J5dGVzPTQqYjtyZXR1cm4gbi5jcmVhdGUoe2tleTphLGl2OmMsc2FsdDpkfSl9fSxjPWQuUGFzc3dvcmRCYXNlZENpcGhlcj1hLmV4dGVuZCh7Y2ZnOmEuY2ZnLmV4dGVuZCh7a2RmOnB9KSxlbmNyeXB0OmZ1bmN0aW9uKGIsYyxkLGwpe2w9dGhpcy5jZmcuZXh0ZW5kKGwpO2Q9bC5rZGYuZXhlY3V0ZShkLFxuXHQgIGIua2V5U2l6ZSxiLml2U2l6ZSk7bC5pdj1kLml2O2I9YS5lbmNyeXB0LmNhbGwodGhpcyxiLGMsZC5rZXksbCk7Yi5taXhJbihkKTtyZXR1cm4gYn0sZGVjcnlwdDpmdW5jdGlvbihiLGMsZCxsKXtsPXRoaXMuY2ZnLmV4dGVuZChsKTtjPXRoaXMuX3BhcnNlKGMsbC5mb3JtYXQpO2Q9bC5rZGYuZXhlY3V0ZShkLGIua2V5U2l6ZSxiLml2U2l6ZSxjLnNhbHQpO2wuaXY9ZC5pdjtyZXR1cm4gYS5kZWNyeXB0LmNhbGwodGhpcyxiLGMsZC5rZXksbCl9fSl9KCk7XG5cblx0Ly8gQUVTXG5cdChmdW5jdGlvbigpe2Zvcih2YXIgdT1DcnlwdG9KUyxwPXUubGliLkJsb2NrQ2lwaGVyLGQ9dS5hbGdvLGw9W10scz1bXSx0PVtdLHI9W10sdz1bXSx2PVtdLGI9W10seD1bXSxxPVtdLG49W10sYT1bXSxjPTA7MjU2PmM7YysrKWFbY109MTI4PmM/Yzw8MTpjPDwxXjI4Mztmb3IodmFyIGU9MCxqPTAsYz0wOzI1Nj5jO2MrKyl7dmFyIGs9al5qPDwxXmo8PDJeajw8M15qPDw0LGs9az4+PjheayYyNTVeOTk7bFtlXT1rO3Nba109ZTt2YXIgej1hW2VdLEY9YVt6XSxHPWFbRl0seT0yNTcqYVtrXV4xNjg0MzAwOCprO3RbZV09eTw8MjR8eT4+Pjg7cltlXT15PDwxNnx5Pj4+MTY7d1tlXT15PDw4fHk+Pj4yNDt2W2VdPXk7eT0xNjg0MzAwOSpHXjY1NTM3KkZeMjU3KnpeMTY4NDMwMDgqZTtiW2tdPXk8PDI0fHk+Pj44O3hba109eTw8MTZ8eT4+PjE2O3Fba109eTw8OHx5Pj4+MjQ7bltrXT15O2U/KGU9el5hW2FbYVtHXnpdXV0sal49YVthW2pdXSk6ZT1qPTF9dmFyIEg9WzAsMSwyLDQsOCxcblx0ICAxNiwzMiw2NCwxMjgsMjcsNTRdLGQ9ZC5BRVM9cC5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuX2tleSxjPWEud29yZHMsZD1hLnNpZ0J5dGVzLzQsYT00KigodGhpcy5fblJvdW5kcz1kKzYpKzEpLGU9dGhpcy5fa2V5U2NoZWR1bGU9W10saj0wO2o8YTtqKyspaWYoajxkKWVbal09Y1tqXTtlbHNle3ZhciBrPWVbai0xXTtqJWQ/NjxkJiY0PT1qJWQmJihrPWxbaz4+PjI0XTw8MjR8bFtrPj4+MTYmMjU1XTw8MTZ8bFtrPj4+OCYyNTVdPDw4fGxbayYyNTVdKTooaz1rPDw4fGs+Pj4yNCxrPWxbaz4+PjI0XTw8MjR8bFtrPj4+MTYmMjU1XTw8MTZ8bFtrPj4+OCYyNTVdPDw4fGxbayYyNTVdLGtePUhbai9kfDBdPDwyNCk7ZVtqXT1lW2otZF1ea31jPXRoaXMuX2ludktleVNjaGVkdWxlPVtdO2ZvcihkPTA7ZDxhO2QrKylqPWEtZCxrPWQlND9lW2pdOmVbai00XSxjW2RdPTQ+ZHx8ND49aj9rOmJbbFtrPj4+MjRdXV54W2xbaz4+PjE2JjI1NV1dXnFbbFtrPj4+XG5cdDgmMjU1XV1ebltsW2smMjU1XV19LGVuY3J5cHRCbG9jazpmdW5jdGlvbihhLGIpe3RoaXMuX2RvQ3J5cHRCbG9jayhhLGIsdGhpcy5fa2V5U2NoZWR1bGUsdCxyLHcsdixsKX0sZGVjcnlwdEJsb2NrOmZ1bmN0aW9uKGEsYyl7dmFyIGQ9YVtjKzFdO2FbYysxXT1hW2MrM107YVtjKzNdPWQ7dGhpcy5fZG9DcnlwdEJsb2NrKGEsYyx0aGlzLl9pbnZLZXlTY2hlZHVsZSxiLHgscSxuLHMpO2Q9YVtjKzFdO2FbYysxXT1hW2MrM107YVtjKzNdPWR9LF9kb0NyeXB0QmxvY2s6ZnVuY3Rpb24oYSxiLGMsZCxlLGosbCxmKXtmb3IodmFyIG09dGhpcy5fblJvdW5kcyxnPWFbYl1eY1swXSxoPWFbYisxXV5jWzFdLGs9YVtiKzJdXmNbMl0sbj1hW2IrM11eY1szXSxwPTQscj0xO3I8bTtyKyspdmFyIHE9ZFtnPj4+MjRdXmVbaD4+PjE2JjI1NV1ealtrPj4+OCYyNTVdXmxbbiYyNTVdXmNbcCsrXSxzPWRbaD4+PjI0XV5lW2s+Pj4xNiYyNTVdXmpbbj4+PjgmMjU1XV5sW2cmMjU1XV5jW3ArK10sdD1cblx0ICBkW2s+Pj4yNF1eZVtuPj4+MTYmMjU1XV5qW2c+Pj44JjI1NV1ebFtoJjI1NV1eY1twKytdLG49ZFtuPj4+MjRdXmVbZz4+PjE2JjI1NV1ealtoPj4+OCYyNTVdXmxbayYyNTVdXmNbcCsrXSxnPXEsaD1zLGs9dDtxPShmW2c+Pj4yNF08PDI0fGZbaD4+PjE2JjI1NV08PDE2fGZbaz4+PjgmMjU1XTw8OHxmW24mMjU1XSleY1twKytdO3M9KGZbaD4+PjI0XTw8MjR8ZltrPj4+MTYmMjU1XTw8MTZ8ZltuPj4+OCYyNTVdPDw4fGZbZyYyNTVdKV5jW3ArK107dD0oZltrPj4+MjRdPDwyNHxmW24+Pj4xNiYyNTVdPDwxNnxmW2c+Pj44JjI1NV08PDh8ZltoJjI1NV0pXmNbcCsrXTtuPShmW24+Pj4yNF08PDI0fGZbZz4+PjE2JjI1NV08PDE2fGZbaD4+PjgmMjU1XTw8OHxmW2smMjU1XSleY1twKytdO2FbYl09cTthW2IrMV09czthW2IrMl09dDthW2IrM109bn0sa2V5U2l6ZTo4fSk7dS5BRVM9cC5fY3JlYXRlSGVscGVyKGQpfSkoKTtcblxuXHQvLyBNb2RlIEVDQlxuXHRDcnlwdG9KUy5tb2RlLkVDQiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIEVDQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICBFQ0IuRW5jcnlwdG9yID0gRUNCLmV4dGVuZCh7XG5cdCAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICBFQ0IuRGVjcnlwdG9yID0gRUNCLmV4dGVuZCh7XG5cdCAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgIHRoaXMuX2NpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICByZXR1cm4gRUNCO1xuXHR9KCkpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQ3J5cHRvSlM7XG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBXRUJTT0NLRVQgSU5URVJGQUNFXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHR2YXIgV1MgPSBmdW5jdGlvbiggdXJsLCBwcm90b2NvbHMgKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdTKSkgcmV0dXJuIG5ldyBXUyggdXJsLCBwcm90b2NvbHMgKTtcblxuXHQgIHZhciBzZWxmICAgICA9IHRoaXNcblx0ICAgICwgICB1cmwgICAgICA9IHNlbGYudXJsICAgICAgPSB1cmwgfHwgJydcblx0ICAgICwgICBwcm90b2NvbCA9IHNlbGYucHJvdG9jb2wgPSBwcm90b2NvbHMgfHwgJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXG5cdCAgICAsICAgYml0cyAgICAgPSB1cmwuc3BsaXQoJy8nKVxuXHQgICAgLCAgIHNldHVwICAgID0ge1xuXHQgICAgJ3NzbCcgICAgICAgICAgIDogYml0c1swXSA9PT0gJ3dzczonXG5cdCAgICAsJ29yaWdpbicgICAgICAgIDogYml0c1syXVxuXHQgICAgLCdwdWJsaXNoX2tleScgICA6IGJpdHNbM11cblx0ICAgICwnc3Vic2NyaWJlX2tleScgOiBiaXRzWzRdXG5cdCAgICAsJ2NoYW5uZWwnICAgICAgIDogYml0c1s1XVxuXHQgIH07XG5cblx0ICAvLyBSRUFEWSBTVEFURVNcblx0ICBzZWxmWydDT05ORUNUSU5HJ10gPSAwOyAvLyBUaGUgY29ubmVjdGlvbiBpcyBub3QgeWV0IG9wZW4uXG5cdCAgc2VsZlsnT1BFTiddICAgICAgID0gMTsgLy8gVGhlIGNvbm5lY3Rpb24gaXMgb3BlbiBhbmQgcmVhZHkgdG8gY29tbXVuaWNhdGUuXG5cdCAgc2VsZlsnQ0xPU0lORyddICAgID0gMjsgLy8gVGhlIGNvbm5lY3Rpb24gaXMgaW4gdGhlIHByb2Nlc3Mgb2YgY2xvc2luZy5cblx0ICBzZWxmWydDTE9TRUQnXSAgICAgPSAzOyAvLyBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQgb3IgY291bGRuJ3QgYmUgb3BlbmVkLlxuXG5cdCAgLy8gQ0xPU0UgU1RBVEVTXG5cdCAgc2VsZlsnQ0xPU0VfTk9STUFMJ10gICAgICAgICA9IDEwMDA7IC8vIE5vcm1hbCBJbnRlbmRlZCBDbG9zZTsgY29tcGxldGVkLlxuXHQgIHNlbGZbJ0NMT1NFX0dPSU5HX0FXQVknXSAgICAgPSAxMDAxOyAvLyBDbG9zZWQgVW5leHBlY3R0ZWRseS5cblx0ICBzZWxmWydDTE9TRV9QUk9UT0NPTF9FUlJPUiddID0gMTAwMjsgLy8gU2VydmVyOiBOb3QgU3VwcG9ydGVkLlxuXHQgIHNlbGZbJ0NMT1NFX1VOU1VQUE9SVEVEJ10gICAgPSAxMDAzOyAvLyBTZXJ2ZXI6IFVuc3VwcG9ydGVkIFByb3RvY29sLlxuXHQgIHNlbGZbJ0NMT1NFX1RPT19MQVJHRSddICAgICAgPSAxMDA0OyAvLyBTZXJ2ZXI6IFRvbyBNdWNoIERhdGEuXG5cdCAgc2VsZlsnQ0xPU0VfTk9fU1RBVFVTJ10gICAgICA9IDEwMDU7IC8vIFNlcnZlcjogTm8gcmVhc29uLlxuXHQgIHNlbGZbJ0NMT1NFX0FCTk9STUFMJ10gICAgICAgPSAxMDA2OyAvLyBBYm5vcm1hbCBEaXNjb25uZWN0LlxuXG5cdCAgLy8gRXZlbnRzIERlZmF1bHRcblx0ICBzZWxmWydvbmNsb3NlJ10gICA9IHNlbGZbJ29uZXJyb3InXSA9XG5cdCAgICBzZWxmWydvbm1lc3NhZ2UnXSA9IHNlbGZbJ29ub3BlbiddICA9XG5cdCAgICAgIHNlbGZbJ29uc2VuZCddICAgID0gIGZ1bmN0aW9uKCl7fTtcblxuXHQgIC8vIEF0dHJpYnV0ZXNcblx0ICBzZWxmWydiaW5hcnlUeXBlJ10gICAgID0gJyc7XG5cdCAgc2VsZlsnZXh0ZW5zaW9ucyddICAgICA9ICcnO1xuXHQgIHNlbGZbJ2J1ZmZlcmVkQW1vdW50J10gPSAwO1xuXHQgIHNlbGZbJ3RyYXNubWl0dGluZyddICAgPSBmYWxzZTtcblx0ICBzZWxmWydidWZmZXInXSAgICAgICAgID0gW107XG5cdCAgc2VsZlsncmVhZHlTdGF0ZSddICAgICA9IHNlbGZbJ0NPTk5FQ1RJTkcnXTtcblxuXHQgIC8vIENsb3NlIGlmIG5vIHNldHVwLlxuXHQgIGlmICghdXJsKSB7XG5cdCAgICBzZWxmWydyZWFkeVN0YXRlJ10gPSBzZWxmWydDTE9TRUQnXTtcblx0ICAgIHNlbGZbJ29uY2xvc2UnXSh7XG5cdCAgICAgICdjb2RlJyAgICAgOiBzZWxmWydDTE9TRV9BQk5PUk1BTCddLFxuXHQgICAgICAncmVhc29uJyAgIDogJ01pc3NpbmcgVVJMJyxcblx0ICAgICAgJ3dhc0NsZWFuJyA6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHNlbGY7XG5cdCAgfVxuXG5cdCAgLy8gUHViTnViIFdlYlNvY2tldCBFbXVsYXRpb25cblx0ICBzZWxmLnB1Ym51YiAgICAgICA9IFBVQk5VQlsnaW5pdCddKHNldHVwKTtcblx0ICBzZWxmLnB1Ym51Yi5zZXR1cCA9IHNldHVwO1xuXHQgIHNlbGYuc2V0dXAgICAgICAgID0gc2V0dXA7XG5cblx0ICBzZWxmLnB1Ym51Ylsnc3Vic2NyaWJlJ10oe1xuXHQgICAgJ3Jlc3RvcmUnICAgIDogZmFsc2UsXG5cdCAgICAnY2hhbm5lbCcgICAgOiBzZXR1cFsnY2hhbm5lbCddLFxuXHQgICAgJ2Rpc2Nvbm5lY3QnIDogc2VsZlsnb25lcnJvciddLFxuXHQgICAgJ3JlY29ubmVjdCcgIDogc2VsZlsnb25vcGVuJ10sXG5cdCAgICAnZXJyb3InICAgICAgOiBmdW5jdGlvbigpIHtcblx0ICAgICAgc2VsZlsnb25jbG9zZSddKHtcblx0ICAgICAgICAnY29kZScgICAgIDogc2VsZlsnQ0xPU0VfQUJOT1JNQUwnXSxcblx0ICAgICAgICAncmVhc29uJyAgIDogJ01pc3NpbmcgVVJMJyxcblx0ICAgICAgICAnd2FzQ2xlYW4nIDogZmFsc2Vcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgJ2NhbGxiYWNrJyAgIDogZnVuY3Rpb24obWVzc2FnZSkge1xuXHQgICAgICBzZWxmWydvbm1lc3NhZ2UnXSh7ICdkYXRhJyA6IG1lc3NhZ2UgfSk7XG5cdCAgICB9LFxuXHQgICAgJ2Nvbm5lY3QnICAgIDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHNlbGZbJ3JlYWR5U3RhdGUnXSA9IHNlbGZbJ09QRU4nXTtcblx0ICAgICAgc2VsZlsnb25vcGVuJ10oKTtcblx0ICAgIH1cblx0ICB9KTtcblx0fTtcblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gV0VCU09DS0VUIFNFTkRcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFdTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBzZWxmLnB1Ym51YlsncHVibGlzaCddKHtcblx0ICAgICdjaGFubmVsJyAgOiBzZWxmLnB1Ym51Yi5zZXR1cFsnY2hhbm5lbCddLFxuXHQgICAgJ21lc3NhZ2UnICA6IGRhdGEsXG5cdCAgICAnY2FsbGJhY2snIDogZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0ICAgICAgc2VsZlsnb25zZW5kJ10oeyAnZGF0YScgOiByZXNwb25zZSB9KTtcblx0ICAgIH1cblx0ICB9KTtcblx0fTtcblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gV0VCU09DS0VUIENMT1NFXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRXUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgc2VsZi5wdWJudWJbJ3Vuc3Vic2NyaWJlJ10oeyAnY2hhbm5lbCcgOiBzZWxmLnB1Ym51Yi5zZXR1cFsnY2hhbm5lbCddIH0pO1xuXHQgIHNlbGZbJ3JlYWR5U3RhdGUnXSA9IHNlbGZbJ0NMT1NFRCddO1xuXHQgIHNlbGZbJ29uY2xvc2UnXSh7fSk7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBXUztcblxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcHVibnViL21vZGVybi9kaXN0L3B1Ym51Yi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQ2xpZW50XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJpbmdDZW50cmFsXCJdID0gcm9vdFtcIlJpbmdDZW50cmFsXCJdIHx8IHt9LCByb290W1wiUmluZ0NlbnRyYWxcIl1bXCJDbGllbnRcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBhY2NvdW50Q2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBjYWxsTG9nQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG52YXIgZGljdGlvbmFyeUNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xudmFyIGV4dGVuc2lvbkNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xudmFyIG1lc3NhZ2VzQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG52YXIgbm90aWZpY2F0aW9uc0NsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xudmFyIHByZXNlbmNlQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XG52YXIgcmluZ291dENsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOTMpO1xudmFyIGZvcndhcmRpbmdOdW1iZXJzQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nik7XG52YXIgYmxvY2tlZE51bWJlcnNDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KTtcbnZhciBDbGllbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsaWVudChzZGspIHtcbiAgICAgICAgdGhpcy5fc2RrID0gc2RrO1xuICAgICAgICB0aGlzLl9hY2NvdW50ID0gbmV3IGFjY291bnRDbGllbnQuQWNjb3VudChzZGspO1xuICAgICAgICB0aGlzLl9jYWxsTG9nID0gbmV3IGNhbGxMb2dDbGllbnQuQ2FsbExvZyhzZGspO1xuICAgICAgICB0aGlzLl9kaWN0aW9uYXJ5ID0gbmV3IGRpY3Rpb25hcnlDbGllbnQuRGljdGlvbmFyeShzZGspO1xuICAgICAgICB0aGlzLl9leHRlbnNpb24gPSBuZXcgZXh0ZW5zaW9uQ2xpZW50LkV4dGVuc2lvbihzZGspO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IG5ldyBtZXNzYWdlc0NsaWVudC5NZXNzYWdlcyhzZGspO1xuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25zID0gbmV3IG5vdGlmaWNhdGlvbnNDbGllbnQuTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSShzZGspO1xuICAgICAgICB0aGlzLl9wcmVzZW5jZSA9IG5ldyBwcmVzZW5jZUNsaWVudC5QcmVzZW5jZShzZGspO1xuICAgICAgICB0aGlzLl9yaW5nb3V0ID0gbmV3IHJpbmdvdXRDbGllbnQuUmluZ091dChzZGspO1xuICAgICAgICB0aGlzLl9mb3J3YXJkaW5nTnVtYmVycyA9IG5ldyBmb3J3YXJkaW5nTnVtYmVyc0NsaWVudC5Gb3J3YXJkaW5nTnVtYmVycyhzZGspO1xuICAgICAgICB0aGlzLl9ibG9ja2VkTnVtYmVycyA9IG5ldyBibG9ja2VkTnVtYmVyc0NsaWVudC5CbG9ja2VkTnVtYmVycyhzZGspO1xuICAgIH1cbiAgICBDbGllbnQucHJvdG90eXBlLmFjY291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hY2NvdW50OyB9O1xuICAgIENsaWVudC5wcm90b3R5cGUuY2FsbExvZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NhbGxMb2c7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5kaWN0aW9uYXJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGljdGlvbmFyeTsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmV4dGVuc2lvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2V4dGVuc2lvbjsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLm1lc3NhZ2VzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWVzc2FnZXM7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5ub3RpZmljYXRpb25zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbm90aWZpY2F0aW9uczsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLnByZXNlbmNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJlc2VuY2U7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5yaW5nb3V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmluZ291dDsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmZvcndhcmRpbmdOdW1iZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZm9yd2FyZGluZ051bWJlcnM7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5ibG9ja2VkTnVtYmVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Jsb2NrZWROdW1iZXJzOyB9O1xuICAgIENsaWVudC52ZXJzaW9uID0gJzAuMS4wJztcbiAgICByZXR1cm4gQ2xpZW50O1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50O1xuXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBhY2NvdW50aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgYWNjb3VudGJ1c2luZXNzYWRkcmVzcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xudmFyIGRpYWxpbmdwbGFuaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xudmFyIHBob25lbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIGFjY291bnRwaG9uZW51bWJlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcbnZhciBhY2NvdW50c2VydmljZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbnZhciBBY2NvdW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIEFjY291bnRcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPkNyZWF0ZXMgdGhlIGFjY291bnQgaW4gSW5pdGlhbCBzdGF0ZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+TWFuYWdpbmcgYWNjb3VudHM6IGNyZWF0aW5nIG5ldyBhY2NvdW50cywgdmlld2luZyBhbmQgdXBkYXRpbmcgYWNjb3VudCBpbmZvcm1hdGlvbiwgZGVsZXRpbmcgZXhpc3RpbmcgYWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlciwgYXNzaWduZWQgcGhvbmUgbnVtYmVycywgZGV2aWNlcyBhbmQgb3RoZXIgZXh0ZW5zaW9uIHNldHRpbmdzKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmNyZWF0ZUFjY291bnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudCcsIG9wdGlvbnMsIGV4cG9ydHMuY3JlYXRlQWNjb3VudE9wdGlvbnMpLCBhY2NvdW50aW5mby5BY2NvdW50SW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWNjb3VudCBJbmZvXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMDwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGEgcGFydGljdWxhciBSaW5nQ2VudHJhbCBjdXN0b21lciBhY2NvdW50LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxvYWRBY2NvdW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEFjY291bnRPcHRpb25zKSwgYWNjb3VudGluZm8uQWNjb3VudEluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgQnVzaW5lc3MgQWRkcmVzc1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxvYWRBY2NvdW50QnVzaW5lc3NBZGRyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9idXNpbmVzcy1hZGRyZXNzJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQWNjb3VudEJ1c2luZXNzQWRkcmVzc09wdGlvbnMpLCBhY2NvdW50aW5mby5BY2NvdW50SW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgQWNjb3VudCBCdXNpbmVzcyBBZGRyZXNzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0QWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUudXBkYXRlQWNjb3VudEJ1c2luZXNzQWRkcmVzcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BVVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vYnVzaW5lc3MtYWRkcmVzcycsIG9wdGlvbnMsIGV4cG9ydHMudXBkYXRlQWNjb3VudEJ1c2luZXNzQWRkcmVzc09wdGlvbnMpLCBhY2NvdW50YnVzaW5lc3NhZGRyZXNzLkFjY291bnRCdXNpbmVzc0FkZHJlc3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgRGlhbGluZyBQbGFuXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+UmV0dXJucyBsaXN0IG9mIGNvdW50cmllcyB3aGljaCBjYW4gYmUgc2VsZWN0ZWQgZm9yIGEgZGlhbGluZyBwbGFuICh0byBjYWxsIHNob3J0IG51bWJlcnMgYW5kIHNwZWNpYWwgc2VydmljZXMpLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxpc3REaWFsaW5nUGxhbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2RpYWxpbmctcGxhbicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdERpYWxpbmdQbGFuc09wdGlvbnMpLCBkaWFsaW5ncGxhbmluZm8uRGlhbGluZ1BsYW5JbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3Zpc2lvbiBQaG9uZSBOdW1iZXJzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTEgKFJlbGVhc2UgNi4zKTwvcD5cbiAgICAgKiA8cD5Qcm92aXNpb25zIGEgcGhvbmUgbnVtYmVyLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLnByb3Zpc2lvblBob25lTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vcGhvbmUtbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5wcm92aXNpb25QaG9uZU51bWJlck9wdGlvbnMpLCBwaG9uZW51bWJlcmluZm8uUGhvbmVOdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBBY2NvdW50IFBob25lIE51bWJlcnNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgcGhvbmUgbnVtYmVycyBhc3NpZ25lZCB0byB0aGUgUmluZ0NlbnRyYWwgY3VzdG9tZXIgYWNjb3VudC4gQm90aCBjb21wYW55LWxldmVsIGFuZCBleHRlbnNpb24tbGV2ZWwgbnVtYmVycyBhcmUgcmV0dXJuZWQuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUubGlzdEFjY291bnRQaG9uZU51bWJlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L3Bob25lLW51bWJlcicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEFjY291bnRQaG9uZU51bWJlcnNPcHRpb25zKSwgYWNjb3VudHBob25lbnVtYmVycy5BY2NvdW50UGhvbmVOdW1iZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBQaG9uZSBOdW1iZXIocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS5sb2FkQWNjb3VudFBob25lTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9waG9uZS1udW1iZXIve3Bob25lTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQWNjb3VudFBob25lTnVtYmVyT3B0aW9ucyksIHBob25lbnVtYmVyaW5mby5QaG9uZU51bWJlckluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgU2VydmljZSBJbmZvXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMDwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBzZXJ2aWNlIHBsYW4sIGF2YWlsYWJsZSBmZWF0dXJlcyBhbmQgbGltaXRhdGlvbnMgZm9yIGEgcGFydGljdWxhciBSaW5nQ2VudHJhbCBjdXN0b21lciBhY2NvdW50LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxvYWRTZXJ2aWNlSW5mbyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vc2VydmljZS1pbmZvJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkU2VydmljZUluZm9PcHRpb25zKSwgYWNjb3VudHNlcnZpY2VpbmZvLkFjY291bnRTZXJ2aWNlSW5mbyk7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudDtcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5BY2NvdW50ID0gQWNjb3VudDtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBjcmVhdGVBY2NvdW50IG9wZXJhdGlvblxuICovXG5leHBvcnRzLmNyZWF0ZUFjY291bnRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcImNyZWF0ZWFjY291bnRyZXF1ZXN0LkNyZWF0ZUFjY291bnRSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRBY2NvdW50IG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRBY2NvdW50T3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRBY2NvdW50QnVzaW5lc3NBZGRyZXNzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRBY2NvdW50QnVzaW5lc3NBZGRyZXNzT3B0aW9ucyA9IFtdO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHVwZGF0ZUFjY291bnRCdXNpbmVzc0FkZHJlc3Mgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlQWNjb3VudEJ1c2luZXNzQWRkcmVzc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibW9kaWZ5YWNjb3VudGJ1c2luZXNzYWRkcmVzc3JlcXVlc3QuTW9kaWZ5QWNjb3VudEJ1c2luZXNzQWRkcmVzc1JlcXVlc3RcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdERpYWxpbmdQbGFucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RGlhbGluZ1BsYW5zT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHByb3Zpc2lvblBob25lTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnByb3Zpc2lvblBob25lTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcInByb3Zpc2lvbnBob25lbnVtYmVycy5Qcm92aXNpb25QaG9uZU51bWJlcnNcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEFjY291bnRQaG9uZU51bWJlcnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEFjY291bnRQaG9uZU51bWJlcnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ1c2FnZVR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiTWFpbkNvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiQ29tcGFueU51bWJlclwiLFxuICAgICAgICAgICAgXCJEaXJlY3ROdW1iZXJcIixcbiAgICAgICAgICAgIFwiQ29tcGFueUZheE51bWJlclwiLFxuICAgICAgICAgICAgXCJGb3J3YXJkZWROdW1iZXJcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEFjY291bnRQaG9uZU51bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQWNjb3VudFBob25lTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGhvbmVOdW1iZXJJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkU2VydmljZUluZm8gb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFNlcnZpY2VJbmZvT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuKGZ1bmN0aW9uIChJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGUpIHtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiTWFpbkNvbXBhbnlOdW1iZXJcIl0gPSAnTWFpbkNvbXBhbnlOdW1iZXInXSA9IFwiTWFpbkNvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIl0gPSAnQWRkaXRpb25hbENvbXBhbnlOdW1iZXInXSA9IFwiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQ29tcGFueU51bWJlclwiXSA9ICdDb21wYW55TnVtYmVyJ10gPSBcIkNvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiRGlyZWN0TnVtYmVyXCJdID0gJ0RpcmVjdE51bWJlciddID0gXCJEaXJlY3ROdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQ29tcGFueUZheE51bWJlclwiXSA9ICdDb21wYW55RmF4TnVtYmVyJ10gPSBcIkNvbXBhbnlGYXhOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiRm9yd2FyZGVkTnVtYmVyXCJdID0gJ0ZvcndhcmRlZE51bWJlciddID0gXCJGb3J3YXJkZWROdW1iZXJcIjtcbn0pKGV4cG9ydHMuSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlIHx8IChleHBvcnRzLklMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlID0gZXhwb3J0cy5JTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ2xpZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGllbnQoc2RrKSB7XG4gICAgICAgIHRoaXMuX3NkayA9IHNkaztcbiAgICB9XG4gICAgQ2xpZW50LnByb3RvdHlwZS5wYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIG9wdGlvbnMsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgICAgICAgIGJvZHk6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICBpZiAocGFyYW0ucmVxdWlyZWQgJiYgIXBhcmFtLmRlZmF1bHQgJiYgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkocGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIHBhcmFtZXRlciBcIicgKyBwYXJhbS5uYW1lICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLmRlZmF1bHQgJiYgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkocGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW3BhcmFtLm5hbWVdID0gcGFyYW0uZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS5pbiA9PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnVybCA9IHJlcXVlc3QudXJsLnJlcGxhY2UoJ3snICsgcGFyYW0ubmFtZSArICd9Jywgb3B0aW9uc1twYXJhbS5uYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0uaW4gPT0gJ3F1ZXJ5JyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KHBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5xdWVyeVtwYXJhbS5uYW1lXSA9IG9wdGlvbnNbcGFyYW0ubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0uaW4gPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0gb3B0aW9uc1twYXJhbS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGFwaU9wdGlvbnMsIENsYXNzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZGsucGxhdGZvcm0oKVxuICAgICAgICAgICAgLnNlbmQoYXBpT3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIC8vVE9ETyBTdXBwb3J0IG11bHRpcGFydFxuICAgICAgICAgICAgLy9UT0RPIFRoaW5rIGhvdyB0byBwYXNzIGhlYWRlcnMmc3R1ZmYgdG8gb3V0c2lkZVxuICAgICAgICAgICAgaWYgKENsYXNzICYmICFyZXMuX2lzTXVsdGlwYXJ0KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDbGFzcyhfdGhpcy5fc2RrLCByZXMuanNvbigpKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENsaWVudDtcbn0oKSk7XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcblxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBleHRlbnNpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBzZXJ2aWNlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xudmFyIGFjY291bnRzdGF0dXNpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG52YXIgQWNjb3VudEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21haW5OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ29wZXJhdG9yJywgQ2xhc3M6IGV4dGVuc2lvbmluZm8uRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFydG5lcklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXJ2aWNlSW5mbycsIENsYXNzOiBzZXJ2aWNlaW5mby5TZXJ2aWNlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2V0dXBXaXphcmRTdGF0ZScsIENsYXNzOiBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXR1cycsIENsYXNzOiBBY2NvdW50SW5mb1N0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdHVzSW5mbycsIENsYXNzOiBhY2NvdW50c3RhdHVzaW5mby5BY2NvdW50U3RhdHVzSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50SW5mbyA9IEFjY291bnRJbmZvO1xuKGZ1bmN0aW9uIChBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGUpIHtcbiAgICBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW1wiTm90U3RhcnRlZFwiXSA9ICdOb3RTdGFydGVkJ10gPSBcIk5vdFN0YXJ0ZWRcIjtcbiAgICBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW1wiSW5jb21wbGV0ZVwiXSA9ICdJbmNvbXBsZXRlJ10gPSBcIkluY29tcGxldGVcIjtcbiAgICBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW1wiQ29tcGxldGVkXCJdID0gJ0NvbXBsZXRlZCddID0gXCJDb21wbGV0ZWRcIjtcbn0pKGV4cG9ydHMuQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlIHx8IChleHBvcnRzLkFjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZSA9IHt9KSk7XG52YXIgQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlID0gZXhwb3J0cy5BY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGU7XG4oZnVuY3Rpb24gKEFjY291bnRJbmZvU3RhdHVzKSB7XG4gICAgQWNjb3VudEluZm9TdGF0dXNbQWNjb3VudEluZm9TdGF0dXNbXCJDb25maXJtZWRcIl0gPSAnQ29uZmlybWVkJ10gPSBcIkNvbmZpcm1lZFwiO1xuICAgIEFjY291bnRJbmZvU3RhdHVzW0FjY291bnRJbmZvU3RhdHVzW1wiRGlzYWJsZWRcIl0gPSAnRGlzYWJsZWQnXSA9IFwiRGlzYWJsZWRcIjtcbn0pKGV4cG9ydHMuQWNjb3VudEluZm9TdGF0dXMgfHwgKGV4cG9ydHMuQWNjb3VudEluZm9TdGF0dXMgPSB7fSkpO1xudmFyIEFjY291bnRJbmZvU3RhdHVzID0gZXhwb3J0cy5BY2NvdW50SW5mb1N0YXR1cztcblxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBNb2RlbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kZWwoc2RrLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3NkayA9IHNkaztcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgIHRoaXMuZ2V0UHJvcGVydHlNYXBwaW5ncygpLmZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgICAgIHZhciBDbGFzcyA9IG1hcHBpbmcuQ2xhc3MsIHByb3AgPSBtYXBwaW5nLnByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBpbmcuaXNSZXF1aXJlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdSZXF1aXJlZCBwcm9wZXJ0eSBcIicgKyBwcm9wICsgJ1wiIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb2Nlc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uIChkYXRhUGFydCkge1xuICAgICAgICAgICAgICAgIGlmICghQ2xhc3MgfHwgdHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2xhc3MoX3RoaXMuX3NkaywgZGF0YVBhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobWFwcGluZy5pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXNbcHJvcF0gPSBkYXRhW3Byb3BdLm1hcChwcm9jZXNzUHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXNbcHJvcF0gPSBwcm9jZXNzUHJvcGVydHkoZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNb2RlbCc7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWydpZCddO1xuICAgIH07XG4gICAgcmV0dXJuIE1vZGVsO1xufSgpKTtcbmV4cG9ydHMuTW9kZWwgPSBNb2RlbDtcblxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjb250YWN0aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgZGVwYXJ0bWVudGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xudmFyIGV4dGVuc2lvbnBlcm1pc3Npb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgcHJvZmlsZWltYWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIHJlZmVyZW5jZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbnZhciByZWdpb25hbHNldHRpbmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgZXh0ZW5zaW9uc2VydmljZWZlYXR1cmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG52YXIgZXh0ZW5zaW9uc3RhdHVzaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xudmFyIEV4dGVuc2lvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb250YWN0JywgQ2xhc3M6IGNvbnRhY3RpbmZvLkNvbnRhY3RJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkZXBhcnRtZW50cycsIENsYXNzOiBkZXBhcnRtZW50aW5mby5EZXBhcnRtZW50SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYXJ0bmVySWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Blcm1pc3Npb25zJywgQ2xhc3M6IGV4dGVuc2lvbnBlcm1pc3Npb25zLkV4dGVuc2lvblBlcm1pc3Npb25zLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwcm9maWxlSW1hZ2UnLCBDbGFzczogcHJvZmlsZWltYWdlaW5mby5Qcm9maWxlSW1hZ2VJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlZmVyZW5jZXMnLCBDbGFzczogcmVmZXJlbmNlaW5mby5SZWZlcmVuY2VJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlZ2lvbmFsU2V0dGluZ3MnLCBDbGFzczogcmVnaW9uYWxzZXR0aW5ncy5SZWdpb25hbFNldHRpbmdzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXJ2aWNlRmVhdHVyZXMnLCBDbGFzczogZXh0ZW5zaW9uc2VydmljZWZlYXR1cmVpbmZvLkV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXR1cFdpemFyZFN0YXRlJywgQ2xhc3M6IEV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXMnLCBDbGFzczogRXh0ZW5zaW9uSW5mb1N0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXNJbmZvJywgQ2xhc3M6IGV4dGVuc2lvbnN0YXR1c2luZm8uRXh0ZW5zaW9uU3RhdHVzSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBFeHRlbnNpb25JbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkluZm8gPSBFeHRlbnNpb25JbmZvO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZSkge1xuICAgIEV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlW0V4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlW1wiTm90U3RhcnRlZFwiXSA9ICdOb3RTdGFydGVkJ10gPSBcIk5vdFN0YXJ0ZWRcIjtcbiAgICBFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZVtFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZVtcIkluY29tcGxldGVcIl0gPSAnSW5jb21wbGV0ZSddID0gXCJJbmNvbXBsZXRlXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGVbRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGVbXCJDb21wbGV0ZWRcIl0gPSAnQ29tcGxldGVkJ10gPSBcIkNvbXBsZXRlZFwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZSB8fCAoZXhwb3J0cy5FeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZSA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGUgPSBleHBvcnRzLkV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvU3RhdHVzKSB7XG4gICAgRXh0ZW5zaW9uSW5mb1N0YXR1c1tFeHRlbnNpb25JbmZvU3RhdHVzW1wiRW5hYmxlZFwiXSA9ICdFbmFibGVkJ10gPSBcIkVuYWJsZWRcIjtcbiAgICBFeHRlbnNpb25JbmZvU3RhdHVzW0V4dGVuc2lvbkluZm9TdGF0dXNbXCJEaXNhYmxlZFwiXSA9ICdEaXNhYmxlZCddID0gXCJEaXNhYmxlZFwiO1xuICAgIEV4dGVuc2lvbkluZm9TdGF0dXNbRXh0ZW5zaW9uSW5mb1N0YXR1c1tcIk5vdEFjdGl2YXRlZFwiXSA9ICdOb3RBY3RpdmF0ZWQnXSA9IFwiTm90QWN0aXZhdGVkXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1N0YXR1c1tFeHRlbnNpb25JbmZvU3RhdHVzW1wiVW5hc3NpZ25lZFwiXSA9ICdVbmFzc2lnbmVkJ10gPSBcIlVuYXNzaWduZWRcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uSW5mb1N0YXR1cyB8fCAoZXhwb3J0cy5FeHRlbnNpb25JbmZvU3RhdHVzID0ge30pKTtcbnZhciBFeHRlbnNpb25JbmZvU3RhdHVzID0gZXhwb3J0cy5FeHRlbnNpb25JbmZvU3RhdHVzO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvVHlwZSkge1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiVXNlclwiXSA9ICdVc2VyJ10gPSBcIlVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkZheFVzZXJcIl0gPSAnRmF4VXNlciddID0gXCJGYXhVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJWaXJ0dWFsVXNlclwiXSA9ICdWaXJ0dWFsVXNlciddID0gXCJWaXJ0dWFsVXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiRGlnaXRhbFVzZXJcIl0gPSAnRGlnaXRhbFVzZXInXSA9IFwiRGlnaXRhbFVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkRlcGFydG1lbnRcIl0gPSAnRGVwYXJ0bWVudCddID0gXCJEZXBhcnRtZW50XCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJBbm5vdW5jZW1lbnRcIl0gPSAnQW5ub3VuY2VtZW50J10gPSBcIkFubm91bmNlbWVudFwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIlNoYXJlZExpbmVzR3JvdXBcIl0gPSAnU2hhcmVkTGluZXNHcm91cCddID0gXCJTaGFyZWRMaW5lc0dyb3VwXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJQYWdpbmdPbmx5R3JvdXBcIl0gPSAnUGFnaW5nT25seUdyb3VwJ10gPSBcIlBhZ2luZ09ubHlHcm91cFwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiSXZyTWVudVwiXSA9ICdJdnJNZW51J10gPSBcIkl2ck1lbnVcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCJdID0gJ0FwcGxpY2F0aW9uRXh0ZW5zaW9uJ10gPSBcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJQYXJrTG9jYXRpb25cIl0gPSAnUGFya0xvY2F0aW9uJ10gPSBcIlBhcmtMb2NhdGlvblwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25JbmZvVHlwZSB8fCAoZXhwb3J0cy5FeHRlbnNpb25JbmZvVHlwZSA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uSW5mb1R5cGUgPSBleHBvcnRzLkV4dGVuc2lvbkluZm9UeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNvbnRhY3RhZGRyZXNzaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgQ29udGFjdEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250YWN0SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250YWN0SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbnRhY3RJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZpcnN0TmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFzdE5hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbXBhbnknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VtYWlsJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdidXNpbmVzc1Bob25lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdidXNpbmVzc0FkZHJlc3MnLCBDbGFzczogY29udGFjdGFkZHJlc3NpbmZvLkNvbnRhY3RBZGRyZXNzSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENvbnRhY3RJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ29udGFjdEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRhY3RJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Db250YWN0SW5mbyA9IENvbnRhY3RJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIENvbnRhY3RBZGRyZXNzSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnRhY3RBZGRyZXNzSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250YWN0QWRkcmVzc0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb250YWN0QWRkcmVzc0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY291bnRyeScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NpdHknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0cmVldCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnemlwJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ29udGFjdEFkZHJlc3NJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ29udGFjdEFkZHJlc3NJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBDb250YWN0QWRkcmVzc0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNvbnRhY3RBZGRyZXNzSW5mbyA9IENvbnRhY3RBZGRyZXNzSW5mbztcblxuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBEZXBhcnRtZW50SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlcGFydG1lbnRJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlcGFydG1lbnRJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGVwYXJ0bWVudEluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGVwYXJ0bWVudEluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEZXBhcnRtZW50SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGVwYXJ0bWVudEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRlcGFydG1lbnRJbmZvID0gRGVwYXJ0bWVudEluZm87XG5cblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHBlcm1pc3Npb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgRXh0ZW5zaW9uUGVybWlzc2lvbnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25QZXJtaXNzaW9ucywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25QZXJtaXNzaW9ucygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvblBlcm1pc3Npb25zLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FkbWluJywgQ2xhc3M6IHBlcm1pc3Npb25pbmZvLlBlcm1pc3Npb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpbnRlcm5hdGlvbmFsQ2FsbGluZycsIENsYXNzOiBwZXJtaXNzaW9uaW5mby5QZXJtaXNzaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvblBlcm1pc3Npb25zLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uUGVybWlzc2lvbnMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvblBlcm1pc3Npb25zO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25QZXJtaXNzaW9ucyA9IEV4dGVuc2lvblBlcm1pc3Npb25zO1xuXG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQZXJtaXNzaW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBlcm1pc3Npb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBlcm1pc3Npb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGVybWlzc2lvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5hYmxlZCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQZXJtaXNzaW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1Blcm1pc3Npb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQZXJtaXNzaW9uSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUGVybWlzc2lvbkluZm8gPSBQZXJtaXNzaW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUHJvZmlsZUltYWdlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb2ZpbGVJbWFnZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvZmlsZUltYWdlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFByb2ZpbGVJbWFnZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V0YWcnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhc3RNb2RpZmllZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFR5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3NjYWxlcycsIENsYXNzOiBudWxsIC8qIHN0cmluZ1tdICovLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQcm9maWxlSW1hZ2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUHJvZmlsZUltYWdlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvZmlsZUltYWdlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUHJvZmlsZUltYWdlSW5mbyA9IFByb2ZpbGVJbWFnZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFJlZmVyZW5jZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZlcmVuY2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZWZlcmVuY2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlZicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBSZWZlcmVuY2VJbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFJlZmVyZW5jZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdSZWZlcmVuY2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBSZWZlcmVuY2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5SZWZlcmVuY2VJbmZvID0gUmVmZXJlbmNlSW5mbztcbihmdW5jdGlvbiAoUmVmZXJlbmNlSW5mb1R5cGUpIHtcbiAgICBSZWZlcmVuY2VJbmZvVHlwZVtSZWZlcmVuY2VJbmZvVHlwZVtcIlBhcnRuZXJJZFwiXSA9ICdQYXJ0bmVySWQnXSA9IFwiUGFydG5lcklkXCI7XG4gICAgUmVmZXJlbmNlSW5mb1R5cGVbUmVmZXJlbmNlSW5mb1R5cGVbXCJDdXN0b21lckRpcmVjdG9yeUlkXCJdID0gJ0N1c3RvbWVyRGlyZWN0b3J5SWQnXSA9IFwiQ3VzdG9tZXJEaXJlY3RvcnlJZFwiO1xufSkoZXhwb3J0cy5SZWZlcmVuY2VJbmZvVHlwZSB8fCAoZXhwb3J0cy5SZWZlcmVuY2VJbmZvVHlwZSA9IHt9KSk7XG52YXIgUmVmZXJlbmNlSW5mb1R5cGUgPSBleHBvcnRzLlJlZmVyZW5jZUluZm9UeXBlO1xuXG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjb3VudHJ5aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xudmFyIHRpbWV6b25laW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xudmFyIGxhbmd1YWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIGdyZWV0aW5nbGFuZ3VhZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG52YXIgZm9ybWF0dGluZ2xvY2FsZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBSZWdpb25hbFNldHRpbmdzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVnaW9uYWxTZXR0aW5ncywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWdpb25hbFNldHRpbmdzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmVnaW9uYWxTZXR0aW5ncy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdob21lQ291bnRyeScsIENsYXNzOiBjb3VudHJ5aW5mby5Db3VudHJ5SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndGltZXpvbmUnLCBDbGFzczogdGltZXpvbmVpbmZvLlRpbWV6b25lSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFuZ3VhZ2UnLCBDbGFzczogbGFuZ3VhZ2VpbmZvLkxhbmd1YWdlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZ3JlZXRpbmdMYW5ndWFnZScsIENsYXNzOiBncmVldGluZ2xhbmd1YWdlaW5mby5HcmVldGluZ0xhbmd1YWdlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZm9ybWF0dGluZ0xvY2FsZScsIENsYXNzOiBmb3JtYXR0aW5nbG9jYWxlaW5mby5Gb3JtYXR0aW5nTG9jYWxlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFJlZ2lvbmFsU2V0dGluZ3MucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdSZWdpb25hbFNldHRpbmdzJztcbiAgICB9O1xuICAgIHJldHVybiBSZWdpb25hbFNldHRpbmdzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5SZWdpb25hbFNldHRpbmdzID0gUmVnaW9uYWxTZXR0aW5ncztcblxuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQ291bnRyeUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb3VudHJ5SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb3VudHJ5SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDb3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NvdW50cnlJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBDb3VudHJ5SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQ291bnRyeUluZm8gPSBDb3VudHJ5SW5mbztcblxuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgVGltZXpvbmVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZXpvbmVJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWV6b25lSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRpbWV6b25lSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkZXNjcmlwdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFRpbWV6b25lSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1RpbWV6b25lSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXpvbmVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5UaW1lem9uZUluZm8gPSBUaW1lem9uZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIExhbmd1YWdlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExhbmd1YWdlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYW5ndWFnZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYW5ndWFnZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZ3JlZXRpbmcnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmb3JtYXR0aW5nTG9jYWxlJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYWxlQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndWknLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTGFuZ3VhZ2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTGFuZ3VhZ2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBMYW5ndWFnZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkxhbmd1YWdlSW5mbyA9IExhbmd1YWdlSW5mbztcblxuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgR3JlZXRpbmdMYW5ndWFnZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcmVldGluZ0xhbmd1YWdlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcmVldGluZ0xhbmd1YWdlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdyZWV0aW5nTGFuZ3VhZ2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsb2NhbGVDb2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgR3JlZXRpbmdMYW5ndWFnZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdHcmVldGluZ0xhbmd1YWdlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gR3JlZXRpbmdMYW5ndWFnZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkdyZWV0aW5nTGFuZ3VhZ2VJbmZvID0gR3JlZXRpbmdMYW5ndWFnZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEZvcm1hdHRpbmdMb2NhbGVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9ybWF0dGluZ0xvY2FsZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9ybWF0dGluZ0xvY2FsZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBGb3JtYXR0aW5nTG9jYWxlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYWxlQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEZvcm1hdHRpbmdMb2NhbGVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRm9ybWF0dGluZ0xvY2FsZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcm1hdHRpbmdMb2NhbGVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Gb3JtYXR0aW5nTG9jYWxlSW5mbyA9IEZvcm1hdHRpbmdMb2NhbGVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VuYWJsZWQnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmZWF0dXJlTmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVhc29uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbyA9IEV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbztcblxuXG4vKioqLyB9LFxuLyogMjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRXh0ZW5zaW9uU3RhdHVzSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvblN0YXR1c0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uU3RhdHVzSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvblN0YXR1c0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29tbWVudCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVhc29uJywgQ2xhc3M6IEV4dGVuc2lvblN0YXR1c0luZm9SZWFzb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25TdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uU3RhdHVzSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uU3RhdHVzSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uU3RhdHVzSW5mbyA9IEV4dGVuc2lvblN0YXR1c0luZm87XG4oZnVuY3Rpb24gKEV4dGVuc2lvblN0YXR1c0luZm9SZWFzb24pIHtcbiAgICBFeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uW0V4dGVuc2lvblN0YXR1c0luZm9SZWFzb25bXCJWb2x1bnRhcmlseVwiXSA9ICdWb2x1bnRhcmlseSddID0gXCJWb2x1bnRhcmlseVwiO1xuICAgIEV4dGVuc2lvblN0YXR1c0luZm9SZWFzb25bRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbltcIkludm9sdW50YXJpbHlcIl0gPSAnSW52b2x1bnRhcmlseSddID0gXCJJbnZvbHVudGFyaWx5XCI7XG59KShleHBvcnRzLkV4dGVuc2lvblN0YXR1c0luZm9SZWFzb24gfHwgKGV4cG9ydHMuRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbiA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbiA9IGV4cG9ydHMuRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbjtcblxuXG4vKioqLyB9LFxuLyogMjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgYmlsbGluZ3BsYW5pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG52YXIgYnJhbmRpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG52YXIgc2VydmljZXBsYW5pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG52YXIgdGFyZ2V0c2VydmljZXBsYW5pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG52YXIgU2VydmljZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXJ2aWNlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNlcnZpY2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYmlsbGluZ1BsYW4nLCBDbGFzczogYmlsbGluZ3BsYW5pbmZvLkJpbGxpbmdQbGFuSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYnJhbmQnLCBDbGFzczogYnJhbmRpbmZvLkJyYW5kSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2VydmljZVBsYW4nLCBDbGFzczogc2VydmljZXBsYW5pbmZvLlNlcnZpY2VQbGFuSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndGFyZ2V0U2VydmljZVBsYW4nLCBDbGFzczogdGFyZ2V0c2VydmljZXBsYW5pbmZvLlRhcmdldFNlcnZpY2VQbGFuSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFNlcnZpY2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU2VydmljZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZpY2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5TZXJ2aWNlSW5mbyA9IFNlcnZpY2VJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBCaWxsaW5nUGxhbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaWxsaW5nUGxhbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmlsbGluZ1BsYW5JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQmlsbGluZ1BsYW5JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvblVuaXQnLCBDbGFzczogQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0LCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBCaWxsaW5nUGxhbkluZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQmlsbGluZ1BsYW5JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQmlsbGluZ1BsYW5JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBCaWxsaW5nUGxhbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkJpbGxpbmdQbGFuSW5mbyA9IEJpbGxpbmdQbGFuSW5mbztcbihmdW5jdGlvbiAoQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0KSB7XG4gICAgQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0W0JpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdFtcIk1vbnRoXCJdID0gJ01vbnRoJ10gPSBcIk1vbnRoXCI7XG4gICAgQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0W0JpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdFtcIkRheVwiXSA9ICdEYXknXSA9IFwiRGF5XCI7XG59KShleHBvcnRzLkJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdCB8fCAoZXhwb3J0cy5CaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXQgPSB7fSkpO1xudmFyIEJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdCA9IGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0O1xuKGZ1bmN0aW9uIChCaWxsaW5nUGxhbkluZm9UeXBlKSB7XG4gICAgQmlsbGluZ1BsYW5JbmZvVHlwZVtCaWxsaW5nUGxhbkluZm9UeXBlW1wiSW5pdGlhbFwiXSA9ICdJbml0aWFsJ10gPSBcIkluaXRpYWxcIjtcbiAgICBCaWxsaW5nUGxhbkluZm9UeXBlW0JpbGxpbmdQbGFuSW5mb1R5cGVbXCJSZWd1bGFyXCJdID0gJ1JlZ3VsYXInXSA9IFwiUmVndWxhclwiO1xuICAgIEJpbGxpbmdQbGFuSW5mb1R5cGVbQmlsbGluZ1BsYW5JbmZvVHlwZVtcIlN1c3BlbmRlZFwiXSA9ICdTdXNwZW5kZWQnXSA9IFwiU3VzcGVuZGVkXCI7XG4gICAgQmlsbGluZ1BsYW5JbmZvVHlwZVtCaWxsaW5nUGxhbkluZm9UeXBlW1wiVHJpYWxcIl0gPSAnVHJpYWwnXSA9IFwiVHJpYWxcIjtcbiAgICBCaWxsaW5nUGxhbkluZm9UeXBlW0JpbGxpbmdQbGFuSW5mb1R5cGVbXCJUcmlhbE5vQ0NcIl0gPSAnVHJpYWxOb0NDJ10gPSBcIlRyaWFsTm9DQ1wiO1xuICAgIEJpbGxpbmdQbGFuSW5mb1R5cGVbQmlsbGluZ1BsYW5JbmZvVHlwZVtcIkZyZWVcIl0gPSAnRnJlZSddID0gXCJGcmVlXCI7XG59KShleHBvcnRzLkJpbGxpbmdQbGFuSW5mb1R5cGUgfHwgKGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvVHlwZSA9IHt9KSk7XG52YXIgQmlsbGluZ1BsYW5JbmZvVHlwZSA9IGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogMjQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbnZhciBCcmFuZEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCcmFuZEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnJhbmRJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQnJhbmRJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdob21lQ291bnRyeScsIENsYXNzOiBjb3VudHJ5aW5mby5Db3VudHJ5SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJyYW5kSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0JyYW5kSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQnJhbmRJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5CcmFuZEluZm8gPSBCcmFuZEluZm87XG5cblxuLyoqKi8gfSxcbi8qIDI1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFNlcnZpY2VQbGFuSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcnZpY2VQbGFuSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlUGxhbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZXJ2aWNlUGxhbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VkaXRpb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBTZXJ2aWNlUGxhbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTZXJ2aWNlUGxhbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZpY2VQbGFuSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuU2VydmljZVBsYW5JbmZvID0gU2VydmljZVBsYW5JbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBUYXJnZXRTZXJ2aWNlUGxhbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYXJnZXRTZXJ2aWNlUGxhbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFyZ2V0U2VydmljZVBsYW5JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGFyZ2V0U2VydmljZVBsYW5JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgVGFyZ2V0U2VydmljZVBsYW5JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnVGFyZ2V0U2VydmljZVBsYW5JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBUYXJnZXRTZXJ2aWNlUGxhbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlRhcmdldFNlcnZpY2VQbGFuSW5mbyA9IFRhcmdldFNlcnZpY2VQbGFuSW5mbztcblxuXG4vKioqLyB9LFxuLyogMjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQWNjb3VudFN0YXR1c0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50U3RhdHVzSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50U3RhdHVzSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRTdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbW1lbnQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlYXNvbicsIENsYXNzOiBBY2NvdW50U3RhdHVzSW5mb1JlYXNvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRTdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudFN0YXR1c0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRTdGF0dXNJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50U3RhdHVzSW5mbyA9IEFjY291bnRTdGF0dXNJbmZvO1xuKGZ1bmN0aW9uIChBY2NvdW50U3RhdHVzSW5mb1JlYXNvbikge1xuICAgIEFjY291bnRTdGF0dXNJbmZvUmVhc29uW0FjY291bnRTdGF0dXNJbmZvUmVhc29uW1wiVm9sdW50YXJpbHlcIl0gPSAnVm9sdW50YXJpbHknXSA9IFwiVm9sdW50YXJpbHlcIjtcbiAgICBBY2NvdW50U3RhdHVzSW5mb1JlYXNvbltBY2NvdW50U3RhdHVzSW5mb1JlYXNvbltcIkludm9sdW50YXJpbHlcIl0gPSAnSW52b2x1bnRhcmlseSddID0gXCJJbnZvbHVudGFyaWx5XCI7XG59KShleHBvcnRzLkFjY291bnRTdGF0dXNJbmZvUmVhc29uIHx8IChleHBvcnRzLkFjY291bnRTdGF0dXNJbmZvUmVhc29uID0ge30pKTtcbnZhciBBY2NvdW50U3RhdHVzSW5mb1JlYXNvbiA9IGV4cG9ydHMuQWNjb3VudFN0YXR1c0luZm9SZWFzb247XG5cblxuLyoqKi8gfSxcbi8qIDI4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGJ1c2luZXNzYWRkcmVzc2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcbnZhciBBY2NvdW50QnVzaW5lc3NBZGRyZXNzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudEJ1c2luZXNzQWRkcmVzcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50QnVzaW5lc3NBZGRyZXNzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudEJ1c2luZXNzQWRkcmVzcy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbXBhbnknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VtYWlsJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdidXNpbmVzc0FkZHJlc3MnLCBDbGFzczogYnVzaW5lc3NhZGRyZXNzaW5mby5CdXNpbmVzc0FkZHJlc3NJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50QnVzaW5lc3NBZGRyZXNzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudEJ1c2luZXNzQWRkcmVzcyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudEJ1c2luZXNzQWRkcmVzcztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudEJ1c2luZXNzQWRkcmVzcyA9IEFjY291bnRCdXNpbmVzc0FkZHJlc3M7XG5cblxuLyoqKi8gfSxcbi8qIDI5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEJ1c2luZXNzQWRkcmVzc0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXNpbmVzc0FkZHJlc3NJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1c2luZXNzQWRkcmVzc0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCdXNpbmVzc0FkZHJlc3NJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvdW50cnknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXRlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjaXR5JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdHJlZXQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ppcCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJ1c2luZXNzQWRkcmVzc0luZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdCdXNpbmVzc0FkZHJlc3NJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBCdXNpbmVzc0FkZHJlc3NJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5CdXNpbmVzc0FkZHJlc3NJbmZvID0gQnVzaW5lc3NBZGRyZXNzSW5mbztcblxuXG4vKioqLyB9LFxuLyogMzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGlhbGluZ3BsYW5jb3VudHJ5aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIERpYWxpbmdQbGFuSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpYWxpbmdQbGFuSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWFsaW5nUGxhbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWFsaW5nUGxhbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBkaWFsaW5ncGxhbmNvdW50cnlpbmZvLkRpYWxpbmdQbGFuQ291bnRyeUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpYWxpbmdQbGFuSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpYWxpbmdQbGFuSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGlhbGluZ1BsYW5JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWFsaW5nUGxhbkluZm8gPSBEaWFsaW5nUGxhbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDMxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIERpYWxpbmdQbGFuQ291bnRyeUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWFsaW5nUGxhbkNvdW50cnlJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpYWxpbmdQbGFuQ291bnRyeUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWFsaW5nUGxhbkNvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NhbGxpbmdDb2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpc29Db2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGlhbGluZ1BsYW5Db3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpYWxpbmdQbGFuQ291bnRyeUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIERpYWxpbmdQbGFuQ291bnRyeUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpYWxpbmdQbGFuQ291bnRyeUluZm8gPSBEaWFsaW5nUGxhbkNvdW50cnlJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAzMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQYWdpbmdJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFnaW5nSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYWdpbmdJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGFnaW5nSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdlJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwZXJQYWdlJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdlU3RhcnQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2VFbmQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvdGFsUGFnZXMnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvdGFsRWxlbWVudHMnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQYWdpbmdJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUGFnaW5nSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUGFnaW5nSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUGFnaW5nSW5mbyA9IFBhZ2luZ0luZm87XG5cblxuLyoqKi8gfSxcbi8qIDMzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE5hdmlnYXRpb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmF2aWdhdGlvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBOYXZpZ2F0aW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmaXJzdFBhZ2UnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25leHRQYWdlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwcmV2aW91c1BhZ2UnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhc3RQYWdlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTmF2aWdhdGlvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdOYXZpZ2F0aW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTmF2aWdhdGlvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk5hdmlnYXRpb25JbmZvID0gTmF2aWdhdGlvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDM0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNvdW50cnlpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG52YXIgcGhvbmVudW1iZXJzZXh0ZW5zaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xudmFyIFBob25lTnVtYmVySW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBob25lTnVtYmVySW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQaG9uZU51bWJlckluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQaG9uZU51bWJlckluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvdW50cnknLCBDbGFzczogY291bnRyeWluZm8uQ291bnRyeUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbicsIENsYXNzOiBwaG9uZW51bWJlcnNleHRlbnNpb25pbmZvLlBob25lTnVtYmVyc0V4dGVuc2lvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZlYXR1cmVzJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nW10gKi8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYXRpb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BheW1lbnRUeXBlJywgQ2xhc3M6IFBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaG9uZU51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdHVzJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IFBob25lTnVtYmVySW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VzYWdlVHlwZScsIENsYXNzOiBQaG9uZU51bWJlckluZm9Vc2FnZVR5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQaG9uZU51bWJlckluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdQaG9uZU51bWJlckluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFBob25lTnVtYmVySW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvID0gUGhvbmVOdW1iZXJJbmZvO1xuKGZ1bmN0aW9uIChQaG9uZU51bWJlckluZm9QYXltZW50VHlwZSkge1xuICAgIFBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlW1Bob25lTnVtYmVySW5mb1BheW1lbnRUeXBlW1wiRXh0ZXJuYWxcIl0gPSAnRXh0ZXJuYWwnXSA9IFwiRXh0ZXJuYWxcIjtcbiAgICBQaG9uZU51bWJlckluZm9QYXltZW50VHlwZVtQaG9uZU51bWJlckluZm9QYXltZW50VHlwZVtcIlRvbGxGcmVlXCJdID0gJ1RvbGxGcmVlJ10gPSBcIlRvbGxGcmVlXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGVbUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGVbXCJMb2NhbFwiXSA9ICdMb2NhbCddID0gXCJMb2NhbFwiO1xufSkoZXhwb3J0cy5QaG9uZU51bWJlckluZm9QYXltZW50VHlwZSB8fCAoZXhwb3J0cy5QaG9uZU51bWJlckluZm9QYXltZW50VHlwZSA9IHt9KSk7XG52YXIgUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGUgPSBleHBvcnRzLlBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlO1xuKGZ1bmN0aW9uIChQaG9uZU51bWJlckluZm9UeXBlKSB7XG4gICAgUGhvbmVOdW1iZXJJbmZvVHlwZVtQaG9uZU51bWJlckluZm9UeXBlW1wiVm9pY2VGYXhcIl0gPSAnVm9pY2VGYXgnXSA9IFwiVm9pY2VGYXhcIjtcbiAgICBQaG9uZU51bWJlckluZm9UeXBlW1Bob25lTnVtYmVySW5mb1R5cGVbXCJGYXhPbmx5XCJdID0gJ0ZheE9ubHknXSA9IFwiRmF4T25seVwiO1xuICAgIFBob25lTnVtYmVySW5mb1R5cGVbUGhvbmVOdW1iZXJJbmZvVHlwZVtcIlZvaWNlT25seVwiXSA9ICdWb2ljZU9ubHknXSA9IFwiVm9pY2VPbmx5XCI7XG59KShleHBvcnRzLlBob25lTnVtYmVySW5mb1R5cGUgfHwgKGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVHlwZSA9IHt9KSk7XG52YXIgUGhvbmVOdW1iZXJJbmZvVHlwZSA9IGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVHlwZTtcbihmdW5jdGlvbiAoUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlKSB7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIk1haW5Db21wYW55TnVtYmVyXCJdID0gJ01haW5Db21wYW55TnVtYmVyJ10gPSBcIk1haW5Db21wYW55TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCJdID0gJ0FkZGl0aW9uYWxDb21wYW55TnVtYmVyJ10gPSBcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkNvbXBhbnlOdW1iZXJcIl0gPSAnQ29tcGFueU51bWJlciddID0gXCJDb21wYW55TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkRpcmVjdE51bWJlclwiXSA9ICdEaXJlY3ROdW1iZXInXSA9IFwiRGlyZWN0TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkNvbXBhbnlGYXhOdW1iZXJcIl0gPSAnQ29tcGFueUZheE51bWJlciddID0gXCJDb21wYW55RmF4TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkZvcndhcmRlZE51bWJlclwiXSA9ICdGb3J3YXJkZWROdW1iZXInXSA9IFwiRm9yd2FyZGVkTnVtYmVyXCI7XG59KShleHBvcnRzLlBob25lTnVtYmVySW5mb1VzYWdlVHlwZSB8fCAoZXhwb3J0cy5QaG9uZU51bWJlckluZm9Vc2FnZVR5cGUgPSB7fSkpO1xudmFyIFBob25lTnVtYmVySW5mb1VzYWdlVHlwZSA9IGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiAzNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhcnRuZXJJZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFBob25lTnVtYmVyc0V4dGVuc2lvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5QaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvID0gUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogMzYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgcGhvbmVudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgQWNjb3VudFBob25lTnVtYmVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRQaG9uZU51bWJlcnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudFBob25lTnVtYmVycygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRQaG9uZU51bWJlcnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBwaG9uZW51bWJlcmluZm8uUGhvbmVOdW1iZXJJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50UGhvbmVOdW1iZXJzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudFBob25lTnVtYmVycyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudFBob25lTnVtYmVycztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudFBob25lTnVtYmVycyA9IEFjY291bnRQaG9uZU51bWJlcnM7XG5cblxuLyoqKi8gfSxcbi8qIDM3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHNlcnZpY2VmZWF0dXJlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xudmFyIGFjY291bnRsaW1pdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcbnZhciBBY2NvdW50U2VydmljZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50U2VydmljZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudFNlcnZpY2VJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudFNlcnZpY2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2VydmljZVBsYW5OYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXJ2aWNlRmVhdHVyZXMnLCBDbGFzczogc2VydmljZWZlYXR1cmVpbmZvLlNlcnZpY2VGZWF0dXJlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsaW1pdHMnLCBDbGFzczogYWNjb3VudGxpbWl0cy5BY2NvdW50TGltaXRzLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50U2VydmljZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50U2VydmljZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRTZXJ2aWNlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudFNlcnZpY2VJbmZvID0gQWNjb3VudFNlcnZpY2VJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAzOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTZXJ2aWNlRmVhdHVyZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXJ2aWNlRmVhdHVyZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VydmljZUZlYXR1cmVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VydmljZUZlYXR1cmVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZlYXR1cmVOYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlbmFibGVkJywgQ2xhc3M6IFNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBTZXJ2aWNlRmVhdHVyZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTZXJ2aWNlRmVhdHVyZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZpY2VGZWF0dXJlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuU2VydmljZUZlYXR1cmVJbmZvID0gU2VydmljZUZlYXR1cmVJbmZvO1xuKGZ1bmN0aW9uIChTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkKSB7XG4gICAgU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZFtTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkW1wiVHJ1ZVwiXSA9ICdUcnVlJ10gPSBcIlRydWVcIjtcbiAgICBTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkW1NlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWRbXCJGYWxzZVwiXSA9ICdGYWxzZSddID0gXCJGYWxzZVwiO1xufSkoZXhwb3J0cy5TZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkIHx8IChleHBvcnRzLlNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQgPSB7fSkpO1xudmFyIFNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQgPSBleHBvcnRzLlNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQ7XG5cblxuLyoqKi8gfSxcbi8qIDM5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEFjY291bnRMaW1pdHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50TGltaXRzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRMaW1pdHMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50TGltaXRzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZyZWVTb2Z0UGhvbmVMaW5lc1BlckV4dGVuc2lvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbWVldGluZ1NpemUnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21heE1vbml0b3JlZEV4dGVuc2lvbnNQZXJVc2VyJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudExpbWl0cy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRMaW1pdHMnO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRMaW1pdHM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRMaW1pdHMgPSBBY2NvdW50TGltaXRzO1xuXG5cbi8qKiovIH0sXG4vKiA0MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgYWNjb3VudGFjdGl2ZWNhbGxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG52YXIgYWNjb3VudGNhbGxsb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcbnZhciBhY2NvdW50Y2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xudmFyIGV4dGVuc2lvbmFjdGl2ZWNhbGxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgZXh0ZW5zaW9uY2FsbGxvZyA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xudmFyIGV4dGVuc2lvbmNhbGxsb2dyZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbnZhciBjYWxsbG9nc3luYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xudmFyIGNhbGxyZWNvcmRpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcbnZhciBDYWxsTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsbExvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsTG9nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgQWN0aXZlIENhbGxzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTMgKFJlbGVhc2UgNi41KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHJlY29yZHMgb2YgYWxsIGNhbGxzIHRoYXQgYXJlIGluIHByb2dyZXNzLCBvcmRlcmVkIGJ5IHN0YXJ0IHRpbWUgaW4gZGVzY2VuZGluZyBvcmRlci48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubGlzdEFjY291bnRBY3RpdmVDYWxscyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vYWN0aXZlLWNhbGxzJywgb3B0aW9ucywgZXhwb3J0cy5saXN0QWNjb3VudEFjdGl2ZUNhbGxzT3B0aW9ucyksIGFjY291bnRhY3RpdmVjYWxscy5BY2NvdW50QWN0aXZlQ2FsbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgTG9nIFJlY29yZHMgYnkgRmlsdGVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMyAoUmVsZWFzZSA1LjExKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGNhbGwgbG9nIHJlY29yZHMgZmlsdGVyZWQgYnkgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkQWNjb3VudENhbGxMb2cgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2NhbGwtbG9nJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQWNjb3VudENhbGxMb2dPcHRpb25zKSwgYWNjb3VudGNhbGxsb2cuQWNjb3VudENhbGxMb2cpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIENhbGwgTG9nIFJlY29yZHMgYnkgRmlsdGVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0Q2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmRlbGV0ZUFjY291bnRDYWxsTG9nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9jYWxsLWxvZycsIG9wdGlvbnMsIGV4cG9ydHMuZGVsZXRlQWNjb3VudENhbGxMb2dPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWNjb3VudCBDYWxsIExvZyBSZWNvcmQocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4zIChSZWxlYXNlIDUuMTEpPC9wPlxuICAgICAqIDxwPlJldHVybnMgaW5kaXZpZHVhbCBjYWxsIGxvZyByZWNvcmQocykgYnkgSUQocykuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLCBzZWUgQmF0Y2ggUmVxdWVzdHMgZm9yIGRldGFpbHMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxvYWRBY2NvdW50Q2FsbExvZ1JlY29yZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vY2FsbC1sb2cve2NhbGxSZWNvcmRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRBY2NvdW50Q2FsbExvZ1JlY29yZE9wdGlvbnMpLCBhY2NvdW50Y2FsbGxvZ3JlY29yZC5BY2NvdW50Q2FsbExvZ1JlY29yZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWN0aXZlIENhbGxzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTMgKFJlbGVhc2UgNi41KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHJlY29yZHMgb2YgYWxsIGV4dGVuc2lvbiBjYWxscyB0aGF0IGFyZSBpbiBwcm9ncmVzcywgb3JkZXJlZCBieSBzdGFydCB0aW1lIGluIGRlc2NlbmRpbmcgb3JkZXIuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxpc3RFeHRlbnNpb25BY3RpdmVDYWxscyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vYWN0aXZlLWNhbGxzJywgb3B0aW9ucywgZXhwb3J0cy5saXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNPcHRpb25zKSwgZXh0ZW5zaW9uYWN0aXZlY2FsbHMuRXh0ZW5zaW9uQWN0aXZlQ2FsbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgTG9nIFJlY29yZHMgYnkgRmlsdGVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMyAoUmVsZWFzZSA1LjExKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGNhbGwgbG9nIHJlY29yZHMgZmlsdGVyZWQgYnkgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkRXh0ZW5zaW9uQ2FsbExvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vY2FsbC1sb2cnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyksIGV4dGVuc2lvbmNhbGxsb2cuRXh0ZW5zaW9uQ2FsbExvZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgQ2FsbCBMb2cgUmVjb3JkcyBieSBGaWx0ZXJcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUuZGVsZXRlRXh0ZW5zaW9uQ2FsbExvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0RFTEVURScsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vY2FsbC1sb2cnLCBvcHRpb25zLCBleHBvcnRzLmRlbGV0ZUV4dGVuc2lvbkNhbGxMb2dPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIENhbGwgTG9nIFJlY29yZChzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjMgKFJlbGVhc2UgNS4xMSk8L3A+XG4gICAgICogPHA+UmV0dXJucyBjYWxsIGxvZyByZWNvcmQocykgYnkgdGhlaXIgSUQocykuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLCBzZWUgQmF0Y2ggUmVxdWVzdHMgZm9yIGRldGFpbHMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxvYWRFeHRlbnNpb25DYWxsTG9nUmVjb3JkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9jYWxsLWxvZy97Y2FsbFJlY29yZElkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRPcHRpb25zKSwgZXh0ZW5zaW9uY2FsbGxvZ3JlY29yZC5FeHRlbnNpb25DYWxsTG9nUmVjb3JkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGwgTG9nIFN5bmNocm9uaXphdGlvblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5zeW5jRXh0ZW5zaW9uQ2FsbExvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vY2FsbC1sb2ctc3luYycsIG9wdGlvbnMsIGV4cG9ydHMuc3luY0V4dGVuc2lvbkNhbGxMb2dPcHRpb25zKSwgY2FsbGxvZ3N5bmMuQ2FsbExvZ1N5bmMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgUmVjb3JkaW5nXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTg8L3A+XG4gICAgICogPHA+UmV0dXJucyBjYWxsIHJlY29yZGluZyBtZXRhZGF0YS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsUmVjb3JkaW5nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+RG93bmxvYWRpbmcgY2FsbCByZWNvcmRpbmcgY29udGVudDwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkQ2FsbFJlY29yZGluZ01ldGFkYXRhID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9yZWNvcmRpbmcve3JlY29yZGluZ0lkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZENhbGxSZWNvcmRpbmdNZXRhZGF0YU9wdGlvbnMpLCBjYWxscmVjb3JkaW5nLkNhbGxSZWNvcmRpbmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgUmVjb3JkaW5nIERhdGFcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsUmVjb3JkaW5nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+RG93bmxvYWRpbmcgY2FsbCByZWNvcmRpbmcgY29udGVudDwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubG9hZENhbGxSZWNvcmRpbmdDb250ZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9yZWNvcmRpbmcve3JlY29yZGluZ0lkfS9jb250ZW50Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQ2FsbFJlY29yZGluZ0NvbnRlbnRPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbExvZztcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5DYWxsTG9nID0gQ2FsbExvZztcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0QWNjb3VudEFjdGl2ZUNhbGxzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RBY2NvdW50QWN0aXZlQ2FsbHNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJWb2ljZVwiLFxuICAgICAgICAgICAgXCJGYXhcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEFjY291bnRDYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRBY2NvdW50Q2FsbExvZ09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbk51bWJlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGhvbmVOdW1iZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiSW5ib3VuZFwiLFxuICAgICAgICAgICAgXCJPdXRib3VuZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJWb2ljZVwiLFxuICAgICAgICAgICAgXCJGYXhcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ2aWV3XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMb2FkQWNjb3VudENhbGxMb2dWaWV3XCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiU2ltcGxlXCIsXG4gICAgICAgICAgICBcIkRldGFpbGVkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwid2l0aFJlY29yZGluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVGcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlVG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBkZWxldGVBY2NvdW50Q2FsbExvZyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5kZWxldGVBY2NvdW50Q2FsbExvZ09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRBY2NvdW50Q2FsbExvZ1JlY29yZCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQWNjb3VudENhbGxMb2dSZWNvcmRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjYWxsUmVjb3JkSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvblwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkluYm91bmRcIixcbiAgICAgICAgICAgIFwiT3V0Ym91bmRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiVm9pY2VcIixcbiAgICAgICAgICAgIFwiRmF4XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRFeHRlbnNpb25DYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbk51bWJlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGhvbmVOdW1iZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiVm9pY2VcIixcbiAgICAgICAgICAgIFwiRmF4XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidmlld1wiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3XCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiU2ltcGxlXCIsXG4gICAgICAgICAgICBcIkRldGFpbGVkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwid2l0aFJlY29yZGluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZUZyb21cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBkZWxldGVFeHRlbnNpb25DYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmRlbGV0ZUV4dGVuc2lvbkNhbGxMb2dPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZVRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY2FsbFJlY29yZElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHN5bmNFeHRlbnNpb25DYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnN5bmNFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN5bmNUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiRlN5bmNcIixcbiAgICAgICAgICAgIFwiSVN5bmNcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzeW5jVG9rZW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVGcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyZWNvcmRDb3VudFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3RhdHVzR3JvdXBcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXBcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJNaXNzZWRcIixcbiAgICAgICAgICAgIFwiQWxsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRDYWxsUmVjb3JkaW5nTWV0YWRhdGEgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZENhbGxSZWNvcmRpbmdNZXRhZGF0YU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInJlY29yZGluZ0lkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRDYWxsUmVjb3JkaW5nQ29udGVudCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQ2FsbFJlY29yZGluZ0NvbnRlbnRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyZWNvcmRpbmdJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbihmdW5jdGlvbiAoSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb24pIHtcbiAgICBJTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbltJTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb25bSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb24gPSBleHBvcnRzLklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGUpIHtcbiAgICBJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGVbSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGVbSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlIHx8IChleHBvcnRzLklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlID0gZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGU7XG4oZnVuY3Rpb24gKElMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb24pIHtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uW0lMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIElMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb25bSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb24gfHwgKGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbiA9IGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGUpIHtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nVHlwZVtJTG9hZEFjY291bnRDYWxsTG9nVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGVbSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nVHlwZSB8fCAoZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nVHlwZSA9IHt9KSk7XG52YXIgSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGUgPSBleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dUeXBlO1xuKGZ1bmN0aW9uIChJTG9hZEFjY291bnRDYWxsTG9nVmlldykge1xuICAgIElMb2FkQWNjb3VudENhbGxMb2dWaWV3W0lMb2FkQWNjb3VudENhbGxMb2dWaWV3W1wiU2ltcGxlXCJdID0gJ1NpbXBsZSddID0gXCJTaW1wbGVcIjtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nVmlld1tJTG9hZEFjY291bnRDYWxsTG9nVmlld1tcIkRldGFpbGVkXCJdID0gJ0RldGFpbGVkJ10gPSBcIkRldGFpbGVkXCI7XG59KShleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dWaWV3IHx8IChleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dWaWV3ID0ge30pKTtcbnZhciBJTG9hZEFjY291bnRDYWxsTG9nVmlldyA9IGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXc7XG4oZnVuY3Rpb24gKElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb24pIHtcbiAgICBJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uW0lMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb25bSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb24gfHwgKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbiA9IGV4cG9ydHMuSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGUpIHtcbiAgICBJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZVtJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGVbSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZSB8fCAoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGUgPSBleHBvcnRzLklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlO1xuKGZ1bmN0aW9uIChJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb24pIHtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb25bSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb25bSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uIHx8IChleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uID0gZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb247XG4oZnVuY3Rpb24gKElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGUpIHtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlW0lMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGVbSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGUgfHwgKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZSA9IHt9KSk7XG52YXIgSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZSA9IGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZTtcbihmdW5jdGlvbiAoSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlldykge1xuICAgIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXdbSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlld1tcIlNpbXBsZVwiXSA9ICdTaW1wbGUnXSA9IFwiU2ltcGxlXCI7XG4gICAgSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlld1tJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3W1wiRGV0YWlsZWRcIl0gPSAnRGV0YWlsZWQnXSA9IFwiRGV0YWlsZWRcIjtcbn0pKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlldyB8fCAoZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3ID0ge30pKTtcbnZhciBJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3ID0gZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3O1xuKGZ1bmN0aW9uIChJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZSkge1xuICAgIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlW0lTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlW1wiRlN5bmNcIl0gPSAnRlN5bmMnXSA9IFwiRlN5bmNcIjtcbiAgICBJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZVtJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZVtcIklTeW5jXCJdID0gJ0lTeW5jJ10gPSBcIklTeW5jXCI7XG59KShleHBvcnRzLklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlIHx8IChleHBvcnRzLklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlID0ge30pKTtcbnZhciBJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZSA9IGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGU7XG4oZnVuY3Rpb24gKElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwKSB7XG4gICAgSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXBbSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXBbXCJNaXNzZWRcIl0gPSAnTWlzc2VkJ10gPSBcIk1pc3NlZFwiO1xuICAgIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwW0lTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwW1wiQWxsXCJdID0gJ0FsbCddID0gXCJBbGxcIjtcbn0pKGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXAgfHwgKGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXAgPSB7fSkpO1xudmFyIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwID0gZXhwb3J0cy5JU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cDtcblxuXG4vKioqLyB9LFxuLyogNDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEFjY291bnRBY3RpdmVDYWxscyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRBY3RpdmVDYWxscywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50QWN0aXZlQ2FsbHMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50QWN0aXZlQ2FsbHMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBjYWxsbG9ncmVjb3JkLkNhbGxMb2dSZWNvcmQsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRBY3RpdmVDYWxscy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRBY3RpdmVDYWxscyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudEFjdGl2ZUNhbGxzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50QWN0aXZlQ2FsbHMgPSBBY2NvdW50QWN0aXZlQ2FsbHM7XG5cblxuLyoqKi8gfSxcbi8qIDQyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2djYWxsZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG52YXIgcmVjb3JkaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xudmFyIGNhbGxsb2dyZWNvcmRsZWdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG52YXIgQ2FsbExvZ1JlY29yZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGxMb2dSZWNvcmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsbExvZ1JlY29yZCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2Vzc2lvbklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmcm9tJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0bycsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBDYWxsTG9nUmVjb3JkVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGlyZWN0aW9uJywgQ2xhc3M6IENhbGxMb2dSZWNvcmREaXJlY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FjdGlvbicsIENsYXNzOiBDYWxsTG9nUmVjb3JkQWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZXN1bHQnLCBDbGFzczogQ2FsbExvZ1JlY29yZFJlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhcnRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFzdE1vZGlmaWVkVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHJhbnNwb3J0JywgQ2xhc3M6IENhbGxMb2dSZWNvcmRUcmFuc3BvcnQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xlZ3MnLCBDbGFzczogY2FsbGxvZ3JlY29yZGxlZ2luZm8uQ2FsbExvZ1JlY29yZExlZ0luZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2FsbExvZ1JlY29yZC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NhbGxMb2dSZWNvcmQnO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxMb2dSZWNvcmQ7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNhbGxMb2dSZWNvcmQgPSBDYWxsTG9nUmVjb3JkO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkVHlwZSkge1xuICAgIENhbGxMb2dSZWNvcmRUeXBlW0NhbGxMb2dSZWNvcmRUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBDYWxsTG9nUmVjb3JkVHlwZVtDYWxsTG9nUmVjb3JkVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRUeXBlIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRUeXBlID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkVHlwZSA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZFR5cGU7XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmREaXJlY3Rpb24pIHtcbiAgICBDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0NhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIENhbGxMb2dSZWNvcmREaXJlY3Rpb25bQ2FsbExvZ1JlY29yZERpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmREaXJlY3Rpb24gfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZERpcmVjdGlvbiA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZERpcmVjdGlvbiA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZERpcmVjdGlvbjtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZEFjdGlvbikge1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUGhvbmVDYWxsXCJdID0gJ1Bob25lIENhbGwnXSA9IFwiUGhvbmVDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUGhvbmVMb2dpblwiXSA9ICdQaG9uZSBMb2dpbiddID0gXCJQaG9uZUxvZ2luXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiSW5jb21pbmdGYXhcIl0gPSAnSW5jb21pbmcgRmF4J10gPSBcIkluY29taW5nRmF4XCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiQWNjZXB0Q2FsbFwiXSA9ICdBY2NlcHQgQ2FsbCddID0gXCJBY2NlcHRDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiRmluZE1lXCJdID0gJ0ZpbmRNZSddID0gXCJGaW5kTWVcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJGb2xsb3dNZVwiXSA9ICdGb2xsb3dNZSddID0gXCJGb2xsb3dNZVwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIk91dGdvaW5nRmF4XCJdID0gJ091dGdvaW5nIEZheCddID0gXCJPdXRnb2luZ0ZheFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxSZXR1cm5cIl0gPSAnQ2FsbCBSZXR1cm4nXSA9IFwiQ2FsbFJldHVyblwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxpbmdDYXJkXCJdID0gJ0NhbGxpbmcgQ2FyZCddID0gXCJDYWxsaW5nQ2FyZFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdEaXJlY3RseVwiXSA9ICdSaW5nIERpcmVjdGx5J10gPSBcIlJpbmdEaXJlY3RseVwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRXZWJcIl0gPSAnUmluZ091dCBXZWInXSA9IFwiUmluZ091dFdlYlwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlZvSVBDYWxsXCJdID0gJ1ZvSVAgQ2FsbCddID0gXCJWb0lQQ2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRQQ1wiXSA9ICdSaW5nT3V0IFBDJ10gPSBcIlJpbmdPdXRQQ1wiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdNZVwiXSA9ICdSaW5nTWUnXSA9IFwiUmluZ01lXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiVHJhbnNmZXJcIl0gPSAnVHJhbnNmZXInXSA9IFwiVHJhbnNmZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bJzQxMUluZm8nXSA9ICc0MTEgSW5mbyddID0gJzQxMUluZm8nO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkVtZXJnZW5jeVwiXSA9ICdFbWVyZ2VuY3knXSA9IFwiRW1lcmdlbmN5XCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uWydFOTExVXBkYXRlJ10gPSAnRTkxMSBVcGRhdGUnXSA9ICdFOTExVXBkYXRlJztcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJTdXBwb3J0XCJdID0gJ1N1cHBvcnQnXSA9IFwiU3VwcG9ydFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRNb2JpbGVcIl0gPSAnUmluZ091dCBNb2JpbGUnXSA9IFwiUmluZ091dE1vYmlsZVwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkQWN0aW9uIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRBY3Rpb24gPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRBY3Rpb24gPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRBY3Rpb247XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRSZXN1bHQpIHtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEluUHJvZ3Jlc3NcIl0gPSAnUmVzdWx0SW5Qcm9ncmVzcyddID0gXCJSZXN1bHRJblByb2dyZXNzXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiTWlzc2VkXCJdID0gJ01pc3NlZCddID0gXCJNaXNzZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsYWNjZXB0ZWRcIl0gPSAnQ2FsbCBhY2NlcHRlZCddID0gXCJDYWxsYWNjZXB0ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJWb2ljZW1haWxcIl0gPSAnVm9pY2VtYWlsJ10gPSBcIlZvaWNlbWFpbFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVwbHlcIl0gPSAnUmVwbHknXSA9IFwiUmVwbHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWNlaXZlZFwiXSA9ICdSZWNlaXZlZCddID0gXCJSZWNlaXZlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlY2VpdmVFcnJvclwiXSA9ICdSZWNlaXZlIEVycm9yJ10gPSBcIlJlY2VpdmVFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheG9uRGVtYW5kXCJdID0gJ0ZheCBvbiBEZW1hbmQnXSA9IFwiRmF4b25EZW1hbmRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsUmVjZWl2ZVwiXSA9ICdQYXJ0aWFsIFJlY2VpdmUnXSA9IFwiUGFydGlhbFJlY2VpdmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJCbG9ja2VkXCJdID0gJ0Jsb2NrZWQnXSA9IFwiQmxvY2tlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxjb25uZWN0ZWRcIl0gPSAnQ2FsbCBjb25uZWN0ZWQnXSA9IFwiQ2FsbGNvbm5lY3RlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIk5vQW5zd2VyXCJdID0gJ05vIEFuc3dlciddID0gXCJOb0Fuc3dlclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsIERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VuZEVycm9yXCJdID0gJ1NlbmQgRXJyb3InXSA9IFwiU2VuZEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb2ZheG1hY2hpbmVcIl0gPSAnTm8gZmF4IG1hY2hpbmUnXSA9IFwiTm9mYXhtYWNoaW5lXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVzdWx0RW1wdHlcIl0gPSAnUmVzdWx0RW1wdHknXSA9IFwiUmVzdWx0RW1wdHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJBY2NvdW50XCJdID0gJ0FjY291bnQnXSA9IFwiQWNjb3VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlN1c3BlbmRlZFwiXSA9ICdTdXNwZW5kZWQnXSA9IFwiU3VzcGVuZGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWxlZFwiXSA9ICdDYWxsIEZhaWxlZCddID0gXCJDYWxsRmFpbGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWx1cmVcIl0gPSAnQ2FsbCBGYWlsdXJlJ10gPSBcIkNhbGxGYWlsdXJlXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSW50ZXJuYWxFcnJvclwiXSA9ICdJbnRlcm5hbCBFcnJvciddID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSVBQaG9uZW9mZmxpbmVcIl0gPSAnSVAgUGhvbmUgb2ZmbGluZSddID0gXCJJUFBob25lb2ZmbGluZVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3RyaWN0ZWROdW1iZXJcIl0gPSAnUmVzdHJpY3RlZCBOdW1iZXInXSA9IFwiUmVzdHJpY3RlZE51bWJlclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIldyb25nTnVtYmVyXCJdID0gJ1dyb25nIE51bWJlciddID0gXCJXcm9uZ051bWJlclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlN0b3BwZWRcIl0gPSAnU3RvcHBlZCddID0gXCJTdG9wcGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSGFuZ3VwXCJdID0gJ0hhbmcgdXAnXSA9IFwiSGFuZ3VwXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUG9vckxpbmVRdWFsaXR5XCJdID0gJ1Bvb3IgTGluZSBRdWFsaXR5J10gPSBcIlBvb3JMaW5lUXVhbGl0eVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlBhcnRpYWxseVNlbnRcIl0gPSAnUGFydGlhbGx5IFNlbnQnXSA9IFwiUGFydGlhbGx5U2VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiXSA9ICdJbnRlcm5hdGlvbmFsIFJlc3RyaWN0aW9uJ10gPSBcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkFiYW5kb25lZFwiXSA9ICdBYmFuZG9uZWQnXSA9IFwiQWJhbmRvbmVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRGVjbGluZWRcIl0gPSAnRGVjbGluZWQnXSA9IFwiRGVjbGluZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhSZWNlaXB0RXJyb3JcIl0gPSAnRmF4IFJlY2VpcHQgRXJyb3InXSA9IFwiRmF4UmVjZWlwdEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4U2VuZEVycm9yXCJdID0gJ0ZheCBTZW5kIEVycm9yJ10gPSBcIkZheFNlbmRFcnJvclwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkUmVzdWx0IHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRSZXN1bHQgPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRSZXN1bHQgPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRSZXN1bHQ7XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRUcmFuc3BvcnQpIHtcbiAgICBDYWxsTG9nUmVjb3JkVHJhbnNwb3J0W0NhbGxMb2dSZWNvcmRUcmFuc3BvcnRbXCJQU1ROXCJdID0gJ1BTVE4nXSA9IFwiUFNUTlwiO1xuICAgIENhbGxMb2dSZWNvcmRUcmFuc3BvcnRbQ2FsbExvZ1JlY29yZFRyYW5zcG9ydFtcIlZvSVBcIl0gPSAnVm9JUCddID0gXCJWb0lQXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRUcmFuc3BvcnQgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZFRyYW5zcG9ydCA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZFRyYW5zcG9ydCA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZFRyYW5zcG9ydDtcblxuXG4vKioqLyB9LFxuLyogNDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQ2FsbExvZ0NhbGxlckluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxsTG9nQ2FsbGVySW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsTG9nQ2FsbGVySW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbGxMb2dDYWxsZXJJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Bob25lTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xvY2F0aW9uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2FsbExvZ0NhbGxlckluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDYWxsTG9nQ2FsbGVySW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbExvZ0NhbGxlckluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNhbGxMb2dDYWxsZXJJbmZvID0gQ2FsbExvZ0NhbGxlckluZm87XG5cblxuLyoqKi8gfSxcbi8qIDQ0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFJlY29yZGluZ0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWNvcmRpbmdJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlY29yZGluZ0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZWNvcmRpbmdJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogUmVjb3JkaW5nSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbnRlbnRVcmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBSZWNvcmRpbmdJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUmVjb3JkaW5nSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjb3JkaW5nSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUmVjb3JkaW5nSW5mbyA9IFJlY29yZGluZ0luZm87XG4oZnVuY3Rpb24gKFJlY29yZGluZ0luZm9UeXBlKSB7XG4gICAgUmVjb3JkaW5nSW5mb1R5cGVbUmVjb3JkaW5nSW5mb1R5cGVbXCJBdXRvbWF0aWNcIl0gPSAnQXV0b21hdGljJ10gPSBcIkF1dG9tYXRpY1wiO1xuICAgIFJlY29yZGluZ0luZm9UeXBlW1JlY29yZGluZ0luZm9UeXBlW1wiT25EZW1hbmRcIl0gPSAnT25EZW1hbmQnXSA9IFwiT25EZW1hbmRcIjtcbn0pKGV4cG9ydHMuUmVjb3JkaW5nSW5mb1R5cGUgfHwgKGV4cG9ydHMuUmVjb3JkaW5nSW5mb1R5cGUgPSB7fSkpO1xudmFyIFJlY29yZGluZ0luZm9UeXBlID0gZXhwb3J0cy5SZWNvcmRpbmdJbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogNDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZXh0ZW5zaW9uaW5mb2NhbGxsb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcbnZhciBjYWxsbG9nY2FsbGVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xudmFyIHJlY29yZGluZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGxMb2dSZWNvcmRMZWdJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGxMb2dSZWNvcmRMZWdJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYWN0aW9uJywgQ2xhc3M6IENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkaXJlY3Rpb24nLCBDbGFzczogQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2R1cmF0aW9uJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb24nLCBDbGFzczogZXh0ZW5zaW9uaW5mb2NhbGxsb2cuRXh0ZW5zaW9uSW5mb0NhbGxMb2csIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xlZ1R5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXJ0VGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Jlc3VsdCcsIENsYXNzOiBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZnJvbScsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndG8nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RyYW5zcG9ydCcsIENsYXNzOiBDYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ2FsbExvZ1JlY29yZExlZ0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxMb2dSZWNvcmRMZWdJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mbyA9IENhbGxMb2dSZWNvcmRMZWdJbmZvO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbikge1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlBob25lQ2FsbFwiXSA9ICdQaG9uZSBDYWxsJ10gPSBcIlBob25lQ2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiUGhvbmVMb2dpblwiXSA9ICdQaG9uZSBMb2dpbiddID0gXCJQaG9uZUxvZ2luXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJJbmNvbWluZ0ZheFwiXSA9ICdJbmNvbWluZyBGYXgnXSA9IFwiSW5jb21pbmdGYXhcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkFjY2VwdENhbGxcIl0gPSAnQWNjZXB0IENhbGwnXSA9IFwiQWNjZXB0Q2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiRmluZE1lXCJdID0gJ0ZpbmRNZSddID0gXCJGaW5kTWVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkZvbGxvd01lXCJdID0gJ0ZvbGxvd01lJ10gPSBcIkZvbGxvd01lXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJPdXRnb2luZ0ZheFwiXSA9ICdPdXRnb2luZyBGYXgnXSA9IFwiT3V0Z29pbmdGYXhcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkNhbGxSZXR1cm5cIl0gPSAnQ2FsbCBSZXR1cm4nXSA9IFwiQ2FsbFJldHVyblwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiQ2FsbGluZ0NhcmRcIl0gPSAnQ2FsbGluZyBDYXJkJ10gPSBcIkNhbGxpbmdDYXJkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJSaW5nRGlyZWN0bHlcIl0gPSAnUmluZyBEaXJlY3RseSddID0gXCJSaW5nRGlyZWN0bHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlJpbmdPdXRXZWJcIl0gPSAnUmluZ091dCBXZWInXSA9IFwiUmluZ091dFdlYlwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiVm9JUENhbGxcIl0gPSAnVm9JUCBDYWxsJ10gPSBcIlZvSVBDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJSaW5nT3V0UENcIl0gPSAnUmluZ091dCBQQyddID0gXCJSaW5nT3V0UENcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlJpbmdNZVwiXSA9ICdSaW5nTWUnXSA9IFwiUmluZ01lXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJUcmFuc2ZlclwiXSA9ICdUcmFuc2ZlciddID0gXCJUcmFuc2ZlclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uWyc0MTFJbmZvJ10gPSAnNDExIEluZm8nXSA9ICc0MTFJbmZvJztcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkVtZXJnZW5jeVwiXSA9ICdFbWVyZ2VuY3knXSA9IFwiRW1lcmdlbmN5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bJ0U5MTFVcGRhdGUnXSA9ICdFOTExIFVwZGF0ZSddID0gJ0U5MTFVcGRhdGUnO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiU3VwcG9ydFwiXSA9ICdTdXBwb3J0J10gPSBcIlN1cHBvcnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlJpbmdPdXRNb2JpbGVcIl0gPSAnUmluZ091dCBNb2JpbGUnXSA9IFwiUmluZ091dE1vYmlsZVwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbiB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbiA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb24gPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbikge1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbiA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb247XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZSkge1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZVtDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZVtDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGUgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGUgPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZTtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHQpIHtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJSZXN1bHRJblByb2dyZXNzXCJdID0gJ1Jlc3VsdEluUHJvZ3Jlc3MnXSA9IFwiUmVzdWx0SW5Qcm9ncmVzc1wiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiTWlzc2VkXCJdID0gJ01pc3NlZCddID0gXCJNaXNzZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkNhbGxhY2NlcHRlZFwiXSA9ICdDYWxsIGFjY2VwdGVkJ10gPSBcIkNhbGxhY2NlcHRlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJSZXBseVwiXSA9ICdSZXBseSddID0gXCJSZXBseVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlY2VpdmVFcnJvclwiXSA9ICdSZWNlaXZlIEVycm9yJ10gPSBcIlJlY2VpdmVFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiRmF4b25EZW1hbmRcIl0gPSAnRmF4IG9uIERlbWFuZCddID0gXCJGYXhvbkRlbWFuZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUGFydGlhbFJlY2VpdmVcIl0gPSAnUGFydGlhbCBSZWNlaXZlJ10gPSBcIlBhcnRpYWxSZWNlaXZlXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJCbG9ja2VkXCJdID0gJ0Jsb2NrZWQnXSA9IFwiQmxvY2tlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQ2FsbGNvbm5lY3RlZFwiXSA9ICdDYWxsIGNvbm5lY3RlZCddID0gXCJDYWxsY29ubmVjdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJOb0Fuc3dlclwiXSA9ICdObyBBbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsIERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlNlbmRFcnJvclwiXSA9ICdTZW5kIEVycm9yJ10gPSBcIlNlbmRFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIk5vZmF4bWFjaGluZVwiXSA9ICdObyBmYXggbWFjaGluZSddID0gXCJOb2ZheG1hY2hpbmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlc3VsdEVtcHR5XCJdID0gJ1Jlc3VsdEVtcHR5J10gPSBcIlJlc3VsdEVtcHR5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJBY2NvdW50XCJdID0gJ0FjY291bnQnXSA9IFwiQWNjb3VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkNhbGxGYWlsZWRcIl0gPSAnQ2FsbCBGYWlsZWQnXSA9IFwiQ2FsbEZhaWxlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQ2FsbEZhaWx1cmVcIl0gPSAnQ2FsbCBGYWlsdXJlJ10gPSBcIkNhbGxGYWlsdXJlXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJJbnRlcm5hbEVycm9yXCJdID0gJ0ludGVybmFsIEVycm9yJ10gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIklQUGhvbmVvZmZsaW5lXCJdID0gJ0lQIFBob25lIG9mZmxpbmUnXSA9IFwiSVBQaG9uZW9mZmxpbmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlc3RyaWN0ZWROdW1iZXJcIl0gPSAnUmVzdHJpY3RlZCBOdW1iZXInXSA9IFwiUmVzdHJpY3RlZE51bWJlclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiV3JvbmdOdW1iZXJcIl0gPSAnV3JvbmcgTnVtYmVyJ10gPSBcIldyb25nTnVtYmVyXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJTdG9wcGVkXCJdID0gJ1N0b3BwZWQnXSA9IFwiU3RvcHBlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiSGFuZ3VwXCJdID0gJ0hhbmcgdXAnXSA9IFwiSGFuZ3VwXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJQb29yTGluZVF1YWxpdHlcIl0gPSAnUG9vciBMaW5lIFF1YWxpdHknXSA9IFwiUG9vckxpbmVRdWFsaXR5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJQYXJ0aWFsbHlTZW50XCJdID0gJ1BhcnRpYWxseSBTZW50J10gPSBcIlBhcnRpYWxseVNlbnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiXSA9ICdJbnRlcm5hdGlvbmFsIFJlc3RyaWN0aW9uJ10gPSBcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQWJhbmRvbmVkXCJdID0gJ0FiYW5kb25lZCddID0gXCJBYmFuZG9uZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkRlY2xpbmVkXCJdID0gJ0RlY2xpbmVkJ10gPSBcIkRlY2xpbmVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJGYXhSZWNlaXB0RXJyb3JcIl0gPSAnRmF4IFJlY2VpcHQgRXJyb3InXSA9IFwiRmF4UmVjZWlwdEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJGYXhTZW5kRXJyb3JcIl0gPSAnRmF4IFNlbmQgRXJyb3InXSA9IFwiRmF4U2VuZEVycm9yXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0IHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0ID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdCA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHQ7XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0KSB7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnRbQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnRbXCJQU1ROXCJdID0gJ1BTVE4nXSA9IFwiUFNUTlwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0W0NhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0W1wiVm9JUFwiXSA9ICdWb0lQJ10gPSBcIlZvSVBcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnQgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnQgPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0ID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydDtcblxuXG4vKioqLyB9LFxuLyogNDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRXh0ZW5zaW9uSW5mb0NhbGxMb2cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25JbmZvQ2FsbExvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25JbmZvQ2FsbExvZygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkluZm9DYWxsTG9nLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25JbmZvQ2FsbExvZy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkluZm9DYWxsTG9nJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25JbmZvQ2FsbExvZztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uSW5mb0NhbGxMb2cgPSBFeHRlbnNpb25JbmZvQ2FsbExvZztcblxuXG4vKioqLyB9LFxuLyogNDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEFjY291bnRDYWxsTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudENhbGxMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudENhbGxMb2coKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50Q2FsbExvZy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGNhbGxsb2dyZWNvcmQuQ2FsbExvZ1JlY29yZCwgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudENhbGxMb2cucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50Q2FsbExvZyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudENhbGxMb2c7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRDYWxsTG9nID0gQWNjb3VudENhbGxMb2c7XG5cblxuLyoqKi8gfSxcbi8qIDQ4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2djYWxsZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG52YXIgcmVjb3JkaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xudmFyIEFjY291bnRDYWxsTG9nUmVjb3JkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudENhbGxMb2dSZWNvcmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudENhbGxMb2dSZWNvcmQoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXNzaW9uSWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Zyb20nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IEFjY291bnRDYWxsTG9nUmVjb3JkVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGlyZWN0aW9uJywgQ2xhc3M6IEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhY3Rpb24nLCBDbGFzczogQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Jlc3VsdCcsIENsYXNzOiBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhcnRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudENhbGxMb2dSZWNvcmQnO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRDYWxsTG9nUmVjb3JkO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZCA9IEFjY291bnRDYWxsTG9nUmVjb3JkO1xuKGZ1bmN0aW9uIChBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGUpIHtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGVbQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGVbQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlIHx8IChleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkVHlwZSA9IHt9KSk7XG52YXIgQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlID0gZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZFR5cGU7XG4oZnVuY3Rpb24gKEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uKSB7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb24gfHwgKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSB7fSkpO1xudmFyIEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uID0gZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbjtcbihmdW5jdGlvbiAoQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24pIHtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJQaG9uZUNhbGxcIl0gPSAnUGhvbmUgQ2FsbCddID0gXCJQaG9uZUNhbGxcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lTG9naW5cIl0gPSAnUGhvbmUgTG9naW4nXSA9IFwiUGhvbmVMb2dpblwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiSW5jb21pbmdGYXhcIl0gPSAnSW5jb21pbmcgRmF4J10gPSBcIkluY29taW5nRmF4XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJBY2NlcHRDYWxsXCJdID0gJ0FjY2VwdCBDYWxsJ10gPSBcIkFjY2VwdENhbGxcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIkZpbmRNZVwiXSA9ICdGaW5kTWUnXSA9IFwiRmluZE1lXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJGb2xsb3dNZVwiXSA9ICdGb2xsb3dNZSddID0gXCJGb2xsb3dNZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiT3V0Z29pbmdGYXhcIl0gPSAnT3V0Z29pbmcgRmF4J10gPSBcIk91dGdvaW5nRmF4XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsUmV0dXJuXCJdID0gJ0NhbGwgUmV0dXJuJ10gPSBcIkNhbGxSZXR1cm5cIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxpbmdDYXJkXCJdID0gJ0NhbGxpbmcgQ2FyZCddID0gXCJDYWxsaW5nQ2FyZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ0RpcmVjdGx5XCJdID0gJ1JpbmcgRGlyZWN0bHknXSA9IFwiUmluZ0RpcmVjdGx5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0V2ViXCJdID0gJ1JpbmdPdXQgV2ViJ10gPSBcIlJpbmdPdXRXZWJcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlZvSVBDYWxsXCJdID0gJ1ZvSVAgQ2FsbCddID0gXCJWb0lQQ2FsbFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ091dFBDXCJdID0gJ1JpbmdPdXQgUEMnXSA9IFwiUmluZ091dFBDXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nTWVcIl0gPSAnUmluZ01lJ10gPSBcIlJpbmdNZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiVHJhbnNmZXJcIl0gPSAnVHJhbnNmZXInXSA9IFwiVHJhbnNmZXJcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvblsnNDExSW5mbyddID0gJzQxMSBJbmZvJ10gPSAnNDExSW5mbyc7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJFbWVyZ2VuY3lcIl0gPSAnRW1lcmdlbmN5J10gPSBcIkVtZXJnZW5jeVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uWydFOTExVXBkYXRlJ10gPSAnRTkxMSBVcGRhdGUnXSA9ICdFOTExVXBkYXRlJztcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlN1cHBvcnRcIl0gPSAnU3VwcG9ydCddID0gXCJTdXBwb3J0XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0TW9iaWxlXCJdID0gJ1JpbmdPdXQgTW9iaWxlJ10gPSBcIlJpbmdPdXRNb2JpbGVcIjtcbn0pKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24gfHwgKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24gPSB7fSkpO1xudmFyIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uID0gZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbjtcbihmdW5jdGlvbiAoQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHQpIHtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN1bHRJblByb2dyZXNzXCJdID0gJ1Jlc3VsdEluUHJvZ3Jlc3MnXSA9IFwiUmVzdWx0SW5Qcm9ncmVzc1wiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiTWlzc2VkXCJdID0gJ01pc3NlZCddID0gXCJNaXNzZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxhY2NlcHRlZFwiXSA9ICdDYWxsIGFjY2VwdGVkJ10gPSBcIkNhbGxhY2NlcHRlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXBseVwiXSA9ICdSZXBseSddID0gXCJSZXBseVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlY2VpdmVFcnJvclwiXSA9ICdSZWNlaXZlIEVycm9yJ10gPSBcIlJlY2VpdmVFcnJvclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4b25EZW1hbmRcIl0gPSAnRmF4IG9uIERlbWFuZCddID0gXCJGYXhvbkRlbWFuZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUGFydGlhbFJlY2VpdmVcIl0gPSAnUGFydGlhbCBSZWNlaXZlJ10gPSBcIlBhcnRpYWxSZWNlaXZlXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJCbG9ja2VkXCJdID0gJ0Jsb2NrZWQnXSA9IFwiQmxvY2tlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbGNvbm5lY3RlZFwiXSA9ICdDYWxsIGNvbm5lY3RlZCddID0gXCJDYWxsY29ubmVjdGVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb0Fuc3dlclwiXSA9ICdObyBBbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsIERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbmRFcnJvclwiXSA9ICdTZW5kIEVycm9yJ10gPSBcIlNlbmRFcnJvclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIk5vZmF4bWFjaGluZVwiXSA9ICdObyBmYXggbWFjaGluZSddID0gXCJOb2ZheG1hY2hpbmVcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEVtcHR5XCJdID0gJ1Jlc3VsdEVtcHR5J10gPSBcIlJlc3VsdEVtcHR5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJBY2NvdW50XCJdID0gJ0FjY291bnQnXSA9IFwiQWNjb3VudFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsZWRcIl0gPSAnQ2FsbCBGYWlsZWQnXSA9IFwiQ2FsbEZhaWxlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWx1cmVcIl0gPSAnQ2FsbCBGYWlsdXJlJ10gPSBcIkNhbGxGYWlsdXJlXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hbEVycm9yXCJdID0gJ0ludGVybmFsIEVycm9yJ10gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIklQUGhvbmVvZmZsaW5lXCJdID0gJ0lQIFBob25lIG9mZmxpbmUnXSA9IFwiSVBQaG9uZW9mZmxpbmVcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3RyaWN0ZWROdW1iZXJcIl0gPSAnUmVzdHJpY3RlZCBOdW1iZXInXSA9IFwiUmVzdHJpY3RlZE51bWJlclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiV3JvbmdOdW1iZXJcIl0gPSAnV3JvbmcgTnVtYmVyJ10gPSBcIldyb25nTnVtYmVyXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdG9wcGVkXCJdID0gJ1N0b3BwZWQnXSA9IFwiU3RvcHBlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSGFuZ3VwXCJdID0gJ0hhbmcgdXAnXSA9IFwiSGFuZ3VwXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJQb29yTGluZVF1YWxpdHlcIl0gPSAnUG9vciBMaW5lIFF1YWxpdHknXSA9IFwiUG9vckxpbmVRdWFsaXR5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsbHlTZW50XCJdID0gJ1BhcnRpYWxseSBTZW50J10gPSBcIlBhcnRpYWxseVNlbnRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiXSA9ICdJbnRlcm5hdGlvbmFsIFJlc3RyaWN0aW9uJ10gPSBcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQWJhbmRvbmVkXCJdID0gJ0FiYW5kb25lZCddID0gXCJBYmFuZG9uZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkRlY2xpbmVkXCJdID0gJ0RlY2xpbmVkJ10gPSBcIkRlY2xpbmVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhSZWNlaXB0RXJyb3JcIl0gPSAnRmF4IFJlY2VpcHQgRXJyb3InXSA9IFwiRmF4UmVjZWlwdEVycm9yXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhTZW5kRXJyb3JcIl0gPSAnRmF4IFNlbmQgRXJyb3InXSA9IFwiRmF4U2VuZEVycm9yXCI7XG59KShleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0IHx8IChleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0ID0ge30pKTtcbnZhciBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdCA9IGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHQ7XG5cblxuLyoqKi8gfSxcbi8qIDQ5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2dyZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBFeHRlbnNpb25BY3RpdmVDYWxscyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkFjdGl2ZUNhbGxzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkFjdGl2ZUNhbGxzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uQWN0aXZlQ2FsbHMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBjYWxsbG9ncmVjb3JkLkNhbGxMb2dSZWNvcmQsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkFjdGl2ZUNhbGxzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uQWN0aXZlQ2FsbHMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkFjdGl2ZUNhbGxzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25BY3RpdmVDYWxscyA9IEV4dGVuc2lvbkFjdGl2ZUNhbGxzO1xuXG5cbi8qKiovIH0sXG4vKiA1MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9ncmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkNhbGxMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uQ2FsbExvZygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkNhbGxMb2cucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBjYWxsbG9ncmVjb3JkLkNhbGxMb2dSZWNvcmQsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkNhbGxMb2cucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25DYWxsTG9nJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25DYWxsTG9nO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nID0gRXh0ZW5zaW9uQ2FsbExvZztcblxuXG4vKioqLyB9LFxuLyogNTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ2NhbGxlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbnZhciByZWNvcmRpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2Vzc2lvbklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmcm9tJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0bycsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGlyZWN0aW9uJywgQ2xhc3M6IEV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FjdGlvbicsIENsYXNzOiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZXN1bHQnLCBDbGFzczogRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhcnRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25DYWxsTG9nUmVjb3JkJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkID0gRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZDtcbihmdW5jdGlvbiAoRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGUpIHtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZVtFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGVbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZSB8fCAoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZSA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGUgPSBleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uKSB7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uIHx8IChleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSB7fSkpO1xudmFyIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSBleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb247XG4oZnVuY3Rpb24gKEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb24pIHtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lQ2FsbFwiXSA9ICdQaG9uZSBDYWxsJ10gPSBcIlBob25lQ2FsbFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lTG9naW5cIl0gPSAnUGhvbmUgTG9naW4nXSA9IFwiUGhvbmVMb2dpblwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkluY29taW5nRmF4XCJdID0gJ0luY29taW5nIEZheCddID0gXCJJbmNvbWluZ0ZheFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkFjY2VwdENhbGxcIl0gPSAnQWNjZXB0IENhbGwnXSA9IFwiQWNjZXB0Q2FsbFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkZpbmRNZVwiXSA9ICdGaW5kTWUnXSA9IFwiRmluZE1lXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiRm9sbG93TWVcIl0gPSAnRm9sbG93TWUnXSA9IFwiRm9sbG93TWVcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJPdXRnb2luZ0ZheFwiXSA9ICdPdXRnb2luZyBGYXgnXSA9IFwiT3V0Z29pbmdGYXhcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsUmV0dXJuXCJdID0gJ0NhbGwgUmV0dXJuJ10gPSBcIkNhbGxSZXR1cm5cIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsaW5nQ2FyZFwiXSA9ICdDYWxsaW5nIENhcmQnXSA9IFwiQ2FsbGluZ0NhcmRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nRGlyZWN0bHlcIl0gPSAnUmluZyBEaXJlY3RseSddID0gXCJSaW5nRGlyZWN0bHlcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0V2ViXCJdID0gJ1JpbmdPdXQgV2ViJ10gPSBcIlJpbmdPdXRXZWJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJWb0lQQ2FsbFwiXSA9ICdWb0lQIENhbGwnXSA9IFwiVm9JUENhbGxcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0UENcIl0gPSAnUmluZ091dCBQQyddID0gXCJSaW5nT3V0UENcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nTWVcIl0gPSAnUmluZ01lJ10gPSBcIlJpbmdNZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlRyYW5zZmVyXCJdID0gJ1RyYW5zZmVyJ10gPSBcIlRyYW5zZmVyXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uWyc0MTFJbmZvJ10gPSAnNDExIEluZm8nXSA9ICc0MTFJbmZvJztcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJFbWVyZ2VuY3lcIl0gPSAnRW1lcmdlbmN5J10gPSBcIkVtZXJnZW5jeVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvblsnRTkxMVVwZGF0ZSddID0gJ0U5MTEgVXBkYXRlJ10gPSAnRTkxMVVwZGF0ZSc7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiU3VwcG9ydFwiXSA9ICdTdXBwb3J0J10gPSBcIlN1cHBvcnRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0TW9iaWxlXCJdID0gJ1JpbmdPdXQgTW9iaWxlJ10gPSBcIlJpbmdPdXRNb2JpbGVcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbiB8fCAoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uID0ge30pKTtcbnZhciBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uID0gZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0KSB7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN1bHRJblByb2dyZXNzXCJdID0gJ1Jlc3VsdEluUHJvZ3Jlc3MnXSA9IFwiUmVzdWx0SW5Qcm9ncmVzc1wiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIk1pc3NlZFwiXSA9ICdNaXNzZWQnXSA9IFwiTWlzc2VkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbGFjY2VwdGVkXCJdID0gJ0NhbGwgYWNjZXB0ZWQnXSA9IFwiQ2FsbGFjY2VwdGVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlcGx5XCJdID0gJ1JlcGx5J10gPSBcIlJlcGx5XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWNlaXZlRXJyb3JcIl0gPSAnUmVjZWl2ZSBFcnJvciddID0gXCJSZWNlaXZlRXJyb3JcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhvbkRlbWFuZFwiXSA9ICdGYXggb24gRGVtYW5kJ10gPSBcIkZheG9uRGVtYW5kXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUGFydGlhbFJlY2VpdmVcIl0gPSAnUGFydGlhbCBSZWNlaXZlJ10gPSBcIlBhcnRpYWxSZWNlaXZlXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQmxvY2tlZFwiXSA9ICdCbG9ja2VkJ10gPSBcIkJsb2NrZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsY29ubmVjdGVkXCJdID0gJ0NhbGwgY29ubmVjdGVkJ10gPSBcIkNhbGxjb25uZWN0ZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb0Fuc3dlclwiXSA9ICdObyBBbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbCBEaXNhYmxlZCddID0gXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJCdXN5XCJdID0gJ0J1c3knXSA9IFwiQnVzeVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbmRFcnJvclwiXSA9ICdTZW5kIEVycm9yJ10gPSBcIlNlbmRFcnJvclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiTm9mYXhtYWNoaW5lXCJdID0gJ05vIGZheCBtYWNoaW5lJ10gPSBcIk5vZmF4bWFjaGluZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEVtcHR5XCJdID0gJ1Jlc3VsdEVtcHR5J10gPSBcIlJlc3VsdEVtcHR5XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQWNjb3VudFwiXSA9ICdBY2NvdW50J10gPSBcIkFjY291bnRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdXNwZW5kZWRcIl0gPSAnU3VzcGVuZGVkJ10gPSBcIlN1c3BlbmRlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsZWRcIl0gPSAnQ2FsbCBGYWlsZWQnXSA9IFwiQ2FsbEZhaWxlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsdXJlXCJdID0gJ0NhbGwgRmFpbHVyZSddID0gXCJDYWxsRmFpbHVyZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmFsRXJyb3JcIl0gPSAnSW50ZXJuYWwgRXJyb3InXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIklQUGhvbmVvZmZsaW5lXCJdID0gJ0lQIFBob25lIG9mZmxpbmUnXSA9IFwiSVBQaG9uZW9mZmxpbmVcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN0cmljdGVkTnVtYmVyXCJdID0gJ1Jlc3RyaWN0ZWQgTnVtYmVyJ10gPSBcIlJlc3RyaWN0ZWROdW1iZXJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJXcm9uZ051bWJlclwiXSA9ICdXcm9uZyBOdW1iZXInXSA9IFwiV3JvbmdOdW1iZXJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdG9wcGVkXCJdID0gJ1N0b3BwZWQnXSA9IFwiU3RvcHBlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkhhbmd1cFwiXSA9ICdIYW5nIHVwJ10gPSBcIkhhbmd1cFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlBvb3JMaW5lUXVhbGl0eVwiXSA9ICdQb29yIExpbmUgUXVhbGl0eSddID0gXCJQb29yTGluZVF1YWxpdHlcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsbHlTZW50XCJdID0gJ1BhcnRpYWxseSBTZW50J10gPSBcIlBhcnRpYWxseVNlbnRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIl0gPSAnSW50ZXJuYXRpb25hbCBSZXN0cmljdGlvbiddID0gXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJBYmFuZG9uZWRcIl0gPSAnQWJhbmRvbmVkJ10gPSBcIkFiYW5kb25lZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkRlY2xpbmVkXCJdID0gJ0RlY2xpbmVkJ10gPSBcIkRlY2xpbmVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4UmVjZWlwdEVycm9yXCJdID0gJ0ZheCBSZWNlaXB0IEVycm9yJ10gPSBcIkZheFJlY2VpcHRFcnJvclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheFNlbmRFcnJvclwiXSA9ICdGYXggU2VuZCBFcnJvciddID0gXCJGYXhTZW5kRXJyb3JcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdCB8fCAoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0ID0ge30pKTtcbnZhciBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0ID0gZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0O1xuXG5cbi8qKiovIH0sXG4vKiA1MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9ncmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG52YXIgc3luY2luZm9jYWxsbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG52YXIgQ2FsbExvZ1N5bmMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxsTG9nU3luYywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsTG9nU3luYygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbGxMb2dTeW5jLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogY2FsbGxvZ3JlY29yZC5DYWxsTG9nUmVjb3JkLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY0luZm8nLCBDbGFzczogc3luY2luZm9jYWxsbG9nLlN5bmNJbmZvQ2FsbExvZywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENhbGxMb2dTeW5jLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ2FsbExvZ1N5bmMnO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxMb2dTeW5jO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5DYWxsTG9nU3luYyA9IENhbGxMb2dTeW5jO1xuXG5cbi8qKiovIH0sXG4vKiA1MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTeW5jSW5mb0NhbGxMb2cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTeW5jSW5mb0NhbGxMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3luY0luZm9DYWxsTG9nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3luY0luZm9DYWxsTG9nLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUeXBlJywgQ2xhc3M6IFN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jVG9rZW4nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU3luY0luZm9DYWxsTG9nLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU3luY0luZm9DYWxsTG9nJztcbiAgICB9O1xuICAgIHJldHVybiBTeW5jSW5mb0NhbGxMb2c7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlN5bmNJbmZvQ2FsbExvZyA9IFN5bmNJbmZvQ2FsbExvZztcbihmdW5jdGlvbiAoU3luY0luZm9DYWxsTG9nU3luY1R5cGUpIHtcbiAgICBTeW5jSW5mb0NhbGxMb2dTeW5jVHlwZVtTeW5jSW5mb0NhbGxMb2dTeW5jVHlwZVtcIkZTeW5jXCJdID0gJ0ZTeW5jJ10gPSBcIkZTeW5jXCI7XG4gICAgU3luY0luZm9DYWxsTG9nU3luY1R5cGVbU3luY0luZm9DYWxsTG9nU3luY1R5cGVbXCJJU3luY1wiXSA9ICdJU3luYyddID0gXCJJU3luY1wiO1xufSkoZXhwb3J0cy5TeW5jSW5mb0NhbGxMb2dTeW5jVHlwZSB8fCAoZXhwb3J0cy5TeW5jSW5mb0NhbGxMb2dTeW5jVHlwZSA9IHt9KSk7XG52YXIgU3luY0luZm9DYWxsTG9nU3luY1R5cGUgPSBleHBvcnRzLlN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA1NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBDYWxsUmVjb3JkaW5nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsbFJlY29yZGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsUmVjb3JkaW5nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2FsbFJlY29yZGluZy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFVyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFR5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2R1cmF0aW9uJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2FsbFJlY29yZGluZy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NhbGxSZWNvcmRpbmcnO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxSZWNvcmRpbmc7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNhbGxSZWNvcmRpbmcgPSBDYWxsUmVjb3JkaW5nO1xuXG5cbi8qKiovIH0sXG4vKiA1NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgY291bnRyeWxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcbnZhciBkaWN0aW9uYXJ5Y291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcbnZhciBsYW5ndWFnZWxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcbnZhciBsYW5ndWFnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBkaWN0aW9uYXJ5bG9jYXRpb25saXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG52YXIgZGljdGlvbmFyeXNlY3JldHF1ZXN0aW9ubGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xudmFyIHNlY3JldHF1ZXN0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xudmFyIGRpY3Rpb25hcnlzaGlwcGluZ29wdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcbnZhciBkaWN0aW9uYXJ5c3RhdGVsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG52YXIgZGljdGlvbmFyeXN0YXRlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xudmFyIGRpY3Rpb25hcnl0aW1lem9uZWxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcbnZhciBkaWN0aW9uYXJ5dGltZXpvbmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG52YXIgRGljdGlvbmFyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBDb3VudHJ5IExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIHRoZSBjb3VudHJpZXMgYXZhaWxhYmxlIGZvciBjYWxsaW5nLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5saXN0Q291bnRyaWVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9jb3VudHJ5Jywgb3B0aW9ucywgZXhwb3J0cy5saXN0Q291bnRyaWVzT3B0aW9ucyksIGNvdW50cnlsaXN0LkNvdW50cnlMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBDb3VudHJ5XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTAgKFJlbGVhc2UgNi4yKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBpbmZvcm1hdGlvbiBvbiB0aGUgcmVxdWlyZWQgY291bnRyeS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZENvdW50cnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L2NvdW50cnkve2NvdW50cnlJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRDb3VudHJ5T3B0aW9ucyksIGRpY3Rpb25hcnljb3VudHJ5aW5mby5EaWN0aW9uYXJ5Q291bnRyeUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IExhbmd1YWdlIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xNCAoUmVsZWFzZSA2LjYpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGluZm9ybWF0aW9uIGFib3V0IHN1cHBvcnRlZCBsYW5ndWFnZXMuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxpc3RMYW5ndWFnZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L2xhbmd1YWdlJywgb3B0aW9ucywgZXhwb3J0cy5saXN0TGFuZ3VhZ2VzT3B0aW9ucyksIGxhbmd1YWdlbGlzdC5MYW5ndWFnZUxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IExhbmd1YWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTQgKFJlbGVhc2UgNi42KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGxhbmd1YWdlIGJ5IGl0cyByZXNwZWN0aXZlIElELjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5sb2FkTGFuZ3VhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L2xhbmd1YWdlL3tsYW5ndWFnZUlkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZExhbmd1YWdlT3B0aW9ucyksIGxhbmd1YWdlaW5mby5MYW5ndWFnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IExvY2F0aW9uIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIHRoZSBhdmFpbGFibGUgbG9jYXRpb25zIGZvciB0aGUgY2VydGFpbiBzdGF0ZS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubGlzdExvY2F0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvbG9jYXRpb24nLCBvcHRpb25zLCBleHBvcnRzLmxpc3RMb2NhdGlvbnNPcHRpb25zKSwgZGljdGlvbmFyeWxvY2F0aW9ubGlzdC5EaWN0aW9uYXJ5TG9jYXRpb25MaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBTZWNyZXQgUXVlc3Rpb24gTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjIwIChSZWxlYXNlIDcuNCk8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBzZWNyZXQgcXVlc3Rpb25zIGZvciBhIHNwZWNpZmljIGxhbmd1YWdlLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5saXN0U2VjcmV0UXVlc3Rpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9zZWNyZXQtcXVlc3Rpb24nLCBvcHRpb25zLCBleHBvcnRzLmxpc3RTZWNyZXRRdWVzdGlvbnNPcHRpb25zKSwgZGljdGlvbmFyeXNlY3JldHF1ZXN0aW9ubGlzdC5EaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBTZWNyZXQgUXVlc3Rpb25cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yMCAoUmVsZWFzZSA3LjQpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYSBwYXJ0aWN1bGFyIHNlY3JldCBxdWVzdGlvbiBpbiBzcGVjaWZpYyBsYW5ndWFnZSBieSBxdWVzdGlvbiBJRC48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZFNlY3JldFF1ZXN0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9zZWNyZXQtcXVlc3Rpb24vcXVlc3Rpb25JZCcsIG9wdGlvbnMsIGV4cG9ydHMubG9hZFNlY3JldFF1ZXN0aW9uT3B0aW9ucyksIHNlY3JldHF1ZXN0aW9uaW5mby5TZWNyZXRRdWVzdGlvbkluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFNoaXBwaW5nIE9wdGlvbnNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xNiAoUmVsZWFzZSA3LjEpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgZGV2aWNlIHNoaXBwaW5nIG9wdGlvbnMgd2l0aCB0aGVpciBwcmljZXMsIGFjY29yZGluZyB0byBicmFuZCwgdGllciwgbnVtYmVyIG9mIG9yZGVyZWQgZGV2aWNlcy48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubGlzdFNoaXBwaW5nT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvc2hpcHBpbmctb3B0aW9ucycsIG9wdGlvbnMsIGV4cG9ydHMubGlzdFNoaXBwaW5nT3B0aW9uc09wdGlvbnMpLCBkaWN0aW9uYXJ5c2hpcHBpbmdvcHRpb25zLkRpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFN0YXRlIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIHRoZSBzdGF0ZXMgZm9yIGEgY2VydGFpbiBjb3VudHJ5LjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5sb2FkbGlzdFN0YXRlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvc3RhdGUnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRsaXN0U3RhdGVzT3B0aW9ucyksIGRpY3Rpb25hcnlzdGF0ZWxpc3QuRGljdGlvbmFyeVN0YXRlTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU3RhdGVcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGluZm9ybWF0aW9uIG9uIHRoZSByZXF1aXJlZCBzdGF0ZS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZFN0YXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9zdGF0ZS97c3RhdGVJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRTdGF0ZU9wdGlvbnMpLCBkaWN0aW9uYXJ5c3RhdGVpbmZvLkRpY3Rpb25hcnlTdGF0ZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFRpbWV6b25lIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIGF2YWlsYWJsZSB0aW1lem9uZXMuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxpc3RUaW1lem9uZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L3RpbWV6b25lJywgb3B0aW9ucywgZXhwb3J0cy5saXN0VGltZXpvbmVzT3B0aW9ucyksIGRpY3Rpb25hcnl0aW1lem9uZWxpc3QuRGljdGlvbmFyeVRpbWV6b25lTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgVGltZXpvbmVcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGluZm9ybWF0aW9uIG9uIGEgY2VydGFpbiB0aW1lem9uZS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZFRpbWV6b25lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS90aW1lem9uZS97dGltZXpvbmVJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRUaW1lem9uZU9wdGlvbnMpLCBkaWN0aW9uYXJ5dGltZXpvbmVpbmZvLkRpY3Rpb25hcnlUaW1lem9uZUluZm8pO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnk7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuRGljdGlvbmFyeSA9IERpY3Rpb25hcnk7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdENvdW50cmllcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0Q291bnRyaWVzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImxvZ2luQWxsb3dlZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm51bWJlclNlbGxpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZENvdW50cnkgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZENvdW50cnlPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY291bnRyeUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RMYW5ndWFnZXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdExhbmd1YWdlc09wdGlvbnMgPSBbXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkTGFuZ3VhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZExhbmd1YWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImxhbmd1YWdlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdExvY2F0aW9ucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0TG9jYXRpb25zT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm9yZGVyQnlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RMb2NhdGlvbnNPcmRlckJ5XCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiTnBhXCIsXG4gICAgICAgICAgICBcIkNpdHlcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdGF0ZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ3aXRoTnh4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RTZWNyZXRRdWVzdGlvbnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdFNlY3JldFF1ZXN0aW9uc09wdGlvbnMgPSBbXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkU2VjcmV0UXVlc3Rpb24gb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFNlY3JldFF1ZXN0aW9uT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInF1ZXN0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdFNoaXBwaW5nT3B0aW9ucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0U2hpcHBpbmdPcHRpb25zT3B0aW9ucyA9IFtdO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRsaXN0U3RhdGVzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRsaXN0U3RhdGVzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNvdW50cnlJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwid2l0aFBob25lTnVtYmVyc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkU3RhdGUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFN0YXRlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0YXRlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdFRpbWV6b25lcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0VGltZXpvbmVzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkVGltZXpvbmUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFRpbWV6b25lT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInRpbWV6b25lSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4oZnVuY3Rpb24gKElMaXN0TG9jYXRpb25zT3JkZXJCeSkge1xuICAgIElMaXN0TG9jYXRpb25zT3JkZXJCeVtJTGlzdExvY2F0aW9uc09yZGVyQnlbXCJOcGFcIl0gPSAnTnBhJ10gPSBcIk5wYVwiO1xuICAgIElMaXN0TG9jYXRpb25zT3JkZXJCeVtJTGlzdExvY2F0aW9uc09yZGVyQnlbXCJDaXR5XCJdID0gJ0NpdHknXSA9IFwiQ2l0eVwiO1xufSkoZXhwb3J0cy5JTGlzdExvY2F0aW9uc09yZGVyQnkgfHwgKGV4cG9ydHMuSUxpc3RMb2NhdGlvbnNPcmRlckJ5ID0ge30pKTtcbnZhciBJTGlzdExvY2F0aW9uc09yZGVyQnkgPSBleHBvcnRzLklMaXN0TG9jYXRpb25zT3JkZXJCeTtcblxuXG4vKioqLyB9LFxuLyogNTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGljdGlvbmFyeWNvdW50cnlpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgQ291bnRyeUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb3VudHJ5TGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb3VudHJ5TGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvdW50cnlMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZGljdGlvbmFyeWNvdW50cnlpbmZvLkRpY3Rpb25hcnlDb3VudHJ5SW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ291bnRyeUxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDb3VudHJ5TGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gQ291bnRyeUxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNvdW50cnlMaXN0ID0gQ291bnRyeUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDU3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIERpY3Rpb25hcnlDb3VudHJ5SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlDb3VudHJ5SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5Q291bnRyeUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5Q291bnRyeUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbGluZ0NvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VtZXJnZW5jeUNhbGxpbmcnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpc29Db2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdudW1iZXJTZWxsaW5nJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9naW5BbGxvd2VkJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlDb3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlDb3VudHJ5SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeUNvdW50cnlJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5Q291bnRyeUluZm8gPSBEaWN0aW9uYXJ5Q291bnRyeUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDU4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGxhbmd1YWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIExhbmd1YWdlTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExhbmd1YWdlTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYW5ndWFnZUxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYW5ndWFnZUxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogbGFuZ3VhZ2VpbmZvLkxhbmd1YWdlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTGFuZ3VhZ2VMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTGFuZ3VhZ2VMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBMYW5ndWFnZUxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkxhbmd1YWdlTGlzdCA9IExhbmd1YWdlTGlzdDtcblxuXG4vKioqLyB9LFxuLyogNTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbG9jYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRGljdGlvbmFyeUxvY2F0aW9uTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlMb2NhdGlvbkxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeUxvY2F0aW9uTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlMb2NhdGlvbkxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBsb2NhdGlvbmluZm8uTG9jYXRpb25JbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeUxvY2F0aW9uTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlMb2NhdGlvbkxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlMb2NhdGlvbkxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlMb2NhdGlvbkxpc3QgPSBEaWN0aW9uYXJ5TG9jYXRpb25MaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA2MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBMb2NhdGlvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhdGlvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTG9jYXRpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTG9jYXRpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYXJlYUNvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NpdHknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25wYScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbnh4JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0ZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIExvY2F0aW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0xvY2F0aW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYXRpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Mb2NhdGlvbkluZm8gPSBMb2NhdGlvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDYxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHNlY3JldHF1ZXN0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBzZWNyZXRxdWVzdGlvbmluZm8uU2VjcmV0UXVlc3Rpb25JbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdCA9IERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDYyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFNlY3JldFF1ZXN0aW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlY3JldFF1ZXN0aW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWNyZXRRdWVzdGlvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZWNyZXRRdWVzdGlvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3F1ZXN0aW9uVHlwZScsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFuZ3VhZ2VJZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncXVlc3Rpb25UZXh0JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzaG93SW5TaWduVXAnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU2VjcmV0UXVlc3Rpb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU2VjcmV0UXVlc3Rpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTZWNyZXRRdWVzdGlvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlNlY3JldFF1ZXN0aW9uSW5mbyA9IFNlY3JldFF1ZXN0aW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogNjMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgc2hpcHBpbmdtZXRob2RpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG52YXIgRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncXVhbnRpdHknLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ByaWNlJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdtZXRob2QnLCBDbGFzczogc2hpcHBpbmdtZXRob2RpbmZvLlNoaXBwaW5nTWV0aG9kSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMnO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMgPSBEaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zO1xuXG5cbi8qKiovIH0sXG4vKiA2NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTaGlwcGluZ01ldGhvZEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaGlwcGluZ01ldGhvZEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2hpcHBpbmdNZXRob2RJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2hpcHBpbmdNZXRob2RJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU2hpcHBpbmdNZXRob2RJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU2hpcHBpbmdNZXRob2RJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTaGlwcGluZ01ldGhvZEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlNoaXBwaW5nTWV0aG9kSW5mbyA9IFNoaXBwaW5nTWV0aG9kSW5mbztcblxuXG4vKioqLyB9LFxuLyogNjUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGljdGlvbmFyeXN0YXRlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERpY3Rpb25hcnlTdGF0ZUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5U3RhdGVMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlTdGF0ZUxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5U3RhdGVMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZGljdGlvbmFyeXN0YXRlaW5mby5EaWN0aW9uYXJ5U3RhdGVJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5U3RhdGVMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVN0YXRlTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVN0YXRlTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVN0YXRlTGlzdCA9IERpY3Rpb25hcnlTdGF0ZUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDY2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHN0YXRlY291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBEaWN0aW9uYXJ5U3RhdGVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGljdGlvbmFyeVN0YXRlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5U3RhdGVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGljdGlvbmFyeVN0YXRlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb3VudHJ5JywgQ2xhc3M6IHN0YXRlY291bnRyeWluZm8uU3RhdGVDb3VudHJ5SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaXNvQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlTdGF0ZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWN0aW9uYXJ5U3RhdGVJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5U3RhdGVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5U3RhdGVJbmZvID0gRGljdGlvbmFyeVN0YXRlSW5mbztcblxuXG4vKioqLyB9LFxuLyogNjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgU3RhdGVDb3VudHJ5SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YXRlQ291bnRyeUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhdGVDb3VudHJ5SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFN0YXRlQ291bnRyeUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFN0YXRlQ291bnRyeUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTdGF0ZUNvdW50cnlJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZUNvdW50cnlJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5TdGF0ZUNvdW50cnlJbmZvID0gU3RhdGVDb3VudHJ5SW5mbztcblxuXG4vKioqLyB9LFxuLyogNjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGljdGlvbmFyeXRpbWV6b25laW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERpY3Rpb25hcnlUaW1lem9uZUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5VGltZXpvbmVMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlUaW1lem9uZUxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5VGltZXpvbmVMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZGljdGlvbmFyeXRpbWV6b25laW5mby5EaWN0aW9uYXJ5VGltZXpvbmVJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5VGltZXpvbmVMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVRpbWV6b25lTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVRpbWV6b25lTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVRpbWV6b25lTGlzdCA9IERpY3Rpb25hcnlUaW1lem9uZUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDY5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIERpY3Rpb25hcnlUaW1lem9uZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5VGltZXpvbmVJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlUaW1lem9uZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5VGltZXpvbmVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Rlc2NyaXB0aW9uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeVRpbWV6b25lSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlUaW1lem9uZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlUaW1lem9uZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlUaW1lem9uZUluZm8gPSBEaWN0aW9uYXJ5VGltZXpvbmVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA3MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgZXh0ZW5zaW9ubGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xudmFyIGV4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIGV4dGVuc2lvbnBob25lbnVtYmVycyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xudmFyIGV4dGVuc2lvbmdyYW50bGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xudmFyIGRlcGFydG1lbnRtZW1iZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG52YXIgRXh0ZW5zaW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjA8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBleHRlbnNpb25zIGNyZWF0ZWQgZm9yIGEgcGFydGljdWxhciBhY2NvdW50LiBBbGwgdHlwZXMgb2YgZXh0ZW5zaW9ucyBhcmUgaW5jbHVkZWQgaW4gdGhpcyBsaXN0LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxpc3RFeHRlbnNpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24nLCBvcHRpb25zLCBleHBvcnRzLmxpc3RFeHRlbnNpb25zT3B0aW9ucyksIGV4dGVuc2lvbmxpc3QuRXh0ZW5zaW9uTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIEluZm9cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4wPC9wPlxuICAgICAqIDxwPlJldHVybnMgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgYSBwYXJ0aWN1bGFyIGV4dGVuc2lvbiBvZiBhbiBhY2NvdW50LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUubG9hZEV4dGVuc2lvbkluZm8gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkRXh0ZW5zaW9uSW5mb09wdGlvbnMpLCBleHRlbnNpb25pbmZvLkV4dGVuc2lvbkluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBQaG9uZSBOdW1iZXIgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBwaG9uZSBudW1iZXJzIHRoYXQgYXJlIHVzZWQgYnkgYSBwYXJ0aWN1bGFyIGV4dGVuc2lvbiwgYW5kIGNhbiBiZSBmaWx0ZXJlZCBieSB0aGUgcGhvbmUgbnVtYmVyIHR5cGUuIFRoZSByZXR1cm5lZCBsaXN0IGNvbnRhaW5zIGFsbCBudW1iZXJzIHdoaWNoIGFyZSBkaXJlY3RseSBtYXBwZWQgdG8gYSBnaXZlbiBleHRlbnNpb24gcGx1cyB0aGUgZmVhdHVyZXMgYW5kIGFsc28gY29tcGFueS1sZXZlbCBudW1iZXJzXG4gICAgICogICAgIHdoaWNoIG1heSBiZSB1c2VkIHdoZW4gcGVyZm9ybWluZyBkaWZmZXJlbnQgb3BlcmF0aW9ucyBvbiBiZWhhbGYgb2YgdGhpcyBleHRlbnNpb24uPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5saXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9waG9uZS1udW1iZXInLCBvcHRpb25zLCBleHBvcnRzLmxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNPcHRpb25zKSwgZXh0ZW5zaW9ucGhvbmVudW1iZXJzLkV4dGVuc2lvblBob25lTnVtYmVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIEdyYW50IExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBsaXN0IG9mIGV4dGVuc2lvbiBncmFudHMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5saXN0RXh0ZW5zaW9uR3JhbnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9ncmFudCcsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEV4dGVuc2lvbkdyYW50c09wdGlvbnMpLCBleHRlbnNpb25ncmFudGxpc3QuRXh0ZW5zaW9uR3JhbnRMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gUHJvZmlsZSBJbWFnZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGV4dGVuc2lvbiBwcm9maWxlIGltYWdlLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxvYWRFeHRlbnNpb25Qcm9maWxlSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3Byb2ZpbGUtaW1hZ2UnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRFeHRlbnNpb25Qcm9maWxlSW1hZ2VPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgRXh0ZW5zaW9uIFByb2ZpbGUgSW1hZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBleHRlbnNpb24gcHJvZmlsZSBpbWFnZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgbXkgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IaWdoPC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUuY3JlYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJvZmlsZS1pbWFnZScsIG9wdGlvbnMsIGV4cG9ydHMuY3JlYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIEV4dGVuc2lvbiBQcm9maWxlIEltYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+VXBkYXRlcyB0aGUgZXh0ZW5zaW9uIHByb2ZpbGUgaW1hZ2UuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIG15IGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGlnaDwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLnVwZGF0ZUV4dGVuc2lvblByb2ZpbGVJbWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BVVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJvZmlsZS1pbWFnZScsIG9wdGlvbnMsIGV4cG9ydHMudXBkYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBQcm9maWxlIEltYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgc2NhbGVkIHByb2ZpbGUgaW1hZ2Ugb2YgYW4gZXh0ZW5zaW9uLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxvYWRFeHRlbnNpb25TY2FsZWRQcm9maWxlSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3Byb2ZpbGUtaW1hZ2Uve3NjYWxlU2l6ZX0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRFeHRlbnNpb25TY2FsZWRQcm9maWxlSW1hZ2VPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRGVwYXJ0bWVudCBNZW1iZXIgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUubGlzdERlcGFydG1lbnRNZW1iZXJzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9kZXBhcnRtZW50L3tkZXBhcnRtZW50SWR9L21lbWJlcnMnLCBvcHRpb25zLCBleHBvcnRzLmxpc3REZXBhcnRtZW50TWVtYmVyc09wdGlvbnMpLCBkZXBhcnRtZW50bWVtYmVycy5EZXBhcnRtZW50TWVtYmVycyk7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLkV4dGVuc2lvbiA9IEV4dGVuc2lvbjtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0RXh0ZW5zaW9ucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RXh0ZW5zaW9uc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0YXR1c1wiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEV4dGVuc2lvbnNTdGF0dXNcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJFbmFibGVkXCIsXG4gICAgICAgICAgICBcIkRpc2FibGVkXCIsXG4gICAgICAgICAgICBcIk5vdEFjdGl2YXRlZFwiLFxuICAgICAgICAgICAgXCJVbmFzc2lnbmVkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEV4dGVuc2lvbnNUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiVXNlclwiLFxuICAgICAgICAgICAgXCJGYXhVc2VyXCIsXG4gICAgICAgICAgICBcIlZpcnR1YWxVc2VyXCIsXG4gICAgICAgICAgICBcIkRpZ2l0YWxVc2VyXCIsXG4gICAgICAgICAgICBcIkRlcGFydG1lbnRcIixcbiAgICAgICAgICAgIFwiQW5ub3VuY2VtZW50XCIsXG4gICAgICAgICAgICBcIlZvaWNlbWFpbFwiLFxuICAgICAgICAgICAgXCJTaGFyZWRMaW5lc0dyb3VwXCIsXG4gICAgICAgICAgICBcIlBhZ2luZ09ubHlHcm91cFwiLFxuICAgICAgICAgICAgXCJJdnJNZW51XCIsXG4gICAgICAgICAgICBcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCIsXG4gICAgICAgICAgICBcIlBhcmtMb2NhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkRXh0ZW5zaW9uSW5mbyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkRXh0ZW5zaW9uSW5mb09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEV4dGVuc2lvblBob25lTnVtYmVycyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInVzYWdlVHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIk1haW5Db21wYW55TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkNvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiRGlyZWN0TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkNvbXBhbnlGYXhOdW1iZXJcIixcbiAgICAgICAgICAgIFwiRm9yd2FyZGVkTnVtYmVyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RFeHRlbnNpb25HcmFudHMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEV4dGVuc2lvbkdyYW50c09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEV4dGVuc2lvblByb2ZpbGVJbWFnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBjcmVhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuY3JlYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkRXh0ZW5zaW9uU2NhbGVkUHJvZmlsZUltYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRFeHRlbnNpb25TY2FsZWRQcm9maWxlSW1hZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic2NhbGVTaXplXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3REZXBhcnRtZW50TWVtYmVycyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RGVwYXJ0bWVudE1lbWJlcnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkZXBhcnRtZW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4oZnVuY3Rpb24gKElMaXN0RXh0ZW5zaW9uc1N0YXR1cykge1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJFbmFibGVkXCJdID0gJ0VuYWJsZWQnXSA9IFwiRW5hYmxlZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJEaXNhYmxlZFwiXSA9ICdEaXNhYmxlZCddID0gXCJEaXNhYmxlZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJOb3RBY3RpdmF0ZWRcIl0gPSAnTm90QWN0aXZhdGVkJ10gPSBcIk5vdEFjdGl2YXRlZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJVbmFzc2lnbmVkXCJdID0gJ1VuYXNzaWduZWQnXSA9IFwiVW5hc3NpZ25lZFwiO1xufSkoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbnNTdGF0dXMgfHwgKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25zU3RhdHVzID0ge30pKTtcbnZhciBJTGlzdEV4dGVuc2lvbnNTdGF0dXMgPSBleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1N0YXR1cztcbihmdW5jdGlvbiAoSUxpc3RFeHRlbnNpb25zVHlwZSkge1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIlVzZXJcIl0gPSAnVXNlciddID0gXCJVc2VyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiRmF4VXNlclwiXSA9ICdGYXhVc2VyJ10gPSBcIkZheFVzZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJWaXJ0dWFsVXNlclwiXSA9ICdWaXJ0dWFsVXNlciddID0gXCJWaXJ0dWFsVXNlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIkRpZ2l0YWxVc2VyXCJdID0gJ0RpZ2l0YWxVc2VyJ10gPSBcIkRpZ2l0YWxVc2VyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiRGVwYXJ0bWVudFwiXSA9ICdEZXBhcnRtZW50J10gPSBcIkRlcGFydG1lbnRcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJBbm5vdW5jZW1lbnRcIl0gPSAnQW5ub3VuY2VtZW50J10gPSBcIkFubm91bmNlbWVudFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIlZvaWNlbWFpbFwiXSA9ICdWb2ljZW1haWwnXSA9IFwiVm9pY2VtYWlsXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiU2hhcmVkTGluZXNHcm91cFwiXSA9ICdTaGFyZWRMaW5lc0dyb3VwJ10gPSBcIlNoYXJlZExpbmVzR3JvdXBcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJQYWdpbmdPbmx5R3JvdXBcIl0gPSAnUGFnaW5nT25seUdyb3VwJ10gPSBcIlBhZ2luZ09ubHlHcm91cFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIkl2ck1lbnVcIl0gPSAnSXZyTWVudSddID0gXCJJdnJNZW51XCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiQXBwbGljYXRpb25FeHRlbnNpb25cIl0gPSAnQXBwbGljYXRpb25FeHRlbnNpb24nXSA9IFwiQXBwbGljYXRpb25FeHRlbnNpb25cIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJQYXJrTG9jYXRpb25cIl0gPSAnUGFya0xvY2F0aW9uJ10gPSBcIlBhcmtMb2NhdGlvblwiO1xufSkoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbnNUeXBlIHx8IChleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1R5cGUgPSB7fSkpO1xudmFyIElMaXN0RXh0ZW5zaW9uc1R5cGUgPSBleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1R5cGU7XG4oZnVuY3Rpb24gKElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlKSB7XG4gICAgSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJNYWluQ29tcGFueU51bWJlclwiXSA9ICdNYWluQ29tcGFueU51bWJlciddID0gXCJNYWluQ29tcGFueU51bWJlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIl0gPSAnQWRkaXRpb25hbENvbXBhbnlOdW1iZXInXSA9IFwiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkNvbXBhbnlOdW1iZXJcIl0gPSAnQ29tcGFueU51bWJlciddID0gXCJDb21wYW55TnVtYmVyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJEaXJlY3ROdW1iZXJcIl0gPSAnRGlyZWN0TnVtYmVyJ10gPSBcIkRpcmVjdE51bWJlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQ29tcGFueUZheE51bWJlclwiXSA9ICdDb21wYW55RmF4TnVtYmVyJ10gPSBcIkNvbXBhbnlGYXhOdW1iZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkZvcndhcmRlZE51bWJlclwiXSA9ICdGb3J3YXJkZWROdW1iZXInXSA9IFwiRm9yd2FyZGVkTnVtYmVyXCI7XG59KShleHBvcnRzLklMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlIHx8IChleHBvcnRzLklMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlID0ge30pKTtcbnZhciBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZSA9IGV4cG9ydHMuSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDcxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGV4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEV4dGVuc2lvbkxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25MaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25MaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZXh0ZW5zaW9uaW5mby5FeHRlbnNpb25JbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25MaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uTGlzdCA9IEV4dGVuc2lvbkxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDcyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHBob25lbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEV4dGVuc2lvblBob25lTnVtYmVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvblBob25lTnVtYmVycywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25QaG9uZU51bWJlcnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25QaG9uZU51bWJlcnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBwaG9uZW51bWJlcmluZm8uUGhvbmVOdW1iZXJJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25QaG9uZU51bWJlcnMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25QaG9uZU51bWJlcnMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvblBob25lTnVtYmVycztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uUGhvbmVOdW1iZXJzID0gRXh0ZW5zaW9uUGhvbmVOdW1iZXJzO1xuXG5cbi8qKiovIH0sXG4vKiA3MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBncmFudGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBFeHRlbnNpb25HcmFudExpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25HcmFudExpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uR3JhbnRMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uR3JhbnRMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZ3JhbnRpbmZvLkdyYW50SW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uR3JhbnRMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uR3JhbnRMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25HcmFudExpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkdyYW50TGlzdCA9IEV4dGVuc2lvbkdyYW50TGlzdDtcblxuXG4vKioqLyB9LFxuLyogNzQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZXh0ZW5zaW9uaW5mb2dyYW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xudmFyIEdyYW50SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyYW50SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcmFudEluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHcmFudEluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb24nLCBDbGFzczogZXh0ZW5zaW9uaW5mb2dyYW50cy5FeHRlbnNpb25JbmZvR3JhbnRzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsUGlja3VwJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbE1vbml0b3JpbmcnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgR3JhbnRJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnR3JhbnRJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBHcmFudEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkdyYW50SW5mbyA9IEdyYW50SW5mbztcblxuXG4vKioqLyB9LFxuLyogNzUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRXh0ZW5zaW9uSW5mb0dyYW50cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkluZm9HcmFudHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uSW5mb0dyYW50cygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkluZm9HcmFudHMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IEV4dGVuc2lvbkluZm9HcmFudHNUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50cy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkluZm9HcmFudHMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkluZm9HcmFudHM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkluZm9HcmFudHMgPSBFeHRlbnNpb25JbmZvR3JhbnRzO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvR3JhbnRzVHlwZSkge1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiVXNlclwiXSA9ICdVc2VyJ10gPSBcIlVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkZheFVzZXJcIl0gPSAnRmF4IFVzZXInXSA9IFwiRmF4VXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiVmlydHVhbFVzZXJcIl0gPSAnVmlydHVhbFVzZXInXSA9IFwiVmlydHVhbFVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkRpZ2l0YWxVc2VyXCJdID0gJ0RpZ2l0YWxVc2VyJ10gPSBcIkRpZ2l0YWxVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJEZXBhcnRtZW50XCJdID0gJ0RlcGFydG1lbnQnXSA9IFwiRGVwYXJ0bWVudFwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiQW5ub3VuY2VtZW50XCJdID0gJ0Fubm91bmNlbWVudCddID0gXCJBbm5vdW5jZW1lbnRcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIlZvaWNlbWFpbFwiXSA9ICdWb2ljZW1haWwnXSA9IFwiVm9pY2VtYWlsXCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJTaGFyZWRMaW5lc0dyb3VwXCJdID0gJ1NoYXJlZExpbmVzR3JvdXAnXSA9IFwiU2hhcmVkTGluZXNHcm91cFwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiUGFnaW5nT25seVwiXSA9ICdQYWdpbmdPbmx5J10gPSBcIlBhZ2luZ09ubHlcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkl2ck1lbnVcIl0gPSAnSXZyTWVudSddID0gXCJJdnJNZW51XCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiXSA9ICdBcHBsaWNhdGlvbkV4dGVuc2lvbiddID0gXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiUGFya0xvY2F0aW9uXCJdID0gJ1BhcmsgTG9jYXRpb24nXSA9IFwiUGFya0xvY2F0aW9uXCI7XG59KShleHBvcnRzLkV4dGVuc2lvbkluZm9HcmFudHNUeXBlIHx8IChleHBvcnRzLkV4dGVuc2lvbkluZm9HcmFudHNUeXBlID0ge30pKTtcbnZhciBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZSA9IGV4cG9ydHMuRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDc2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGV4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERlcGFydG1lbnRNZW1iZXJzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVwYXJ0bWVudE1lbWJlcnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVwYXJ0bWVudE1lbWJlcnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEZXBhcnRtZW50TWVtYmVycy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGV4dGVuc2lvbmluZm8uRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGVwYXJ0bWVudE1lbWJlcnMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEZXBhcnRtZW50TWVtYmVycyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGVwYXJ0bWVudE1lbWJlcnM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRlcGFydG1lbnRNZW1iZXJzID0gRGVwYXJ0bWVudE1lbWJlcnM7XG5cblxuLyoqKi8gfSxcbi8qIDc3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBtZXNzYWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xudmFyIG1lc3NhZ2VsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG52YXIgbWVzc2FnZXN5bmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyKTtcbnZhciBNZXNzYWdlcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFBhZ2VyIE1lc3NhZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPkNyZWF0ZXMgYW5kIHNlbmRzIGEgcGFnZXIgbWVzc2FnZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkludGVybmFsTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5TZW5kaW5nIGFuZCByZWNlaXZpbmcgaW50cmEtY29tcGFueSB0ZXh0IG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUuc2VuZEludGVybmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2NvbXBhbnktcGFnZXInLCBvcHRpb25zLCBleHBvcnRzLnNlbmRJbnRlcm5hbE1lc3NhZ2VPcHRpb25zKSwgbWVzc2FnZWluZm8uTWVzc2FnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIEZheCBNZXNzYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5DcmVhdGVzIGFuZCBzZW5kcy9yZXNlbmRzIG5ldyBmYXggbWVzc2FnZS4gUmVzZW5kIGNhbiBiZSBkb25lIGlmIHNlbmRpbmcgZmFpbGVkLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RmF4ZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5TZW5kaW5nIGFuZCByZWNlaXZpbmcgZmF4ZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnNlbmRGYXhNZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vZmF4Jywgb3B0aW9ucywgZXhwb3J0cy5zZW5kRmF4TWVzc2FnZU9wdGlvbnMpLCBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgU01TIE1lc3NhZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPkNyZWF0ZXMgYW5kIHNlbmRzIG5ldyBTTVMgbWVzc2FnZS4gU2VuZGluZyBTTVMgbWVzc2FnZXMgc2ltdWx0YW5lb3VzbHkgdG8gZGlmZmVyZW50IHJlY2lwaWVudHMgaXMgbGltaXRlZCB1cCB0byA1MCByZXF1ZXN0cyBwZXIgbWludXRlOyByZWxldmFudCBmb3IgYWxsIGNsaWVudCBhcHBsaWNhdGlvbnMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5TTVM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5TZW5kaW5nIGFuZCByZWNlaXZpbmcgU01TICh0ZXh0KSBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnNlbmRTTVMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9zbXMnLCBvcHRpb25zLCBleHBvcnRzLnNlbmRTTVNPcHRpb25zKSwgbWVzc2FnZWluZm8uTWVzc2FnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1lc3NhZ2UgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBtZXNzYWdlcyBmcm9tIGFuIGV4dGVuc2lvbiBtYWlsYm94LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUubGlzdE1lc3NhZ2VzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN0b3JlJywgb3B0aW9ucywgZXhwb3J0cy5saXN0TWVzc2FnZXNPcHRpb25zKSwgbWVzc2FnZWxpc3QuTWVzc2FnZUxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1lc3NhZ2UocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgaW5kaXZpZHVhbCBtZXNzYWdlIHJlY29yZChzKSBieSB0aGUgZ2l2ZW4gbWVzc2FnZSBJRChzKS4gVGhlIGxlbmd0aCBvZiBpbmJvdW5kIG1lc3NhZ2VzIGlzIHVubGltaXRlZC4gQmF0Y2ggcmVxdWVzdCBpcyBzdXBwb3J0ZWQsIHNlZSBCYXRjaCBSZXF1ZXN0cyBmb3IgZGV0YWlscy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLmxvYWRNZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN0b3JlL3ttZXNzYWdlSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkTWVzc2FnZU9wdGlvbnMpLCBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgTWVzc2FnZShzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+VXBkYXRlcyBtZXNzYWdlKHMpIGJ5IElEKHMpLiBCYXRjaCByZXF1ZXN0IGlzIHN1cHBvcnRlZCwgc2VlIEJhdGNoIFJlcXVlc3RzIGZvciBkZXRhaWxzLiBDdXJyZW50bHksIG9ubHkgdGhlIG1lc3NhZ2UgcmVhZCBzdGF0dXMgdXBkYXRpbmcgaXMgc3VwcG9ydGVkLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnVwZGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L21lc3NhZ2Utc3RvcmUve21lc3NhZ2VJZH0nLCBvcHRpb25zLCBleHBvcnRzLnVwZGF0ZU1lc3NhZ2VPcHRpb25zKSwgbWVzc2FnZWluZm8uTWVzc2FnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIE1lc3NhZ2UocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5EZWxldGVzIG1lc3NhZ2UocykgYnkgdGhlIGdpdmVuIG1lc3NhZ2UgSUQocykuIFRoZSBmaXJzdCBjYWxsIG9mIHRoaXMgbWV0aG9kIHRyYW5zZmVycyB0aGUgbWVzc2FnZSB0byB0aGUgJ0RlbGV0ZScgc3RhdHVzLiBUaGUgc2Vjb25kIGNhbGwgdHJhbnNmZXJzIHRoZSBkZWxldGVkIG1lc3NhZ2UgdG8gdGhlICdQdXJnZWQnIHN0YXR1cy4gSWYgaXQgaXMgcmVxdWlyZWQgdG8gbWFrZSB0aGUgbWVzc2FnZSAnUHVyZ2VkJyBpbW1lZGlhdGVseVxuICAgICAqICAgICAoZnJvbSB0aGUgZmlyc3QgY2FsbCksIHRoZW4gc2V0IHRoZSBxdWVyeSBwYXJhbWV0ZXIgcHVyZ2UgdG8gJ1RydWUnLiBCYXRjaCByZXF1ZXN0IGlzIHN1cHBvcnRlZC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIE1lc3NhZ2VzLnByb3RvdHlwZS5kZWxldGVNZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN0b3JlL3ttZXNzYWdlSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5kZWxldGVNZXNzYWdlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1lc3NhZ2UgQXR0YWNobWVudFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjQgKFJlbGVhc2UgNS4xMyk8L3A+XG4gICAgICogPHA+UmV0dXJucyBwYXJ0aWN1bGFyIG1lc3NhZ2UgYXR0YWNobWVudCBkYXRhIGFzIGEgbWVkaWEgc3RyZWFtLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLmxvYWRNZXNzYWdlQXR0YWNobWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vbWVzc2FnZS1zdG9yZS97bWVzc2FnZUlkfS9jb250ZW50L3thdHRhY2htZW50SWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkTWVzc2FnZUF0dGFjaG1lbnRPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgTWVzc2FnZSBTeW5jXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNCAoUmVsZWFzZSA1LjEzKTwvcD5cbiAgICAgKiA8cD5Qcm92aWRlcyBmYWNpbGl0aWVzIHRvIHN5bmNocm9uaXplIG1haWxib3ggY29udGVudCBzdG9yZWQgZXh0ZXJuYWxseSB3aXRoIHNlcnZlciBzdGF0ZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnN5bmNNZXNzYWdlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vbWVzc2FnZS1zeW5jJywgb3B0aW9ucywgZXhwb3J0cy5zeW5jTWVzc2FnZXNPcHRpb25zKSwgbWVzc2FnZXN5bmMuTWVzc2FnZVN5bmMpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VzO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLk1lc3NhZ2VzID0gTWVzc2FnZXM7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc2VuZEludGVybmFsTWVzc2FnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5zZW5kSW50ZXJuYWxNZXNzYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVwYWdlcm1lc3NhZ2VyZXF1ZXN0LkNyZWF0ZVBhZ2VyTWVzc2FnZVJlcXVlc3RcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc2VuZEZheE1lc3NhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuc2VuZEZheE1lc3NhZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwibm90ZXNcIjogXCJcIixcbiAgICAgICAgXCJwYXJhbVR5cGVcIjogXCJwYXRoXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IFwiflwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiYWxsb3dNdWx0aXBsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJub3Rlc1wiOiBcIlwiLFxuICAgICAgICBcInBhcmFtVHlwZVwiOiBcInBhdGhcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogXCJ+XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJhbGxvd011bHRpcGxlXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJDb250ZW50LVR5cGVcIixcbiAgICAgICAgXCJpblwiOiBcImhlYWRlclwiLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJtdWx0aXBhcnQvbWl4ZWQ7IGJvdW5kYXJ5PUJvdW5kYXJ5XzFfMTQ0MTM5MDFfMTM2MTg3MTA4MDg4OFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJDb250ZW50LUxlbmd0aFwiLFxuICAgICAgICBcImluXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIlwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwiY29uc3VtZXNcIjogW1xuICAgICAgICAgICAgXCJtdWx0aXBhcnQvbWl4ZWQ7IGJvdW5kYXJ5PUJvdW5kYXJ5XzFfMTQ0MTM5MDFfMTM2MTg3MTA4MDg4OFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIi0tQm91bmRhcnlfMV8xNDQxMzkwMV8xMzYxODcxMDgwODg4XFxuQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXFxuXFxue1xcbiAgXFxcInRvXFxcIjpbe1xcXCJwaG9uZU51bWJlclxcXCI6XFxcIjE4MDA1NjMwMDAzXFxcIn1dLFxcbiAgXFxcImZheFJlc29sdXRpb25cXFwiOlxcXCJIaWdoXFxcIixcXG4gIFxcXCJzZW5kVGltZVxcXCI6XFxcIjIwMTMtMDItMjZUMDk6MzE6MjAuODgyWlxcXCJcXG59XFxuXFxuLS1Cb3VuZGFyeV8xXzE0NDEzOTAxXzEzNjE4NzEwODA4ODhcXG5Db250ZW50LVR5cGU6IHRleHQvcGxhaW5cXG5cXG5IZWxsbywgV29ybGQhXFxuXFxuLS1Cb3VuZGFyeV8xXzE0NDEzOTAxXzEzNjE4NzEwODA4ODgtLVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc2VuZFNNUyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5zZW5kU01TT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVzbXNtZXNzYWdlLkNyZWF0ZVNNU01lc3NhZ2VcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdE1lc3NhZ2VzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RNZXNzYWdlc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhdmFpbGFiaWxpdHlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkFsaXZlXCIsXG4gICAgICAgICAgICBcIkRlbGV0ZWRcIixcbiAgICAgICAgICAgIFwiUHVyZ2VkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY29udmVyc2F0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVGcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlVG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiSW5ib3VuZFwiLFxuICAgICAgICAgICAgXCJPdXRib3VuZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpc3RpbmN0Q29udmVyc2F0aW9uc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm1lc3NhZ2VUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkZheFwiLFxuICAgICAgICAgICAgXCJTTVNcIixcbiAgICAgICAgICAgIFwiVm9pY2VNYWlsXCIsXG4gICAgICAgICAgICBcIlBhZ2VyXCIsXG4gICAgICAgICAgICBcIlRleHRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyZWFkU3RhdHVzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0TWVzc2FnZXNSZWFkU3RhdHVzXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiUmVhZFwiLFxuICAgICAgICAgICAgXCJVbnJlYWRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwaG9uZU51bWJlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRNZXNzYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRNZXNzYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm1lc3NhZ2VJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGVNZXNzYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZU1lc3NhZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibWVzc2FnZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcInVwZGF0ZW1lc3NhZ2VyZXF1ZXN0LlVwZGF0ZU1lc3NhZ2VSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGRlbGV0ZU1lc3NhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZGVsZXRlTWVzc2FnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJtZXNzYWdlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwdXJnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNvbnZlcnNhdGlvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZE1lc3NhZ2VBdHRhY2htZW50IG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRNZXNzYWdlQXR0YWNobWVudE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhdHRhY2htZW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJtZXNzYWdlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc3luY01lc3NhZ2VzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnN5bmNNZXNzYWdlc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjb252ZXJzYXRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZUZyb21cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklTeW5jTWVzc2FnZXNEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlzdGluY3RDb252ZXJzYXRpb25zXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibWVzc2FnZVR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiRmF4XCIsXG4gICAgICAgICAgICBcIlNNU1wiLFxuICAgICAgICAgICAgXCJWb2ljZU1haWxcIixcbiAgICAgICAgICAgIFwiUGFnZXJcIixcbiAgICAgICAgICAgIFwiVGV4dFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInJlY29yZENvdW50XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzeW5jVG9rZW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN5bmNUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklTeW5jTWVzc2FnZXNTeW5jVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkZTeW5jXCIsXG4gICAgICAgICAgICBcIklTeW5jXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuKGZ1bmN0aW9uIChJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5KSB7XG4gICAgSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVtJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5W1wiQWxpdmVcIl0gPSAnQWxpdmUnXSA9IFwiQWxpdmVcIjtcbiAgICBJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5W0lMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHlbXCJEZWxldGVkXCJdID0gJ0RlbGV0ZWQnXSA9IFwiRGVsZXRlZFwiO1xuICAgIElMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHlbSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVtcIlB1cmdlZFwiXSA9ICdQdXJnZWQnXSA9IFwiUHVyZ2VkXCI7XG59KShleHBvcnRzLklMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHkgfHwgKGV4cG9ydHMuSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eSA9IHt9KSk7XG52YXIgSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eSA9IGV4cG9ydHMuSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eTtcbihmdW5jdGlvbiAoSUxpc3RNZXNzYWdlc0RpcmVjdGlvbikge1xuICAgIElMaXN0TWVzc2FnZXNEaXJlY3Rpb25bSUxpc3RNZXNzYWdlc0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSUxpc3RNZXNzYWdlc0RpcmVjdGlvbltJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSUxpc3RNZXNzYWdlc0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JTGlzdE1lc3NhZ2VzRGlyZWN0aW9uID0ge30pKTtcbnZhciBJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uID0gZXhwb3J0cy5JTGlzdE1lc3NhZ2VzRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGUpIHtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiU01TXCJdID0gJ1NNUyddID0gXCJTTVNcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVm9pY2VNYWlsXCJdID0gJ1ZvaWNlTWFpbCddID0gXCJWb2ljZU1haWxcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiUGFnZXJcIl0gPSAnUGFnZXInXSA9IFwiUGFnZXJcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVGV4dFwiXSA9ICdUZXh0J10gPSBcIlRleHRcIjtcbn0pKGV4cG9ydHMuSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlIHx8IChleHBvcnRzLklMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlID0gZXhwb3J0cy5JTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKElMaXN0TWVzc2FnZXNSZWFkU3RhdHVzKSB7XG4gICAgSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXNbSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXNbXCJSZWFkXCJdID0gJ1JlYWQnXSA9IFwiUmVhZFwiO1xuICAgIElMaXN0TWVzc2FnZXNSZWFkU3RhdHVzW0lMaXN0TWVzc2FnZXNSZWFkU3RhdHVzW1wiVW5yZWFkXCJdID0gJ1VucmVhZCddID0gXCJVbnJlYWRcIjtcbn0pKGV4cG9ydHMuSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXMgfHwgKGV4cG9ydHMuSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXMgPSB7fSkpO1xudmFyIElMaXN0TWVzc2FnZXNSZWFkU3RhdHVzID0gZXhwb3J0cy5JTGlzdE1lc3NhZ2VzUmVhZFN0YXR1cztcbihmdW5jdGlvbiAoSVN5bmNNZXNzYWdlc0RpcmVjdGlvbikge1xuICAgIElTeW5jTWVzc2FnZXNEaXJlY3Rpb25bSVN5bmNNZXNzYWdlc0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSVN5bmNNZXNzYWdlc0RpcmVjdGlvbltJU3luY01lc3NhZ2VzRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSVN5bmNNZXNzYWdlc0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JU3luY01lc3NhZ2VzRGlyZWN0aW9uID0ge30pKTtcbnZhciBJU3luY01lc3NhZ2VzRGlyZWN0aW9uID0gZXhwb3J0cy5JU3luY01lc3NhZ2VzRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGUpIHtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiU01TXCJdID0gJ1NNUyddID0gXCJTTVNcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVm9pY2VNYWlsXCJdID0gJ1ZvaWNlTWFpbCddID0gXCJWb2ljZU1haWxcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiUGFnZXJcIl0gPSAnUGFnZXInXSA9IFwiUGFnZXJcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVGV4dFwiXSA9ICdUZXh0J10gPSBcIlRleHRcIjtcbn0pKGV4cG9ydHMuSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlIHx8IChleHBvcnRzLklTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZSA9IHt9KSk7XG52YXIgSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlID0gZXhwb3J0cy5JU3luY01lc3NhZ2VzTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKElTeW5jTWVzc2FnZXNTeW5jVHlwZSkge1xuICAgIElTeW5jTWVzc2FnZXNTeW5jVHlwZVtJU3luY01lc3NhZ2VzU3luY1R5cGVbXCJGU3luY1wiXSA9ICdGU3luYyddID0gXCJGU3luY1wiO1xuICAgIElTeW5jTWVzc2FnZXNTeW5jVHlwZVtJU3luY01lc3NhZ2VzU3luY1R5cGVbXCJJU3luY1wiXSA9ICdJU3luYyddID0gXCJJU3luY1wiO1xufSkoZXhwb3J0cy5JU3luY01lc3NhZ2VzU3luY1R5cGUgfHwgKGV4cG9ydHMuSVN5bmNNZXNzYWdlc1N5bmNUeXBlID0ge30pKTtcbnZhciBJU3luY01lc3NhZ2VzU3luY1R5cGUgPSBleHBvcnRzLklTeW5jTWVzc2FnZXNTeW5jVHlwZTtcblxuXG4vKioqLyB9LFxuLyogNzggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbWVzc2FnZWF0dGFjaG1lbnRpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG52YXIgbWVzc2FnZXN0b3JlY2FsbGVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xudmFyIE1lc3NhZ2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVzc2FnZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhdHRhY2htZW50cycsIENsYXNzOiBtZXNzYWdlYXR0YWNobWVudGluZm8uTWVzc2FnZUF0dGFjaG1lbnRJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2F2YWlsYWJpbGl0eScsIENsYXNzOiBNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udmVyc2F0aW9uSWQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NyZWF0aW9uVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGVsaXZlcnlFcnJvckNvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RpcmVjdGlvbicsIENsYXNzOiBNZXNzYWdlSW5mb0RpcmVjdGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmF4UGFnZUNvdW50JywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmYXhSZXNvbHV0aW9uJywgQ2xhc3M6IE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZnJvbScsIENsYXNzOiBtZXNzYWdlc3RvcmVjYWxsZXJpbmZvLk1lc3NhZ2VTdG9yZUNhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhc3RNb2RpZmllZFRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21lc3NhZ2VTdGF0dXMnLCBDbGFzczogTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwZ1RvRGVwYXJ0bWVudCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ByaW9yaXR5JywgQ2xhc3M6IE1lc3NhZ2VJbmZvUHJpb3JpdHksIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlYWRTdGF0dXMnLCBDbGFzczogTWVzc2FnZUluZm9SZWFkU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzbXNEZWxpdmVyeVRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Ntc1NlbmRpbmdBdHRlbXB0c0NvdW50JywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdWJqZWN0JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0bycsIENsYXNzOiBtZXNzYWdlc3RvcmVjYWxsZXJpbmZvLk1lc3NhZ2VTdG9yZUNhbGxlckluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBNZXNzYWdlSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ZtVHJhbnNjcmlwdGlvblN0YXR1cycsIENsYXNzOiBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE1lc3NhZ2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTWVzc2FnZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5NZXNzYWdlSW5mbyA9IE1lc3NhZ2VJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSkge1xuICAgIE1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5W01lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5W1wiQWxpdmVcIl0gPSAnQWxpdmUnXSA9IFwiQWxpdmVcIjtcbiAgICBNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eVtNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eVtcIkRlbGV0ZWRcIl0gPSAnRGVsZXRlZCddID0gXCJEZWxldGVkXCI7XG4gICAgTWVzc2FnZUluZm9BdmFpbGFiaWxpdHlbTWVzc2FnZUluZm9BdmFpbGFiaWxpdHlbXCJQdXJnZWRcIl0gPSAnUHVyZ2VkJ10gPSBcIlB1cmdlZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9BdmFpbGFiaWxpdHkgPSBleHBvcnRzLk1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5O1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb0RpcmVjdGlvbikge1xuICAgIE1lc3NhZ2VJbmZvRGlyZWN0aW9uW01lc3NhZ2VJbmZvRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBNZXNzYWdlSW5mb0RpcmVjdGlvbltNZXNzYWdlSW5mb0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvRGlyZWN0aW9uIHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvRGlyZWN0aW9uID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb0RpcmVjdGlvbiA9IGV4cG9ydHMuTWVzc2FnZUluZm9EaXJlY3Rpb247XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbikge1xuICAgIE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbltNZXNzYWdlSW5mb0ZheFJlc29sdXRpb25bXCJIaWdoXCJdID0gJ0hpZ2gnXSA9IFwiSGlnaFwiO1xuICAgIE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbltNZXNzYWdlSW5mb0ZheFJlc29sdXRpb25bXCJMb3dcIl0gPSAnTG93J10gPSBcIkxvd1wiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb0ZheFJlc29sdXRpb24gfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb0ZheFJlc29sdXRpb24gPSBleHBvcnRzLk1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbjtcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzKSB7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlF1ZXVlZFwiXSA9ICdRdWV1ZWQnXSA9IFwiUXVldWVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIkRlbGl2ZXJlZFwiXSA9ICdEZWxpdmVyZWQnXSA9IFwiRGVsaXZlcmVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIkRlbGl2ZXJ5RmFpbGVkXCJdID0gJ0RlbGl2ZXJ5RmFpbGVkJ10gPSBcIkRlbGl2ZXJ5RmFpbGVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbmRpbmdGYWlsZWRcIl0gPSAnU2VuZGluZ0ZhaWxlZCddID0gXCJTZW5kaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlJlY2VpdmVkXCJdID0gJ1JlY2VpdmVkJ10gPSBcIlJlY2VpdmVkXCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1cyB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXMgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1cyA9IGV4cG9ydHMuTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb1ByaW9yaXR5KSB7XG4gICAgTWVzc2FnZUluZm9Qcmlvcml0eVtNZXNzYWdlSW5mb1ByaW9yaXR5W1wiTm9ybWFsXCJdID0gJ05vcm1hbCddID0gXCJOb3JtYWxcIjtcbiAgICBNZXNzYWdlSW5mb1ByaW9yaXR5W01lc3NhZ2VJbmZvUHJpb3JpdHlbXCJIaWdoXCJdID0gJ0hpZ2gnXSA9IFwiSGlnaFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb1ByaW9yaXR5IHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvUHJpb3JpdHkgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvUHJpb3JpdHkgPSBleHBvcnRzLk1lc3NhZ2VJbmZvUHJpb3JpdHk7XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvUmVhZFN0YXR1cykge1xuICAgIE1lc3NhZ2VJbmZvUmVhZFN0YXR1c1tNZXNzYWdlSW5mb1JlYWRTdGF0dXNbXCJSZWFkXCJdID0gJ1JlYWQnXSA9IFwiUmVhZFwiO1xuICAgIE1lc3NhZ2VJbmZvUmVhZFN0YXR1c1tNZXNzYWdlSW5mb1JlYWRTdGF0dXNbXCJVbnJlYWRcIl0gPSAnVW5yZWFkJ10gPSBcIlVucmVhZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb1JlYWRTdGF0dXMgfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9SZWFkU3RhdHVzID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb1JlYWRTdGF0dXMgPSBleHBvcnRzLk1lc3NhZ2VJbmZvUmVhZFN0YXR1cztcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9UeXBlKSB7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlNNU1wiXSA9ICdTTVMnXSA9IFwiU01TXCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlZvaWNlTWFpbFwiXSA9ICdWb2ljZU1haWwnXSA9IFwiVm9pY2VNYWlsXCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlBhZ2VyXCJdID0gJ1BhZ2VyJ10gPSBcIlBhZ2VyXCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlRleHRcIl0gPSAnVGV4dCddID0gXCJUZXh0XCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvVHlwZSB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb1R5cGUgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvVHlwZSA9IGV4cG9ydHMuTWVzc2FnZUluZm9UeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cykge1xuICAgIE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW01lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW1wiTm90QXZhaWxhYmxlXCJdID0gJ05vdEF2YWlsYWJsZSddID0gXCJOb3RBdmFpbGFibGVcIjtcbiAgICBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tcIkluUHJvZ3Jlc3NcIl0gPSAnSW5Qcm9ncmVzcyddID0gXCJJblByb2dyZXNzXCI7XG4gICAgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbXCJUaW1lZE91dFwiXSA9ICdUaW1lZE91dCddID0gXCJUaW1lZE91dFwiO1xuICAgIE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW01lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW1wiQ29tcGxldGVkXCJdID0gJ0NvbXBsZXRlZCddID0gXCJDb21wbGV0ZWRcIjtcbiAgICBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tcIkNvbXBsZXRlZFBhcnRpYWxseVwiXSA9ICdDb21wbGV0ZWRQYXJ0aWFsbHknXSA9IFwiQ29tcGxldGVkUGFydGlhbGx5XCI7XG4gICAgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbXCJGYWlsZWRcIl0gPSAnRmFpbGVkJ10gPSBcIkZhaWxlZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cyB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cyA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXMgPSBleHBvcnRzLk1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA3OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBNZXNzYWdlQXR0YWNobWVudEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlQXR0YWNobWVudEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZUF0dGFjaG1lbnRJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFR5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ZtRHVyYXRpb24nLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNZXNzYWdlQXR0YWNobWVudEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VBdHRhY2htZW50SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTWVzc2FnZUF0dGFjaG1lbnRJbmZvID0gTWVzc2FnZUF0dGFjaG1lbnRJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlKSB7XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW1wiQXVkaW9SZWNvcmRpbmdcIl0gPSAnQXVkaW9SZWNvcmRpbmcnXSA9IFwiQXVkaW9SZWNvcmRpbmdcIjtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW01lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbXCJBdWRpb1RyYW5zY3JpcHRpb25cIl0gPSAnQXVkaW9UcmFuc2NyaXB0aW9uJ10gPSBcIkF1ZGlvVHJhbnNjcmlwdGlvblwiO1xuICAgIE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtcIlRleHRcIl0gPSAnVGV4dCddID0gXCJUZXh0XCI7XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW1wiU291cmNlRG9jdW1lbnRcIl0gPSAnU291cmNlRG9jdW1lbnQnXSA9IFwiU291cmNlRG9jdW1lbnRcIjtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW01lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbXCJSZW5kZXJlZERvY3VtZW50XCJdID0gJ1JlbmRlcmVkRG9jdW1lbnQnXSA9IFwiUmVuZGVyZWREb2N1bWVudFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlQXR0YWNobWVudEluZm9UeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGUgPSB7fSkpO1xudmFyIE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGUgPSBleHBvcnRzLk1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDgwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE1lc3NhZ2VTdG9yZUNhbGxlckluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlU3RvcmVDYWxsZXJJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VTdG9yZUNhbGxlckluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsb2NhdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbWVzc2FnZVN0YXR1cycsIENsYXNzOiBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmF4RXJyb3JDb2RlJywgQ2xhc3M6IE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Bob25lTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VTdG9yZUNhbGxlckluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VTdG9yZUNhbGxlckluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm8gPSBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cykge1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW1wiUXVldWVkXCJdID0gJ1F1ZXVlZCddID0gXCJRdWV1ZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbXCJEZWxpdmVyZWRcIl0gPSAnRGVsaXZlcmVkJ10gPSBcIkRlbGl2ZXJlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW1wiRGVsaXZlcnlGYWlsZWRcIl0gPSAnRGVsaXZlcnlGYWlsZWQnXSA9IFwiRGVsaXZlcnlGYWlsZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbmRpbmdGYWlsZWRcIl0gPSAnU2VuZGluZ0ZhaWxlZCddID0gXCJTZW5kaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbXCJSZWNlaXZlZFwiXSA9ICdSZWNlaXZlZCddID0gXCJSZWNlaXZlZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cyB8fCAoZXhwb3J0cy5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cyA9IHt9KSk7XG52YXIgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXMgPSBleHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzO1xuKGZ1bmN0aW9uIChNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlKSB7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiVW5kZWZpbmVkXCJdID0gJ1VuZGVmaW5lZCddID0gXCJVbmRlZmluZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJOb0ZheFNlbmRQZXJtaXNzaW9uXCJdID0gJ05vRmF4U2VuZFBlcm1pc3Npb24nXSA9IFwiTm9GYXhTZW5kUGVybWlzc2lvblwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIk5vSW50ZXJuYXRpb25hbFBlcm1pc3Npb25cIl0gPSAnTm9JbnRlcm5hdGlvbmFsUGVybWlzc2lvbiddID0gXCJOb0ludGVybmF0aW9uYWxQZXJtaXNzaW9uXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiTm9GYXhNYWNoaW5lXCJdID0gJ05vRmF4TWFjaGluZSddID0gXCJOb0ZheE1hY2hpbmVcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJPdXRnb2luZ0NhbGxFcnJvclwiXSA9ICdPdXRnb2luZ0NhbGxFcnJvciddID0gXCJPdXRnb2luZ0NhbGxFcnJvclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlJlbmRlcmluZ0ZhaWxlZFwiXSA9ICdSZW5kZXJpbmdGYWlsZWQnXSA9IFwiUmVuZGVyaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiVG9vTWFueVBhZ2VzXCJdID0gJ1Rvb01hbnlQYWdlcyddID0gXCJUb29NYW55UGFnZXNcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJSZXR1cm5Ub0RCUXVldWVcIl0gPSAnUmV0dXJuVG9EQlF1ZXVlJ10gPSBcIlJldHVyblRvREJRdWV1ZVwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIk5vQ2FsbFRpbWVcIl0gPSAnTm9DYWxsVGltZSddID0gXCJOb0NhbGxUaW1lXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiV3JvbmdOdW1iZXJcIl0gPSAnV3JvbmdOdW1iZXInXSA9IFwiV3JvbmdOdW1iZXJcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJQcm9oaWJpdGVkTnVtYmVyXCJdID0gJ1Byb2hpYml0ZWROdW1iZXInXSA9IFwiUHJvaGliaXRlZE51bWJlclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIkludGVybmFsRXJyb3JcIl0gPSAnSW50ZXJuYWxFcnJvciddID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiRmF4U2VuZGluZ1Byb2hpYml0ZWRcIl0gPSAnRmF4U2VuZGluZ1Byb2hpYml0ZWQnXSA9IFwiRmF4U2VuZGluZ1Byb2hpYml0ZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJUaGVQaG9uZUlzQmxhY2tsaXN0ZWRcIl0gPSAnVGhlUGhvbmVJc0JsYWNrbGlzdGVkJ10gPSBcIlRoZVBob25lSXNCbGFja2xpc3RlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlVzZXJOb3RGb3VuZFwiXSA9ICdVc2VyTm90Rm91bmQnXSA9IFwiVXNlck5vdEZvdW5kXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiQ29udmVydEVycm9yXCJdID0gJ0NvbnZlcnRFcnJvciddID0gXCJDb252ZXJ0RXJyb3JcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJEQkdlbmVyYWxFcnJvclwiXSA9ICdEQkdlbmVyYWxFcnJvciddID0gXCJEQkdlbmVyYWxFcnJvclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlNreXBlQmlsbGluZ0ZhaWxlZFwiXSA9ICdTa3lwZUJpbGxpbmdGYWlsZWQnXSA9IFwiU2t5cGVCaWxsaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiQWNjb3VudFN1c3BlbmRlZFwiXSA9ICdBY2NvdW50U3VzcGVuZGVkJ10gPSBcIkFjY291bnRTdXNwZW5kZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJQcm9oaWJpdGVkRGVzdGluYXRpb25cIl0gPSAnUHJvaGliaXRlZERlc3RpbmF0aW9uJ10gPSBcIlByb2hpYml0ZWREZXN0aW5hdGlvblwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG59KShleHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGUgfHwgKGV4cG9ydHMuTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZSA9IHt9KSk7XG52YXIgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZSA9IGV4cG9ydHMuTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZTtcblxuXG4vKioqLyB9LFxuLyogODEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbWVzc2FnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBNZXNzYWdlTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVzc2FnZUxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZUxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNZXNzYWdlTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZUxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VMaXN0ID0gTWVzc2FnZUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDgyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIG1lc3NhZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XG52YXIgbWVzc2FnZXNzeW5jaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oODMpO1xudmFyIE1lc3NhZ2VTeW5jID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVzc2FnZVN5bmMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVN5bmMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlU3luYy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IG1lc3NhZ2VpbmZvLk1lc3NhZ2VJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY0luZm8nLCBDbGFzczogbWVzc2FnZXNzeW5jaW5mby5NZXNzYWdlc1N5bmNJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNZXNzYWdlU3luYy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VTeW5jJztcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlU3luYztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTWVzc2FnZVN5bmMgPSBNZXNzYWdlU3luYztcblxuXG4vKioqLyB9LFxuLyogODMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgTWVzc2FnZXNTeW5jSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VzU3luY0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZXNTeW5jSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1lc3NhZ2VzU3luY0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY1R5cGUnLCBDbGFzczogTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jVG9rZW4nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZXNTeW5jSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VzU3luY0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VzU3luY0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VzU3luY0luZm8gPSBNZXNzYWdlc1N5bmNJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGUpIHtcbiAgICBNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGVbTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlW1wiRlN5bmNcIl0gPSAnRlN5bmMnXSA9IFwiRlN5bmNcIjtcbiAgICBNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGVbTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlW1wiSVN5bmNcIl0gPSAnSVN5bmMnXSA9IFwiSVN5bmNcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VzU3luY0luZm9TeW5jVHlwZSA9IHt9KSk7XG52YXIgTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlID0gZXhwb3J0cy5NZXNzYWdlc1N5bmNJbmZvU3luY1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDg0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBnZXRzdWJzY3JpcHRpb25pbmZvcmVzcG9uc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KTtcbnZhciBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjYgKFJlbGVhc2UgNS4xNSk8L3A+XG4gICAgICogPHA+Q3JlYXRlcyBhIG5ldyBzdWJzY3JpcHRpb24uIFRvIGNhbGwgdGhpcyBtZXRob2Qgd2l0aCBBUE5TIHRyYW5zcG9ydCB0eXBlIHlvdSBoYXZlIHRvIHNwZWNpZnkgZW5kcG9pbnRfaWQgYXR0cmlidXRlIGluIGdldCB0b2tlbiByZXF1ZXN0IGF0IGF1dGhvcml6YXRpb24uPC9wPlxuICAgICAqIDxoND5Vc2FnZSBQbGFuIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbicsIG9wdGlvbnMsIGV4cG9ydHMuY3JlYXRlT3B0aW9ucyksIGdldHN1YnNjcmlwdGlvbmluZm9yZXNwb25zZS5HZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjYgKFJlbGVhc2UgNS4xNSk8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgcmVxdWVzdGVkIHN1YnNjcmlwdGlvbi48L3A+XG4gICAgICogPGg0PlVzYWdlIFBsYW4gR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24ve3N1YnNjcmlwdGlvbklkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZE9wdGlvbnMpLCBnZXRzdWJzY3JpcHRpb25pbmZvcmVzcG9uc2UuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbmV3IFN1YnNjcmlwdGlvbiAvIE1vZGlmeSBFdmVudCBGaWx0ZXJzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNiAoUmVsZWFzZSA1LjE1KTwvcD5cbiAgICAgKiA8cD5XaXRoIGVtcHR5IHJlcXVlc3QgYm9keSAtIHJlbmV3cyB0aGUgZXhpc3RlbnQgc3Vic2NyaXB0aW9uLiBJZiBldmVudCBmaWx0ZXJzIHNwZWNpZmllZCAtIG1vZGlmaWVzIHRoZSBldmVudCBmaWx0ZXJzIGZvciB0aGUgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uLiBUaGUgY2xpZW50IGFwcGxpY2F0aW9uIGNhbiBleHRlbmQgb3IgbmFycm93IHRoZSBldmVudHMgZm9yIHdoaWNoIGl0IHJlY2VpdmVzIG5vdGlmaWNhdGlvbnMgaW4gdGhlIGZyYW1lXG4gICAgICogICAgIG9mIG9uZSBzdWJzY3JpcHRpb24uPC9wPlxuICAgICAqIDxoND5Vc2FnZSBQbGFuIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUFVUJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uL3tzdWJzY3JpcHRpb25JZH0nLCBvcHRpb25zLCBleHBvcnRzLnVwZGF0ZU9wdGlvbnMpLCBnZXRzdWJzY3JpcHRpb25pbmZvcmVzcG9uc2UuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbmNlbCBTdWJzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5DYW5jZWxzIHRoZSBleGlzdGVudCBzdWJzY3JpcHRpb24uPC9wPlxuICAgICAqIDxoND5Vc2FnZSBQbGFuIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uL3tzdWJzY3JpcHRpb25JZH0nLCBvcHRpb25zLCBleHBvcnRzLnJlbW92ZU9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkgPSBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGNyZWF0ZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5jcmVhdGVPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVzdWJzY3JpcHRpb25yZXF1ZXN0LkNyZWF0ZVN1YnNjcmlwdGlvblJlcXVlc3RcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3Vic2NyaXB0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgdXBkYXRlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdWJzY3JpcHRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibW9kaWZ5c3Vic2NyaXB0aW9ucmVxdWVzdC5Nb2RpZnlTdWJzY3JpcHRpb25SZXF1ZXN0XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgcmVtb3ZlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnJlbW92ZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdWJzY3JpcHRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcblxuXG4vKioqLyB9LFxuLyogODUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbm90aWZpY2F0aW9uZGVsaXZlcnltb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nik7XG52YXIgR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdldmVudEZpbHRlcnMnLCBDbGFzczogbnVsbCAvKiBzdHJpbmdbXSAqLywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHBpcmF0aW9uVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXhwaXJlc0luJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXMnLCBDbGFzczogR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjcmVhdGlvblRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RlbGl2ZXJ5TW9kZScsIENsYXNzOiBub3RpZmljYXRpb25kZWxpdmVyeW1vZGUuTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UnO1xuICAgIH07XG4gICAgcmV0dXJuIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZTtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlID0gR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlO1xuKGZ1bmN0aW9uIChHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXMpIHtcbiAgICBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXNbR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzW1wiQWN0aXZlXCJdID0gJ0FjdGl2ZSddID0gXCJBY3RpdmVcIjtcbiAgICBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXNbR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzW1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbn0pKGV4cG9ydHMuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzIHx8IChleHBvcnRzLkdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1cyA9IHt9KSk7XG52YXIgR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzID0gZXhwb3J0cy5HZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXM7XG5cblxuLyoqKi8gfSxcbi8qIDg2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGUucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHJhbnNwb3J0VHlwZScsIENsYXNzOiBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VuY3J5cHRpb24nLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FkZHJlc3MnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3Vic2NyaWJlcktleScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5jcnlwdGlvbkFsZ29yaXRobScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5jcnlwdGlvbktleScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVnaXN0cmF0aW9uSWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NlcnRpZmljYXRlTmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZS5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ05vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSc7XG4gICAgfTtcbiAgICByZXR1cm4gTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Ob3RpZmljYXRpb25EZWxpdmVyeU1vZGUgPSBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGU7XG4oZnVuY3Rpb24gKE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGUpIHtcbiAgICBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlW05vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbXCJQdWJOdWJcIl0gPSAnUHViTnViJ10gPSBcIlB1Yk51YlwiO1xuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtcIkFQTlNcIl0gPSAnQVBOUyddID0gXCJBUE5TXCI7XG4gICAgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlWydQdWJOdWIvQVBOUy9Wb0lQJ10gPSAnUHViTnViL0FQTlMvVm9JUCddID0gJ1B1Yk51Yi9BUE5TL1ZvSVAnO1xuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtcIldlYkhvb2tcIl0gPSAnV2ViSG9vayddID0gXCJXZWJIb29rXCI7XG59KShleHBvcnRzLk5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGUgfHwgKGV4cG9ydHMuTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZSA9IHt9KSk7XG52YXIgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZTtcblxuXG4vKioqLyB9LFxuLyogODcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIHByZXNlbmNlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xudmFyIG1vbml0b3JlZGV4dGVuc2lvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKTtcbnZhciBQcmVzZW5jZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByZXNlbmNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByZXNlbmNlKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbihzKSBQcmVzZW5jZSBTdGF0dXMgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgcHJlc2VuY2Ugc3RhdHVzIG9mIGFuIGV4dGVuc2lvbiBvciBzZXZlcmFsIGV4dGVuc2lvbnMgYnkgdGhlaXIgSUQocykuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLCBzZWUgQmF0Y2ggUmVxdWVzdHMgZm9yIGRldGFpbHMuVGhlIHByZXNlbmNlU3RhdHVzIGlzIHJldHVybmVkIGFzIE9mZmxpbmUgKHRoZSBwYXJhbWV0ZXJzIHRlbGVwaG9ueVN0YXR1cywgbWVzc2FnZSwgdXNlclN0YXR1cyBhbmQgZG5kU3RhdHVzIGFyZSBub3RcbiAgICAgKiAgICAgcmV0dXJuZWQgYXQgYWxsKSBmb3IgdGhlIGZvbGxvd2luZyBleHRlbnNpb24gdHlwZXM6IERlcGFydG1lbnQvQW5ub3VuY2VtZW50IE9ubHkvVGFrZSBNZXNzYWdlcyBPbmx5IChWb2ljZW1haWwpL0ZheCBVc2VyL1BhZ2luZyBPbmx5IEdyb3VwL1NoYXJlZCBMaW5lcyBHcm91cC9JVlIgTWVudS9BcHBsaWNhdGlvbiBFeHRlbnNpb24vUGFyayBMb2NhdGlvbi5JZiB0aGUgdXNlciByZXF1ZXN0cyBoaXMvaGVyIG93biBwcmVzZW5jZSBzdGF0dXMsXG4gICAgICogICAgIHRoZSByZXNwb25zZSBjb250YWlucyBhY3R1YWwgcHJlc2VuY2Ugc3RhdHVzIGV2ZW4gaWYgdGhlIHN0YXR1cyBwdWJsaWNhdGlvbiBpcyB0dXJuZWQgb2ZmLkJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLiBGb3IgYmF0Y2ggcmVxdWVzdHMgdGhlIG51bWJlciBvZiBleHRlbnNpb25zIGluIG9uZSByZXF1ZXN0IGlzIGxpbWl0ZWQgdG8gMzAuIElmIG1vcmUgZXh0ZW5zaW9ucyBhcmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QsIHRoZVxuICAgICAqICAgICBlcnJvciBjb2RlIDQwMCBCYWQgUmVxdWVzdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBsb2dpY2FsIGVycm9yIGNvZGUgSW52YWxpZE11bHRpcGFydFJlcXVlc3QgYW5kIHRoZSBjb3JyZXNwb25kaW5nIG1lc3NhZ2UgJ0V4dGVuc2lvbiBQcmVzZW5jZSBJbmZvIG11bHRpcGFydCByZXF1ZXN0IGlzIGxpbWl0ZWQgdG8gMzAgZXh0ZW5zaW9ucycuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkUHJlc2VuY2U8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5HZXR0aW5nIHVzZXIgcHJlc2VuY2UgaW5mb3JtYXRpb248L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIFByZXNlbmNlLnByb3RvdHlwZS5nZXRQcmVzZW5jZVN0YXR1cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJlc2VuY2UnLCBvcHRpb25zLCBleHBvcnRzLmdldFByZXNlbmNlU3RhdHVzT3B0aW9ucyksIHByZXNlbmNlaW5mby5QcmVzZW5jZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1vbml0b3JlZCBFeHRlbnNpb25zXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTMgKFJlbGVhc2UgNi41KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGxpc3Qgb2YgbGluZXMgLSBleHRlbnNpb25zIHdoaWNoIHByZXNlbmNlIHN0YXR1cyBjYW4gYmUgaW5kaWNhdGVkIGFuZCBtb25pdG9yZWQgb24gQkxGLWVuYWJsZWQgKEJ1c3kgTGFtcCBGaWVsZCkgZGV2aWNlcy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRQcmVzZW5jZTwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPkdldHRpbmcgdXNlciBwcmVzZW5jZSBpbmZvcm1hdGlvbjwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgUHJlc2VuY2UucHJvdG90eXBlLmxpc3RNb25pdG9yZWRFeHRlbnNpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9wcmVzZW5jZS9saW5lJywgb3B0aW9ucywgZXhwb3J0cy5saXN0TW9uaXRvcmVkRXh0ZW5zaW9uc09wdGlvbnMpLCBtb25pdG9yZWRleHRlbnNpb25zLk1vbml0b3JlZEV4dGVuc2lvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFByZXNlbmNlO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLlByZXNlbmNlID0gUHJlc2VuY2U7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgZ2V0UHJlc2VuY2VTdGF0dXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZ2V0UHJlc2VuY2VTdGF0dXNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RNb25pdG9yZWRFeHRlbnNpb25zIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RNb25pdG9yZWRFeHRlbnNpb25zT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcblxuXG4vKioqLyB9LFxuLyogODggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgcHJlc2VuY2VleHRlbnNpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OSk7XG52YXIgUHJlc2VuY2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJlc2VuY2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByZXNlbmNlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFByZXNlbmNlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FsbG93U2VlTXlQcmVzZW5jZScsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RuZFN0YXR1cycsIENsYXNzOiBQcmVzZW5jZUluZm9EbmRTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbicsIENsYXNzOiBwcmVzZW5jZWV4dGVuc2lvbmluZm8uUHJlc2VuY2VFeHRlbnNpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdtZXNzYWdlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaWNrVXBDYWxsc09uSG9sZCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ByZXNlbmNlU3RhdHVzJywgQ2xhc3M6IFByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyaW5nT25Nb25pdG9yZWRDYWxsJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndGVsZXBob255U3RhdHVzJywgQ2xhc3M6IFByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXNlclN0YXR1cycsIENsYXNzOiBQcmVzZW5jZUluZm9Vc2VyU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUHJlc2VuY2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUHJlc2VuY2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQcmVzZW5jZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlByZXNlbmNlSW5mbyA9IFByZXNlbmNlSW5mbztcbihmdW5jdGlvbiAoUHJlc2VuY2VJbmZvRG5kU3RhdHVzKSB7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIlRha2VBbGxDYWxsc1wiXSA9ICdUYWtlQWxsQ2FsbHMnXSA9IFwiVGFrZUFsbENhbGxzXCI7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIkRvTm90QWNjZXB0QW55Q2FsbHNcIl0gPSAnRG9Ob3RBY2NlcHRBbnlDYWxscyddID0gXCJEb05vdEFjY2VwdEFueUNhbGxzXCI7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIkRvTm90QWNjZXB0RGVwYXJ0bWVudENhbGxzXCJdID0gJ0RvTm90QWNjZXB0RGVwYXJ0bWVudENhbGxzJ10gPSBcIkRvTm90QWNjZXB0RGVwYXJ0bWVudENhbGxzXCI7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIlRha2VEZXBhcnRtZW50Q2FsbHNPbmx5XCJdID0gJ1Rha2VEZXBhcnRtZW50Q2FsbHNPbmx5J10gPSBcIlRha2VEZXBhcnRtZW50Q2FsbHNPbmx5XCI7XG59KShleHBvcnRzLlByZXNlbmNlSW5mb0RuZFN0YXR1cyB8fCAoZXhwb3J0cy5QcmVzZW5jZUluZm9EbmRTdGF0dXMgPSB7fSkpO1xudmFyIFByZXNlbmNlSW5mb0RuZFN0YXR1cyA9IGV4cG9ydHMuUHJlc2VuY2VJbmZvRG5kU3RhdHVzO1xuKGZ1bmN0aW9uIChQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cykge1xuICAgIFByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzW1ByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzW1wiT2ZmbGluZVwiXSA9ICdPZmZsaW5lJ10gPSBcIk9mZmxpbmVcIjtcbiAgICBQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1c1tQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1c1tcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXNbUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXNbXCJBdmFpbGFibGVcIl0gPSAnQXZhaWxhYmxlJ10gPSBcIkF2YWlsYWJsZVwiO1xufSkoZXhwb3J0cy5QcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cyB8fCAoZXhwb3J0cy5QcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cyA9IHt9KSk7XG52YXIgUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXMgPSBleHBvcnRzLlByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzO1xuKGZ1bmN0aW9uIChQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXMpIHtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiTm9DYWxsXCJdID0gJ05vQ2FsbCddID0gXCJOb0NhbGxcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiQ2FsbENvbm5lY3RlZFwiXSA9ICdDYWxsQ29ubmVjdGVkJ10gPSBcIkNhbGxDb25uZWN0ZWRcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiUmluZ2luZ1wiXSA9ICdSaW5naW5nJ10gPSBcIlJpbmdpbmdcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiT25Ib2xkXCJdID0gJ09uSG9sZCddID0gXCJPbkhvbGRcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiUGFya2VkQ2FsbFwiXSA9ICdQYXJrZWRDYWxsJ10gPSBcIlBhcmtlZENhbGxcIjtcbn0pKGV4cG9ydHMuUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzIHx8IChleHBvcnRzLlByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1cyA9IHt9KSk7XG52YXIgUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzID0gZXhwb3J0cy5QcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXM7XG4oZnVuY3Rpb24gKFByZXNlbmNlSW5mb1VzZXJTdGF0dXMpIHtcbiAgICBQcmVzZW5jZUluZm9Vc2VyU3RhdHVzW1ByZXNlbmNlSW5mb1VzZXJTdGF0dXNbXCJPZmZsaW5lXCJdID0gJ09mZmxpbmUnXSA9IFwiT2ZmbGluZVwiO1xuICAgIFByZXNlbmNlSW5mb1VzZXJTdGF0dXNbUHJlc2VuY2VJbmZvVXNlclN0YXR1c1tcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgUHJlc2VuY2VJbmZvVXNlclN0YXR1c1tQcmVzZW5jZUluZm9Vc2VyU3RhdHVzW1wiQXZhaWxhYmxlXCJdID0gJ0F2YWlsYWJsZSddID0gXCJBdmFpbGFibGVcIjtcbn0pKGV4cG9ydHMuUHJlc2VuY2VJbmZvVXNlclN0YXR1cyB8fCAoZXhwb3J0cy5QcmVzZW5jZUluZm9Vc2VyU3RhdHVzID0ge30pKTtcbnZhciBQcmVzZW5jZUluZm9Vc2VyU3RhdHVzID0gZXhwb3J0cy5QcmVzZW5jZUluZm9Vc2VyU3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA4OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQcmVzZW5jZUV4dGVuc2lvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmVzZW5jZUV4dGVuc2lvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJlc2VuY2VFeHRlbnNpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUHJlc2VuY2VFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFByZXNlbmNlRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1ByZXNlbmNlRXh0ZW5zaW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUHJlc2VuY2VFeHRlbnNpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5QcmVzZW5jZUV4dGVuc2lvbkluZm8gPSBQcmVzZW5jZUV4dGVuc2lvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDkwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGxpbmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgTW9uaXRvcmVkRXh0ZW5zaW9ucyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vbml0b3JlZEV4dGVuc2lvbnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9uaXRvcmVkRXh0ZW5zaW9ucygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1vbml0b3JlZEV4dGVuc2lvbnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGxpbmVpbmZvLkxpbmVJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNb25pdG9yZWRFeHRlbnNpb25zLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTW9uaXRvcmVkRXh0ZW5zaW9ucyc7XG4gICAgfTtcbiAgICByZXR1cm4gTW9uaXRvcmVkRXh0ZW5zaW9ucztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTW9uaXRvcmVkRXh0ZW5zaW9ucyA9IE1vbml0b3JlZEV4dGVuc2lvbnM7XG5cblxuLyoqKi8gfSxcbi8qIDkxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIG1vbml0b3JlZGxpbmVzZXh0ZW5zaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xudmFyIExpbmVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGluZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMaW5lSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb24nLCBDbGFzczogbW9uaXRvcmVkbGluZXNleHRlbnNpb25pbmZvLk1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIExpbmVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTGluZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIExpbmVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5MaW5lSW5mbyA9IExpbmVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA5MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbyA9IE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbztcbihmdW5jdGlvbiAoTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZSkge1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIlVzZXJcIl0gPSAnVXNlciddID0gXCJVc2VyXCI7XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW1wiRmF4VXNlclwiXSA9ICdGYXhVc2VyJ10gPSBcIkZheFVzZXJcIjtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbXCJWaXJ0dWFsVXNlclwiXSA9ICdWaXJ0dWFsVXNlciddID0gXCJWaXJ0dWFsVXNlclwiO1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIkRpZ2l0YWxVc2VyXCJdID0gJ0RpZ2l0YWxVc2VyJ10gPSBcIkRpZ2l0YWxVc2VyXCI7XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW1wiRGVwYXJ0bWVudFwiXSA9ICdEZXBhcnRtZW50J10gPSBcIkRlcGFydG1lbnRcIjtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiXSA9ICdBcHBsaWNhdGlvbkV4dGVuc2lvbiddID0gXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiO1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIlBhcmtMb2NhdGlvblwiXSA9ICdQYXJrTG9jYXRpb24nXSA9IFwiUGFya0xvY2F0aW9uXCI7XG59KShleHBvcnRzLk1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGUgfHwgKGV4cG9ydHMuTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZSA9IHt9KSk7XG52YXIgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZSA9IGV4cG9ydHMuTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogOTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIHJpbmdvdXRzdGF0dXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KTtcbnZhciBSaW5nT3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmluZ091dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSaW5nT3V0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSBSaW5nT3V0IENhbGxcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC43IChSZWxlYXNlIDUuMTYpPC9wPlxuICAgICAqIDxwPk1ha2VzIGEgMi1sZWcgUmluZ091dCBjYWxsLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmluZ091dDwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlBlcmZvcm1pbmcgdHdvLWxlZ2dlZCByaW5nLW91dCBwaG9uZSBjYWxsczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgUmluZ091dC5wcm90b3R5cGUubWFrZVJpbmdPdXRDYWxsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcmluZ291dCcsIG9wdGlvbnMsIGV4cG9ydHMubWFrZVJpbmdPdXRDYWxsT3B0aW9ucyksIHJpbmdvdXRzdGF0dXMuUmluZ091dFN0YXR1cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU3RhdHVzIG9mIFJpbmdPdXQgQ2FsbFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjcgKFJlbGVhc2UgNS4xNik8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgc3RhdHVzIG9mIGEgMi1sZWcgUmluZ091dCBjYWxsLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmluZ091dDwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlBlcmZvcm1pbmcgdHdvLWxlZ2dlZCByaW5nLW91dCBwaG9uZSBjYWxsczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgUmluZ091dC5wcm90b3R5cGUuZ2V0UmluZ091dENhbGxTdGF0dXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3JpbmdvdXQve3JpbmdvdXRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmdldFJpbmdPdXRDYWxsU3RhdHVzT3B0aW9ucyksIHJpbmdvdXRzdGF0dXMuUmluZ091dFN0YXR1cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYW5jZWwgUmluZ091dCBDYWxsXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+Q2FuY2VscyB0aGUgMi1sZWcgUmluZ091dCBjYWxsLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmluZ091dDwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlBlcmZvcm1pbmcgdHdvLWxlZ2dlZCByaW5nLW91dCBwaG9uZSBjYWxsczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgUmluZ091dC5wcm90b3R5cGUuY2FuY2VsUmluZ091dENhbGwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdERUxFVEUnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3JpbmdvdXQve3JpbmdvdXRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmNhbmNlbFJpbmdPdXRDYWxsT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIFJpbmdPdXQ7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuUmluZ091dCA9IFJpbmdPdXQ7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbWFrZVJpbmdPdXRDYWxsIG9wZXJhdGlvblxuICovXG5leHBvcnRzLm1ha2VSaW5nT3V0Q2FsbE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibWFrZXJpbmdvdXRyZXF1ZXN0Lk1ha2VSaW5nT3V0UmVxdWVzdFwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBnZXRSaW5nT3V0Q2FsbFN0YXR1cyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5nZXRSaW5nT3V0Q2FsbFN0YXR1c09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyaW5nb3V0SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgY2FuY2VsUmluZ091dENhbGwgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuY2FuY2VsUmluZ091dENhbGxPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicmluZ291dElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuXG5cbi8qKiovIH0sXG4vKiA5NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciByaW5nb3V0c3RhdHVzaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xudmFyIFJpbmdPdXRTdGF0dXMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSaW5nT3V0U3RhdHVzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJpbmdPdXRTdGF0dXMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSaW5nT3V0U3RhdHVzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXMnLCBDbGFzczogcmluZ291dHN0YXR1c2luZm8uUmluZ091dFN0YXR1c0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBSaW5nT3V0U3RhdHVzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUmluZ091dFN0YXR1cyc7XG4gICAgfTtcbiAgICByZXR1cm4gUmluZ091dFN0YXR1cztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUmluZ091dFN0YXR1cyA9IFJpbmdPdXRTdGF0dXM7XG5cblxuLyoqKi8gfSxcbi8qIDk1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFJpbmdPdXRTdGF0dXNJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmluZ091dFN0YXR1c0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmluZ091dFN0YXR1c0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSaW5nT3V0U3RhdHVzSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsU3RhdHVzJywgQ2xhc3M6IFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbGVyU3RhdHVzJywgQ2xhc3M6IFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsZWVTdGF0dXMnLCBDbGFzczogUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBSaW5nT3V0U3RhdHVzSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1JpbmdPdXRTdGF0dXNJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBSaW5nT3V0U3RhdHVzSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUmluZ091dFN0YXR1c0luZm8gPSBSaW5nT3V0U3RhdHVzSW5mbztcbihmdW5jdGlvbiAoUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzKSB7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkludmFsaWRcIl0gPSAnSW52YWxpZCddID0gXCJJbnZhbGlkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIlN1Y2Nlc3NcIl0gPSAnU3VjY2VzcyddID0gXCJTdWNjZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkluUHJvZ3Jlc3NcIl0gPSAnSW5Qcm9ncmVzcyddID0gXCJJblByb2dyZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIk5vQW5zd2VyXCJdID0gJ05vQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkdlbmVyaWNFcnJvclwiXSA9ICdHZW5lcmljRXJyb3InXSA9IFwiR2VuZXJpY0Vycm9yXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkZpbmlzaGVkXCJdID0gJ0ZpbmlzaGVkJ10gPSBcIkZpbmlzaGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkRlc3RpbmF0aW9uQmxvY2tlZFwiXSA9ICdEZXN0aW5hdGlvbkJsb2NrZWQnXSA9IFwiRGVzdGluYXRpb25CbG9ja2VkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIk5vdEVub3VnaEZ1bmRzXCJdID0gJ05vdEVub3VnaEZ1bmRzJ10gPSBcIk5vdEVub3VnaEZ1bmRzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIk5vU3VjaFVzZXJcIl0gPSAnTm9TdWNoVXNlciddID0gXCJOb1N1Y2hVc2VyXCI7XG59KShleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cyB8fCAoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXMgPSB7fSkpO1xudmFyIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cyA9IGV4cG9ydHMuUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzO1xuKGZ1bmN0aW9uIChSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cykge1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiSW52YWxpZFwiXSA9ICdJbnZhbGlkJ10gPSBcIkludmFsaWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIlN1Y2Nlc3NcIl0gPSAnU3VjY2VzcyddID0gXCJTdWNjZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJJblByb2dyZXNzXCJdID0gJ0luUHJvZ3Jlc3MnXSA9IFwiSW5Qcm9ncmVzc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIk5vQW5zd2VyXCJdID0gJ05vQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiR2VuZXJpY0Vycm9yXCJdID0gJ0dlbmVyaWNFcnJvciddID0gXCJHZW5lcmljRXJyb3JcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIkZpbmlzaGVkXCJdID0gJ0ZpbmlzaGVkJ10gPSBcIkZpbmlzaGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiRGVzdGluYXRpb25CbG9ja2VkXCJdID0gJ0Rlc3RpbmF0aW9uQmxvY2tlZCddID0gXCJEZXN0aW5hdGlvbkJsb2NrZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIk5vdEVub3VnaEZ1bmRzXCJdID0gJ05vdEVub3VnaEZ1bmRzJ10gPSBcIk5vdEVub3VnaEZ1bmRzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJOb1N1Y2hVc2VyXCJdID0gJ05vU3VjaFVzZXInXSA9IFwiTm9TdWNoVXNlclwiO1xufSkoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cyB8fCAoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cyA9IHt9KSk7XG52YXIgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXMgPSBleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzO1xuKGZ1bmN0aW9uIChSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cykge1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiSW52YWxpZFwiXSA9ICdJbnZhbGlkJ10gPSBcIkludmFsaWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIlN1Y2Nlc3NcIl0gPSAnU3VjY2VzcyddID0gXCJTdWNjZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJJblByb2dyZXNzXCJdID0gJ0luUHJvZ3Jlc3MnXSA9IFwiSW5Qcm9ncmVzc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIk5vQW5zd2VyXCJdID0gJ05vQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiR2VuZXJpY0Vycm9yXCJdID0gJ0dlbmVyaWNFcnJvciddID0gXCJHZW5lcmljRXJyb3JcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIkZpbmlzaGVkXCJdID0gJ0ZpbmlzaGVkJ10gPSBcIkZpbmlzaGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiRGVzdGluYXRpb25CbG9ja2VkXCJdID0gJ0Rlc3RpbmF0aW9uQmxvY2tlZCddID0gXCJEZXN0aW5hdGlvbkJsb2NrZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIk5vdEVub3VnaEZ1bmRzXCJdID0gJ05vdEVub3VnaEZ1bmRzJ10gPSBcIk5vdEVub3VnaEZ1bmRzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJOb1N1Y2hVc2VyXCJdID0gJ05vU3VjaFVzZXInXSA9IFwiTm9TdWNoVXNlclwiO1xufSkoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cyB8fCAoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cyA9IHt9KSk7XG52YXIgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXMgPSBleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA5NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgZXh0ZW5zaW9uZm9yd2FyZGluZ251bWJlcmxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcbnZhciBmb3J3YXJkaW5nbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOTgpO1xudmFyIEZvcndhcmRpbmdOdW1iZXJzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9yd2FyZGluZ051bWJlcnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9yd2FyZGluZ051bWJlcnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIEZvcndhcmRpbmcgTnVtYmVyIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC43IChSZWxlYXNlIDUuMTYpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgZXh0ZW5zaW9uIHBob25lIG51bWJlcnMgdXNlZCBmb3IgY2FsbCBmb3J3YXJkaW5nIGFuZCBjYWxsIGZsaXAuIFRoZSByZXR1cm5lZCBsaXN0IGNvbnRhaW5zIGFsbCB0aGUgZXh0ZW5zaW9uIHBob25lIG51bWJlcnMgdGhhdCBhcmUgdXNlZCBmb3IgY2FsbCBmb3J3YXJkaW5nIGFuZCBjYWxsIGZsaXAuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRm9yd2FyZGluZ051bWJlcnMucHJvdG90eXBlLmxpc3RFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVycyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vZm9yd2FyZGluZy1udW1iZXInLCBvcHRpb25zLCBleHBvcnRzLmxpc3RFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyc09wdGlvbnMpLCBleHRlbnNpb25mb3J3YXJkaW5nbnVtYmVybGlzdC5FeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgRm9yd2FyZGluZyBOdW1iZXJcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMiAoUmVsZWFzZSA2LjQpPC9wPlxuICAgICAqIDxwPkFkZHMgYSBuZXcgZm9yd2FyZGluZyBudW1iZXIgdG8gdGhlIGZvcndhcmRpbmcgbnVtYmVyIGxpc3QuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIsIGFzc2lnbmVkIHBob25lIG51bWJlcnMsIGRldmljZXMgYW5kIG90aGVyIGV4dGVuc2lvbiBzZXR0aW5ncyk8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBGb3J3YXJkaW5nTnVtYmVycy5wcm90b3R5cGUuY3JlYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2ZvcndhcmRpbmctbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5jcmVhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyksIGZvcndhcmRpbmdudW1iZXJpbmZvLkZvcndhcmRpbmdOdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBGb3J3YXJkaW5nIE51bWJlciBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI0IChSZWxlYXNlIDguMCk8L3A+XG4gICAgICogPHA+VXBkYXRlcyBhbiBleGlzdGVudCBmb3J3YXJkaW5nIG51bWJlciBmcm9tIHRoZSBmb3J3YXJkaW5nIG51bWJlciBsaXN0LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyLCBhc3NpZ25lZCBwaG9uZSBudW1iZXJzLCBkZXZpY2VzIGFuZCBvdGhlciBleHRlbnNpb24gc2V0dGluZ3MpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgRm9yd2FyZGluZ051bWJlcnMucHJvdG90eXBlLnVwZGF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2ZvcndhcmRpbmctbnVtYmVyL3tmb3J3YXJkaW5nTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy51cGRhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyksIGZvcndhcmRpbmdudW1iZXJpbmZvLkZvcndhcmRpbmdOdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBGb3J3YXJkaW5nIE51bWJlciBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI0IChSZWxlYXNlIDguMCk8L3A+XG4gICAgICogPHA+RGVsZXRlcyBhIGZvcndhcmRpbmcgbnVtYmVyIGZyb20gdGhlIGZvcndhcmRpbmcgbnVtYmVyIGxpc3QgYnkgaXRzIElELjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyLCBhc3NpZ25lZCBwaG9uZSBudW1iZXJzLCBkZXZpY2VzIGFuZCBvdGhlciBleHRlbnNpb24gc2V0dGluZ3MpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgRm9yd2FyZGluZ051bWJlcnMucHJvdG90eXBlLmRlbGV0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdERUxFVEUnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2ZvcndhcmRpbmctbnVtYmVyL3tmb3J3YXJkaW5nTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy5kZWxldGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcndhcmRpbmdOdW1iZXJzO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLkZvcndhcmRpbmdOdW1iZXJzID0gRm9yd2FyZGluZ051bWJlcnM7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgY3JlYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5jcmVhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVmb3J3YXJkaW5nbnVtYmVycmVxdWVzdC5DcmVhdGVGb3J3YXJkaW5nTnVtYmVyUmVxdWVzdFwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZm9yd2FyZGluZ051bWJlcklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcInVwZGF0ZWZvcndhcmRpbmdudW1iZXJyZXF1ZXN0LlVwZGF0ZUZvcndhcmRpbmdOdW1iZXJSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGRlbGV0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZGVsZXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJmb3J3YXJkaW5nTnVtYmVySWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG5cblxuLyoqKi8gfSxcbi8qIDk3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGZvcndhcmRpbmdudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZm9yd2FyZGluZ251bWJlcmluZm8uRm9yd2FyZGluZ051bWJlckluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCA9IEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA5OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBGb3J3YXJkaW5nTnVtYmVySW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZvcndhcmRpbmdOdW1iZXJJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcndhcmRpbmdOdW1iZXJJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRm9yd2FyZGluZ051bWJlckluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGhvbmVOdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhYmVsJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmZWF0dXJlcycsIENsYXNzOiBGb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmbGlwTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRm9yd2FyZGluZ051bWJlckluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdGb3J3YXJkaW5nTnVtYmVySW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRm9yd2FyZGluZ051bWJlckluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkZvcndhcmRpbmdOdW1iZXJJbmZvID0gRm9yd2FyZGluZ051bWJlckluZm87XG4oZnVuY3Rpb24gKEZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXMpIHtcbiAgICBGb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzW0ZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXNbXCJDYWxsRmxpcFwiXSA9ICdDYWxsRmxpcCddID0gXCJDYWxsRmxpcFwiO1xuICAgIEZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXNbRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlc1tcIkNhbGxGb3J3YXJkaW5nXCJdID0gJ0NhbGxGb3J3YXJkaW5nJ10gPSBcIkNhbGxGb3J3YXJkaW5nXCI7XG59KShleHBvcnRzLkZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXMgfHwgKGV4cG9ydHMuRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcyA9IHt9KSk7XG52YXIgRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcyA9IGV4cG9ydHMuRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcztcblxuXG4vKioqLyB9LFxuLyogOTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGJsb2NrZWRudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDApO1xudmFyIGJsb2NrZWRudW1iZXJzbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKTtcbnZhciBCbG9ja2VkTnVtYmVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrZWROdW1iZXJzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrZWROdW1iZXJzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIEJsb2NrZWQgTnVtYmVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIG15IGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEJsb2NrZWROdW1iZXJzLnByb3RvdHlwZS5ibG9ja051bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5ibG9ja051bWJlck9wdGlvbnMpLCBibG9ja2VkbnVtYmVyaW5mby5CbG9ja2VkTnVtYmVySW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQmxvY2tlZCBOdW1iZXIgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBwaG9uZSBudW1iZXJzIHdoaWNoIGFyZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdG8gYmxvY2sgaW5ib3VuZCBjYWxscyBhbmQgU01TIG1lc3NhZ2VzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEJsb2NrZWROdW1iZXJzLnByb3RvdHlwZS5saXN0QmxvY2tlZE51bWJlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5saXN0QmxvY2tlZE51bWJlcnNPcHRpb25zKSwgYmxvY2tlZG51bWJlcnNsaXN0LkJsb2NrZWROdW1iZXJzTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQmxvY2tlZCBOdW1iZXIocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBCbG9ja2VkTnVtYmVycy5wcm90b3R5cGUubG9hZEJsb2NrZWROdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyL3tibG9ja2VkTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQmxvY2tlZE51bWJlck9wdGlvbnMpLCBibG9ja2VkbnVtYmVyaW5mby5CbG9ja2VkTnVtYmVySW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgQmxvY2tlZCBOdW1iZXIocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgbXkgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgQmxvY2tlZE51bWJlcnMucHJvdG90eXBlLnVwZGF0ZUJsb2NrZWROdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyL3tibG9ja2VkTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy51cGRhdGVCbG9ja2VkTnVtYmVyT3B0aW9ucyksIGJsb2NrZWRudW1iZXJpbmZvLkJsb2NrZWROdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBCbG9ja2VkIE51bWJlcihzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyBteSBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBCbG9ja2VkTnVtYmVycy5wcm90b3R5cGUudW5ibG9ja051bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0RFTEVURScsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vYmxvY2tlZC1udW1iZXIve2Jsb2NrZWROdW1iZXJJZH0nLCBvcHRpb25zLCBleHBvcnRzLnVuYmxvY2tOdW1iZXJPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tlZE51bWJlcnM7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuQmxvY2tlZE51bWJlcnMgPSBCbG9ja2VkTnVtYmVycztcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBibG9ja051bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5ibG9ja051bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEJsb2NrZWROdW1iZXJzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RCbG9ja2VkTnVtYmVyc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEJsb2NrZWROdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEJsb2NrZWROdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYmxvY2tlZE51bWJlcklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHVwZGF0ZUJsb2NrZWROdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlQmxvY2tlZE51bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJibG9ja2VkTnVtYmVySWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgdW5ibG9ja051bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy51bmJsb2NrTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJsb2NrZWROdW1iZXJJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcblxuXG4vKioqLyB9LFxuLyogMTAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEJsb2NrZWROdW1iZXJJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tlZE51bWJlckluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tlZE51bWJlckluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCbG9ja2VkTnVtYmVySW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaG9uZU51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJsb2NrZWROdW1iZXJJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQmxvY2tlZE51bWJlckluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrZWROdW1iZXJJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5CbG9ja2VkTnVtYmVySW5mbyA9IEJsb2NrZWROdW1iZXJJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAxMDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgYmxvY2tlZG51bWJlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgQmxvY2tlZE51bWJlcnNMaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tlZE51bWJlcnNMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrZWROdW1iZXJzTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJsb2NrZWROdW1iZXJzTGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGJsb2NrZWRudW1iZXJpbmZvLkJsb2NrZWROdW1iZXJJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBCbG9ja2VkTnVtYmVyc0xpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdCbG9ja2VkTnVtYmVyc0xpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrZWROdW1iZXJzTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQmxvY2tlZE51bWJlcnNMaXN0ID0gQmxvY2tlZE51bWJlcnNMaXN0O1xuXG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpbmdjZW50cmFsLWNsaWVudC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yaW5nY2VudHJhbC1jbGllbnQvYnVpbGQvcmluZ2NlbnRyYWwtY2xpZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4vc3ltYm9sLW1hcCc7XG5pbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi9yZWR1eC1oZWxwZXInO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudC1lbWl0dGVyJztcblxuY29uc3Qgc3ltYm9scyA9IG5ldyBTeW1ib2xNYXAoW1xuICAnc3RvcmUnLFxuICAnbWFwcGVyJyxcbiAgJ3ByZWZpeCcsXG4gICdhY3Rpb25zJyxcbiAgJ2VtaXR0ZXInLFxuXSk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBkZXNjcmlwdGlvbiBEZWZhdWx0IHJlZHVjZXIgaWYgbW9kdWxlIGRvZXMgbm90IGhhcyBpdHMgb3duIHJlZHVjZXIuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRSZWR1Y2VyKHN0YXRlKSB7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4ge307XG4gIHJldHVybiBzdGF0ZTtcbn1cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBkZXNjcmlwdGlvbiBEZWZhdWx0IHBhcmVudCBzdGF0ZSB0byBtb2R1bGUgc3RhdGUgbWFwcGVyLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0TWFwcGVyKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBkZWZhdWx0XG4gKiBAZGVzY3JpcHRpb24gQmFzZSBtb2R1bGUgY2xhc3MuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJjTW9kdWxlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyLFxuICAgIHN0YXRlTWFwcGVyID0gZGVmYXVsdE1hcHBlcixcbiAgICBwcmVmaXgsXG4gICAgYWN0aW9ucyxcbiAgfSkge1xuICAgIC8vIEV4dGVuZGluZyBFdmVudEVtaXR0ZXIgYnJlYWtzIHNvbWUgbWVjaGFuaWMsIHNvIHdlIHdpcmUgZW1pdHRlciB1cCBsaWtlIHRoaXMgaW5zdGVhZC5cbiAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpc1tzeW1ib2xzLm1hcHBlcl0gPSBzdGF0ZU1hcHBlcjtcbiAgICB0aGlzW3N5bWJvbHMucHJlZml4XSA9IHByZWZpeDtcbiAgICB0aGlzW3N5bWJvbHMuYWN0aW9uc10gPSBhY3Rpb25zICYmIHByZWZpeEFjdGlvbnMoYWN0aW9ucywgcHJlZml4KTtcbiAgICByZWdpc3RlclN0b3JlSGFuZGxlcigoc3RvcmUpID0+IHtcbiAgICAgIHRoaXNbc3ltYm9scy5zdG9yZV0gPSBzdG9yZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiB7RnVuY3Rpb259IFVucmVnaXN0ZXIgZnVuY3Rpb24uXG4gICAqL1xuICBvbihldmVudCwgaGFuZGxlcikge1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5vbihldmVudCwgaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5vZmYoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbil9IGhhbmRsZXJcbiAgICogQHJldHVybiB7RnVuY3Rpb259IFVucmVnaXN0ZXIgZnVuY3Rpb24uXG4gICAqL1xuICBvbmNlKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGhpc1tzeW1ib2xzLmVtaXR0ZXJdLm9uY2UoZXZlbnQsIGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0ub2ZmKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7Li4uYXJnc30gYXJnc1xuICAgKi9cbiAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0ub2ZmKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLm1hcHBlcl0odGhpc1tzeW1ib2xzLnN0b3JlXS5nZXRTdGF0ZSgpKTtcbiAgfVxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlZHVjZXI7XG4gIH1cbiAgZ2V0IHN0b3JlKCkge1xuICAgIHJldHVybiB0aGlzW3N5bWJvbHMuc3RvcmVdO1xuICB9XG4gIGdldCBwcmVmaXgoKSB7XG4gICAgcmV0dXJuIHRoaXNbc3ltYm9scy5wcmVmaXhdO1xuICB9XG4gIGdldCBhY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzW3N5bWJvbHMuYWN0aW9uc107XG4gIH1cblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL3JjLW1vZHVsZS5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4vZW51bSc7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZGVzY3JpcHRpb24gSGVscGVyIGNsYXNzIGZvciBjcmVhdGluZyBhIHN5bWJvbCBtYXBwaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5bWJvbE1hcCBleHRlbmRzIEVudW0ge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGtleXMpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0ge307XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBkZWZpbml0aW9uW2tleV0gPSBTeW1ib2woKTtcbiAgICB9KTtcbiAgICBzdXBlcihkZWZpbml0aW9uKTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL3N5bWJvbC1tYXAuanNcbiAqKi8iLCJjb25zdCBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuY29uc3QgREVGSU5JVElPTiA9IFN5bWJvbCgpO1xuY29uc3QgVkFMVUVTID0gU3ltYm9sKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudW0ge1xuICBjb25zdHJ1Y3RvcihkZWZpbml0aW9uKSB7XG4gICAgdGhpc1tERUZJTklUSU9OXSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmluaXRpb24pO1xuICAgIHRoaXNbVkFMVUVTXSA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmluaXRpb24pIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24sIGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0RFRklOSVRJT05dW2tleV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpc1tWQUxVRVNdLmFkZCh0aGlzW0RFRklOSVRJT05dW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgaGFzVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpc1tWQUxVRVNdLmhhcyh2YWx1ZSk7XG4gIH1cbn1cblxuLypcbiAqIC8vd2l0aCBQcm94eSBzdXBwb3J0XG4gKmNvbnN0IGVudW1IYW5kbGVyID0ge1xuICogIGdldCh0YXJnZXQsIGtleSkge1xuICogICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICogIH0sXG4gKiAgc2V0KCkge1xuICogICAgcmV0dXJuO1xuICogIH1cbiAqfTtcbiAqRW51bSA9IGNsYXNzIEVudW0gZXh0ZW5kcyBQcm94eSB7XG4gKiAgY29uc3RydWN0b3IoZGVmaW5pdGlvbikge1xuICogICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgZGVmaW5pdGlvbiksIGVudW1IYW5kbGVyKTtcbiAqICB9XG4gKn1cbiAqL1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvZW51bS5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4vZW51bSc7XG5cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogQGNsYXNzXG4gKiBAZGVzY3JpcHRpb24gaGVscGVyIGNsYXNzIGZvciBjcmVhdGluZyByZWR1eCBhY3Rpb24gZGVmaW5pdGlvbiBtYXBzXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3Rpb25NYXAgZXh0ZW5kcyBFbnVtIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBhY3Rpb25zIC0gbGlzdCBvZiBhY3Rpb24gc3RyaW5nc1xuICAgKiBAZXh0ZW5kcyBFbnVtXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhY3Rpb25zID0gW10sIHByZWZpeCA9ICcnKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHt9O1xuICAgIGFjdGlvbnMuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgZGVmaW5pdGlvblthY3Rpb25dID0gcHJlZml4ICE9PSAnJyA/IGAke3ByZWZpeH0tJHthY3Rpb259YCA6IGFjdGlvbjtcbiAgICB9KTtcbiAgICBzdXBlcihkZWZpbml0aW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIGhlbHBlciBmdW5jdGlvbiB0byByZXR1cm4gYSBwcmVmaXhlZCBhY3Rpb24gZGVmaW5pdGlvbiBtYXBzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVmaXhBY3Rpb25zKGFjdGlvbnMsIHByZWZpeCkge1xuICBpZiAoIXByZWZpeCB8fCBwcmVmaXggPT09ICcnKSByZXR1cm4gYWN0aW9ucztcbiAgY29uc3QgZGVmaW5pdGlvbiA9IHt9O1xuICBmb3IgKGNvbnN0IGFjdGlvbiBpbiBhY3Rpb25zKSB7XG4gICAgaWYgKGFjdGlvbnM6Omhhc093blByb3BlcnR5KGFjdGlvbikpIHtcbiAgICAgIGRlZmluaXRpb25bYWN0aW9uXSA9IGAke3ByZWZpeH0tJHthY3Rpb259YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBFbnVtKGRlZmluaXRpb24pO1xufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvcmVkdXgtaGVscGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBjYWxsYWJsZSA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcblxuICAsIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGRlc2NyaXB0b3IgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH1cblxuICAsIG9uLCBvbmNlLCBvZmYsIGVtaXQsIG1ldGhvZHMsIGRlc2NyaXB0b3JzLCBiYXNlO1xuXG5vbiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkge1xuXHRcdGRhdGEgPSBkZXNjcmlwdG9yLnZhbHVlID0gY3JlYXRlKG51bGwpO1xuXHRcdGRlZmluZVByb3BlcnR5KHRoaXMsICdfX2VlX18nLCBkZXNjcmlwdG9yKTtcblx0XHRkZXNjcmlwdG9yLnZhbHVlID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRkYXRhID0gdGhpcy5fX2VlX187XG5cdH1cblx0aWYgKCFkYXRhW3R5cGVdKSBkYXRhW3R5cGVdID0gbGlzdGVuZXI7XG5cdGVsc2UgaWYgKHR5cGVvZiBkYXRhW3R5cGVdID09PSAnb2JqZWN0JykgZGF0YVt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0ZWxzZSBkYXRhW3R5cGVdID0gW2RhdGFbdHlwZV0sIGxpc3RlbmVyXTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9uY2UgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIG9uY2UsIHNlbGY7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXHRzZWxmID0gdGhpcztcblx0b24uY2FsbCh0aGlzLCB0eXBlLCBvbmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdG9mZi5jYWxsKHNlbGYsIHR5cGUsIG9uY2UpO1xuXHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0pO1xuXG5cdG9uY2UuX19lZU9uY2VMaXN0ZW5lcl9fID0gbGlzdGVuZXI7XG5cdHJldHVybiB0aGlzO1xufTtcblxub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBkYXRhLCBsaXN0ZW5lcnMsIGNhbmRpZGF0ZSwgaTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuIHRoaXM7XG5cdGRhdGEgPSB0aGlzLl9fZWVfXztcblx0aWYgKCFkYXRhW3R5cGVdKSByZXR1cm4gdGhpcztcblx0bGlzdGVuZXJzID0gZGF0YVt0eXBlXTtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRmb3IgKGkgPSAwOyAoY2FuZGlkYXRlID0gbGlzdGVuZXJzW2ldKTsgKytpKSB7XG5cdFx0XHRpZiAoKGNhbmRpZGF0ZSA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdFx0KGNhbmRpZGF0ZS5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMikgZGF0YVt0eXBlXSA9IGxpc3RlbmVyc1tpID8gMCA6IDFdO1xuXHRcdFx0XHRlbHNlIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmICgobGlzdGVuZXJzID09PSBsaXN0ZW5lcikgfHxcblx0XHRcdFx0KGxpc3RlbmVycy5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0ZGVsZXRlIGRhdGFbdHlwZV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0dmFyIGksIGwsIGxpc3RlbmVyLCBsaXN0ZW5lcnMsIGFyZ3M7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuO1xuXHRsaXN0ZW5lcnMgPSB0aGlzLl9fZWVfX1t0eXBlXTtcblx0aWYgKCFsaXN0ZW5lcnMpIHJldHVybjtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuXHRcdGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuXHRcdGZvciAoaSA9IDA7IChsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0YXBwbHkuY2FsbChsaXN0ZW5lciwgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGNhc2UgMTpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJndW1lbnRzWzFdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdH1cblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH1cbn07XG5cbm1ldGhvZHMgPSB7XG5cdG9uOiBvbixcblx0b25jZTogb25jZSxcblx0b2ZmOiBvZmYsXG5cdGVtaXQ6IGVtaXRcbn07XG5cbmRlc2NyaXB0b3JzID0ge1xuXHRvbjogZChvbiksXG5cdG9uY2U6IGQob25jZSksXG5cdG9mZjogZChvZmYpLFxuXHRlbWl0OiBkKGVtaXQpXG59O1xuXG5iYXNlID0gZGVmaW5lUHJvcGVydGllcyh7fSwgZGVzY3JpcHRvcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiAobykge1xuXHRyZXR1cm4gKG8gPT0gbnVsbCkgPyBjcmVhdGUoYmFzZSkgOiBkZWZpbmVQcm9wZXJ0aWVzKE9iamVjdChvKSwgZGVzY3JpcHRvcnMpO1xufTtcbmV4cG9ydHMubWV0aG9kcyA9IG1ldGhvZHM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9ldmVudC1lbWl0dGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvYXNzaWduJylcbiAgLCBub3JtYWxpemVPcHRzID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMnKVxuICAsIGlzQ2FsbGFibGUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZScpXG4gICwgY29udGFpbnMgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMnKVxuXG4gICwgZDtcblxuZCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRzY3IsIHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgdywgb3B0aW9ucywgZGVzYztcblx0aWYgKChhcmd1bWVudHMubGVuZ3RoIDwgMikgfHwgKHR5cGVvZiBkc2NyICE9PSAnc3RyaW5nJykpIHtcblx0XHRvcHRpb25zID0gdmFsdWU7XG5cdFx0dmFsdWUgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB3ID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHRcdHcgPSBjb250YWlucy5jYWxsKGRzY3IsICd3Jyk7XG5cdH1cblxuXHRkZXNjID0geyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSwgd3JpdGFibGU6IHcgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cbmQuZ3MgPSBmdW5jdGlvbiAoZHNjciwgZ2V0LCBzZXQvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCBvcHRpb25zLCBkZXNjO1xuXHRpZiAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSBnZXQ7XG5cdFx0Z2V0ID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzNdO1xuXHR9XG5cdGlmIChnZXQgPT0gbnVsbCkge1xuXHRcdGdldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShnZXQpKSB7XG5cdFx0b3B0aW9ucyA9IGdldDtcblx0XHRnZXQgPSBzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoc2V0ID09IG51bGwpIHtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUoc2V0KSkge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9XG5cdGlmIChkc2NyID09IG51bGwpIHtcblx0XHRjID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHR9XG5cblx0ZGVzYyA9IHsgZ2V0OiBnZXQsIHNldDogc2V0LCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9kL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBPYmplY3QuYXNzaWduXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduLCBvYmo7XG5cdGlmICh0eXBlb2YgYXNzaWduICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdG9iaiA9IHsgZm9vOiAncmF6JyB9O1xuXHRhc3NpZ24ob2JqLCB7IGJhcjogJ2R3YScgfSwgeyB0cnp5OiAndHJ6eScgfSk7XG5cdHJldHVybiAob2JqLmZvbyArIG9iai5iYXIgKyBvYmoudHJ6eSkgPT09ICdyYXpkd2F0cnp5Jztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vaXMtaW1wbGVtZW50ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgID0gcmVxdWlyZSgnLi4va2V5cycpXG4gICwgdmFsdWUgPSByZXF1aXJlKCcuLi92YWxpZC12YWx1ZScpXG5cbiAgLCBtYXggPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVzdCwgc3JjLyosIOKApnNyY24qLykge1xuXHR2YXIgZXJyb3IsIGksIGwgPSBtYXgoYXJndW1lbnRzLmxlbmd0aCwgMiksIGFzc2lnbjtcblx0ZGVzdCA9IE9iamVjdCh2YWx1ZShkZXN0KSk7XG5cdGFzc2lnbiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR0cnkgeyBkZXN0W2tleV0gPSBzcmNba2V5XTsgfSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlO1xuXHRcdH1cblx0fTtcblx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRrZXlzKHNyYykuZm9yRWFjaChhc3NpZ24pO1xuXHR9XG5cdGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnJvcjtcblx0cmV0dXJuIGRlc3Q7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanNcbiAqKiBtb2R1bGUgaWQgPSAxNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IE9iamVjdC5rZXlzXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdE9iamVjdC5rZXlzKCdwcmltaXRpdmUnKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL2lzLWltcGxlbWVudGVkLmpzXG4gKiogbW9kdWxlIGlkID0gMTQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuXHRyZXR1cm4ga2V5cyhvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IE9iamVjdChvYmplY3QpKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL3NoaW0uanNcbiAqKiBtb2R1bGUgaWQgPSAxNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoc3JjLCBvYmopIHtcblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gc3JjKSBvYmpba2V5XSA9IHNyY1trZXldO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucy8qLCDigKZvcHRpb25zKi8pIHtcblx0dmFyIHJlc3VsdCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucyA9PSBudWxsKSByZXR1cm47XG5cdFx0cHJvY2VzcyhPYmplY3Qob3B0aW9ucyksIHJlc3VsdCk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBEZXByZWNhdGVkXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvaXMtY2FsbGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IFN0cmluZy5wcm90b3R5cGUuY29udGFpbnNcblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0ciA9ICdyYXpkd2F0cnp5JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc3RyLmNvbnRhaW5zICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoKHN0ci5jb250YWlucygnZHdhJykgPT09IHRydWUpICYmIChzdHIuY29udGFpbnMoJ2ZvbycpID09PSBmYWxzZSkpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaXMtaW1wbGVtZW50ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluZGV4T2YgPSBTdHJpbmcucHJvdG90eXBlLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZy8qLCBwb3NpdGlvbiovKSB7XG5cdHJldHVybiBpbmRleE9mLmNhbGwodGhpcywgc2VhcmNoU3RyaW5nLCBhcmd1bWVudHNbMV0pID4gLTE7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9zaGltLmpzXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcblx0cmV0dXJuIGZuO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgeyBBY3Rpb25NYXAsIHByZWZpeEFjdGlvbnMgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gJ3JlZHV4JztcblxuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ3JlZHVjZXInLFxuXSk7XG5cbmZ1bmN0aW9uIGdldFNldHRpbmdzUmVkdWNlcihwcmVmaXgpIHtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB7fTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3MgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICAgIHRoaXNbc3ltYm9scy5yZWR1Y2VyXSA9IHtcbiAgICAgIGJhc2U6IGdldFNldHRpbmdzUmVkdWNlcih0aGlzLnByZWZpeCksXG4gICAgfTtcbiAgfVxuICByZWdpc3RlclJlZHVjZXIobmFtZSwgcmVkdWNlcikge1xuICAgIHRoaXNbc3ltYm9scy5yZWR1Y2VyXVtuYW1lXSA9IHJlZHVjZXI7XG4gIH1cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVSZWR1Y2Vycyh0aGlzW3N5bWJvbHMucmVkdWNlcl0pO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3NldHRpbmdzL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb21wb3NlID0gZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBleHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IGV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gZXhwb3J0cy5jcmVhdGVTdG9yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9jcmVhdGVTdG9yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVTdG9yZSk7XG5cbnZhciBfY29tYmluZVJlZHVjZXJzID0gcmVxdWlyZSgnLi9jb21iaW5lUmVkdWNlcnMnKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tYmluZVJlZHVjZXJzKTtcblxudmFyIF9iaW5kQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2JpbmRBY3Rpb25DcmVhdG9ycycpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaW5kQWN0aW9uQ3JlYXRvcnMpO1xuXG52YXIgX2FwcGx5TWlkZGxld2FyZSA9IHJlcXVpcmUoJy4vYXBwbHlNaWRkbGV3YXJlJyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FwcGx5TWlkZGxld2FyZSk7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKlxuKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXG4qIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cbiovXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgaXNDcnVzaGVkLm5hbWUgPT09ICdzdHJpbmcnICYmIGlzQ3J1c2hlZC5uYW1lICE9PSAnaXNDcnVzaGVkJykge1xuICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXFwncHJvZHVjdGlvblxcJy4gJyArICdUaGlzIG1lYW5zIHRoYXQgeW91IGFyZSBydW5uaW5nIGEgc2xvd2VyIGRldmVsb3BtZW50IGJ1aWxkIG9mIFJlZHV4LiAnICsgJ1lvdSBjYW4gdXNlIGxvb3NlLWVudmlmeSAoaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvbG9vc2UtZW52aWZ5KSBmb3IgYnJvd3NlcmlmeSAnICsgJ29yIERlZmluZVBsdWdpbiBmb3Igd2VicGFjayAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDAzMDAzMSkgJyArICd0byBlbnN1cmUgeW91IGhhdmUgdGhlIGNvcnJlY3QgY29kZSBmb3IgeW91ciBwcm9kdWN0aW9uIGJ1aWxkLicpO1xufVxuXG5leHBvcnRzLmNyZWF0ZVN0b3JlID0gX2NyZWF0ZVN0b3JlMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmNvbWJpbmVSZWR1Y2VycyA9IF9jb21iaW5lUmVkdWNlcnMyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gX2JpbmRBY3Rpb25DcmVhdG9yczJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBfYXBwbHlNaWRkbGV3YXJlMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmNvbXBvc2UgPSBfY29tcG9zZTJbXCJkZWZhdWx0XCJdO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHVuZGVmaW5lZDtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY3JlYXRlU3RvcmU7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlID0gcmVxdWlyZSgnc3ltYm9sLW9ic2VydmFibGUnKTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbE9ic2VydmFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciBBY3Rpb25UeXBlcyA9IGV4cG9ydHMuQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6ICdAQHJlZHV4L0lOSVQnXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBbaW5pdGlhbFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmhhbmNlciBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IGluaXRpYWxTdGF0ZTtcbiAgICBpbml0aWFsU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gJyArICdVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiAnICsgJ0hhdmUgeW91IG1pc3NwZWxsZWQgYSBjb25zdGFudD8nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbX3N5bWJvbE9ic2VydmFibGUyW1wiZGVmYXVsdFwiXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9XG5cbiAgLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG4gIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcjogcmVwbGFjZVJlZHVjZXJcbiAgfSwgX3JlZjJbX3N5bWJvbE9ic2VydmFibGUyW1wiZGVmYXVsdFwiXV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc0hvc3RPYmplY3QgPSByZXF1aXJlKCcuL19pc0hvc3RPYmplY3QnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHxcbiAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpICE9IG9iamVjdFRhZyB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuLyoqXG4gKiBHZXRzIHRoZSBgW1tQcm90b3R5cGVdXWAgb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIGBbW1Byb3RvdHlwZV1dYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvdG90eXBlKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVHZXRQcm90b3R5cGUoT2JqZWN0KHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL19nZXRQcm90b3R5cGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNIb3N0T2JqZWN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL19pc0hvc3RPYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC9pc09iamVjdExpa2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BvbnlmaWxsJykoZ2xvYmFsIHx8IHdpbmRvdyB8fCB0aGlzKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N5bWJvbC1vYnNlcnZhYmxlL3BvbnlmaWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbWJpbmVSZWR1Y2VycztcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pIHtcbiAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uVHlwZSAmJiAnXCInICsgYWN0aW9uVHlwZS50b1N0cmluZygpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcblxuICByZXR1cm4gJ0dpdmVuIGFjdGlvbiAnICsgYWN0aW9uTmFtZSArICcsIHJlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZC4gJyArICdUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuJztcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgPyAnaW5pdGlhbFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gJ1RoZSAnICsgYXJndW1lbnROYW1lICsgJyBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFwiJyArIHt9LnRvU3RyaW5nLmNhbGwoaW5wdXRTdGF0ZSkubWF0Y2goL1xccyhbYS16fEEtWl0rKS8pWzFdICsgJ1wiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nICcgKyAoJ2tleXM6IFwiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiJyk7XG4gIH1cblxuICB2YXIgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgfSk7XG5cbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgJyArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgJyAnICsgKCdcIicgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgYXJndW1lbnROYW1lICsgJy4gJykgKyAnRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiAnICsgKCdcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2FuaXR5KHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSAnQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl8nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUICsgJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpICsgJ25hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlICcgKyAnY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgJyArICdpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgJyArICdhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICB2YXIgc2FuaXR5RXJyb3I7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNhbml0eShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNhbml0eUVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHNhbml0eUVycm9yKSB7XG4gICAgICB0aHJvdyBzYW5pdHlFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShzdGF0ZSwgZmluYWxSZWR1Y2VycywgYWN0aW9uKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGZpbmFsUmVkdWNlcktleXNbaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNba2V5XTtcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVba2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVba2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvY29tYmluZVJlZHVjZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMTYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHdhcm5pbmc7XG4vKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMTYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGJpbmRBY3Rpb25DcmVhdG9ycztcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBhcHBseU1pZGRsZXdhcmU7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpO1xuICAgICAgdmFyIF9kaXNwYXRjaCA9IHN0b3JlLmRpc3BhdGNoO1xuICAgICAgdmFyIGNoYWluID0gW107XG5cbiAgICAgIHZhciBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gX2Rpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKTtcbiAgICAgIH0pO1xuICAgICAgX2Rpc3BhdGNoID0gX2NvbXBvc2UyW1wiZGVmYXVsdFwiXS5hcHBseSh1bmRlZmluZWQsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzXG4gKiogbW9kdWxlIGlkID0gMTY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29tcG9zZTtcbi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvclxuICogdGhlIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3MgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQuIEZvciBleGFtcGxlLCBjb21wb3NlKGYsIGcsIGgpIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSkuXG4gKi9cblxuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmVzdCA9IGZ1bmNzLnNsaWNlKDAsIC0xKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHY6IGZ1bmN0aW9uIHYoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3QucmVkdWNlUmlnaHQoZnVuY3Rpb24gKGNvbXBvc2VkLCBmKSB7XG4gICAgICAgICAgICByZXR1cm4gZihjb21wb3NlZCk7XG4gICAgICAgICAgfSwgbGFzdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGlmICh0eXBlb2YgX3JldCA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzXG4gKiogbW9kdWxlIGlkID0gMTY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgYnJhbmRBY3Rpb25zIGZyb20gJy4vYnJhbmQtYWN0aW9ucyc7XG5pbXBvcnQgZ2V0UmVkdWNlciBmcm9tICcuL2JyYW5kLXJlZHVjZXInO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ2luaXRpYWxTdGF0ZScsXG5dKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJhbmQgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZWdpc3RlclN0b3JlSGFuZGxlcixcbiAgICBzdGF0ZU1hcHBlciA9IChzdGF0ZSkgPT4gc3RhdGUuYnJhbmQsXG4gICAgcHJlZml4LFxuICAgIGlkLFxuICAgIG5hbWUsXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcixcbiAgICAgIHN0YXRlTWFwcGVyLFxuICAgICAgcHJlZml4LFxuICAgICAgYWN0aW9uczogYnJhbmRBY3Rpb25zLFxuICAgIH0pO1xuICAgIHRoaXNbc3ltYm9scy5pbml0aWFsU3RhdGVdID0ge1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgIH07XG4gIH1cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIGdldFJlZHVjZXIodGhpc1tzeW1ib2xzLmluaXRpYWxTdGF0ZV0sIHRoaXMucHJlZml4KTtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaWQ7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubmFtZTtcbiAgfVxufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2JyYW5kL2luZGV4LmpzXG4gKiovIiwiaW1wb3J0IHsgQWN0aW9uTWFwIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBBY3Rpb25NYXAoW1xuICAnc2V0QnJhbmQnLFxuXSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2JyYW5kL2JyYW5kLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgYnJhbmRBY3Rpb25zIGZyb20gJy4vYnJhbmQtYWN0aW9ucyc7XG5pbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UmVkdWNlcihpbml0aWFsU3RhdGUsIHByZWZpeCkge1xuICBjb25zdCBhY3Rpb25zID0gcHJlZml4QWN0aW9ucyhicmFuZEFjdGlvbnMsIHByZWZpeCk7XG4gIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcblxuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgY2FzZSBhY3Rpb25zLnNldEJyYW5kOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBuYW1lOiBhY3Rpb24ucGF5bG9hZC5uYW1lLFxuICAgICAgICAgIGlkOiBhY3Rpb24ucGF5bG9hZC5pZCxcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9icmFuZC9icmFuZC1yZWR1Y2VyLmpzXG4gKiovIiwiaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4uLy4uL2xpYi9yYy1tb2R1bGUnO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5pbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgbG9naW5TdGF0dXMgZnJvbSAnLi9sb2dpbi1zdGF0dXMnO1xuaW1wb3J0IGF1dGhBY3Rpb25zIGZyb20gJy4vYXV0aC1hY3Rpb25zJztcbmltcG9ydCBnZXRBdXRoUmVkdWNlciBmcm9tICcuL2F1dGgtcmVkdWNlcic7XG5pbXBvcnQgeyBhdXRoRXZlbnRzLCBhdXRoRXZlbnRUeXBlcyB9IGZyb20gJy4vYXV0aC1ldmVudHMnO1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5cblxuY29uc3Qgc3ltYm9scyA9IG5ldyBTeW1ib2xNYXAoW1xuICAncGxhdGZvcm0nLFxuICAnZW1pdHRlcicsXG4gICdiZWZvcmVMb2dvdXRIYW5kbGVycycsXG5dKTtcblxuY29uc3QgRU5VTVMgPSBuZXcgRW51bSh7XG4gIGxvZ2luU3RhdHVzLFxufSk7XG5cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBkZXNjcmlwdGlvbiBBdXRoZW50aWNhdGlvbiBtb2R1bGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0aCBleHRlbmRzIFJjTW9kdWxlIHtcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhY3Rpb25zOiBhdXRoQWN0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBwbGF0Zm9ybSxcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzW3N5bWJvbHMuYmVmb3JlTG9nb3V0SGFuZGxlcnNdID0gbmV3IFNldCgpO1xuXG4gICAgLy8gbG9hZCBpbmZvIG9uIGxvZ2luXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luU3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dpblN1Y2Nlc3MsXG4gICAgICB9KTtcbiAgICAgIHRoaXM6OmVtaXQoYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXRlLnN0YXR1cyk7XG4gICAgfSk7XG4gICAgLy8gbG9naW5FcnJvclxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dpbkVycm9yLCBlcnJvciA9PiB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmxvZ2luRXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gdW5sb2FkIGluZm8gb24gbG9nb3V0XG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ291dFN1Y2Nlc3MsICgpID0+IHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMubG9nb3V0U3VjY2VzcyxcbiAgICAgIH0pO1xuICAgICAgLy8gdGhpcy5lbWl0KGF1dGhFdmVudHMudXNlckluZm9DbGVhcmVkKTtcbiAgICB9KTtcblxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dvdXRFcnJvciwgZXJyb3IgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dvdXRFcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5yZWZyZXNoRXJyb3IsIGVycm9yID0+IHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMucmVmcmVzaEVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gbG9hZCBpbmZvIGlmIGFscmVhZHkgbG9nZ2VkIGluXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlZEluID0gYXdhaXQgcGxhdGZvcm0ubG9nZ2VkSW4oKTtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuaW5pdCxcbiAgICAgICAgc3RhdHVzOiBsb2dnZWRJbiA/IGxvZ2luU3RhdHVzLmxvZ2dlZEluIDogbG9naW5TdGF0dXMubm90TG9nZ2VkSW4sXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChhdXRoRXZlbnRUeXBlcy5hdXRoRXZlbnRUeXBlcywgdGhpcy5zdGF0ZS5zdGF0dXMpO1xuICAgIH0pKCk7XG4gIH1cblxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZ2V0QXV0aFJlZHVjZXIodGhpcy5wcmVmaXgpO1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBkZXNjcmlwdGlvbiBMb2dpbiBmdW5jdGlvbiB1c2luZyB1c2VybmFtZSBhbmQgcGFzc3dvcmRcbiAgICovXG4gIGFzeW5jIGxvZ2luKHsgdXNlcm5hbWUsIHBhc3N3b3JkLCBleHRlbnNpb24sIHJlbWVtYmVyIH0pIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dpbixcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgdXNlcm5hbWUsXG4gICAgICAgIHBhc3N3b3JkLFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgIHJlbWVtYmVyLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzOjplbWl0KGF1dGhFdmVudFR5cGVzLmxvZ2luU3RhdHVzQ2hhbmdlZCwgYXV0aEV2ZW50cy5sb2dnaW5nSW4pO1xuICAgIHJldHVybiBhd2FpdCB0aGlzW3N5bWJvbHMucGxhdGZvcm1dLmxvZ2luKHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQsXG4gICAgICBleHRlbnNpb24sXG4gICAgICByZW1lbWJlcixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBkZXNjcmlwdGlvbiBBdXRob3JpemUgdXNpbmcgT0FhdXRoIGNvZGVcbiAgICovXG4gIGFzeW5jIGF1dGhvcml6ZSh7IGNvZGUsIHJlZGlyZWN0VXJpIH0pIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dpbixcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgY29kZSxcbiAgICAgICAgcmVkaXJlY3RVcmksXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCBhdXRoRXZlbnRzLmxvZ2dpbmdJbik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0ubG9naW4oe1xuICAgICAgY29kZSxcbiAgICAgIHJlZGlyZWN0VXJpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQGRlc2NyaXB0aW9uIExvZyB0aGUgdXNlciBvdXRcbiAgICovXG4gIGFzeW5jIGxvZ291dCgpIHtcbiAgICAvLyBkZWFsIHdpdGggcmVtb3Zpbmcgc3Vic2NyaXB0aW9uc1xuXG4gICAgdGhpczo6ZW1pdChhdXRoRXZlbnRUeXBlcy5sb2dpblN0YXR1c0NoYW5nZWQsIGF1dGhFdmVudHMubG9nZ2luZ091dCk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBbLi4udGhpc1tzeW1ib2xzLmJlZm9yZUxvZ291dEhhbmRsZXJzXV07XG4gICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB3cmFwcyB3aXRoIGFzeW5jIHNvIGV2ZW4gbm9ybWFsIGZ1bmN0aW9ucyBjYW4gYmUgYXdhaXRlZFxuICAgICAgICAvLyBUT0RPIGNhbmNlbCBsb2dvdXQgaWYgaGFuZGxlciByZXNvbHZlcyB0byBmYWxzZVxuICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4gaGFuZGxlcigpKSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgZW1pdCBlcnJvclxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpc1tzeW1ib2xzLnBsYXRmb3JtXS5sb2dvdXQoKTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKi9cbiAgYWRkQmVmb3JlTG9nb3V0SGFuZGxlcihoYW5kbGVyKSB7XG4gICAgdGhpc1tzeW1ib2xzLmJlZm9yZUxvZ291dEhhbmRsZXJzXS5hZGQoaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXNbc3ltYm9scy5iZWZvcmVMb2dvdXRIYW5kbGVyc10ucmVtb3ZlKGhhbmRsZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZW1vdmVCZWZvcmVMb2dvdXRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICB0aGlzW3N5bWJvbHMuYmVmb3JlTG9nb3V0SGFuZGxlcnNdLnJlbW92ZShoYW5kbGVyKTtcbiAgfVxuXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhdHVzO1xuICB9XG5cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gYXV0aEV2ZW50cztcbiAgfVxuXG4gIGdldCBldmVudFR5cGVzKCkge1xuICAgIHJldHVybiBhdXRoRXZlbnRUeXBlcztcbiAgfVxuXG4gIGdldCBlbnVtcygpIHtcbiAgICByZXR1cm4gRU5VTVM7XG4gIH1cblxuICBhc3luYyBpc0xvZ2dlZEluKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzW3N5bWJvbHMucGxhdGZvcm1dLmxvZ2dlZEluKCk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYXV0aC9pbmRleC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXHJcbiAgLCBjcmVhdGVEZXNjICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgaW5kZXgsIHZhbHVlKXtcclxuICBpZihpbmRleCBpbiBvYmplY3QpJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xyXG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUoKG91dGVyRm4gfHwgR2VuZXJhdG9yKS5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLmFyZykudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8XG4gICAgICAgICAgICAgIChtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBhcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9wcm9taXNlXCIpO1xuXG52YXIgX3Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvbWlzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gc3RlcChrZXksIGFyZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIpO1xuICAgIH0pO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlByb21pc2U7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2xhc3NvZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc2V0UHJvdG8gICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0XG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAxODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgcGVuZGluZzogJ1BFTkRJTkcnLCAvLyBhZnRlciBpbml0LCBiZWZvcmUgc3RhdHVzIGZyb20gcGxhdGZvcm0gaXMgZGV0ZXJtaW5lZFxuICBub3RMb2dnZWRJbjogJ05PVF9MT0dHRURfSU4nLFxuICBsb2dnaW5nSW46ICdMT0dHSU5HX0lOJyxcbiAgbG9nZ2VkSW46ICdMT0dHRURfSU4nLFxuICBsb2dnaW5nT3V0OiAnTE9HR0lOR19PVVQnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEVudW0oZGVmaW5pdGlvbik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2F1dGgvbG9naW4tc3RhdHVzLmpzXG4gKiovIiwiaW1wb3J0IHsgQWN0aW9uTWFwIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBBY3Rpb25NYXAoW1xuICAnbG9naW4nLFxuICAnbG9naW5TdWNjZXNzJyxcbiAgJ2xvZ2luRXJyb3InLFxuICAnbG9nb3V0JyxcbiAgJ2xvZ291dFN1Y2Nlc3MnLFxuICAnbG9nb3V0RXJyb3InLFxuICAncmVmcmVzaCcsXG4gICdyZWZyZXNoU3VjY2VzcycsXG4gICdyZWZyZXNoRXJyb3InLFxuICAnaW5pdCcsXG5dLCAnYXV0aCcpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtYWN0aW9ucy5qc1xuICoqLyIsImltcG9ydCB7IHByZWZpeEFjdGlvbnMgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcbmltcG9ydCBhdXRoQWN0aW9ucyBmcm9tICcuL2F1dGgtYWN0aW9ucyc7XG5pbXBvcnQgbG9naW5TdGF0dXMgZnJvbSAnLi9sb2dpbi1zdGF0dXMnO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIHN0YXR1czogbG9naW5TdGF0dXMucGVuZGluZyxcbiAgYXV0aEVycm9yOiBudWxsLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QXV0aFJlZHVjZXIocHJlZml4KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBwcmVmaXhBY3Rpb25zKGF1dGhBY3Rpb25zLCBwcmVmaXgpO1xuICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgaWYgKCFhY3Rpb24pIHJldHVybiBzdGF0ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICAgIGNhc2UgYWN0aW9ucy5pbml0OlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHsgc3RhdHVzOiBhY3Rpb24uc3RhdHVzIH0pO1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9naW46XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBsb2dpblN0YXR1cy5sb2dnaW5nSW4sXG4gICAgICAgICAgYXV0aEVycm9yOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9naW5TdWNjZXNzOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogbG9naW5TdGF0dXMubG9nZ2VkSW4sXG4gICAgICAgICAgYXV0aEVycm9yOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9nb3V0U3VjY2VzczpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IGxvZ2luU3RhdHVzLm5vdExvZ2dlZEluLFxuICAgICAgICAgIGF1dGhFcnJvcjogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBhY3Rpb25zLmxvZ2luRXJyb3I6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6IGxvZ2luU3RhdHVzLm5vdExvZ2dlZEluLFxuICAgICAgICAgIGF1dGhFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9nb3V0RXJyb3I6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBsb2dpblN0YXR1cy5sb2dnZWRJbixcbiAgICAgICAgICBhdXRoRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYXV0aC9hdXRoLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgbG9naW5TdGF0dXMgZnJvbSAnLi9sb2dpbi1zdGF0dXMnO1xuXG5jb25zdCBldmVudERlZmluaXRpb25zID0ge1xuICAuLi5sb2dpblN0YXR1cyxcbn07XG5cbmV4cG9ydCBjb25zdCBhdXRoRXZlbnRzID0gbmV3IEVudW0oZXZlbnREZWZpbml0aW9ucyk7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb25zID0ge1xuICBsb2dpblN0YXR1c0NoYW5nZWQ6ICdMT0dJTl9TVEFUVVNfQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3QgYXV0aEV2ZW50VHlwZXMgPSBuZXcgRW51bShldmVudFR5cGVEZWZpbml0aW9ucyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2F1dGgvYXV0aC1ldmVudHMuanNcbiAqKi8iLCJleHBvcnQgZnVuY3Rpb24gZXh0cmFjdERhdGEobW9kZWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWwpKSB7XG4gICAgcmV0dXJuIG1vZGVsLm1hcChpdGVtID0+IGV4dHJhY3REYXRhKGl0ZW0pKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZWwgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1vZGVsKSB7XG4gICAgICBpZiAoa2V5WzBdICE9PSAnXycgJiYgbW9kZWwuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkYXRhW2tleV0gPSBleHRyYWN0RGF0YShtb2RlbFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIG1vZGVsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hMaXN0KGZuKSB7XG4gIGxldCBmZXRjaGVkUGFnZXMgPSAwO1xuICBsZXQgdG90YWxQYWdlcyA9IDE7XG4gIGxldCBsaXN0ID0gW107XG4gIHdoaWxlIChmZXRjaGVkUGFnZXMgPCB0b3RhbFBhZ2VzKSB7XG4gICAgZmV0Y2hlZFBhZ2VzKys7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZuKHtcbiAgICAgIHBhZ2U6IGZldGNoZWRQYWdlcyxcbiAgICB9KTtcbiAgICB0b3RhbFBhZ2VzID0gZGF0YS5wYWdpbmcudG90YWxQYWdlcztcbiAgICBsaXN0ID0gbGlzdC5jb25jYXQoZGF0YS5yZWNvcmRzKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQGRlc2NyaXB0aW9uIEhlbHBlciBmdW5jdGlvbiB0byBlbWl0IGV2ZW50VHlwZWQgZXZlbnRzIGFuZCB0aGUgZXZlbnQgaXRzZWxmXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbWl0KGV2ZW50VHlwZSwgZXZlbnQsIC4uLnBheWxvYWRzKSB7XG4gIHRoaXMuZW1pdChldmVudCwgLi4ucGF5bG9hZHMpO1xuICB0aGlzLmVtaXQoZXZlbnRUeXBlLCBldmVudCwgLi4ucGF5bG9hZHMpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKHQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdCk7XG4gIH0pO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL3V0aWxzLmpzXG4gKiovIiwiaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4uLy4uL2xpYi9yYy1tb2R1bGUnO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5pbXBvcnQgc3Vic2NyaXB0aW9uQWN0aW9ucyBmcm9tICcuL3N1YnNjcmlwdGlvbi1hY3Rpb25zJztcbmltcG9ydCBnZXRTdWJzY3JpcHRpb25SZWR1Y2VyIGZyb20gJy4vc3Vic2NyaXB0aW9uLXJlZHVjZXInO1xuaW1wb3J0IHsgc3Vic2NyaXB0aW9uRXZlbnRzLCBzdWJzY3JpcHRpb25FdmVudFR5cGVzIH0gZnJvbSAnLi9zdWJzY3JpcHRpb24tZXZlbnRzJztcbmltcG9ydCBzdWJzY3JpcHRpb25TdGF0dXMgZnJvbSAnLi9zdWJzY3JpcHRpb24tc3RhdHVzJztcbmltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcbmltcG9ydCB7IGVtaXQgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdhdXRoJyxcbiAgJ3NkaycsXG4gICdwbGF0Zm9ybScsXG4gICdzdWJzY3JpcHRpb24nLFxuICAnZmlsdGVyQ2FjaGUnLFxuXSk7XG5cblxuY29uc3QgZmlsdGVyUmVnZXggPSB7XG4gIG1lc3NhZ2U6IC9tZXNzYWdlLXN0b3JlJC8sXG4gIHByZXNlbmNlOiAvcHJlc2VuY2UoXFw/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlKT8kLyxcbiAgdGVsZXBob255OiAvcHJlc2VuY2VcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUkLyxcbiAgbGluZTogL3ByZXNlbmNlXFwvbGluZSQvLFxuICBsaW5lUHJlc2VuY2U6IC9wcmVzZW5jZVxcL2xpbmVcXC9wcmVzZW5jZShcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUpPyQvLFxuICBsaW5lVGVsZXBob255OiAvcHJlc2VuY2VcXC9saW5lXFwvcHJlc2VuY2VcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUkLyxcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgbWVzc2FnZXMgZGVsaXZlcmVkIGJ5IHRoZSBzdWJzY3JpcHRvblxuICovXG5mdW5jdGlvbiBtZXNzYWdlSGFuZGxlcihtZXNzYWdlKSB7XG4gIC8vIGRldGVybWluZSB3aGljaCBldmVudHMgdGhlIG1lc3NhZ2UgZmFsbHMgdW5kZXJcbiAgY29uc3QgZXZlbnRzID0gW107XG4gIGlmIChmaWx0ZXJSZWdleC5tZXNzYWdlLnRlc3QobWVzc2FnZS5ldmVudCkpIHtcbiAgICBldmVudHMucHVzaCgnbWVzc2FnZScpO1xuICB9IGVsc2UgaWYgKGZpbHRlclJlZ2V4LmxpbmUudGVzdChtZXNzYWdlLmV2ZW50KSkge1xuICAgIGV2ZW50cy5wdXNoKCdsaW5lJyk7XG4gIH0gZWxzZSBpZiAoZmlsdGVyUmVnZXgubGluZVByZXNlbmNlLnRlc3QobWVzc2FnZS5ldmVudCkpIHtcbiAgICBldmVudHMucHVzaCgnbGluZVByZXNlbmNlJyk7XG4gICAgaWYgKGZpbHRlclJlZ2V4LmxpbmVUZWxlcGhvbnkudGVzdChtZXNzYWdlLmV2ZW50KSkgZXZlbnRzLnB1c2goJ2xpbmVUZWxlcGhvbnknKTtcbiAgfSBlbHNlIGlmIChmaWx0ZXJSZWdleC5wcmVzZW5jZS50ZXN0KG1lc3NhZ2UuZXZlbnQpKSB7XG4gICAgZXZlbnRzLnB1c2goJ3ByZXNlbmNlJyk7XG4gICAgaWYgKGZpbHRlclJlZ2V4LnRlbGVwaG9ueS50ZXN0KG1lc3NhZ2UuZXZlbnQpKSBldmVudHMucHVzaCgndGVsZXBob255Jyk7XG4gIH1cbiAgLy8gZGlzcGF0Y2ggdGhlIG1lc3NhZ2UgaW4gcmVkdXggbWFubmVyXG4gIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5ub3RpZmljYXRpb24sXG4gICAgZXZlbnRUeXBlczogZXZlbnRzLFxuICAgIHBheWxvYWQ6IG1lc3NhZ2UsXG4gIH0pO1xuICAvLyBlbWl0IHRoZSBtZXNzYWdlcyBhcyBldmVudHNcbiAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5ub3RpZmljYXRpb24sIHN1YnNjcmlwdGlvbkV2ZW50c1tldmVudF0sIG1lc3NhZ2UpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGNvbnN0IHBsYXRmb3JtID0gdGhpc1tzeW1ib2xzLnBsYXRmb3JtXTtcbiAgdGhpc1tzeW1ib2xzLnN1YnNjcmlwdGlvbl0gPSB0aGlzW3N5bWJvbHMuc2RrXS5jcmVhdGVTdWJzY3JpcHRpb24oKTtcbiAgY29uc3Qgb3duZXJJZCA9IHBsYXRmb3JtLmF1dGgoKS5kYXRhKCkub3duZXJfaWQ7XG4gIGxldCBjYWNoZUtleSA9IG51bGw7XG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNhY2hlS2V5ID0gYCR7dGhpcy5wcmVmaXh9LXN1Yi0ke293bmVySWR9YDtcbiAgICBjb25zdCBjYWNoZWRTdWJzY3JpcHRpb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZFN1YnNjcmlwdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5iYXNlLnNldFN1YnNjcmlwdGlvbihKU09OLnBhcnNlKGNhY2hlZFN1YnNjcmlwdGlvbikpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBkbyBub3RoaW5nICovXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICB0aGlzLmJhc2Uuc2V0RXZlbnRGaWx0ZXJzKHRoaXMuZmlsdGVycyk7XG5cbiAgdGhpcy5iYXNlLm9uKHRoaXMuYmFzZS5ldmVudHMubm90aWZpY2F0aW9uLCBtZXNzYWdlID0+IHtcbiAgICB0aGlzOjptZXNzYWdlSGFuZGxlcihtZXNzYWdlKTtcbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnJlbW92ZVN1Y2Nlc3MsICgpID0+IHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5ub3RTdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiBudWxsLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gIH0pO1xuICB0aGlzLmJhc2Uub24odGhpcy5iYXNlLmV2ZW50cy5yZW1vdmVFcnJvciwgKCkgPT4ge1xuICAgIC8vIFRPRE9cbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnJlbmV3U3VjY2VzcywgKCkgPT4ge1xuICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oY2FjaGVLZXksIEpTT04uc3RyaW5naWZ5KHRoaXMuYmFzZS5zdWJzY3JpcHRpb24oKSkpO1xuICAgIH1cbiAgICBjb25zdCBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5zdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiB0aGlzLmJhc2Uuc3Vic2NyaXB0aW9uKCksXG4gICAgfSk7XG4gICAgaWYgKG9sZFN0YXR1cyAhPT0gdGhpcy5zdGF0dXMpIHtcbiAgICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gICAgfVxuICB9KTtcbiAgdGhpcy5iYXNlLm9uKHRoaXMuYmFzZS5ldmVudHMucmVuZXdFcnJvciwgZXJyb3IgPT4ge1xuICAgIC8vIFRPRE8gaGFuZGxlIDQyOVxuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZVN0YXR1cyxcbiAgICAgIHN0YXR1czogc3Vic2NyaXB0aW9uU3RhdHVzLm5vdFN1YnNjcmliZWQsXG4gICAgICBzdWJzY3JpcHRpb246IG51bGwsXG4gICAgfSk7XG4gICAgdGhpczo6ZW1pdChzdWJzY3JpcHRpb25FdmVudFR5cGVzLnN0YXR1c0NoYW5nZWQsIHRoaXMuc3RhdHVzKTtcbiAgICB0aGlzLmJhc2UucmVzZXQoKS5zZXRFdmVudEZpbHRlcnModGhpcy5maWx0ZXJzKS5yZWdpc3RlcigpLmNhdGNoKGUgPT4geyB9KTtcbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnN1YnNjcmliZVN1Y2Nlc3MsICgpID0+IHtcbiAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGNhY2hlS2V5LCBKU09OLnN0cmluZ2lmeSh0aGlzLmJhc2Uuc3Vic2NyaXB0aW9uKCkpKTtcbiAgICB9XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudXBkYXRlU3RhdHVzLFxuICAgICAgc3RhdHVzOiBzdWJzY3JpcHRpb25TdGF0dXMuc3Vic2NyaWJlZCxcbiAgICAgIHN1YnNjcmlwdGlvbjogdGhpcy5iYXNlLnN1YnNjcmlwdGlvbigpLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gIH0pO1xuICB0aGlzLmJhc2Uub24odGhpcy5iYXNlLmV2ZW50cy5zdWJzY3JpYmVFcnJvciwgZXJyb3IgPT4ge1xuICAgIC8vIFRPRE9cbiAgICAvLyBoYW5kbGUgNDI5XG4gICAgLy8gaGFuZGxlIHN1YnNjcmlwdGlvbiBsaW1pdFxuICB9KTtcblxuICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgIHRoaXMuYmFzZS5yZWdpc3RlcigpLmNhdGNoKCgpID0+IHsgLyogZG8gbm90aGluZyAqLyB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJzY3JpcHRpb24gZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBvcHRpb25zLnJlZ2lzdGVyU3RvcmVIYW5kbGVyKHN0b3JlID0+IHtcbiAgICAgICAgICAvLyBzZXQgc3RvcmUgdG8gc2VsZiBmaXJzdFxuICAgICAgICAgIGhhbmRsZXIoc3RvcmUpO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHN0b3JlIHdpdGggY2FjaGVkRmlsdGVyc1xuICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZUZpbHRlcnMsXG4gICAgICAgICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzW3N5bWJvbHMuZmlsdGVyQ2FjaGVdID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYWN0aW9uczogc3Vic2NyaXB0aW9uQWN0aW9ucyxcbiAgICB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGF1dGgsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHNkayxcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzW3N5bWJvbHMuYXV0aF0gPSBhdXRoO1xuICAgIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzW3N5bWJvbHMuc2RrXSA9IHNkaztcbiAgICB0aGlzW3N5bWJvbHMuc3Vic2NyaXB0aW9uXSA9IG51bGw7XG5cbiAgICAvLyBjYWNoZXMgZmlsdGVycyBiZWZvcmUgcmVkdXggc3RvcmUgaXMgY3JlYXRlZFxuICAgIHRoaXNbc3ltYm9scy5maWx0ZXJDYWNoZV0gPSBbXTtcblxuICAgIGF1dGgub24oYXV0aC5ldmVudHMubG9nZ2VkSW4sICgpID0+IHtcbiAgICAgIHRoaXM6OmluaXQoKTtcbiAgICB9KTtcblxuICAgIGF1dGgub24oYXV0aC5ldmVudHMubG9nZ2VkT3V0LCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5iYXNlKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dpblN1Y2Nlc3MsICgpID0+IHtcbiAgICAvLyAgIHRoaXM6OmluaXQoKTtcbiAgICAvLyB9KTtcbiAgICAvLyBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9nb3V0U3VjY2VzcywgYXN5bmMgKCkgPT4ge1xuICAgIC8vICAgaWYgKHRoaXMuYmFzZSkge1xuICAgIC8vICAgICBhd2FpdCB0aGlzLnJlc2V0KCk7XG4gICAgLy8gICB9XG4gICAgLy8gICB0aGlzW3N5bWJvbHMuc3Vic2NyaXB0aW9uXSA9IG51bGw7XG4gICAgLy8gfSk7XG5cbiAgICBhdXRoLmFkZEJlZm9yZUxvZ291dEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXNldCgpO1xuICAgIH0pO1xuXG4gICAgLy8gKGFzeW5jICgpID0+IHtcbiAgICAvLyAgIGlmIChhd2FpdCBwbGF0Zm9ybS5sb2dnZWRJbigpKSB7XG4gICAgLy8gICAgIHRoaXM6OmluaXQoKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9KSgpO1xuICB9XG5cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIGdldFN1YnNjcmlwdGlvblJlZHVjZXIodGhpcy5wcmVmaXgpO1xuICB9XG5cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5zdGF0dXM7XG4gIH1cblxuICBnZXQgZmlsdGVycygpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLmZpbHRlckNhY2hlXSB8fCB0aGlzLnN0YXRlLmZpbHRlcnM7XG4gIH1cblxuICBnZXQgYmFzZSgpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLnN1YnNjcmlwdGlvbl07XG4gIH1cblxuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBzdWJzY3JpcHRpb25FdmVudHM7XG4gIH1cblxuICBnZXQgZXZlbnRUeXBlcygpIHtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uRXZlbnRUeXBlcztcbiAgfVxuXG4gIHN1YnNjcmliZShldmVudCkge1xuICAgIC8vIFRPRE8gbm9ybWFsaXplZCBlcnJvclxuICAgIGlmICghc3Vic2NyaXB0aW9uRXZlbnRzOjpFbnVtLmhhc1ZhbHVlKGV2ZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmVudCBpcyBub3QgcmVjb2duaXplZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbHRlcnMuaW5kZXhPZihldmVudCkgPT09IC0xKSB7XG4gICAgICBjb25zdCBuZXdGaWx0ZXJzID0gdGhpcy5maWx0ZXJzLnNsaWNlKCk7XG4gICAgICBuZXdGaWx0ZXJzLnB1c2goZXZlbnQpO1xuICAgICAgaWYgKHRoaXMuYmFzZSkge1xuICAgICAgICB0aGlzLmJhc2Uuc2V0RXZlbnRGaWx0ZXJzKG5ld0ZpbHRlcnMpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudXBkYXRlRmlsdGVycyxcbiAgICAgICAgICBmaWx0ZXJzOiBuZXdGaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYXNlLnJlZ2lzdGVyKCkuY2F0Y2goKCkgPT4geyAvKiBkbyBub3RoaW5nICovIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tzeW1ib2xzLmZpbHRlckNhY2hlXSA9IG5ld0ZpbHRlcnM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdW5zdWJzY3JpYmUoZXZlbnQpIHtcbiAgICAvLyBUT0RPIG5vcm1hbGl6ZWQgZXJyb3JcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkV2ZW50czo6RW51bS5oYXNWYWx1ZShldmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXZlbnQgaXMgbm90IHJlY29nbml6ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgaWR4ID0gdGhpcy5maWx0ZXJzLmluZGV4T2YoZXZlbnQpO1xuICAgIGlmICh0aGlzLmZpbHRlcnMuaW5kZXhPZihldmVudCkgPiAtMSkge1xuICAgICAgY29uc3QgbmV3RmlsdGVycyA9IHRoaXMuZmlsdGVycy5zbGljZSgpO1xuICAgICAgbmV3RmlsdGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIGlmICh0aGlzLmJhc2UpIHtcbiAgICAgICAgdGhpcy5iYXNlLnNldEV2ZW50RmlsdGVycyhuZXdGaWx0ZXJzKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZUZpbHRlcnMsXG4gICAgICAgICAgZmlsdGVyczogbmV3RmlsdGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdGaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYmFzZS5yZWdpc3RlcigpLmNhdGNoKCgpID0+IHsgLyogZG8gbm90aGluZyAqLyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJhc2UucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbc3ltYm9scy5maWx0ZXJDYWNoZV0gPSBuZXdGaWx0ZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlc2V0KCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5iYXNlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gc3Vic2NyaXB0aW9uU3RhdHVzLnN1YnNjcmliZWQpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmJhc2UucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5iYXNlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIHRoaXNbc3ltYm9scy5zdWJzY3JpcHRpb25dID0gbnVsbDtcbiAgICBjb25zdCBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5ub3RTdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiBudWxsLFxuICAgIH0pO1xuICAgIGlmIChvbGRTdGF0dXMgIT09IHRoaXMuc3RhdHVzKSB7XG4gICAgICB0aGlzOjplbWl0KHN1YnNjcmlwdGlvbkV2ZW50VHlwZXMuc3RhdHVzQ2hhbmdlZCwgdGhpcy5zdGF0dXMpO1xuICAgIH1cbiAgfVxuXG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL2luZGV4LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCB7IEFjdGlvbk1hcCB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgQWN0aW9uTWFwKFtcbiAgJ3VwZGF0ZUZpbHRlcnMnLFxuICAnbm90aWZpY2F0aW9uJyxcblxuICAndXBkYXRlU3RhdHVzJyxcblxuXSwgJ3N1YnNjcmlwdGlvbicpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5pbXBvcnQgc3Vic2NyaXB0aW9uQWN0aW9ucyBmcm9tICcuL3N1YnNjcmlwdGlvbi1hY3Rpb25zJztcbmltcG9ydCB7IHN1YnNjcmlwdGlvbkV2ZW50cyB9IGZyb20gJy4vc3Vic2NyaXB0aW9uLWV2ZW50cyc7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgY2FjaGVLZXk6IG51bGwsXG4gIGZpbHRlcnM6IFtdLFxuICBzdGF0dXM6IHN1YnNjcmlwdGlvbkV2ZW50cy5wZW5kaW5nLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uUmVkdWNlcihwcmVmaXgpIHtcbiAgY29uc3QgYWN0aW9ucyA9IHByZWZpeEFjdGlvbnMoc3Vic2NyaXB0aW9uQWN0aW9ucywgcHJlZml4KTtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgY2FzZSBhY3Rpb25zLnVwZGF0ZVN0YXR1czpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdHVzOiBhY3Rpb24uc3RhdHVzLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiBhY3Rpb25zLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICBjYXNlIGFjdGlvbnMudXBkYXRlRmlsdGVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVyczogYWN0aW9uLmZpbHRlcnMuc2xpY2UoKSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgc3Vic2NyaXB0aW9uU3RhdHVzIGZyb20gJy4vc3Vic2NyaXB0aW9uLXN0YXR1cyc7XG5cblxuY29uc3QgZXZlbnREZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vbWVzc2FnZS1zdG9yZScsXG4gIHByZXNlbmNlOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UnLFxuICB0ZWxlcGhvbnk6ICcvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vfi9wcmVzZW5jZT9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUnLFxuICBsaW5lOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UvbGluZScsXG4gIGxpbmVQcmVzZW5jZTpcbiAgICAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UvbGluZS9wcmVzZW5jZScsXG4gIGxpbmVUZWxlcGhvbnk6XG4gICAgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC9+L2V4dGVuc2lvbi9+L3ByZXNlbmNlL2xpbmUvcHJlc2VuY2U/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlJyxcbiAgLi4uc3Vic2NyaXB0aW9uU3RhdHVzLFxufTtcblxuZXhwb3J0IGNvbnN0IHN1YnNjcmlwdGlvbkV2ZW50cyA9IG5ldyBFbnVtKGV2ZW50RGVmaW5pdGlvbik7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb24gPSB7XG4gIG5vdGlmaWNhdGlvbjogJ05PVElGSUNBVElPTicsXG4gIHN0YXR1c0NoYW5nZWQ6ICdTVEFUVVNfQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3Qgc3Vic2NyaXB0aW9uRXZlbnRUeXBlcyA9IG5ldyBFbnVtKGV2ZW50VHlwZURlZmluaXRpb24pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLWV2ZW50cy5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgcGVuZGluZzogJ1BFTkRJTkcnLFxuICBzdWJzY3JpYmVkOiAnU1VCU0NSSUJFRCcsXG4gIG5vdFN1YnNjcmliZWQ6ICdOT1RfU1VCU0NSSUJFRCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgRW51bShkZWZpbml0aW9uKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1zdGF0dXMuanNcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4uLy4uL2xpYi9zeW1ib2wtbWFwJztcbmltcG9ydCB7IGV4dHJhY3REYXRhLCBmZXRjaExpc3QsIGVtaXQgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHVzZXJBY3Rpb25zIGZyb20gJy4vdXNlci1hY3Rpb25zJztcbmltcG9ydCBnZXRVc2VyUmVkdWNlciBmcm9tICcuL3VzZXItcmVkdWNlcic7XG5pbXBvcnQgeyB1c2VyRXZlbnRzLCB1c2VyRXZlbnRUeXBlcyB9IGZyb20gJy4vdXNlci1ldmVudHMnO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdhcGknLFxuICAncGxhdGZvcm0nLFxuICAnc2V0dGluZ3MnLFxuXSk7XG5cbi8vIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbi8vICAgdGVzdDogdHJ1ZSxcbi8vIH07XG5cbi8vIGZ1bmN0aW9uIGdldFVzZXJTZXR0aW5nc1JlZHVjZXIocHJlZml4KSB7XG4vLyAgIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuLy8gICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcbi8vICAgICBpZiAoIWFjdGlvbikgcmV0dXJuIHN0YXRlO1xuLy8gICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbi8vICAgICAgIGRlZmF1bHQ6XG4vLyAgICAgICAgIHJldHVybiBzdGF0ZTtcbi8vICAgICB9XG4vLyAgIH07XG4vLyB9XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxvYWRGdW5jdGlvbiAtIGFzeW5jIGxvYWRlciBmdW5jdGlvbiByZXR1cm5pbmcgYSBwcm9taXNlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGRlc2NyaXB0aW9uIEdlbmVyaWMgZGF0YSBsb2FkaW5nIGxvZ2ljIHdpdGggZXZlbnRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWREYXRhKGRhdGFUeXBlLCBsb2FkRnVuY3Rpb24pIHtcbiAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1gXSxcbiAgfSk7XG4gIHRoaXMuZW1pdCh1c2VyRXZlbnRzW2Bsb2FkJHtkYXRhVHlwZX1gXSk7XG4gIHRyeSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXM6OmxvYWRGdW5jdGlvbigpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1TdWNjZXNzYF0sXG4gICAgICBwYXlsb2FkLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQodXNlckV2ZW50VHlwZXMudXNlckluZm9DaGFuZ2VkLCB1c2VyRXZlbnRzW2Bsb2FkJHtkYXRhVHlwZX1TdWNjZXNzYF0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1GYWlsZWRgXSxcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQodXNlckV2ZW50c1tgbG9hZCR7ZGF0YVR5cGV9RmFpbGVkYF0pO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59XG4gKiBAZGVzY3JpcHRpb24gRmV0Y2ggYWNjb3VudCBpbmZvIGFuZCBleHRyYWN0IHRoZSBkYXRhXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RBY2NvdW50SW5mbygpIHtcbiAgcmV0dXJuIGV4dHJhY3REYXRhKGF3YWl0IHRoaXNbc3ltYm9scy5hcGldLmFjY291bnQoKS5sb2FkQWNjb3VudCgpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRBY2NvdW50SW5mbygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdBY2NvdW50SW5mbycsIGV4dHJhY3RBY2NvdW50SW5mbyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RFeHRlbnNpb25JbmZvKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpc1tzeW1ib2xzLmFwaV0uZXh0ZW5zaW9uKCkubG9hZEV4dGVuc2lvbkluZm8oKSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkRXh0ZW5zaW9uSW5mbygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdFeHRlbnNpb25JbmZvJywgZXh0cmFjdEV4dGVuc2lvbkluZm8pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0RGlhbGluZ1BsYW5zKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpczo6ZmV0Y2hMaXN0KG9wdGlvbnMgPT4gKFxuICAgIHRoaXNbc3ltYm9scy5hcGldLmFjY291bnQoKS5saXN0RGlhbGluZ1BsYW5zKG9wdGlvbnMpXG4gICkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWREaWFsaW5nUGxhbnMoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzOjpsb2FkRGF0YSgnRGlhbGluZ1BsYW5zJywgZXh0cmFjdERpYWxpbmdQbGFucyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RQaG9uZU51bWJlcnMoKSB7XG4gIHJldHVybiBleHRyYWN0RGF0YShhd2FpdCB0aGlzOjpmZXRjaExpc3Qob3B0aW9ucyA9PiAoXG4gICAgdGhpc1tzeW1ib2xzLmFwaV0uZXh0ZW5zaW9uKCkubGlzdEV4dGVuc2lvblBob25lTnVtYmVycyhvcHRpb25zKVxuICApKSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkUGhvbmVOdW1iZXJzKCkge1xuICByZXR1cm4gYXdhaXQgdGhpczo6bG9hZERhdGEoJ1Bob25lTnVtYmVycycsIGV4dHJhY3RQaG9uZU51bWJlcnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0Rm9yd2FyZGluZ051bWJlcnMoKSB7XG4gIHJldHVybiBleHRyYWN0RGF0YShhd2FpdCB0aGlzOjpmZXRjaExpc3Qob3B0aW9ucyA9PiAoXG4gICAgdGhpc1tzeW1ib2xzLmFwaV0uZm9yd2FyZGluZ051bWJlcnMoKS5saXN0RXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlcnMob3B0aW9ucylcbiAgKSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEZvcndhcmRpbmdOdW1iZXJzKCkge1xuICByZXR1cm4gYXdhaXQgdGhpczo6bG9hZERhdGEoJ0ZvcndhcmRpbmdOdW1iZXJzJywgZXh0cmFjdEZvcndhcmRpbmdOdW1iZXJzKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEJsb2NrZWROdW1iZXJzKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpczo6ZmV0Y2hMaXN0KG9wdGlvbnMgPT4gKFxuICAgIHRoaXNbc3ltYm9scy5hcGldLmJsb2NrZWROdW1iZXJzKCkubGlzdEJsb2NrZWROdW1iZXJzKG9wdGlvbnMpXG4gICkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRCbG9ja2VkTnVtYmVycygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdCbG9ja2VkTnVtYmVycycsIGV4dHJhY3RCbG9ja2VkTnVtYmVycyk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkSW5mbygpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzOjpsb2FkQWNjb3VudEluZm8oKSxcbiAgICAgIHRoaXM6OmxvYWRFeHRlbnNpb25JbmZvKCksXG4gICAgICB0aGlzOjpsb2FkRGlhbGluZ1BsYW5zKCksXG4gICAgICB0aGlzOjpsb2FkUGhvbmVOdW1iZXJzKCksXG4gICAgICB0aGlzOjpsb2FkRm9yd2FyZGluZ051bWJlcnMoKSxcbiAgICAgIHRoaXM6OmxvYWRCbG9ja2VkTnVtYmVycygpLFxuICAgIF0pO1xuICAgIC8vIHRoaXMuZW1pdCh1c2VyRXZlbnRzLnVzZXJJbmZvTG9hZGVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE8gc2VuZCBlcnJvciBvdXRcbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBjbGFzcyBVc2VyXG4gKiBAZXh0ZW5kcyBSY01vZHVsZVxuICogQGRlZmF1bHRcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlciBleHRlbmRzIFJjTW9kdWxlIHtcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhY3Rpb25zOiB1c2VyQWN0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhcGksXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHNldHRpbmdzLFxuICAgIH0gPSBvcHRpb25zO1xuICAgIHRoaXNbc3ltYm9scy5hcGldID0gYXBpO1xuICAgIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzW3N5bWJvbHMuc2V0dGluZ3NdID0gc2V0dGluZ3M7XG5cbiAgICAvLyBzZXR0aW5ncy5yZWdpc3RlclJlZHVjZXIoJ3VzZXInLCBnZXRVc2VyU2V0dGluZ3NSZWR1Y2VyKCkpO1xuXG4gICAgLy8gbG9hZCBpbmZvIG9uIGxvZ2luXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luU3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpczo6bG9hZEluZm8oKTtcbiAgICB9KTtcbiAgICAvLyB1bmxvYWQgaW5mbyBvbiBsb2dvdXRcbiAgICBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9nb3V0U3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jbGVhclVzZXJJbmZvLFxuICAgICAgfSk7XG4gICAgICAvLyB0aGlzLmVtaXQodXNlckV2ZW50cy51c2VySW5mb0NsZWFyZWQpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBsb2FkIGluZm8gaWYgYWxyZWFkeSBsb2dnZWQgaW5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGF3YWl0IHBsYXRmb3JtLmxvZ2dlZEluKCkpIHtcbiAgICAgICAgYXdhaXQgdGhpczo6bG9hZEluZm8oKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogVE9ETzpcbiAgICAgKiAgIDEuIERpYWxpbmcgUGxhbiBDaGVja2luZ1xuICAgICAqL1xuICB9XG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiBnZXRVc2VyUmVkdWNlcih0aGlzLnByZWZpeCk7XG4gIH1cblxuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiB1c2VyRXZlbnRzO1xuICB9XG5cbiAgZ2V0IGV2ZW50VHlwZXMoKSB7XG4gICAgcmV0dXJuIHVzZXJFdmVudFR5cGVzO1xuICB9XG5cbiAgZ2V0IGRpcmVjdE51bWJlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGhvbmVOdW1iZXJzLmZpbHRlcihuID0+IG4udXNhZ2VUeXBlID09PSAnRGlyZWN0TnVtYmVyJyk7XG4gIH1cblxuICBnZXQgbWFpbkNvbXBhbnlOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGhvbmVOdW1iZXJzLmZpbmQobiA9PiBuLnVzYWdlVHlwZSA9PT0gJ01haW5Db21wYW55TnVtYmVyJyk7XG4gIH1cblxuICBnZXQgZGlhbGluZ1BsYW5zKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRpYWxpbmdQbGFucztcbiAgfVxuXG4gIGdldCBleHRlbnNpb25OdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXh0ZW5zaW9uSW5mby5leHRlbnNpb25OdW1iZXI7XG4gIH1cblxuICBnZXQgc21zTnVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5waG9uZU51bWJlcnMuZmlsdGVyKG4gPT4gbi5mZWF0dXJlcy5pbmRleE9mKCdTbXNTZW5kZXInKSA+IC0xKTtcbiAgfVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3VzZXIvaW5kZXguanNcbiAqKi8iLCJpbXBvcnQgeyBBY3Rpb25NYXAgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFjdGlvbk1hcChbXG4gICdjbGVhclVzZXJJbmZvJyxcblxuICAnbG9hZEFjY291bnRJbmZvJyxcbiAgJ2xvYWRBY2NvdW50SW5mb1N1Y2Nlc3MnLFxuICAnbG9hZEFjY291bnRJbmZvRmFpbGVkJyxcblxuICAnbG9hZEV4dGVuc2lvbkluZm8nLFxuICAnbG9hZEV4dGVuc2lvbkluZm9TdWNjZXNzJyxcbiAgJ2xvYWRFeHRlbnNpb25JbmZvRmFpbGVkJyxcblxuICAnbG9hZERpYWxpbmdQbGFucycsXG4gICdsb2FkRGlhbGluZ1BsYW5zU3VjY2VzcycsXG4gICdsb2FkRGlhbGluZ1BsYW5zRmFpbGVkJyxcblxuICAnbG9hZFBob25lTnVtYmVycycsXG4gICdsb2FkUGhvbmVOdW1iZXJzU3VjY2VzcycsXG4gICdsb2FkUGhvbmVOdW1iZXJzRmFpbGVkJyxcblxuICAnbG9hZEZvcndhcmRpbmdOdW1iZXJzJyxcbiAgJ2xvYWRGb3J3YXJkaW5nTnVtYmVyc1N1Y2Nlc3MnLFxuICAnbG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkJyxcblxuICAnbG9hZEJsb2NrZWROdW1iZXJzJyxcbiAgJ2xvYWRCbG9ja2VkTnVtYmVyc1N1Y2Nlc3MnLFxuICAnbG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkJyxcblxuXSwgJ3VzZXInKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvdXNlci91c2VyLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5pbXBvcnQgdXNlckFjdGlvbnMgZnJvbSAnLi91c2VyLWFjdGlvbnMnO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGFjY291bnRJbmZvOiBudWxsLFxuICBhY2NvdW50SW5mb0xvYWRpbmc6IGZhbHNlLFxuICBhY2NvdW50SW5mb0Vycm9yOiBudWxsLFxuXG4gIGV4dGVuc2lvbkluZm86IG51bGwsXG4gIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiBmYWxzZSxcbiAgZXh0ZW5zaW9uSW5mb0Vycm9yOiBudWxsLFxuXG4gIGRpYWxpbmdQbGFuczogW10sXG4gIGRpYWxpbmdQbGFuc0xvYWRpbmc6IGZhbHNlLFxuICBkaWFsaW5nUGxhbnNFcnJvcjogbnVsbCxcblxuICBwaG9uZU51bWJlcnM6IFtdLFxuICBwaG9uZU51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgcGhvbmVOdW1iZXJzRXJyb3I6IG51bGwsXG5cbiAgZm9yd2FyZGluZ051bWJlcnM6IFtdLFxuICBmb3J3YXJkaW5nTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICBmb3J3YXJkaW5nTnVtYmVyc0Vycm9yOiBudWxsLFxuXG4gIGJsb2NrZWROdW1iZXJzOiBbXSxcbiAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgYmxvY2tlZE51bWJlcnNFcnJvcjogbnVsbCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVzZXJSZWR1Y2VyKHByZWZpeCkge1xuICBjb25zdCBhY3Rpb25zID0gcHJlZml4QWN0aW9ucyh1c2VyQWN0aW9ucywgcHJlZml4KTtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG4gICAgICAvLyBhY2NvdW50IGluZm9cbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkQWNjb3VudEluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFjY291bnRJbmZvTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRBY2NvdW50SW5mb1N1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFjY291bnRJbmZvOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICAgIGFjY291bnRJbmZvTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBhY2NvdW50SW5mb0Vycm9yOiBudWxsLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEFjY291bnRJbmZvRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY2NvdW50SW5mb0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYWNjb3VudEluZm9FcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGV4dGVuc2lvbiBpbmZvXG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEV4dGVuc2lvbkluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEV4dGVuc2lvbkluZm9TdWNjZXNzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHRlbnNpb25JbmZvOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9FcnJvcjogbnVsbCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRFeHRlbnNpb25JbmZvRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHRlbnNpb25JbmZvTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBleHRlbnNpb25JbmZvRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICAvLyBkaWFsaW5nIHBsYW5zXG4gICAgICBjYXNlIGFjdGlvbnMubG9hZERpYWxpbmdQbGFuczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGlhbGluZ1BsYW5zTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWREaWFsaW5nUGxhbnNTdWNjZXNzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkaWFsaW5nUGxhbnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGRpYWxpbmdQbGFuczogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgYWN0aW9uLmxvYWREaWFsaW5nUGxhbnNGYWlsZWQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRpYWxpbmdQbGFuc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZGlhbGluZ1BsYW5zRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG5cbiAgICAgIC8vIHBob25lIG51bWJlcnNcbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkUGhvbmVOdW1iZXJzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwaG9uZU51bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZFBob25lTnVtYmVyc1N1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBob25lTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZFBob25lTnVtYmVyc0ZhaWxlZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcGhvbmVOdW1iZXJzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBwaG9uZU51bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGZvcndhcmRpbmcgbnVtYmVyc1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRGb3J3YXJkaW5nTnVtYmVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEZvcndhcmRpbmdOdW1iZXJzU3VjY2VzczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcndhcmRpbmdOdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmb3J3YXJkaW5nTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGJsb2NrZWQgbnVtYmVyc1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRCbG9ja2VkTnVtYmVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEJsb2NrZWROdW1iZXJzU3VjY2VzczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGJsb2NrZWROdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBibG9ja2VkTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgYWN0aW9uLmNsZWFyVXNlckluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvdXNlci91c2VyLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5cbmNvbnN0IGV2ZW50RGVmaW5pdGlvbnMgPSB7XG4gIHVzZXJJbmZvTG9hZGVkOiAnVVNFUl9JTkZPX0xPQURFRCcsXG4gIHVzZXJJbmZvQ2xlYXJlZDogJ1VTRVJfSU5GT19DTEVBUkVEJyxcblxuICBsb2FkQWNjb3VudEluZm86ICdMT0FEX0FDQ09VTlRfSU5GTycsXG4gIGxvYWRBY2NvdW50SW5mb1N1Y2Nlc3M6ICdMT0FEX0FDQ09VTlRfSU5GT19TVUNDRVNTJyxcbiAgbG9hZEFjY291bnRJbmZvRmFpbGVkOiAnTE9BRF9BQ0NPVU5UX0lORk9fRkFJTEVEJyxcblxuICBsb2FkRXh0ZW5zaW9uSW5mbzogJ0xPQURfRVhURU5TSU9OX0lORk8nLFxuICBsb2FkRXh0ZW5zaW9uSW5mb1N1Y2Nlc3M6ICdMT0FEX0VYVEVOU0lPTl9JTkZPX1NVQ0NFU1MnLFxuICBsb2FkRXh0ZW5zaW9uSW5mb0ZhaWxlZDogJ0xPQURfRVhURU5TSU9OX0lORk9fRkFJTEVEJyxcblxuICBsb2FkRGlhbGluZ1BsYW5zOiAnTE9BRF9ESUFMSU5HX1BMQU5TJyxcbiAgbG9hZERpYWxpbmdQbGFuc1N1Y2Nlc3M6ICdMT0FEX0RJQUxJTkdfUExBTlNfU1VDQ0VTUycsXG4gIGxvYWREaWFsaW5nUGxhbnNGYWlsZWQ6ICdMT0FEX0RJQUxJTkdfUExBTlNfRkFJTEVEJyxcblxuICBsb2FkUGhvbmVOdW1iZXJzOiAnTE9BRF9QSE9ORV9OVU1CRVJTJyxcbiAgbG9hZFBob25lTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX1BIT05FX05VTUJFUlNfU1VDQ0VTUycsXG4gIGxvYWRQaG9uZU51bWJlcnNGYWlsZWQ6ICdMT0FEX1BIT05FX05VTUJFUlNfRkFJTEVEJyxcblxuICBsb2FkRm9yd2FyZGluZ051bWJlcnM6ICdMT0FEX0ZPUldBUkRJTkdfTlVNQkVSUycsXG4gIGxvYWRGb3J3YXJkaW5nTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX0ZPUldBUkRJTkdfTlVNQkVSU19TVUNDRVNTJyxcbiAgbG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkOiAnTE9BRF9GT1JXQVJESU5HX05VTUJFUlNfRkFJTEVEJyxcblxuICBsb2FkQmxvY2tlZE51bWJlcnM6ICdMT0FEX0JMT0NLRURfTlVNQkVSUycsXG4gIGxvYWRCbG9ja2VkTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX0JMT0NLRURfTlVNQkVSU19TVUNDRVNTJyxcbiAgbG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkOiAnTE9BRF9CTE9DS0VEX05VTUJFUlNfRkFJTEVEJyxcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VyRXZlbnRzID0gbmV3IEVudW0oZXZlbnREZWZpbml0aW9ucyk7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb25zID0ge1xuICB1c2VySW5mb0NoYW5nZWQ6ICdVU0VSX0lORk9fQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3QgdXNlckV2ZW50VHlwZXMgPSBuZXcgRW51bShldmVudFR5cGVEZWZpbml0aW9ucyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3VzZXIvdXNlci1ldmVudHMuanNcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4uLy4uL2xpYi9zeW1ib2wtbWFwJztcbmltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcbmltcG9ydCB3ZWJwaG9uZUFjdGlvbnMgZnJvbSAnLi93ZWJwaG9uZS1hY3Rpb25zJztcbmltcG9ydCBjYWxsQWN0aW9ucyBmcm9tICcuL2NhbGwtYWN0aW9ucyc7XG5pbXBvcnQgZ2V0UmVkdWNlciBmcm9tICcuL3dlYnBob25lLXJlZHVjZXInO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSAnZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgUmluZ0NlbnRyYWxXZWJwaG9uZSBmcm9tICdyaW5nY2VudHJhbC13ZWItcGhvbmUnO1xuaW1wb3J0IHdlYnBob25lU3RhdHVzIGZyb20gJy4uLy4uL2VudW1zL3dlYnBob25lLXN0YXR1cyc7XG5pbXBvcnQgY2FsbFN0YXR1cyBmcm9tICcuLi8uLi9lbnVtcy9jYWxsLXN0YXR1cyc7XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ2FwaScsXG4gICdwbGF0Zm9ybScsXG4gICdlbWl0dGVyJyxcbiAgJ3NldHRpbmdzJyxcbiAgJ3Bob25lSW5zdGFuY2UnLFxuXSk7XG5cbmNvbnN0IEVOVU1TID0gbmV3IEVudW0oe1xuICB3ZWJwaG9uZVN0YXR1cyxcbiAgY2FsbFN0YXR1cyxcbn0pO1xuXG5hc3luYyBmdW5jdGlvbiBpbml0UGhvbmVJbnN0YW5jZSgpIHtcbiAgY29uc3QgaW5mbyA9IGF3YWl0IHRoaXNbc3ltYm9scy5wbGF0Zm9ybV1cbiAgICAucG9zdCgnL2NsaWVudC1pbmZvL3NpcC1wcm92aXNpb24nLCB7XG4gICAgICBzaXBJbmZvOiBbeyB0cmFuc3BvcnQ6ICdXU1MnIH1dLFxuICAgIH0pXG4gICAgLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpO1xuICByZXR1cm4gbmV3IFJpbmdDZW50cmFsV2VicGhvbmUoaW5mbywge1xuICAgIGxvZ0xldmVsOiAwLFxuICAgIGF1ZGlvSGVscGVyOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICB9LFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVjb3JkKGZsYWcgPSB0cnVlKSB7XG4gIGlmICghZmxhZykge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uc3RvcFJlY29yZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMuc3RvcFJlY29yZCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi5zdGFydFJlY29yZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMucmVjb3JkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBtdXRlKGZsYWcgPSB0cnVlKSB7XG4gIGlmICghZmxhZykge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24udW5tdXRlKCk7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICB0eXBlOiBjYWxsQWN0aW9ucy51bm11dGUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24ubXV0ZSgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMubXV0ZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaG9sZChmbGFnID0gdHJ1ZSkge1xuICBpZiAoIWZsYWcpIHtcbiAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnVuaG9sZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMudW5ob2xkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLmhvbGQoKTtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmhvbGQsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhcmsoKSB7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24ucGFyaygpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLnBhcmssXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zZmVyKG51bWJlcikge1xuICB0aGlzLmNoZWNrU2Vzc2lvbigpO1xuICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnRyYW5zZmVyKG51bWJlcik7XG4gIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgIG9wZXJhdGlvbjoge1xuICAgICAgdHlwZTogY2FsbEFjdGlvbnMudHJhbnNmZXIsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZsaXAobnVtYmVyKSB7XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uZmxpcChudW1iZXIpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmZsaXAsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGR0bWYobnVtYmVyKSB7XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uZHRtZihudW1iZXIpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmR0bWYsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9wZXJhdGlvbnMobmFtZSwgLi4uYXJncykge1xuICBjb25zdCBhY3Rpb25zID0geyByZWNvcmQsIG11dGUsIGhvbGQsIHBhcmssIHRyYW5zZmVyLCBmbGlwLCBkdG1mIH07XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgYWN0aW9uc1tuYW1lXS5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMuZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICAvLyBUT0RPOiBuZWVkZWQ/XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2VicGhvbmUgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYWN0aW9uczogd2VicGhvbmVBY3Rpb25zLFxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFwaSxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgc2V0dGluZ3MsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpc1tzeW1ib2xzLmFwaV0gPSBhcGk7XG4gICAgdGhpc1tzeW1ib2xzLnBsYXRmb3JtXSA9IHBsYXRmb3JtO1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXSA9IG5ldyBFbWl0dGVyKCk7XG4gICAgdGhpc1tzeW1ib2xzLnNldHRpbmdzXSA9IHNldHRpbmdzO1xuXG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICAgIC8vIFRPRE86IGNvbW1lbnRlZCBvdXQgdW50aWwgc2V0dGluZyBtb2R1bGUgY29tcGxldGVkXG4gICAgLy8gc2V0dGluZ3MucmVnaXN0ZXJSZWR1Y2VyKCd3ZWJwaG9uZScsIGdldFdlYnBob25lUmVkdWNlcigpKVxuXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luU3VjY2VzcywgYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpc1tzeW1ib2xzLnBob25lSW5zdGFuY2VdID0gYXdhaXQgdGhpczo6aW5pdFBob25lSW5zdGFuY2UoKTtcbiAgICAgIHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQub24oJ3JlZ2lzdGVyZWQnLCAoKSA9PiB7XG4gICAgICAgIC8vIHNpcCB3aWxsIGZpcmUgbXVsdGlwbGUgcmVnaXN0ZXJlZCBldmVudHMsIG9ubHkgZGlzcGF0Y2ggb25lIHJlZ2lzdGVyIGFjdGlvbiB0byBzdGF0ZS5cbiAgICAgICAgLy8gVE9ETzogaXMgdGhpcyBpc1JlZ2lzdGVyZWQgc3RhdGUgbmVlZGVkIHRvIGJlIHN0b3JlIGFzIGluc3RhbmNlIHZhcmlhYmxlXG4gICAgICAgIC8vICAgICAgIG9yIGp1c3QgY2hlY2sgc3RvcmUgc3RhdGVcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVnaXN0ZXJlZCkge1xuICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnJlZ2lzdGVyU3VjY2VzcyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVnaXN0ZXJlZCA9IHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQuaXNSZWdpc3RlcmVkKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQub24oJ3VucmVnaXN0ZXJlZCcsICgpID0+IHtcbiAgICAgICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50LmlzUmVnaXN0ZXJlZCgpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudW5yZWdpc3RlcixcbiAgICAgICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmNsZWFyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50Lm9uKCdyZWdpc3RyYXRpb25GYWlsZWQnLCAoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnJlZ2lzdGVyRXJyb3IsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50Lm9uKCdpbnZpdGUnLCAoc2Vzc2lvbikgPT4ge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5saXN0ZW5TZXNzaW9uRXZlbnRzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNlc3Npb24pO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbEluY29taW5nLFxuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHJlbW90ZUlkZW50aXR5OiBzZXNzaW9uLnJlbW90ZUlkZW50aXR5LFxuICAgICAgICAgICAgbG9jYWxJZGVudGl0eTogc2Vzc2lvbi5sb2NhbElkZW50aXR5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZ2V0UmVkdWNlcih0aGlzLnByZWZpeCk7XG4gIH1cblxuICBnZXQgZW51bXMoKSB7XG4gICAgcmV0dXJuIEVOVU1TO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBwaG9uZSBjYWxsLCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGluIHJlZ2lzdGVyU3VjY2VzcyBzdGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9OdW1iZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tTnVtYmVyXVxuICAgKiBAcmV0dXJuIHtTZXNzaW9ufVxuICAgKi9cbiAgYXN5bmMgY2FsbCh7IHRvTnVtYmVyLCBmcm9tTnVtYmVyLCBtZWRpYSB9KSB7XG4gICAgLy8gQ2hlY2sgc3RhdHVzXG4gICAgaWYgKCF0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0pIHtcbiAgICAgIHRocm93IEVycm9yKCdub3QgcmVnaXN0ZXJlZCcpO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICB0b051bWJlcixcbiAgICAgICAgZnJvbU51bWJlcixcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQuaW52aXRlKHRvTnVtYmVyLCB7XG4gICAgICBtZWRpYToge1xuICAgICAgICByZW5kZXI6IG1lZGlhLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlblNlc3Npb25FdmVudHMoKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxFcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGEgcGhvbmUgY2FsbCwgdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGNhbGwgaXMgaW5jb21pbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lZGlhLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JpbmdjZW50cmFsL3JpbmdjZW50cmFsLXdlYi1waG9uZSNhY2NlcHRpbmctaW5jb21pbmctY2FsbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYWNjZXB0KG1lZGlhKSB7XG4gICAgdGhpcy5jaGVja1Nlc3Npb24oKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi5hY2NlcHQobWVkaWEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBUT0RPXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBieWUoKSB7XG4gICAgdGhpcy5jaGVja1Nlc3Npb24oKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi50ZXJtaW5hdGUoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVE9ET1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVjb3JkKGZsYWcpIHtcbiAgICBvcGVyYXRpb25zLmNhbGwodGhpcywgJ3JlY29yZCcsIGZsYWcpO1xuICB9XG5cbiAgYXN5bmMgbXV0ZShmbGFnKSB7XG4gICAgb3BlcmF0aW9ucy5jYWxsKHRoaXMsICdtdXRlJywgZmxhZyk7XG4gIH1cblxuICBhc3luYyBob2xkKGZsYWcpIHtcbiAgICBvcGVyYXRpb25zLmNhbGwodGhpcywgJ2hvbGQnLCBmbGFnKTtcbiAgfVxuXG4gIGFzeW5jIHBhcmsoZmxhZykge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAncGFyaycsIGZsYWcpO1xuICB9XG5cbiAgYXN5bmMgdHJhbnNmZXIobnVtYmVyKSB7XG4gICAgb3BlcmF0aW9ucy5jYWxsKHRoaXMsICd0cmFuc2ZlcicsIG51bWJlcik7XG4gIH1cblxuICBhc3luYyBmbGlwKG51bWJlcikge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAnZmxpcCcsIG51bWJlcik7XG4gIH1cblxuICBhc3luYyBkdG1mKG51bWJlcikge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAnZHRtZicsIG51bWJlcik7XG4gIH1cblxuICBjaGVja1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnNlc3Npb25FcnJvcixcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgRXJyb3IoJ05vIGFjdGl2ZSBzZXNzaW9uJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCBmb3IgbGlzdGVuIHNlc3Npb24gZXZlbnRzXG4gICAqL1xuICBsaXN0ZW5TZXNzaW9uRXZlbnRzKCkge1xuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ2FjY2VwdGVkJywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAvLyBhY2NlcHRlZCBldmVudCBmb3Igb3V0Ym91bmQgY2FsbCB3aWxsIHJldHVybmUgYSBpbmNvbWluZ1Jlc3BvbnNlXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YSkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbENvbm5lY3QsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgcmVtb3RlSWRlbnRpdHk6IHJlc3BvbnNlLnRvLFxuICAgICAgICAgICAgbG9jYWxJZGVudGl0eTogcmVzcG9uc2UuZnJvbSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIC8vIGFjY2VwdGVkIGV2ZW50IGZvciBpbmJvdW5kIGNhbGwgd2lsbCBvbmx5IGNvbnRhaW4gYSByb3cgc2lwIGRhdGFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsQWNjZXB0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBhbGwgc2l0dWF0aW9uIGFib3V0IGNhbGwgdGVybWluYXRlZCBleGNlcHQgJ2NhbGwgY2FuY2VsJ1xuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ3Rlcm1pbmF0ZWQnLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxFbmQsXG4gICAgICAgIGVycm9yOiBjYXVzZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgfSk7XG4gICAgLy8gd2hlbiB3ZSBjYWxsIG91dCBhbmQgY2FuY2VsIHRoZSBwaG9uZSBjYWxsXG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbi5vbignY2FuY2VsJywgKHJlc3BvbnNlLCBjYXVzZSkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsRW5kLFxuICAgICAgICBlcnJvcjogY2F1c2UsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgIH0pO1xuICAgIC8vIHNob3VsZCBub3QgbmVlZFxuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ2J5ZScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsRW5kLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gbnVsbDtcbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS9pbmRleC5qc1xuICoqLyIsImltcG9ydCB7IEFjdGlvbk1hcCB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgQWN0aW9uTWFwKFtcbiAgJ3JlZ2lzdGVyJyxcbiAgJ3JlZ2lzdGVyU3VjY2VzcycsXG4gICdyZWdpc3RlckVycm9yJyxcbiAgJ3VucmVnaXN0ZXInLFxuXG4gIC8vIG91dGJvdW5kIGNhbGxcbiAgJ2NhbGwnLFxuICAnY2FsbENvbm5lY3QnLFxuICAvLyBpbmJvdW5kIGNhbGxcbiAgJ2NhbGxBY2NlcHQnLFxuICAnY2FsbEluY29taW5nJyxcblxuICAnY2FsbEVuZCcsXG4gICdjYWxsRXJyb3InLFxuICAnY2FsbE9wZXJhdGlvbicsXG4gIC8vIG5vIGFjdGl2ZSBzZXNzaW9uXG4gICdzZXNzaW9uRXJyb3InLFxuXSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBBY3Rpb25NYXAgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFjdGlvbk1hcChbXG4gIC8vIG9wZXJhdGlvbmFsIGVycm9yXG4gICdlcnJvcicsXG4gIC8vIHVucmVnaXN0ZXIsIGNsZWFyIG9wZXJhdGlvbmFsIHN0YXRlXG4gICdjbGVhcicsXG4gIC8vIG9wZXJhdGlvblxuICAnZmxpcCcsXG4gICdyZWNvcmQnLFxuICAnc3RvcFJlY29yZCcsXG4gICdob2xkJyxcbiAgJ3VuaG9sZCcsXG4gICdtdXRlJyxcbiAgJ3VubXV0ZScsXG4gICdwYXJrJyxcbiAgJ3RyYW5zZmVyJyxcbiAgJ2ZvcndhcmQnLFxuICAnZHRtZicsXG5dKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1hY3Rpb25zLmpzXG4gKiovIiwiaW1wb3J0IHsgcHJlZml4QWN0aW9ucyB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuaW1wb3J0IHdlYnBob25lQWN0aW9ucyBmcm9tICcuL3dlYnBob25lLWFjdGlvbnMnO1xuaW1wb3J0IHdlYnBob25lU3RhdHVzIGZyb20gJy4uLy4uL2VudW1zL3dlYnBob25lLXN0YXR1cyc7XG5cbmltcG9ydCBjYWxsUmVkdWNlciBmcm9tICcuL2NhbGwtcmVkdWNlcic7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgc3RhdHVzOiB3ZWJwaG9uZVN0YXR1cy5wcmVSZWdpc3RlcixcbiAgLy8gYXNzaWduIGZyb20gVUlcbiAgdG9OdW1iZXI6ICcnLFxuICBmcm9tTnVtYmVyOiAnJyxcbiAgLy8gc2lwIGluZm8gcmV0dXJuIGZyb20gc2lwIHNlcnZlclxuICByZW1vdGVJZGVudGl0eTogbnVsbCxcbiAgbG9jYWxJZGVudGl0eTogbnVsbCxcbiAgb3BlcmF0aW9uOiBjYWxsUmVkdWNlcigpLFxuICBlcnJvcjogbnVsbCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJlZHVjZXIocHJlZml4KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBwcmVmaXhBY3Rpb25zKHdlYnBob25lQWN0aW9ucywgcHJlZml4KTtcblxuICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgaWYgKCFhY3Rpb24pIHJldHVybiBzdGF0ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICAgIGNhc2UgYWN0aW9ucy5yZWdpc3RlclN1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJTdWNjZXNzZWQsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBhY3Rpb25zLnJlZ2lzdGVyRXJyb3I6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJGYWlsZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMudW5yZWdpc3RlcjpcbiAgICAgICAgcmV0dXJuIGluaXRpYWxTdGF0ZTtcbiAgICAgIGNhc2UgYWN0aW9ucy5jYWxsOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxDb25uZWN0aW5nLFxuICAgICAgICAgIHRvTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC50b051bWJlcixcbiAgICAgICAgICBmcm9tTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC5mcm9tTnVtYmVyLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgYWN0aW9ucy5jYWxsSW5jb21pbmc6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMuY2FsbEluY29taW5nLFxuICAgICAgICAgIHJlbW90ZUlkZW50aXR5OiBhY3Rpb24ucGF5bG9hZC5yZW1vdGVJZGVudGl0eSxcbiAgICAgICAgICBsb2NhbElkZW50aXR5OiBhY3Rpb24ucGF5bG9hZC5sb2NhbElkZW50aXR5LFxuICAgICAgICB9KTtcbiAgICAgIC8vIFRPRE86IHVwZGF0ZSBmcm9tTnVtYmVyLCB0b051bWJlclxuICAgICAgY2FzZSBhY3Rpb25zLmNhbGxDb25uZWN0OlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxDb25uZWN0ZWQsXG4gICAgICAgICAgcmVtb3RlSWRlbnRpdHk6IGFjdGlvbi5wYXlsb2FkLnJlbW90ZUlkZW50aXR5LFxuICAgICAgICAgIGxvY2FsSWRlbnRpdHk6IGFjdGlvbi5wYXlsb2FkLmxvY2FsSWRlbnRpdHksXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBhY3Rpb25zLmNhbGxBY2NlcHQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMuY2FsbENvbm5lY3RlZCxcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbEVuZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJTdWNjZXNzZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbEVycm9yOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxGYWlsZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbE9wZXJhdGlvbjpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgICAgb3BlcmF0aW9uOiBjYWxsUmVkdWNlcihzdGF0ZS5vcGVyYXRpb24sIGFjdGlvbi5vcGVyYXRpb24pLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgYWN0aW9ucy5zZXNzaW9uRXJyb3I6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUsIHtcbiAgICAgICAgICBlcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICB9KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvd2VicGhvbmUtcmVkdWNlci5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgLy8gRm9yIHJlZ2lzdGVyaW5nXG4gIHByZVJlZ2lzdGVyOiAnUFJFX1JFR0lTVEVSJyxcbiAgcmVnaXN0ZXJTdWNjZXNzZWQ6ICdSRUdJU1RFUl9TVUNDRVNTRUQnLFxuICByZWdpc3RlckZhaWxlZDogJ1JFR0lTVEVSX0ZBSUxFRCcsXG4gIC8vIEZvciBjYWxsb3V0IGFuZCBhY3RpdmUgY2FsbFxuICBjYWxsQ29ubmVjdGluZzogJ0NBTExfQ09OTkVDVElORycsXG4gIGNhbGxDb25uZWN0ZWQ6ICdDQUxMX0NPTk5FQ1RFRCcsXG4gIGNhbGxGYWlsZWQ6ICdDQUxMX0ZBSUxFRCcsXG4gIC8vIEZvciBpbmNvbWluZyBjYWxsXG4gIGNhbGxJbmNvbWluZzogJ0NBTExfSU5DT01JTkcnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEVudW0oZGVmaW5pdGlvbik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9lbnVtcy93ZWJwaG9uZS1zdGF0dXMuanNcbiAqKi8iLCJpbXBvcnQgY2FsbEFjdGlvbnMgZnJvbSAnLi9jYWxsLWFjdGlvbnMnO1xuaW1wb3J0IGNhbGxTdGF0dXMgZnJvbSAnLi4vLi4vZW51bXMvY2FsbC1zdGF0dXMnO1xuXG5mdW5jdGlvbiBjb250YWluKGFyciwgZWxlKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZihlbGUpID4gLTE7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShhcnIsIGVsZSkge1xuICBpZiAoY29udGFpbihhcnIsIGVsZSkpIHtcbiAgICBhcnIuc3BsaWNlKGFyci5pbmRleE9mKGVsZSksIDEpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgLy8gb3BlcmF0aW9ucyB3aGljaCBpcyBlbmFibGVcbiAgc3RhdHVzOiBbXSxcbiAgLy8gc29tZSBvcGVyYXRpb25zIHdpbGwgZGlzYWJsZSBhbm90aGVyLCBzdWNoIGFzICdob2xkJ1xuICBkaXNhYmxlZDogW10sXG4gIC8vIHNvbWUgb3BlcmF0aW9ucyBoYXZlIGluZm9tYXRpb24gbmVlZCB0byBiZSBzdG9yZWRcbiAgdHJhbnNmZXJUYWdldDogbnVsbCxcbiAgZmxpcFRhcmdldDogbnVsbCxcbiAgZHRtZk51bWJlcjogbnVsbCxcbiAgLy8gb3BlcmF0aW9uIGVycm9yXG4gIGVycm9yOiBudWxsLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICBpZiAoIWFjdGlvbikgcmV0dXJuIHN0YXRlO1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICBjYXNlIGNhbGxBY3Rpb25zLmVycm9yOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIGVycm9yOiBhY3Rpb24uZXJyb3IsXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLmNsZWFyOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy5yZWNvcmQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiBjb250YWluKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5yZWNvcmRpbmcpID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMucmVjb3JkaW5nKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuc3RvcFJlY29yZDpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IHJlbW92ZShzdGF0ZS5zdGF0dXMsIGNhbGxTdGF0dXMucmVjb3JkaW5nKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMubXV0ZTpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLm11dGVkKSA/XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgOlxuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzLmNvbmNhdChjYWxsU3RhdHVzLm11dGVkKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMudW5tdXRlOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIHN0YXR1czogcmVtb3ZlKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5tdXRlZCksXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLmhvbGQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiBjb250YWluKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5ob2xkaW5nKSA/XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgOlxuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzLmNvbmNhdChjYWxsU3RhdHVzLmhvbGRpbmcpLFxuICAgICAgICBkaXNhYmxlZDogWydwYXJrJywgJ3JlY29yZCddLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy51bmhvbGQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiByZW1vdmUoc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLmhvbGRpbmcpLFxuICAgICAgICBkaXNhYmxlZDogW10sXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLnBhcms6XG4gICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWxsX3BhcmtpbmdcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLnBhcmtlcikgP1xuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzIDpcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cy5jb25jYXQoY2FsbFN0YXR1cy5wYXJrZXIpLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy50cmFuc2ZlcjpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLnRyYW5zZmVyZWQpID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMudHJhbnNmZXJlZCksXG4gICAgICAgIHRyYW5zZmVyVGFnZXQ6IGFjdGlvbi5wYXlsb2FkLm51bWJlcixcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuZmxpcDpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLmZsaXApID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMuZmxpcCksXG4gICAgICAgIGZsaXBUYXJnZXQ6IGFjdGlvbi5wYXlsb2FkLm51bWJlcixcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuZHRtZjpcbiAgICAgIC8vIFRPRE86IGNsYXJpZnkgcGFyayBhY3Rpb25cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IHN0YXRlLnN0YXR1cy5jb25jYXQoY2FsbFN0YXR1cy5wYXJrZWQpLFxuICAgICAgICBkdG1mTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC5udW1iZXIsXG4gICAgICB9KTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1yZWR1Y2VyLmpzXG4gKiovIiwiaW1wb3J0IEVudW0gZnJvbSAnLi4vbGliL2VudW0nO1xuXG5jb25zdCBkZWZpbml0aW9uID0ge1xuICBmbGlwOiAnRkxJUEVEJyxcbiAgcmVjb3JkaW5nOiAnUkVDT1JESU5HJyxcbiAgaG9sZGluZzogJ0hPTERJTkcnLFxuICBtdXRlZDogJ01VVEVEJyxcbiAgcGFya2VkOiAnUEFSS0VEJyxcbiAgdHJhbnNmZXJlZDogJ1RSQU5TRkVSRUQnLFxuICBmb3J3YXJkZWQ6ICdGT1dBUkRFRCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgRW51bShkZWZpbml0aW9uKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2VudW1zL2NhbGwtc3RhdHVzLmpzXG4gKiovIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ3NpcC5qcyddLCBmdW5jdGlvbihTSVApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KFNJUCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3NpcC5qcycpKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzOyAvL0VTNlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuUmluZ0NlbnRyYWwgPSByb290LlJpbmdDZW50cmFsIHx8IHt9O1xuICAgICAgICByb290LlJpbmdDZW50cmFsLldlYlBob25lID0gZmFjdG9yeShyb290LlNJUCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbihTSVApIHtcblxuICAgIHZhciBtZXNzYWdlcyA9IHtcbiAgICAgICAgcGFyazoge3JlcWlkOiAxLCBjb21tYW5kOiAnY2FsbHBhcmsnfSxcbiAgICAgICAgc3RhcnRSZWNvcmQ6IHtyZXFpZDogMiwgY29tbWFuZDogJ3N0YXJ0Y2FsbHJlY29yZCd9LFxuICAgICAgICBzdG9wUmVjb3JkOiB7cmVxaWQ6IDMsIGNvbW1hbmQ6ICdzdG9wY2FsbHJlY29yZCd9LFxuICAgICAgICBmbGlwOiB7cmVxaWQ6IDMsIGNvbW1hbmQ6ICdjYWxsZmxpcCcsIHRhcmdldDogJyd9LFxuICAgICAgICBtb25pdG9yOiB7cmVxaWQ6IDQsIGNvbW1hbmQ6ICdtb25pdG9yJ30sXG4gICAgICAgIGJhcmdlOiB7cmVxaWQ6IDUsIGNvbW1hbmQ6ICdiYXJnZSd9LFxuICAgICAgICB3aGlzcGVyOiB7cmVxaWQ6IDYsIGNvbW1hbmQ6ICd3aGlzcGVyJ30sXG4gICAgICAgIHRha2VvdmVyOiB7cmVxaWQ6IDcsIGNvbW1hbmQ6ICd0YWtlb3Zlcid9XG4gICAgfTtcblxuICAgIHZhciByZXNwb25zZVRpbWVvdXQgPSAxMDAwMDtcblxuICAgIGZ1bmN0aW9uIHV1aWQoKSB7XG4gICAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsYXkobXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChkc3QsIHNyYykge1xuICAgICAgICBzcmMgPSBzcmMgfHwge307XG4gICAgICAgIGRzdCA9IGRzdCB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGRzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1ZGlvSGVscGVyKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLl9lbmFibGVkID0gISFvcHRpb25zLmVuYWJsZWQ7XG4gICAgICAgIHRoaXMuX2luY29taW5nID0gb3B0aW9ucy5pbmNvbWluZyB8fCAnLi4vYXVkaW8vaW5jb21pbmcub2dnJztcbiAgICAgICAgdGhpcy5fb3V0Z29pbmcgPSBvcHRpb25zLm91dGdvaW5nIHx8ICcuLi9hdWRpby9vdXRnb2luZy5vZ2cnO1xuICAgICAgICB0aGlzLl9hdWRpbyA9IHt9O1xuXG4gICAgfVxuXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLl9wbGF5U291bmQgPSBmdW5jdGlvbih1cmwsIHZhbCwgdm9sdW1lKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoIXRoaXMuX2F1ZGlvW3VybF0pIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdID0gbmV3IEF1ZGlvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9bdXJsXS5zcmMgPSB1cmw7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9bdXJsXS5sb29wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnBsYXkoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9bdXJsXS5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLnBsYXlJbmNvbWluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxheVNvdW5kKHRoaXMuX2luY29taW5nLCB2YWwsIDAuNSk7XG4gICAgfTtcblxuICAgIEF1ZGlvSGVscGVyLnByb3RvdHlwZS5wbGF5T3V0Z29pbmcgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlTb3VuZCh0aGlzLl9vdXRnb2luZywgdmFsLCAxKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVnRGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudXVpZF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwS2V5XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcHBOYW1lXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcHBWZXJzaW9uXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hdWRpb0hlbHBlcl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub25TZXNzaW9uXSBmaXJlZCBlYWNoIHRpbWUgVXNlckFnZW50IHN0YXJ0cyB3b3JraW5nIHdpdGggc2Vzc2lvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdlYlBob25lKHJlZ0RhdGEsIG9wdGlvbnMpIHtcblxuICAgICAgICByZWdEYXRhID0gcmVnRGF0YSB8fCB7fTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5zaXBJbmZvID0gcmVnRGF0YS5zaXBJbmZvWzBdIHx8IHJlZ0RhdGEuc2lwSW5mbztcbiAgICAgICAgdGhpcy5zaXBGbGFncyA9IHJlZ0RhdGEuc2lwRmxhZ3M7XG5cbiAgICAgICAgdmFyIGlkID0gb3B0aW9ucy51dWlkIHx8IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdyYy13ZWJQaG9uZS11dWlkJykgfHwgdXVpZCgpOyAvL1RPRE8gTWFrZSBjb25maWd1cmFibGVcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JjLXdlYlBob25lLXV1aWQnLCBpZCk7XG5cbiAgICAgICAgdGhpcy5lbmRwb2ludEhlYWRlciA9ICdQLXJjLWVuZHBvaW50LWlkOiAnICsgaWQ7XG5cbiAgICAgICAgdmFyIGNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgICAgICB1cmk6ICdzaXA6JyArIHRoaXMuc2lwSW5mby51c2VybmFtZSArICdAJyArIHRoaXMuc2lwSW5mby5kb21haW4sXG4gICAgICAgICAgICB3c1NlcnZlcnM6IHRoaXMuc2lwSW5mby5vdXRib3VuZFByb3h5ICYmIHRoaXMuc2lwSW5mby50cmFuc3BvcnRcbiAgICAgICAgICAgICAgICA/IHRoaXMuc2lwSW5mby50cmFuc3BvcnQudG9Mb3dlckNhc2UoKSArICc6Ly8nICsgdGhpcy5zaXBJbmZvLm91dGJvdW5kUHJveHlcbiAgICAgICAgICAgICAgICA6IHRoaXMuc2lwSW5mby53c1NlcnZlcnMsXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uVXNlcjogdGhpcy5zaXBJbmZvLmF1dGhvcml6YXRpb25JZCxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLnNpcEluZm8ucGFzc3dvcmQsXG4gICAgICAgICAgICB0cmFjZVNpcDogdHJ1ZSxcbiAgICAgICAgICAgIHN0dW5TZXJ2ZXJzOiB0aGlzLnNpcEluZm8uc3R1blNlcnZlcnMgfHwgWydzdHVuOjc0LjEyNS4xOTQuMTI3OjE5MzAyJ10sIC8vRklYTUUgSGFyZGNvZGVkP1xuICAgICAgICAgICAgdHVyblNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgbG9nOiB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IG9wdGlvbnMubG9nTGV2ZWwgfHwgMSAvL0ZJWE1FIExPRyBMRVZFTCAzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tYWluOiB0aGlzLnNpcEluZm8uZG9tYWluLFxuICAgICAgICAgICAgYXV0b3N0YXJ0OiB0cnVlLFxuICAgICAgICAgICAgcmVnaXN0ZXI6IHRydWUsXG4gICAgICAgICAgICBpY2VHYXRoZXJpbmdUaW1lb3V0OiB0aGlzLnNpcEluZm8uaWNlR2F0aGVyaW5nVGltZW91dCB8fCAzMDAwXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hcHBLZXkgPSBvcHRpb25zLmFwcEtleTtcbiAgICAgICAgdGhpcy5hcHBOYW1lID0gb3B0aW9ucy5hcHBOYW1lO1xuICAgICAgICB0aGlzLmFwcFZlcnNpb24gPSBvcHRpb25zLmFwcFZlcnNpb247XG4gICAgICAgIHRoaXMudXNlckFnZW50SGVhZGVyID0gJ1JDLVVzZXItQWdlbnQ6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25zLmFwcE5hbWUgPyAob3B0aW9ucy5hcHBOYW1lICsgKG9wdGlvbnMuYXBwVmVyc2lvbiA/ICcvJyArIG9wdGlvbnMuYXBwVmVyc2lvbiA6ICcnKSkgKyAnICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSQ1dFQlBIT05FLycgKyBXZWJQaG9uZS52ZXJzaW9uO1xuXG4gICAgICAgIHRoaXMuY2xpZW50SWRIZWFkZXIgPSAnQ2xpZW50LWlkOicgKyBvcHRpb25zLmFwcEtleTtcblxuICAgICAgICB0aGlzLnVzZXJBZ2VudCA9IG5ldyBTSVAuVUEoY29uZmlndXJhdGlvbikucmVnaXN0ZXIoe1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBbXG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludEhlYWRlcixcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJBZ2VudEhlYWRlcixcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudElkSGVhZGVyXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudXNlckFnZW50LmVuZHBvaW50SGVhZGVyID0gdGhpcy5lbmRwb2ludEhlYWRlcjtcbiAgICAgICAgdGhpcy51c2VyQWdlbnQudXNlckFnZW50SGVhZGVyID0gdGhpcy51c2VyQWdlbnRIZWFkZXI7XG4gICAgICAgIHRoaXMudXNlckFnZW50LmNsaWVudElkSGVhZGVyID0gdGhpcy5jbGllbnRJZEhlYWRlcjtcbiAgICAgICAgdGhpcy51c2VyQWdlbnQuc2lwSW5mbyA9IHRoaXMuc2lwSW5mbztcblxuICAgICAgICB0aGlzLnVzZXJBZ2VudC5fX2ludml0ZSA9IHRoaXMudXNlckFnZW50Lmludml0ZTtcbiAgICAgICAgdGhpcy51c2VyQWdlbnQuaW52aXRlID0gaW52aXRlO1xuXG4gICAgICAgIHRoaXMudXNlckFnZW50Lm9uKCdpbnZpdGUnLCBmdW5jdGlvbihzZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJBZ2VudC5hdWRpb0hlbHBlci5wbGF5SW5jb21pbmcodHJ1ZSk7XG4gICAgICAgICAgICBwYXRjaFNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQuYXVkaW9IZWxwZXIgPSBuZXcgQXVkaW9IZWxwZXIob3B0aW9ucy5hdWRpb0hlbHBlcik7XG5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQub25TZXNzaW9uID0gb3B0aW9ucy5vblNlc3Npb24gfHwgbnVsbDtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgV2ViUGhvbmUudmVyc2lvbiA9ICcwLjMuMSc7XG4gICAgV2ViUGhvbmUudXVpZCA9IHV1aWQ7XG4gICAgV2ViUGhvbmUuZGVsYXkgPSBkZWxheTtcbiAgICBXZWJQaG9uZS5leHRlbmQgPSBleHRlbmQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIGZ1bmN0aW9uIHBhdGNoU2Vzc2lvbihzZXNzaW9uKSB7XG5cbiAgICAgICAgaWYgKHNlc3Npb24uX19wYXRjaGVkKSByZXR1cm4gc2Vzc2lvbjtcblxuICAgICAgICBzZXNzaW9uLl9fcGF0Y2hlZCA9IHRydWU7XG5cbiAgICAgICAgc2Vzc2lvbi5fX3NlbmRSZXF1ZXN0ID0gc2Vzc2lvbi5zZW5kUmVxdWVzdDtcbiAgICAgICAgc2Vzc2lvbi5fX3JlY2VpdmVSZXF1ZXN0ID0gc2Vzc2lvbi5yZWNlaXZlUmVxdWVzdDtcbiAgICAgICAgc2Vzc2lvbi5fX3JlY2VpdmVJbnZpdGVSZXNwb25zZSA9IHNlc3Npb24ucmVjZWl2ZUludml0ZVJlc3BvbnNlO1xuICAgICAgICBzZXNzaW9uLl9fcmVjZWl2ZVJlc3BvbnNlID0gc2Vzc2lvbi5yZWNlaXZlUmVzcG9uc2U7XG4gICAgICAgIHNlc3Npb24uX19hY2NlcHQgPSBzZXNzaW9uLmFjY2VwdDtcbiAgICAgICAgc2Vzc2lvbi5fX2hvbGQgPSBzZXNzaW9uLmhvbGQ7XG4gICAgICAgIHNlc3Npb24uX191bmhvbGQgPSBzZXNzaW9uLnVuaG9sZDtcbiAgICAgICAgc2Vzc2lvbi5fX2R0bWYgPSBzZXNzaW9uLmR0bWY7XG5cbiAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdCA9IHNlbmRSZXF1ZXN0O1xuICAgICAgICBzZXNzaW9uLnJlY2VpdmVSZXF1ZXN0ID0gcmVjZWl2ZVJlcXVlc3Q7XG4gICAgICAgIHNlc3Npb24ucmVjZWl2ZUludml0ZVJlc3BvbnNlID0gcmVjZWl2ZUludml0ZVJlc3BvbnNlO1xuICAgICAgICBzZXNzaW9uLnJlY2VpdmVSZXNwb25zZSA9IHJlY2VpdmVSZXNwb25zZTtcbiAgICAgICAgc2Vzc2lvbi5hY2NlcHQgPSBhY2NlcHQ7XG4gICAgICAgIHNlc3Npb24uaG9sZCA9IGhvbGQ7XG4gICAgICAgIHNlc3Npb24udW5ob2xkID0gdW5ob2xkO1xuICAgICAgICBzZXNzaW9uLmR0bWYgPSBkdG1mO1xuXG4gICAgICAgIHNlc3Npb24uYmxpbmRUcmFuc2ZlciA9IGJsaW5kVHJhbnNmZXI7XG4gICAgICAgIHNlc3Npb24udHJhbnNmZXIgPSB0cmFuc2ZlcjtcbiAgICAgICAgc2Vzc2lvbi5wYXJrID0gcGFyaztcbiAgICAgICAgc2Vzc2lvbi5mb3J3YXJkID0gZm9yd2FyZDtcbiAgICAgICAgc2Vzc2lvbi5zdGFydFJlY29yZCA9IHN0YXJ0UmVjb3JkO1xuICAgICAgICBzZXNzaW9uLnN0b3BSZWNvcmQgPSBzdG9wUmVjb3JkO1xuICAgICAgICBzZXNzaW9uLmZsaXAgPSBmbGlwO1xuXG4gICAgICAgIHNlc3Npb24ub24oJ3JlcGxhY2VkJywgcGF0Y2hTZXNzaW9uKTtcbiAgICAgICAgLy8gc2Vzc2lvbi5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG5cbiAgICAgICAgLy8gQXVkaW9cbiAgICAgICAgc2Vzc2lvbi5vbignYWNjZXB0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ub24oJ3JlamVjdGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm9uKCdieWUnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ub24oJ3Rlcm1pbmF0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ub24oJ2NhbmNlbCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5vbignZmFpbGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm9uKCdyZXBsYWNlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oJ2ljZUNvbm5lY3Rpb25Db21wbGV0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ubWVkaWFIYW5kbGVyLm9uKCdpY2VDb25uZWN0aW9uRmFpbGVkJywgc3RvcFBsYXlpbmcpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHN0b3BQbGF5aW5nKCkge1xuICAgICAgICAgICAgc2Vzc2lvbi51YS5hdWRpb0hlbHBlci5wbGF5T3V0Z29pbmcoZmFsc2UpO1xuICAgICAgICAgICAgc2Vzc2lvbi51YS5hdWRpb0hlbHBlci5wbGF5SW5jb21pbmcoZmFsc2UpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignYWNjZXB0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdyZWplY3RlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ2J5ZScsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ3Rlcm1pbmF0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdjYW5jZWwnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdmYWlsZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdyZXBsYWNlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ubWVkaWFIYW5kbGVyLnJlbW92ZUxpc3RlbmVyKCdpY2VDb25uZWN0aW9uQ29tcGxldGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5tZWRpYUhhbmRsZXIucmVtb3ZlTGlzdGVuZXIoJ2ljZUNvbm5lY3Rpb25GYWlsZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Vzc2lvbi51YS5vblNlc3Npb24pIHNlc3Npb24udWEub25TZXNzaW9uKHNlc3Npb24pO1xuXG4gICAgICAgIHJldHVybiBzZXNzaW9uO1xuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29tbWFuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlbmRSZWNlaXZlKHNlc3Npb24sIGNvbW1hbmQsIG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBleHRlbmQoY29tbWFuZCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIGNzZXEgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdChTSVAuQy5JTkZPLCB7XG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBjb21tYW5kXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi51YS51c2VyQWdlbnRIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24udWEuZW5kcG9pbnRIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24udWEuY2xpZW50SWRIZWFkZXJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NlcSA9IHJlc3BvbnNlLmNzZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25JbmZvID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5jc2VxID09PSBjc2VxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSByZXF1ZXN0ICYmIHJlcXVlc3QuYm9keSB8fCAne30nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmoucmVzcG9uc2UgJiYgb2JqLnJlc3BvbnNlLmNvbW1hbmQgPT09IGNvbW1hbmQuY29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5yZXNwb25zZS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnJlc3BvbnNlLnJlc3VsdC5jb2RlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUob2JqLnJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChvYmoucmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ1JDX1NJUF9JTkZPJywgb25JbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTsgLy9GSVhNRSBXaGF0IHRvIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0OiBubyByZXBseScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdSQ19TSVBfSU5GTycsIG9uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZXNwb25zZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5vbignUkNfU0lQX0lORk8nLCBvbkluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGhlIElORk8gcmVzcG9uc2Ugc3RhdHVzIGNvZGUgaXM6ICcgKyByZXNwb25zZS5zdGF0dXNfY29kZSArICcgKHdhaXRpbmcgZm9yIDIwMCknKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgZnVuY3Rpb24gc2VuZFJlcXVlc3QodHlwZSwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0eXBlID09IFNJUC5DLlBSQUNLKSB7XG4gICAgICAgICAgICB0eXBlID0gU0lQLkMuQUNLO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fc2VuZFJlcXVlc3QodHlwZSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGVhY2ggdGltZSBhIHByb3Zpc2lvbmFsICgxMDAtMTk5KSByZXNwb25zZSBpcyByZWNlaXZlZC5cbiAgICAgKiBFYXJseSBtZWRpYSBpcyBzdXBwb3J0ZWQgYnkgU0lQLmpzIGxpYnJhcnlcbiAgICAgKiBCdXQgaW4gY2FzZSBpdCBpcyBzZW50IHdpdGhvdXQgMTAwcmVsIHN1cHBvcnQgd2UgcGxheSBpdCBtYW51YWxseVxuICAgICAqIFNUQVRVU19FQVJMWV9NRURJQSA9PT0gMTEsIGl0IHdpbGwgYmUgc2V0IGJ5IFNJUC5qcyBpZiAxMDByZWwgaXMgc3VwcG9ydGVkXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwNzIzODhcbiAgICAgKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtmdW5jaXRvbn0gY2JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXRjaDEwMHJlbChzZXNzaW9uLCByZXNwb25zZSwgY2IpIHtcblxuICAgICAgICAvL0Vhcmx5IG1lZGlhIGlzIHN1cHBvcnRlZCBieSBTSVAuanMgbGlicmFyeVxuICAgICAgICAvL0J1dCBpbiBjYXNlIGl0IGlzIHNlbnQgd2l0aG91dCAxMDByZWwgc3VwcG9ydCB3ZSBwbGF5IGl0IG1hbnVhbGx5XG4gICAgICAgIC8vU1RBVFVTX0VBUkxZX01FRElBID09PSAxMSwgaXQgd2lsbCBiZSBzZXQgYnkgU0lQLmpzIGlmIDEwMHJlbCBpcyBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzICE9PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19FQVJMWV9NRURJQSAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA9PT0gMTgzICYmIHR5cGVvZihyZXNwb25zZS5ib2R5KSA9PT0gJ3N0cmluZycgJiYgcmVzcG9uc2UuYm9keS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UuaGFzSGVhZGVyKCdyZXF1aXJlJykpIHJlc3BvbnNlLnNldEhlYWRlcigncmVxdWlyZScsICcxMDByZWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYi5jYWxsKHNlc3Npb24sIHJlc3BvbnNlKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnZpdGVSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcGF0Y2gxMDByZWwodGhpcywgcmVzcG9uc2UsIHRoaXMuX19yZWNlaXZlSW52aXRlUmVzcG9uc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY2VpdmVSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcGF0Y2gxMDByZWwodGhpcywgcmVzcG9uc2UsIHRoaXMuX19yZWNlaXZlUmVzcG9uc2UpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRSZWNvcmQoc2Vzc2lvbiwgZmxhZykge1xuXG4gICAgICAgIHZhciBtZXNzYWdlID0gISFmbGFnXG4gICAgICAgICAgICA/IG1lc3NhZ2VzLnN0YXJ0UmVjb3JkXG4gICAgICAgICAgICA6IG1lc3NhZ2VzLnN0b3BSZWNvcmQ7XG5cbiAgICAgICAgaWYgKChzZXNzaW9uLl9fb25SZWNvcmQgJiYgIWZsYWcpIHx8ICghc2Vzc2lvbi5fX29uUmVjb3JkICYmIGZsYWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VuZFJlY2VpdmUoc2Vzc2lvbiwgbWVzc2FnZSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24uX19vblJlY29yZCA9ICEhZmxhZztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRIb2xkKHNlc3Npb24sIGZsYWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRlZDogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkOiByZWplY3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZmxhZykge1xuICAgICAgICAgICAgICAgIHNlc3Npb24uX19ob2xkKG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLl9fdW5ob2xkKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5VQX1cbiAgICAgKiBAcGFyYW0gbnVtYmVyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTSVAuU2Vzc2lvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZpdGUobnVtYmVyLCBvcHRpb25zKSB7XG5cbiAgICAgICAgdmFyIHVhID0gdGhpcztcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXTtcblxuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKHVhLnVzZXJBZ2VudEhlYWRlcik7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2godWEuZW5kcG9pbnRIZWFkZXIpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKHVhLmNsaWVudElkSGVhZGVyKTtcblxuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdQLUFzc2VydGVkLUlkZW50aXR5OiBzaXA6JyArIChvcHRpb25zLmZyb21OdW1iZXIgfHwgdWEuc2lwSW5mby51c2VybmFtZSkgKyAnQCcgKyB1YS5zaXBJbmZvLmRvbWFpbik7IC8vRklYTUUgUGhvbmUgTnVtYmVyXG5cbiAgICAgICAgLy9GSVhNRSBCYWNrZW5kIHNob3VsZCBrbm93IGl0IGFscmVhZHlcbiAgICAgICAgaWYgKG9wdGlvbnMuaG9tZUNvdW50cnlJZCkgeyBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdQLXJjLWNvdW50cnktaWQ6ICcgKyBvcHRpb25zLmhvbWVDb3VudHJ5SWQpOyB9XG5cbiAgICAgICAgb3B0aW9ucy5tZWRpYSA9IG9wdGlvbnMubWVkaWEgfHwge307XG4gICAgICAgIG9wdGlvbnMubWVkaWEuY29uc3RyYWludHMgPSBvcHRpb25zLm1lZGlhLmNvbnN0cmFpbnRzIHx8IHthdWRpbzogdHJ1ZSwgdmlkZW86IGZhbHNlfTtcblxuICAgICAgICBvcHRpb25zLlJUQ0NvbnN0cmFpbnRzID0gb3B0aW9ucy5SVENDb25zdHJhaW50cyB8fCB7b3B0aW9uYWw6IFt7RHRsc1NydHBLZXlBZ3JlZW1lbnQ6ICd0cnVlJ31dfTtcblxuICAgICAgICB1YS5hdWRpb0hlbHBlci5wbGF5T3V0Z29pbmcodHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGNoU2Vzc2lvbih1YS5fX2ludml0ZShudW1iZXIsIG9wdGlvbnMpKTtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEBwYXJhbSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWNlaXZlUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcztcbiAgICAgICAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBTSVAuQy5JTkZPOlxuICAgICAgICAgICAgICAgIHNlc3Npb24uZW1pdCgnUkNfU0lQX0lORk8nLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAvL1NJUC5qcyBkb2VzIG5vdCBzdXBwb3J0IGFwcGxpY2F0aW9uL2pzb24gY29udGVudCB0eXBlLCBzbyB3ZSBtb25rZXkgb3ZlcnJpZGUgaXRzIGJlaGF2aW91ciBpbiB0aGlzIGNhc2VcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX0NPTkZJUk1FRCB8fCBzZXNzaW9uLnN0YXR1cyA9PT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlLm1hdGNoKC9eYXBwbGljYXRpb25cXC9qc29uL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vUmVmcmVzaCBpbnZpdGUgc2hvdWxkIG5vdCBiZSByZWplY3RlZCB3aXRoIDQ4OFxuICAgICAgICAgICAgY2FzZSBTSVAuQy5JTlZJVEU6XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY2FsbF9pZCAmJiBzZXNzaW9uLmRpYWxvZyAmJiBzZXNzaW9uLmRpYWxvZy5pZCAmJiByZXF1ZXN0LmNhbGxfaWQgPT0gc2Vzc2lvbi5kaWFsb2cuaWQuY2FsbF9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBjaGVjayB0aGF0IFNEUCBkaWQgbm90IGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIubG9nKCdyZS1JTlZJVEUgcmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbFNEUCA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLnBlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb24uc2RwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBseSgyMDAsIG51bGwsIFsnQ29udGFjdDogJyArIHNlc3Npb24uY29udGFjdF0sIGxvY2FsU0RQLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnN0YXR1cyA9IFNJUC5TZXNzaW9uLkMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnNldEludml0ZTJ4eFRpbWVyKHJlcXVlc3QsIGxvY2FsU0RQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnNldEFDS1RpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vZWxzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggNDg4IGJ5IFNJUC5qc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vV2UgbmVlZCB0byBhbmFsaXplIE5PVElGWSBtZXNzYWdlcyBzb21ldGltZXMsIHNvIHdlIGZpcmUgYW4gZXZlbnRcbiAgICAgICAgICAgIGNhc2UgU0lQLkMuTk9USUZZOlxuICAgICAgICAgICAgICAgIHNlc3Npb24uZW1pdCgnUkNfU0lQX05PVElGWScsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXNzaW9uLl9fcmVjZWl2ZVJlcXVlc3QuYXBwbHkoc2Vzc2lvbiwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWNjZXB0KG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXM7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW107XG5cbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChzZXNzaW9uLnVhLnVzZXJBZ2VudEhlYWRlcik7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goc2Vzc2lvbi51YS5lbmRwb2ludEhlYWRlcik7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goc2Vzc2lvbi51YS5jbGllbnRJZEhlYWRlcik7XG5cbiAgICAgICAgb3B0aW9ucy5tZWRpYSA9IG9wdGlvbnMubWVkaWEgfHwge307XG4gICAgICAgIG9wdGlvbnMubWVkaWEuY29uc3RyYWludHMgPSBvcHRpb25zLm1lZGlhLmNvbnN0cmFpbnRzIHx8IHthdWRpbzogdHJ1ZSwgdmlkZW86IGZhbHNlfTtcblxuICAgICAgICBvcHRpb25zLlJUQ0NvbnN0cmFpbnRzID0gb3B0aW9ucy5SVENDb25zdHJhaW50cyB8fCB7b3B0aW9uYWw6IFt7RHRsc1NydHBLZXlBZ3JlZW1lbnQ6ICd0cnVlJ31dfTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uQW5zd2VyZWQoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdmYWlsZWQnLCBvbkZhaWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkZhaWwoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdhY2NlcHRlZCcsIG9uQW5zd2VyZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1RPRE8gTW9yZSBldmVudHM/XG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2FjY2VwdGVkJywgb25BbnN3ZXJlZCk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2ZhaWxlZCcsIG9uRmFpbCk7XG5cbiAgICAgICAgICAgIHNlc3Npb24uX19hY2NlcHQob3B0aW9ucyk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkdG1mXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkdG1mKGR0bWYsIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcztcbiAgICAgICAgZHVyYXRpb24gPSBwYXJzZUludChkdXJhdGlvbikgfHwgMTAwMDtcbiAgICAgICAgdmFyIHBlZXIgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5wZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHN0cmVhbSA9IHNlc3Npb24uZ2V0TG9jYWxTdHJlYW1zKClbMF07XG4gICAgICAgIHZhciBkdG1mU2VuZGVyID0gcGVlci5jcmVhdGVEVE1GU2VuZGVyKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdKTtcbiAgICAgICAgaWYgKGR0bWZTZW5kZXIgIT09IHVuZGVmaW5lZCAmJiBkdG1mU2VuZGVyLmNhbkluc2VydERUTUYpIHtcbiAgICAgICAgICAgIHJldHVybiBkdG1mU2VuZGVyLmluc2VydERUTUYoZHRtZiwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VuZCBEVE1GIGZhaWxlZDogJyArICghZHRtZlNlbmRlciA/ICdubyBzZW5kZXInIDogKCFkdG1mU2VuZGVyLmNhbkluc2VydERUTUYgPyAnY2FuXFwndCBpbnNlcnQgRFRNRicgOiAnVW5rbm93bicpKSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhvbGQoKSB7XG4gICAgICAgIHJldHVybiBzZXRIb2xkKHRoaXMsIHRydWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmhvbGQoKSB7XG4gICAgICAgIHJldHVybiBzZXRIb2xkKHRoaXMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmxpbmRUcmFuc2Zlcih0YXJnZXQsIG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXM7XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXTtcbiAgICAgICAgdmFyIG9yaWdpbmFsVGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vQmxpbmQgVHJhbnNmZXIgaXMgdGFrZW4gZnJvbSBTSVAuanMgc291cmNlXG5cbiAgICAgICAgICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgIT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcihzZXNzaW9uLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZVRhcmdldCBhbGxvd3MgaW5zdGFuY2VzIG9mIFNJUC5VUkkgdG8gcGFzcyB0aHJvdWdoIHVuYWx0ZXJlZCxcbiAgICAgICAgICAgIC8vIHNvIHRyeSB0byBtYWtlIG9uZSBhaGVhZCBvZiB0aW1lXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IFNJUC5HcmFtbWFyLnBhcnNlKHRhcmdldCwgJ1JlZmVyX1RvJykudXJpIHx8IHRhcmdldDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci5kZWJ1ZyhcIi5yZWZlcigpIGNhbm5vdCBwYXJzZSBSZWZlcl9UbyBmcm9tXCIsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIuZGVidWcoXCIuLi5mYWxsaW5nIHRocm91Z2ggdG8gbm9ybWFsaXplVGFyZ2V0KClcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRhcmdldCB2YWxpZGl0eVxuICAgICAgICAgICAgdGFyZ2V0ID0gc2Vzc2lvbi51YS5ub3JtYWxpemVUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0YXJnZXQ6ICcgKyBvcmlnaW5hbFRhcmdldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnICsgc2Vzc2lvbi5jb250YWN0KTtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJyArIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZWZlci1UbzogJyArIHRhcmdldCk7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChzZXNzaW9uLnVhLnVzZXJBZ2VudEhlYWRlcik7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChzZXNzaW9uLnVhLmVuZHBvaW50SGVhZGVyKTtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKHNlc3Npb24udWEuY2xpZW50SWRIZWFkZXIpO1xuXG4gICAgICAgICAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICBzZXNzaW9uLnNlbmRSZXF1ZXN0KFNJUC5DLlJFRkVSLCB7XG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDIwMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxJZCA9IHJlc3BvbnNlLmNhbGxfaWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbk5vdGlmeSA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5jYWxsX2lkID09PSBjYWxsSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSByZXF1ZXN0ICYmIHJlcXVlc3QuYm9keSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIC8xWzAtOV17Mn0vLnRlc3QoYm9keSk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAvMlswLTldezJ9Ly50ZXN0KGJvZHkpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24udGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ1JDX1NJUF9OT1RJRlknLCBvbk5vdGlmeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0OiBubyByZXBseScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdSQ19TSVBfTk9USUZZJywgb25Ob3RpZnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVzcG9uc2VUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ub24oJ1JDX1NJUF9OT1RJRlknLCBvbk5vdGlmeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgaXM6ICcgKyByZXNwb25zZS5zdGF0dXNfY29kZSArICcgKHdhaXRpbmcgZm9yIDIwMiknKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZmVyKHRhcmdldCwgb3B0aW9ucykge1xuXG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKHNlc3Npb24uaXNPbkhvbGQoKSA/IFByb21pc2UucmVzb2x2ZShudWxsKSA6IHNlc3Npb24uaG9sZCgpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiBkZWxheSgzMDApOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24uYmxpbmRUcmFuc2Zlcih0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFjY2VwdE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3RyYW5zZmVyT3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcndhcmQodGFyZ2V0LCBhY2NlcHRPcHRpb25zLCB0cmFuc2Zlck9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBudWxsLFxuICAgICAgICAgICAgc2Vzc2lvbiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHNlc3Npb24uYWNjZXB0KGFjY2VwdE9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0YXR1cyA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLm11dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNlc3Npb24udHJhbnNmZXIodGFyZ2V0LCB0cmFuc2Zlck9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCA3MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydFJlY29yZCgpIHtcbiAgICAgICAgcmV0dXJuIHNldFJlY29yZCh0aGlzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0b3BSZWNvcmQoKSB7XG4gICAgICAgIHJldHVybiBzZXRSZWNvcmQodGhpcywgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsaXAodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBzZW5kUmVjZWl2ZSh0aGlzLCBtZXNzYWdlcy5mbGlwLCB7dGFyZ2V0OiB0YXJnZXR9KTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcmsoKSB7XG4gICAgICAgIHJldHVybiBzZW5kUmVjZWl2ZSh0aGlzLCBtZXNzYWdlcy5wYXJrKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIHJldHVybiBXZWJQaG9uZTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JpbmdjZW50cmFsLXdlYi1waG9uZS9zcmMvcmluZ2NlbnRyYWwtd2ViLXBob25lLmpzXG4gKiogbW9kdWxlIGlkID0gMjEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9TSVAnKShyZXF1aXJlKCcuL2Vudmlyb25tZW50JykpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbmFtZSBTSVBcbiAqIEBuYW1lc3BhY2VcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG5cbnZhciBwa2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcblxudmFyIFNJUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7XG4gIHZlcnNpb246IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBwa2cudmVyc2lvbjsgfVxuICB9LFxuICBuYW1lOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gcGtnLnRpdGxlOyB9XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL1V0aWxzJykoU0lQLCBlbnZpcm9ubWVudCk7XG5TSVAuTG9nZ2VyRmFjdG9yeSA9IHJlcXVpcmUoJy4vTG9nZ2VyRmFjdG9yeScpKGVudmlyb25tZW50LmNvbnNvbGUpO1xuU0lQLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vRXZlbnRFbWl0dGVyJykoZW52aXJvbm1lbnQuY29uc29sZSk7XG5TSVAuQyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJykoU0lQLm5hbWUsIFNJUC52ZXJzaW9uKTtcblNJUC5FeGNlcHRpb25zID0gcmVxdWlyZSgnLi9FeGNlcHRpb25zJyk7XG5TSVAuVGltZXJzID0gcmVxdWlyZSgnLi9UaW1lcnMnKShlbnZpcm9ubWVudC50aW1lcnMpO1xuU0lQLlRyYW5zcG9ydCA9IGVudmlyb25tZW50LlRyYW5zcG9ydChTSVAsIGVudmlyb25tZW50LldlYlNvY2tldCk7XG5yZXF1aXJlKCcuL1BhcnNlcicpKFNJUCk7XG5yZXF1aXJlKCcuL1NJUE1lc3NhZ2UnKShTSVApO1xucmVxdWlyZSgnLi9VUkknKShTSVApO1xucmVxdWlyZSgnLi9OYW1lQWRkckhlYWRlcicpKFNJUCk7XG5yZXF1aXJlKCcuL1RyYW5zYWN0aW9ucycpKFNJUCk7XG5yZXF1aXJlKCcuL0RpYWxvZ3MnKShTSVApO1xucmVxdWlyZSgnLi9SZXF1ZXN0U2VuZGVyJykoU0lQKTtcbnJlcXVpcmUoJy4vUmVnaXN0ZXJDb250ZXh0JykoU0lQKTtcblNJUC5NZWRpYUhhbmRsZXIgPSByZXF1aXJlKCcuL01lZGlhSGFuZGxlcicpKFNJUC5FdmVudEVtaXR0ZXIpO1xucmVxdWlyZSgnLi9DbGllbnRDb250ZXh0JykoU0lQKTtcbnJlcXVpcmUoJy4vU2VydmVyQ29udGV4dCcpKFNJUCk7XG5yZXF1aXJlKCcuL1Nlc3Npb24nKShTSVAsIGVudmlyb25tZW50KTtcbnJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJykoU0lQKTtcblNJUC5XZWJSVEMgPSByZXF1aXJlKCcuL1dlYlJUQycpKFNJUCwgZW52aXJvbm1lbnQpO1xucmVxdWlyZSgnLi9VQScpKFNJUCwgZW52aXJvbm1lbnQpO1xuU0lQLkhhY2tzID0gcmVxdWlyZSgnLi9IYWNrcycpKFNJUCk7XG5yZXF1aXJlKCcuL1Nhbml0eUNoZWNrJykoU0lQKTtcblNJUC5EaWdlc3RBdXRoZW50aWNhdGlvbiA9IHJlcXVpcmUoJy4vRGlnZXN0QXV0aGVudGljYXRpb24nKShTSVAuVXRpbHMpO1xuU0lQLkdyYW1tYXIgPSByZXF1aXJlKCcuL0dyYW1tYXInKShTSVApO1xuXG5yZXR1cm4gU0lQO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvU0lQLmpzXG4gKiogbW9kdWxlIGlkID0gMjEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJfYXJnc1wiOiBbXG5cdFx0W1xuXHRcdFx0XCJzaXAuanNAMC43LjVcIixcblx0XHRcdFwiL1VzZXJzL2hvd2FyZC56aGFuZy9TaXRlcy9yaW5nY2VudHJhbC1qcy1pbnRlZ3JhdGlvbi1jb21tb25zL25vZGVfbW9kdWxlcy9yaW5nY2VudHJhbC13ZWItcGhvbmVcIlxuXHRcdF1cblx0XSxcblx0XCJfZnJvbVwiOiBcInNpcC5qc0AwLjcuNVwiLFxuXHRcIl9pZFwiOiBcInNpcC5qc0AwLjcuNVwiLFxuXHRcIl9pbkNhY2hlXCI6IHRydWUsXG5cdFwiX2luc3RhbGxhYmxlXCI6IHRydWUsXG5cdFwiX2xvY2F0aW9uXCI6IFwiL3NpcC5qc1wiLFxuXHRcIl9ub2RlVmVyc2lvblwiOiBcIjQuNC4zXCIsXG5cdFwiX25wbU9wZXJhdGlvbmFsSW50ZXJuYWxcIjoge1xuXHRcdFwiaG9zdFwiOiBcInBhY2thZ2VzLTEyLXdlc3QuaW50ZXJuYWwubnBtanMuY29tXCIsXG5cdFx0XCJ0bXBcIjogXCJ0bXAvc2lwLmpzLTAuNy41LnRnel8xNDYxNTk0NDE4NjkwXzAuNTgzOTkzMzEyNDM3MDg3M1wiXG5cdH0sXG5cdFwiX25wbVVzZXJcIjoge1xuXHRcdFwiZW1haWxcIjogXCIxMjEyanRyYWNldXJAZ21haWwuY29tXCIsXG5cdFx0XCJuYW1lXCI6IFwiam9zZXBoZnJhemllclwiXG5cdH0sXG5cdFwiX25wbVZlcnNpb25cIjogXCIyLjE1LjFcIixcblx0XCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuXHRcIl9yZXF1ZXN0ZWRcIjoge1xuXHRcdFwibmFtZVwiOiBcInNpcC5qc1wiLFxuXHRcdFwicmF3XCI6IFwic2lwLmpzQDAuNy41XCIsXG5cdFx0XCJyYXdTcGVjXCI6IFwiMC43LjVcIixcblx0XHRcInNjb3BlXCI6IG51bGwsXG5cdFx0XCJzcGVjXCI6IFwiMC43LjVcIixcblx0XHRcInR5cGVcIjogXCJ2ZXJzaW9uXCJcblx0fSxcblx0XCJfcmVxdWlyZWRCeVwiOiBbXG5cdFx0XCIvcmluZ2NlbnRyYWwtd2ViLXBob25lXCJcblx0XSxcblx0XCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9zaXAuanMvLS9zaXAuanMtMC43LjUudGd6XCIsXG5cdFwiX3NoYXN1bVwiOiBcIjg2YWNlNzA1MTU5NGY5MWI0NTUxYmRiODEyMGExNmM0NDk2MmQzYTJcIixcblx0XCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuXHRcIl9zcGVjXCI6IFwic2lwLmpzQDAuNy41XCIsXG5cdFwiX3doZXJlXCI6IFwiL1VzZXJzL2hvd2FyZC56aGFuZy9TaXRlcy9yaW5nY2VudHJhbC1qcy1pbnRlZ3JhdGlvbi1jb21tb25zL25vZGVfbW9kdWxlcy9yaW5nY2VudHJhbC13ZWItcGhvbmVcIixcblx0XCJhdXRob3JcIjoge1xuXHRcdFwiZW1haWxcIjogXCJkZXZlbG9wZXJAb25zaXAuY29tXCIsXG5cdFx0XCJuYW1lXCI6IFwiT25TSVBcIixcblx0XHRcInVybFwiOiBcImh0dHA6Ly9zaXBqcy5jb20vYXV0aG9ycy9cIlxuXHR9LFxuXHRcImJyb3dzZXJcIjoge1xuXHRcdFwiLi9zcmMvZW52aXJvbm1lbnQuanNcIjogXCIuL3NyYy9lbnZpcm9ubWVudF9icm93c2VyLmpzXCJcblx0fSxcblx0XCJidWdzXCI6IHtcblx0XHRcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbnNpcC9TSVAuanMvaXNzdWVzXCJcblx0fSxcblx0XCJjb250cmlidXRvcnNcIjogW1xuXHRcdHtcblx0XHRcdFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL29uc2lwL1NJUC5qcy9ibG9iL21hc3Rlci9USEFOS1MubWRcIlxuXHRcdH1cblx0XSxcblx0XCJkZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwicHJvbWlzY3VvdXNcIjogXCJeMC42LjBcIixcblx0XHRcIndzXCI6IFwiXjAuNi40XCJcblx0fSxcblx0XCJkZXNjcmlwdGlvblwiOiBcIkEgc2ltcGxlLCBpbnR1aXRpdmUsIGFuZCBwb3dlcmZ1bCBKYXZhU2NyaXB0IHNpZ25hbGluZyBsaWJyYXJ5XCIsXG5cdFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcImJlZWZ5XCI6IFwiXjIuMS41XCIsXG5cdFx0XCJicm93c2VyaWZ5XCI6IFwiXjQuMS44XCIsXG5cdFx0XCJncnVudFwiOiBcIn4wLjQuMFwiLFxuXHRcdFwiZ3J1bnQtYnJvd3NlcmlmeVwiOiBcIl40LjAuMVwiLFxuXHRcdFwiZ3J1bnQtY2xpXCI6IFwifjAuMS42XCIsXG5cdFx0XCJncnVudC1jb250cmliLWNvcHlcIjogXCJeMC41LjBcIixcblx0XHRcImdydW50LWNvbnRyaWItamFzbWluZVwiOiBcIl4wLjkuMlwiLFxuXHRcdFwiZ3J1bnQtY29udHJpYi1qc2hpbnRcIjogXCI+MC41LjBcIixcblx0XHRcImdydW50LWNvbnRyaWItdWdsaWZ5XCI6IFwifjAuMi4wXCIsXG5cdFx0XCJncnVudC1wZWdcIjogXCJ+MS4zLjFcIixcblx0XHRcImdydW50LXRyaW10cmFpbGluZ3NwYWNlc1wiOiBcIl4wLjQuMFwiLFxuXHRcdFwicGVnanNcIjogXCJeMC44LjBcIlxuXHR9LFxuXHRcImRpcmVjdG9yaWVzXCI6IHt9LFxuXHRcImRpc3RcIjoge1xuXHRcdFwic2hhc3VtXCI6IFwiODZhY2U3MDUxNTk0ZjkxYjQ1NTFiZGI4MTIwYTE2YzQ0OTYyZDNhMlwiLFxuXHRcdFwidGFyYmFsbFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3NpcC5qcy8tL3NpcC5qcy0wLjcuNS50Z3pcIlxuXHR9LFxuXHRcImVuZ2luZXNcIjoge1xuXHRcdFwibm9kZVwiOiBcIj49MC44XCJcblx0fSxcblx0XCJnaXRIZWFkXCI6IFwiYmFlNDRiZDAzNTlmNGQ3MGRlZDMwOWEzMjM2MWYwNGEwNGU3OGQ2ZVwiLFxuXHRcImhvbWVwYWdlXCI6IFwiaHR0cDovL3NpcGpzLmNvbVwiLFxuXHRcImtleXdvcmRzXCI6IFtcblx0XHRcInNpcFwiLFxuXHRcdFwid2Vic29ja2V0XCIsXG5cdFx0XCJ3ZWJydGNcIixcblx0XHRcImxpYnJhcnlcIixcblx0XHRcImphdmFzY3JpcHRcIlxuXHRdLFxuXHRcImxpY2Vuc2VcIjogXCJNSVRcIixcblx0XCJtYWluXCI6IFwic3JjL2luZGV4LmpzXCIsXG5cdFwibWFpbnRhaW5lcnNcIjogW1xuXHRcdHtcblx0XHRcdFwiZW1haWxcIjogXCJlcmljLmdyZWVuQG9uc2lwLmNvbVwiLFxuXHRcdFx0XCJuYW1lXCI6IFwiZWdyZWVuX29uc2lwXCJcblx0XHR9LFxuXHRcdHtcblx0XHRcdFwiZW1haWxcIjogXCJqYW1lc0BvbnNpcC5jb21cIixcblx0XHRcdFwibmFtZVwiOiBcImphbWVzLWNyaXNjdW9sb1wiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcImVtYWlsXCI6IFwiMTIxMmp0cmFjZXVyQGdtYWlsLmNvbVwiLFxuXHRcdFx0XCJuYW1lXCI6IFwiam9zZXBoZnJhemllclwiXG5cdFx0fVxuXHRdLFxuXHRcIm5hbWVcIjogXCJzaXAuanNcIixcblx0XCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJwcm9taXNjdW91c1wiOiBcIl4wLjYuMFwiXG5cdH0sXG5cdFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuXHRcInJlcG9zaXRvcnlcIjoge1xuXHRcdFwidHlwZVwiOiBcImdpdFwiLFxuXHRcdFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9vbnNpcC9TSVAuanMuZ2l0XCJcblx0fSxcblx0XCJzY3JpcHRzXCI6IHtcblx0XHRcImJ1aWxkXCI6IFwiZ3J1bnQgYnVpbGRcIixcblx0XHRcInByZXB1Ymxpc2hcIjogXCJjZCBzcmMvR3JhbW1hciAmJiBta2RpciAtcCBkaXN0ICYmIHBlZ2pzIC0tZXh0cmEtb3B0aW9ucy1maWxlIHBlZy5qc29uIHNyYy9HcmFtbWFyLnBlZ2pzIGRpc3QvR3JhbW1hci5qc1wiLFxuXHRcdFwicmVwbFwiOiBcImJlZWZ5IHRlc3QvcmVwbC5qcyAtLW9wZW5cIixcblx0XHRcInRlc3RcIjogXCJncnVudCB0cmF2aXMgLS12ZXJib3NlXCJcblx0fSxcblx0XCJ0aXRsZVwiOiBcIlNJUC5qc1wiLFxuXHRcInZlcnNpb25cIjogXCIwLjcuNVwiXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9wYWNrYWdlLmpzb25cbiAqKiBtb2R1bGUgaWQgPSAyMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQLCBlbnZpcm9ubWVudCkge1xudmFyIFV0aWxzO1xuXG5VdGlscz0ge1xuXG4gIFByb21pc2U6IGVudmlyb25tZW50LlByb21pc2UsXG5cbiAgZGVmZXI6IGZ1bmN0aW9uIGRlZmVyICgpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSB7fTtcbiAgICBkZWZlcnJlZC5wcm9taXNlID0gbmV3IFV0aWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9LFxuXG4gIHByb21pc2lmeTogZnVuY3Rpb24gcHJvbWlzaWZ5IChvYmplY3QsIG1ldGhvZE5hbWUsIGNhbGxiYWNrc0ZpcnN0KSB7XG4gICAgdmFyIG9sZE1ldGhvZCA9IG9iamVjdFttZXRob2ROYW1lXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcHJvbWlzaWZpZWRNZXRob2QgKGFyZywgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgICAgIHJldHVybiBuZXcgVXRpbHMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBvbGRBcmdzID0gW2FyZywgcmVzb2x2ZSwgcmVqZWN0XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrc0ZpcnN0KSB7XG4gICAgICAgICAgb2xkQXJncyA9IFtyZXNvbHZlLCByZWplY3QsIGFyZ107XG4gICAgICAgIH1cbiAgICAgICAgb2xkTWV0aG9kLmFwcGx5KG9iamVjdCwgb2xkQXJncyk7XG4gICAgICB9KS50aGVuKG9uU3VjY2Vzcywgb25GYWlsdXJlKTtcbiAgICB9O1xuICB9LFxuXG4gIGF1Z21lbnQ6IGZ1bmN0aW9uIChvYmplY3QsIGNvbnN0cnVjdG9yLCBhcmdzLCBvdmVycmlkZSkge1xuICAgIHZhciBpZHgsIHByb3RvO1xuXG4gICAgLy8gQWRkIHB1YmxpYyBwcm9wZXJ0aWVzIGZyb20gY29uc3RydWN0b3IncyBwcm90b3R5cGUgb250byBvYmplY3RcbiAgICBwcm90byA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICBmb3IgKGlkeCBpbiBwcm90bykge1xuICAgICAgaWYgKG92ZXJyaWRlIHx8IG9iamVjdFtpZHhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2JqZWN0W2lkeF0gPSBwcm90b1tpZHhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCB0aGUgb2JqZWN0IGFzIHRob3VnaCBpdCB3ZXJlIGp1c3QgY3JlYXRlZCBieSBjb25zdHJ1Y3RvclxuICAgIGNvbnN0cnVjdG9yLmFwcGx5KG9iamVjdCwgYXJncyk7XG4gIH0sXG5cbiAgb3B0aW9uc092ZXJyaWRlOiBmdW5jdGlvbiAob3B0aW9ucywgd2lubmVyLCBsb3NlciwgaXNEZXByZWNhdGVkLCBsb2dnZXIsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChpc0RlcHJlY2F0ZWQgJiYgb3B0aW9uc1tsb3Nlcl0pIHtcbiAgICAgIGxvZ2dlci53YXJuKGxvc2VyICsgJyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlICcgKyB3aW5uZXIgKyAnIGluc3RlYWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc1t3aW5uZXJdICYmIG9wdGlvbnNbbG9zZXJdKSB7XG4gICAgICBsb2dnZXIud2Fybih3aW5uZXIgKyAnIG92ZXJyaWRpbmcgJyArIGxvc2VyKTtcbiAgICB9XG5cbiAgICBvcHRpb25zW3dpbm5lcl0gPSBvcHRpb25zW3dpbm5lcl0gfHwgb3B0aW9uc1tsb3Nlcl0gfHwgZGVmYXVsdFZhbHVlO1xuICB9LFxuXG4gIHN0cl91dGY4X2xlbmd0aDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpLnJlcGxhY2UoLyVbQS1GXFxkXXsyfS9nLCAnVScpLmxlbmd0aDtcbiAgfSxcblxuICBnZW5lcmF0ZUZha2VTRFA6IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBib2R5LmluZGV4T2YoJ289Jyk7XG4gICAgdmFyIGVuZCA9IGJvZHkuaW5kZXhPZignXFxyXFxuJywgc3RhcnQpO1xuXG4gICAgcmV0dXJuICd2PTBcXHJcXG4nICsgYm9keS5zbGljZShzdGFydCwgZW5kKSArICdcXHJcXG5zPS1cXHJcXG50PTAgMFxcclxcbmM9SU4gSVA0IDAuMC4wLjAnO1xuICB9LFxuXG4gIGlzRnVuY3Rpb246IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKGZuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIGlzRGVjaW1hbDogZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiAhaXNOYU4obnVtKSAmJiAocGFyc2VGbG9hdChudW0pID09PSBwYXJzZUludChudW0sMTApKTtcbiAgfSxcblxuICBjcmVhdGVSYW5kb21Ub2tlbjogZnVuY3Rpb24oc2l6ZSwgYmFzZSkge1xuICAgIHZhciBpLCByLFxuICAgICAgdG9rZW4gPSAnJztcblxuICAgIGJhc2UgPSBiYXNlIHx8IDMyO1xuXG4gICAgZm9yKCBpPTA7IGkgPCBzaXplOyBpKysgKSB7XG4gICAgICByID0gTWF0aC5yYW5kb20oKSAqIGJhc2V8MDtcbiAgICAgIHRva2VuICs9IHIudG9TdHJpbmcoYmFzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VuO1xuICB9LFxuXG4gIG5ld1RhZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFNJUC5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbihTSVAuVUEuQy5UQUdfTEVOR1RIKTtcbiAgfSxcblxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vdXNlcnMvMTA5NTM4L2Jyb29mYVxuICBuZXdVVUlEOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgVVVJRCA9ICAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSoxNnwwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyJjB4M3wweDgpO1xuICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFVVSUQ7XG4gIH0sXG5cbiAgaG9zdFR5cGU6IGZ1bmN0aW9uKGhvc3QpIHtcbiAgICBpZiAoIWhvc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9zdCA9IFNJUC5HcmFtbWFyLnBhcnNlKGhvc3QsJ2hvc3QnKTtcbiAgICAgIGlmIChob3N0ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gaG9zdC5ob3N0X3R5cGU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIE5vcm1hbGl6ZSBTSVAgVVJJLlxuICAqIE5PVEU6IEl0IGRvZXMgbm90IGFsbG93IGEgU0lQIFVSSSB3aXRob3V0IHVzZXJuYW1lLlxuICAqIEFjY2VwdHMgJ3NpcCcsICdzaXBzJyBhbmQgJ3RlbCcgVVJJcyBhbmQgY29udmVydCB0aGVtIGludG8gJ3NpcCcuXG4gICogRGV0ZWN0cyB0aGUgZG9tYWluIHBhcnQgKGlmIGdpdmVuKSBhbmQgcHJvcGVybHkgaGV4LWVzY2FwZXMgdGhlIHVzZXIgcG9ydGlvbi5cbiAgKiBJZiB0aGUgdXNlciBwb3J0aW9uIGhhcyBvbmx5ICd0ZWwnIG51bWJlciBzeW1ib2xzIHRoZSB1c2VyIHBvcnRpb24gaXMgY2xlYW4gb2YgJ3RlbCcgdmlzdWFsIHNlcGFyYXRvcnMuXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0XG4gICogQHBhcmFtIHtTdHJpbmd9IFtkb21haW5dXG4gICovXG4gIG5vcm1hbGl6ZVRhcmdldDogZnVuY3Rpb24odGFyZ2V0LCBkb21haW4pIHtcbiAgICB2YXIgdXJpLCB0YXJnZXRfYXJyYXksIHRhcmdldF91c2VyLCB0YXJnZXRfZG9tYWluO1xuXG4gICAgLy8gSWYgbm8gdGFyZ2V0IGlzIGdpdmVuIHRoZW4gcmFpc2UgYW4gZXJyb3IuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICAvLyBJZiBhIFNJUC5VUkkgaW5zdGFuY2UgaXMgZ2l2ZW4gdGhlbiByZXR1cm4gaXQuXG4gICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTSVAuVVJJKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuXG4gICAgLy8gSWYgYSBzdHJpbmcgaXMgZ2l2ZW4gc3BsaXQgaXQgYnkgJ0AnOlxuICAgIC8vIC0gTGFzdCBmcmFnbWVudCBpcyB0aGUgZGVzaXJlZCBkb21haW4uXG4gICAgLy8gLSBPdGhlcndpc2UgYXBwZW5kIHRoZSBnaXZlbiBkb21haW4gYXJndW1lbnQuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGFyZ2V0X2FycmF5ID0gdGFyZ2V0LnNwbGl0KCdAJyk7XG5cbiAgICAgIHN3aXRjaCh0YXJnZXRfYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRfdXNlciA9IHRhcmdldDtcbiAgICAgICAgICB0YXJnZXRfZG9tYWluID0gZG9tYWluO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGFyZ2V0X3VzZXIgPSB0YXJnZXRfYXJyYXlbMF07XG4gICAgICAgICAgdGFyZ2V0X2RvbWFpbiA9IHRhcmdldF9hcnJheVsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0YXJnZXRfdXNlciA9IHRhcmdldF9hcnJheS5zbGljZSgwLCB0YXJnZXRfYXJyYXkubGVuZ3RoLTEpLmpvaW4oJ0AnKTtcbiAgICAgICAgICB0YXJnZXRfZG9tYWluID0gdGFyZ2V0X2FycmF5W3RhcmdldF9hcnJheS5sZW5ndGgtMV07XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgVVJJIHNjaGVtZSAoaWYgcHJlc2VudCkuXG4gICAgICB0YXJnZXRfdXNlciA9IHRhcmdldF91c2VyLnJlcGxhY2UoL14oc2lwcz98dGVsKTovaSwgJycpO1xuXG4gICAgICAvLyBSZW1vdmUgJ3RlbCcgdmlzdWFsIHNlcGFyYXRvcnMgaWYgdGhlIHVzZXIgcG9ydGlvbiBqdXN0IGNvbnRhaW5zICd0ZWwnIG51bWJlciBzeW1ib2xzLlxuICAgICAgaWYgKC9eW1xcLVxcLlxcKFxcKV0qXFwrP1swLTlcXC1cXC5cXChcXCldKyQvLnRlc3QodGFyZ2V0X3VzZXIpKSB7XG4gICAgICAgIHRhcmdldF91c2VyID0gdGFyZ2V0X3VzZXIucmVwbGFjZSgvW1xcLVxcLlxcKFxcKV0vZywgJycpO1xuICAgICAgfVxuXG4gICAgICAvLyBCdWlsZCB0aGUgY29tcGxldGUgU0lQIFVSSS5cbiAgICAgIHRhcmdldCA9IFNJUC5DLlNJUCArICc6JyArIFNJUC5VdGlscy5lc2NhcGVVc2VyKHRhcmdldF91c2VyKSArICdAJyArIHRhcmdldF9kb21haW47XG5cbiAgICAgIC8vIEZpbmFsbHkgcGFyc2UgdGhlIHJlc3VsdGluZyBVUkkuXG4gICAgICBpZiAodXJpID0gU0lQLlVSSS5wYXJzZSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogSGV4LWVzY2FwZSBhIFNJUCBVUkkgdXNlci5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gICovXG4gIGVzY2FwZVVzZXI6IGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAvLyBEb24ndCBoZXgtZXNjYXBlICc6JyAoJTNBKSwgJysnICglMkIpLCAnPycgKCUzRlwiKSwgJy8nICglMkYpLlxuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVzZXIpKS5yZXBsYWNlKC8lM0EvaWcsICc6JykucmVwbGFjZSgvJTJCL2lnLCAnKycpLnJlcGxhY2UoLyUzRi9pZywgJz8nKS5yZXBsYWNlKC8lMkYvaWcsICcvJyk7XG4gIH0sXG5cbiAgaGVhZGVyaXplOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZXhjZXB0aW9ucyA9IHtcbiAgICAgICdDYWxsLUlkJzogJ0NhbGwtSUQnLFxuICAgICAgJ0NzZXEnOiAnQ1NlcScsXG4gICAgICAnTWluLVNlJzogJ01pbi1TRScsXG4gICAgICAnUmFjayc6ICdSQWNrJyxcbiAgICAgICdSc2VxJzogJ1JTZXEnLFxuICAgICAgJ1d3dy1BdXRoZW50aWNhdGUnOiAnV1dXLUF1dGhlbnRpY2F0ZSdcbiAgICAgIH0sXG4gICAgICBuYW1lID0gc3RyaW5nLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXy9nLCctJykuc3BsaXQoJy0nKSxcbiAgICAgIGhuYW1lID0gJycsXG4gICAgICBwYXJ0cyA9IG5hbWUubGVuZ3RoLCBwYXJ0O1xuXG4gICAgZm9yIChwYXJ0ID0gMDsgcGFydCA8IHBhcnRzOyBwYXJ0KyspIHtcbiAgICAgIGlmIChwYXJ0ICE9PSAwKSB7XG4gICAgICAgIGhuYW1lICs9Jy0nO1xuICAgICAgfVxuICAgICAgaG5hbWUgKz0gbmFtZVtwYXJ0XS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuYW1lW3BhcnRdLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKGV4Y2VwdGlvbnNbaG5hbWVdKSB7XG4gICAgICBobmFtZSA9IGV4Y2VwdGlvbnNbaG5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gaG5hbWU7XG4gIH0sXG5cbiAgc2lwRXJyb3JDYXVzZTogZnVuY3Rpb24oc3RhdHVzX2NvZGUpIHtcbiAgICB2YXIgY2F1c2U7XG5cbiAgICBmb3IgKGNhdXNlIGluIFNJUC5DLlNJUF9FUlJPUl9DQVVTRVMpIHtcbiAgICAgIGlmIChTSVAuQy5TSVBfRVJST1JfQ0FVU0VTW2NhdXNlXS5pbmRleE9mKHN0YXR1c19jb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLmNhdXNlc1tjYXVzZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFNJUC5DLmNhdXNlcy5TSVBfRkFJTFVSRV9DT0RFO1xuICB9LFxuXG4gIGdldFJlYXNvblBocmFzZTogZnVuY3Rpb24gZ2V0UmVhc29uUGhyYXNlIChjb2RlLCBzcGVjaWZpYykge1xuICAgIHJldHVybiBzcGVjaWZpYyB8fCBTSVAuQy5SRUFTT05fUEhSQVNFW2NvZGVdIHx8ICcnO1xuICB9LFxuXG4gIGdldFJlYXNvbkhlYWRlclZhbHVlOiBmdW5jdGlvbiBnZXRSZWFzb25IZWFkZXJWYWx1ZSAoY29kZSwgcmVhc29uKSB7XG4gICAgcmVhc29uID0gU0lQLlV0aWxzLmdldFJlYXNvblBocmFzZShjb2RlLCByZWFzb24pO1xuICAgIHJldHVybiAnU0lQIDtjYXVzZT0nICsgY29kZSArICcgO3RleHQ9XCInICsgcmVhc29uICsgJ1wiJztcbiAgfSxcblxuICBnZXRDYW5jZWxSZWFzb246IGZ1bmN0aW9uIGdldENhbmNlbFJlYXNvbiAoY29kZSwgcmVhc29uKSB7XG4gICAgaWYgKGNvZGUgJiYgY29kZSA8IDIwMCB8fCBjb2RlID4gNjk5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0YXR1c19jb2RlOiAnICsgY29kZSk7XG4gICAgfSBlbHNlIGlmIChjb2RlKSB7XG4gICAgICByZXR1cm4gU0lQLlV0aWxzLmdldFJlYXNvbkhlYWRlclZhbHVlKGNvZGUsIHJlYXNvbik7XG4gICAgfVxuICB9LFxuXG4gIGJ1aWxkU3RhdHVzTGluZTogZnVuY3Rpb24gYnVpbGRTdGF0dXNMaW5lIChjb2RlLCByZWFzb24pIHtcbiAgICBjb2RlID0gY29kZSB8fCBudWxsO1xuICAgIHJlYXNvbiA9IHJlYXNvbiB8fCBudWxsO1xuXG4gICAgLy8gVmFsaWRhdGUgY29kZSBhbmQgcmVhc29uIHZhbHVlc1xuICAgIGlmICghY29kZSB8fCAoY29kZSA8IDEwMCB8fCBjb2RlID4gNjk5KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNfY29kZTogJysgY29kZSk7XG4gICAgfSBlbHNlIGlmIChyZWFzb24gJiYgdHlwZW9mIHJlYXNvbiAhPT0gJ3N0cmluZycgJiYgIShyZWFzb24gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHJlYXNvbl9waHJhc2U6ICcrIHJlYXNvbik7XG4gICAgfVxuXG4gICAgcmVhc29uID0gVXRpbHMuZ2V0UmVhc29uUGhyYXNlKGNvZGUsIHJlYXNvbik7XG5cbiAgICByZXR1cm4gJ1NJUC8yLjAgJyArIGNvZGUgKyAnICcgKyByZWFzb24gKyAnXFxyXFxuJztcbiAgfSxcblxuICAvKipcbiAgKiBHZW5lcmF0ZSBhIHJhbmRvbSBUZXN0LU5ldCBJUCAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTczNSlcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBnZXRSYW5kb21UZXN0TmV0SVA6IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGdldE9jdGV0KGZyb20sdG8pIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKHRvLWZyb20rMSkrZnJvbSk7XG4gICAgfVxuICAgIHJldHVybiAnMTkyLjAuMi4nICsgZ2V0T2N0ZXQoMSwgMjU0KTtcbiAgfSxcblxuICAvLyBNRDUgKE1lc3NhZ2UtRGlnZXN0IEFsZ29yaXRobSkgaHR0cDovL3d3dy53ZWJ0b29sa2l0LmluZm9cbiAgY2FsY3VsYXRlTUQ1OiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBmdW5jdGlvbiBSb3RhdGVMZWZ0KGxWYWx1ZSwgaVNoaWZ0Qml0cykge1xuICAgICAgcmV0dXJuIChsVmFsdWU8PGlTaGlmdEJpdHMpIHwgKGxWYWx1ZT4+PigzMi1pU2hpZnRCaXRzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQWRkVW5zaWduZWQobFgsbFkpIHtcbiAgICAgIHZhciBsWDQsbFk0LGxYOCxsWTgsbFJlc3VsdDtcbiAgICAgIGxYOCA9IChsWCAmIDB4ODAwMDAwMDApO1xuICAgICAgbFk4ID0gKGxZICYgMHg4MDAwMDAwMCk7XG4gICAgICBsWDQgPSAobFggJiAweDQwMDAwMDAwKTtcbiAgICAgIGxZNCA9IChsWSAmIDB4NDAwMDAwMDApO1xuICAgICAgbFJlc3VsdCA9IChsWCAmIDB4M0ZGRkZGRkYpKyhsWSAmIDB4M0ZGRkZGRkYpO1xuICAgICAgaWYgKGxYNCAmIGxZNCkge1xuICAgICAgICByZXR1cm4gKGxSZXN1bHQgXiAweDgwMDAwMDAwIF4gbFg4IF4gbFk4KTtcbiAgICAgIH1cbiAgICAgIGlmIChsWDQgfCBsWTQpIHtcbiAgICAgICAgaWYgKGxSZXN1bHQgJiAweDQwMDAwMDAwKSB7XG4gICAgICAgICAgcmV0dXJuIChsUmVzdWx0IF4gMHhDMDAwMDAwMCBeIGxYOCBeIGxZOCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChsUmVzdWx0IF4gMHg0MDAwMDAwMCBeIGxYOCBeIGxZOCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAobFJlc3VsdCBeIGxYOCBeIGxZOCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRih4LHkseikge1xuICAgICAgcmV0dXJuICh4ICYgeSkgfCAoKH54KSAmIHopO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEcoeCx5LHopIHtcbiAgICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiAofnopKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBIKHgseSx6KSB7XG4gICAgICByZXR1cm4gKHggXiB5IF4geik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSSh4LHkseikge1xuICAgICAgcmV0dXJuICh5IF4gKHggfCAofnopKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRkYoYSxiLGMsZCx4LHMsYWMpIHtcbiAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChGKGIsIGMsIGQpLCB4KSwgYWMpKTtcbiAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHRyhhLGIsYyxkLHgscyxhYykge1xuICAgICAgYSA9IEFkZFVuc2lnbmVkKGEsIEFkZFVuc2lnbmVkKEFkZFVuc2lnbmVkKEcoYiwgYywgZCksIHgpLCBhYykpO1xuICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEhIKGEsYixjLGQseCxzLGFjKSB7XG4gICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoSChiLCBjLCBkKSwgeCksIGFjKSk7XG4gICAgICByZXR1cm4gQWRkVW5zaWduZWQoUm90YXRlTGVmdChhLCBzKSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSUkoYSxiLGMsZCx4LHMsYWMpIHtcbiAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChJKGIsIGMsIGQpLCB4KSwgYWMpKTtcbiAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb252ZXJ0VG9Xb3JkQXJyYXkoc3RyaW5nKSB7XG4gICAgICB2YXIgbFdvcmRDb3VudDtcbiAgICAgIHZhciBsTWVzc2FnZUxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICB2YXIgbE51bWJlck9mV29yZHNfdGVtcDE9bE1lc3NhZ2VMZW5ndGggKyA4O1xuICAgICAgdmFyIGxOdW1iZXJPZldvcmRzX3RlbXAyPShsTnVtYmVyT2ZXb3Jkc190ZW1wMS0obE51bWJlck9mV29yZHNfdGVtcDEgJSA2NCkpLzY0O1xuICAgICAgdmFyIGxOdW1iZXJPZldvcmRzID0gKGxOdW1iZXJPZldvcmRzX3RlbXAyKzEpKjE2O1xuICAgICAgdmFyIGxXb3JkQXJyYXk9QXJyYXkobE51bWJlck9mV29yZHMtMSk7XG4gICAgICB2YXIgbEJ5dGVQb3NpdGlvbiA9IDA7XG4gICAgICB2YXIgbEJ5dGVDb3VudCA9IDA7XG4gICAgICB3aGlsZSAoIGxCeXRlQ291bnQgPCBsTWVzc2FnZUxlbmd0aCApIHtcbiAgICAgICAgbFdvcmRDb3VudCA9IChsQnl0ZUNvdW50LShsQnl0ZUNvdW50ICUgNCkpLzQ7XG4gICAgICAgIGxCeXRlUG9zaXRpb24gPSAobEJ5dGVDb3VudCAlIDQpKjg7XG4gICAgICAgIGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gPSAobFdvcmRBcnJheVtsV29yZENvdW50XSB8IChzdHJpbmcuY2hhckNvZGVBdChsQnl0ZUNvdW50KTw8bEJ5dGVQb3NpdGlvbikpO1xuICAgICAgICBsQnl0ZUNvdW50Kys7XG4gICAgICB9XG4gICAgICBsV29yZENvdW50ID0gKGxCeXRlQ291bnQtKGxCeXRlQ291bnQgJSA0KSkvNDtcbiAgICAgIGxCeXRlUG9zaXRpb24gPSAobEJ5dGVDb3VudCAlIDQpKjg7XG4gICAgICBsV29yZEFycmF5W2xXb3JkQ291bnRdID0gbFdvcmRBcnJheVtsV29yZENvdW50XSB8ICgweDgwPDxsQnl0ZVBvc2l0aW9uKTtcbiAgICAgIGxXb3JkQXJyYXlbbE51bWJlck9mV29yZHMtMl0gPSBsTWVzc2FnZUxlbmd0aDw8MztcbiAgICAgIGxXb3JkQXJyYXlbbE51bWJlck9mV29yZHMtMV0gPSBsTWVzc2FnZUxlbmd0aD4+PjI5O1xuICAgICAgcmV0dXJuIGxXb3JkQXJyYXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV29yZFRvSGV4KGxWYWx1ZSkge1xuICAgICAgdmFyIFdvcmRUb0hleFZhbHVlPVwiXCIsV29yZFRvSGV4VmFsdWVfdGVtcD1cIlwiLGxCeXRlLGxDb3VudDtcbiAgICAgIGZvciAobENvdW50ID0gMDtsQ291bnQ8PTM7bENvdW50KyspIHtcbiAgICAgICAgbEJ5dGUgPSAobFZhbHVlPj4+KGxDb3VudCo4KSkgJiAyNTU7XG4gICAgICAgIFdvcmRUb0hleFZhbHVlX3RlbXAgPSBcIjBcIiArIGxCeXRlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgV29yZFRvSGV4VmFsdWUgPSBXb3JkVG9IZXhWYWx1ZSArIFdvcmRUb0hleFZhbHVlX3RlbXAuc3Vic3RyKFdvcmRUb0hleFZhbHVlX3RlbXAubGVuZ3RoLTIsMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gV29yZFRvSGV4VmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVXRmOEVuY29kZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXHJcXG4vZyxcIlxcblwiKTtcbiAgICAgIHZhciB1dGZ0ZXh0ID0gXCJcIjtcblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBzdHJpbmcubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChuKTtcblxuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKChjID4gMTI3KSAmJiAoYyA8IDIwNDgpKSB7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjID4+IDYpIHwgMTkyKTtcbiAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiA2MykgfCAxMjgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyA+PiAxMikgfCAyMjQpO1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgPj4gNikgJiA2MykgfCAxMjgpO1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDYzKSB8IDEyOCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1dGZ0ZXh0O1xuICAgIH1cblxuICAgIHZhciB4PVtdO1xuICAgIHZhciBrLEFBLEJCLENDLERELGEsYixjLGQ7XG4gICAgdmFyIFMxMT03LCBTMTI9MTIsIFMxMz0xNywgUzE0PTIyO1xuICAgIHZhciBTMjE9NSwgUzIyPTkgLCBTMjM9MTQsIFMyND0yMDtcbiAgICB2YXIgUzMxPTQsIFMzMj0xMSwgUzMzPTE2LCBTMzQ9MjM7XG4gICAgdmFyIFM0MT02LCBTNDI9MTAsIFM0Mz0xNSwgUzQ0PTIxO1xuXG4gICAgc3RyaW5nID0gVXRmOEVuY29kZShzdHJpbmcpO1xuXG4gICAgeCA9IENvbnZlcnRUb1dvcmRBcnJheShzdHJpbmcpO1xuXG4gICAgYSA9IDB4Njc0NTIzMDE7IGIgPSAweEVGQ0RBQjg5OyBjID0gMHg5OEJBRENGRTsgZCA9IDB4MTAzMjU0NzY7XG5cbiAgICBmb3IgKGs9MDtrPHgubGVuZ3RoO2srPTE2KSB7XG4gICAgICBBQT1hOyBCQj1iOyBDQz1jOyBERD1kO1xuICAgICAgYT1GRihhLGIsYyxkLHhbayswXSwgUzExLDB4RDc2QUE0NzgpO1xuICAgICAgZD1GRihkLGEsYixjLHhbaysxXSwgUzEyLDB4RThDN0I3NTYpO1xuICAgICAgYz1GRihjLGQsYSxiLHhbaysyXSwgUzEzLDB4MjQyMDcwREIpO1xuICAgICAgYj1GRihiLGMsZCxhLHhbayszXSwgUzE0LDB4QzFCRENFRUUpO1xuICAgICAgYT1GRihhLGIsYyxkLHhbays0XSwgUzExLDB4RjU3QzBGQUYpO1xuICAgICAgZD1GRihkLGEsYixjLHhbays1XSwgUzEyLDB4NDc4N0M2MkEpO1xuICAgICAgYz1GRihjLGQsYSxiLHhbays2XSwgUzEzLDB4QTgzMDQ2MTMpO1xuICAgICAgYj1GRihiLGMsZCxhLHhbays3XSwgUzE0LDB4RkQ0Njk1MDEpO1xuICAgICAgYT1GRihhLGIsYyxkLHhbays4XSwgUzExLDB4Njk4MDk4RDgpO1xuICAgICAgZD1GRihkLGEsYixjLHhbays5XSwgUzEyLDB4OEI0NEY3QUYpO1xuICAgICAgYz1GRihjLGQsYSxiLHhbaysxMF0sUzEzLDB4RkZGRjVCQjEpO1xuICAgICAgYj1GRihiLGMsZCxhLHhbaysxMV0sUzE0LDB4ODk1Q0Q3QkUpO1xuICAgICAgYT1GRihhLGIsYyxkLHhbaysxMl0sUzExLDB4NkI5MDExMjIpO1xuICAgICAgZD1GRihkLGEsYixjLHhbaysxM10sUzEyLDB4RkQ5ODcxOTMpO1xuICAgICAgYz1GRihjLGQsYSxiLHhbaysxNF0sUzEzLDB4QTY3OTQzOEUpO1xuICAgICAgYj1GRihiLGMsZCxhLHhbaysxNV0sUzE0LDB4NDlCNDA4MjEpO1xuICAgICAgYT1HRyhhLGIsYyxkLHhbaysxXSwgUzIxLDB4RjYxRTI1NjIpO1xuICAgICAgZD1HRyhkLGEsYixjLHhbays2XSwgUzIyLDB4QzA0MEIzNDApO1xuICAgICAgYz1HRyhjLGQsYSxiLHhbaysxMV0sUzIzLDB4MjY1RTVBNTEpO1xuICAgICAgYj1HRyhiLGMsZCxhLHhbayswXSwgUzI0LDB4RTlCNkM3QUEpO1xuICAgICAgYT1HRyhhLGIsYyxkLHhbays1XSwgUzIxLDB4RDYyRjEwNUQpO1xuICAgICAgZD1HRyhkLGEsYixjLHhbaysxMF0sUzIyLDB4MjQ0MTQ1Myk7XG4gICAgICBjPUdHKGMsZCxhLGIseFtrKzE1XSxTMjMsMHhEOEExRTY4MSk7XG4gICAgICBiPUdHKGIsYyxkLGEseFtrKzRdLCBTMjQsMHhFN0QzRkJDOCk7XG4gICAgICBhPUdHKGEsYixjLGQseFtrKzldLCBTMjEsMHgyMUUxQ0RFNik7XG4gICAgICBkPUdHKGQsYSxiLGMseFtrKzE0XSxTMjIsMHhDMzM3MDdENik7XG4gICAgICBjPUdHKGMsZCxhLGIseFtrKzNdLCBTMjMsMHhGNEQ1MEQ4Nyk7XG4gICAgICBiPUdHKGIsYyxkLGEseFtrKzhdLCBTMjQsMHg0NTVBMTRFRCk7XG4gICAgICBhPUdHKGEsYixjLGQseFtrKzEzXSxTMjEsMHhBOUUzRTkwNSk7XG4gICAgICBkPUdHKGQsYSxiLGMseFtrKzJdLCBTMjIsMHhGQ0VGQTNGOCk7XG4gICAgICBjPUdHKGMsZCxhLGIseFtrKzddLCBTMjMsMHg2NzZGMDJEOSk7XG4gICAgICBiPUdHKGIsYyxkLGEseFtrKzEyXSxTMjQsMHg4RDJBNEM4QSk7XG4gICAgICBhPUhIKGEsYixjLGQseFtrKzVdLCBTMzEsMHhGRkZBMzk0Mik7XG4gICAgICBkPUhIKGQsYSxiLGMseFtrKzhdLCBTMzIsMHg4NzcxRjY4MSk7XG4gICAgICBjPUhIKGMsZCxhLGIseFtrKzExXSxTMzMsMHg2RDlENjEyMik7XG4gICAgICBiPUhIKGIsYyxkLGEseFtrKzE0XSxTMzQsMHhGREU1MzgwQyk7XG4gICAgICBhPUhIKGEsYixjLGQseFtrKzFdLCBTMzEsMHhBNEJFRUE0NCk7XG4gICAgICBkPUhIKGQsYSxiLGMseFtrKzRdLCBTMzIsMHg0QkRFQ0ZBOSk7XG4gICAgICBjPUhIKGMsZCxhLGIseFtrKzddLCBTMzMsMHhGNkJCNEI2MCk7XG4gICAgICBiPUhIKGIsYyxkLGEseFtrKzEwXSxTMzQsMHhCRUJGQkM3MCk7XG4gICAgICBhPUhIKGEsYixjLGQseFtrKzEzXSxTMzEsMHgyODlCN0VDNik7XG4gICAgICBkPUhIKGQsYSxiLGMseFtrKzBdLCBTMzIsMHhFQUExMjdGQSk7XG4gICAgICBjPUhIKGMsZCxhLGIseFtrKzNdLCBTMzMsMHhENEVGMzA4NSk7XG4gICAgICBiPUhIKGIsYyxkLGEseFtrKzZdLCBTMzQsMHg0ODgxRDA1KTtcbiAgICAgIGE9SEgoYSxiLGMsZCx4W2srOV0sIFMzMSwweEQ5RDREMDM5KTtcbiAgICAgIGQ9SEgoZCxhLGIsYyx4W2srMTJdLFMzMiwweEU2REI5OUU1KTtcbiAgICAgIGM9SEgoYyxkLGEsYix4W2srMTVdLFMzMywweDFGQTI3Q0Y4KTtcbiAgICAgIGI9SEgoYixjLGQsYSx4W2srMl0sIFMzNCwweEM0QUM1NjY1KTtcbiAgICAgIGE9SUkoYSxiLGMsZCx4W2srMF0sIFM0MSwweEY0MjkyMjQ0KTtcbiAgICAgIGQ9SUkoZCxhLGIsYyx4W2srN10sIFM0MiwweDQzMkFGRjk3KTtcbiAgICAgIGM9SUkoYyxkLGEsYix4W2srMTRdLFM0MywweEFCOTQyM0E3KTtcbiAgICAgIGI9SUkoYixjLGQsYSx4W2srNV0sIFM0NCwweEZDOTNBMDM5KTtcbiAgICAgIGE9SUkoYSxiLGMsZCx4W2srMTJdLFM0MSwweDY1NUI1OUMzKTtcbiAgICAgIGQ9SUkoZCxhLGIsYyx4W2srM10sIFM0MiwweDhGMENDQzkyKTtcbiAgICAgIGM9SUkoYyxkLGEsYix4W2srMTBdLFM0MywweEZGRUZGNDdEKTtcbiAgICAgIGI9SUkoYixjLGQsYSx4W2srMV0sIFM0NCwweDg1ODQ1REQxKTtcbiAgICAgIGE9SUkoYSxiLGMsZCx4W2srOF0sIFM0MSwweDZGQTg3RTRGKTtcbiAgICAgIGQ9SUkoZCxhLGIsYyx4W2srMTVdLFM0MiwweEZFMkNFNkUwKTtcbiAgICAgIGM9SUkoYyxkLGEsYix4W2srNl0sIFM0MywweEEzMDE0MzE0KTtcbiAgICAgIGI9SUkoYixjLGQsYSx4W2srMTNdLFM0NCwweDRFMDgxMUExKTtcbiAgICAgIGE9SUkoYSxiLGMsZCx4W2srNF0sIFM0MSwweEY3NTM3RTgyKTtcbiAgICAgIGQ9SUkoZCxhLGIsYyx4W2srMTFdLFM0MiwweEJEM0FGMjM1KTtcbiAgICAgIGM9SUkoYyxkLGEsYix4W2srMl0sIFM0MywweDJBRDdEMkJCKTtcbiAgICAgIGI9SUkoYixjLGQsYSx4W2srOV0sIFM0NCwweEVCODZEMzkxKTtcbiAgICAgIGE9QWRkVW5zaWduZWQoYSxBQSk7XG4gICAgICBiPUFkZFVuc2lnbmVkKGIsQkIpO1xuICAgICAgYz1BZGRVbnNpZ25lZChjLENDKTtcbiAgICAgIGQ9QWRkVW5zaWduZWQoZCxERCk7XG4gICAgfVxuXG4gICAgdmFyIHRlbXAgPSBXb3JkVG9IZXgoYSkrV29yZFRvSGV4KGIpK1dvcmRUb0hleChjKStXb3JkVG9IZXgoZCk7XG5cbiAgICByZXR1cm4gdGVtcC50b0xvd2VyQ2FzZSgpO1xuICB9XG59O1xuXG5TSVAuVXRpbHMgPSBVdGlscztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMjE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsZXZlbHMgPSB7XG4gICdlcnJvcic6IDAsXG4gICd3YXJuJzogMSxcbiAgJ2xvZyc6IDIsXG4gICdkZWJ1Zyc6IDNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnNvbGUpIHtcblxudmFyIExvZ2dlckZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb2dnZXIsXG4gICAgbGV2ZWwgPSAyLFxuICAgIGJ1aWx0aW5FbmFibGVkID0gdHJ1ZSxcbiAgICBjb25uZWN0b3IgPSBudWxsO1xuXG4gICAgdGhpcy5sb2dnZXJzID0ge307XG5cbiAgICBsb2dnZXIgPSB0aGlzLmdldExvZ2dlcignc2lwLmxvZ2dlcmZhY3RvcnknKTtcblxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBidWlsdGluRW5hYmxlZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gYnVpbHRpbkVuYWJsZWQ7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgYnVpbHRpbkVuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ2ludmFsaWQgXCJidWlsdGluRW5hYmxlZFwiIHBhcmFtZXRlciB2YWx1ZTogJysgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBsZXZlbDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtyZXR1cm4gbGV2ZWw7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDw9Mykge1xuICAgICAgICAgIGxldmVsID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiAzKSB7XG4gICAgICAgICAgbGV2ZWwgPSAzO1xuICAgICAgICB9IGVsc2UgaWYgKGxldmVscy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgICAgICBsZXZlbCA9IGxldmVsc1t2YWx1ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdpbnZhbGlkIFwibGV2ZWxcIiBwYXJhbWV0ZXIgdmFsdWU6ICcrIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29ubmVjdG9yOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge3JldHVybiBjb25uZWN0b3I7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgaWYodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbm5lY3RvciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29ubmVjdG9yID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdpbnZhbGlkIFwiY29ubmVjdG9yXCIgcGFyYW1ldGVyIHZhbHVlOiAnKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkxvZ2dlckZhY3RvcnkucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24odGFyZ2V0LCBjYXRlZ29yeSwgbGFiZWwsIGNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwcmVmaXggPSBbbmV3IERhdGUoKSwgY2F0ZWdvcnldO1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgcHJlZml4LnB1c2gobGFiZWwpO1xuICAgIH1cbiAgICBjb250ZW50ID0gcHJlZml4LmNvbmNhdChjb250ZW50KS5qb2luKCcgfCAnKTtcbiAgfVxuICB0YXJnZXQuY2FsbChjb25zb2xlLCBjb250ZW50KTtcbn07XG5cbmZ1bmN0aW9uIExvZ2dlciAobG9nZ2VyLCBjYXRlZ29yeSwgbGFiZWwpIHtcbiAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIHRoaXMuY2F0ZWdvcnkgPSBjYXRlZ29yeTtcbiAgdGhpcy5sYWJlbCA9IGxhYmVsO1xufVxuXG5PYmplY3Qua2V5cyhsZXZlbHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldE5hbWUpIHtcbiAgTG9nZ2VyLnByb3RvdHlwZVt0YXJnZXROYW1lXSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgdGhpcy5sb2dnZXJbdGFyZ2V0TmFtZV0odGhpcy5jYXRlZ29yeSwgdGhpcy5sYWJlbCwgY29udGVudCk7XG4gIH07XG5cbiAgTG9nZ2VyRmFjdG9yeS5wcm90b3R5cGVbdGFyZ2V0TmFtZV0gPSBmdW5jdGlvbiAoY2F0ZWdvcnksIGxhYmVsLCBjb250ZW50KSB7XG4gICAgaWYgKHRoaXMubGV2ZWwgPj0gbGV2ZWxzW3RhcmdldE5hbWVdKSB7XG4gICAgICBpZiAodGhpcy5idWlsdGluRW5hYmxlZCkge1xuICAgICAgICB0aGlzLnByaW50KGNvbnNvbGVbdGFyZ2V0TmFtZV0sIGNhdGVnb3J5LCBsYWJlbCwgY29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbm5lY3Rvcikge1xuICAgICAgICB0aGlzLmNvbm5lY3Rvcih0YXJnZXROYW1lLCBjYXRlZ29yeSwgbGFiZWwsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pO1xuXG5Mb2dnZXJGYWN0b3J5LnByb3RvdHlwZS5nZXRMb2dnZXIgPSBmdW5jdGlvbihjYXRlZ29yeSwgbGFiZWwpIHtcbiAgdmFyIGxvZ2dlcjtcblxuICBpZiAobGFiZWwgJiYgdGhpcy5sZXZlbCA9PT0gMykge1xuICAgIHJldHVybiBuZXcgTG9nZ2VyKHRoaXMsIGNhdGVnb3J5LCBsYWJlbCk7XG4gIH0gZWxzZSBpZiAodGhpcy5sb2dnZXJzW2NhdGVnb3J5XSkge1xuICAgIHJldHVybiB0aGlzLmxvZ2dlcnNbY2F0ZWdvcnldO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlciA9IG5ldyBMb2dnZXIodGhpcywgY2F0ZWdvcnkpO1xuICAgIHRoaXMubG9nZ2Vyc1tjYXRlZ29yeV0gPSBsb2dnZXI7XG4gICAgcmV0dXJuIGxvZ2dlcjtcbiAgfVxufTtcblxucmV0dXJuIExvZ2dlckZhY3Rvcnk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9Mb2dnZXJGYWN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gMjE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBOb2RlRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25zb2xlKSB7XG5cbi8vIERvbid0IHVzZSBgbmV3IFNJUC5FdmVudEVtaXR0ZXIoKWAgZm9yIGluaGVyaXRpbmcuXG4vLyBVc2UgT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdG95cGUpO1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyICgpIHtcbiAgTm9kZUV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlRXZlbnRFbWl0dGVyLnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Rvcjoge1xuICAgIHZhbHVlOiBFdmVudEVtaXR0ZXIsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgd2FybmluZyA9ICcnO1xuICB3YXJuaW5nICs9ICdTSVAuRXZlbnRFbWl0dGVyI29mZiBpcyBkZXByZWNhdGVkIGFuZCBtYXkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgU0lQLmpzIHZlcnNpb25zLlxcbic7XG4gIHdhcm5pbmcgKz0gJ1BsZWFzZSB1c2UgcmVtb3ZlTGlzdGVuZXIgb3IgcmVtb3ZlQWxsTGlzdGVuZXJzIGluc3RlYWQuXFxuJztcbiAgd2FybmluZyArPSAnU2VlIGhlcmUgZm9yIG1vcmUgZGV0YWlsczpcXG4nO1xuICB3YXJuaW5nICs9ICdodHRwOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2VtaXR0ZXJfcmVtb3ZlbGlzdGVuZXJfZXZlbnRfbGlzdGVuZXInO1xuICBjb25zb2xlLndhcm4od2FybmluZyk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cbn07XG5cbnJldHVybiBFdmVudEVtaXR0ZXI7XG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0V2ZW50RW1pdHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXZlbnRzL2V2ZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIENvbnN0YW50c1xuICovXG5cbi8qKlxuICogU0lQIENvbnN0YW50cy5cbiAqIEBhdWdtZW50cyBTSVBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lLCB2ZXJzaW9uKSB7XG5yZXR1cm4ge1xuICBVU0VSX0FHRU5UOiBuYW1lICsnLycrIHZlcnNpb24sXG5cbiAgLy8gU0lQIHNjaGVtZVxuICBTSVA6ICAnc2lwJyxcbiAgU0lQUzogJ3NpcHMnLFxuXG4gIC8vIEVuZCBhbmQgRmFpbHVyZSBjYXVzZXNcbiAgY2F1c2VzOiB7XG4gICAgLy8gR2VuZXJpYyBlcnJvciBjYXVzZXNcbiAgICBDT05ORUNUSU9OX0VSUk9SOiAgICAgICAgICdDb25uZWN0aW9uIEVycm9yJyxcbiAgICBSRVFVRVNUX1RJTUVPVVQ6ICAgICAgICAgICdSZXF1ZXN0IFRpbWVvdXQnLFxuICAgIFNJUF9GQUlMVVJFX0NPREU6ICAgICAgICAgJ1NJUCBGYWlsdXJlIENvZGUnLFxuICAgIElOVEVSTkFMX0VSUk9SOiAgICAgICAgICAgJ0ludGVybmFsIEVycm9yJyxcblxuICAgIC8vIFNJUCBlcnJvciBjYXVzZXNcbiAgICBCVVNZOiAgICAgICAgICAgICAgICAgICAgICdCdXN5JyxcbiAgICBSRUpFQ1RFRDogICAgICAgICAgICAgICAgICdSZWplY3RlZCcsXG4gICAgUkVESVJFQ1RFRDogICAgICAgICAgICAgICAnUmVkaXJlY3RlZCcsXG4gICAgVU5BVkFJTEFCTEU6ICAgICAgICAgICAgICAnVW5hdmFpbGFibGUnLFxuICAgIE5PVF9GT1VORDogICAgICAgICAgICAgICAgJ05vdCBGb3VuZCcsXG4gICAgQUREUkVTU19JTkNPTVBMRVRFOiAgICAgICAnQWRkcmVzcyBJbmNvbXBsZXRlJyxcbiAgICBJTkNPTVBBVElCTEVfU0RQOiAgICAgICAgICdJbmNvbXBhdGlibGUgU0RQJyxcbiAgICBBVVRIRU5USUNBVElPTl9FUlJPUjogICAgICdBdXRoZW50aWNhdGlvbiBFcnJvcicsXG4gICAgRElBTE9HX0VSUk9SOiAgICAgICAgICAgICAnRGlhbG9nIEVycm9yJyxcblxuICAgIC8vIFNlc3Npb24gZXJyb3IgY2F1c2VzXG4gICAgV0VCUlRDX05PVF9TVVBQT1JURUQ6ICAgICAnV2ViUlRDIE5vdCBTdXBwb3J0ZWQnLFxuICAgIFdFQlJUQ19FUlJPUjogICAgICAgICAgICAgJ1dlYlJUQyBFcnJvcicsXG4gICAgQ0FOQ0VMRUQ6ICAgICAgICAgICAgICAgICAnQ2FuY2VsZWQnLFxuICAgIE5PX0FOU1dFUjogICAgICAgICAgICAgICAgJ05vIEFuc3dlcicsXG4gICAgRVhQSVJFUzogICAgICAgICAgICAgICAgICAnRXhwaXJlcycsXG4gICAgTk9fQUNLOiAgICAgICAgICAgICAgICAgICAnTm8gQUNLJyxcbiAgICBOT19QUkFDSzogICAgICAgICAgICAgICAgICdObyBQUkFDSycsXG4gICAgVVNFUl9ERU5JRURfTUVESUFfQUNDRVNTOiAnVXNlciBEZW5pZWQgTWVkaWEgQWNjZXNzJyxcbiAgICBCQURfTUVESUFfREVTQ1JJUFRJT046ICAgICdCYWQgTWVkaWEgRGVzY3JpcHRpb24nLFxuICAgIFJUUF9USU1FT1VUOiAgICAgICAgICAgICAgJ1JUUCBUaW1lb3V0J1xuICB9LFxuXG4gIHN1cHBvcnRlZDoge1xuICAgIFVOU1VQUE9SVEVEOiAgICAgICAgJ25vbmUnLFxuICAgIFNVUFBPUlRFRDogICAgICAgICAgJ3N1cHBvcnRlZCcsXG4gICAgUkVRVUlSRUQ6ICAgICAgICAgICAncmVxdWlyZWQnXG4gIH0sXG5cbiAgU0lQX0VSUk9SX0NBVVNFUzoge1xuICAgIFJFRElSRUNURUQ6IFszMDAsMzAxLDMwMiwzMDUsMzgwXSxcbiAgICBCVVNZOiBbNDg2LDYwMF0sXG4gICAgUkVKRUNURUQ6IFs0MDMsNjAzXSxcbiAgICBOT1RfRk9VTkQ6IFs0MDQsNjA0XSxcbiAgICBVTkFWQUlMQUJMRTogWzQ4MCw0MTAsNDA4LDQzMF0sXG4gICAgQUREUkVTU19JTkNPTVBMRVRFOiBbNDg0XSxcbiAgICBJTkNPTVBBVElCTEVfU0RQOiBbNDg4LDYwNl0sXG4gICAgQVVUSEVOVElDQVRJT05fRVJST1I6WzQwMSw0MDddXG4gIH0sXG5cbiAgLy8gU0lQIE1ldGhvZHNcbiAgQUNLOiAgICAgICAgJ0FDSycsXG4gIEJZRTogICAgICAgICdCWUUnLFxuICBDQU5DRUw6ICAgICAnQ0FOQ0VMJyxcbiAgSU5GTzogICAgICAgJ0lORk8nLFxuICBJTlZJVEU6ICAgICAnSU5WSVRFJyxcbiAgTUVTU0FHRTogICAgJ01FU1NBR0UnLFxuICBOT1RJRlk6ICAgICAnTk9USUZZJyxcbiAgT1BUSU9OUzogICAgJ09QVElPTlMnLFxuICBSRUdJU1RFUjogICAnUkVHSVNURVInLFxuICBVUERBVEU6ICAgICAnVVBEQVRFJyxcbiAgU1VCU0NSSUJFOiAgJ1NVQlNDUklCRScsXG4gIFJFRkVSOiAgICAgICdSRUZFUicsXG4gIFBSQUNLOiAgICAgICdQUkFDSycsXG5cbiAgLyogU0lQIFJlc3BvbnNlIFJlYXNvbnNcbiAgICogRE9DOiBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL3NpcC1wYXJhbWV0ZXJzXG4gICAqIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJzYXRpY2EvT3ZlclNJUC9ibG9iL21hc3Rlci9saWIvb3ZlcnNpcC9zaXAvY29uc3RhbnRzLnJiI0w3XG4gICAqL1xuICBSRUFTT05fUEhSQVNFOiB7XG4gICAgMTAwOiAnVHJ5aW5nJyxcbiAgICAxODA6ICdSaW5naW5nJyxcbiAgICAxODE6ICdDYWxsIElzIEJlaW5nIEZvcndhcmRlZCcsXG4gICAgMTgyOiAnUXVldWVkJyxcbiAgICAxODM6ICdTZXNzaW9uIFByb2dyZXNzJyxcbiAgICAxOTk6ICdFYXJseSBEaWFsb2cgVGVybWluYXRlZCcsICAvLyBkcmFmdC1pZXRmLXNpcGNvcmUtMTk5XG4gICAgMjAwOiAnT0snLFxuICAgIDIwMjogJ0FjY2VwdGVkJywgIC8vIFJGQyAzMjY1XG4gICAgMjA0OiAnTm8gTm90aWZpY2F0aW9uJywgIC8vUkZDIDU4MzlcbiAgICAzMDA6ICdNdWx0aXBsZSBDaG9pY2VzJyxcbiAgICAzMDE6ICdNb3ZlZCBQZXJtYW5lbnRseScsXG4gICAgMzAyOiAnTW92ZWQgVGVtcG9yYXJpbHknLFxuICAgIDMwNTogJ1VzZSBQcm94eScsXG4gICAgMzgwOiAnQWx0ZXJuYXRpdmUgU2VydmljZScsXG4gICAgNDAwOiAnQmFkIFJlcXVlc3QnLFxuICAgIDQwMTogJ1VuYXV0aG9yaXplZCcsXG4gICAgNDAyOiAnUGF5bWVudCBSZXF1aXJlZCcsXG4gICAgNDAzOiAnRm9yYmlkZGVuJyxcbiAgICA0MDQ6ICdOb3QgRm91bmQnLFxuICAgIDQwNTogJ01ldGhvZCBOb3QgQWxsb3dlZCcsXG4gICAgNDA2OiAnTm90IEFjY2VwdGFibGUnLFxuICAgIDQwNzogJ1Byb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJyxcbiAgICA0MDg6ICdSZXF1ZXN0IFRpbWVvdXQnLFxuICAgIDQxMDogJ0dvbmUnLFxuICAgIDQxMjogJ0NvbmRpdGlvbmFsIFJlcXVlc3QgRmFpbGVkJywgIC8vIFJGQyAzOTAzXG4gICAgNDEzOiAnUmVxdWVzdCBFbnRpdHkgVG9vIExhcmdlJyxcbiAgICA0MTQ6ICdSZXF1ZXN0LVVSSSBUb28gTG9uZycsXG4gICAgNDE1OiAnVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZScsXG4gICAgNDE2OiAnVW5zdXBwb3J0ZWQgVVJJIFNjaGVtZScsXG4gICAgNDE3OiAnVW5rbm93biBSZXNvdXJjZS1Qcmlvcml0eScsICAvLyBSRkMgNDQxMlxuICAgIDQyMDogJ0JhZCBFeHRlbnNpb24nLFxuICAgIDQyMTogJ0V4dGVuc2lvbiBSZXF1aXJlZCcsXG4gICAgNDIyOiAnU2Vzc2lvbiBJbnRlcnZhbCBUb28gU21hbGwnLCAgLy8gUkZDIDQwMjhcbiAgICA0MjM6ICdJbnRlcnZhbCBUb28gQnJpZWYnLFxuICAgIDQyODogJ1VzZSBJZGVudGl0eSBIZWFkZXInLCAgLy8gUkZDIDQ0NzRcbiAgICA0Mjk6ICdQcm92aWRlIFJlZmVycmVyIElkZW50aXR5JywgIC8vIFJGQyAzODkyXG4gICAgNDMwOiAnRmxvdyBGYWlsZWQnLCAgLy8gUkZDIDU2MjZcbiAgICA0MzM6ICdBbm9ueW1pdHkgRGlzYWxsb3dlZCcsICAvLyBSRkMgNTA3OVxuICAgIDQzNjogJ0JhZCBJZGVudGl0eS1JbmZvJywgIC8vIFJGQyA0NDc0XG4gICAgNDM3OiAnVW5zdXBwb3J0ZWQgQ2VydGlmaWNhdGUnLCAgLy8gUkZDIDQ3NDRcbiAgICA0Mzg6ICdJbnZhbGlkIElkZW50aXR5IEhlYWRlcicsICAvLyBSRkMgNDc0NFxuICAgIDQzOTogJ0ZpcnN0IEhvcCBMYWNrcyBPdXRib3VuZCBTdXBwb3J0JywgIC8vIFJGQyA1NjI2XG4gICAgNDQwOiAnTWF4LUJyZWFkdGggRXhjZWVkZWQnLCAgLy8gUkZDIDUzOTNcbiAgICA0Njk6ICdCYWQgSW5mbyBQYWNrYWdlJywgIC8vIGRyYWZ0LWlldGYtc2lwY29yZS1pbmZvLWV2ZW50c1xuICAgIDQ3MDogJ0NvbnNlbnQgTmVlZGVkJywgIC8vIFJGQyA1MzYwXG4gICAgNDc4OiAnVW5yZXNvbHZhYmxlIERlc3RpbmF0aW9uJywgIC8vIEN1c3RvbSBjb2RlIGNvcGllZCBmcm9tIEthbWFpbGlvLlxuICAgIDQ4MDogJ1RlbXBvcmFyaWx5IFVuYXZhaWxhYmxlJyxcbiAgICA0ODE6ICdDYWxsL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0JyxcbiAgICA0ODI6ICdMb29wIERldGVjdGVkJyxcbiAgICA0ODM6ICdUb28gTWFueSBIb3BzJyxcbiAgICA0ODQ6ICdBZGRyZXNzIEluY29tcGxldGUnLFxuICAgIDQ4NTogJ0FtYmlndW91cycsXG4gICAgNDg2OiAnQnVzeSBIZXJlJyxcbiAgICA0ODc6ICdSZXF1ZXN0IFRlcm1pbmF0ZWQnLFxuICAgIDQ4ODogJ05vdCBBY2NlcHRhYmxlIEhlcmUnLFxuICAgIDQ4OTogJ0JhZCBFdmVudCcsICAvLyBSRkMgMzI2NVxuICAgIDQ5MTogJ1JlcXVlc3QgUGVuZGluZycsXG4gICAgNDkzOiAnVW5kZWNpcGhlcmFibGUnLFxuICAgIDQ5NDogJ1NlY3VyaXR5IEFncmVlbWVudCBSZXF1aXJlZCcsICAvLyBSRkMgMzMyOVxuICAgIDUwMDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgNTAxOiAnTm90IEltcGxlbWVudGVkJyxcbiAgICA1MDI6ICdCYWQgR2F0ZXdheScsXG4gICAgNTAzOiAnU2VydmljZSBVbmF2YWlsYWJsZScsXG4gICAgNTA0OiAnU2VydmVyIFRpbWUtb3V0JyxcbiAgICA1MDU6ICdWZXJzaW9uIE5vdCBTdXBwb3J0ZWQnLFxuICAgIDUxMzogJ01lc3NhZ2UgVG9vIExhcmdlJyxcbiAgICA1ODA6ICdQcmVjb25kaXRpb24gRmFpbHVyZScsICAvLyBSRkMgMzMxMlxuICAgIDYwMDogJ0J1c3kgRXZlcnl3aGVyZScsXG4gICAgNjAzOiAnRGVjbGluZScsXG4gICAgNjA0OiAnRG9lcyBOb3QgRXhpc3QgQW55d2hlcmUnLFxuICAgIDYwNjogJ05vdCBBY2NlcHRhYmxlJ1xuICB9LFxuXG4gIC8qIFNJUCBPcHRpb24gVGFnc1xuICAgKiBET0M6IGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvc2lwLXBhcmFtZXRlcnMvc2lwLXBhcmFtZXRlcnMueGh0bWwjc2lwLXBhcmFtZXRlcnMtNFxuICAgKi9cbiAgT1BUSU9OX1RBR1M6IHtcbiAgICAnMTAwcmVsJzogICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzMjYyXG4gICAgMTk5OiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNjIyOFxuICAgIGFuc3dlcm1vZGU6ICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDUzNzNcbiAgICAnZWFybHktc2Vzc2lvbic6ICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzOTU5XG4gICAgZXZlbnRsaXN0OiAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDY2MlxuICAgIGV4cGxpY2l0c3ViOiAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDLWlldGYtc2lwY29yZS1yZWZlci1leHBsaWNpdC1zdWJzY3JpcHRpb24tMDNcbiAgICAnZnJvbS1jaGFuZ2UnOiAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA0OTE2XG4gICAgJ2dlb2xvY2F0aW9uLWh0dHAnOiAgICAgICAgIHRydWUsICAvLyBSRkMgNjQ0MlxuICAgICdnZW9sb2NhdGlvbi1zaXAnOiAgICAgICAgICB0cnVlLCAgLy8gUkZDIDY0NDJcbiAgICBnaW46ICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA2MTQwXG4gICAgZ3J1dTogICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNTYyN1xuICAgIGhpc3RpbmZvOiAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDcwNDRcbiAgICBpY2U6ICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1NzY4XG4gICAgam9pbjogICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzkxMVxuICAgICdtdWx0aXBsZS1yZWZlcic6ICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDUzNjhcbiAgICBub3JlZmVyc3ViOiAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA0NDg4XG4gICAgbm9zdWI6ICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMtaWV0Zi1zaXBjb3JlLXJlZmVyLWV4cGxpY2l0LXN1YnNjcmlwdGlvbi0wM1xuICAgIG91dGJvdW5kOiAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDU2MjZcbiAgICBwYXRoOiAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzMzI3XG4gICAgcG9saWN5OiAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNjc5NFxuICAgIHByZWNvbmRpdGlvbjogICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDMzMTJcbiAgICBwcmVmOiAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzODQwXG4gICAgcHJpdmFjeTogICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzMyM1xuICAgICdyZWNpcGllbnQtbGlzdC1pbnZpdGUnOiAgICB0cnVlLCAgLy8gUkZDIDUzNjZcbiAgICAncmVjaXBpZW50LWxpc3QtbWVzc2FnZSc6ICAgdHJ1ZSwgIC8vIFJGQyA1MzY1XG4gICAgJ3JlY2lwaWVudC1saXN0LXN1YnNjcmliZSc6IHRydWUsICAvLyBSRkMgNTM2N1xuICAgIHJlcGxhY2VzOiAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDM4OTFcbiAgICAncmVzb3VyY2UtcHJpb3JpdHknOiAgICAgICAgdHJ1ZSwgIC8vIFJGQyA0NDEyXG4gICAgJ3NkcC1hbmF0JzogICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDA5MlxuICAgICdzZWMtYWdyZWUnOiAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDMzMjlcbiAgICB0ZGlhbG9nOiAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA0NTM4XG4gICAgdGltZXI6ICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDAyOFxuICAgIHV1aTogICAgICAgICAgICAgICAgICAgICAgICB0cnVlICAgLy8gUkZDIDc0MzNcbiAgfVxufTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0NvbnN0YW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXhjZXB0aW9uc1xuICovXG5cbi8qKlxuICogU0lQIEV4Y2VwdGlvbnMuXG4gKiBAYXVnbWVudHMgU0lQXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDb25maWd1cmF0aW9uRXJyb3I6IChmdW5jdGlvbigpe1xuICAgIHZhciBleGNlcHRpb24gPSBmdW5jdGlvbihwYXJhbWV0ZXIsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNvZGUgPSAxO1xuICAgICAgdGhpcy5uYW1lID0gJ0NPTkZJR1VSQVRJT05fRVJST1InO1xuICAgICAgdGhpcy5wYXJhbWV0ZXIgPSBwYXJhbWV0ZXI7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSAoIXRoaXMudmFsdWUpPyAnTWlzc2luZyBwYXJhbWV0ZXI6ICcrIHRoaXMucGFyYW1ldGVyIDogJ0ludmFsaWQgdmFsdWUgJysgSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSkgKycgZm9yIHBhcmFtZXRlciBcIicrIHRoaXMucGFyYW1ldGVyICsnXCInO1xuICAgIH07XG4gICAgZXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgIHJldHVybiBleGNlcHRpb247XG4gIH0oKSksXG5cbiAgSW52YWxpZFN0YXRlRXJyb3I6IChmdW5jdGlvbigpe1xuICAgIHZhciBleGNlcHRpb24gPSBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIHRoaXMuY29kZSA9IDI7XG4gICAgICB0aGlzLm5hbWUgPSAnSU5WQUxJRF9TVEFURV9FUlJPUic7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgIHRoaXMubWVzc2FnZSA9ICdJbnZhbGlkIHN0YXR1czogJyArIHN0YXR1cztcbiAgICB9O1xuICAgIGV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICByZXR1cm4gZXhjZXB0aW9uO1xuICB9KCkpLFxuXG4gIE5vdFN1cHBvcnRlZEVycm9yOiAoZnVuY3Rpb24oKXtcbiAgICB2YXIgZXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgdGhpcy5jb2RlID0gMztcbiAgICAgIHRoaXMubmFtZSA9ICdOT1RfU1VQUE9SVEVEX0VSUk9SJztcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfTtcbiAgICBleGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgcmV0dXJuIGV4Y2VwdGlvbjtcbiAgfSgpKSxcblxuICBHZXREZXNjcmlwdGlvbkVycm9yOiAoZnVuY3Rpb24oKXtcbiAgICB2YXIgZXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgdGhpcy5jb2RlID0gNDtcbiAgICAgIHRoaXMubmFtZSA9ICdHRVRfREVTQ1JJUFRJT05fRVJST1InO1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9O1xuICAgIGV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICByZXR1cm4gZXhjZXB0aW9uO1xuICB9KCkpXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9FeGNlcHRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgVElNRVJTXG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKi9cbnZhclxuICBUMSA9IDUwMCxcbiAgVDIgPSA0MDAwLFxuICBUNCA9IDUwMDA7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aW1lcnMpIHtcbiAgdmFyIFRpbWVycyA9IHtcbiAgICBUMTogVDEsXG4gICAgVDI6IFQyLFxuICAgIFQ0OiBUNCxcbiAgICBUSU1FUl9COiA2NCAqIFQxLFxuICAgIFRJTUVSX0Q6IDAgICogVDEsXG4gICAgVElNRVJfRjogNjQgKiBUMSxcbiAgICBUSU1FUl9IOiA2NCAqIFQxLFxuICAgIFRJTUVSX0k6IDAgICogVDEsXG4gICAgVElNRVJfSjogMCAgKiBUMSxcbiAgICBUSU1FUl9LOiAwICAqIFQ0LFxuICAgIFRJTUVSX0w6IDY0ICogVDEsXG4gICAgVElNRVJfTTogNjQgKiBUMSxcbiAgICBUSU1FUl9OOiA2NCAqIFQxLFxuICAgIFBST1ZJU0lPTkFMX1JFU1BPTlNFX0lOVEVSVkFMOiA2MDAwMCAgLy8gU2VlIFJGQyAzMjYxIFNlY3Rpb24gMTMuMy4xLjFcbiAgfTtcblxuICBbJ3NldFRpbWVvdXQnLCAnY2xlYXJUaW1lb3V0JywgJ3NldEludGVydmFsJywgJ2NsZWFySW50ZXJ2YWwnXVxuICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIGNhbid0IGp1c3QgdXNlIHRpbWVyc1tuYW1lXS5iaW5kKHRpbWVycykgc2luY2UgaXQgYnlwYXNzZXMgamFzbWluZSdzXG4gICAgLy8gY2xvY2stbW9ja2luZ1xuICAgIFRpbWVyc1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aW1lcnNbbmFtZV0uYXBwbHkodGltZXJzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBUaW1lcnM7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9UaW1lcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBNZXNzYWdlIFBhcnNlclxuICovXG5cbi8qKlxuICogRXh0cmFjdCBhbmQgcGFyc2UgZXZlcnkgaGVhZGVyIG9mIGEgU0lQIG1lc3NhZ2UuXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAbmFtZXNwYWNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIFBhcnNlcjtcblxuZnVuY3Rpb24gZ2V0SGVhZGVyKGRhdGEsIGhlYWRlclN0YXJ0KSB7XG4gIHZhclxuICAgIC8vICdzdGFydCcgcG9zaXRpb24gb2YgdGhlIGhlYWRlci5cbiAgICBzdGFydCA9IGhlYWRlclN0YXJ0LFxuICAgIC8vICdlbmQnIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIuXG4gICAgZW5kID0gMCxcbiAgICAvLyAncGFydGlhbCBlbmQnIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIuXG4gICAgcGFydGlhbEVuZCA9IDA7XG5cbiAgLy9FbmQgb2YgbWVzc2FnZS5cbiAgaWYgKGRhdGEuc3Vic3RyaW5nKHN0YXJ0LCBzdGFydCArIDIpLm1hdGNoKC8oXlxcclxcbikvKSkge1xuICAgIHJldHVybiAtMjtcbiAgfVxuXG4gIHdoaWxlKGVuZCA9PT0gMCkge1xuICAgIC8vIFBhcnRpYWwgRW5kIG9mIEhlYWRlci5cbiAgICBwYXJ0aWFsRW5kID0gZGF0YS5pbmRleE9mKCdcXHJcXG4nLCBzdGFydCk7XG5cbiAgICAvLyAnaW5kZXhPZicgcmV0dXJucyAtMSBpZiB0aGUgdmFsdWUgdG8gYmUgZm91bmQgbmV2ZXIgb2NjdXJzLlxuICAgIGlmIChwYXJ0aWFsRW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIHBhcnRpYWxFbmQ7XG4gICAgfVxuXG4gICAgaWYoIWRhdGEuc3Vic3RyaW5nKHBhcnRpYWxFbmQgKyAyLCBwYXJ0aWFsRW5kICsgNCkubWF0Y2goLyheXFxyXFxuKS8pICYmIGRhdGEuY2hhckF0KHBhcnRpYWxFbmQgKyAyKS5tYXRjaCgvKF5cXHMrKS8pKSB7XG4gICAgICAvLyBOb3QgdGhlIGVuZCBvZiB0aGUgbWVzc2FnZS4gQ29udGludWUgZnJvbSB0aGUgbmV4dCBwb3NpdGlvbi5cbiAgICAgIHN0YXJ0ID0gcGFydGlhbEVuZCArIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IHBhcnRpYWxFbmQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVuZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIobWVzc2FnZSwgZGF0YSwgaGVhZGVyU3RhcnQsIGhlYWRlckVuZCkge1xuICB2YXIgaGVhZGVyLCBpZHgsIGxlbmd0aCwgcGFyc2VkLFxuICAgIGhjb2xvbkluZGV4ID0gZGF0YS5pbmRleE9mKCc6JywgaGVhZGVyU3RhcnQpLFxuICAgIGhlYWRlck5hbWUgPSBkYXRhLnN1YnN0cmluZyhoZWFkZXJTdGFydCwgaGNvbG9uSW5kZXgpLnRyaW0oKSxcbiAgICBoZWFkZXJWYWx1ZSA9IGRhdGEuc3Vic3RyaW5nKGhjb2xvbkluZGV4ICsgMSwgaGVhZGVyRW5kKS50cmltKCk7XG5cbiAgLy8gSWYgaGVhZGVyLWZpZWxkIGlzIHdlbGwta25vd24sIHBhcnNlIGl0LlxuICBzd2l0Y2goaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAndmlhJzpcbiAgICBjYXNlICd2JzpcbiAgICAgIG1lc3NhZ2UuYWRkSGVhZGVyKCd2aWEnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBpZihtZXNzYWdlLmdldEhlYWRlcnMoJ3ZpYScpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdWaWEnKTtcbiAgICAgICAgaWYocGFyc2VkKSB7XG4gICAgICAgICAgbWVzc2FnZS52aWEgPSBwYXJzZWQ7XG4gICAgICAgICAgbWVzc2FnZS52aWFfYnJhbmNoID0gcGFyc2VkLmJyYW5jaDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zyb20nOlxuICAgIGNhc2UgJ2YnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ2Zyb20nLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdmcm9tJyk7XG4gICAgICBpZihwYXJzZWQpIHtcbiAgICAgICAgbWVzc2FnZS5mcm9tID0gcGFyc2VkO1xuICAgICAgICBtZXNzYWdlLmZyb21fdGFnID0gcGFyc2VkLmdldFBhcmFtKCd0YWcnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RvJzpcbiAgICBjYXNlICd0JzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCd0bycsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ3RvJyk7XG4gICAgICBpZihwYXJzZWQpIHtcbiAgICAgICAgbWVzc2FnZS50byA9IHBhcnNlZDtcbiAgICAgICAgbWVzc2FnZS50b190YWcgPSBwYXJzZWQuZ2V0UGFyYW0oJ3RhZycpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmVjb3JkLXJvdXRlJzpcbiAgICAgIHBhcnNlZCA9IFNJUC5HcmFtbWFyLnBhcnNlKGhlYWRlclZhbHVlLCAnUmVjb3JkX1JvdXRlJyk7XG5cbiAgICAgIGlmIChwYXJzZWQgPT09IC0xKSB7XG4gICAgICAgIHBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IHBhcnNlZC5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaGVhZGVyID0gcGFyc2VkW2lkeF07XG4gICAgICAgIG1lc3NhZ2UuYWRkSGVhZGVyKCdyZWNvcmQtcm91dGUnLCBoZWFkZXJWYWx1ZS5zdWJzdHJpbmcoaGVhZGVyLnBvc2l0aW9uLCBoZWFkZXIub2Zmc2V0KSk7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyc1snUmVjb3JkLVJvdXRlJ11bbWVzc2FnZS5nZXRIZWFkZXJzKCdyZWNvcmQtcm91dGUnKS5sZW5ndGggLSAxXS5wYXJzZWQgPSBoZWFkZXIucGFyc2VkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2FsbC1pZCc6XG4gICAgY2FzZSAnaSc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcignY2FsbC1pZCcsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2NhbGwtaWQnKTtcbiAgICAgIGlmKHBhcnNlZCkge1xuICAgICAgICBtZXNzYWdlLmNhbGxfaWQgPSBoZWFkZXJWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbnRhY3QnOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcGFyc2VkID0gU0lQLkdyYW1tYXIucGFyc2UoaGVhZGVyVmFsdWUsICdDb250YWN0Jyk7XG5cbiAgICAgIGlmIChwYXJzZWQgPT09IC0xKSB7XG4gICAgICAgIHBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IHBhcnNlZC5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaGVhZGVyID0gcGFyc2VkW2lkeF07XG4gICAgICAgIG1lc3NhZ2UuYWRkSGVhZGVyKCdjb250YWN0JywgaGVhZGVyVmFsdWUuc3Vic3RyaW5nKGhlYWRlci5wb3NpdGlvbiwgaGVhZGVyLm9mZnNldCkpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlcnNbJ0NvbnRhY3QnXVttZXNzYWdlLmdldEhlYWRlcnMoJ2NvbnRhY3QnKS5sZW5ndGggLSAxXS5wYXJzZWQgPSBoZWFkZXIucGFyc2VkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY29udGVudC1sZW5ndGgnOlxuICAgIGNhc2UgJ2wnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignY29udGVudC1sZW5ndGgnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbnRlbnQtdHlwZSc6XG4gICAgY2FzZSAnYyc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcignY29udGVudC10eXBlJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignY29udGVudC10eXBlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjc2VxJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdjc2VxJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignY3NlcScpO1xuICAgICAgaWYocGFyc2VkKSB7XG4gICAgICAgIG1lc3NhZ2UuY3NlcSA9IHBhcnNlZC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXNwb25zZSkge1xuICAgICAgICBtZXNzYWdlLm1ldGhvZCA9IHBhcnNlZC5tZXRob2Q7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtYXgtZm9yd2FyZHMnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ21heC1mb3J3YXJkcycsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ21heC1mb3J3YXJkcycpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnd3d3LWF1dGhlbnRpY2F0ZSc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcignd3d3LWF1dGhlbnRpY2F0ZScsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ3d3dy1hdXRoZW50aWNhdGUnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3Byb3h5LWF1dGhlbnRpY2F0ZSc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcigncHJveHktYXV0aGVudGljYXRlJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcigncHJveHktYXV0aGVudGljYXRlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWZlci10byc6XG4gICAgY2FzZSAncic6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcigncmVmZXItdG8nLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdyZWZlci10bycpO1xuICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICBtZXNzYWdlLnJlZmVyX3RvID0gcGFyc2VkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIERvIG5vdCBwYXJzZSB0aGlzIGhlYWRlci5cbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IDA7XG4gIH1cblxuICBpZiAocGFyc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6ICdlcnJvciBwYXJzaW5nIGhlYWRlciBcIicrIGhlYWRlck5hbWUgKydcIidcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKiBQYXJzZSBTSVAgTWVzc2FnZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBTSVAgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2dnZXIgb2JqZWN0LlxuICogQHJldHVybnMge1NJUC5JbmNvbWluZ1JlcXVlc3R8U0lQLkluY29taW5nUmVzcG9uc2V8dW5kZWZpbmVkfVxuICovXG5QYXJzZXIgPSB7fTtcblBhcnNlci5wYXJzZU1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhLCB1YSkge1xuICB2YXIgbWVzc2FnZSwgZmlyc3RMaW5lLCBjb250ZW50TGVuZ3RoLCBib2R5U3RhcnQsIHBhcnNlZCxcbiAgICBoZWFkZXJTdGFydCA9IDAsXG4gICAgaGVhZGVyRW5kID0gZGF0YS5pbmRleE9mKCdcXHJcXG4nKSxcbiAgICBsb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5wYXJzZXInKTtcblxuICBpZihoZWFkZXJFbmQgPT09IC0xKSB7XG4gICAgbG9nZ2VyLndhcm4oJ25vIENSTEYgZm91bmQsIG5vdCBhIFNJUCBtZXNzYWdlLCBkaXNjYXJkZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBQYXJzZSBmaXJzdCBsaW5lLiBDaGVjayBpZiBpdCBpcyBhIFJlcXVlc3Qgb3IgYSBSZXBseS5cbiAgZmlyc3RMaW5lID0gZGF0YS5zdWJzdHJpbmcoMCwgaGVhZGVyRW5kKTtcbiAgcGFyc2VkID0gU0lQLkdyYW1tYXIucGFyc2UoZmlyc3RMaW5lLCAnUmVxdWVzdF9SZXNwb25zZScpO1xuXG4gIGlmKHBhcnNlZCA9PT0gLTEpIHtcbiAgICBsb2dnZXIud2FybignZXJyb3IgcGFyc2luZyBmaXJzdCBsaW5lIG9mIFNJUCBtZXNzYWdlOiBcIicgKyBmaXJzdExpbmUgKyAnXCInKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZighcGFyc2VkLnN0YXR1c19jb2RlKSB7XG4gICAgbWVzc2FnZSA9IG5ldyBTSVAuSW5jb21pbmdSZXF1ZXN0KHVhKTtcbiAgICBtZXNzYWdlLm1ldGhvZCA9IHBhcnNlZC5tZXRob2Q7XG4gICAgbWVzc2FnZS5ydXJpID0gcGFyc2VkLnVyaTtcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlID0gbmV3IFNJUC5JbmNvbWluZ1Jlc3BvbnNlKHVhKTtcbiAgICBtZXNzYWdlLnN0YXR1c19jb2RlID0gcGFyc2VkLnN0YXR1c19jb2RlO1xuICAgIG1lc3NhZ2UucmVhc29uX3BocmFzZSA9IHBhcnNlZC5yZWFzb25fcGhyYXNlO1xuICB9XG5cbiAgbWVzc2FnZS5kYXRhID0gZGF0YTtcbiAgaGVhZGVyU3RhcnQgPSBoZWFkZXJFbmQgKyAyO1xuXG4gIC8qIExvb3Agb3ZlciBldmVyeSBsaW5lIGluIGRhdGEuIERldGVjdCB0aGUgZW5kIG9mIGVhY2ggaGVhZGVyIGFuZCBwYXJzZVxuICAqIGl0IG9yIHNpbXBseSBhZGQgdG8gdGhlIGhlYWRlcnMgY29sbGVjdGlvbi5cbiAgKi9cbiAgd2hpbGUodHJ1ZSkge1xuICAgIGhlYWRlckVuZCA9IGdldEhlYWRlcihkYXRhLCBoZWFkZXJTdGFydCk7XG5cbiAgICAvLyBUaGUgU0lQIG1lc3NhZ2UgaGFzIG5vcm1hbGx5IGZpbmlzaGVkLlxuICAgIGlmKGhlYWRlckVuZCA9PT0gLTIpIHtcbiAgICAgIGJvZHlTdGFydCA9IGhlYWRlclN0YXJ0ICsgMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBkYXRhLmluZGV4T2YgcmV0dXJuZWQgLTEgZHVlIHRvIGEgbWFsZm9ybWVkIG1lc3NhZ2UuXG4gICAgZWxzZSBpZihoZWFkZXJFbmQgPT09IC0xKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ21hbGZvcm1lZCBtZXNzYWdlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFyc2VkID0gcGFyc2VIZWFkZXIobWVzc2FnZSwgZGF0YSwgaGVhZGVyU3RhcnQsIGhlYWRlckVuZCk7XG5cbiAgICBpZihwYXJzZWQgIT09IHRydWUpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihwYXJzZWQuZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhlYWRlclN0YXJ0ID0gaGVhZGVyRW5kICsgMjtcbiAgfVxuXG4gIC8qIFJGQzMyNjEgMTguMy5cbiAgICogSWYgdGhlcmUgYXJlIGFkZGl0aW9uYWwgYnl0ZXMgaW4gdGhlIHRyYW5zcG9ydCBwYWNrZXRcbiAgICogYmV5b25kIHRoZSBlbmQgb2YgdGhlIGJvZHksIHRoZXkgTVVTVCBiZSBkaXNjYXJkZWQuXG4gICAqL1xuICBpZihtZXNzYWdlLmhhc0hlYWRlcignY29udGVudC1sZW5ndGgnKSkge1xuICAgIGNvbnRlbnRMZW5ndGggPSBtZXNzYWdlLmdldEhlYWRlcignY29udGVudC1sZW5ndGgnKTtcbiAgICBtZXNzYWdlLmJvZHkgPSBkYXRhLnN1YnN0cihib2R5U3RhcnQsIGNvbnRlbnRMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UuYm9keSA9IGRhdGEuc3Vic3RyaW5nKGJvZHlTdGFydCk7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZTtcbn07XG5cblNJUC5QYXJzZXIgPSBQYXJzZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9QYXJzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBNZXNzYWdlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXJcbiAgT3V0Z29pbmdSZXF1ZXN0LFxuICBJbmNvbWluZ01lc3NhZ2UsXG4gIEluY29taW5nUmVxdWVzdCxcbiAgSW5jb21pbmdSZXNwb25zZTtcblxuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkSGVhZGVyIChyZXF1ZXN0KSB7XG4gIHZhciBhbGxvd1VucmVnaXN0ZXJlZCA9IHJlcXVlc3QudWEuY29uZmlndXJhdGlvbi5oYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzO1xuICB2YXIgb3B0aW9uVGFncyA9IFtdO1xuICB2YXIgb3B0aW9uVGFnU2V0ID0ge307XG5cbiAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5SRUdJU1RFUikge1xuICAgIG9wdGlvblRhZ3MucHVzaCgncGF0aCcsICdncnV1Jyk7XG4gIH0gZWxzZSBpZiAocmVxdWVzdC5tZXRob2QgPT09IFNJUC5DLklOVklURSAmJlxuICAgICAgICAgICAgIChyZXF1ZXN0LnVhLmNvbnRhY3QucHViX2dydXUgfHwgcmVxdWVzdC51YS5jb250YWN0LnRlbXBfZ3J1dSkpIHtcbiAgICBvcHRpb25UYWdzLnB1c2goJ2dydXUnKTtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LnVhLmNvbmZpZ3VyYXRpb24ucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgb3B0aW9uVGFncy5wdXNoKCcxMDByZWwnKTtcbiAgfVxuICBpZiAocmVxdWVzdC51YS5jb25maWd1cmF0aW9uLnJlcGxhY2VzID09PSBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgb3B0aW9uVGFncy5wdXNoKCdyZXBsYWNlcycpO1xuICB9XG5cbiAgb3B0aW9uVGFncy5wdXNoKCdvdXRib3VuZCcpO1xuXG4gIG9wdGlvblRhZ3MgPSBvcHRpb25UYWdzLmNvbmNhdChyZXF1ZXN0LnVhLmNvbmZpZ3VyYXRpb24uZXh0cmFTdXBwb3J0ZWQpO1xuXG4gIG9wdGlvblRhZ3MgPSBvcHRpb25UYWdzLmZpbHRlcihmdW5jdGlvbihvcHRpb25UYWcpIHtcbiAgICB2YXIgcmVnaXN0ZXJlZCA9IFNJUC5DLk9QVElPTl9UQUdTW29wdGlvblRhZ107XG4gICAgdmFyIHVuaXF1ZSA9ICFvcHRpb25UYWdTZXRbb3B0aW9uVGFnXTtcbiAgICBvcHRpb25UYWdTZXRbb3B0aW9uVGFnXSA9IHRydWU7XG4gICAgcmV0dXJuIChyZWdpc3RlcmVkIHx8IGFsbG93VW5yZWdpc3RlcmVkKSAmJiB1bmlxdWU7XG4gIH0pO1xuXG4gIHJldHVybiAnU3VwcG9ydGVkOiAnICsgb3B0aW9uVGFncy5qb2luKCcsICcpICsgJ1xcclxcbic7XG59XG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGZvciBvdXRnb2luZyBTSVAgcmVxdWVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgcmVxdWVzdCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBydXJpIHJlcXVlc3QgdXJpXG4gKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVycyB0aGF0IHdpbGwgaGF2ZSBwcmlvcml0eSBvdmVyIHVhLmNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAqIDxicj5cbiAqICAtIGNzZXEsIGNhbGxfaWQsIGZyb21fdGFnLCBmcm9tX3VyaSwgZnJvbV9kaXNwbGF5TmFtZSwgdG9fdXJpLCB0b190YWcsIHJvdXRlX3NldFxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBleHRyYSBoZWFkZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gW2JvZHldXG4gKi9cbk91dGdvaW5nUmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgcnVyaSwgdWEsIHBhcmFtcywgZXh0cmFIZWFkZXJzLCBib2R5KSB7XG4gIHZhclxuICAgIHRvLFxuICAgIGZyb20sXG4gICAgY2FsbF9pZCxcbiAgICBjc2VxLFxuICAgIHRvX3VyaSxcbiAgICBmcm9tX3VyaTtcblxuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgLy8gTWFuZGF0b3J5IHBhcmFtZXRlcnMgY2hlY2tcbiAgaWYoIW1ldGhvZCB8fCAhcnVyaSB8fCAhdWEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuc2lwbWVzc2FnZScpO1xuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMuaGVhZGVycyA9IHt9O1xuICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgdGhpcy5ydXJpID0gcnVyaTtcbiAgdGhpcy5ib2R5ID0gYm9keTtcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSAoZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICB0aGlzLnN0YXR1c0NvZGUgPSBwYXJhbXMuc3RhdHVzX2NvZGU7XG4gIHRoaXMucmVhc29uUGhyYXNlID0gcGFyYW1zLnJlYXNvbl9waHJhc2U7XG5cbiAgLy8gRmlsbCB0aGUgQ29tbW9uIFNJUCBSZXF1ZXN0IEhlYWRlcnNcblxuICAvLyBSb3V0ZVxuICBpZiAocGFyYW1zLnJvdXRlX3NldCkge1xuICAgIHRoaXMuc2V0SGVhZGVyKCdyb3V0ZScsIHBhcmFtcy5yb3V0ZV9zZXQpO1xuICB9IGVsc2UgaWYgKHVhLmNvbmZpZ3VyYXRpb24udXNlUHJlbG9hZGVkUm91dGUpe1xuICAgIHRoaXMuc2V0SGVhZGVyKCdyb3V0ZScsIHVhLnRyYW5zcG9ydC5zZXJ2ZXIuc2lwX3VyaSk7XG4gIH1cblxuICAvLyBWaWFcbiAgLy8gRW1wdHkgVmlhIGhlYWRlci4gV2lsbCBiZSBmaWxsZWQgYnkgdGhlIGNsaWVudCB0cmFuc2FjdGlvbi5cbiAgdGhpcy5zZXRIZWFkZXIoJ3ZpYScsICcnKTtcblxuICAvLyBNYXgtRm9yd2FyZHNcbiAgdGhpcy5zZXRIZWFkZXIoJ21heC1mb3J3YXJkcycsIFNJUC5VQS5DLk1BWF9GT1JXQVJEUyk7XG5cbiAgLy8gVG9cbiAgdG9fdXJpID0gcGFyYW1zLnRvX3VyaSB8fCBydXJpO1xuICB0byA9IChwYXJhbXMudG9fZGlzcGxheU5hbWUgfHwgcGFyYW1zLnRvX2Rpc3BsYXlOYW1lID09PSAwKSA/ICdcIicgKyBwYXJhbXMudG9fZGlzcGxheU5hbWUgKyAnXCIgJyA6ICcnO1xuICB0byArPSAnPCcgKyAodG9fdXJpICYmIHRvX3VyaS50b1JhdyA/IHRvX3VyaS50b1JhdygpIDogdG9fdXJpKSArICc+JztcbiAgdG8gKz0gcGFyYW1zLnRvX3RhZyA/ICc7dGFnPScgKyBwYXJhbXMudG9fdGFnIDogJyc7XG4gIHRoaXMudG8gPSBuZXcgU0lQLk5hbWVBZGRySGVhZGVyLnBhcnNlKHRvKTtcbiAgdGhpcy5zZXRIZWFkZXIoJ3RvJywgdG8pO1xuXG4gIC8vIEZyb21cbiAgZnJvbV91cmkgPSBwYXJhbXMuZnJvbV91cmkgfHwgdWEuY29uZmlndXJhdGlvbi51cmk7XG4gIGlmIChwYXJhbXMuZnJvbV9kaXNwbGF5TmFtZSB8fCBwYXJhbXMuZnJvbV9kaXNwbGF5TmFtZSA9PT0gMCkge1xuICAgIGZyb20gPSAnXCInICsgcGFyYW1zLmZyb21fZGlzcGxheU5hbWUgKyAnXCIgJztcbiAgfSBlbHNlIGlmICh1YS5jb25maWd1cmF0aW9uLmRpc3BsYXlOYW1lKSB7XG4gICAgZnJvbSA9ICdcIicgKyB1YS5jb25maWd1cmF0aW9uLmRpc3BsYXlOYW1lICsgJ1wiICc7XG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9ICcnO1xuICB9XG4gIGZyb20gKz0gJzwnICsgKGZyb21fdXJpICYmIGZyb21fdXJpLnRvUmF3ID8gZnJvbV91cmkudG9SYXcoKSA6IGZyb21fdXJpKSArICc+O3RhZz0nO1xuICBmcm9tICs9IHBhcmFtcy5mcm9tX3RhZyB8fCBTSVAuVXRpbHMubmV3VGFnKCk7XG4gIHRoaXMuZnJvbSA9IG5ldyBTSVAuTmFtZUFkZHJIZWFkZXIucGFyc2UoZnJvbSk7XG4gIHRoaXMuc2V0SGVhZGVyKCdmcm9tJywgZnJvbSk7XG5cbiAgLy8gQ2FsbC1JRFxuICBjYWxsX2lkID0gcGFyYW1zLmNhbGxfaWQgfHwgKHVhLmNvbmZpZ3VyYXRpb24uc2lwanNJZCArIFNJUC5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbigxNSkpO1xuICB0aGlzLmNhbGxfaWQgPSBjYWxsX2lkO1xuICB0aGlzLnNldEhlYWRlcignY2FsbC1pZCcsIGNhbGxfaWQpO1xuXG4gIC8vIENTZXFcbiAgY3NlcSA9IHBhcmFtcy5jc2VxIHx8IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgdGhpcy5jc2VxID0gY3NlcTtcbiAgdGhpcy5zZXRIZWFkZXIoJ2NzZXEnLCBjc2VxICsgJyAnICsgbWV0aG9kKTtcbn07XG5cbk91dGdvaW5nUmVxdWVzdC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSB0aGUgZ2l2ZW4gaGVhZGVyIGJ5IHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gdmFsdWUgaGVhZGVyIHZhbHVlXG4gICAqL1xuICBzZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldID0gKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpID8gdmFsdWUgOiBbdmFsdWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBoZWFkZXIgbmFtZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtTdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgaGVhZGVyLCB1bmRlZmluZWQgaWYgaGVhZGVyIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBnZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgcmVnZXhwLCBpZHgsXG4gICAgICBsZW5ndGggPSB0aGlzLmV4dHJhSGVhZGVycy5sZW5ndGgsXG4gICAgICBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV07XG5cbiAgICBpZihoZWFkZXIpIHtcbiAgICAgIGlmKGhlYWRlclswXSkge1xuICAgICAgICByZXR1cm4gaGVhZGVyWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWdleHAgPSBuZXcgUmVnRXhwKCdeXFxcXHMqJyArIG5hbWUgKyAnXFxcXHMqOicsJ2knKTtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBoZWFkZXIgPSB0aGlzLmV4dHJhSGVhZGVyc1tpZHhdO1xuICAgICAgICBpZiAocmVnZXhwLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICAgIHJldHVybiBoZWFkZXIuc3Vic3RyaW5nKGhlYWRlci5pbmRleE9mKCc6JykrMSkudHJpbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhlYWRlci9zIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IHdpdGggYWxsIHRoZSBoZWFkZXJzIG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICovXG4gIGdldEhlYWRlcnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaWR4LCBsZW5ndGgsIHJlZ2V4cCxcbiAgICAgIGhlYWRlciA9IHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgaWYoaGVhZGVyKSB7XG4gICAgICBsZW5ndGggPSBoZWFkZXIubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGhlYWRlcltpZHhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRoaXMuZXh0cmFIZWFkZXJzLmxlbmd0aDtcbiAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ15cXFxccyonICsgbmFtZSArICdcXFxccyo6JywnaScpO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGhlYWRlciA9IHRoaXMuZXh0cmFIZWFkZXJzW2lkeF07XG4gICAgICAgIGlmIChyZWdleHAudGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaGVhZGVyLnN1YnN0cmluZyhoZWFkZXIuaW5kZXhPZignOicpKzEpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBoZWFkZXIgd2l0aCBnaXZlbiBuYW1lIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBoYXNIZWFkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgcmVnZXhwLCBpZHgsXG4gICAgICBsZW5ndGggPSB0aGlzLmV4dHJhSGVhZGVycy5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxzKicgKyBuYW1lICsgJ1xcXFxzKjonLCdpJyk7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KHRoaXMuZXh0cmFIZWFkZXJzW2lkeF0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtc2cgPSAnJywgaGVhZGVyLCBsZW5ndGgsIGlkeDtcblxuICAgIG1zZyArPSB0aGlzLm1ldGhvZCArICcgJyArICh0aGlzLnJ1cmkudG9SYXcgPyB0aGlzLnJ1cmkudG9SYXcoKSA6IHRoaXMucnVyaSkgKyAnIFNJUC8yLjBcXHJcXG4nO1xuXG4gICAgZm9yIChoZWFkZXIgaW4gdGhpcy5oZWFkZXJzKSB7XG4gICAgICBsZW5ndGggPSB0aGlzLmhlYWRlcnNbaGVhZGVyXS5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgbXNnICs9IGhlYWRlciArICc6ICcgKyB0aGlzLmhlYWRlcnNbaGVhZGVyXVtpZHhdICsgJ1xcclxcbic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGVuZ3RoID0gdGhpcy5leHRyYUhlYWRlcnMubGVuZ3RoO1xuICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgbXNnICs9IHRoaXMuZXh0cmFIZWFkZXJzW2lkeF0udHJpbSgpICsnXFxyXFxuJztcbiAgICB9XG5cbiAgICBtc2cgKz0gZ2V0U3VwcG9ydGVkSGVhZGVyKHRoaXMpO1xuICAgIG1zZyArPSAnVXNlci1BZ2VudDogJyArIHRoaXMudWEuY29uZmlndXJhdGlvbi51c2VyQWdlbnRTdHJpbmcgKydcXHJcXG4nO1xuXG4gICAgaWYodGhpcy5ib2R5KSB7XG4gICAgICBsZW5ndGggPSBTSVAuVXRpbHMuc3RyX3V0ZjhfbGVuZ3RoKHRoaXMuYm9keSk7XG4gICAgICBtc2cgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAnICsgbGVuZ3RoICsgJ1xcclxcblxcclxcbic7XG4gICAgICBtc2cgKz0gdGhpcy5ib2R5O1xuICAgIH0gZWxzZSB7XG4gICAgICBtc2cgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAwXFxyXFxuXFxyXFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gbXNnO1xuICB9XG59O1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBmb3IgaW5jb21pbmcgU0lQIG1lc3NhZ2UuXG4gKi9cbkluY29taW5nTWVzc2FnZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZGF0YSA9IG51bGw7XG4gIHRoaXMuaGVhZGVycyA9IG51bGw7XG4gIHRoaXMubWV0aG9kID0gIG51bGw7XG4gIHRoaXMudmlhID0gbnVsbDtcbiAgdGhpcy52aWFfYnJhbmNoID0gbnVsbDtcbiAgdGhpcy5jYWxsX2lkID0gbnVsbDtcbiAgdGhpcy5jc2VxID0gbnVsbDtcbiAgdGhpcy5mcm9tID0gbnVsbDtcbiAgdGhpcy5mcm9tX3RhZyA9IG51bGw7XG4gIHRoaXMudG8gPSBudWxsO1xuICB0aGlzLnRvX3RhZyA9IG51bGw7XG4gIHRoaXMuYm9keSA9IG51bGw7XG59O1xuXG5JbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlID0ge1xuICAvKipcbiAgKiBJbnNlcnQgYSBoZWFkZXIgb2YgdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlIGludG8gdGhlIGxhc3QgcG9zaXRpb24gb2YgdGhlXG4gICogaGVhZGVyIGFycmF5LlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGhlYWRlciB2YWx1ZVxuICAqL1xuICBhZGRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGhlYWRlciA9IHsgcmF3OiB2YWx1ZSB9O1xuXG4gICAgbmFtZSA9IFNJUC5VdGlscy5oZWFkZXJpemUobmFtZSk7XG5cbiAgICBpZih0aGlzLmhlYWRlcnNbbmFtZV0pIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tuYW1lXS5wdXNoKGhlYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tuYW1lXSA9IFtoZWFkZXJdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyIG5hbWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUgc3BlY2lmaWVkIGhlYWRlciwgbnVsbCBpZiBoZWFkZXIgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGdldEhlYWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV07XG5cbiAgICBpZihoZWFkZXIpIHtcbiAgICAgIGlmKGhlYWRlclswXSkge1xuICAgICAgICByZXR1cm4gaGVhZGVyWzBdLnJhdztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBoZWFkZXIvcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge0FycmF5fSBBcnJheSB3aXRoIGFsbCB0aGUgaGVhZGVycyBvZiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gICAqL1xuICBnZXRIZWFkZXJzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGlkeCwgbGVuZ3RoLFxuICAgICAgaGVhZGVyID0gdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgICBpZighaGVhZGVyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGVuZ3RoID0gaGVhZGVyLmxlbmd0aDtcbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGhlYWRlcltpZHhdLnJhdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogVmVyaWZ5IHRoZSBleGlzdGVuY2Ugb2YgdGhlIGdpdmVuIGhlYWRlci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaGVhZGVyIHdpdGggZ2l2ZW4gbmFtZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgaGFzSGVhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuKHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSkgPyB0cnVlIDogZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBvbiB0aGUgZ2l2ZW4gaW5kZXguXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgKiBAcGFyYW0ge051bWJlcn0gW2lkeD0wXSBoZWFkZXIgaW5kZXhcbiAgKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH0gUGFyc2VkIGhlYWRlciBvYmplY3QsIHVuZGVmaW5lZCBpZiB0aGUgaGVhZGVyIGlzIG5vdCBwcmVzZW50IG9yIGluIGNhc2Ugb2YgYSBwYXJzaW5nIGVycm9yLlxuICAqL1xuICBwYXJzZUhlYWRlcjogZnVuY3Rpb24obmFtZSwgaWR4KSB7XG4gICAgdmFyIGhlYWRlciwgdmFsdWUsIHBhcnNlZDtcblxuICAgIG5hbWUgPSBTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpO1xuXG4gICAgaWR4ID0gaWR4IHx8IDA7XG5cbiAgICBpZighdGhpcy5oZWFkZXJzW25hbWVdKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ2hlYWRlciBcIicgKyBuYW1lICsgJ1wiIG5vdCBwcmVzZW50Jyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmKGlkeCA+PSB0aGlzLmhlYWRlcnNbbmFtZV0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ25vdCBzbyBtYW55IFwiJyArIG5hbWUgKyAnXCIgaGVhZGVycyBwcmVzZW50Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGVhZGVyID0gdGhpcy5oZWFkZXJzW25hbWVdW2lkeF07XG4gICAgdmFsdWUgPSBoZWFkZXIucmF3O1xuXG4gICAgaWYoaGVhZGVyLnBhcnNlZCkge1xuICAgICAgcmV0dXJuIGhlYWRlci5wYXJzZWQ7XG4gICAgfVxuXG4gICAgLy9zdWJzdGl0dXRlICctJyBieSAnXycgZm9yIGdyYW1tYXIgcnVsZSBtYXRjaGluZy5cbiAgICBwYXJzZWQgPSBTSVAuR3JhbW1hci5wYXJzZSh2YWx1ZSwgbmFtZS5yZXBsYWNlKC8tL2csICdfJykpO1xuXG4gICAgaWYocGFyc2VkID09PSAtMSkge1xuICAgICAgdGhpcy5oZWFkZXJzW25hbWVdLnNwbGljZShpZHgsIDEpOyAvL2RlbGV0ZSBmcm9tIGhlYWRlcnNcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2Vycm9yIHBhcnNpbmcgXCInICsgbmFtZSArICdcIiBoZWFkZXIgZmllbGQgd2l0aCB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIicpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIucGFyc2VkID0gcGFyc2VkO1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lc3NhZ2UgSGVhZGVyIGF0dHJpYnV0ZSBzZWxlY3Rvci4gQWxpYXMgb2YgcGFyc2VIZWFkZXIuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaWR4PTBdIGhlYWRlciBpbmRleFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH0gUGFyc2VkIGhlYWRlciBvYmplY3QsIHVuZGVmaW5lZCBpZiB0aGUgaGVhZGVyIGlzIG5vdCBwcmVzZW50IG9yIGluIGNhc2Ugb2YgYSBwYXJzaW5nIGVycm9yLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBtZXNzYWdlLnMoJ3ZpYScsMykucG9ydFxuICAgKi9cbiAgczogZnVuY3Rpb24obmFtZSwgaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VIZWFkZXIobmFtZSwgaWR4KTtcbiAgfSxcblxuICAvKipcbiAgKiBSZXBsYWNlIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyIGJ5IHRoZSB2YWx1ZS5cbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBoZWFkZXIgdmFsdWVcbiAgKi9cbiAgc2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBoZWFkZXIgPSB7IHJhdzogdmFsdWUgfTtcbiAgICB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV0gPSBbaGVhZGVyXTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBAYXVnbWVudHMgSW5jb21pbmdNZXNzYWdlXG4gKiBAY2xhc3MgQ2xhc3MgZm9yIGluY29taW5nIFNJUCByZXF1ZXN0LlxuICovXG5JbmNvbWluZ1JlcXVlc3QgPSBmdW5jdGlvbih1YSkge1xuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnNpcG1lc3NhZ2UnKTtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgdGhpcy5ydXJpID0gbnVsbDtcbiAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB0aGlzLnNlcnZlcl90cmFuc2FjdGlvbiA9IG51bGw7XG59O1xuSW5jb21pbmdSZXF1ZXN0LnByb3RvdHlwZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2UoKTtcblxuLyoqXG4qIFN0YXRlZnVsIHJlcGx5LlxuKiBAcGFyYW0ge051bWJlcn0gY29kZSBzdGF0dXMgY29kZVxuKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIHJlYXNvbiBwaHJhc2VcbiogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgZXh0cmEgaGVhZGVyc1xuKiBAcGFyYW0ge1N0cmluZ30gYm9keSBib2R5XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIG9uU3VjY2VzcyBjYWxsYmFja1xuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GYWlsdXJlXSBvbkZhaWx1cmUgY2FsbGJhY2tcbiovXG5JbmNvbWluZ1JlcXVlc3QucHJvdG90eXBlLnJlcGx5ID0gZnVuY3Rpb24oY29kZSwgcmVhc29uLCBleHRyYUhlYWRlcnMsIGJvZHksIG9uU3VjY2Vzcywgb25GYWlsdXJlKSB7XG4gIHZhciByciwgdmlhcywgbGVuZ3RoLCBpZHgsIHJlc3BvbnNlLFxuICAgIHRvID0gdGhpcy5nZXRIZWFkZXIoJ1RvJyksXG4gICAgciA9IDAsXG4gICAgdiA9IDA7XG5cbiAgcmVzcG9uc2UgPSBTSVAuVXRpbHMuYnVpbGRTdGF0dXNMaW5lKGNvZGUsIHJlYXNvbik7XG4gIGV4dHJhSGVhZGVycyA9IChleHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgaWYodGhpcy5tZXRob2QgPT09IFNJUC5DLklOVklURSAmJiBjb2RlID4gMTAwICYmIGNvZGUgPD0gMjAwKSB7XG4gICAgcnIgPSB0aGlzLmdldEhlYWRlcnMoJ3JlY29yZC1yb3V0ZScpO1xuICAgIGxlbmd0aCA9IHJyLmxlbmd0aDtcblxuICAgIGZvcihyOyByIDwgbGVuZ3RoOyByKyspIHtcbiAgICAgIHJlc3BvbnNlICs9ICdSZWNvcmQtUm91dGU6ICcgKyBycltyXSArICdcXHJcXG4nO1xuICAgIH1cbiAgfVxuXG4gIHZpYXMgPSB0aGlzLmdldEhlYWRlcnMoJ3ZpYScpO1xuICBsZW5ndGggPSB2aWFzLmxlbmd0aDtcblxuICBmb3IodjsgdiA8IGxlbmd0aDsgdisrKSB7XG4gICAgcmVzcG9uc2UgKz0gJ1ZpYTogJyArIHZpYXNbdl0gKyAnXFxyXFxuJztcbiAgfVxuXG4gIGlmKCF0aGlzLnRvX3RhZyAmJiBjb2RlID4gMTAwKSB7XG4gICAgdG8gKz0gJzt0YWc9JyArIFNJUC5VdGlscy5uZXdUYWcoKTtcbiAgfSBlbHNlIGlmKHRoaXMudG9fdGFnICYmICF0aGlzLnMoJ3RvJykuaGFzUGFyYW0oJ3RhZycpKSB7XG4gICAgdG8gKz0gJzt0YWc9JyArIHRoaXMudG9fdGFnO1xuICB9XG5cbiAgcmVzcG9uc2UgKz0gJ1RvOiAnICsgdG8gKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0Zyb206ICcgKyB0aGlzLmdldEhlYWRlcignRnJvbScpICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdDYWxsLUlEOiAnICsgdGhpcy5jYWxsX2lkICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdDU2VxOiAnICsgdGhpcy5jc2VxICsgJyAnICsgdGhpcy5tZXRob2QgKyAnXFxyXFxuJztcblxuICBsZW5ndGggPSBleHRyYUhlYWRlcnMubGVuZ3RoO1xuICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICByZXNwb25zZSArPSBleHRyYUhlYWRlcnNbaWR4XS50cmltKCkgKydcXHJcXG4nO1xuICB9XG5cbiAgcmVzcG9uc2UgKz0gZ2V0U3VwcG9ydGVkSGVhZGVyKHRoaXMpO1xuICByZXNwb25zZSArPSAnVXNlci1BZ2VudDogJyArIHRoaXMudWEuY29uZmlndXJhdGlvbi51c2VyQWdlbnRTdHJpbmcgKydcXHJcXG4nO1xuXG4gIGlmKGJvZHkpIHtcbiAgICBsZW5ndGggPSBTSVAuVXRpbHMuc3RyX3V0ZjhfbGVuZ3RoKGJvZHkpO1xuICAgIHJlc3BvbnNlICs9ICdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL3NkcFxcclxcbic7XG4gICAgcmVzcG9uc2UgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAnICsgbGVuZ3RoICsgJ1xcclxcblxcclxcbic7XG4gICAgcmVzcG9uc2UgKz0gYm9keTtcbiAgfSBlbHNlIHtcbiAgICByZXNwb25zZSArPSAnQ29udGVudC1MZW5ndGg6ICcgKyAwICsgJ1xcclxcblxcclxcbic7XG4gIH1cblxuICB0aGlzLnNlcnZlcl90cmFuc2FjdGlvbi5yZWNlaXZlUmVzcG9uc2UoY29kZSwgcmVzcG9uc2UpLnRoZW4ob25TdWNjZXNzLCBvbkZhaWx1cmUpO1xuXG4gIHJldHVybiByZXNwb25zZTtcbn07XG5cbi8qKlxuKiBTdGF0ZWxlc3MgcmVwbHkuXG4qIEBwYXJhbSB7TnVtYmVyfSBjb2RlIHN0YXR1cyBjb2RlXG4qIEBwYXJhbSB7U3RyaW5nfSByZWFzb24gcmVhc29uIHBocmFzZVxuKi9cbkluY29taW5nUmVxdWVzdC5wcm90b3R5cGUucmVwbHlfc2wgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgdmFyIHRvLCByZXNwb25zZSxcbiAgICB2ID0gMCxcbiAgICB2aWFzID0gdGhpcy5nZXRIZWFkZXJzKCd2aWEnKSxcbiAgICBsZW5ndGggPSB2aWFzLmxlbmd0aDtcblxuICByZXNwb25zZSA9IFNJUC5VdGlscy5idWlsZFN0YXR1c0xpbmUoY29kZSwgcmVhc29uKTtcblxuICBmb3IodjsgdiA8IGxlbmd0aDsgdisrKSB7XG4gICAgcmVzcG9uc2UgKz0gJ1ZpYTogJyArIHZpYXNbdl0gKyAnXFxyXFxuJztcbiAgfVxuXG4gIHRvID0gdGhpcy5nZXRIZWFkZXIoJ1RvJyk7XG5cbiAgaWYoIXRoaXMudG9fdGFnICYmIGNvZGUgPiAxMDApIHtcbiAgICB0byArPSAnO3RhZz0nICsgU0lQLlV0aWxzLm5ld1RhZygpO1xuICB9IGVsc2UgaWYodGhpcy50b190YWcgJiYgIXRoaXMucygndG8nKS5oYXNQYXJhbSgndGFnJykpIHtcbiAgICB0byArPSAnO3RhZz0nICsgdGhpcy50b190YWc7XG4gIH1cblxuICByZXNwb25zZSArPSAnVG86ICcgKyB0byArICdcXHJcXG4nO1xuICByZXNwb25zZSArPSAnRnJvbTogJyArIHRoaXMuZ2V0SGVhZGVyKCdGcm9tJykgKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0NhbGwtSUQ6ICcgKyB0aGlzLmNhbGxfaWQgKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0NTZXE6ICcgKyB0aGlzLmNzZXEgKyAnICcgKyB0aGlzLm1ldGhvZCArICdcXHJcXG4nO1xuICByZXNwb25zZSArPSAnVXNlci1BZ2VudDogJyArIHRoaXMudWEuY29uZmlndXJhdGlvbi51c2VyQWdlbnRTdHJpbmcgKydcXHJcXG4nO1xuICByZXNwb25zZSArPSAnQ29udGVudC1MZW5ndGg6ICcgKyAwICsgJ1xcclxcblxcclxcbic7XG5cbiAgdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSk7XG59O1xuXG5cbi8qKlxuICogQGF1Z21lbnRzIEluY29taW5nTWVzc2FnZVxuICogQGNsYXNzIENsYXNzIGZvciBpbmNvbWluZyBTSVAgcmVzcG9uc2UuXG4gKi9cbkluY29taW5nUmVzcG9uc2UgPSBmdW5jdGlvbih1YSkge1xuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnNpcG1lc3NhZ2UnKTtcbiAgdGhpcy5oZWFkZXJzID0ge307XG4gIHRoaXMuc3RhdHVzX2NvZGUgPSBudWxsO1xuICB0aGlzLnJlYXNvbl9waHJhc2UgPSBudWxsO1xufTtcbkluY29taW5nUmVzcG9uc2UucHJvdG90eXBlID0gbmV3IEluY29taW5nTWVzc2FnZSgpO1xuXG5TSVAuT3V0Z29pbmdSZXF1ZXN0ID0gT3V0Z29pbmdSZXF1ZXN0O1xuU0lQLkluY29taW5nUmVxdWVzdCA9IEluY29taW5nUmVxdWVzdDtcblNJUC5JbmNvbWluZ1Jlc3BvbnNlID0gSW5jb21pbmdSZXNwb25zZTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1NJUE1lc3NhZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBVUklcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIFNJUCBVUkkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtzY2hlbWVdXG4gKiBAcGFyYW0ge1N0cmluZ30gW3VzZXJdXG4gKiBAcGFyYW0ge1N0cmluZ30gaG9zdFxuICogQHBhcmFtIHtTdHJpbmd9IFtwb3J0XVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgVVJJO1xuXG5VUkkgPSBmdW5jdGlvbihzY2hlbWUsIHVzZXIsIGhvc3QsIHBvcnQsIHBhcmFtZXRlcnMsIGhlYWRlcnMpIHtcbiAgdmFyIHBhcmFtLCBoZWFkZXIsIHJhdywgbm9ybWFsO1xuXG4gIC8vIENoZWNrc1xuICBpZighaG9zdCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3Npbmcgb3IgaW52YWxpZCBcImhvc3RcIiBwYXJhbWV0ZXInKTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgcGFyYW1ldGVyc1xuICBzY2hlbWUgPSBzY2hlbWUgfHwgU0lQLkMuU0lQO1xuICB0aGlzLnBhcmFtZXRlcnMgPSB7fTtcbiAgdGhpcy5oZWFkZXJzID0ge307XG5cbiAgZm9yIChwYXJhbSBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5zZXRQYXJhbShwYXJhbSwgcGFyYW1ldGVyc1twYXJhbV0pO1xuICB9XG5cbiAgZm9yIChoZWFkZXIgaW4gaGVhZGVycykge1xuICAgIHRoaXMuc2V0SGVhZGVyKGhlYWRlciwgaGVhZGVyc1toZWFkZXJdKTtcbiAgfVxuXG4gIC8vIFJhdyBVUklcbiAgcmF3ID0ge1xuICAgIHNjaGVtZTogc2NoZW1lLFxuICAgIHVzZXI6IHVzZXIsXG4gICAgaG9zdDogaG9zdCxcbiAgICBwb3J0OiBwb3J0XG4gIH07XG5cbiAgLy8gTm9ybWFsaXplZCBVUklcbiAgbm9ybWFsID0ge1xuICAgIHNjaGVtZTogc2NoZW1lLnRvTG93ZXJDYXNlKCksXG4gICAgdXNlcjogdXNlcixcbiAgICBob3N0OiBob3N0LnRvTG93ZXJDYXNlKCksXG4gICAgcG9ydDogcG9ydFxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBfbm9ybWFsOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsOyB9XG4gICAgfSxcblxuICAgIF9yYXc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiByYXc7IH1cbiAgICB9LFxuXG4gICAgc2NoZW1lOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsLnNjaGVtZTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmF3LnNjaGVtZSA9IHZhbHVlO1xuICAgICAgICBub3JtYWwuc2NoZW1lID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXNlcjoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbC51c2VyOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBub3JtYWwudXNlciA9IHJhdy51c2VyID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhvc3Q6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWwuaG9zdDsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmF3Lmhvc3QgPSB2YWx1ZTtcbiAgICAgICAgbm9ybWFsLmhvc3QgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhb3I6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWwudXNlciArICdAJyArIG5vcm1hbC5ob3N0OyB9XG4gICAgfSxcblxuICAgIHBvcnQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWwucG9ydDsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgbm9ybWFsLnBvcnQgPSByYXcucG9ydCA9IHZhbHVlID09PSAwID8gdmFsdWUgOiAocGFyc2VJbnQodmFsdWUsMTApIHx8IG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5VUkkucHJvdG90eXBlID0ge1xuICBzZXRQYXJhbTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmKGtleSkge1xuICAgICAgdGhpcy5wYXJhbWV0ZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9ICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSA/IG51bGwgOiB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9LFxuXG4gIGdldFBhcmFtOiBmdW5jdGlvbihrZXkpIHtcbiAgICBpZihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgfSxcblxuICBoYXNQYXJhbTogZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYoa2V5KSB7XG4gICAgICByZXR1cm4gKHRoaXMucGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShrZXkudG9Mb3dlckNhc2UoKSkgJiYgdHJ1ZSkgfHwgZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIGRlbGV0ZVBhcmFtOiBmdW5jdGlvbihwYXJhbWV0ZXIpIHtcbiAgICB2YXIgdmFsdWU7XG4gICAgcGFyYW1ldGVyID0gcGFyYW1ldGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRoaXMucGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdO1xuICAgICAgZGVsZXRlIHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBjbGVhclBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge307XG4gIH0sXG5cbiAgc2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSA9ICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgfSxcblxuICBnZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldO1xuICAgIH1cbiAgfSxcblxuICBoYXNIZWFkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZihuYW1lKSB7XG4gICAgICByZXR1cm4gKHRoaXMuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpKSAmJiB0cnVlKSB8fCBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgZGVsZXRlSGVhZGVyOiBmdW5jdGlvbihoZWFkZXIpIHtcbiAgICB2YXIgdmFsdWU7XG4gICAgaGVhZGVyID0gU0lQLlV0aWxzLmhlYWRlcml6ZShoZWFkZXIpO1xuICAgIGlmKHRoaXMuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoZWFkZXIpKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuaGVhZGVyc1toZWFkZXJdO1xuICAgICAgZGVsZXRlIHRoaXMuaGVhZGVyc1toZWFkZXJdO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBjbGVhckhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFVSSShcbiAgICAgIHRoaXMuX3Jhdy5zY2hlbWUsXG4gICAgICB0aGlzLl9yYXcudXNlcixcbiAgICAgIHRoaXMuX3Jhdy5ob3N0LFxuICAgICAgdGhpcy5fcmF3LnBvcnQsXG4gICAgICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGFyYW1ldGVycykpLFxuICAgICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmhlYWRlcnMpKSk7XG4gIH0sXG5cbiAgdG9SYXc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90b1N0cmluZyh0aGlzLl9yYXcpO1xuICB9LFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9TdHJpbmcodGhpcy5fbm9ybWFsKTtcbiAgfSxcblxuICBfdG9TdHJpbmc6IGZ1bmN0aW9uKHVyaSkge1xuICAgIHZhciBoZWFkZXIsIHBhcmFtZXRlciwgaWR4LCB1cmlTdHJpbmcsIGhlYWRlcnMgPSBbXTtcblxuICAgIHVyaVN0cmluZyAgPSB1cmkuc2NoZW1lICsgJzonO1xuICAgIC8vIGFkZCBzbGFzaGVzIGlmIGl0J3Mgbm90IGEgc2lwKHMpIFVSSVxuICAgIGlmICghdXJpLnNjaGVtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKFwiXnNpcHM/JFwiKSkge1xuICAgICAgdXJpU3RyaW5nICs9IFwiLy9cIjtcbiAgICB9XG4gICAgaWYgKHVyaS51c2VyKSB7XG4gICAgICB1cmlTdHJpbmcgKz0gU0lQLlV0aWxzLmVzY2FwZVVzZXIodXJpLnVzZXIpICsgJ0AnO1xuICAgIH1cbiAgICB1cmlTdHJpbmcgKz0gdXJpLmhvc3Q7XG4gICAgaWYgKHVyaS5wb3J0IHx8IHVyaS5wb3J0ID09PSAwKSB7XG4gICAgICB1cmlTdHJpbmcgKz0gJzonICsgdXJpLnBvcnQ7XG4gICAgfVxuXG4gICAgZm9yIChwYXJhbWV0ZXIgaW4gdGhpcy5wYXJhbWV0ZXJzKSB7XG4gICAgICB1cmlTdHJpbmcgKz0gJzsnICsgcGFyYW1ldGVyO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl0gIT09IG51bGwpIHtcbiAgICAgICAgdXJpU3RyaW5nICs9ICc9JysgdGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKGhlYWRlciBpbiB0aGlzLmhlYWRlcnMpIHtcbiAgICAgIGZvcihpZHggaW4gdGhpcy5oZWFkZXJzW2hlYWRlcl0pIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGhlYWRlciArICc9JyArIHRoaXMuaGVhZGVyc1toZWFkZXJdW2lkeF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVyaVN0cmluZyArPSAnPycgKyBoZWFkZXJzLmpvaW4oJyYnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJpU3RyaW5nO1xuICB9XG59O1xuXG5cbi8qKlxuICAqIFBhcnNlIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgYSBTSVAuVVJJIGluc3RhbmNlIG9yIHVuZGVmaW5lZCBpZlxuICAqIGl0IGlzIGFuIGludmFsaWQgVVJJLlxuICAqIEBwdWJsaWNcbiAgKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gICovXG5VUkkucGFyc2UgPSBmdW5jdGlvbih1cmkpIHtcbiAgdXJpID0gU0lQLkdyYW1tYXIucGFyc2UodXJpLCdTSVBfVVJJJyk7XG5cbiAgaWYgKHVyaSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdXJpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cblNJUC5VUkkgPSBVUkk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9VUkkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBOYW1lQWRkckhlYWRlclxuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGEgTmFtZSBBZGRyZXNzIFNJUCBoZWFkZXIuXG4gKlxuICogQHBhcmFtIHtTSVAuVVJJfSB1cmlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZGlzcGxheU5hbWVdXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBOYW1lQWRkckhlYWRlcjtcblxuTmFtZUFkZHJIZWFkZXIgPSBmdW5jdGlvbih1cmksIGRpc3BsYXlOYW1lLCBwYXJhbWV0ZXJzKSB7XG4gIHZhciBwYXJhbTtcblxuICAvLyBDaGVja3NcbiAgaWYoIXVyaSB8fCAhKHVyaSBpbnN0YW5jZW9mIFNJUC5VUkkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBvciBpbnZhbGlkIFwidXJpXCIgcGFyYW1ldGVyJyk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHBhcmFtZXRlcnNcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMucGFyYW1ldGVycyA9IHt9O1xuXG4gIGZvciAocGFyYW0gaW4gcGFyYW1ldGVycykge1xuICAgIHRoaXMuc2V0UGFyYW0ocGFyYW0sIHBhcmFtZXRlcnNbcGFyYW1dKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBmcmllbmRseU5hbWU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRpc3BsYXlOYW1lIHx8IHVyaS5hb3I7IH1cbiAgICB9LFxuXG4gICAgZGlzcGxheU5hbWU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBkaXNwbGF5TmFtZTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgZGlzcGxheU5hbWUgPSAodmFsdWUgPT09IDApID8gJzAnIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5OYW1lQWRkckhlYWRlci5wcm90b3R5cGUgPSB7XG4gIHNldFBhcmFtOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmKGtleSkge1xuICAgICAgdGhpcy5wYXJhbWV0ZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9ICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSA/IG51bGwgOiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgfSxcbiAgZ2V0UGFyYW06IFNJUC5VUkkucHJvdG90eXBlLmdldFBhcmFtLFxuICBoYXNQYXJhbTogU0lQLlVSSS5wcm90b3R5cGUuaGFzUGFyYW0sXG4gIGRlbGV0ZVBhcmFtOiBTSVAuVVJJLnByb3RvdHlwZS5kZWxldGVQYXJhbSxcbiAgY2xlYXJQYXJhbXM6IFNJUC5VUkkucHJvdG90eXBlLmNsZWFyUGFyYW1zLFxuXG4gIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE5hbWVBZGRySGVhZGVyKFxuICAgICAgdGhpcy51cmkuY2xvbmUoKSxcbiAgICAgIHRoaXMuZGlzcGxheU5hbWUsXG4gICAgICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGFyYW1ldGVycykpKTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvZHksIHBhcmFtZXRlcjtcblxuICAgIGJvZHkgID0gKHRoaXMuZGlzcGxheU5hbWUgfHwgdGhpcy5kaXNwbGF5TmFtZSA9PT0gMCkgPyAnXCInICsgdGhpcy5kaXNwbGF5TmFtZSArICdcIiAnIDogJyc7XG4gICAgYm9keSArPSAnPCcgKyB0aGlzLnVyaS50b1N0cmluZygpICsgJz4nO1xuXG4gICAgZm9yIChwYXJhbWV0ZXIgaW4gdGhpcy5wYXJhbWV0ZXJzKSB7XG4gICAgICBib2R5ICs9ICc7JyArIHBhcmFtZXRlcjtcblxuICAgICAgaWYgKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdICE9PSBudWxsKSB7XG4gICAgICAgIGJvZHkgKz0gJz0nKyB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYm9keTtcbiAgfVxufTtcblxuXG4vKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIGEgU0lQLk5hbWVBZGRySGVhZGVyIGluc3RhbmNlIG9yIHVuZGVmaW5lZCBpZlxuICAqIGl0IGlzIGFuIGludmFsaWQgTmFtZUFkZHJIZWFkZXIuXG4gICogQHB1YmxpY1xuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lX2FkZHJfaGVhZGVyXG4gICovXG5OYW1lQWRkckhlYWRlci5wYXJzZSA9IGZ1bmN0aW9uKG5hbWVfYWRkcl9oZWFkZXIpIHtcbiAgbmFtZV9hZGRyX2hlYWRlciA9IFNJUC5HcmFtbWFyLnBhcnNlKG5hbWVfYWRkcl9oZWFkZXIsJ05hbWVfQWRkcl9IZWFkZXInKTtcblxuICBpZiAobmFtZV9hZGRyX2hlYWRlciAhPT0gLTEpIHtcbiAgICByZXR1cm4gbmFtZV9hZGRyX2hlYWRlcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG5TSVAuTmFtZUFkZHJIZWFkZXIgPSBOYW1lQWRkckhlYWRlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL05hbWVBZGRySGVhZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgVHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBTSVAgVHJhbnNhY3Rpb25zIG1vZHVsZS5cbiAqIEBhdWdtZW50cyBTSVBcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXJcbiAgQyA9IHtcbiAgICAvLyBUcmFuc2FjdGlvbiBzdGF0ZXNcbiAgICBTVEFUVVNfVFJZSU5HOiAgICAgMSxcbiAgICBTVEFUVVNfUFJPQ0VFRElORzogMixcbiAgICBTVEFUVVNfQ0FMTElORzogICAgMyxcbiAgICBTVEFUVVNfQUNDRVBURUQ6ICAgNCxcbiAgICBTVEFUVVNfQ09NUExFVEVEOiAgNSxcbiAgICBTVEFUVVNfVEVSTUlOQVRFRDogNixcbiAgICBTVEFUVVNfQ09ORklSTUVEOiAgNyxcblxuICAgIC8vIFRyYW5zYWN0aW9uIHR5cGVzXG4gICAgTk9OX0lOVklURV9DTElFTlQ6ICduaWN0JyxcbiAgICBOT05fSU5WSVRFX1NFUlZFUjogJ25pc3QnLFxuICAgIElOVklURV9DTElFTlQ6ICdpY3QnLFxuICAgIElOVklURV9TRVJWRVI6ICdpc3QnXG4gIH07XG5cbmZ1bmN0aW9uIGJ1aWxkVmlhSGVhZGVyIChyZXF1ZXN0X3NlbmRlciwgdHJhbnNwb3J0LCBpZCkge1xuICB2YXIgdmlhO1xuICB2aWEgPSAnU0lQLzIuMC8nICsgKHJlcXVlc3Rfc2VuZGVyLnVhLmNvbmZpZ3VyYXRpb24uaGFja1ZpYVRjcCA/ICdUQ1AnIDogdHJhbnNwb3J0LnNlcnZlci5zY2hlbWUpO1xuICB2aWEgKz0gJyAnICsgcmVxdWVzdF9zZW5kZXIudWEuY29uZmlndXJhdGlvbi52aWFIb3N0ICsgJzticmFuY2g9JyArIGlkO1xuICBpZiAocmVxdWVzdF9zZW5kZXIudWEuY29uZmlndXJhdGlvbi5mb3JjZVJwb3J0KSB7XG4gICAgdmlhICs9ICc7cnBvcnQnO1xuICB9XG4gIHJldHVybiB2aWE7XG59XG5cbi8qKlxuKiBAYXVnbWVudHMgU0lQLlRyYW5zYWN0aW9uc1xuKiBAY2xhc3MgTm9uIEludml0ZSBDbGllbnQgVHJhbnNhY3Rpb25cbiogQHBhcmFtIHtTSVAuUmVxdWVzdFNlbmRlcn0gcmVxdWVzdF9zZW5kZXJcbiogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fSByZXF1ZXN0XG4qIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0XG4qL1xudmFyIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocmVxdWVzdF9zZW5kZXIsIHJlcXVlc3QsIHRyYW5zcG9ydCkge1xuICB2YXIgdmlhO1xuXG4gIHRoaXMudHlwZSA9IEMuTk9OX0lOVklURV9DTElFTlQ7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLmlkID0gJ3o5aEc0YksnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyID0gcmVxdWVzdF9zZW5kZXI7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgdGhpcy5sb2dnZXIgPSByZXF1ZXN0X3NlbmRlci51YS5nZXRMb2dnZXIoJ3NpcC50cmFuc2FjdGlvbi5uaWN0JywgdGhpcy5pZCk7XG5cbiAgdmlhID0gYnVpbGRWaWFIZWFkZXIocmVxdWVzdF9zZW5kZXIsIHRyYW5zcG9ydCwgdGhpcy5pZCk7XG4gIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoJ3ZpYScsIHZpYSk7XG5cbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5uZXdUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZWQnKTtcbn07XG5cbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ciA9IHRoaXM7XG5cbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVFJZSU5HKTtcbiAgdGhpcy5GID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0YuYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfRik7XG5cbiAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5yZXF1ZXN0KSkge1xuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG59O1xuXG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ3RyYW5zcG9ydCBlcnJvciBvY2N1cnJlZCwgZGVsZXRpbmcgbm9uLUlOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkYpO1xuICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkspO1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIub25UcmFuc3BvcnRFcnJvcigpO1xufTtcblxuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0YgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCdUaW1lciBGIGV4cGlyZWQgZm9yIG5vbi1JTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLm9uUmVxdWVzdFRpbWVvdXQoKTtcbn07XG5cbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9LID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5cbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICB2YXJcbiAgICB0ciA9IHRoaXMsXG4gICAgc3RhdHVzX2NvZGUgPSByZXNwb25zZS5zdGF0dXNfY29kZTtcblxuICBpZihzdGF0dXNfY29kZSA8IDIwMCkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1RSWUlORzpcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfUFJPQ0VFRElORyk7XG4gICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1RSWUlORzpcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQ09NUExFVEVEKTtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5GKTtcblxuICAgICAgICBpZihzdGF0dXNfY29kZSA9PT0gNDA4KSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5LID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0suYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfSyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlNUQVRVU19DT01QTEVURUQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8qKlxuKiBAYXVnbWVudHMgU0lQLlRyYW5zYWN0aW9uc1xuKiBAY2xhc3MgSW52aXRlIENsaWVudCBUcmFuc2FjdGlvblxuKiBAcGFyYW0ge1NJUC5SZXF1ZXN0U2VuZGVyfSByZXF1ZXN0X3NlbmRlclxuKiBAcGFyYW0ge1NJUC5PdXRnb2luZ1JlcXVlc3R9IHJlcXVlc3RcbiogQHBhcmFtIHtTSVAuVHJhbnNwb3J0fSB0cmFuc3BvcnRcbiovXG52YXIgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24gPSBmdW5jdGlvbihyZXF1ZXN0X3NlbmRlciwgcmVxdWVzdCwgdHJhbnNwb3J0KSB7XG4gIHZhciB2aWEsXG4gICAgdHIgPSB0aGlzO1xuXG4gIHRoaXMudHlwZSA9IEMuSU5WSVRFX0NMSUVOVDtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMuaWQgPSAnejloRzRiSycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIgPSByZXF1ZXN0X3NlbmRlcjtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcblxuICB0aGlzLmxvZ2dlciA9IHJlcXVlc3Rfc2VuZGVyLnVhLmdldExvZ2dlcignc2lwLnRyYW5zYWN0aW9uLmljdCcsIHRoaXMuaWQpO1xuXG4gIHZpYSA9IGJ1aWxkVmlhSGVhZGVyKHJlcXVlc3Rfc2VuZGVyLCB0cmFuc3BvcnQsIHRoaXMuaWQpO1xuICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKCd2aWEnLCB2aWEpO1xuXG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEubmV3VHJhbnNhY3Rpb24odGhpcyk7XG5cbiAgLy8gQWRkIHRoZSBjYW5jZWwgcHJvcGVydHkgdG8gdGhlIHJlcXVlc3QuXG4gIC8vV2lsbCBiZSBjYWxsZWQgZnJvbSB0aGUgcmVxdWVzdCBpbnN0YW5jZSwgbm90IHRoZSB0cmFuc2FjdGlvbiBpdHNlbGYuXG4gIHRoaXMucmVxdWVzdC5jYW5jZWwgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICB0ci5jYW5jZWxfcmVxdWVzdCh0ciwgcmVhc29uKTtcbiAgfTtcbn07XG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZWQnKTtcbn07XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ciA9IHRoaXM7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX0NBTExJTkcpO1xuICB0aGlzLkIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfQi5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9CKTtcblxuICBpZighdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLnJlcXVlc3QpKSB7XG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cbn07XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygndHJhbnNwb3J0IGVycm9yIG9jY3VycmVkLCBkZWxldGluZyBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5CKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5EKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5NKTtcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuXG4gIGlmICh0aGlzLnN0YXRlICE9PSBDLlNUQVRVU19BQ0NFUFRFRCkge1xuICAgIHRoaXMucmVxdWVzdF9zZW5kZXIub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG59O1xuXG4vLyBSRkMgNjAyNiA3LjJcbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9NID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgTSBleHBpcmVkIGZvciBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcblxuICBpZih0aGlzLnN0YXRlID09PSBDLlNUQVRVU19BQ0NFUFRFRCkge1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuQik7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gICAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gIH1cbn07XG5cbi8vIFJGQyAzMjYxIDE3LjEuMVxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCdUaW1lciBCIGV4cGlyZWQgZm9yIElOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuICBpZih0aGlzLnN0YXRlID09PSBDLlNUQVRVU19DQUxMSU5HKSB7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gICAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5vblJlcXVlc3RUaW1lb3V0KCk7XG4gIH1cbn07XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9EID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgRCBleHBpcmVkIGZvciBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5CKTtcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xufTtcblxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnNlbmRBQ0sgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICB2YXIgdHIgPSB0aGlzO1xuXG4gIHRoaXMuYWNrID0gJ0FDSyAnICsgdGhpcy5yZXF1ZXN0LnJ1cmkgKyAnIFNJUC8yLjBcXHJcXG4nO1xuICB0aGlzLmFjayArPSAnVmlhOiAnICsgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1ZpYSddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcblxuICBpZih0aGlzLnJlcXVlc3QuaGVhZGVyc1snUm91dGUnXSkge1xuICAgIHRoaXMuYWNrICs9ICdSb3V0ZTogJyArIHRoaXMucmVxdWVzdC5oZWFkZXJzWydSb3V0ZSddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgfVxuXG4gIHRoaXMuYWNrICs9ICdUbzogJyArIHJlc3BvbnNlLmdldEhlYWRlcigndG8nKSArICdcXHJcXG4nO1xuICB0aGlzLmFjayArPSAnRnJvbTogJyArIHRoaXMucmVxdWVzdC5oZWFkZXJzWydGcm9tJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB0aGlzLmFjayArPSAnQ2FsbC1JRDogJyArIHRoaXMucmVxdWVzdC5oZWFkZXJzWydDYWxsLUlEJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB0aGlzLmFjayArPSAnQ29udGVudC1MZW5ndGg6IDBcXHJcXG4nO1xuICB0aGlzLmFjayArPSAnQ1NlcTogJyArIHRoaXMucmVxdWVzdC5oZWFkZXJzWydDU2VxJ10udG9TdHJpbmcoKS5zcGxpdCgnICcpWzBdO1xuICB0aGlzLmFjayArPSAnIEFDS1xcclxcblxcclxcbic7XG5cbiAgdGhpcy5EID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0QuYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfRCk7XG5cbiAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLmFjayk7XG59O1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuY2FuY2VsX3JlcXVlc3QgPSBmdW5jdGlvbih0ciwgcmVhc29uKSB7XG4gIHZhciByZXF1ZXN0ID0gdHIucmVxdWVzdDtcblxuICB0aGlzLmNhbmNlbCA9IFNJUC5DLkNBTkNFTCArICcgJyArIHJlcXVlc3QucnVyaSArICcgU0lQLzIuMFxcclxcbic7XG4gIHRoaXMuY2FuY2VsICs9ICdWaWE6ICcgKyByZXF1ZXN0LmhlYWRlcnNbJ1ZpYSddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcblxuICBpZih0aGlzLnJlcXVlc3QuaGVhZGVyc1snUm91dGUnXSkge1xuICAgIHRoaXMuY2FuY2VsICs9ICdSb3V0ZTogJyArIHJlcXVlc3QuaGVhZGVyc1snUm91dGUnXS50b1N0cmluZygpICsgJ1xcclxcbic7XG4gIH1cblxuICB0aGlzLmNhbmNlbCArPSAnVG86ICcgKyByZXF1ZXN0LmhlYWRlcnNbJ1RvJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB0aGlzLmNhbmNlbCArPSAnRnJvbTogJyArIHJlcXVlc3QuaGVhZGVyc1snRnJvbSddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgdGhpcy5jYW5jZWwgKz0gJ0NhbGwtSUQ6ICcgKyByZXF1ZXN0LmhlYWRlcnNbJ0NhbGwtSUQnXS50b1N0cmluZygpICsgJ1xcclxcbic7XG4gIHRoaXMuY2FuY2VsICs9ICdDU2VxOiAnICsgcmVxdWVzdC5oZWFkZXJzWydDU2VxJ10udG9TdHJpbmcoKS5zcGxpdCgnICcpWzBdICtcbiAgJyBDQU5DRUxcXHJcXG4nO1xuXG4gIGlmKHJlYXNvbikge1xuICAgIHRoaXMuY2FuY2VsICs9ICdSZWFzb246ICcgKyByZWFzb24gKyAnXFxyXFxuJztcbiAgfVxuXG4gIHRoaXMuY2FuY2VsICs9ICdDb250ZW50LUxlbmd0aDogMFxcclxcblxcclxcbic7XG5cbiAgLy8gU2VuZCBvbmx5IGlmIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UgKD4xMDApIGhhcyBiZWVuIHJlY2VpdmVkLlxuICBpZih0aGlzLnN0YXRlID09PSBDLlNUQVRVU19QUk9DRUVESU5HKSB7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLmNhbmNlbCk7XG4gIH1cbn07XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICB2YXJcbiAgdHIgPSB0aGlzLFxuICBzdGF0dXNfY29kZSA9IHJlc3BvbnNlLnN0YXR1c19jb2RlO1xuXG4gIGlmKHN0YXR1c19jb2RlID49IDEwMCAmJiBzdGF0dXNfY29kZSA8PSAxOTkpIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19DQUxMSU5HOlxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19QUk9DRUVESU5HKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBpZih0aGlzLmNhbmNlbCkge1xuICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5jYW5jZWwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIGlmKHN0YXR1c19jb2RlID49IDIwMCAmJiBzdGF0dXNfY29kZSA8PSAyOTkpIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19DQUxMSU5HOlxuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19BQ0NFUFRFRCk7XG4gICAgICAgIHRoaXMuTSA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9NLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX00pO1xuICAgICAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlNUQVRVU19BQ0NFUFRFRDpcbiAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSBpZihzdGF0dXNfY29kZSA+PSAzMDAgJiYgc3RhdHVzX2NvZGUgPD0gNjk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ0FMTElORzpcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQ09NUExFVEVEKTtcbiAgICAgICAgdGhpcy5zZW5kQUNLKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ09NUExFVEVEOlxuICAgICAgICB0aGlzLnNlbmRBQ0socmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQLlRyYW5zYWN0aW9uc1xuICogQGNsYXNzIEFDSyBDbGllbnQgVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U0lQLlJlcXVlc3RTZW5kZXJ9IHJlcXVlc3Rfc2VuZGVyXG4gKiBAcGFyYW0ge1NJUC5PdXRnb2luZ1JlcXVlc3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0XG4gKi9cbnZhciBBY2tDbGllbnRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHJlcXVlc3Rfc2VuZGVyLCByZXF1ZXN0LCB0cmFuc3BvcnQpIHtcbiAgdmFyIHZpYTtcblxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdGhpcy5pZCA9ICd6OWhHNGJLJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlciA9IHJlcXVlc3Rfc2VuZGVyO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuXG4gIHRoaXMubG9nZ2VyID0gcmVxdWVzdF9zZW5kZXIudWEuZ2V0TG9nZ2VyKCdzaXAudHJhbnNhY3Rpb24ubmljdCcsIHRoaXMuaWQpO1xuXG4gIHZpYSA9IGJ1aWxkVmlhSGVhZGVyKHJlcXVlc3Rfc2VuZGVyLCB0cmFuc3BvcnQsIHRoaXMuaWQpO1xuICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKCd2aWEnLCB2aWEpO1xufTtcbkFja0NsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG5BY2tDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCkge1xuICBpZighdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLnJlcXVlc3QpKSB7XG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cbn07XG5cbkFja0NsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygndHJhbnNwb3J0IGVycm9yIG9jY3VycmVkLCBmb3IgYW4gQUNLIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIub25UcmFuc3BvcnRFcnJvcigpO1xufTtcblxuXG4vKipcbiogQGF1Z21lbnRzIFNJUC5UcmFuc2FjdGlvbnNcbiogQGNsYXNzIE5vbiBJbnZpdGUgU2VydmVyIFRyYW5zYWN0aW9uXG4qIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdH0gcmVxdWVzdFxuKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiovXG52YXIgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24gPSBmdW5jdGlvbihyZXF1ZXN0LCB1YSkge1xuICB0aGlzLnR5cGUgPSBDLk5PTl9JTlZJVEVfU0VSVkVSO1xuICB0aGlzLmlkID0gcmVxdWVzdC52aWFfYnJhbmNoO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICB0aGlzLnRyYW5zcG9ydCA9IHJlcXVlc3QudHJhbnNwb3J0O1xuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMubGFzdF9yZXNwb25zZSA9ICcnO1xuICByZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbiA9IHRoaXM7XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC50cmFuc2FjdGlvbi5uaXN0JywgdGhpcy5pZCk7XG5cbiAgdGhpcy5zdGF0ZSA9IEMuU1RBVFVTX1RSWUlORztcblxuICB1YS5uZXdUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZWQnKTtcbn07XG5cbk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9KID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgSiBleHBpcmVkIGZvciBub24tSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5cbk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy50cmFuc3BvcnRFcnJvcikge1xuICAgIHRoaXMudHJhbnNwb3J0RXJyb3IgPSB0cnVlO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKCd0cmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQsIGRlbGV0aW5nIG5vbi1JTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcblxuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuSik7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gICAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gIH1cbn07XG5cbk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihzdGF0dXNfY29kZSwgcmVzcG9uc2UpIHtcbiAgdmFyIHRyID0gdGhpcztcbiAgdmFyIGRlZmVycmVkID0gU0lQLlV0aWxzLmRlZmVyKCk7XG5cbiAgaWYoc3RhdHVzX2NvZGUgPT09IDEwMCkge1xuICAgIC8qIFJGQyA0MzIwIDQuMVxuICAgICAqICdBIFNJUCBlbGVtZW50IE1VU1QgTk9UXG4gICAgICogc2VuZCBhbnkgcHJvdmlzaW9uYWwgcmVzcG9uc2Ugd2l0aCBhXG4gICAgICogU3RhdHVzLUNvZGUgb3RoZXIgdGhhbiAxMDAgdG8gYSBub24tSU5WSVRFIHJlcXVlc3QuJ1xuICAgICAqL1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1RSWUlORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfUFJPQ0VFRElORyk7XG4gICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKSkgIHtcbiAgICAgICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5sYXN0X3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKSkge1xuICAgICAgICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSBpZihzdGF0dXNfY29kZSA+PSAyMDAgJiYgc3RhdHVzX2NvZGUgPD0gNjk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfVFJZSU5HOlxuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19DT01QTEVURUQpO1xuICAgICAgICB0aGlzLmxhc3RfcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5KID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0ouYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfSik7XG4gICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKSkge1xuICAgICAgICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ09NUExFVEVEOlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuKiBAYXVnbWVudHMgU0lQLlRyYW5zYWN0aW9uc1xuKiBAY2xhc3MgSW52aXRlIFNlcnZlciBUcmFuc2FjdGlvblxuKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3RcbiogQHBhcmFtIHtTSVAuVUF9IHVhXG4qL1xudmFyIEludml0ZVNlcnZlclRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocmVxdWVzdCwgdWEpIHtcbiAgdGhpcy50eXBlID0gQy5JTlZJVEVfU0VSVkVSO1xuICB0aGlzLmlkID0gcmVxdWVzdC52aWFfYnJhbmNoO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICB0aGlzLnRyYW5zcG9ydCA9IHJlcXVlc3QudHJhbnNwb3J0O1xuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMubGFzdF9yZXNwb25zZSA9ICcnO1xuICByZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbiA9IHRoaXM7XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC50cmFuc2FjdGlvbi5pc3QnLCB0aGlzLmlkKTtcblxuICB0aGlzLnN0YXRlID0gQy5TVEFUVVNfUFJPQ0VFRElORztcblxuICB1YS5uZXdUcmFuc2FjdGlvbih0aGlzKTtcblxuICB0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPSBudWxsO1xuXG4gIHJlcXVlc3QucmVwbHkoMTAwKTtcbn07XG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZWQnKTtcbn07XG5cbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9IID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgSCBleHBpcmVkIGZvciBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcblxuICBpZih0aGlzLnN0YXRlID09PSBDLlNUQVRVU19DT01QTEVURUQpIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCd0cmFuc2FjdGlvbnMnLCAnQUNLIGZvciBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uIHdhcyBuZXZlciByZWNlaXZlZCwgY2FsbCB3aWxsIGJlIHRlcm1pbmF0ZWQnKTtcbiAgfVxuXG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5cbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9JID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5cbi8vIFJGQyA2MDI2IDcuMVxuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0wgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCdUaW1lciBMIGV4cGlyZWQgZm9yIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuXG4gIGlmKHRoaXMuc3RhdGUgPT09IEMuU1RBVFVTX0FDQ0VQVEVEKSB7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gICAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gIH1cbn07XG5cbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy50cmFuc3BvcnRFcnJvcikge1xuICAgIHRoaXMudHJhbnNwb3J0RXJyb3IgPSB0cnVlO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKCd0cmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQsIGRlbGV0aW5nIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuXG4gICAgaWYgKHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciAhPT0gbnVsbCkge1xuICAgICAgU0lQLlRpbWVycy5jbGVhckludGVydmFsKHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lcik7XG4gICAgICB0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuTCk7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5IKTtcbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkkpO1xuXG4gICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gICAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gIH1cbn07XG5cbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZXNlbmRfcHJvdmlzaW9uYWwgPSBmdW5jdGlvbigpIHtcbiAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5sYXN0X3Jlc3BvbnNlKSkge1xuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG59O1xuXG4vLyBJTlZJVEUgU2VydmVyIFRyYW5zYWN0aW9uIFJGQyAzMjYxIDE3LjIuMVxuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uKHN0YXR1c19jb2RlLCByZXNwb25zZSkge1xuICB2YXIgdHIgPSB0aGlzO1xuICB2YXIgZGVmZXJyZWQgPSBTSVAuVXRpbHMuZGVmZXIoKTtcblxuICBpZihzdGF0dXNfY29kZSA+PSAxMDAgJiYgc3RhdHVzX2NvZGUgPD0gMTk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0X3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmKHN0YXR1c19jb2RlID4gMTAwICYmIHN0YXR1c19jb2RlIDw9IDE5OSAmJiB0aGlzLnN0YXRlID09PSBDLlNUQVRVU19QUk9DRUVESU5HKSB7XG4gICAgLy8gVHJpZ2dlciB0aGUgcmVzZW5kUHJvdmlzaW9uYWxUaW1lciBvbmx5IGZvciB0aGUgZmlyc3Qgbm9uIDEwMCBwcm92aXNpb25hbCByZXNwb25zZS5cbiAgICBpZih0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciA9IFNJUC5UaW1lcnMuc2V0SW50ZXJ2YWwodHIucmVzZW5kX3Byb3Zpc2lvbmFsLmJpbmQodHIpLFxuICAgICAgICBTSVAuVGltZXJzLlBST1ZJU0lPTkFMX1JFU1BPTlNFX0lOVEVSVkFMKTtcbiAgICB9XG4gIH0gZWxzZSBpZihzdGF0dXNfY29kZSA+PSAyMDAgJiYgc3RhdHVzX2NvZGUgPD0gMjk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQUNDRVBURUQpO1xuICAgICAgICB0aGlzLmxhc3RfcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5MID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0wuYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfTCk7XG5cbiAgICAgICAgaWYgKHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJJbnRlcnZhbCh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIpO1xuICAgICAgICAgIHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlIEMuU1RBVFVTX0FDQ0VQVEVEOlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHBvaW50IHdpbGwgYmUgcmVhY2hlZCBmb3IgcHJvY2VlZGluZyB0ci5zdGF0ZSBhbHNvLlxuICAgICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSBpZihzdGF0dXNfY29kZSA+PSAzMDAgJiYgc3RhdHVzX2NvZGUgPD0gNjk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgaWYgKHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJJbnRlcnZhbCh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIpO1xuICAgICAgICAgIHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSkpIHtcbiAgICAgICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19DT01QTEVURUQpO1xuICAgICAgICAgIHRoaXMuSCA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9ILmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0gpO1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiAqIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdH0gcmVxdWVzdFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBJTlZJVEU6XG4gKiAgX3RydWVfIGlmIHJldHJhbnNtaXNzaW9uXG4gKiAgX2ZhbHNlXyBuZXcgcmVxdWVzdFxuICpcbiAqIEFDSzpcbiAqICBfdHJ1ZV8gIEFDSyB0byBub24yeHggcmVzcG9uc2VcbiAqICBfZmFsc2VfIEFDSyBtdXN0IGJlIHBhc3NlZCB0byBUVSAoYWNjZXB0ZWQgc3RhdGUpXG4gKiAgICAgICAgICBBQ0sgdG8gMnh4IHJlc3BvbnNlXG4gKlxuICogQ0FOQ0VMOlxuICogIF90cnVlXyAgbm8gbWF0Y2hpbmcgaW52aXRlIHRyYW5zYWN0aW9uXG4gKiAgX2ZhbHNlXyBtYXRjaGluZyBpbnZpdGUgdHJhbnNhY3Rpb24gYW5kIG5vIGZpbmFsIHJlc3BvbnNlIHNlbnRcbiAqXG4gKiBPVEhFUjpcbiAqICBfdHJ1ZV8gIHJldHJhbnNtaXNzaW9uXG4gKiAgX2ZhbHNlXyBuZXcgcmVxdWVzdFxuICovXG52YXIgY2hlY2tUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHVhLCByZXF1ZXN0KSB7XG4gIHZhciB0cjtcblxuICBzd2l0Y2gocmVxdWVzdC5tZXRob2QpIHtcbiAgICBjYXNlIFNJUC5DLklOVklURTpcbiAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLmlzdFtyZXF1ZXN0LnZpYV9icmFuY2hdO1xuICAgICAgaWYodHIpIHtcbiAgICAgICAgc3dpdGNoKHRyLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICAgICAgdHIudHJhbnNwb3J0LnNlbmQodHIubGFzdF9yZXNwb25zZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gUkZDIDYwMjYgNy4xIEludml0ZSByZXRyYW5zbWlzc2lvblxuICAgICAgICAgICAgLy9yZWNlaXZlZCB3aGlsZSBpbiBDLlNUQVRVU19BQ0NFUFRFRCBzdGF0ZS4gQWJzb3JiIGl0LlxuICAgICAgICAgIGNhc2UgQy5TVEFUVVNfQUNDRVBURUQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0lQLkMuQUNLOlxuICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMuaXN0W3JlcXVlc3QudmlhX2JyYW5jaF07XG5cbiAgICAgIC8vIFJGQyA2MDI2IDcuMVxuICAgICAgaWYodHIpIHtcbiAgICAgICAgaWYodHIuc3RhdGUgPT09IEMuU1RBVFVTX0FDQ0VQVEVEKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYodHIuc3RhdGUgPT09IEMuU1RBVFVTX0NPTVBMRVRFRCkge1xuICAgICAgICAgIHRyLnN0YXRlID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgICAgIHRyLkkgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfSS5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9JKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBQ0sgdG8gMlhYIFJlc3BvbnNlLlxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0lQLkMuQ0FOQ0VMOlxuICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMuaXN0W3JlcXVlc3QudmlhX2JyYW5jaF07XG4gICAgICBpZih0cikge1xuICAgICAgICByZXF1ZXN0LnJlcGx5X3NsKDIwMCk7XG4gICAgICAgIGlmKHRyLnN0YXRlID09PSBDLlNUQVRVU19QUk9DRUVESU5HKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0LnJlcGx5X3NsKDQ4MSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcblxuICAgICAgLy8gTm9uLUlOVklURSBTZXJ2ZXIgVHJhbnNhY3Rpb24gUkZDIDMyNjEgMTcuMi4yXG4gICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5uaXN0W3JlcXVlc3QudmlhX2JyYW5jaF07XG4gICAgICBpZih0cikge1xuICAgICAgICBzd2l0Y2godHIuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlIEMuU1RBVFVTX1RSWUlORzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgICBjYXNlIEMuU1RBVFVTX0NPTVBMRVRFRDpcbiAgICAgICAgICAgIHRyLnRyYW5zcG9ydC5zZW5kKHRyLmxhc3RfcmVzcG9uc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuU0lQLlRyYW5zYWN0aW9ucyA9IHtcbiAgQzogQyxcbiAgY2hlY2tUcmFuc2FjdGlvbjogY2hlY2tUcmFuc2FjdGlvbixcbiAgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb246IE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLFxuICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbjogSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sXG4gIEFja0NsaWVudFRyYW5zYWN0aW9uOiBBY2tDbGllbnRUcmFuc2FjdGlvbixcbiAgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb246IE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLFxuICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbjogSW52aXRlU2VydmVyVHJhbnNhY3Rpb25cbn07XG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1RyYW5zYWN0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIERpYWxvZ1xuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGEgU0lQIGRpYWxvZy5cbiAqIEBwYXJhbSB7U0lQLlJUQ1Nlc3Npb259IG93bmVyXG4gKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R8U0lQLkluY29taW5nUmVzcG9uc2V9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7RW51bX0gdHlwZSBVQUMgLyBVQVNcbiAqIEBwYXJhbSB7RW51bX0gc3RhdGUgU0lQLkRpYWxvZy5DLlNUQVRVU19FQVJMWSAvIFNJUC5EaWFsb2cuQy5TVEFUVVNfQ09ORklSTUVEXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuXG52YXIgUmVxdWVzdFNlbmRlciA9IHJlcXVpcmUoJy4vRGlhbG9nL1JlcXVlc3RTZW5kZXInKShTSVApO1xuXG52YXIgRGlhbG9nLFxuICBDID0ge1xuICAgIC8vIERpYWxvZyBzdGF0ZXNcbiAgICBTVEFUVVNfRUFSTFk6ICAgICAgIDEsXG4gICAgU1RBVFVTX0NPTkZJUk1FRDogICAyXG4gIH07XG5cbi8vIFJGQyAzMjYxIDEyLjFcbkRpYWxvZyA9IGZ1bmN0aW9uKG93bmVyLCBtZXNzYWdlLCB0eXBlLCBzdGF0ZSkge1xuICB2YXIgY29udGFjdDtcblxuICB0aGlzLnVhY19wZW5kaW5nX3JlcGx5ID0gZmFsc2U7XG4gIHRoaXMudWFzX3BlbmRpbmdfcmVwbHkgPSBmYWxzZTtcblxuICBpZighbWVzc2FnZS5oYXNIZWFkZXIoJ2NvbnRhY3QnKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogJ3VuYWJsZSB0byBjcmVhdGUgYSBEaWFsb2cgd2l0aG91dCBDb250YWN0IGhlYWRlciBmaWVsZCdcbiAgICB9O1xuICB9XG5cbiAgaWYobWVzc2FnZSBpbnN0YW5jZW9mIFNJUC5JbmNvbWluZ1Jlc3BvbnNlKSB7XG4gICAgc3RhdGUgPSAobWVzc2FnZS5zdGF0dXNfY29kZSA8IDIwMCkgPyBDLlNUQVRVU19FQVJMWSA6IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgfSBlbHNlIHtcbiAgICAvLyBDcmVhdGUgY29uZmlybWVkIGRpYWxvZyBpZiBzdGF0ZSBpcyBub3QgZGVmaW5lZFxuICAgIHN0YXRlID0gc3RhdGUgfHwgQy5TVEFUVVNfQ09ORklSTUVEO1xuICB9XG5cbiAgY29udGFjdCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2NvbnRhY3QnKTtcblxuICAvLyBSRkMgMzI2MSAxMi4xLjFcbiAgaWYodHlwZSA9PT0gJ1VBUycpIHtcbiAgICB0aGlzLmlkID0ge1xuICAgICAgY2FsbF9pZDogbWVzc2FnZS5jYWxsX2lkLFxuICAgICAgbG9jYWxfdGFnOiBtZXNzYWdlLnRvX3RhZyxcbiAgICAgIHJlbW90ZV90YWc6IG1lc3NhZ2UuZnJvbV90YWcsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxfaWQgKyB0aGlzLmxvY2FsX3RhZyArIHRoaXMucmVtb3RlX3RhZztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLnJlbW90ZV9zZXFudW0gPSBtZXNzYWdlLmNzZXE7XG4gICAgdGhpcy5sb2NhbF91cmkgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCd0bycpLnVyaTtcbiAgICB0aGlzLnJlbW90ZV91cmkgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdmcm9tJykudXJpO1xuICAgIHRoaXMucmVtb3RlX3RhcmdldCA9IGNvbnRhY3QudXJpO1xuICAgIHRoaXMucm91dGVfc2V0ID0gbWVzc2FnZS5nZXRIZWFkZXJzKCdyZWNvcmQtcm91dGUnKTtcbiAgICB0aGlzLmludml0ZV9zZXFudW0gPSBtZXNzYWdlLmNzZXE7XG4gICAgdGhpcy5sb2NhbF9zZXFudW0gPSBtZXNzYWdlLmNzZXE7XG4gIH1cbiAgLy8gUkZDIDMyNjEgMTIuMS4yXG4gIGVsc2UgaWYodHlwZSA9PT0gJ1VBQycpIHtcbiAgICB0aGlzLmlkID0ge1xuICAgICAgY2FsbF9pZDogbWVzc2FnZS5jYWxsX2lkLFxuICAgICAgbG9jYWxfdGFnOiBtZXNzYWdlLmZyb21fdGFnLFxuICAgICAgcmVtb3RlX3RhZzogbWVzc2FnZS50b190YWcsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxfaWQgKyB0aGlzLmxvY2FsX3RhZyArIHRoaXMucmVtb3RlX3RhZztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmludml0ZV9zZXFudW0gPSBtZXNzYWdlLmNzZXE7XG4gICAgdGhpcy5sb2NhbF9zZXFudW0gPSBtZXNzYWdlLmNzZXE7XG4gICAgdGhpcy5sb2NhbF91cmkgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdmcm9tJykudXJpO1xuICAgIHRoaXMucHJhY2tlZCA9IFtdO1xuICAgIHRoaXMucmVtb3RlX3VyaSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ3RvJykudXJpO1xuICAgIHRoaXMucmVtb3RlX3RhcmdldCA9IGNvbnRhY3QudXJpO1xuICAgIHRoaXMucm91dGVfc2V0ID0gbWVzc2FnZS5nZXRIZWFkZXJzKCdyZWNvcmQtcm91dGUnKS5yZXZlcnNlKCk7XG5cbiAgICAvL1JFTkRFUkJPRFlcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfRUFSTFkgJiYgKCFvd25lci5oYXNPZmZlcikpIHtcbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyID0gb3duZXIubWVkaWFIYW5kbGVyRmFjdG9yeShvd25lcik7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5sb2dnZXIgPSBvd25lci51YS5nZXRMb2dnZXIoJ3NpcC5kaWFsb2cnLCB0aGlzLmlkLnRvU3RyaW5nKCkpO1xuICB0aGlzLm93bmVyID0gb3duZXI7XG4gIG93bmVyLnVhLmRpYWxvZ3NbdGhpcy5pZC50b1N0cmluZygpXSA9IHRoaXM7XG4gIHRoaXMubG9nZ2VyLmxvZygnbmV3ICcgKyB0eXBlICsgJyBkaWFsb2cgY3JlYXRlZCB3aXRoIHN0YXR1cyAnICsgKHRoaXMuc3RhdGUgPT09IEMuU1RBVFVTX0VBUkxZID8gJ0VBUkxZJzogJ0NPTkZJUk1FRCcpKTtcbiAgb3duZXIuZW1pdCgnZGlhbG9nJywgdGhpcyk7XG59O1xuXG5EaWFsb2cucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtTSVAuSW5jb21pbmdNZXNzYWdlfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RW51bX0gVUFDL1VBU1xuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbihtZXNzYWdlLCB0eXBlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcblxuICAgIHRoaXMubG9nZ2VyLmxvZygnZGlhbG9nICcrIHRoaXMuaWQudG9TdHJpbmcoKSArJyAgY2hhbmdlZCB0byBDT05GSVJNRUQgc3RhdGUnKTtcblxuICAgIGlmKHR5cGUgPT09ICdVQUMnKSB7XG4gICAgICAvLyBSRkMgMzI2MSAxMy4yLjIuNFxuICAgICAgdGhpcy5yb3V0ZV9zZXQgPSBtZXNzYWdlLmdldEhlYWRlcnMoJ3JlY29yZC1yb3V0ZScpLnJldmVyc2UoKTtcbiAgICB9XG4gIH0sXG5cbiAgdGVybWluYXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ2RpYWxvZyAnICsgdGhpcy5pZC50b1N0cmluZygpICsgJyBkZWxldGVkJyk7XG4gICAgaWYgKHRoaXMubWVkaWFIYW5kbGVyICYmIHRoaXMuc3RhdGUgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIucGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMub3duZXIudWEuZGlhbG9nc1t0aGlzLmlkLnRvU3RyaW5nKCldO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgcmVxdWVzdCBtZXRob2RcbiAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmFIZWFkZXJzIGV4dHJhIGhlYWRlcnNcbiAgKiBAcmV0dXJucyB7U0lQLk91dGdvaW5nUmVxdWVzdH1cbiAgKi9cblxuICAvLyBSRkMgMzI2MSAxMi4yLjEuMVxuICBjcmVhdGVSZXF1ZXN0OiBmdW5jdGlvbihtZXRob2QsIGV4dHJhSGVhZGVycywgYm9keSkge1xuICAgIHZhciBjc2VxLCByZXF1ZXN0O1xuICAgIGV4dHJhSGVhZGVycyA9IChleHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgICBpZighdGhpcy5sb2NhbF9zZXFudW0pIHsgdGhpcy5sb2NhbF9zZXFudW0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7IH1cblxuICAgIGNzZXEgPSAobWV0aG9kID09PSBTSVAuQy5DQU5DRUwgfHwgbWV0aG9kID09PSBTSVAuQy5BQ0spID8gdGhpcy5pbnZpdGVfc2VxbnVtIDogdGhpcy5sb2NhbF9zZXFudW0gKz0gMTtcblxuICAgIHJlcXVlc3QgPSBuZXcgU0lQLk91dGdvaW5nUmVxdWVzdChcbiAgICAgIG1ldGhvZCxcbiAgICAgIHRoaXMucmVtb3RlX3RhcmdldCxcbiAgICAgIHRoaXMub3duZXIudWEsIHtcbiAgICAgICAgJ2NzZXEnOiBjc2VxLFxuICAgICAgICAnY2FsbF9pZCc6IHRoaXMuaWQuY2FsbF9pZCxcbiAgICAgICAgJ2Zyb21fdXJpJzogdGhpcy5sb2NhbF91cmksXG4gICAgICAgICdmcm9tX3RhZyc6IHRoaXMuaWQubG9jYWxfdGFnLFxuICAgICAgICAndG9fdXJpJzogdGhpcy5yZW1vdGVfdXJpLFxuICAgICAgICAndG9fdGFnJzogdGhpcy5pZC5yZW1vdGVfdGFnLFxuICAgICAgICAncm91dGVfc2V0JzogdGhpcy5yb3V0ZV9zZXRcbiAgICAgIH0sIGV4dHJhSGVhZGVycywgYm9keSk7XG5cbiAgICByZXF1ZXN0LmRpYWxvZyA9IHRoaXM7XG5cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3RcbiAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgKi9cblxuICAvLyBSRkMgMzI2MSAxMi4yLjJcbiAgY2hlY2tJbkRpYWxvZ1JlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZighdGhpcy5yZW1vdGVfc2VxbnVtKSB7XG4gICAgICB0aGlzLnJlbW90ZV9zZXFudW0gPSByZXF1ZXN0LmNzZXE7XG4gICAgfSBlbHNlIGlmKHJlcXVlc3QuY3NlcSA8IHRoaXMucmVtb3RlX3NlcW51bSkge1xuICAgICAgICAvL0RvIG5vdCB0cnkgdG8gcmVwbHkgdG8gYW4gQUNLIHJlcXVlc3QuXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gU0lQLkMuQUNLKSB7XG4gICAgICAgICAgcmVxdWVzdC5yZXBseSg1MDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0LmNzZXEgPT09IHRoaXMuaW52aXRlX3NlcW51bSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYocmVxdWVzdC5jc2VxID4gdGhpcy5yZW1vdGVfc2VxbnVtKSB7XG4gICAgICB0aGlzLnJlbW90ZV9zZXFudW0gPSByZXF1ZXN0LmNzZXE7XG4gICAgfVxuXG4gICAgc3dpdGNoKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgICAvLyBSRkMzMjYxIDE0LjIgTW9kaWZ5aW5nIGFuIEV4aXN0aW5nIFNlc3Npb24gLVVBUyBCRUhBVklPUi1cbiAgICAgIGNhc2UgU0lQLkMuSU5WSVRFOlxuICAgICAgICBpZiAodGhpcy51YWNfcGVuZGluZ19yZXBseSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJlcXVlc3QucmVwbHkoNDkxKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnVhc19wZW5kaW5nX3JlcGx5ID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJldHJ5QWZ0ZXIgPSAoTWF0aC5yYW5kb20oKSAqIDEwIHwgMCkgKyAxO1xuICAgICAgICAgIHJlcXVlc3QucmVwbHkoNTAwLCBudWxsLCBbJ1JldHJ5LUFmdGVyOicgKyByZXRyeUFmdGVyXSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudWFzX3BlbmRpbmdfcmVwbHkgPSB0cnVlO1xuICAgICAgICAgIHJlcXVlc3Quc2VydmVyX3RyYW5zYWN0aW9uLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoKXtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX0FDQ0VQVEVEIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19DT01QTEVURUQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX1RFUk1JTkFURUQpIHtcblxuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgICAgICBzZWxmLnVhc19wZW5kaW5nX3JlcGx5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgaWYgKHNlbGYudWFjX3BlbmRpbmdfcmVwbHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vd25lci5vblJlYWR5VG9SZWludml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSRkMzMjYxIDEyLjIuMiBSZXBsYWNlIHRoZSBkaWFsb2dgcyByZW1vdGUgdGFyZ2V0IFVSSSBpZiB0aGUgcmVxdWVzdCBpcyBhY2NlcHRlZFxuICAgICAgICBpZihyZXF1ZXN0Lmhhc0hlYWRlcignY29udGFjdCcpKSB7XG4gICAgICAgICAgcmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24ub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19BQ0NFUFRFRCkge1xuICAgICAgICAgICAgICBzZWxmLnJlbW90ZV90YXJnZXQgPSByZXF1ZXN0LnBhcnNlSGVhZGVyKCdjb250YWN0JykudXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5OT1RJRlk6XG4gICAgICAgIC8vIFJGQzY2NjUgMy4yIFJlcGxhY2UgdGhlIGRpYWxvZ2BzIHJlbW90ZSB0YXJnZXQgVVJJIGlmIHRoZSByZXF1ZXN0IGlzIGFjY2VwdGVkXG4gICAgICAgIGlmKHJlcXVlc3QuaGFzSGVhZGVyKCdjb250YWN0JykpIHtcbiAgICAgICAgICByZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbi5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX0NPTVBMRVRFRCkge1xuICAgICAgICAgICAgICBzZWxmLnJlbW90ZV90YXJnZXQgPSByZXF1ZXN0LnBhcnNlSGVhZGVyKCdjb250YWN0JykudXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHNlbmRSZXF1ZXN0OiBmdW5jdGlvbihhcHBsaWNhbnQsIG1ldGhvZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyXG4gICAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgICBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG51bGwsXG4gICAgICByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KG1ldGhvZCwgZXh0cmFIZWFkZXJzLCBib2R5KSxcbiAgICAgIHJlcXVlc3Rfc2VuZGVyID0gbmV3IFJlcXVlc3RTZW5kZXIodGhpcywgYXBwbGljYW50LCByZXF1ZXN0KTtcblxuICAgIHJlcXVlc3Rfc2VuZGVyLnNlbmQoKTtcblxuICAgIHJldHVybiByZXF1ZXN0O1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdH0gcmVxdWVzdFxuICAqL1xuICByZWNlaXZlUmVxdWVzdDogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIC8vQ2hlY2sgaW4tZGlhbG9nIHJlcXVlc3RcbiAgICBpZighdGhpcy5jaGVja0luRGlhbG9nUmVxdWVzdChyZXF1ZXN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub3duZXIucmVjZWl2ZVJlcXVlc3QocmVxdWVzdCk7XG4gIH1cbn07XG5cbkRpYWxvZy5DID0gQztcblNJUC5EaWFsb2cgPSBEaWFsb2c7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9EaWFsb2dzLmpzXG4gKiogbW9kdWxlIGlkID0gMjI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEluLURpYWxvZyBSZXF1ZXN0IFNlbmRlclxuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUC5EaWFsb2dcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhbiBJbi1kaWFsb2cgcmVxdWVzdCBzZW5kZXIuXG4gKiBAcGFyYW0ge1NJUC5EaWFsb2d9IGRpYWxvZ1xuICogQHBhcmFtIHtPYmplY3R9IGFwcGxpY2FudFxuICogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fSByZXF1ZXN0XG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBpbi1EaWFsb2cgUmVxdWVzdCBTZW5kZXJcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBSZXF1ZXN0U2VuZGVyO1xuXG5SZXF1ZXN0U2VuZGVyID0gZnVuY3Rpb24oZGlhbG9nLCBhcHBsaWNhbnQsIHJlcXVlc3QpIHtcblxuICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcbiAgdGhpcy5hcHBsaWNhbnQgPSBhcHBsaWNhbnQ7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgLy8gUkZDMzI2MSAxNC4xIE1vZGlmeWluZyBhbiBFeGlzdGluZyBTZXNzaW9uLiBVQUMgQmVoYXZpb3IuXG4gIHRoaXMucmVhdHRlbXB0ID0gZmFsc2U7XG4gIHRoaXMucmVhdHRlbXB0VGltZXIgPSBudWxsO1xufTtcblxuUmVxdWVzdFNlbmRlci5wcm90b3R5cGUgPSB7XG4gIHNlbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHJlcXVlc3Rfc2VuZGVyID0gbmV3IFNJUC5SZXF1ZXN0U2VuZGVyKHRoaXMsIHRoaXMuZGlhbG9nLm93bmVyLnVhKTtcblxuICAgICAgcmVxdWVzdF9zZW5kZXIuc2VuZCgpO1xuXG4gICAgLy8gUkZDMzI2MSAxNC4yIE1vZGlmeWluZyBhbiBFeGlzdGluZyBTZXNzaW9uIC1VQUMgQkVIQVZJT1ItXG4gICAgaWYgKHRoaXMucmVxdWVzdC5tZXRob2QgPT09IFNJUC5DLklOVklURSAmJiByZXF1ZXN0X3NlbmRlci5jbGllbnRUcmFuc2FjdGlvbi5zdGF0ZSAhPT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmRpYWxvZy51YWNfcGVuZGluZ19yZXBseSA9IHRydWU7XG4gICAgICByZXF1ZXN0X3NlbmRlci5jbGllbnRUcmFuc2FjdGlvbi5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gc3RhdGVDaGFuZ2VkKCl7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX0FDQ0VQVEVEIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX0NPTVBMRVRFRCB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG5cbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgIHNlbGYuZGlhbG9nLnVhY19wZW5kaW5nX3JlcGx5ID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoc2VsZi5kaWFsb2cudWFzX3BlbmRpbmdfcmVwbHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzZWxmLmRpYWxvZy5vd25lci5vblJlYWR5VG9SZWludml0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXBwbGljYW50Lm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgfSxcblxuICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFwcGxpY2FudC5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH0sXG5cbiAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFJGQzMyNjEgMTIuMi4xLjIgNDA4IG9yIDQ4MSBpcyByZWNlaXZlZCBmb3IgYSByZXF1ZXN0IHdpdGhpbiBhIGRpYWxvZy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDQwOCB8fCByZXNwb25zZS5zdGF0dXNfY29kZSA9PT0gNDgxKSB7XG4gICAgICB0aGlzLmFwcGxpY2FudC5vbkRpYWxvZ0Vycm9yKHJlc3BvbnNlKTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLm1ldGhvZCA9PT0gU0lQLkMuSU5WSVRFICYmIHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSA0OTEpIHtcbiAgICAgIGlmICh0aGlzLnJlYXR0ZW1wdCkge1xuICAgICAgICB0aGlzLmFwcGxpY2FudC5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0LmNzZXEudmFsdWUgPSB0aGlzLmRpYWxvZy5sb2NhbF9zZXFudW0gKz0gMTtcbiAgICAgICAgdGhpcy5yZWF0dGVtcHRUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmFwcGxpY2FudC5vd25lci5zdGF0dXMgIT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgICAgc2VsZi5yZWF0dGVtcHQgPSB0cnVlO1xuICAgICAgICAgICAgICBzZWxmLnJlcXVlc3Rfc2VuZGVyLnNlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRoaXMuZ2V0UmVhdHRlbXB0VGltZW91dCgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbGljYW50LnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfVxuICB9XG59O1xuXG5yZXR1cm4gUmVxdWVzdFNlbmRlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0RpYWxvZy9SZXF1ZXN0U2VuZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcXVlc3QgU2VuZGVyXG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSByZXF1ZXN0IHNlbmRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhcHBsaWNhbnRcbiAqIEBwYXJhbSB7U0lQLlVBfSB1YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBSZXF1ZXN0U2VuZGVyO1xuXG5SZXF1ZXN0U2VuZGVyID0gZnVuY3Rpb24oYXBwbGljYW50LCB1YSkge1xuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnJlcXVlc3RzZW5kZXInKTtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmFwcGxpY2FudCA9IGFwcGxpY2FudDtcbiAgdGhpcy5tZXRob2QgPSBhcHBsaWNhbnQucmVxdWVzdC5tZXRob2Q7XG4gIHRoaXMucmVxdWVzdCA9IGFwcGxpY2FudC5yZXF1ZXN0O1xuICB0aGlzLmNyZWRlbnRpYWxzID0gbnVsbDtcbiAgdGhpcy5jaGFsbGVuZ2VkID0gZmFsc2U7XG4gIHRoaXMuc3RhbGVkID0gZmFsc2U7XG5cbiAgLy8gSWYgdWEgaXMgaW4gY2xvc2luZyBwcm9jZXNzIG9yIGV2ZW4gY2xvc2VkIGp1c3QgYWxsb3cgc2VuZGluZyBCeWUgYW5kIEFDS1xuICBpZiAodWEuc3RhdHVzID09PSBTSVAuVUEuQy5TVEFUVVNfVVNFUl9DTE9TRUQgJiYgKHRoaXMubWV0aG9kICE9PSBTSVAuQy5CWUUgfHwgdGhpcy5tZXRob2QgIT09IFNJUC5DLkFDSykpIHtcbiAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxufTtcblxuLyoqXG4qIENyZWF0ZSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIGFuZCBzZW5kIHRoZSBtZXNzYWdlLlxuKi9cblJlcXVlc3RTZW5kZXIucHJvdG90eXBlID0ge1xuICBzZW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2godGhpcy5tZXRob2QpIHtcbiAgICAgIGNhc2UgXCJJTlZJVEVcIjpcbiAgICAgICAgdGhpcy5jbGllbnRUcmFuc2FjdGlvbiA9IG5ldyBTSVAuVHJhbnNhY3Rpb25zLkludml0ZUNsaWVudFRyYW5zYWN0aW9uKHRoaXMsIHRoaXMucmVxdWVzdCwgdGhpcy51YS50cmFuc3BvcnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBQ0tcIjpcbiAgICAgICAgdGhpcy5jbGllbnRUcmFuc2FjdGlvbiA9IG5ldyBTSVAuVHJhbnNhY3Rpb25zLkFja0NsaWVudFRyYW5zYWN0aW9uKHRoaXMsIHRoaXMucmVxdWVzdCwgdGhpcy51YS50cmFuc3BvcnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuY2xpZW50VHJhbnNhY3Rpb24gPSBuZXcgU0lQLlRyYW5zYWN0aW9ucy5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLnJlcXVlc3QsIHRoaXMudWEudHJhbnNwb3J0KTtcbiAgICB9XG4gICAgdGhpcy5jbGllbnRUcmFuc2FjdGlvbi5zZW5kKCk7XG5cbiAgICByZXR1cm4gdGhpcy5jbGllbnRUcmFuc2FjdGlvbjtcbiAgfSxcblxuICAvKipcbiAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHJlY2VpdmluZyBhIHJlcXVlc3QgdGltZW91dCBlcnJvciBmcm9tIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24uXG4gICogVG8gYmUgcmUtZGVmaW5lZCBieSB0aGUgYXBwbGljYW50LlxuICAqIEBldmVudFxuICAqL1xuICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFwcGxpY2FudC5vblJlcXVlc3RUaW1lb3V0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICogQ2FsbGJhY2sgZmlyZWQgd2hlbiByZWNlaXZpbmcgYSB0cmFuc3BvcnQgZXJyb3IgZnJvbSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uLlxuICAqIFRvIGJlIHJlLWRlZmluZWQgYnkgdGhlIGFwcGxpY2FudC5cbiAgKiBAZXZlbnRcbiAgKi9cbiAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hcHBsaWNhbnQub25UcmFuc3BvcnRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAqIENhbGxlZCBmcm9tIGNsaWVudCB0cmFuc2FjdGlvbiB3aGVuIHJlY2VpdmluZyBhIGNvcnJlY3QgcmVzcG9uc2UgdG8gdGhlIHJlcXVlc3QuXG4gICogQXV0aGVudGljYXRlIHJlcXVlc3QgaWYgbmVlZGVkIG9yIHBhc3MgdGhlIHJlc3BvbnNlIGJhY2sgdG8gdGhlIGFwcGxpY2FudC5cbiAgKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1Jlc3BvbnNlfSByZXNwb25zZVxuICAqL1xuICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgdmFyIGNzZXEsIGNoYWxsZW5nZSwgYXV0aG9yaXphdGlvbl9oZWFkZXJfbmFtZSxcbiAgICAgIHN0YXR1c19jb2RlID0gcmVzcG9uc2Uuc3RhdHVzX2NvZGU7XG5cbiAgICAvKlxuICAgICogQXV0aGVudGljYXRpb25cbiAgICAqIEF1dGhlbnRpY2F0ZSBvbmNlLiBfY2hhbGxlbmdlZF8gZmxhZyB1c2VkIHRvIGF2b2lkIGluZmluaXRlIGF1dGhlbnRpY2F0aW9ucy5cbiAgICAqL1xuICAgIGlmIChzdGF0dXNfY29kZSA9PT0gNDAxIHx8IHN0YXR1c19jb2RlID09PSA0MDcpIHtcblxuICAgICAgLy8gR2V0IGFuZCBwYXJzZSB0aGUgYXBwcm9wcmlhdGUgV1dXLUF1dGhlbnRpY2F0ZSBvciBQcm94eS1BdXRoZW50aWNhdGUgaGVhZGVyLlxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSA0MDEpIHtcbiAgICAgICAgY2hhbGxlbmdlID0gcmVzcG9uc2UucGFyc2VIZWFkZXIoJ3d3dy1hdXRoZW50aWNhdGUnKTtcbiAgICAgICAgYXV0aG9yaXphdGlvbl9oZWFkZXJfbmFtZSA9ICdhdXRob3JpemF0aW9uJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYWxsZW5nZSA9IHJlc3BvbnNlLnBhcnNlSGVhZGVyKCdwcm94eS1hdXRoZW50aWNhdGUnKTtcbiAgICAgICAgYXV0aG9yaXphdGlvbl9oZWFkZXJfbmFtZSA9ICdwcm94eS1hdXRob3JpemF0aW9uJztcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IGl0IHNlZW1zIGEgdmFsaWQgY2hhbGxlbmdlLlxuICAgICAgaWYgKCEgY2hhbGxlbmdlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4ocmVzcG9uc2Uuc3RhdHVzX2NvZGUgKyAnIHdpdGggd3Jvbmcgb3IgbWlzc2luZyBjaGFsbGVuZ2UsIGNhbm5vdCBhdXRoZW50aWNhdGUnKTtcbiAgICAgICAgdGhpcy5hcHBsaWNhbnQucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuY2hhbGxlbmdlZCB8fCAoIXRoaXMuc3RhbGVkICYmIGNoYWxsZW5nZS5zdGFsZSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHRoaXMudWEuY29uZmlndXJhdGlvbi5hdXRoZW50aWNhdGlvbkZhY3RvcnkodGhpcy51YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY2hhbGxlbmdlIGlzIHJlYWxseSB2YWxpZC5cbiAgICAgICAgaWYgKCF0aGlzLmNyZWRlbnRpYWxzLmF1dGhlbnRpY2F0ZSh0aGlzLnJlcXVlc3QsIGNoYWxsZW5nZSkpIHtcbiAgICAgICAgICB0aGlzLmFwcGxpY2FudC5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYWxsZW5nZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChjaGFsbGVuZ2Uuc3RhbGUpIHtcbiAgICAgICAgICB0aGlzLnN0YWxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzcG9uc2UubWV0aG9kID09PSBTSVAuQy5SRUdJU1RFUikge1xuICAgICAgICAgIGNzZXEgPSB0aGlzLmFwcGxpY2FudC5jc2VxICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXF1ZXN0LmRpYWxvZyl7XG4gICAgICAgICAgY3NlcSA9IHRoaXMucmVxdWVzdC5kaWFsb2cubG9jYWxfc2VxbnVtICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3NlcSA9IHRoaXMucmVxdWVzdC5jc2VxICsgMTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3QuY3NlcSA9IGNzZXE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcignY3NlcScsIGNzZXEgKycgJysgdGhpcy5tZXRob2QpO1xuXG4gICAgICAgIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoYXV0aG9yaXphdGlvbl9oZWFkZXJfbmFtZSwgdGhpcy5jcmVkZW50aWFscy50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5zZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGxpY2FudC5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGxpY2FudC5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgfVxufTtcblxuU0lQLlJlcXVlc3RTZW5kZXIgPSBSZXF1ZXN0U2VuZGVyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvUmVxdWVzdFNlbmRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblxudmFyIFJlZ2lzdGVyQ29udGV4dDtcblxuUmVnaXN0ZXJDb250ZXh0ID0gZnVuY3Rpb24gKHVhKSB7XG4gIHZhciBwYXJhbXMgPSB7fSxcbiAgICAgIHJlZ0lkID0gMTtcblxuICB0aGlzLnJlZ2lzdHJhciA9IHVhLmNvbmZpZ3VyYXRpb24ucmVnaXN0cmFyU2VydmVyO1xuICB0aGlzLmV4cGlyZXMgPSB1YS5jb25maWd1cmF0aW9uLnJlZ2lzdGVyRXhwaXJlcztcblxuXG4gIC8vIENvbnRhY3QgaGVhZGVyXG4gIHRoaXMuY29udGFjdCA9IHVhLmNvbnRhY3QudG9TdHJpbmcoKTtcblxuICBpZihyZWdJZCkge1xuICAgIHRoaXMuY29udGFjdCArPSAnO3JlZy1pZD0nKyByZWdJZDtcbiAgICB0aGlzLmNvbnRhY3QgKz0gJzsrc2lwLmluc3RhbmNlPVwiPHVybjp1dWlkOicrIHVhLmNvbmZpZ3VyYXRpb24uaW5zdGFuY2VJZCsnPlwiJztcbiAgfVxuXG4gIC8vIENhbGwtSUQgYW5kIENTZXEgdmFsdWVzIFJGQzMyNjEgMTAuMlxuICB0aGlzLmNhbGxfaWQgPSBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oMjIpO1xuICB0aGlzLmNzZXEgPSA4MDtcblxuICB0aGlzLnRvX3VyaSA9IHVhLmNvbmZpZ3VyYXRpb24udXJpO1xuXG4gIHBhcmFtcy50b191cmkgPSB0aGlzLnRvX3VyaTtcbiAgcGFyYW1zLnRvX2Rpc3BsYXlOYW1lID0gdWEuY29uZmlndXJhdGlvbi5kaXNwbGF5TmFtZTtcbiAgcGFyYW1zLmNhbGxfaWQgPSB0aGlzLmNhbGxfaWQ7XG4gIHBhcmFtcy5jc2VxID0gdGhpcy5jc2VxO1xuXG4gIC8vIEV4dGVuZHMgQ2xpZW50Q29udGV4dFxuICBTSVAuVXRpbHMuYXVnbWVudCh0aGlzLCBTSVAuQ2xpZW50Q29udGV4dCwgW3VhLCAnUkVHSVNURVInLCB0aGlzLnJlZ2lzdHJhciwge3BhcmFtczogcGFyYW1zfV0pO1xuXG4gIHRoaXMucmVnaXN0cmF0aW9uVGltZXIgPSBudWxsO1xuICB0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciA9IG51bGw7XG5cbiAgLy8gU2V0IHN0YXR1c1xuICB0aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnJlZ2lzdGVyY29udGV4dCcpO1xufTtcblxuUmVnaXN0ZXJDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBleHRyYUhlYWRlcnM7XG5cbiAgICAvLyBIYW5kbGUgT3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgZXh0cmFIZWFkZXJzID0gKHRoaXMub3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcgKyB0aGlzLmNvbnRhY3QgKyAnO2V4cGlyZXM9JyArIHRoaXMuZXhwaXJlcyk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnICsgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCkpO1xuXG4gICAgLy8gU2F2ZSBvcmlnaW5hbCBleHRyYUhlYWRlcnMgdG8gYmUgdXNlZCBpbiAuY2xvc2VcbiAgICB0aGlzLmNsb3NlSGVhZGVycyA9IHRoaXMub3B0aW9ucy5jbG9zZVdpdGhIZWFkZXJzID9cbiAgICAgICh0aGlzLm9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpIDogW107XG5cbiAgICB0aGlzLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB2YXIgY29udGFjdCwgZXhwaXJlcyxcbiAgICAgICAgY29udGFjdHMgPSByZXNwb25zZS5nZXRIZWFkZXJzKCdjb250YWN0JykubGVuZ3RoLFxuICAgICAgICBjYXVzZTtcblxuICAgICAgLy8gRGlzY2FyZCByZXNwb25zZXMgdG8gb2xkZXIgUkVHSVNURVIvdW4tUkVHSVNURVIgcmVxdWVzdHMuXG4gICAgICBpZihyZXNwb25zZS5jc2VxICE9PSB0aGlzLmNzZXEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciByZWdpc3RyYXRpb24gdGltZXJcbiAgICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uVGltZXIpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoKHRydWUpIHtcbiAgICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgICB0aGlzLmVtaXQoJ2FjY2VwdGVkJywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgaWYocmVzcG9uc2UuaGFzSGVhZGVyKCdleHBpcmVzJykpIHtcbiAgICAgICAgICAgIGV4cGlyZXMgPSByZXNwb25zZS5nZXRIZWFkZXIoJ2V4cGlyZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZWFyY2ggdGhlIENvbnRhY3QgcG9pbnRpbmcgdG8gdXMgYW5kIHVwZGF0ZSB0aGUgZXhwaXJlcyB2YWx1ZSBhY2NvcmRpbmdseS5cbiAgICAgICAgICBpZiAoIWNvbnRhY3RzKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdubyBDb250YWN0IGhlYWRlciBpbiByZXNwb25zZSB0byBSRUdJU1RFUiwgcmVzcG9uc2UgaWdub3JlZCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUoY29udGFjdHMtLSkge1xuICAgICAgICAgICAgY29udGFjdCA9IHJlc3BvbnNlLnBhcnNlSGVhZGVyKCdjb250YWN0JywgY29udGFjdHMpO1xuICAgICAgICAgICAgaWYoY29udGFjdC51cmkudXNlciA9PT0gdGhpcy51YS5jb250YWN0LnVyaS51c2VyKSB7XG4gICAgICAgICAgICAgIGV4cGlyZXMgPSBjb250YWN0LmdldFBhcmFtKCdleHBpcmVzJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGFjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjb250YWN0KSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdubyBDb250YWN0IGhlYWRlciBwb2ludGluZyB0byB1cywgcmVzcG9uc2UgaWdub3JlZCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIWV4cGlyZXMpIHtcbiAgICAgICAgICAgIGV4cGlyZXMgPSB0aGlzLmV4cGlyZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmUtUmVnaXN0ZXIgYmVmb3JlIHRoZSBleHBpcmF0aW9uIGludGVydmFsIGhhcyBlbGFwc2VkLlxuICAgICAgICAgIC8vIEZvciB0aGF0LCBkZWNyZWFzZSB0aGUgZXhwaXJlcyB2YWx1ZS4gaWU6IDMgc2Vjb25kc1xuICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnJlZ2lzdHJhdGlvblRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYucmVnaXN0ZXIoc2VsZi5vcHRpb25zKTtcbiAgICAgICAgICB9LCAoZXhwaXJlcyAqIDEwMDApIC0gMzAwMCk7XG4gICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5sb2dnZXIud2FybigncmVnaXN0cmF0aW9uIGV4cGlyZWQnKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgICAgc2VsZi51bnJlZ2lzdGVyZWQobnVsbCwgU0lQLkMuY2F1c2VzLkVYUElSRVMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGV4cGlyZXMgKiAxMDAwKTtcblxuICAgICAgICAgIC8vU2F2ZSBncnV1IHZhbHVlc1xuICAgICAgICAgIGlmIChjb250YWN0Lmhhc1BhcmFtKCd0ZW1wLWdydXUnKSkge1xuICAgICAgICAgICAgdGhpcy51YS5jb250YWN0LnRlbXBfZ3J1dSA9IFNJUC5VUkkucGFyc2UoY29udGFjdC5nZXRQYXJhbSgndGVtcC1ncnV1JykucmVwbGFjZSgvXCIvZywnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udGFjdC5oYXNQYXJhbSgncHViLWdydXUnKSkge1xuICAgICAgICAgICAgdGhpcy51YS5jb250YWN0LnB1Yl9ncnV1ID0gU0lQLlVSSS5wYXJzZShjb250YWN0LmdldFBhcmFtKCdwdWItZ3J1dScpLnJlcGxhY2UoL1wiL2csJycpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZW1pdCgncmVnaXN0ZXJlZCcsIHJlc3BvbnNlIHx8IG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBJbnRlcnZhbCB0b28gYnJpZWYgUkZDMzI2MSAxMC4yLjhcbiAgICAgICAgY2FzZSAvXjQyMyQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICAgIGlmKHJlc3BvbnNlLmhhc0hlYWRlcignbWluLWV4cGlyZXMnKSkge1xuICAgICAgICAgICAgLy8gSW5jcmVhc2Ugb3VyIHJlZ2lzdHJhdGlvbiBpbnRlcnZhbCB0byB0aGUgc3VnZ2VzdGVkIG1pbmltdW1cbiAgICAgICAgICAgIHRoaXMuZXhwaXJlcyA9IHJlc3BvbnNlLmdldEhlYWRlcignbWluLWV4cGlyZXMnKTtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdGhlIHJlZ2lzdHJhdGlvbiBhZ2FpbiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7IC8vVGhpcyByZXNwb25zZSBNVVNUIGNvbnRhaW4gYSBNaW4tRXhwaXJlcyBoZWFkZXIgZmllbGRcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJzQyMyByZXNwb25zZSByZWNlaXZlZCBmb3IgUkVHSVNURVIgd2l0aG91dCBNaW4tRXhwaXJlcycpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25GYWlsdXJlKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuU0lQX0ZBSUxVUkVfQ09ERSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhdXNlID0gU0lQLlV0aWxzLnNpcEVycm9yQ2F1c2UocmVzcG9uc2Uuc3RhdHVzX2NvZGUpO1xuICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uRmFpbHVyZShyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uRmFpbHVyZShudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvbkZhaWx1cmUobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH07XG5cbiAgICB0aGlzLmNzZXErKztcbiAgICB0aGlzLnJlcXVlc3QuY3NlcSA9IHRoaXMuY3NlcTtcbiAgICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKCdjc2VxJywgdGhpcy5jc2VxICsgJyBSRUdJU1RFUicpO1xuICAgIHRoaXMucmVxdWVzdC5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgdGhpcy5zZW5kKCk7XG4gIH0sXG5cbiAgcmVnaXN0cmF0aW9uRmFpbHVyZTogZnVuY3Rpb24gKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgIHRoaXMuZW1pdCgnZmFpbGVkJywgcmVzcG9uc2UgfHwgbnVsbCwgY2F1c2UgfHwgbnVsbCk7XG4gIH0sXG5cbiAgb25UcmFuc3BvcnRDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVnaXN0ZXJlZF9iZWZvcmUgPSB0aGlzLnJlZ2lzdGVyZWQ7XG4gICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uVGltZXIgIT09IG51bGwpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uVGltZXIpO1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyICE9PSBudWxsKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lcik7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYodGhpcy5yZWdpc3RlcmVkKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfVxuICB9LFxuXG4gIG9uVHJhbnNwb3J0Q29ubmVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKHRoaXMub3B0aW9ucyk7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYWxsOiBmYWxzZSxcbiAgICAgIGV4dHJhSGVhZGVyczogdGhpcy5jbG9zZUhlYWRlcnNcbiAgICB9O1xuXG4gICAgdGhpcy5yZWdpc3RlcmVkX2JlZm9yZSA9IHRoaXMucmVnaXN0ZXJlZDtcbiAgICB0aGlzLnVucmVnaXN0ZXIob3B0aW9ucyk7XG4gIH0sXG5cbiAgdW5yZWdpc3RlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBleHRyYUhlYWRlcnM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmKCF0aGlzLnJlZ2lzdGVyZWQgJiYgIW9wdGlvbnMuYWxsKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdhbHJlYWR5IHVucmVnaXN0ZXJlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcblxuICAgIHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG4gICAgLy8gQ2xlYXIgdGhlIHJlZ2lzdHJhdGlvbiB0aW1lci5cbiAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25UaW1lciAhPT0gbnVsbCkge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWdpc3RyYXRpb25UaW1lcik7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZihvcHRpb25zLmFsbCkge1xuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6IConKTtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdFeHBpcmVzOiAwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnKyB0aGlzLmNvbnRhY3QgKyAnO2V4cGlyZXM9MCcpO1xuICAgIH1cblxuXG4gICAgdGhpcy5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgdmFyIGNhdXNlO1xuXG4gICAgICBzd2l0Y2godHJ1ZSkge1xuICAgICAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICAgIHRoaXMuZW1pdCgnYWNjZXB0ZWQnLCByZXNwb25zZSk7XG4gICAgICAgICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudW5yZWdpc3RlcmVkKHJlc3BvbnNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYXVzZSA9IFNJUC5VdGlscy5zaXBFcnJvckNhdXNlKHJlc3BvbnNlLnN0YXR1c19jb2RlKTtcbiAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJlZChyZXNwb25zZSxjYXVzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gTm90IGFjdHVhbGx5IHVucmVnaXN0ZXJlZC4uLlxuICAgICAgLy90aGlzLnVucmVnaXN0ZXJlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBOb3QgYWN0dWFsbHkgdW5yZWdpc3RlcmVkLi4uXG4gICAgICAvL3RoaXMudW5yZWdpc3RlcmVkKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jc2VxKys7XG4gICAgdGhpcy5yZXF1ZXN0LmNzZXEgPSB0aGlzLmNzZXE7XG4gICAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcignY3NlcScsIHRoaXMuY3NlcSArICcgUkVHSVNURVInKTtcbiAgICB0aGlzLnJlcXVlc3QuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuXG4gICAgdGhpcy5zZW5kKCk7XG4gIH0sXG5cbiAgdW5yZWdpc3RlcmVkOiBmdW5jdGlvbihyZXNwb25zZSwgY2F1c2UpIHtcbiAgICB0aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3VucmVnaXN0ZXJlZCcsIHJlc3BvbnNlIHx8IG51bGwsIGNhdXNlIHx8IG51bGwpO1xuICB9XG5cbn07XG5cblxuU0lQLlJlZ2lzdGVyQ29udGV4dCA9IFJlZ2lzdGVyQ29udGV4dDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1JlZ2lzdGVyQ29udGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWVkaWFIYW5kbGVyXG4gKi9cblxuLyogTWVkaWFIYW5kbGVyXG4gKiBAY2xhc3MgUGVlckNvbm5lY3Rpb24gaGVscGVyIENsYXNzLlxuICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChFdmVudEVtaXR0ZXIpIHtcbnZhciBNZWRpYUhhbmRsZXIgPSBmdW5jdGlvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gIC8vIGtlZXAganNoaW50IGhhcHB5XG4gIHNlc3Npb24gPSBzZXNzaW9uO1xuICBvcHRpb25zID0gb3B0aW9ucztcbn07XG5cbk1lZGlhSGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUsIHtcbiAgaXNSZWFkeToge3ZhbHVlOiBmdW5jdGlvbiBpc1JlYWR5ICgpIHt9fSxcblxuICBjbG9zZToge3ZhbHVlOiBmdW5jdGlvbiBjbG9zZSAoKSB7fX0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbWVkaWFIaW50XSBBIGN1c3RvbSBvYmplY3QgZGVzY3JpYmluZyB0aGUgbWVkaWEgdG8gYmUgdXNlZCBkdXJpbmcgdGhpcyBzZXNzaW9uLlxuICAgKi9cbiAgZ2V0RGVzY3JpcHRpb246IHt2YWx1ZTogZnVuY3Rpb24gZ2V0RGVzY3JpcHRpb24gKG1lZGlhSGludCkge1xuICAgIC8vIGtlZXAganNoaW50IGhhcHB5XG4gICAgbWVkaWFIaW50ID0gbWVkaWFIaW50O1xuICB9fSxcblxuICAvKipcbiAgKiBNZXNzYWdlIHJlY2VwdGlvbi5cbiAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvblxuICAqL1xuICBzZXREZXNjcmlwdGlvbjoge3ZhbHVlOiBmdW5jdGlvbiBzZXREZXNjcmlwdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAvLyBrZWVwIGpzaGludCBoYXBweVxuICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIH19XG59KTtcblxucmV0dXJuIE1lZGlhSGFuZGxlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL01lZGlhSGFuZGxlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBDbGllbnRDb250ZXh0O1xuXG5DbGllbnRDb250ZXh0ID0gZnVuY3Rpb24gKHVhLCBtZXRob2QsIHRhcmdldCwgb3B0aW9ucykge1xuICB2YXIgb3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgLy8gVmFsaWRhdGUgYXJndW1lbnRzXG4gIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIH1cblxuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuY2xpZW50Y29udGV4dCcpO1xuICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgdGFyZ2V0ID0gdWEubm9ybWFsaXplVGFyZ2V0KHRhcmdldCk7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0YXJnZXQ6ICcgKyBvcmlnaW5hbFRhcmdldCk7XG4gIH1cblxuICAvKiBPcHRpb25zXG4gICAqIC0gZXh0cmFIZWFkZXJzXG4gICAqIC0gcGFyYW1zXG4gICAqIC0gY29udGVudFR5cGVcbiAgICogLSBib2R5XG4gICAqL1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcblxuICBpZiAob3B0aW9ucy5jb250ZW50VHlwZSkge1xuICAgIHRoaXMuY29udGVudFR5cGUgPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogJyArIHRoaXMuY29udGVudFR5cGUpO1xuICB9XG5cbiAgLy8gQnVpbGQgdGhlIHJlcXVlc3RcbiAgdGhpcy5yZXF1ZXN0ID0gbmV3IFNJUC5PdXRnb2luZ1JlcXVlc3QodGhpcy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzKTtcbiAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgIHRoaXMuYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICB0aGlzLnJlcXVlc3QuYm9keSA9IHRoaXMuYm9keTtcbiAgfVxuXG4gIC8qIFNldCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gdGhlIHJlcXVlc3QgKi9cbiAgdGhpcy5sb2NhbElkZW50aXR5ID0gdGhpcy5yZXF1ZXN0LmZyb207XG4gIHRoaXMucmVtb3RlSWRlbnRpdHkgPSB0aGlzLnJlcXVlc3QudG87XG5cbiAgdGhpcy5kYXRhID0ge307XG59O1xuQ2xpZW50Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuQ2xpZW50Q29udGV4dC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgKG5ldyBTSVAuUmVxdWVzdFNlbmRlcih0aGlzLCB0aGlzLnVhKSkuc2VuZCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkNsaWVudENvbnRleHQucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBjYW5jZWxfcmVhc29uID0gU0lQLlV0aWxzLmdldENhbmNlbFJlYXNvbihvcHRpb25zLnN0YXR1c19jb2RlLCBvcHRpb25zLnJlYXNvbl9waHJhc2UpO1xuICB0aGlzLnJlcXVlc3QuY2FuY2VsKGNhbmNlbF9yZWFzb24pO1xuXG4gIHRoaXMuZW1pdCgnY2FuY2VsJyk7XG59O1xuXG5DbGllbnRDb250ZXh0LnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgdmFyIGNhdXNlID0gU0lQLlV0aWxzLmdldFJlYXNvblBocmFzZShyZXNwb25zZS5zdGF0dXNfY29kZSk7XG5cbiAgc3dpdGNoKHRydWUpIHtcbiAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgaWYodGhpcy51YS5hcHBsaWNhbnRzW3RoaXNdKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVhLmFwcGxpY2FudHNbdGhpc107XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ2FjY2VwdGVkJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmKHRoaXMudWEuYXBwbGljYW50c1t0aGlzXSkge1xuICAgICAgICBkZWxldGUgdGhpcy51YS5hcHBsaWNhbnRzW3RoaXNdO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdyZWplY3RlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICBicmVhaztcbiAgfVxuXG59O1xuXG5DbGllbnRDb250ZXh0LnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xufTtcblxuQ2xpZW50Q29udGV4dC5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG59O1xuXG5TSVAuQ2xpZW50Q29udGV4dCA9IENsaWVudENvbnRleHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9DbGllbnRDb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMjMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIFNlcnZlckNvbnRleHQ7XG5cblNlcnZlckNvbnRleHQgPSBmdW5jdGlvbiAodWEsIHJlcXVlc3QpIHtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnNlcnZlcmNvbnRleHQnKTtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5JTlZJVEUpIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gbmV3IFNJUC5UcmFuc2FjdGlvbnMuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ocmVxdWVzdCwgdWEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSBuZXcgU0lQLlRyYW5zYWN0aW9ucy5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbihyZXF1ZXN0LCB1YSk7XG4gIH1cblxuICBpZiAocmVxdWVzdC5ib2R5KSB7XG4gICAgdGhpcy5ib2R5ID0gcmVxdWVzdC5ib2R5O1xuICB9XG4gIGlmIChyZXF1ZXN0Lmhhc0hlYWRlcignQ29udGVudC1UeXBlJykpIHtcbiAgICB0aGlzLmNvbnRlbnRUeXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICB9XG4gIHRoaXMubWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG5cbiAgdGhpcy5kYXRhID0ge307XG5cbiAgdGhpcy5sb2NhbElkZW50aXR5ID0gcmVxdWVzdC50bztcbiAgdGhpcy5yZW1vdGVJZGVudGl0eSA9IHJlcXVlc3QuZnJvbTtcbn07XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgb3B0aW9ucy5zdGF0dXNDb2RlIHx8IChvcHRpb25zLnN0YXR1c0NvZGUgPSAxODApO1xuICBvcHRpb25zLm1pbkNvZGUgPSAxMDA7XG4gIG9wdGlvbnMubWF4Q29kZSA9IDE5OTtcbiAgb3B0aW9ucy5ldmVudHMgPSBbJ3Byb2dyZXNzJ107XG4gIHJldHVybiB0aGlzLnJlcGx5KG9wdGlvbnMpO1xufTtcblxuU2VydmVyQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgb3B0aW9ucy5zdGF0dXNDb2RlIHx8IChvcHRpb25zLnN0YXR1c0NvZGUgPSAyMDApO1xuICBvcHRpb25zLm1pbkNvZGUgPSAyMDA7XG4gIG9wdGlvbnMubWF4Q29kZSA9IDI5OTtcbiAgb3B0aW9ucy5ldmVudHMgPSBbJ2FjY2VwdGVkJ107XG4gIHJldHVybiB0aGlzLnJlcGx5KG9wdGlvbnMpO1xufTtcblxuU2VydmVyQ29udGV4dC5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgb3B0aW9ucy5zdGF0dXNDb2RlIHx8IChvcHRpb25zLnN0YXR1c0NvZGUgPSA0ODApO1xuICBvcHRpb25zLm1pbkNvZGUgPSAzMDA7XG4gIG9wdGlvbnMubWF4Q29kZSA9IDY5OTtcbiAgb3B0aW9ucy5ldmVudHMgPSBbJ3JlamVjdGVkJywgJ2ZhaWxlZCddO1xuICByZXR1cm4gdGhpcy5yZXBseShvcHRpb25zKTtcbn07XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlLnJlcGx5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIFRoaXMgaXMgb2theSwgc28gbG9uZyBhcyB3ZSB0cmVhdCBvcHRpb25zIGFzIHJlYWQtb25seSBpbiB0aGlzIG1ldGhvZFxuICB2YXJcbiAgICBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDEwMCxcbiAgICBtaW5Db2RlID0gb3B0aW9ucy5taW5Db2RlIHx8IDEwMCxcbiAgICBtYXhDb2RlID0gb3B0aW9ucy5tYXhDb2RlIHx8IDY5OSxcbiAgICByZWFzb25QaHJhc2UgPSBTSVAuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHN0YXR1c0NvZGUsIG9wdGlvbnMucmVhc29uUGhyYXNlKSxcbiAgICBleHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSxcbiAgICBib2R5ID0gb3B0aW9ucy5ib2R5LFxuICAgIGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzIHx8IFtdLFxuICAgIHJlc3BvbnNlO1xuXG4gIGlmIChzdGF0dXNDb2RlIDwgbWluQ29kZSB8fCBzdGF0dXNDb2RlID4gbWF4Q29kZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzQ29kZTogJyArIHN0YXR1c0NvZGUpO1xuICB9XG4gIHJlc3BvbnNlID0gdGhpcy5yZXF1ZXN0LnJlcGx5KHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzLCBib2R5KTtcbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5lbWl0KGV2ZW50LCByZXNwb25zZSwgcmVhc29uUGhyYXNlKTtcbiAgfSwgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xufTtcblxuU2VydmVyQ29udGV4dC5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG59O1xuXG5TSVAuU2VydmVyQ29udGV4dCA9IFNlcnZlckNvbnRleHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TZXJ2ZXJDb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMjMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgZW52aXJvbm1lbnQpIHtcblxudmFyIERUTUYgPSByZXF1aXJlKCcuL1Nlc3Npb24vRFRNRicpKFNJUCk7XG5cbnZhciBTZXNzaW9uLCBJbnZpdGVTZXJ2ZXJDb250ZXh0LCBJbnZpdGVDbGllbnRDb250ZXh0LFxuIEMgPSB7XG4gICAgLy9TZXNzaW9uIHN0YXRlc1xuICAgIFNUQVRVU19OVUxMOiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgU1RBVFVTX0lOVklURV9TRU5UOiAgICAgICAgICAgICAgICAgMSxcbiAgICBTVEFUVVNfMVhYX1JFQ0VJVkVEOiAgICAgICAgICAgICAgICAyLFxuICAgIFNUQVRVU19JTlZJVEVfUkVDRUlWRUQ6ICAgICAgICAgICAgIDMsXG4gICAgU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUjogICAgICAgICAgNCxcbiAgICBTVEFUVVNfQU5TV0VSRUQ6ICAgICAgICAgICAgICAgICAgICA1LFxuICAgIFNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSzogICAgICAgICAgIDYsXG4gICAgU1RBVFVTX1dBSVRJTkdfRk9SX0FDSzogICAgICAgICAgICAgNyxcbiAgICBTVEFUVVNfQ0FOQ0VMRUQ6ICAgICAgICAgICAgICAgICAgICA4LFxuICAgIFNUQVRVU19URVJNSU5BVEVEOiAgICAgICAgICAgICAgICAgIDksXG4gICAgU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLOiAxMCxcbiAgICBTVEFUVVNfRUFSTFlfTUVESUE6ICAgICAgICAgICAgICAgIDExLFxuICAgIFNUQVRVU19DT05GSVJNRUQ6ICAgICAgICAgICAgICAgICAgMTJcbiAgfTtcblxuLypcbiAqIEBwYXJhbSB7ZnVuY3Rpb24gcmV0dXJuaW5nIFNJUC5NZWRpYUhhbmRsZXJ9IFttZWRpYUhhbmRsZXJGYWN0b3J5XVxuICogICAgICAgIChTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBtZWRpYUhhbmRsZXJGYWN0b3J5IGFyZ3VtZW50IG9mIHRoZSBVQSBjb25zdHJ1Y3Rvci4pXG4gKi9cblNlc3Npb24gPSBmdW5jdGlvbiAobWVkaWFIYW5kbGVyRmFjdG9yeSkge1xuICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX05VTEw7XG4gIHRoaXMuZGlhbG9nID0gbnVsbDtcbiAgdGhpcy5lYXJseURpYWxvZ3MgPSB7fTtcbiAgdGhpcy5tZWRpYUhhbmRsZXJGYWN0b3J5ID0gbWVkaWFIYW5kbGVyRmFjdG9yeSB8fCBTSVAuV2ViUlRDLk1lZGlhSGFuZGxlci5kZWZhdWx0RmFjdG9yeTtcbiAgLy8gdGhpcy5tZWRpYUhhbmRsZXIgZ2V0cyBzZXQgYnkgSUNDL0lTQyBjb25zdHJ1Y3RvcnNcbiAgdGhpcy5oYXNPZmZlciA9IGZhbHNlO1xuICB0aGlzLmhhc0Fuc3dlciA9IGZhbHNlO1xuXG4gIC8vIFNlc3Npb24gVGltZXJzXG4gIHRoaXMudGltZXJzID0ge1xuICAgIGFja1RpbWVyOiBudWxsLFxuICAgIGV4cGlyZXNUaW1lcjogbnVsbCxcbiAgICBpbnZpdGUyeHhUaW1lcjogbnVsbCxcbiAgICB1c2VyTm9BbnN3ZXJUaW1lcjogbnVsbCxcbiAgICByZWwxeHhUaW1lcjogbnVsbCxcbiAgICBwcmFja1RpbWVyOiBudWxsXG4gIH07XG5cbiAgLy8gU2Vzc2lvbiBpbmZvXG4gIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgdGhpcy5lbmRUaW1lID0gbnVsbDtcbiAgdGhpcy50b25lcyA9IG51bGw7XG5cbiAgLy8gTXV0ZS9Ib2xkIHN0YXRlXG4gIHRoaXMubG9jYWxfaG9sZCA9IGZhbHNlO1xuICB0aGlzLnJlbW90ZV9ob2xkID0gZmFsc2U7XG5cbiAgdGhpcy5wZW5kaW5nX2FjdGlvbnMgPSB7XG4gICAgYWN0aW9uczogW10sXG5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5sZW5ndGg7XG4gICAgfSxcblxuICAgIGlzUGVuZGluZzogZnVuY3Rpb24obmFtZSl7XG4gICAgICB2YXJcbiAgICAgIGlkeCA9IDAsXG4gICAgICBsZW5ndGggPSB0aGlzLmFjdGlvbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGlkeDsgaWR4PGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpZHhdLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBzaGlmdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnNoaWZ0KCk7XG4gICAgfSxcblxuICAgIHB1c2g6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMuYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHBvcDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyXG4gICAgICBpZHggPSAwLFxuICAgICAgbGVuZ3RoID0gdGhpcy5hY3Rpb25zLmxlbmd0aDtcblxuICAgICAgZm9yIChpZHg7IGlkeDxsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaWR4XS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdGhpcy5hY3Rpb25zLnNwbGljZShpZHgsMSk7XG4gICAgICAgICAgbGVuZ3RoIC0tO1xuICAgICAgICAgIGlkeC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgfTtcblxuICB0aGlzLmVhcmx5X3NkcCA9IG51bGw7XG4gIHRoaXMucmVsMTAwID0gU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEO1xufTtcblxuU2Vzc2lvbi5wcm90b3R5cGUgPSB7XG4gIGR0bWY6IGZ1bmN0aW9uKHRvbmVzLCBvcHRpb25zKSB7XG4gICAgdmFyIHRvbmUsIGR0bWZzID0gW10sXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAodG9uZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEICYmIHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdG9uZXNcbiAgICBpZiAoKHR5cGVvZiB0b25lcyAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHRvbmVzICE9PSAnbnVtYmVyJykgfHwgIXRvbmVzLnRvU3RyaW5nKCkubWF0Y2goL15bMC05QS1EIyosXSskL2kpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRvbmVzOiAnKyB0b25lcyk7XG4gICAgfVxuXG4gICAgdG9uZXMgPSB0b25lcy50b1N0cmluZygpLnNwbGl0KCcnKTtcblxuICAgIHdoaWxlICh0b25lcy5sZW5ndGggPiAwKSB7IGR0bWZzLnB1c2gobmV3IERUTUYodGhpcywgdG9uZXMuc2hpZnQoKSwgb3B0aW9ucykpOyB9XG5cbiAgICBpZiAodGhpcy50b25lcykge1xuICAgICAgLy8gVG9uZXMgYXJlIGFscmVhZHkgcXVldWVkLCBqdXN0IGFkZCB0byB0aGUgcXVldWVcbiAgICAgIHRoaXMudG9uZXMgPSAgdGhpcy50b25lcy5jb25jYXQoZHRtZnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNlbmREVE1GID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGR0bWYsIHRpbWVvdXQ7XG5cbiAgICAgIGlmIChzZWxmLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCB8fCAhc2VsZi50b25lcyB8fCBzZWxmLnRvbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBTdG9wIHNlbmRpbmcgRFRNRlxuICAgICAgICBzZWxmLnRvbmVzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGR0bWYgPSBzZWxmLnRvbmVzLnNoaWZ0KCk7XG5cbiAgICAgIGlmICh0b25lID09PSAnLCcpIHtcbiAgICAgICAgdGltZW91dCA9IDIwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkdG1mLm9uKCdmYWlsZWQnLCBmdW5jdGlvbigpe3NlbGYudG9uZXMgPSBudWxsO30pO1xuICAgICAgICBkdG1mLnNlbmQob3B0aW9ucyk7XG4gICAgICAgIHRpbWVvdXQgPSBkdG1mLmR1cmF0aW9uICsgZHRtZi5pbnRlclRvbmVHYXA7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aW1lb3V0IGZvciB0aGUgbmV4dCB0b25lXG4gICAgICBTSVAuVGltZXJzLnNldFRpbWVvdXQoc2VuZERUTUYsIHRpbWVvdXQpO1xuICAgIH07XG5cbiAgICB0aGlzLnRvbmVzID0gZHRtZnM7XG4gICAgc2VuZERUTUYoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBieWU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHZhciBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlO1xuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdFcnJvcjogQXR0ZW1wdGVkIHRvIHNlbmQgQllFIGluIGEgdGVybWluYXRlZCBzZXNzaW9uLicpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIubG9nKCd0ZXJtaW5hdGluZyBTZXNzaW9uJyk7XG5cbiAgICBpZiAoc3RhdHVzQ29kZSAmJiAoc3RhdHVzQ29kZSA8IDIwMCB8fCBzdGF0dXNDb2RlID49IDcwMCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzQ29kZTogJysgc3RhdHVzQ29kZSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHJldHVybiB0aGlzLlxuICAgICAgc2VuZFJlcXVlc3QoU0lQLkMuQllFLCBvcHRpb25zKS5cbiAgICAgIHRlcm1pbmF0ZWQoKTtcbiAgfSxcblxuICByZWZlcjogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSxcbiAgICAgICAgd2l0aFJlcGxhY2VzID1cbiAgICAgICAgICB0YXJnZXQgaW5zdGFuY2VvZiBTSVAuSW52aXRlU2VydmVyQ29udGV4dCB8fFxuICAgICAgICAgIHRhcmdldCBpbnN0YW5jZW9mIFNJUC5JbnZpdGVDbGllbnRDb250ZXh0LFxuICAgICAgICBvcmlnaW5hbFRhcmdldCA9IHRhcmdldDtcblxuICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIC8vIHRyYW5zZm9ybSBgdGFyZ2V0YCBzbyB0aGF0IGl0IGNhbiBiZSBhIFJlZmVyLVRvIGhlYWRlciB2YWx1ZVxuICAgIGlmICh3aXRoUmVwbGFjZXMpIHtcbiAgICAgIC8vQXR0ZW5kZWQgVHJhbnNmZXJcbiAgICAgIC8vIEIudHJhbnNmZXIoQylcbiAgICAgIHRhcmdldCA9ICdcIicgKyB0YXJnZXQucmVtb3RlSWRlbnRpdHkuZnJpZW5kbHlOYW1lICsgJ1wiICcgK1xuICAgICAgICAnPCcgKyB0YXJnZXQuZGlhbG9nLnJlbW90ZV90YXJnZXQudG9TdHJpbmcoKSArXG4gICAgICAgICc/UmVwbGFjZXM9JyArIHRhcmdldC5kaWFsb2cuaWQuY2FsbF9pZCArXG4gICAgICAgICclM0J0by10YWclM0QnICsgdGFyZ2V0LmRpYWxvZy5pZC5yZW1vdGVfdGFnICtcbiAgICAgICAgJyUzQmZyb20tdGFnJTNEJyArIHRhcmdldC5kaWFsb2cuaWQubG9jYWxfdGFnICsgJz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL0JsaW5kIFRyYW5zZmVyXG4gICAgICAvLyBub3JtYWxpemVUYXJnZXQgYWxsb3dzIGluc3RhbmNlcyBvZiBTSVAuVVJJIHRvIHBhc3MgdGhyb3VnaCB1bmFsdGVyZWQsXG4gICAgICAvLyBzbyB0cnkgdG8gbWFrZSBvbmUgYWhlYWQgb2YgdGltZVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGFyZ2V0ID0gU0lQLkdyYW1tYXIucGFyc2UodGFyZ2V0LCAnUmVmZXJfVG8nKS51cmkgfHwgdGFyZ2V0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIi5yZWZlcigpIGNhbm5vdCBwYXJzZSBSZWZlcl9UbyBmcm9tXCIsIHRhcmdldCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiLi4uZmFsbGluZyB0aHJvdWdoIHRvIG5vcm1hbGl6ZVRhcmdldCgpXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0YXJnZXQgdmFsaWRpdHlcbiAgICAgIHRhcmdldCA9IHRoaXMudWEubm9ybWFsaXplVGFyZ2V0KHRhcmdldCk7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRhcmdldDogJyArIG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJysgdGhpcy5jb250YWN0KTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcrIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVmZXItVG86ICcrIHRhcmdldCk7XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5SRUZFUiwge1xuICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAoICEgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKSApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZyB1cCBvbmx5IGlmIHdlIHRyYW5zZmVycmVkIHRvIGEgU0lQIGFkZHJlc3NcbiAgICAgICAgaWYgKHdpdGhSZXBsYWNlcyB8fCAodGFyZ2V0LnNjaGVtZSAmJiB0YXJnZXQuc2NoZW1lLm1hdGNoKFwiXnNpcHM/JFwiKSkpIHtcbiAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBmb2xsb3dSZWZlcjogZnVuY3Rpb24gZm9sbG93UmVmZXIgKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlZmVyTGlzdGVuZXIgKGNhbGxiYWNrLCByZXF1ZXN0KSB7XG4gICAgICAvLyBvcGVuIG5vbi1TSVAgVVJJcyBpZiBwb3NzaWJsZSBhbmQga2VlcCBzZXNzaW9uIG9wZW5cbiAgICAgIHZhciByZWZlclRvID0gcmVxdWVzdC5wYXJzZUhlYWRlcigncmVmZXItdG8nKTtcbiAgICAgIHZhciB0YXJnZXQgPSByZWZlclRvLnVyaTtcbiAgICAgIGlmICghdGFyZ2V0LnNjaGVtZS5tYXRjaChcIl5zaXBzPyRcIikpIHtcbiAgICAgICAgdmFyIHRhcmdldFN0cmluZyA9IHRhcmdldC50b1N0cmluZygpO1xuICAgICAgICBpZiAodHlwZW9mIGVudmlyb25tZW50Lm9wZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGVudmlyb25tZW50Lm9wZW4odGFyZ2V0U3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwicmVmZXJyZWQgdG8gbm9uLVNJUCBVUkkgYnV0IGBvcGVuYCBpc24ndCBpbiB0aGUgZW52aXJvbm1lbnQ6IFwiICsgdGFyZ2V0U3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXTtcblxuICAgICAgLyogQ29weSB0aGUgUmVwbGFjZXMgcXVlcnkgaW50byBhIFJlcGxhY2VzIGhlYWRlciAqL1xuICAgICAgLyogVE9ETyAtIG1ha2Ugc3VyZSB3ZSBkb24ndCBjb3B5IGEgcG9vcmx5IGZvcm1hdHRlZCBoZWFkZXI/ICovXG4gICAgICB2YXIgcmVwbGFjZXMgPSB0YXJnZXQuZ2V0SGVhZGVyKCdSZXBsYWNlcycpO1xuICAgICAgaWYgKHJlcGxhY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JlcGxhY2VzOiAnICsgZGVjb2RlVVJJQ29tcG9uZW50KHJlcGxhY2VzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbid0IGVtYmVkIGhlYWRlcnMgaW50byBSZXF1ZXN0LVVSSSBvZiBJTlZJVEVcbiAgICAgIHRhcmdldC5jbGVhckhlYWRlcnMoKTtcblxuICAgICAgLypcbiAgICAgICAgSGFybWxlc3MgcmFjZSBjb25kaXRpb24uICBCb3RoIHNpZGVzIG9mIFJFRkVSXG4gICAgICAgIG1heSBzZW5kIGEgQllFLCBidXQgaW4gdGhlIGVuZCB0aGUgZGlhbG9ncyBhcmUgZGVzdHJveWVkLlxuICAgICAgKi9cbiAgICAgIHZhciBnZXRSZWZlck1lZGlhID0gdGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVmZXJNZWRpYTtcbiAgICAgIHZhciBtZWRpYUhpbnQgPSBnZXRSZWZlck1lZGlhID8gZ2V0UmVmZXJNZWRpYS5jYWxsKHRoaXMubWVkaWFIYW5kbGVyKSA6IHRoaXMubWVkaWFIaW50O1xuXG4gICAgICBTSVAuSGFja3MuQ2hyb21lLmdldHNDb25mdXNlZEFib3V0R1VNKHRoaXMpO1xuXG4gICAgICB2YXIgcmVmZXJTZXNzaW9uID0gdGhpcy51YS5pbnZpdGUodGFyZ2V0LCB7XG4gICAgICAgIG1lZGlhOiBtZWRpYUhpbnQsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIHRvX2Rpc3BsYXlOYW1lOiByZWZlclRvLmZyaWVuZGx5TmFtZVxuICAgICAgICB9LFxuICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVyc1xuICAgICAgfSk7XG5cbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgcmVxdWVzdCwgcmVmZXJTZXNzaW9uKTtcblxuICAgICAgdGhpcy50ZXJtaW5hdGUoKTtcbiAgICB9LmJpbmQodGhpcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIHNlbmRSZXF1ZXN0OiBmdW5jdGlvbihtZXRob2Qsb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFNJUC5PdXRnb2luZ1JlcXVlc3QoXG4gICAgICBtZXRob2QsXG4gICAgICB0aGlzLmRpYWxvZy5yZW1vdGVfdGFyZ2V0LFxuICAgICAgdGhpcy51YSxcbiAgICAgIHtcbiAgICAgICAgY3NlcTogb3B0aW9ucy5jc2VxIHx8ICh0aGlzLmRpYWxvZy5sb2NhbF9zZXFudW0gKz0gMSksXG4gICAgICAgIGNhbGxfaWQ6IHRoaXMuZGlhbG9nLmlkLmNhbGxfaWQsXG4gICAgICAgIGZyb21fdXJpOiB0aGlzLmRpYWxvZy5sb2NhbF91cmksXG4gICAgICAgIGZyb21fdGFnOiB0aGlzLmRpYWxvZy5pZC5sb2NhbF90YWcsXG4gICAgICAgIHRvX3VyaTogdGhpcy5kaWFsb2cucmVtb3RlX3VyaSxcbiAgICAgICAgdG9fdGFnOiB0aGlzLmRpYWxvZy5pZC5yZW1vdGVfdGFnLFxuICAgICAgICByb3V0ZV9zZXQ6IHRoaXMuZGlhbG9nLnJvdXRlX3NldCxcbiAgICAgICAgc3RhdHVzQ29kZTogb3B0aW9ucy5zdGF0dXNDb2RlLFxuICAgICAgICByZWFzb25QaHJhc2U6IG9wdGlvbnMucmVhc29uUGhyYXNlXG4gICAgICB9LFxuICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10sXG4gICAgICBvcHRpb25zLmJvZHlcbiAgICApO1xuXG4gICAgbmV3IFNJUC5SZXF1ZXN0U2VuZGVyKHtcbiAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICB9LFxuICAgICAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgfSxcbiAgICAgIHJlY2VpdmVSZXNwb25zZTogb3B0aW9ucy5yZWNlaXZlUmVzcG9uc2UgfHwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgc2VsZi5yZWNlaXZlTm9uSW52aXRlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sIHRoaXMudWEpLnNlbmQoKTtcblxuICAgIC8vIEVtaXQgdGhlIHJlcXVlc3QgZXZlbnRcbiAgICB0aGlzLmVtaXQobWV0aG9kLnRvTG93ZXJDYXNlKCksIHJlcXVlc3QpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZHg7XG5cbiAgICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIubG9nKCdjbG9zaW5nIElOVklURSBzZXNzaW9uICcgKyB0aGlzLmlkKTtcblxuICAgIC8vIDFzdCBTdGVwLiBUZXJtaW5hdGUgbWVkaWEuXG4gICAgaWYgKHRoaXMubWVkaWFIYW5kbGVyKXtcbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gMm5kIFN0ZXAuIFRlcm1pbmF0ZSBzaWduYWxpbmcuXG5cbiAgICAvLyBDbGVhciBzZXNzaW9uIHRpbWVyc1xuICAgIGZvcihpZHggaW4gdGhpcy50aW1lcnMpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzW2lkeF0pO1xuICAgIH1cblxuICAgIC8vIFRlcm1pbmF0ZSBkaWFsb2dzXG5cbiAgICAvLyBUZXJtaW5hdGUgY29uZmlybWVkIGRpYWxvZ1xuICAgIGlmKHRoaXMuZGlhbG9nKSB7XG4gICAgICB0aGlzLmRpYWxvZy50ZXJtaW5hdGUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRpYWxvZztcbiAgICB9XG5cbiAgICAvLyBUZXJtaW5hdGUgZWFybHkgZGlhbG9nc1xuICAgIGZvcihpZHggaW4gdGhpcy5lYXJseURpYWxvZ3MpIHtcbiAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkeF0udGVybWluYXRlKCk7XG4gICAgICBkZWxldGUgdGhpcy5lYXJseURpYWxvZ3NbaWR4XTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX1RFUk1JTkFURUQ7XG5cbiAgICBkZWxldGUgdGhpcy51YS5zZXNzaW9uc1t0aGlzLmlkXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjcmVhdGVEaWFsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIHR5cGUsIGVhcmx5KSB7XG4gICAgdmFyIGRpYWxvZywgZWFybHlfZGlhbG9nLFxuICAgICAgbG9jYWxfdGFnID0gbWVzc2FnZVsodHlwZSA9PT0gJ1VBUycpID8gJ3RvX3RhZycgOiAnZnJvbV90YWcnXSxcbiAgICAgIHJlbW90ZV90YWcgPSBtZXNzYWdlWyh0eXBlID09PSAnVUFTJykgPyAnZnJvbV90YWcnIDogJ3RvX3RhZyddLFxuICAgICAgaWQgPSBtZXNzYWdlLmNhbGxfaWQgKyBsb2NhbF90YWcgKyByZW1vdGVfdGFnO1xuXG4gICAgZWFybHlfZGlhbG9nID0gdGhpcy5lYXJseURpYWxvZ3NbaWRdO1xuXG4gICAgLy8gRWFybHkgRGlhbG9nXG4gICAgaWYgKGVhcmx5KSB7XG4gICAgICBpZiAoZWFybHlfZGlhbG9nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFybHlfZGlhbG9nID0gbmV3IFNJUC5EaWFsb2codGhpcywgbWVzc2FnZSwgdHlwZSwgU0lQLkRpYWxvZy5DLlNUQVRVU19FQVJMWSk7XG5cbiAgICAgICAgLy8gRGlhbG9nIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjcmVhdGVkLlxuICAgICAgICBpZihlYXJseV9kaWFsb2cuZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlYXJseV9kaWFsb2cuZXJyb3IpO1xuICAgICAgICAgIHRoaXMuZmFpbGVkKG1lc3NhZ2UsIFNJUC5DLmNhdXNlcy5JTlRFUk5BTF9FUlJPUik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkXSA9IGVhcmx5X2RpYWxvZztcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBDb25maXJtZWQgRGlhbG9nXG4gICAgZWxzZSB7XG4gICAgICAvLyBJbiBjYXNlIHRoZSBkaWFsb2cgaXMgaW4gX2Vhcmx5XyBzdGF0ZSwgdXBkYXRlIGl0XG4gICAgICBpZiAoZWFybHlfZGlhbG9nKSB7XG4gICAgICAgIGVhcmx5X2RpYWxvZy51cGRhdGUobWVzc2FnZSwgdHlwZSk7XG4gICAgICAgIHRoaXMuZGlhbG9nID0gZWFybHlfZGlhbG9nO1xuICAgICAgICBkZWxldGUgdGhpcy5lYXJseURpYWxvZ3NbaWRdO1xuICAgICAgICBmb3IgKHZhciBkaWEgaW4gdGhpcy5lYXJseURpYWxvZ3MpIHtcbiAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9nc1tkaWFdLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmVhcmx5RGlhbG9nc1tkaWFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIF9jb25maXJtZWRfIGRpYWxvZ1xuICAgICAgZGlhbG9nID0gbmV3IFNJUC5EaWFsb2codGhpcywgbWVzc2FnZSwgdHlwZSk7XG5cbiAgICAgIGlmKGRpYWxvZy5lcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihkaWFsb2cuZXJyb3IpO1xuICAgICAgICB0aGlzLmZhaWxlZChtZXNzYWdlLCBTSVAuQy5jYXVzZXMuSU5URVJOQUxfRVJST1IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvX3RhZyA9IG1lc3NhZ2UudG9fdGFnO1xuICAgICAgICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIENoZWNrIGlmIFNlc3Npb24gaXMgcmVhZHkgZm9yIGEgcmUtSU5WSVRFXG4gICpcbiAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgKi9cbiAgaXNSZWFkeVRvUmVpbnZpdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lZGlhSGFuZGxlci5pc1JlYWR5KCkgJiZcbiAgICAgICF0aGlzLmRpYWxvZy51YWNfcGVuZGluZ19yZXBseSAmJlxuICAgICAgIXRoaXMuZGlhbG9nLnVhc19wZW5kaW5nX3JlcGx5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBNdXRlXG4gICAqL1xuICBtdXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHJldCA9IHRoaXMubWVkaWFIYW5kbGVyLm11dGUob3B0aW9ucyk7XG4gICAgaWYgKHJldCkge1xuICAgICAgdGhpcy5vbm11dGUocmV0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubXV0ZVxuICAgKi9cbiAgdW5tdXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHJldCA9IHRoaXMubWVkaWFIYW5kbGVyLnVubXV0ZShvcHRpb25zKTtcbiAgICBpZiAocmV0KSB7XG4gICAgICB0aGlzLm9udW5tdXRlKHJldCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIb2xkXG4gICAqL1xuICBob2xkOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSyAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIHRoaXMubWVkaWFIYW5kbGVyLmhvbGQoKTtcblxuICAgIC8vIENoZWNrIGlmIFJUQ1Nlc3Npb24gaXMgcmVhZHkgdG8gc2VuZCBhIHJlSU5WSVRFXG4gICAgaWYgKCF0aGlzLmlzUmVhZHlUb1JlaW52aXRlKCkpIHtcbiAgICAgIC8qIElmIHRoZXJlIGlzIGEgcGVuZGluZyAndW5ob2xkJyBhY3Rpb24sIGNhbmNlbCBpdCBhbmQgZG9uJ3QgcXVldWUgdGhpcyBvbmVcbiAgICAgICAqIEVsc2UsIGlmIHRoZXJlIGlzbid0IGFueSAnaG9sZCcgYWN0aW9uLCBhZGQgdGhpcyBvbmUgdG8gdGhlIHF1ZXVlXG4gICAgICAgKiBFbHNlLCBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ2hvbGQnIGFjdGlvbiwgc2tpcFxuICAgICAgICovXG4gICAgICBpZiAodGhpcy5wZW5kaW5nX2FjdGlvbnMuaXNQZW5kaW5nKCd1bmhvbGQnKSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdfYWN0aW9ucy5wb3AoJ3VuaG9sZCcpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5wZW5kaW5nX2FjdGlvbnMuaXNQZW5kaW5nKCdob2xkJykpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2FjdGlvbnMucHVzaCgnaG9sZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbF9ob2xkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9uaG9sZCgnbG9jYWwnKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMubWFuZ2xlID0gZnVuY3Rpb24oYm9keSl7XG5cbiAgICAgIC8vIERvbid0IHJlY2VpdmUgbWVkaWFcbiAgICAgIC8vIFRPRE8gLSBUaGlzIHdpbGwgYnJlYWsgZm9yIG1lZGlhIHN0cmVhbXMgd2l0aCBkaWZmZXJlbnQgZGlyZWN0aW9ucy5cbiAgICAgIGlmICghKC9hPShzZW5kcmVjdnxzZW5kb25seXxyZWN2b25seXxpbmFjdGl2ZSkvKS50ZXN0KGJvZHkpKSB7XG4gICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoLyhtPVteXFxyXSpcXHJcXG4pL2csICckMWE9c2VuZG9ubHlcXHJcXG4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoL2E9c2VuZHJlY3ZcXHJcXG4vZywgJ2E9c2VuZG9ubHlcXHJcXG4nKTtcbiAgICAgICAgYm9keSA9IGJvZHkucmVwbGFjZSgvYT1yZWN2b25seVxcclxcbi9nLCAnYT1pbmFjdGl2ZVxcclxcbicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZW5kUmVpbnZpdGUob3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuaG9sZFxuICAgKi9cbiAgdW5ob2xkOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSyAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIHRoaXMubWVkaWFIYW5kbGVyLnVuaG9sZCgpO1xuXG4gICAgaWYgKCF0aGlzLmlzUmVhZHlUb1JlaW52aXRlKCkpIHtcbiAgICAgIC8qIElmIHRoZXJlIGlzIGEgcGVuZGluZyAnaG9sZCcgYWN0aW9uLCBjYW5jZWwgaXQgYW5kIGRvbid0IHF1ZXVlIHRoaXMgb25lXG4gICAgICAgKiBFbHNlLCBpZiB0aGVyZSBpc24ndCBhbnkgJ3VuaG9sZCcgYWN0aW9uLCBhZGQgdGhpcyBvbmUgdG8gdGhlIHF1ZXVlXG4gICAgICAgKiBFbHNlLCBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ3VuaG9sZCcgYWN0aW9uLCBza2lwXG4gICAgICAgKi9cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdfYWN0aW9ucy5pc1BlbmRpbmcoJ2hvbGQnKSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdfYWN0aW9ucy5wb3AoJ2hvbGQnKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucGVuZGluZ19hY3Rpb25zLmlzUGVuZGluZygndW5ob2xkJykpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2FjdGlvbnMucHVzaCgndW5ob2xkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLmxvY2FsX2hvbGQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vbnVuaG9sZCgnbG9jYWwnKTtcblxuICAgIHRoaXMuc2VuZFJlaW52aXRlKG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBpc09uSG9sZFxuICAgKi9cbiAgaXNPbkhvbGQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhbDogdGhpcy5sb2NhbF9ob2xkLFxuICAgICAgcmVtb3RlOiB0aGlzLnJlbW90ZV9ob2xkXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogSW4gZGlhbG9nIElOVklURSBSZWNlcHRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlY2VpdmVSZWludml0ZTogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghcmVxdWVzdC5ib2R5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKSAhPT0gJ2FwcGxpY2F0aW9uL3NkcCcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2ludmFsaWQgQ29udGVudC1UeXBlJyk7XG4gICAgICByZXF1ZXN0LnJlcGx5KDQxNSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVxdWVzdC5ib2R5KVxuICAgIC50aGVuKHRoaXMubWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uLmJpbmQodGhpcy5tZWRpYUhhbmRsZXIsIHRoaXMubWVkaWFIaW50KSlcbiAgICAudGhlbihmdW5jdGlvbihib2R5KSB7XG4gICAgICByZXF1ZXN0LnJlcGx5KDIwMCwgbnVsbCwgWydDb250YWN0OiAnICsgc2VsZi5jb250YWN0XSwgYm9keSxcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5zdGF0dXMgPSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0s7XG4gICAgICAgICAgc2VsZi5zZXRJbnZpdGUyeHhUaW1lcihyZXF1ZXN0LCBib2R5KTtcbiAgICAgICAgICBzZWxmLnNldEFDS1RpbWVyKCk7XG5cbiAgICAgICAgICAvLyBBcmUgd2UgaG9sZGluZz9cbiAgICAgICAgICB2YXIgaG9sZCA9ICgvYT0oc2VuZG9ubHl8aW5hY3RpdmUpLykudGVzdChyZXF1ZXN0LmJvZHkpO1xuXG4gICAgICAgICAgaWYgKHNlbGYucmVtb3RlX2hvbGQgJiYgIWhvbGQpIHtcbiAgICAgICAgICAgIHNlbGYub251bmhvbGQoJ3JlbW90ZScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXNlbGYucmVtb3RlX2hvbGQgJiYgaG9sZCkge1xuICAgICAgICAgICAgc2VsZi5vbmhvbGQoJ3JlbW90ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAuY2F0Y2goZnVuY3Rpb24gb25GYWlsdXJlIChlKSB7XG4gICAgICB2YXIgc3RhdHVzQ29kZTtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU0lQLkV4Y2VwdGlvbnMuR2V0RGVzY3JpcHRpb25FcnJvcikge1xuICAgICAgICBzdGF0dXNDb2RlID0gNTAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoZSk7XG4gICAgICAgIHN0YXR1c0NvZGUgPSA0ODg7XG4gICAgICB9XG4gICAgICByZXF1ZXN0LnJlcGx5KHN0YXR1c0NvZGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIHNlbmRSZWludml0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSxcbiAgICAgIGV2ZW50SGFuZGxlcnMgPSBvcHRpb25zLmV2ZW50SGFuZGxlcnMgfHwge30sXG4gICAgICBtYW5nbGUgPSBvcHRpb25zLm1hbmdsZSB8fCBudWxsLFxuICAgICAgc3VjY2VlZGVkO1xuXG4gICAgaWYgKGV2ZW50SGFuZGxlcnMuc3VjY2VlZGVkKSB7XG4gICAgICBzdWNjZWVkZWQgPSBldmVudEhhbmRsZXJzLnN1Y2NlZWRlZDtcbiAgICB9XG4gICAgdGhpcy5yZWludml0ZVN1Y2NlZWRlZCA9IGZ1bmN0aW9uKCl7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dChzZWxmLnRpbWVycy5hY2tUaW1lcik7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dChzZWxmLnRpbWVycy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICBzZWxmLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgIHN1Y2NlZWRlZCAmJiBzdWNjZWVkZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIGlmIChldmVudEhhbmRsZXJzLmZhaWxlZCkge1xuICAgICAgdGhpcy5yZWludml0ZUZhaWxlZCA9IGV2ZW50SGFuZGxlcnMuZmFpbGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlaW52aXRlRmFpbGVkID0gZnVuY3Rpb24oKXt9O1xuICAgIH1cblxuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnICsgdGhpcy5jb250YWN0KTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcrIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9zZHAnKTtcblxuICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlID0gdGhpcy5yZWNlaXZlUmVpbnZpdGVSZXNwb25zZTtcbiAgICAvL1JFVklTSVRcbiAgICB0aGlzLm1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbihzZWxmLm1lZGlhSGludClcbiAgICAudGhlbihtYW5nbGUpXG4gICAgLnRoZW4oXG4gICAgICBmdW5jdGlvbihib2R5KXtcbiAgICAgICAgc2VsZi5kaWFsb2cuc2VuZFJlcXVlc3Qoc2VsZiwgU0lQLkMuSU5WSVRFLCB7XG4gICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgYm9keTogYm9keVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuaXNSZWFkeVRvUmVpbnZpdGUoKSkge1xuICAgICAgICAgIHNlbGYub25SZWFkeVRvUmVpbnZpdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnJlaW52aXRlRmFpbGVkKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfSxcblxuICByZWNlaXZlUmVxdWVzdDogZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICBzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgICBjYXNlIFNJUC5DLkJZRTpcbiAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuICAgICAgICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdieWUnLCByZXF1ZXN0KTtcbiAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJZRSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLklOVklURTpcbiAgICAgICAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygncmUtSU5WSVRFIHJlY2VpdmVkJyk7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlUmVpbnZpdGUocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLklORk86XG4gICAgICAgIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQgfHwgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICAgIHZhciBib2R5LCB0b25lLCBkdXJhdGlvbixcbiAgICAgICAgICAgICAgY29udGVudFR5cGUgPSByZXF1ZXN0LmdldEhlYWRlcignY29udGVudC10eXBlJyksXG4gICAgICAgICAgICAgIHJlZ190b25lID0gL14oU2lnbmFsXFxzKj89XFxzKj8pKFswLTlBLUQjKl17MX0pKFxccyk/LiovLFxuICAgICAgICAgICAgICByZWdfZHVyYXRpb24gPSAvXihEdXJhdGlvblxccz89XFxzPykoWzAtOV17MSw0fSkoXFxzKT8uKi87XG5cbiAgICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZS5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvZHRtZi1yZWxheS9pKSkge1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHJlcXVlc3QuYm9keS5zcGxpdCgnXFxyXFxuJywgMik7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVnX3RvbmUudGVzdChib2R5WzBdKSkge1xuICAgICAgICAgICAgICAgICAgICB0b25lID0gYm9keVswXS5yZXBsYWNlKHJlZ190b25lLFwiJDJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocmVnX2R1cmF0aW9uLnRlc3QoYm9keVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBwYXJzZUludChib2R5WzFdLnJlcGxhY2UocmVnX2R1cmF0aW9uLFwiJDJcIiksIDEwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuZXcgRFRNRih0aGlzLCB0b25lLCB7ZHVyYXRpb246IGR1cmF0aW9ufSkuaW5pdF9pbmNvbWluZyhyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoNDE1LCBudWxsLCBbXCJBY2NlcHQ6IGFwcGxpY2F0aW9uL2R0bWYtcmVsYXlcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuUkVGRVI6XG4gICAgICAgIGlmKHRoaXMuc3RhdHVzID09PSAgQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdSRUZFUiByZWNlaXZlZCcpO1xuICAgICAgICAgIHZhciBoYXNSZWZlckxpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnMoJ3JlZmVyJykubGVuZ3RoLFxuICAgICAgICAgICAgICBub3RpZnlCb2R5O1xuXG4gICAgICAgICAgaWYgKGhhc1JlZmVyTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoMjAyLCAnQWNjZXB0ZWQnKTtcbiAgICAgICAgICAgIG5vdGlmeUJvZHkgPSAnU0lQLzIuMCAxMDAgVHJ5aW5nJztcblxuICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5OT1RJRlksIHtcbiAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOltcbiAgICAgICAgICAgICAgICAnRXZlbnQ6IHJlZmVyJyxcbiAgICAgICAgICAgICAgICAnU3Vic2NyaXB0aW9uLVN0YXRlOiB0ZXJtaW5hdGVkJyxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlOiBtZXNzYWdlL3NpcGZyYWcnXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGJvZHk6IG5vdGlmeUJvZHksXG4gICAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVmZXInLCByZXF1ZXN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUkZDIDM1MTUuMi40LjI6ICd0aGUgVUEgTUFZIGRlY2xpbmUgdGhlIHJlcXVlc3QuJ1xuICAgICAgICAgICAgcmVxdWVzdC5yZXBseSg2MDMsICdEZWNsaW5lZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuTk9USUZZOlxuICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMCwgJ09LJyk7XG4gICAgICAgIHRoaXMuZW1pdCgnbm90aWZ5JywgcmVxdWVzdCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZXB0aW9uIG9mIFJlc3BvbnNlIGZvciBpbi1kaWFsb2cgSU5WSVRFXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWNlaXZlUmVpbnZpdGVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKTtcblxuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCh0cnVlKSB7XG4gICAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcblxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSyx7Y3NlcTpyZXNwb25zZS5jc2VxfSk7XG5cbiAgICAgICAgaWYoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICB0aGlzLnJlaW52aXRlRmFpbGVkKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGVudFR5cGUgIT09ICdhcHBsaWNhdGlvbi9zZHAnKSB7XG4gICAgICAgICAgdGhpcy5yZWludml0ZUZhaWxlZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9SRVZJU0lUXG4gICAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyAoKSB7XG4gICAgICAgICAgICBzZWxmLnJlaW52aXRlU3VjY2VlZGVkKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUgKCkge1xuICAgICAgICAgICAgc2VsZi5yZWludml0ZUZhaWxlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJlaW52aXRlRmFpbGVkKCk7XG4gICAgfVxuICB9LFxuXG4gIGFjY2VwdEFuZFRlcm1pbmF0ZTogZnVuY3Rpb24ocmVzcG9uc2UsIHN0YXR1c19jb2RlLCByZWFzb25fcGhyYXNlKSB7XG4gICAgdmFyIGV4dHJhSGVhZGVycyA9IFtdO1xuXG4gICAgaWYgKHN0YXR1c19jb2RlKSB7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVhc29uOiAnICsgU0lQLlV0aWxzLmdldFJlYXNvbkhlYWRlclZhbHVlKHN0YXR1c19jb2RlLCByZWFzb25fcGhyYXNlKSk7XG4gICAgfVxuXG4gICAgLy8gQW4gZXJyb3Igb24gZGlhbG9nIGNyZWF0aW9uIHdpbGwgZmlyZSAnZmFpbGVkJyBldmVudFxuICAgIGlmICh0aGlzLmRpYWxvZyB8fCB0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycpKSB7XG4gICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSyx7Y3NlcTogcmVzcG9uc2UuY3NlcX0pO1xuICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5CWUUsIHtcbiAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSRkMzMjYxIDEzLjMuMS40XG4gICAqIFJlc3BvbnNlIHJldHJhbnNtaXNzaW9ucyBjYW5ub3QgYmUgYWNjb21wbGlzaGVkIGJ5IHRyYW5zYWN0aW9uIGxheWVyXG4gICAqICBzaW5jZSBpdCBpcyBkZXN0cm95ZWQgd2hlbiByZWNlaXZpbmcgdGhlIGZpcnN0IDJ4eCBhbnN3ZXJcbiAgICovXG4gIHNldEludml0ZTJ4eFRpbWVyOiBmdW5jdGlvbihyZXF1ZXN0LCBib2R5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0aW1lb3V0ID0gU0lQLlRpbWVycy5UMTtcblxuICAgIHRoaXMudGltZXJzLmludml0ZTJ4eFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uIGludml0ZTJ4eFJldHJhbnNtaXNzaW9uKCkge1xuICAgICAgaWYgKHNlbGYuc3RhdHVzICE9PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ25vIEFDSyByZWNlaXZlZCwgYXR0ZW1wdGluZyB0byByZXRyYW5zbWl0IE9LJyk7XG5cbiAgICAgIHJlcXVlc3QucmVwbHkoMjAwLCBudWxsLCBbJ0NvbnRhY3Q6ICcgKyBzZWxmLmNvbnRhY3RdLCBib2R5KTtcblxuICAgICAgdGltZW91dCA9IE1hdGgubWluKHRpbWVvdXQgKiAyLCBTSVAuVGltZXJzLlQyKTtcblxuICAgICAgc2VsZi50aW1lcnMuaW52aXRlMnh4VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoaW52aXRlMnh4UmV0cmFuc21pc3Npb24sIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSRkMzMjYxIDE0LjJcbiAgICogSWYgYSBVQVMgZ2VuZXJhdGVzIGEgMnh4IHJlc3BvbnNlIGFuZCBuZXZlciByZWNlaXZlcyBhbiBBQ0ssXG4gICAqICBpdCBTSE9VTEQgZ2VuZXJhdGUgYSBCWUUgdG8gdGVybWluYXRlIHRoZSBkaWFsb2cuXG4gICAqL1xuICBzZXRBQ0tUaW1lcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy50aW1lcnMuYWNrVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZihzZWxmLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLmxvZygnbm8gQUNLIHJlY2VpdmVkIGZvciBhbiBleHRlbmRlZCBwZXJpb2Qgb2YgdGltZSwgdGVybWluYXRpbmcgdGhlIGNhbGwnKTtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQoc2VsZi50aW1lcnMuaW52aXRlMnh4VGltZXIpO1xuICAgICAgICBzZWxmLnNlbmRSZXF1ZXN0KFNJUC5DLkJZRSk7XG4gICAgICAgIHNlbGYudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuTk9fQUNLKTtcbiAgICAgIH1cbiAgICB9LCBTSVAuVGltZXJzLlRJTUVSX0gpO1xuICB9LFxuXG4gIC8qXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblJlYWR5VG9SZWludml0ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFjdGlvbiA9IHRoaXMucGVuZGluZ19hY3Rpb25zLnNoaWZ0KCk7XG5cbiAgICBpZiAoIWFjdGlvbiB8fCAhdGhpc1thY3Rpb24ubmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzW2FjdGlvbi5uYW1lXSgpO1xuICB9LFxuXG4gIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEICYmIHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfVxuICB9LFxuXG4gIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfVxuICB9LFxuXG4gIG9uRGlhbG9nRXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMudGVybWluYXRlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5ESUFMT0dfRVJST1IpO1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuRElBTE9HX0VSUk9SKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbmhvbGQ6IGZ1bmN0aW9uKG9yaWdpbmF0b3IpIHtcbiAgICB0aGlzW29yaWdpbmF0b3IgPT09ICdsb2NhbCcgPyAnbG9jYWxfaG9sZCcgOiAncmVtb3RlX2hvbGQnXSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdob2xkJywgeyBvcmlnaW5hdG9yOiBvcmlnaW5hdG9yIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb251bmhvbGQ6IGZ1bmN0aW9uKG9yaWdpbmF0b3IpIHtcbiAgICB0aGlzW29yaWdpbmF0b3IgPT09ICdsb2NhbCcgPyAnbG9jYWxfaG9sZCcgOiAncmVtb3RlX2hvbGQnXSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgndW5ob2xkJywgeyBvcmlnaW5hdG9yOiBvcmlnaW5hdG9yIH0pO1xuICB9LFxuXG4gIC8qXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbm11dGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmVtaXQoJ211dGVkJywge1xuICAgICAgYXVkaW86IG9wdGlvbnMuYXVkaW8sXG4gICAgICB2aWRlbzogb3B0aW9ucy52aWRlb1xuICAgIH0pO1xuICB9LFxuXG4gIC8qXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbnVubXV0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuZW1pdCgndW5tdXRlZCcsIHtcbiAgICAgIGF1ZGlvOiBvcHRpb25zLmF1ZGlvLFxuICAgICAgdmlkZW86IG9wdGlvbnMudmlkZW9cbiAgICB9KTtcbiAgfSxcblxuICBmYWlsZWQ6IGZ1bmN0aW9uKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnZmFpbGVkJywgcmVzcG9uc2UgfHwgbnVsbCwgY2F1c2UgfHwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVqZWN0ZWQ6IGZ1bmN0aW9uKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgIHRoaXMuZW1pdCgncmVqZWN0ZWQnLFxuICAgICAgcmVzcG9uc2UgfHwgbnVsbCxcbiAgICAgIGNhdXNlIHx8IG51bGxcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNhbmNlbGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVtaXQoJ2NhbmNlbCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGFjY2VwdGVkOiBmdW5jdGlvbihyZXNwb25zZSwgY2F1c2UpIHtcbiAgICBjYXVzZSA9IFNJUC5VdGlscy5nZXRSZWFzb25QaHJhc2UocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUsIGNhdXNlKTtcblxuICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcblxuICAgIGlmICh0aGlzLnJlcGxhY2VlKSB7XG4gICAgICB0aGlzLnJlcGxhY2VlLmVtaXQoJ3JlcGxhY2VkJywgdGhpcyk7XG4gICAgICB0aGlzLnJlcGxhY2VlLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2FjY2VwdGVkJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0ZXJtaW5hdGVkOiBmdW5jdGlvbihtZXNzYWdlLCBjYXVzZSkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5lbmRUaW1lID0gbmV3IERhdGUoKTtcblxuICAgIHRoaXMuY2xvc2UoKTtcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLFxuICAgICAgbWVzc2FnZSB8fCBudWxsLFxuICAgICAgY2F1c2UgfHwgbnVsbFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY29ubmVjdGluZzogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdGluZycsIHsgcmVxdWVzdDogcmVxdWVzdCB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuU2Vzc2lvbi5kZXN1Z2FyID0gZnVuY3Rpb24gZGVzdWdhcihvcHRpb25zKSB7XG4gIGlmIChlbnZpcm9ubWVudC5IVE1MTWVkaWFFbGVtZW50ICYmIG9wdGlvbnMgaW5zdGFuY2VvZiBlbnZpcm9ubWVudC5IVE1MTWVkaWFFbGVtZW50KSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1lZGlhOiB7XG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICAgICAgdmlkZW86IG9wdGlvbnMudGFnTmFtZSA9PT0gJ1ZJREVPJ1xuICAgICAgICB9LFxuICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICByZW1vdGU6IG9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMgfHwge307XG59O1xuXG5cblNlc3Npb24uQyA9IEM7XG5TSVAuU2Vzc2lvbiA9IFNlc3Npb247XG5cblxuSW52aXRlU2VydmVyQ29udGV4dCA9IGZ1bmN0aW9uKHVhLCByZXF1ZXN0KSB7XG4gIHZhciBleHBpcmVzLFxuICAgIHNlbGYgPSB0aGlzLFxuICAgIGNvbnRlbnRUeXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpLFxuICAgIGNvbnRlbnREaXNwID0gcmVxdWVzdC5wYXJzZUhlYWRlcignQ29udGVudC1EaXNwb3NpdGlvbicpO1xuXG4gIC8vIENoZWNrIGJvZHkgYW5kIGNvbnRlbnQgdHlwZVxuICBpZiAoKCFjb250ZW50RGlzcCAmJiBjb250ZW50VHlwZSAhPT0gJ2FwcGxpY2F0aW9uL3NkcCcpIHx8IChjb250ZW50RGlzcCAmJiBjb250ZW50RGlzcC50eXBlID09PSAncmVuZGVyJykpIHtcbiAgICB0aGlzLnJlbmRlcmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgdGhpcy5yZW5kZXJ0eXBlID0gY29udGVudFR5cGU7XG4gIH0gZWxzZSBpZiAoY29udGVudFR5cGUgIT09ICdhcHBsaWNhdGlvbi9zZHAnICYmIChjb250ZW50RGlzcCAmJiBjb250ZW50RGlzcC50eXBlID09PSAnc2Vzc2lvbicpKSB7XG4gICAgcmVxdWVzdC5yZXBseSg0MTUpO1xuICAgIC8vVE9ETzogaW5zdGVhZCBvZiA0MTUsIHBhc3Mgb2ZmIHRvIHRoZSBtZWRpYSBoYW5kbGVyLCB3aG8gY2FuIHRoZW4gZGVjaWRlIGlmIHdlIGNhbiB1c2UgaXRcbiAgICByZXR1cm47XG4gIH1cblxuICAvL1RPRE86IG1vdmUgdGhpcyBpbnRvIG1lZGlhIGhhbmRsZXJcbiAgU0lQLkhhY2tzLkZpcmVmb3guY2Fubm90SGFuZGxlRXh0cmFXaGl0ZXNwYWNlKHJlcXVlc3QpO1xuICBTSVAuSGFja3MuQWxsQnJvd3NlcnMubWFza0R0bHMocmVxdWVzdCk7XG5cbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLlNlcnZlckNvbnRleHQsIFt1YSwgcmVxdWVzdF0pO1xuICBTSVAuVXRpbHMuYXVnbWVudCh0aGlzLCBTSVAuU2Vzc2lvbiwgW3VhLmNvbmZpZ3VyYXRpb24ubWVkaWFIYW5kbGVyRmFjdG9yeV0pO1xuXG4gIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfSU5WSVRFX1JFQ0VJVkVEO1xuICB0aGlzLmZyb21fdGFnID0gcmVxdWVzdC5mcm9tX3RhZztcbiAgdGhpcy5pZCA9IHJlcXVlc3QuY2FsbF9pZCArIHRoaXMuZnJvbV90YWc7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHRoaXMuY29udGFjdCA9IHRoaXMudWEuY29udGFjdC50b1N0cmluZygpO1xuXG4gIHRoaXMucmVjZWl2ZU5vbkludml0ZVJlc3BvbnNlID0gZnVuY3Rpb24gKCkge307IC8vIGludGVudGlvbmFsIG5vLW9wXG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5pbnZpdGVzZXJ2ZXJjb250ZXh0JywgdGhpcy5pZCk7XG5cbiAgLy9TYXZlIHRoZSBzZXNzaW9uIGludG8gdGhlIHVhIHNlc3Npb25zIGNvbGxlY3Rpb24uXG4gIHRoaXMudWEuc2Vzc2lvbnNbdGhpcy5pZF0gPSB0aGlzO1xuXG4gIC8vR2V0IHRoZSBFeHBpcmVzIGhlYWRlciB2YWx1ZSBpZiBleGlzdHNcbiAgaWYocmVxdWVzdC5oYXNIZWFkZXIoJ2V4cGlyZXMnKSkge1xuICAgIGV4cGlyZXMgPSByZXF1ZXN0LmdldEhlYWRlcignZXhwaXJlcycpICogMTAwMDtcbiAgfVxuXG4gIC8vU2V0IDEwMHJlbCBpZiBuZWNlc3NhcnlcbiAgZnVuY3Rpb24gc2V0MTAwcmVsKGgsYykge1xuICAgIGlmIChyZXF1ZXN0Lmhhc0hlYWRlcihoKSAmJiByZXF1ZXN0LmdldEhlYWRlcihoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJzEwMHJlbCcpID49IDApIHtcbiAgICAgIHNlbGYucmVsMTAwID0gYztcbiAgICB9XG4gIH1cbiAgc2V0MTAwcmVsKCdyZXF1aXJlJywgU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEKTtcbiAgc2V0MTAwcmVsKCdzdXBwb3J0ZWQnLCBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKTtcblxuICAvKiBTZXQgdGhlIHRvX3RhZyBiZWZvcmVcbiAgICogcmVwbHlpbmcgYSByZXNwb25zZSBjb2RlIHRoYXQgd2lsbCBjcmVhdGUgYSBkaWFsb2cuXG4gICAqL1xuICByZXF1ZXN0LnRvX3RhZyA9IFNJUC5VdGlscy5uZXdUYWcoKTtcblxuICAvLyBBbiBlcnJvciBvbiBkaWFsb2cgY3JlYXRpb24gd2lsbCBmaXJlICdmYWlsZWQnIGV2ZW50XG4gIGlmKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXF1ZXN0LCAnVUFTJywgdHJ1ZSkpIHtcbiAgICByZXF1ZXN0LnJlcGx5KDUwMCwgJ01pc3NpbmcgQ29udGFjdCBoZWFkZXIgZmllbGQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvL0luaXRpYWxpemUgTWVkaWEgU2Vzc2lvblxuICB0aGlzLm1lZGlhSGFuZGxlciA9IHRoaXMubWVkaWFIYW5kbGVyRmFjdG9yeSh0aGlzLCB7XG4gICAgUlRDQ29uc3RyYWludHM6IHtcIm9wdGlvbmFsXCI6IFt7J0R0bHNTcnRwS2V5QWdyZWVtZW50JzogJ3RydWUnfV19XG4gIH0pO1xuXG4gIGlmICh0aGlzLm1lZGlhSGFuZGxlciAmJiB0aGlzLm1lZGlhSGFuZGxlci5nZXRSZW1vdGVTdHJlYW1zKSB7XG4gICAgdGhpcy5nZXRSZW1vdGVTdHJlYW1zID0gdGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVtb3RlU3RyZWFtcy5iaW5kKHRoaXMubWVkaWFIYW5kbGVyKTtcbiAgICB0aGlzLmdldExvY2FsU3RyZWFtcyA9IHRoaXMubWVkaWFIYW5kbGVyLmdldExvY2FsU3RyZWFtcy5iaW5kKHRoaXMubWVkaWFIYW5kbGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVOZXdTZXNzaW9uKCkge1xuICAgIHZhciBvcHRpb25zID0ge2V4dHJhSGVhZGVyczogWydDb250YWN0OiAnICsgc2VsZi5jb250YWN0XX07XG5cbiAgICBpZiAoc2VsZi5yZWwxMDAgIT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgICAgc2VsZi5wcm9ncmVzcyhvcHRpb25zKTtcbiAgICB9XG4gICAgc2VsZi5zdGF0dXMgPSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVI7XG5cbiAgICAvLyBTZXQgdXNlck5vQW5zd2VyVGltZXJcbiAgICBzZWxmLnRpbWVycy51c2VyTm9BbnN3ZXJUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHJlcXVlc3QucmVwbHkoNDA4KTtcbiAgICAgIHNlbGYuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5OT19BTlNXRVIpO1xuICAgICAgc2VsZi50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5OT19BTlNXRVIpO1xuICAgIH0sIHNlbGYudWEuY29uZmlndXJhdGlvbi5ub0Fuc3dlclRpbWVvdXQpO1xuXG4gICAgLyogU2V0IGV4cGlyZXNUaW1lclxuICAgICAqIFJGQzMyNjEgMTMuMy4xXG4gICAgICovXG4gICAgaWYgKGV4cGlyZXMpIHtcbiAgICAgIHNlbGYudGltZXJzLmV4cGlyZXNUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoc2VsZi5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUikge1xuICAgICAgICAgIHJlcXVlc3QucmVwbHkoNDg3KTtcbiAgICAgICAgICBzZWxmLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuRVhQSVJFUyk7XG4gICAgICAgICAgc2VsZi50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5FWFBJUkVTKTtcbiAgICAgICAgfVxuICAgICAgfSwgZXhwaXJlcyk7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdpbnZpdGUnLHJlcXVlc3QpO1xuICB9XG5cbiAgaWYgKCFyZXF1ZXN0LmJvZHkgfHwgdGhpcy5yZW5kZXJib2R5KSB7XG4gICAgU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZpcmVOZXdTZXNzaW9uLCAwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhc09mZmVyID0gdHJ1ZTtcbiAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXF1ZXN0LmJvZHkpXG4gICAgLnRoZW4oXG4gICAgICBmaXJlTmV3U2Vzc2lvbixcbiAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSAoZSkge1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKCdpbnZhbGlkIFNEUCcpO1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICByZXF1ZXN0LnJlcGx5KDQ4OCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcblxuSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gIHJlamVjdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZygncmVqZWN0aW5nIFJUQ1Nlc3Npb24nKTtcblxuICAgIFNJUC5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5yZWplY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy50ZXJtaW5hdGVkKCk7XG4gIH0sXG5cbiAgdGVybWluYXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXJcbiAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgYm9keSA9IG9wdGlvbnMuYm9keSxcbiAgICBkaWFsb2csXG4gICAgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSyAmJlxuICAgICAgIHRoaXMucmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24uc3RhdGUgIT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgZGlhbG9nID0gdGhpcy5kaWFsb2c7XG5cbiAgICAgIHRoaXMucmVjZWl2ZVJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gU0lQLkMuQUNLKSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0KFNJUC5DLkJZRSwge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGlhbG9nLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnJlcXVlc3Quc2VydmVyX3RyYW5zYWN0aW9uLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbigpe1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0ID0gbmV3IFNJUC5PdXRnb2luZ1JlcXVlc3QoXG4gICAgICAgICAgICBTSVAuQy5CWUUsXG4gICAgICAgICAgICB0aGlzLmRpYWxvZy5yZW1vdGVfdGFyZ2V0LFxuICAgICAgICAgICAgdGhpcy51YSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgJ2NzZXEnOiB0aGlzLmRpYWxvZy5sb2NhbF9zZXFudW0rPTEsXG4gICAgICAgICAgICAgICdjYWxsX2lkJzogdGhpcy5kaWFsb2cuaWQuY2FsbF9pZCxcbiAgICAgICAgICAgICAgJ2Zyb21fdXJpJzogdGhpcy5kaWFsb2cubG9jYWxfdXJpLFxuICAgICAgICAgICAgICAnZnJvbV90YWcnOiB0aGlzLmRpYWxvZy5pZC5sb2NhbF90YWcsXG4gICAgICAgICAgICAgICd0b191cmknOiB0aGlzLmRpYWxvZy5yZW1vdGVfdXJpLFxuICAgICAgICAgICAgICAndG9fdGFnJzogdGhpcy5kaWFsb2cuaWQucmVtb3RlX3RhZyxcbiAgICAgICAgICAgICAgJ3JvdXRlX3NldCc6IHRoaXMuZGlhbG9nLnJvdXRlX3NldFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgbmV3IFNJUC5SZXF1ZXN0U2VuZGVyKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLnJlcXVlc3QsXG4gICAgICAgICAgICAgIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYub25SZXF1ZXN0VGltZW91dCgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLnVhXG4gICAgICAgICAgKS5zZW5kKCk7XG4gICAgICAgICAgZGlhbG9nLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5lbWl0KCdieWUnLCB0aGlzLnJlcXVlc3QpO1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKCk7XG5cbiAgICAgIC8vIFJlc3RvcmUgdGhlIGRpYWxvZyBpbnRvICd0aGlzJyBpbiBvcmRlciB0byBiZSBhYmxlIHRvIHNlbmQgdGhlIGluLWRpYWxvZyBCWUUgOi0pXG4gICAgICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcblxuICAgICAgLy8gUmVzdG9yZSB0aGUgZGlhbG9nIGludG8gJ3VhJyBzbyB0aGUgQUNLIGNhbiByZWFjaCAndGhpcycgc2Vzc2lvblxuICAgICAgdGhpcy51YS5kaWFsb2dzW2RpYWxvZy5pZC50b1N0cmluZygpXSA9IGRpYWxvZztcblxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhpcy5ieWUob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVqZWN0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tZWRpYV0gZ2V0cyBwYXNzZWQgdG8gU0lQLk1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbiBhcyBtZWRpYUhpbnRcbiAgICovXG4gIHByb2dyZXNzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhclxuICAgICAgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAxODAsXG4gICAgICByZWFzb25QaHJhc2UgPSBvcHRpb25zLnJlYXNvblBocmFzZSxcbiAgICAgIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSxcbiAgICAgIGljZVNlcnZlcnMsXG4gICAgICBzdHVuU2VydmVycyA9IG9wdGlvbnMuc3R1blNlcnZlcnMgfHwgbnVsbCxcbiAgICAgIHR1cm5TZXJ2ZXJzID0gb3B0aW9ucy50dXJuU2VydmVycyB8fCBudWxsLFxuICAgICAgYm9keSA9IG9wdGlvbnMuYm9keSxcbiAgICAgIHJlc3BvbnNlO1xuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAxMDAgfHwgc3RhdHVzQ29kZSA+IDE5OSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNDb2RlOiAnICsgc3RhdHVzQ29kZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDYW5jZWxlZCB8fCB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHN0dW5TZXJ2ZXJzIHx8IHR1cm5TZXJ2ZXJzKSB7XG4gICAgICBpZiAoc3R1blNlcnZlcnMpIHtcbiAgICAgICAgaWNlU2VydmVycyA9IFNJUC5VQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsWydzdHVuU2VydmVycyddKHN0dW5TZXJ2ZXJzKTtcbiAgICAgICAgaWYgKCFpY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdHVuU2VydmVyczogJysgc3R1blNlcnZlcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3R1blNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0dXJuU2VydmVycykge1xuICAgICAgICBpY2VTZXJ2ZXJzID0gU0lQLlVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbJ3R1cm5TZXJ2ZXJzJ10odHVyblNlcnZlcnMpO1xuICAgICAgICBpZiAoIWljZVNlcnZlcnMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHR1cm5TZXJ2ZXJzOiAnKyB0dXJuU2VydmVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50dXJuU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIudXBkYXRlSWNlU2VydmVycyh7XG4gICAgICAgIHN0dW5TZXJ2ZXJzOiB0aGlzLnN0dW5TZXJ2ZXJzLFxuICAgICAgICB0dXJuU2VydmVyczogdGhpcy50dXJuU2VydmVyc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG8xMDByZWwoKSB7XG4gICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgICBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDE4MztcblxuICAgICAgLy8gU2V0IHN0YXR1cyBhbmQgYWRkIGV4dHJhIGhlYWRlcnNcbiAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0s7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJysgdGhpcy5jb250YWN0KTtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZXF1aXJlOiAxMDByZWwnKTtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSU2VxOiAnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApKTtcblxuICAgICAgLy8gU2F2ZSBtZWRpYSBoaW50IGZvciBsYXRlciAocmVmZXJyZWQgc2Vzc2lvbnMpXG4gICAgICB0aGlzLm1lZGlhSGludCA9IG9wdGlvbnMubWVkaWE7XG5cbiAgICAgIC8vIEdldCB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvbiB0byBhZGQgdG8gcHJlYWNjZXB0IHdpdGhcbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uKG9wdGlvbnMubWVkaWEpXG4gICAgICAudGhlbihcbiAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzIChib2R5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxlZCB8fCB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZWFybHlfc2RwID0gYm9keTtcbiAgICAgICAgICB0aGlzW3RoaXMuaGFzT2ZmZXIgPyAnaGFzQW5zd2VyJyA6ICdoYXNPZmZlciddID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIFJldHJhbnNtaXQgdW50aWwgd2UgZ2V0IGEgcmVzcG9uc2Ugb3Igd2UgdGltZSBvdXQgKHNlZSBwcmFja1RpbWVyIGJlbG93KVxuICAgICAgICAgIHZhciB0aW1lb3V0ID0gU0lQLlRpbWVycy5UMTtcbiAgICAgICAgICB0aGlzLnRpbWVycy5yZWwxeHhUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbiByZWwxeHhSZXRyYW5zbWlzc2lvbigpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5yZXBseShzdGF0dXNDb2RlLCBudWxsLCBleHRyYUhlYWRlcnMsIGJvZHkpO1xuICAgICAgICAgICAgdGltZW91dCAqPSAyO1xuICAgICAgICAgICAgdGhpcy50aW1lcnMucmVsMXh4VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQocmVsMXh4UmV0cmFuc21pc3Npb24uYmluZCh0aGlzKSwgdGltZW91dCk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpLCB0aW1lb3V0KTtcblxuICAgICAgICAgIC8vIFRpbWVvdXQgYW5kIHJlamVjdCBJTlZJVEUgaWYgbm8gcmVzcG9uc2VcbiAgICAgICAgICB0aGlzLnRpbWVycy5wcmFja1RpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ25vIFBSQUNLIHJlY2VpdmVkLCByZWplY3RpbmcgdGhlIGNhbGwnKTtcbiAgICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnJlbDF4eFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5yZXBseSg1MDQpO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5OT19QUkFDSyk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpLCBTSVAuVGltZXJzLlQxICogNjQpO1xuXG4gICAgICAgICAgLy8gU2VuZCB0aGUgaW5pdGlhbCByZXNwb25zZVxuICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5yZXF1ZXN0LnJlcGx5KHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzLCBib2R5KTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UsIHJlYXNvblBocmFzZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcblxuICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUgKCkge1xuICAgICAgICAgIHRoaXMucmVxdWVzdC5yZXBseSg0ODApO1xuICAgICAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICApO1xuICAgIH0gLy8gZW5kIGRvMTAwcmVsXG5cbiAgICBmdW5jdGlvbiBub3JtYWxSZXBseSgpIHtcbiAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgcmVzcG9uc2UgPSB0aGlzLnJlcXVlc3QucmVwbHkoc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlLCBleHRyYUhlYWRlcnMsIGJvZHkpO1xuICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlLCByZWFzb25QaHJhc2UpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXR1c0NvZGUgIT09IDEwMCAmJlxuICAgICAgICAodGhpcy5yZWwxMDAgPT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCB8fFxuICAgICAgICAgKHRoaXMucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEICYmIG9wdGlvbnMucmVsMTAwKSB8fFxuICAgICAgICAgKHRoaXMucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEICYmICh0aGlzLnVhLmNvbmZpZ3VyYXRpb24ucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpKSkpIHtcbiAgICAgIGRvMTAwcmVsLmFwcGx5KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxSZXBseS5hcHBseSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLypcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1lZGlhXSBnZXRzIHBhc3NlZCB0byBTSVAuTWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uIGFzIG1lZGlhSGludFxuICAgKi9cbiAgYWNjZXB0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoU2Vzc2lvbi5kZXN1Z2FyKG9wdGlvbnMpKTtcbiAgICBTSVAuVXRpbHMub3B0aW9uc092ZXJyaWRlKG9wdGlvbnMsICdtZWRpYScsICdtZWRpYUNvbnN0cmFpbnRzJywgdHJ1ZSwgdGhpcy5sb2dnZXIsIHRoaXMudWEuY29uZmlndXJhdGlvbi5tZWRpYSk7XG4gICAgdGhpcy5tZWRpYUhpbnQgPSBvcHRpb25zLm1lZGlhO1xuXG4gICAgLy8gY29tbWVudGVkIG91dCBub3ctdW51c2VkIGhvbGQtcmVsYXRlZCB2YXJpYWJsZXMgZm9yIGpzaGludC4gU2VlIGJlbG93LiBKTUYgMjAxNC0xLTIxXG4gICAgdmFyXG4gICAgICAvL2lkeCwgbGVuZ3RoLCBoYXNBdWRpbywgaGFzVmlkZW8sXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3QsXG4gICAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgLy9tZWRpYVN0cmVhbSA9IG9wdGlvbnMubWVkaWFTdHJlYW0gfHwgbnVsbCxcbiAgICAgIGljZVNlcnZlcnMsXG4gICAgICBzdHVuU2VydmVycyA9IG9wdGlvbnMuc3R1blNlcnZlcnMgfHwgbnVsbCxcbiAgICAgIHR1cm5TZXJ2ZXJzID0gb3B0aW9ucy50dXJuU2VydmVycyB8fCBudWxsLFxuICAgICAgc2RwQ3JlYXRpb25TdWNjZWVkZWQgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgIHZhclxuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIC8vIHJ1biBmb3IgcmVwbHkgc3VjY2VzcyBjYWxsYmFja1xuICAgICAgICAgIHJlcGx5U3VjY2VlZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXR1cyA9IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSztcblxuICAgICAgICAgICAgc2VsZi5zZXRJbnZpdGUyeHhUaW1lcihyZXF1ZXN0LCBib2R5KTtcbiAgICAgICAgICAgIHNlbGYuc2V0QUNLVGltZXIoKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gcnVuIGZvciByZXBseSBmYWlsdXJlIGNhbGxiYWNrXG4gICAgICAgICAgcmVwbHlGYWlsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICAgICAgICAgIHNlbGYudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAvLyBDaHJvbWUgbWlnaHQgY2FsbCBvbmFkZHN0cmVhbSBiZWZvcmUgYWNjZXB0KCkgaXMgY2FsbGVkLCB3aGljaCBtZWFuc1xuICAgICAgICAvLyBtZWRpYUhhbmRsZXIucmVuZGVyKCkgd2FzIGNhbGxlZCB3aXRob3V0IGEgcmVuZGVySGludCwgc28gd2UgbmVlZCB0b1xuICAgICAgICAvLyByZS1yZW5kZXIgbm93IHRoYXQgbWVkaWFIaW50LnJlbmRlciBoYXMgYmVlbiBzZXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIENocm9tZSBzZWVtcyB0byBiZSBpbiB0aGUgcmlnaHQgcmVnYXJkaW5nIHRoaXMsIHNlZVxuICAgICAgICAvLyBodHRwOi8vZGV2LnczLm9yZy8yMDExL3dlYnJ0Yy9lZGl0b3Ivd2VicnRjLmh0bWwjd2lkbC1SVENQZWVyQ29ubmVjdGlvbi1vbmFkZHN0cmVhbVxuICAgICAgICBzZWxmLm1lZGlhSGFuZGxlci5yZW5kZXIoKTtcblxuICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJyArIHNlbGYuY29udGFjdCk7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJyArIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcblxuICAgICAgICBpZighc2VsZi5oYXNPZmZlcikge1xuICAgICAgICAgIHNlbGYuaGFzT2ZmZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXNwb25zZSA9IHJlcXVlc3QucmVwbHkoMjAwLCBudWxsLCBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICByZXBseVN1Y2NlZWRlZCxcbiAgICAgICAgICAgICAgICAgICAgICByZXBseUZhaWxlZFxuICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgaWYgKHNlbGYuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7IC8vIERpZG4ndCBmYWlsXG4gICAgICAgICAgc2VsZi5hY2NlcHRlZChyZXNwb25zZSwgU0lQLlV0aWxzLmdldFJlYXNvblBocmFzZSgyMDApKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgc2RwQ3JlYXRpb25GYWlsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gLSBmYWlsIG91dCBvbiBlcnJvclxuICAgICAgICBzZWxmLnJlcXVlc3QucmVwbHkoNDgwKTtcbiAgICAgICAgLy9zZWxmLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLlVTRVJfREVOSUVEX01FRElBX0FDQ0VTUyk7XG4gICAgICAgIHNlbGYuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICBzZWxmLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICB9O1xuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0FOU1dFUkVEO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0VBUkxZX01FRElBKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIGlmICgoc3R1blNlcnZlcnMgfHwgdHVyblNlcnZlcnMpICYmXG4gICAgICAgICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfRUFSTFlfTUVESUEgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLKSkge1xuICAgICAgaWYgKHN0dW5TZXJ2ZXJzKSB7XG4gICAgICAgIGljZVNlcnZlcnMgPSBTSVAuVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFsnc3R1blNlcnZlcnMnXShzdHVuU2VydmVycyk7XG4gICAgICAgIGlmICghaWNlU2VydmVycykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3R1blNlcnZlcnM6ICcrIHN0dW5TZXJ2ZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0dW5TZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHVyblNlcnZlcnMpIHtcbiAgICAgICAgaWNlU2VydmVycyA9IFNJUC5VQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsWyd0dXJuU2VydmVycyddKHR1cm5TZXJ2ZXJzKTtcbiAgICAgICAgaWYgKCFpY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0dXJuU2VydmVyczogJysgdHVyblNlcnZlcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHVyblNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnVwZGF0ZUljZVNlcnZlcnMoe1xuICAgICAgICBzdHVuU2VydmVyczogdGhpcy5zdHVuU2VydmVycyxcbiAgICAgICAgdHVyblNlcnZlcnM6IHRoaXMudHVyblNlcnZlcnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFuIGVycm9yIG9uIGRpYWxvZyBjcmVhdGlvbiB3aWxsIGZpcmUgJ2ZhaWxlZCcgZXZlbnRcbiAgICBpZighdGhpcy5jcmVhdGVEaWFsb2cocmVxdWVzdCwgJ1VBUycpKSB7XG4gICAgICByZXF1ZXN0LnJlcGx5KDUwMCwgJ01pc3NpbmcgQ29udGFjdCBoZWFkZXIgZmllbGQnKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnVzZXJOb0Fuc3dlclRpbWVyKTtcblxuICAgIC8vIHRoaXMgaG9sZC1yZWxhdGVkIGNvZGUgYnJlYWtzIEZGIGFjY2VwdGluZyBuZXcgY2FsbHMgLSBKTUYgMjAxNC0xLTIxXG4gICAgLypcbiAgICBsZW5ndGggPSB0aGlzLmdldFJlbW90ZVN0cmVhbXMoKS5sZW5ndGg7XG5cbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhSGFuZGxlci5nZXRSZW1vdGVTdHJlYW1zKClbaWR4XS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaGFzVmlkZW8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWVkaWFIYW5kbGVyLmdldFJlbW90ZVN0cmVhbXMoKVtpZHhdLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICBoYXNBdWRpbyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYXNBdWRpbyAmJiB0aGlzLm1lZGlhQ29uc3RyYWludHMuYXVkaW8gPT09IHRydWUpIHtcbiAgICAgIHRoaXMubWVkaWFDb25zdHJhaW50cy5hdWRpbyA9IGZhbHNlO1xuICAgICAgaWYgKG1lZGlhU3RyZWFtKSB7XG4gICAgICAgIGxlbmd0aCA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoO1xuICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayhtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpW2lkeF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYXNWaWRlbyAmJiB0aGlzLm1lZGlhQ29uc3RyYWludHMudmlkZW8gPT09IHRydWUpIHtcbiAgICAgIHRoaXMubWVkaWFDb25zdHJhaW50cy52aWRlbyA9IGZhbHNlO1xuICAgICAgaWYgKG1lZGlhU3RyZWFtKSB7XG4gICAgICAgIGxlbmd0aCA9IG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoO1xuICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayhtZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpW2lkeF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICovXG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBKSB7XG4gICAgICBzZHBDcmVhdGlvblN1Y2NlZWRlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbihzZWxmLm1lZGlhSGludClcbiAgICAgIC50aGVuKFxuICAgICAgICBzZHBDcmVhdGlvblN1Y2NlZWRlZCxcbiAgICAgICAgc2RwQ3JlYXRpb25GYWlsZWRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVjZWl2ZVJlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcblxuICAgIC8vIElTQyBSRUNFSVZFIFJFUVVFU1RcblxuICAgIGZ1bmN0aW9uIGNvbmZpcm1TZXNzaW9uKCkge1xuICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgY29udGVudFR5cGU7XG5cbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmFja1RpbWVyKTtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmludml0ZTJ4eFRpbWVyKTtcbiAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgdGhpcy51bm11dGUoKTtcblxuICAgICAgLy8gVE9ETyAtIHRoaXMgbG9naWMgYXNzdW1lcyBDb250ZW50LURpc3Bvc2l0aW9uIGRlZmF1bHRzXG4gICAgICBjb250ZW50VHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgIGlmIChjb250ZW50VHlwZSAhPT0gJ2FwcGxpY2F0aW9uL3NkcCcpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICB0aGlzLnJlbmRlcnR5cGUgPSBjb250ZW50VHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2gocmVxdWVzdC5tZXRob2QpIHtcbiAgICBjYXNlIFNJUC5DLkNBTkNFTDpcbiAgICAgIC8qIFJGQzMyNjEgMTUgU3RhdGVzIHRoYXQgYSBVQVMgbWF5IGhhdmUgYWNjZXB0ZWQgYW4gaW52aXRhdGlvbiB3aGlsZSBhIENBTkNFTFxuICAgICAgICogd2FzIGluIHByb2dyZXNzIGFuZCB0aGF0IHRoZSBVQUMgTUFZIGNvbnRpbnVlIHdpdGggdGhlIHNlc3Npb24gZXN0YWJsaXNoZWQgYnlcbiAgICAgICAqIGFueSAyeHggcmVzcG9uc2UsIG9yIE1BWSB0ZXJtaW5hdGUgd2l0aCBCWUUuIFNJUCBkb2VzIGNvbnRpbnVlIHdpdGggdGhlXG4gICAgICAgKiBlc3RhYmxpc2hlZCBzZXNzaW9uLiBTbyB0aGUgQ0FOQ0VMIGlzIHByb2Nlc3NlZCBvbmx5IGlmIHRoZSBzZXNzaW9uIGlzIG5vdCB5ZXRcbiAgICAgICAqIGVzdGFibGlzaGVkLlxuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICAgKiBUZXJtaW5hdGUgdGhlIHdob2xlIHNlc3Npb24gaW4gY2FzZSB0aGUgdXNlciBkaWRuJ3QgYWNjZXB0IChvciB5ZXQgdG8gc2VuZCB0aGUgYW5zd2VyKSBub3IgcmVqZWN0IHRoZVxuICAgICAgICpyZXF1ZXN0IG9wZW5pbmcgdGhlIHNlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVIgfHxcbiAgICAgICAgIHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSyB8fFxuICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLIHx8XG4gICAgICAgICB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfRUFSTFlfTUVESUEgfHxcbiAgICAgICAgIHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19BTlNXRVJFRCkge1xuXG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfQ0FOQ0VMRUQ7XG4gICAgICAgIHRoaXMucmVxdWVzdC5yZXBseSg0ODcpO1xuICAgICAgICB0aGlzLmNhbmNlbGVkKHJlcXVlc3QpO1xuICAgICAgICB0aGlzLnJlamVjdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5DQU5DRUxFRCk7XG4gICAgICAgIHRoaXMuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5DQU5DRUxFRCk7XG4gICAgICAgIHRoaXMudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQ0FOQ0VMRUQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSVAuQy5BQ0s6XG4gICAgICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNBbnN3ZXIpIHtcbiAgICAgICAgICBpZihyZXF1ZXN0LmJvZHkgJiYgcmVxdWVzdC5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpID09PSAnYXBwbGljYXRpb24vc2RwJykge1xuICAgICAgICAgICAgLy8gQUNLIGNvbnRhaW5zIGFuc3dlciB0byBhbiBJTlZJVEUgdy9vIFNEUCBuZWdvdGlhdGlvblxuICAgICAgICAgICAgU0lQLkhhY2tzLkZpcmVmb3guY2Fubm90SGFuZGxlRXh0cmFXaGl0ZXNwYWNlKHJlcXVlc3QpO1xuICAgICAgICAgICAgU0lQLkhhY2tzLkFsbEJyb3dzZXJzLm1hc2tEdGxzKHJlcXVlc3QpO1xuXG4gICAgICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXF1ZXN0LmJvZHkpXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgY29uZmlybVNlc3Npb24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSh7XG4gICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAnNDg4JyxcbiAgICAgICAgICAgICAgICAgIHJlYXNvblBocmFzZTogJ0JhZCBNZWRpYSBEZXNjcmlwdGlvbidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZWFybHlfc2RwKSB7XG4gICAgICAgICAgICBjb25maXJtU2Vzc2lvbi5hcHBseSh0aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9UT0RPOiBQYXNzIHRvIG1lZGlhaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmZpcm1TZXNzaW9uLmFwcGx5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNJUC5DLlBSQUNLOlxuICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSyB8fCB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgLy9sb2NhbE1lZGlhID0gc2Vzc2lvbi5tZWRpYUhhbmRsZXIubG9jYWxNZWRpYTtcbiAgICAgICAgaWYoIXRoaXMuaGFzQW5zd2VyKSB7XG4gICAgICAgICAgaWYocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSA9PT0gJ2FwcGxpY2F0aW9uL3NkcCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlcXVlc3QuYm9keSlcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiBvblN1Y2Nlc3MgKCkge1xuICAgICAgICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnJlbDF4eFRpbWVyKTtcbiAgICAgICAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5wcmFja1RpbWVyKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgICAgLy9SRVZJU0lUXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlKCk7XG4gICAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlIChlKSB7XG4gICAgICAgICAgICAgICAgLy9UT0RPOiBTZW5kIHRvIG1lZGlhIGhhbmRsZXJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMudGVybWluYXRlKHtcbiAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6ICc0ODgnLFxuICAgICAgICAgICAgICAgICAgcmVhc29uUGhyYXNlOiAnQmFkIE1lZGlhIERlc2NyaXB0aW9uJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgIHRoaXMudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSh7XG4gICAgICAgICAgICAgIHN0YXR1c0NvZGU6ICc0ODgnLFxuICAgICAgICAgICAgICByZWFzb25QaHJhc2U6ICdCYWQgTWVkaWEgRGVzY3JpcHRpb24nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5yZWwxeHhUaW1lcik7XG4gICAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMucHJhY2tUaW1lcik7XG4gICAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgLy9SRVZJU0lUXG4gICAgICAgICAgdGhpcy5tdXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfRUFSTFlfTUVESUEpIHtcbiAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIFNlc3Npb24ucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0LmFwcGx5KHRoaXMsIFtyZXF1ZXN0XSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19DT05GSVJNRUQgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9XG4gIH0sXG5cbiAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9XG4gIH1cblxufTtcblxuU0lQLkludml0ZVNlcnZlckNvbnRleHQgPSBJbnZpdGVTZXJ2ZXJDb250ZXh0O1xuXG5JbnZpdGVDbGllbnRDb250ZXh0ID0gZnVuY3Rpb24odWEsIHRhcmdldCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShTZXNzaW9uLmRlc3VnYXIob3B0aW9ucykpO1xuICBvcHRpb25zLnBhcmFtcyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5wYXJhbXMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG5cbiAgdmFyIGljZVNlcnZlcnMsXG4gICAgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpLFxuICAgIHN0dW5TZXJ2ZXJzID0gb3B0aW9ucy5zdHVuU2VydmVycyB8fCBudWxsLFxuICAgIHR1cm5TZXJ2ZXJzID0gb3B0aW9ucy50dXJuU2VydmVycyB8fCBudWxsLFxuICAgIG1lZGlhSGFuZGxlckZhY3RvcnkgPSBvcHRpb25zLm1lZGlhSGFuZGxlckZhY3RvcnkgfHwgdWEuY29uZmlndXJhdGlvbi5tZWRpYUhhbmRsZXJGYWN0b3J5LFxuICAgIGlzTWVkaWFTdXBwb3J0ZWQgPSBtZWRpYUhhbmRsZXJGYWN0b3J5LmlzU3VwcG9ydGVkO1xuXG4gIC8vIENoZWNrIFdlYlJUQyBzdXBwb3J0XG4gIGlmIChpc01lZGlhU3VwcG9ydGVkICYmICFpc01lZGlhU3VwcG9ydGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuTm90U3VwcG9ydGVkRXJyb3IoJ01lZGlhIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIHRoaXMuUlRDQ29uc3RyYWludHMgPSBvcHRpb25zLlJUQ0NvbnN0cmFpbnRzIHx8IHt9O1xuICB0aGlzLmludml0ZVdpdGhvdXRTZHAgPSBvcHRpb25zLmludml0ZVdpdGhvdXRTZHAgfHwgZmFsc2U7XG5cbiAgLy8gU2V0IGFub255bW91cyBwcm9wZXJ0eVxuICB0aGlzLmFub255bW91cyA9IG9wdGlvbnMuYW5vbnltb3VzIHx8IGZhbHNlO1xuXG4gIC8vIEN1c3RvbSBkYXRhIHRvIGJlIHNlbnQgZWl0aGVyIGluIElOVklURSBvciBpbiBBQ0tcbiAgdGhpcy5yZW5kZXJib2R5ID0gb3B0aW9ucy5yZW5kZXJib2R5IHx8IG51bGw7XG4gIHRoaXMucmVuZGVydHlwZSA9IG9wdGlvbnMucmVuZGVydHlwZSB8fCAndGV4dC9wbGFpbic7XG5cbiAgb3B0aW9ucy5wYXJhbXMuZnJvbV90YWcgPSB0aGlzLmZyb21fdGFnO1xuXG4gIC8qIERvIG5vdCBhZGQgO29iIGluIGluaXRpYWwgZm9ybWluZyBkaWFsb2cgcmVxdWVzdHMgaWYgdGhlIHJlZ2lzdHJhdGlvbiBvdmVyXG4gICAqICB0aGUgY3VycmVudCBjb25uZWN0aW9uIGdvdCBhIEdSVVUgVVJJLlxuICAgKi9cbiAgdGhpcy5jb250YWN0ID0gdWEuY29udGFjdC50b1N0cmluZyh7XG4gICAgYW5vbnltb3VzOiB0aGlzLmFub255bW91cyxcbiAgICBvdXRib3VuZDogdGhpcy5hbm9ueW1vdXMgPyAhdWEuY29udGFjdC50ZW1wX2dydXUgOiAhdWEuY29udGFjdC5wdWJfZ3J1dVxuICB9KTtcblxuICBpZiAodGhpcy5hbm9ueW1vdXMpIHtcbiAgICBvcHRpb25zLnBhcmFtcy5mcm9tX2Rpc3BsYXlOYW1lID0gJ0Fub255bW91cyc7XG4gICAgb3B0aW9ucy5wYXJhbXMuZnJvbV91cmkgPSAnc2lwOmFub255bW91c0Bhbm9ueW1vdXMuaW52YWxpZCc7XG5cbiAgICBleHRyYUhlYWRlcnMucHVzaCgnUC1QcmVmZXJyZWQtSWRlbnRpdHk6ICcrIHVhLmNvbmZpZ3VyYXRpb24udXJpLnRvU3RyaW5nKCkpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdQcml2YWN5OiBpZCcpO1xuICB9XG4gIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnKyB0aGlzLmNvbnRhY3QpO1xuICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcrIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcbiAgaWYgKCF0aGlzLmludml0ZVdpdGhvdXRTZHApIHtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9zZHAnKTtcbiAgfSBlbHNlIGlmICh0aGlzLnJlbmRlcmJvZHkpIHtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiAnICsgdGhpcy5yZW5kZXJ0eXBlKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1EaXNwb3NpdGlvbjogcmVuZGVyO2hhbmRsaW5nPW9wdGlvbmFsJyk7XG4gIH1cblxuICBpZiAodWEuY29uZmlndXJhdGlvbi5yZWwxMDAgPT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZXF1aXJlOiAxMDByZWwnKTtcbiAgfVxuICBpZiAodWEuY29uZmlndXJhdGlvbi5yZXBsYWNlcyA9PT0gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSB7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JlcXVpcmU6IHJlcGxhY2VzJyk7XG4gIH1cblxuICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcblxuICBTSVAuVXRpbHMuYXVnbWVudCh0aGlzLCBTSVAuQ2xpZW50Q29udGV4dCwgW3VhLCBTSVAuQy5JTlZJVEUsIHRhcmdldCwgb3B0aW9uc10pO1xuICBTSVAuVXRpbHMuYXVnbWVudCh0aGlzLCBTSVAuU2Vzc2lvbiwgW21lZGlhSGFuZGxlckZhY3RvcnldKTtcblxuICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX05VTEwpIHtcbiAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICB9XG5cbiAgLy8gU2Vzc2lvbiBwYXJhbWV0ZXIgaW5pdGlhbGl6YXRpb25cbiAgdGhpcy5mcm9tX3RhZyA9IFNJUC5VdGlscy5uZXdUYWcoKTtcblxuICAvLyBPdXRnb2luZ1Nlc3Npb24gc3BlY2lmaWMgcGFyYW1ldGVyc1xuICB0aGlzLmlzQ2FuY2VsZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWNlaXZlZF8xMDAgPSBmYWxzZTtcblxuICB0aGlzLm1ldGhvZCA9IFNJUC5DLklOVklURTtcblxuICB0aGlzLnJlY2VpdmVOb25JbnZpdGVSZXNwb25zZSA9IHRoaXMucmVjZWl2ZVJlc3BvbnNlO1xuICB0aGlzLnJlY2VpdmVSZXNwb25zZSA9IHRoaXMucmVjZWl2ZUludml0ZVJlc3BvbnNlO1xuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuaW52aXRlY2xpZW50Y29udGV4dCcpO1xuXG4gIGlmIChzdHVuU2VydmVycykge1xuICAgIGljZVNlcnZlcnMgPSBTSVAuVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFsnc3R1blNlcnZlcnMnXShzdHVuU2VydmVycyk7XG4gICAgaWYgKCFpY2VTZXJ2ZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0dW5TZXJ2ZXJzOiAnKyBzdHVuU2VydmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R1blNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0dXJuU2VydmVycykge1xuICAgIGljZVNlcnZlcnMgPSBTSVAuVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFsndHVyblNlcnZlcnMnXSh0dXJuU2VydmVycyk7XG4gICAgaWYgKCFpY2VTZXJ2ZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHR1cm5TZXJ2ZXJzOiAnKyB0dXJuU2VydmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHVyblNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgIH1cbiAgfVxuXG4gIHVhLmFwcGxpY2FudHNbdGhpc10gPSB0aGlzO1xuXG4gIHRoaXMuaWQgPSB0aGlzLnJlcXVlc3QuY2FsbF9pZCArIHRoaXMuZnJvbV90YWc7XG5cbiAgLy9Jbml0aWFsaXplIE1lZGlhIFNlc3Npb25cbiAgdGhpcy5tZWRpYUhhbmRsZXIgPSB0aGlzLm1lZGlhSGFuZGxlckZhY3RvcnkodGhpcywge1xuICAgIFJUQ0NvbnN0cmFpbnRzOiB0aGlzLlJUQ0NvbnN0cmFpbnRzLFxuICAgIHN0dW5TZXJ2ZXJzOiB0aGlzLnN0dW5TZXJ2ZXJzLFxuICAgIHR1cm5TZXJ2ZXJzOiB0aGlzLnR1cm5TZXJ2ZXJzXG4gIH0pO1xuXG4gIGlmICh0aGlzLm1lZGlhSGFuZGxlciAmJiB0aGlzLm1lZGlhSGFuZGxlci5nZXRSZW1vdGVTdHJlYW1zKSB7XG4gICAgdGhpcy5nZXRSZW1vdGVTdHJlYW1zID0gdGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVtb3RlU3RyZWFtcy5iaW5kKHRoaXMubWVkaWFIYW5kbGVyKTtcbiAgICB0aGlzLmdldExvY2FsU3RyZWFtcyA9IHRoaXMubWVkaWFIYW5kbGVyLmdldExvY2FsU3RyZWFtcy5iaW5kKHRoaXMubWVkaWFIYW5kbGVyKTtcbiAgfVxuXG4gIFNJUC5VdGlscy5vcHRpb25zT3ZlcnJpZGUob3B0aW9ucywgJ21lZGlhJywgJ21lZGlhQ29uc3RyYWludHMnLCB0cnVlLCB0aGlzLmxvZ2dlciwgdGhpcy51YS5jb25maWd1cmF0aW9uLm1lZGlhKTtcbiAgdGhpcy5tZWRpYUhpbnQgPSBvcHRpb25zLm1lZGlhO1xufTtcblxuSW52aXRlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUgPSB7XG4gIGludml0ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vU2F2ZSB0aGUgc2Vzc2lvbiBpbnRvIHRoZSB1YSBzZXNzaW9ucyBjb2xsZWN0aW9uLlxuICAgIC8vTm90ZTogcGxhY2luZyBpbiBjb25zdHJ1Y3RvciBicmVha3MgY2FsbCB0byByZXF1ZXN0LmNhbmNlbCBvbiBjbG9zZS4uLiBVc2VyIGRvZXMgbm90IG5lZWQgdGhpcyBhbnl3YXlcbiAgICB0aGlzLnVhLnNlc3Npb25zW3RoaXMuaWRdID0gdGhpcztcblxuICAgIC8vTm90ZTogZHVlIHRvIHRoZSB3YXkgRmlyZWZveCBoYW5kbGVzIGdVTSBjYWxscywgaXQgaXMgcmVjb21tZW5kZWQgdG8gbWFrZSB0aGUgZ1VNIGNhbGwgYXQgdGhlIGFwcCBsZXZlbFxuICAgIC8vIGFuZCBoYW5kIHNpcC5qcyBhIHN0cmVhbSBhcyB0aGUgbWVkaWFIaW50XG4gICAgaWYgKHRoaXMuaW52aXRlV2l0aG91dFNkcCkge1xuICAgICAgLy9qdXN0IHNlbmQgYW4gaW52aXRlIHdpdGggbm8gc2RwLi4uXG4gICAgICB0aGlzLnJlcXVlc3QuYm9keSA9IHNlbGYucmVuZGVyYm9keTtcbiAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfSU5WSVRFX1NFTlQ7XG4gICAgICB0aGlzLnNlbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24oc2VsZi5tZWRpYUhpbnQpXG4gICAgICAudGhlbihcbiAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzKG9mZmVyKSB7XG4gICAgICAgICAgaWYgKHNlbGYuaXNDYW5jZWxlZCB8fCBzZWxmLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmhhc09mZmVyID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLnJlcXVlc3QuYm9keSA9IG9mZmVyO1xuICAgICAgICAgIHNlbGYuc3RhdHVzID0gQy5TVEFUVVNfSU5WSVRFX1NFTlQ7XG4gICAgICAgICAgc2VsZi5zZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSgpIHtcbiAgICAgICAgICBpZiAoc2VsZi5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETy4uLmZhaWwgb3V0XG4gICAgICAgICAgLy9zZWxmLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuVVNFUl9ERU5JRURfTUVESUFfQUNDRVNTKTtcbiAgICAgICAgICAvL3NlbGYuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgIHNlbGYuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgIHNlbGYudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZWNlaXZlSW52aXRlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgdmFyIGNhdXNlLCAvL2xvY2FsTWVkaWEsXG4gICAgICBzZXNzaW9uID0gdGhpcyxcbiAgICAgIGlkID0gcmVzcG9uc2UuY2FsbF9pZCArIHJlc3BvbnNlLmZyb21fdGFnICsgcmVzcG9uc2UudG9fdGFnLFxuICAgICAgZXh0cmFIZWFkZXJzID0gW10sXG4gICAgICBvcHRpb25zID0ge307XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQgfHwgcmVzcG9uc2UubWV0aG9kICE9PSBTSVAuQy5JTlZJVEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kaWFsb2cgJiYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA8PSAyOTkpKSB7XG4gICAgICBpZiAoaWQgIT09IHRoaXMuZGlhbG9nLmlkLnRvU3RyaW5nKCkgKSB7XG4gICAgICAgIGlmICghdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnLCB0cnVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0uc2VuZFJlcXVlc3QodGhpcywgU0lQLkMuQUNLLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBTSVAuVXRpbHMuZ2VuZXJhdGVGYWtlU0RQKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnNlbmRSZXF1ZXN0KHRoaXMsIFNJUC5DLkJZRSk7XG5cbiAgICAgICAgLyogTk9URTogVGhpcyBmYWlscyBiZWNhdXNlIHRoZSBmb3JraW5nIHByb3h5IGRvZXMgbm90IHJlY29nbml6ZSB0aGF0IGFuIHVuYW5zd2VyYWJsZVxuICAgICAgICAgKiBsZWcgKGR1ZSB0byBwZWVyQ29ubmVjdGlvbiBsaW1pdGF0aW9ucykgaGFzIGJlZW4gYW5zd2VyZWQgZmlyc3QuIElmIHlvdXIgZm9ya2luZ1xuICAgICAgICAgKiBwcm94eSBkb2VzIG5vdCBoYW5nIHVwIGFsbCB1bmFuc3dlcmVkIGJyYW5jaGVzIG9uIHRoZSBmaXJzdCBicmFuY2ggYW5zd2VyZWQsIHJlbW92ZSB0aGlzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSyx7Y3NlcTogcmVzcG9uc2UuY3NlcX0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmhhc0Fuc3dlcikge1xuICAgICAgICAvLyBpbnZpdGUgdy9vIHNkcCBpcyB3YWl0aW5nIGZvciBjYWxsYmFja1xuICAgICAgICAvL2FuIGludml0ZSB3aXRoIHNkcCBtdXN0IGdvIG9uLCBhbmQgaGFzQW5zd2VyIGlzIHRydWVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmRpYWxvZyAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA8IDIwMCkge1xuICAgICAgLypcbiAgICAgICAgRWFybHkgbWVkaWEgaGFzIGJlZW4gc2V0IHVwIHdpdGggYXQgbGVhc3Qgb25lIG90aGVyIGRpZmZlcmVudCBicmFuY2gsXG4gICAgICAgIGJ1dCBhIGZpbmFsIDJ4eCByZXNwb25zZSBoYXNuJ3QgYmVlbiByZWNlaXZlZFxuICAgICAgKi9cbiAgICAgIGlmICh0aGlzLmRpYWxvZy5wcmFja2VkLmluZGV4T2YocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpICE9PSAtMSB8fFxuICAgICAgICAgICh0aGlzLmRpYWxvZy5wcmFja2VkW3RoaXMuZGlhbG9nLnByYWNrZWQubGVuZ3RoLTFdID49IHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICYmIHRoaXMuZGlhbG9nLnByYWNrZWQubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZWFybHlEaWFsb2dzW2lkXSAmJiAhdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnLCB0cnVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5pbmRleE9mKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKSAhPT0gLTEgfHxcbiAgICAgICAgICAodGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWRbdGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQubGVuZ3RoLTFdID49IHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICYmIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JBY2s6ICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSArICcgJyArIHJlc3BvbnNlLmdldEhlYWRlcignY3NlcScpKTtcbiAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLnB1c2gocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpO1xuXG4gICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0uc2VuZFJlcXVlc3QodGhpcywgU0lQLkMuUFJBQ0ssIHtcbiAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgIGJvZHk6IFNJUC5VdGlscy5nZW5lcmF0ZUZha2VTRFAocmVzcG9uc2UuYm9keSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByb2NlZWQgdG8gY2FuY2VsbGF0aW9uIGlmIHRoZSB1c2VyIHJlcXVlc3RlZC5cbiAgICBpZih0aGlzLmlzQ2FuY2VsZWQpIHtcbiAgICAgIGlmKHJlc3BvbnNlLnN0YXR1c19jb2RlID49IDEwMCAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA8IDIwMCkge1xuICAgICAgICB0aGlzLnJlcXVlc3QuY2FuY2VsKHRoaXMuY2FuY2VsUmVhc29uKTtcbiAgICAgICAgdGhpcy5jYW5jZWxlZChudWxsKTtcbiAgICAgIH0gZWxzZSBpZihyZXNwb25zZS5zdGF0dXNfY29kZSA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPCAyOTkpIHtcbiAgICAgICAgdGhpcy5hY2NlcHRBbmRUZXJtaW5hdGUocmVzcG9uc2UpO1xuICAgICAgICB0aGlzLmVtaXQoJ2J5ZScsIHRoaXMucmVxdWVzdCk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID49IDMwMCkge1xuICAgICAgICBjYXVzZSA9IFNJUC5DLlJFQVNPTl9QSFJBU0VbcmVzcG9uc2Uuc3RhdHVzX2NvZGVdIHx8IFNJUC5DLmNhdXNlcy5DQU5DRUxFRDtcbiAgICAgICAgdGhpcy5yZWplY3RlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2godHJ1ZSkge1xuICAgICAgY2FzZSAvXjEwMCQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICB0aGlzLnJlY2VpdmVkXzEwMCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAoL14xWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKSk6XG4gICAgICAgIC8vIERvIG5vdGhpbmcgd2l0aCAxeHggcmVzcG9uc2VzIHdpdGhvdXQgVG8gdGFnLlxuICAgICAgICBpZighcmVzcG9uc2UudG9fdGFnKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybignMXh4IHJlc3BvbnNlIHJlY2VpdmVkIHdpdGhvdXQgdG8gdGFnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgRWFybHkgRGlhbG9nIGlmIDFYWCBjb21lcyB3aXRoIGNvbnRhY3RcbiAgICAgICAgaWYocmVzcG9uc2UuaGFzSGVhZGVyKCdjb250YWN0JykpIHtcbiAgICAgICAgICAvLyBBbiBlcnJvciBvbiBkaWFsb2cgY3JlYXRpb24gd2lsbCBmaXJlICdmYWlsZWQnIGV2ZW50XG4gICAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycsIHRydWUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTXzFYWF9SRUNFSVZFRDtcblxuICAgICAgICBpZihyZXNwb25zZS5oYXNIZWFkZXIoJ3JlcXVpcmUnKSAmJlxuICAgICAgICAgICByZXNwb25zZS5nZXRIZWFkZXIoJ3JlcXVpcmUnKS5pbmRleE9mKCcxMDByZWwnKSAhPT0gLTEpIHtcblxuICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhpcy5kaWFsb2cgaXMgYWxyZWFkeSBjb25maXJtZWRcbiAgICAgICAgICBpZiAodGhpcy5kaWFsb2cgfHwgIXRoaXMuZWFybHlEaWFsb2dzW2lkXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLmluZGV4T2YocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAodGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWRbdGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQubGVuZ3RoLTFdID49IHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICYmIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgU0lQLkhhY2tzLkZpcmVmb3guY2Fubm90SGFuZGxlRXh0cmFXaGl0ZXNwYWNlKHJlc3BvbnNlKTtcbiAgICAgICAgICBTSVAuSGFja3MuQWxsQnJvd3NlcnMubWFza0R0bHMocmVzcG9uc2UpO1xuXG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnUkFjazogJyArIHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICsgJyAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdjc2VxJykpO1xuICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQucHVzaChyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSk7XG4gICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0uc2VuZFJlcXVlc3QodGhpcywgU0lQLkMuUFJBQ0ssIHtcbiAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNPZmZlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kaWFsb2cucHJhY2tlZC5wdXNoKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKTtcblxuICAgICAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVzcG9uc2UuYm9keSlcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiBvblN1Y2Nlc3MgKCkge1xuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSQWNrOiAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykgKyAnICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ2NzZXEnKSk7XG5cbiAgICAgICAgICAgICAgICBzZXNzaW9uLnNlbmRSZXF1ZXN0KFNJUC5DLlBSQUNLLCB7XG4gICAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5tdXRlKCk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0YXR1cyA9PT0gQy5TVEFUVVNfRUFSTFlfTUVESUEpIHtcbiAgICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpWzBdLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlIChlKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmFjY2VwdEFuZFRlcm1pbmF0ZShyZXNwb25zZSwgNDg4LCAnTm90IEFjY2VwdGFibGUgSGVyZScpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVhcmx5RGlhbG9nID0gdGhpcy5lYXJseURpYWxvZ3NbaWRdO1xuICAgICAgICAgICAgdmFyIGVhcmx5TWVkaWEgPSBlYXJseURpYWxvZy5tZWRpYUhhbmRsZXI7XG5cbiAgICAgICAgICAgIGVhcmx5RGlhbG9nLnByYWNrZWQucHVzaChyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSk7XG5cbiAgICAgICAgICAgIGVhcmx5TWVkaWEuc2V0RGVzY3JpcHRpb24ocmVzcG9uc2UuYm9keSlcbiAgICAgICAgICAgIC50aGVuKGVhcmx5TWVkaWEuZ2V0RGVzY3JpcHRpb24uYmluZChlYXJseU1lZGlhLCBzZXNzaW9uLm1lZGlhSGludCkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiBvblN1Y2Nlc3Moc2RwKSB7XG4gICAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL3NkcCcpO1xuICAgICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnUkFjazogJyArIHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICsgJyAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdjc2VxJykpO1xuICAgICAgICAgICAgICBlYXJseURpYWxvZy5zZW5kUmVxdWVzdChzZXNzaW9uLCBTSVAuQy5QUkFDSywge1xuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHNkcFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5zdGF0dXMgPSBDLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gb25GYWlsdXJlKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTSVAuRXhjZXB0aW9ucy5HZXREZXNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgZWFybHlEaWFsb2cucHJhY2tlZC5wdXNoKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIGZhaWwgb3V0IG9uIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gc2Vzc2lvbi5mYWlsZWQoZ3VtIGVycm9yKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWFybHlEaWFsb2cucHJhY2tlZC5zcGxpY2UoZWFybHlEaWFsb2cucHJhY2tlZC5pbmRleE9mKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKSwgMSk7XG4gICAgICAgICAgICAgICAgLy8gQ291bGQgbm90IHNldCByZW1vdGUgZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKCdpbnZhbGlkIFNEUCcpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICB2YXIgY3NlcSA9IHRoaXMucmVxdWVzdC5jc2VxICsgJyAnICsgdGhpcy5yZXF1ZXN0Lm1ldGhvZDtcbiAgICAgICAgaWYgKGNzZXEgIT09IHJlc3BvbnNlLmdldEhlYWRlcignY3NlcScpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBICYmIHRoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgdGhpcy51bm11dGUoKTtcbiAgICAgICAgICAvKmxvY2FsTWVkaWEgPSB0aGlzLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhO1xuICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9Ki9cbiAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgaWYgKHRoaXMucmVuZGVyYm9keSkge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogJyArIHRoaXMucmVuZGVydHlwZSk7XG4gICAgICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcbiAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IHRoaXMucmVuZGVyYm9keTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0aW9ucy5jc2VxID0gcmVzcG9uc2UuY3NlcTtcbiAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSywgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5hY2NlcHRlZChyZXNwb25zZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGlzLmRpYWxvZyBpcyBhbHJlYWR5IGNvbmZpcm1lZFxuICAgICAgICBpZiAodGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIFNJUC5IYWNrcy5GaXJlZm94LmNhbm5vdEhhbmRsZUV4dHJhV2hpdGVzcGFjZShyZXNwb25zZSk7XG4gICAgICAgIFNJUC5IYWNrcy5BbGxCcm93c2Vycy5tYXNrRHRscyhyZXNwb25zZSk7XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnZpdGUgd2l0aG91dCBzZHBcbiAgICAgICAgaWYgKCF0aGlzLmhhc09mZmVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWFybHlEaWFsb2dzW2lkXSAmJiB0aGlzLmVhcmx5RGlhbG9nc1tpZF0ubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWEpIHtcbiAgICAgICAgICAgIC8vUkVWSVNJVFxuICAgICAgICAgICAgdGhpcy5oYXNPZmZlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1lZGlhSGFuZGxlciA9IHRoaXMuZWFybHlEaWFsb2dzW2lkXS5tZWRpYUhhbmRsZXI7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuQUNLLCB7Y3NlcTpyZXNwb25zZS5jc2VxfSk7XG5cbiAgICAgICAgICAgIHRoaXMudW5tdXRlKCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgbG9jYWxNZWRpYSA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWE7XG4gICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdGhpcy5hY2NlcHRlZChyZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICAgIHRoaXMuYWNjZXB0QW5kVGVybWluYXRlKHJlc3BvbnNlLCA0MDAsICdNaXNzaW5nIHNlc3Npb24gZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFzT2ZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVzcG9uc2UuYm9keSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMubWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uLmJpbmQodGhpcy5tZWRpYUhhbmRsZXIsIHRoaXMubWVkaWFIaW50KSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIG9uU3VjY2VzcyhzZHApIHtcbiAgICAgICAgICAgICAgLy92YXIgbG9jYWxNZWRpYTtcbiAgICAgICAgICAgICAgaWYoc2Vzc2lvbi5pc0NhbmNlbGVkIHx8IHNlc3Npb24uc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2RwID0gU0lQLkhhY2tzLkZpcmVmb3guaGFzTWlzc2luZ0NMaW5lSW5TRFAoc2RwKTtcblxuICAgICAgICAgICAgICBzZXNzaW9uLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5oYXNBbnN3ZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIHNlc3Npb24udW5tdXRlKCk7XG4gICAgICAgICAgICAgIC8qbG9jYWxNZWRpYSA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWE7XG4gICAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgICBzZXNzaW9uLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSyx7XG4gICAgICAgICAgICAgICAgYm9keTogc2RwLFxuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczpbJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vc2RwJ10sXG4gICAgICAgICAgICAgICAgY3NlcTpyZXNwb25zZS5jc2VxXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZXNzaW9uLmFjY2VwdGVkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gb25GYWlsdXJlKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTSVAuRXhjZXB0aW9ucy5HZXREZXNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBkbyBzb21ldGhpbmcgaGVyZVxuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oXCJ0aGVyZSB3YXMgYSBwcm9ibGVtXCIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oJ2ludmFsaWQgU0RQJyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5yZXBseSg0ODgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNBbnN3ZXIpe1xuICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmJvZHkpIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6ICcgKyBzZXNzaW9uLnJlbmRlcnR5cGUpO1xuICAgICAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSB0aGlzLnJlbmRlcmJvZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuQUNLLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZighcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgdGhpcy5hY2NlcHRBbmRUZXJtaW5hdGUocmVzcG9uc2UsIDQwMCwgJ01pc3Npbmcgc2Vzc2lvbiBkZXNjcmlwdGlvbicpO1xuICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5ib2R5KVxuICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzICgpIHtcbiAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTsvLyxsb2NhbE1lZGlhO1xuICAgICAgICAgICAgICBzZXNzaW9uLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgICAgICAgICAgc2Vzc2lvbi51bm11dGUoKTtcbiAgICAgICAgICAgICAgLypsb2NhbE1lZGlhID0gc2Vzc2lvbi5tZWRpYUhhbmRsZXIubG9jYWxNZWRpYTtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgIGlmIChzZXNzaW9uLnJlbmRlcmJvZHkpIHtcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiAnICsgc2Vzc2lvbi5yZW5kZXJ0eXBlKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBzZXNzaW9uLnJlbmRlcmJvZHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3B0aW9ucy5jc2VxID0gcmVzcG9uc2UuY3NlcTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdChTSVAuQy5BQ0ssIG9wdGlvbnMpO1xuICAgICAgICAgICAgICBzZXNzaW9uLmFjY2VwdGVkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUgKGUpIHtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5hY2NlcHRBbmRUZXJtaW5hdGUocmVzcG9uc2UsIDQ4OCwgJ05vdCBBY2NlcHRhYmxlIEhlcmUnKTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjYXVzZSA9IFNJUC5VdGlscy5zaXBFcnJvckNhdXNlKHJlc3BvbnNlLnN0YXR1c19jb2RlKTtcbiAgICAgICAgdGhpcy5yZWplY3RlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICB9XG4gIH0sXG5cbiAgY2FuY2VsOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCB8fCB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZygnY2FuY2VsaW5nIFJUQ1Nlc3Npb24nKTtcblxuICAgIHZhciBjYW5jZWxfcmVhc29uID0gU0lQLlV0aWxzLmdldENhbmNlbFJlYXNvbihvcHRpb25zLnN0YXR1c19jb2RlLCBvcHRpb25zLnJlYXNvbl9waHJhc2UpO1xuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX05VTEwgfHxcbiAgICAgICAgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19JTlZJVEVfU0VOVCAmJiAhdGhpcy5yZWNlaXZlZF8xMDApKSB7XG4gICAgICB0aGlzLmlzQ2FuY2VsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jYW5jZWxSZWFzb24gPSBjYW5jZWxfcmVhc29uO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0lOVklURV9TRU5UIHx8XG4gICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfMVhYX1JFQ0VJVkVEIHx8XG4gICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfRUFSTFlfTUVESUEpIHtcbiAgICAgIHRoaXMucmVxdWVzdC5jYW5jZWwoY2FuY2VsX3JlYXNvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2FuY2VsZWQoKTtcbiAgfSxcblxuICB0ZXJtaW5hdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLIHx8IHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMuYnllKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbmNlbChvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZWNlaXZlUmVxdWVzdDogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIC8vIElDQyBSRUNFSVZFIFJFUVVFU1RcblxuICAgIC8vIFJlamVjdCBDQU5DRUxzXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5DQU5DRUwpIHtcbiAgICAgIC8vIFRPRE87IG1ha2UgdGhpcyBhIHN3aXRjaCB3aGVuIGl0IGdldHMgYWRkZWRcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFNJUC5DLkFDSyAmJiB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5hY2tUaW1lcik7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgIHRoaXMudW5tdXRlKCk7XG5cbiAgICAgIHRoaXMuYWNjZXB0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU2Vzc2lvbi5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QuYXBwbHkodGhpcywgW3JlcXVlc3RdKTtcbiAgfSxcblxuICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH1cbiAgfSxcblxuICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5TSVAuSW52aXRlQ2xpZW50Q29udGV4dCA9IEludml0ZUNsaWVudENvbnRleHQ7XG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1Nlc3Npb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERUTUZcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBEVE1GXG4gKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuXG52YXIgRFRNRixcbiAgQyA9IHtcbiAgICBNSU5fRFVSQVRJT046ICAgICAgICAgICAgNzAsXG4gICAgTUFYX0RVUkFUSU9OOiAgICAgICAgICAgIDYwMDAsXG4gICAgREVGQVVMVF9EVVJBVElPTjogICAgICAgIDEwMCxcbiAgICBNSU5fSU5URVJfVE9ORV9HQVA6ICAgICAgNTAsXG4gICAgREVGQVVMVF9JTlRFUl9UT05FX0dBUDogIDUwMFxuICB9O1xuXG5EVE1GID0gZnVuY3Rpb24oc2Vzc2lvbiwgdG9uZSwgb3B0aW9ucykge1xuICB2YXIgZHVyYXRpb24sIGludGVyVG9uZUdhcDtcblxuICBpZiAodG9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgfVxuXG4gIHRoaXMubG9nZ2VyID0gc2Vzc2lvbi51YS5nZXRMb2dnZXIoJ3NpcC5pbnZpdGVjb250ZXh0LmR0bWYnLCBzZXNzaW9uLmlkKTtcbiAgdGhpcy5vd25lciA9IHNlc3Npb247XG4gIHRoaXMuZGlyZWN0aW9uID0gbnVsbDtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IG51bGw7XG4gIGludGVyVG9uZUdhcCA9IG9wdGlvbnMuaW50ZXJUb25lR2FwIHx8IG51bGw7XG5cbiAgLy8gQ2hlY2sgdG9uZSB0eXBlXG4gIGlmICh0eXBlb2YgdG9uZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgdG9uZSA9IHRvbmUudG9VcHBlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdG9uZSA9PT0gJ251bWJlcicpIHtcbiAgICB0b25lID0gdG9uZS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdG9uZTogJysgdG9uZSk7XG4gIH1cblxuICAvLyBDaGVjayB0b25lIHZhbHVlXG4gIGlmICghdG9uZS5tYXRjaCgvXlswLTlBLUQjKl0kLykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRvbmU6ICcrIHRvbmUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9uZSA9IHRvbmU7XG4gIH1cblxuICAvLyBDaGVjayBkdXJhdGlvblxuICBpZiAoZHVyYXRpb24gJiYgIVNJUC5VdGlscy5pc0RlY2ltYWwoZHVyYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0b25lIGR1cmF0aW9uOiAnKyBkdXJhdGlvbik7XG4gIH0gZWxzZSBpZiAoIWR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gPSBEVE1GLkMuREVGQVVMVF9EVVJBVElPTjtcbiAgfSBlbHNlIGlmIChkdXJhdGlvbiA8IERUTUYuQy5NSU5fRFVSQVRJT04pIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdcImR1cmF0aW9uXCIgdmFsdWUgaXMgbG93ZXIgdGhhbiB0aGUgbWluaW11bSBhbGxvd2VkLCBzZXR0aW5nIGl0IHRvICcrIERUTUYuQy5NSU5fRFVSQVRJT04rICcgbWlsbGlzZWNvbmRzJyk7XG4gICAgZHVyYXRpb24gPSBEVE1GLkMuTUlOX0RVUkFUSU9OO1xuICB9IGVsc2UgaWYgKGR1cmF0aW9uID4gRFRNRi5DLk1BWF9EVVJBVElPTikge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ1wiZHVyYXRpb25cIiB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCwgc2V0dGluZyBpdCB0byAnKyBEVE1GLkMuTUFYX0RVUkFUSU9OICsnIG1pbGxpc2Vjb25kcycpO1xuICAgIGR1cmF0aW9uID0gRFRNRi5DLk1BWF9EVVJBVElPTjtcbiAgfSBlbHNlIHtcbiAgICBkdXJhdGlvbiA9IE1hdGguYWJzKGR1cmF0aW9uKTtcbiAgfVxuICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG5cbiAgLy8gQ2hlY2sgaW50ZXJUb25lR2FwXG4gIGlmIChpbnRlclRvbmVHYXAgJiYgIVNJUC5VdGlscy5pc0RlY2ltYWwoaW50ZXJUb25lR2FwKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaW50ZXJUb25lR2FwOiAnKyBpbnRlclRvbmVHYXApO1xuICB9IGVsc2UgaWYgKCFpbnRlclRvbmVHYXApIHtcbiAgICBpbnRlclRvbmVHYXAgPSBEVE1GLkMuREVGQVVMVF9JTlRFUl9UT05FX0dBUDtcbiAgfSBlbHNlIGlmIChpbnRlclRvbmVHYXAgPCBEVE1GLkMuTUlOX0lOVEVSX1RPTkVfR0FQKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignXCJpbnRlclRvbmVHYXBcIiB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBtaW5pbXVtIGFsbG93ZWQsIHNldHRpbmcgaXQgdG8gJysgRFRNRi5DLk1JTl9JTlRFUl9UT05FX0dBUCArJyBtaWxsaXNlY29uZHMnKTtcbiAgICBpbnRlclRvbmVHYXAgPSBEVE1GLkMuTUlOX0lOVEVSX1RPTkVfR0FQO1xuICB9IGVsc2Uge1xuICAgIGludGVyVG9uZUdhcCA9IE1hdGguYWJzKGludGVyVG9uZUdhcCk7XG4gIH1cbiAgdGhpcy5pbnRlclRvbmVHYXAgPSBpbnRlclRvbmVHYXA7XG59O1xuRFRNRi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuXG5EVE1GLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgZXh0cmFIZWFkZXJzLCBib2R5O1xuXG4gIHRoaXMuZGlyZWN0aW9uID0gJ291dGdvaW5nJztcblxuICAvLyBDaGVjayBSVENTZXNzaW9uIFN0YXR1c1xuICBpZiAodGhpcy5vd25lci5zdGF0dXMgIT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX0NPTkZJUk1FRCAmJlxuICAgIHRoaXMub3duZXIuc3RhdHVzICE9PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5vd25lci5zdGF0dXMpO1xuICB9XG5cbiAgLy8gR2V0IERUTUYgb3B0aW9uc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgPyBvcHRpb25zLmV4dHJhSGVhZGVycy5zbGljZSgpIDogW107XG5cbiAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vZHRtZi1yZWxheScpO1xuXG4gIGJvZHkgPSBcIlNpZ25hbD0gXCIgKyB0aGlzLnRvbmUgKyBcIlxcclxcblwiO1xuICBib2R5ICs9IFwiRHVyYXRpb249IFwiICsgdGhpcy5kdXJhdGlvbjtcblxuICB0aGlzLnJlcXVlc3QgPSB0aGlzLm93bmVyLmRpYWxvZy5zZW5kUmVxdWVzdCh0aGlzLCBTSVAuQy5JTkZPLCB7XG4gICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgYm9keTogYm9keVxuICB9KTtcblxuICB0aGlzLm93bmVyLmVtaXQoJ2R0bWYnLCB0aGlzLnJlcXVlc3QsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5EVE1GLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICB2YXIgY2F1c2U7XG5cbiAgc3dpdGNoKHRydWUpIHtcbiAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAvLyBJZ25vcmUgcHJvdmlzaW9uYWwgcmVzcG9uc2VzLlxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICB0aGlzLmVtaXQoJ3N1Y2NlZWRlZCcsIHtcbiAgICAgICAgb3JpZ2luYXRvcjogJ3JlbW90ZScsXG4gICAgICAgIHJlc3BvbnNlOiByZXNwb25zZVxuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBjYXVzZSA9IFNJUC5VdGlscy5zaXBFcnJvckNhdXNlKHJlc3BvbnNlLnN0YXR1c19jb2RlKTtcbiAgICAgIHRoaXMuZW1pdCgnZmFpbGVkJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkRUTUYucHJvdG90eXBlLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgdGhpcy5vd25lci5vblJlcXVlc3RUaW1lb3V0KCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkRUTUYucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gIHRoaXMub3duZXIub25UcmFuc3BvcnRFcnJvcigpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5EVE1GLnByb3RvdHlwZS5vbkRpYWxvZ0Vycm9yID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCByZXNwb25zZSwgU0lQLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gIHRoaXMub3duZXIub25EaWFsb2dFcnJvcihyZXNwb25zZSk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkRUTUYucHJvdG90eXBlLmluaXRfaW5jb21pbmcgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHRoaXMuZGlyZWN0aW9uID0gJ2luY29taW5nJztcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcblxuICByZXF1ZXN0LnJlcGx5KDIwMCk7XG5cbiAgaWYgKCF0aGlzLnRvbmUgfHwgIXRoaXMuZHVyYXRpb24pIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdpbnZhbGlkIElORk8gRFRNRiByZWNlaXZlZCwgZGlzY2FyZGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vd25lci5lbWl0KCdkdG1mJywgcmVxdWVzdCwgdGhpcyk7XG4gIH1cbn07XG5cbkRUTUYuQyA9IEM7XG5yZXR1cm4gRFRNRjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1Nlc3Npb24vRFRNRi5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgU3Vic2NyaWJlciAoU0lQLVNwZWNpZmljIEV2ZW50IE5vdGlmaWNhdGlvbnMgUkZDNjY2NSlcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIFNJUCBTdWJzY3JpcHRpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuU0lQLlN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICh1YSwgdGFyZ2V0LCBldmVudCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuXG4gIHRoaXMuaWQgPSBudWxsO1xuICB0aGlzLnN0YXRlID0gJ2luaXQnO1xuXG4gIGlmICghZXZlbnQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFdmVudCBuZWNlc3NhcnkgdG8gY3JlYXRlIGEgc3Vic2NyaXB0aW9uLicpO1xuICB9IGVsc2Uge1xuICAgIC8vVE9ETzogY2hlY2sgZm9yIHZhbGlkIGV2ZW50cyBoZXJlIHByb2JhYmx5IG1ha2UgYSBsaXN0IGluIFNJUC5DOyBvciBsZWF2ZSBpdCB1cCB0byBhcHAgdG8gY2hlY2s/XG4gICAgLy9UaGUgY2hlY2sgbWF5IG5lZWQgdG8vc2hvdWxkIHByb2JhYmx5IG9jY3VyIG9uIHRoZSBvdGhlciBzaWRlLFxuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgfVxuXG4gIGlmKHR5cGVvZiBvcHRpb25zLmV4cGlyZXMgIT09ICdudW1iZXInKXtcbiAgICB1YS5sb2dnZXIud2FybignZXhwaXJlcyBtdXN0IGJlIGEgbnVtYmVyLiBVc2luZyBkZWZhdWx0IG9mIDM2MDAuJyk7XG4gICAgdGhpcy5leHBpcmVzID0gMzYwMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmV4cGlyZXMgPSBvcHRpb25zLmV4cGlyZXM7XG4gIH1cblxuICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdFdmVudDogJyArIHRoaXMuZXZlbnQpO1xuICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdFeHBpcmVzOiAnICsgdGhpcy5leHBpcmVzKTtcblxuICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgdGhpcy5ib2R5ID0gb3B0aW9ucy5ib2R5O1xuICB9XG5cbiAgdGhpcy5jb250YWN0ID0gdWEuY29udGFjdC50b1N0cmluZygpO1xuXG4gIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcrIHRoaXMuY29udGFjdCk7XG4gIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG5cbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLkNsaWVudENvbnRleHQsIFt1YSwgU0lQLkMuU1VCU0NSSUJFLCB0YXJnZXQsIG9wdGlvbnNdKTtcblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnN1YnNjcmlwdGlvbicpO1xuXG4gIHRoaXMuZGlhbG9nID0gbnVsbDtcbiAgdGhpcy50aW1lcnMgPSB7TjogbnVsbCwgc3ViX2R1cmF0aW9uOiBudWxsfTtcbiAgdGhpcy5lcnJvckNvZGVzICA9IFs0MDQsNDA1LDQxMCw0MTYsNDgwLDQ4MSw0ODIsNDgzLDQ4NCw0ODUsNDg5LDUwMSw2MDRdO1xufTtcblxuU0lQLlN1YnNjcmlwdGlvbi5wcm90b3R5cGUgPSB7XG4gIHN1YnNjcmliZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN1YiA9IHRoaXM7XG5cbiAgICAgLy90aGVzZSBzdGF0ZXMgcG9pbnQgdG8gYW4gZXhpc3Rpbmcgc3Vic2NyaXB0aW9uLCBubyBzdWJzY3JpYmUgaXMgbmVjZXNzYXJ5XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICdhY3RpdmUnKSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ25vdGlmeV93YWl0Jykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uKTtcbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcbiAgICB0aGlzLnRpbWVycy5OID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHN1Yi50aW1lcl9maXJlLmJpbmQoc3ViKSwgU0lQLlRpbWVycy5USU1FUl9OKTtcblxuICAgIHRoaXMuc2VuZCgpO1xuXG4gICAgdGhpcy5zdGF0ZSA9ICdub3RpZnlfd2FpdCc7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICd0ZXJtaW5hdGVkJyB8fCB0aGlzLnN0YXRlID09PSAncGVuZGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ25vdGlmeV93YWl0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGlhbG9nLnNlbmRSZXF1ZXN0KHRoaXMsIFNJUC5DLlNVQlNDUklCRSwge1xuICAgICAgZXh0cmFIZWFkZXJzOiB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICAgIGJvZHk6IHRoaXMuYm9keVxuICAgIH0pO1xuICB9LFxuXG4gIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB2YXIgZXhwaXJlcywgc3ViID0gdGhpcyxcbiAgICAgICAgY2F1c2UgPSBTSVAuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHJlc3BvbnNlLnN0YXR1c19jb2RlKTtcblxuICAgIGlmICgodGhpcy5zdGF0ZSA9PT0gJ25vdGlmeV93YWl0JyAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA+PSAzMDApIHx8XG4gICAgICAgICh0aGlzLnN0YXRlICE9PSAnbm90aWZ5X3dhaXQnICYmIHRoaXMuZXJyb3JDb2Rlcy5pbmRleE9mKHJlc3BvbnNlLnN0YXR1c19jb2RlKSAhPT0gLTEpKSB7XG4gICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgbnVsbCk7XG4gICAgfSBlbHNlIGlmICgvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpKXtcbiAgICAgIGV4cGlyZXMgPSByZXNwb25zZS5nZXRIZWFkZXIoJ0V4cGlyZXMnKTtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLk4pO1xuXG4gICAgICBpZiAodGhpcy5jcmVhdGVDb25maXJtZWREaWFsb2cocmVzcG9uc2UsJ1VBQycpKSB7XG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLmRpYWxvZy5pZC50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnVhLnN1YnNjcmlwdGlvbnNbdGhpcy5pZF0gPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXQoJ2FjY2VwdGVkJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgLy8gVVBEQVRFIFJPVVRFIFNFVCBUTyBCRSBCQUNLV0FSRFMgQ09NUEFUSUJMRT9cbiAgICAgIH1cblxuICAgICAgaWYgKGV4cGlyZXMgJiYgZXhwaXJlcyA8PSB0aGlzLmV4cGlyZXMpIHtcbiAgICAgICAgLy8gUHJlc2VydmUgbmV3IGV4cGlyZXMgdmFsdWUgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHNcbiAgICAgICAgdGhpcy5leHBpcmVzID0gZXhwaXJlcztcbiAgICAgICAgdGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHN1Yi5yZWZyZXNoLmJpbmQoc3ViKSwgZXhwaXJlcyAqIDkwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWV4cGlyZXMpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdFeHBpcmVzIGhlYWRlciBtaXNzaW5nIGluIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIFNVQlNDUklCRScpO1xuICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5FWFBJUkVTX0hFQURFUl9NSVNTSU5HKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdFeHBpcmVzIGhlYWRlciBpbiBhIDIwMC1jbGFzcyByZXNwb25zZSB0byBTVUJTQ1JJQkUgd2l0aCBhIGhpZ2hlciB2YWx1ZSB0aGFuIHRoZSBvbmUgaW4gdGhlIHJlcXVlc3QnKTtcbiAgICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuSU5WQUxJRF9FWFBJUkVTX0hFQURFUik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vVXNlZCB0byBqdXN0IGlnbm9yZSBwcm92aXNpb25hbCByZXNwb25zZXM7IG5vdyBpZ25vcmVzIGV2ZXJ5dGhpbmcgZXhjZXB0IGVycm9yQ29kZXMgYW5kIDJ4eFxuICB9LFxuXG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0cmFIZWFkZXJzID0gW10sIHN1YiA9IHRoaXM7XG5cbiAgICB0aGlzLnN0YXRlID0gJ3Rlcm1pbmF0ZWQnO1xuXG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0V2ZW50OiAnICsgdGhpcy5ldmVudCk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0V4cGlyZXM6IDAnKTtcblxuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnKyB0aGlzLmNvbnRhY3QpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJysgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCkpO1xuXG4gICAgLy9tYWtlcyBzdXJlIGV4cGlyZXMgaXNuJ3Qgc2V0LCBhbmQgb3RoZXIgdHlwaWNhbCByZXN1YnNjcmliZSBiZWhhdmlvclxuICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24oKXt9O1xuXG4gICAgdGhpcy5kaWFsb2cuc2VuZFJlcXVlc3QodGhpcywgdGhpcy5tZXRob2QsIHtcbiAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgYm9keTogdGhpcy5ib2R5XG4gICAgfSk7XG5cbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zdWJfZHVyYXRpb24pO1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLk4pO1xuICAgIHRoaXMudGltZXJzLk4gPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoc3ViLnRpbWVyX2ZpcmUuYmluZChzdWIpLCBTSVAuVGltZXJzLlRJTUVSX04pO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICovXG4gIHRpbWVyX2ZpcmU6IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICd0ZXJtaW5hdGVkJykge1xuICAgICAgdGhpcy50ZXJtaW5hdGVEaWFsb2coKTtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLk4pO1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uKTtcblxuICAgICAgZGVsZXRlIHRoaXMudWEuc3Vic2NyaXB0aW9uc1t0aGlzLmlkXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdwZW5kaW5nJyB8fCB0aGlzLnN0YXRlID09PSAnbm90aWZ5X3dhaXQnKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5zdGF0ZSAhPT0gJ25vdGlmeV93YWl0JyAmJiB0aGlzLnN0YXRlICE9PSAndGVybWluYXRlZCcpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKi9cbiAgY3JlYXRlQ29uZmlybWVkRGlhbG9nOiBmdW5jdGlvbihtZXNzYWdlLCB0eXBlKSB7XG4gICAgdmFyIGRpYWxvZztcblxuICAgIHRoaXMudGVybWluYXRlRGlhbG9nKCk7XG4gICAgZGlhbG9nID0gbmV3IFNJUC5EaWFsb2codGhpcywgbWVzc2FnZSwgdHlwZSk7XG5cbiAgICBpZighZGlhbG9nLmVycm9yKSB7XG4gICAgICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBEaWFsb2cgbm90IGNyZWF0ZWQgZHVlIHRvIGFuIGVycm9yXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICovXG4gIHRlcm1pbmF0ZURpYWxvZzogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5kaWFsb2cpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnVhLnN1YnNjcmlwdGlvbnNbdGhpcy5pZF07XG4gICAgICB0aGlzLmRpYWxvZy50ZXJtaW5hdGUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRpYWxvZztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKi9cbiAgcmVjZWl2ZVJlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgc3ViX3N0YXRlLCBzdWIgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gc2V0RXhwaXJlc1RpbWVvdXQoKSB7XG4gICAgICBpZiAoc3ViX3N0YXRlLmV4cGlyZXMpIHtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQoc3ViLnRpbWVycy5zdWJfZHVyYXRpb24pO1xuICAgICAgICBzdWJfc3RhdGUuZXhwaXJlcyA9IE1hdGgubWluKHN1Yi5leHBpcmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHN1Yl9zdGF0ZS5leHBpcmVzLCAwKSk7XG4gICAgICAgIHN1Yi50aW1lcnMuc3ViX2R1cmF0aW9uID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHN1Yi5yZWZyZXNoLmJpbmQoc3ViKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJfc3RhdGUuZXhwaXJlcyAqIDkwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm1hdGNoRXZlbnQocmVxdWVzdCkpIHsgLy9jaGVja3MgZXZlbnQgYW5kIHN1YnNjcmlwdGlvbl9zdGF0ZSBoZWFkZXJzXG4gICAgICByZXF1ZXN0LnJlcGx5KDQ4OSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3ViX3N0YXRlID0gcmVxdWVzdC5wYXJzZUhlYWRlcignU3Vic2NyaXB0aW9uLVN0YXRlJyk7XG5cbiAgICByZXF1ZXN0LnJlcGx5KDIwMCwgU0lQLkMuUkVBU09OXzIwMCk7XG5cbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcblxuICAgIHRoaXMuZW1pdCgnbm90aWZ5Jywge3JlcXVlc3Q6IHJlcXVlc3R9KTtcblxuICAgIC8vIGlmIHdlJ3ZlIHNldCBzdGF0ZSB0byB0ZXJtaW5hdGVkLCBubyBmdXJ0aGVyIHByb2Nlc3Npbmcgc2hvdWxkIHRha2UgcGxhY2VcbiAgICAvLyBhbmQgd2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBjbGVhbmluZyB1cCBhZnRlciB0aGUgYXBwcm9wcmlhdGUgTk9USUZZXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICd0ZXJtaW5hdGVkJykge1xuICAgICAgaWYgKHN1Yl9zdGF0ZS5zdGF0ZSA9PT0gJ3Rlcm1pbmF0ZWQnKSB7XG4gICAgICAgIHRoaXMudGVybWluYXRlRGlhbG9nKCk7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLk4pO1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zdWJfZHVyYXRpb24pO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLnVhLnN1YnNjcmlwdGlvbnNbdGhpcy5pZF07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoIChzdWJfc3RhdGUuc3RhdGUpIHtcbiAgICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnYWN0aXZlJztcbiAgICAgICAgc2V0RXhwaXJlc1RpbWVvdXQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdub3RpZnlfd2FpdCcpIHtcbiAgICAgICAgICBzZXRFeHBpcmVzVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAncGVuZGluZyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGVybWluYXRlZCc6XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbik7XG4gICAgICAgIGlmIChzdWJfc3RhdGUucmVhc29uKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCd0ZXJtaW5hdGluZyBzdWJzY3JpcHRpb24gd2l0aCByZWFzb24gJysgc3ViX3N0YXRlLnJlYXNvbik7XG4gICAgICAgICAgc3dpdGNoIChzdWJfc3RhdGUucmVhc29uKSB7XG4gICAgICAgICAgICBjYXNlICdkZWFjdGl2YXRlZCc6XG4gICAgICAgICAgICBjYXNlICd0aW1lb3V0JzpcbiAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAncHJvYmF0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ2dpdmV1cCc6XG4gICAgICAgICAgICAgIGlmKHN1Yl9zdGF0ZS5wYXJhbXMgJiYgc3ViX3N0YXRlLnBhcmFtc1sncmV0cnktYWZ0ZXInXSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChzdWIuc3Vic2NyaWJlLmJpbmQoc3ViKSwgc3ViX3N0YXRlLnBhcmFtc1sncmV0cnktYWZ0ZXInXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICBjYXNlICdub3Jlc291cmNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2ludmFyaWFudCc6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICBmYWlsZWQ6IGZ1bmN0aW9uKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb25EaWFsb2dFcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gIH0sXG5cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKi9cbiAgbWF0Y2hFdmVudDogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHZhciBldmVudDtcblxuICAgIC8vIENoZWNrIG1hbmRhdG9yeSBoZWFkZXIgRXZlbnRcbiAgICBpZiAoIXJlcXVlc3QuaGFzSGVhZGVyKCdFdmVudCcpKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdtaXNzaW5nIEV2ZW50IGhlYWRlcicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayBtYW5kYXRvcnkgaGVhZGVyIFN1YnNjcmlwdGlvbi1TdGF0ZVxuICAgIGlmICghcmVxdWVzdC5oYXNIZWFkZXIoJ1N1YnNjcmlwdGlvbi1TdGF0ZScpKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdtaXNzaW5nIFN1YnNjcmlwdGlvbi1TdGF0ZSBoZWFkZXInKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBldmVudCBpbiBOT1RJRlkgbWF0Y2hlcyB0aGUgZXZlbnQgaW4gU1VCU0NSSUJFXG4gICAgZXZlbnQgPSByZXF1ZXN0LnBhcnNlSGVhZGVyKCdldmVudCcpLmV2ZW50O1xuXG4gICAgaWYgKHRoaXMuZXZlbnQgIT09IGV2ZW50KSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdldmVudCBtYXRjaCBmYWlsZWQnKTtcbiAgICAgIHJlcXVlc3QucmVwbHkoNDgxLCAnRXZlbnQgTWF0Y2ggRmFpbGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1N1YnNjcmlwdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgV2ViUlRDXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQLCBlbnZpcm9ubWVudCkge1xudmFyIFdlYlJUQztcblxuV2ViUlRDID0ge307XG5cbldlYlJUQy5NZWRpYUhhbmRsZXIgPSByZXF1aXJlKCcuL1dlYlJUQy9NZWRpYUhhbmRsZXInKShTSVApO1xuV2ViUlRDLk1lZGlhU3RyZWFtTWFuYWdlciA9IHJlcXVpcmUoJy4vV2ViUlRDL01lZGlhU3RyZWFtTWFuYWdlcicpKFNJUCwgZW52aXJvbm1lbnQpO1xuXG52YXIgX2lzU3VwcG9ydGVkO1xuXG5XZWJSVEMuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBfaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBXZWJSVEMuTWVkaWFTdHJlYW0gPSBlbnZpcm9ubWVudC5NZWRpYVN0cmVhbTtcbiAgV2ViUlRDLmdldFVzZXJNZWRpYSA9IGVudmlyb25tZW50LmdldFVzZXJNZWRpYTtcbiAgV2ViUlRDLlJUQ1BlZXJDb25uZWN0aW9uID0gZW52aXJvbm1lbnQuUlRDUGVlckNvbm5lY3Rpb247XG4gIFdlYlJUQy5SVENTZXNzaW9uRGVzY3JpcHRpb24gPSBlbnZpcm9ubWVudC5SVENTZXNzaW9uRGVzY3JpcHRpb247XG5cbiAgaWYgKFdlYlJUQy5SVENQZWVyQ29ubmVjdGlvbiAmJiBXZWJSVEMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKFdlYlJUQy5nZXRVc2VyTWVkaWEpIHtcbiAgICAgIFdlYlJUQy5nZXRVc2VyTWVkaWEgPSBTSVAuVXRpbHMucHJvbWlzaWZ5KGVudmlyb25tZW50LCAnZ2V0VXNlck1lZGlhJyk7XG4gICAgfVxuICAgIF9pc1N1cHBvcnRlZCA9IHRydWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgX2lzU3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIF9pc1N1cHBvcnRlZDtcbn07XG5cbnJldHVybiBXZWJSVEM7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9XZWJSVEMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1lZGlhSGFuZGxlclxuICovXG5cbi8qIE1lZGlhSGFuZGxlclxuICogQGNsYXNzIFBlZXJDb25uZWN0aW9uIGhlbHBlciBDbGFzcy5cbiAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7U0lQLldlYlJUQy5NZWRpYVN0cmVhbU1hbmFnZXJ9IFtvcHRpb25zLm1lZGlhU3RyZWFtTWFuYWdlcl1cbiAqICAgICAgICBUaGUgTWVkaWFTdHJlYW1NYW5hZ2VyIHRvIGFjcXVpcmUvcmVsZWFzZSBzdHJlYW1zIGZyb20vdG8uXG4gKiAgICAgICAgSWYgbm90IHByb3ZpZGVkLCBhIGRlZmF1bHQgTWVkaWFTdHJlYW1NYW5hZ2VyIHdpbGwgYmUgdXNlZC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG5cbnZhciBNZWRpYUhhbmRsZXIgPSBmdW5jdGlvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMubG9nZ2VyID0gc2Vzc2lvbi51YS5nZXRMb2dnZXIoJ3NpcC5pbnZpdGVjb250ZXh0Lm1lZGlhaGFuZGxlcicsIHNlc3Npb24uaWQpO1xuICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICB0aGlzLmxvY2FsTWVkaWEgPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgdGhpcy5tZWRpYVN0cmVhbU1hbmFnZXIgPSBvcHRpb25zLm1lZGlhU3RyZWFtTWFuYWdlciB8fCBuZXcgU0lQLldlYlJUQy5NZWRpYVN0cmVhbU1hbmFnZXIodGhpcy5sb2dnZXIpO1xuICB0aGlzLmF1ZGlvTXV0ZWQgPSBmYWxzZTtcbiAgdGhpcy52aWRlb011dGVkID0gZmFsc2U7XG5cbiAgLy8gb2xkIGluaXQoKSBmcm9tIGhlcmUgb25cbiAgdmFyIHNlcnZlcnMgPSB0aGlzLnByZXBhcmVJY2VTZXJ2ZXJzKG9wdGlvbnMuc3R1blNlcnZlcnMsIG9wdGlvbnMudHVyblNlcnZlcnMpO1xuICB0aGlzLlJUQ0NvbnN0cmFpbnRzID0gb3B0aW9ucy5SVENDb25zdHJhaW50cyB8fCB7fTtcblxuICB0aGlzLmluaXRQZWVyQ29ubmVjdGlvbihzZXJ2ZXJzLCB0aGlzLlJUQ0NvbnN0cmFpbnRzKTtcblxuICBmdW5jdGlvbiBzZWxmRW1pdChtaCwgZXZlbnQpIHtcbiAgICBpZiAobWgubWVkaWFTdHJlYW1NYW5hZ2VyLm9uKSB7XG4gICAgICBtaC5tZWRpYVN0cmVhbU1hbmFnZXIub24oZXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWguZW1pdC5hcHBseShtaCwgW2V2ZW50XS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc2VsZkVtaXQodGhpcywgJ3VzZXJNZWRpYVJlcXVlc3QnKTtcbiAgc2VsZkVtaXQodGhpcywgJ3VzZXJNZWRpYScpO1xuICBzZWxmRW1pdCh0aGlzLCAndXNlck1lZGlhRmFpbGVkJyk7XG59O1xuXG5NZWRpYUhhbmRsZXIuZGVmYXVsdEZhY3RvcnkgPSBmdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAoc2Vzc2lvbiwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IE1lZGlhSGFuZGxlcihzZXNzaW9uLCBvcHRpb25zKTtcbn07XG5NZWRpYUhhbmRsZXIuZGVmYXVsdEZhY3RvcnkuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBTSVAuV2ViUlRDLmlzU3VwcG9ydGVkKCk7XG59O1xuXG5NZWRpYUhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuTWVkaWFIYW5kbGVyLnByb3RvdHlwZSwge1xuLy8gRnVuY3Rpb25zIHRoZSBzZXNzaW9uIGNhbiB1c2VcbiAgaXNSZWFkeToge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gaXNSZWFkeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZHk7XG4gIH19LFxuXG4gIGNsb3NlOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdjbG9zaW5nIFBlZXJDb25uZWN0aW9uJyk7XG4gICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgIC8vIGhhdmUgdG8gY2hlY2sgc2lnbmFsaW5nU3RhdGUgc2luY2UgdGhpcy5jbG9zZSgpIGdldHMgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gVE9ETyBmaWd1cmUgb3V0IHdoeSB0aGF0IGhhcHBlbnNcbiAgICBpZih0aGlzLnBlZXJDb25uZWN0aW9uICYmIHRoaXMucGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG5cbiAgICAgIGlmKHRoaXMubG9jYWxNZWRpYSkge1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtTWFuYWdlci5yZWxlYXNlKHRoaXMubG9jYWxNZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICB9fSxcblxuICAvKipcbiAgICogQHBhcmFtIHtTSVAuV2ViUlRDLk1lZGlhU3RyZWFtIHwgKGdldFVzZXJNZWRpYSBjb25zdHJhaW50cyl9IFttZWRpYUhpbnRdXG4gICAqICAgICAgICB0aGUgTWVkaWFTdHJlYW0gKG9yIHRoZSBjb25zdHJhaW50cyBkZXNjcmliaW5nIGl0KSB0byBiZSB1c2VkIGZvciB0aGUgc2Vzc2lvblxuICAgKi9cbiAgZ2V0RGVzY3JpcHRpb246IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGdldERlc2NyaXB0aW9uIChtZWRpYUhpbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFjcXVpcmUgPSBzZWxmLm1lZGlhU3RyZWFtTWFuYWdlci5hY3F1aXJlO1xuICAgIGlmIChhY3F1aXJlLmxlbmd0aCA+IDEpIHtcbiAgICAgIGFjcXVpcmUgPSBTSVAuVXRpbHMucHJvbWlzaWZ5KHRoaXMubWVkaWFTdHJlYW1NYW5hZ2VyLCAnYWNxdWlyZScsIHRydWUpO1xuICAgIH1cbiAgICBtZWRpYUhpbnQgPSBtZWRpYUhpbnQgfHwge307XG4gICAgaWYgKG1lZGlhSGludC5kYXRhQ2hhbm5lbCA9PT0gdHJ1ZSkge1xuICAgICAgbWVkaWFIaW50LmRhdGFDaGFubmVsID0ge307XG4gICAgfVxuICAgIHRoaXMubWVkaWFIaW50ID0gbWVkaWFIaW50O1xuXG4gICAgLypcbiAgICAgKiAxLiBhY3F1aXJlIHN0cmVhbXMgKHNraXAgaWYgTWVkaWFTdHJlYW1zIHBhc3NlZCBpbilcbiAgICAgKiAyLiBhZGRTdHJlYW1zXG4gICAgICogMy4gY3JlYXRlT2ZmZXIvY3JlYXRlQW5zd2VyXG4gICAgICovXG5cbiAgICB2YXIgc3RyZWFtUHJvbWlzZTtcbiAgICBpZiAoc2VsZi5sb2NhbE1lZGlhKSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ2FscmVhZHkgaGF2ZSBsb2NhbCBtZWRpYScpO1xuICAgICAgc3RyZWFtUHJvbWlzZSA9IFNJUC5VdGlscy5Qcm9taXNlLnJlc29sdmUoc2VsZi5sb2NhbE1lZGlhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ2FjcXVpcmluZyBsb2NhbCBtZWRpYScpO1xuICAgICAgc3RyZWFtUHJvbWlzZSA9IGFjcXVpcmUuY2FsbChzZWxmLm1lZGlhU3RyZWFtTWFuYWdlciwgbWVkaWFIaW50KVxuICAgICAgICAudGhlbihmdW5jdGlvbiBhY3F1aXJlU3VjY2VlZGVkKHN0cmVhbXMpIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5sb2coJ2FjcXVpcmVkIGxvY2FsIG1lZGlhIHN0cmVhbXMnKTtcbiAgICAgICAgICBzZWxmLmxvY2FsTWVkaWEgPSBzdHJlYW1zO1xuICAgICAgICAgIHNlbGYuc2Vzc2lvbi5jb25uZWN0aW5nKCk7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbXM7XG4gICAgICAgIH0sIGZ1bmN0aW9uIGFjcXVpcmVGYWlsZWQoZXJyKSB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoJ3VuYWJsZSB0byBhY3F1aXJlIHN0cmVhbXMnKTtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgIHNlbGYuc2Vzc2lvbi5jb25uZWN0aW5nKCk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbih0aGlzLmFkZFN0cmVhbXMuYmluZCh0aGlzKSlcbiAgICAgIDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyZWFtUHJvbWlzZVxuICAgICAgLnRoZW4oZnVuY3Rpb24gc3RyZWFtQWRkaXRpb25TdWNjZWVkZWQoKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc09mZmVyKCdyZW1vdGUnKSkge1xuICAgICAgICAgIHNlbGYucGVlckNvbm5lY3Rpb24ub25kYXRhY2hhbm5lbCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIHNlbGYuZGF0YUNoYW5uZWwgPSBldnQuY2hhbm5lbDtcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZGF0YUNoYW5uZWwnLCBzZWxmLmRhdGFDaGFubmVsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhSGludC5kYXRhQ2hhbm5lbCAmJlxuICAgICAgICAgICAgICAgICAgIHNlbGYucGVlckNvbm5lY3Rpb24uY3JlYXRlRGF0YUNoYW5uZWwpIHtcbiAgICAgICAgICBzZWxmLmRhdGFDaGFubmVsID0gc2VsZi5wZWVyQ29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbChcbiAgICAgICAgICAgICdzaXBqcycsXG4gICAgICAgICAgICBtZWRpYUhpbnQuZGF0YUNoYW5uZWxcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlbGYuZW1pdCgnZGF0YUNoYW5uZWwnLCBzZWxmLmRhdGFDaGFubmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICAgIHJldHVybiBzZWxmLmNyZWF0ZU9mZmVyT3JBbnN3ZXIoc2VsZi5SVENDb25zdHJhaW50cyk7XG4gICAgICB9KVxuICAgIDtcbiAgfX0sXG5cbiAgLyoqXG4gICogTWVzc2FnZSByZWNlcHRpb24uXG4gICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gc2RwXG4gICovXG4gIHNldERlc2NyaXB0aW9uOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBzZXREZXNjcmlwdGlvbiAoc2RwKSB7XG4gICAgdmFyIHJhd0Rlc2NyaXB0aW9uID0ge1xuICAgICAgdHlwZTogdGhpcy5oYXNPZmZlcignbG9jYWwnKSA/ICdhbnN3ZXInIDogJ29mZmVyJyxcbiAgICAgIHNkcDogc2RwXG4gICAgfTtcblxuICAgIHRoaXMuZW1pdCgnc2V0RGVzY3JpcHRpb24nLCByYXdEZXNjcmlwdGlvbik7XG5cbiAgICB2YXIgZGVzY3JpcHRpb24gPSBuZXcgU0lQLldlYlJUQy5SVENTZXNzaW9uRGVzY3JpcHRpb24ocmF3RGVzY3JpcHRpb24pO1xuICAgIHJldHVybiBTSVAuVXRpbHMucHJvbWlzaWZ5KHRoaXMucGVlckNvbm5lY3Rpb24sICdzZXRSZW1vdGVEZXNjcmlwdGlvbicpKGRlc2NyaXB0aW9uKTtcbiAgfX0sXG5cbiAgLyoqXG4gICAqIElmIHRoZSBTZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1lZGlhSGFuZGxlciB3ZXJlIHRvIGJlIHJlZmVycmVkLFxuICAgKiB3aGF0IG1lZGlhSGludCBzaG91bGQgYmUgcHJvdmlkZWQgdG8gdGhlIFVBJ3MgaW52aXRlIG1ldGhvZD9cbiAgICovXG4gIGdldFJlZmVyTWVkaWE6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGdldFJlZmVyTWVkaWEgKCkge1xuICAgIGZ1bmN0aW9uIGhhc1RyYWNrcyAodHJhY2tHZXR0ZXIsIHN0cmVhbSkge1xuICAgICAgcmV0dXJuIHN0cmVhbVt0cmFja0dldHRlcl0oKS5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJvdGhIYXZlVHJhY2tzICh0cmFja0dldHRlcikge1xuICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICByZXR1cm4gdGhpcy5nZXRMb2NhbFN0cmVhbXMoKS5zb21lKGhhc1RyYWNrcy5iaW5kKG51bGwsIHRyYWNrR2V0dGVyKSkgJiZcbiAgICAgICAgICAgICB0aGlzLmdldFJlbW90ZVN0cmVhbXMoKS5zb21lKGhhc1RyYWNrcy5iaW5kKG51bGwsIHRyYWNrR2V0dGVyKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgIGF1ZGlvOiBib3RoSGF2ZVRyYWNrcy5jYWxsKHRoaXMsICdnZXRBdWRpb1RyYWNrcycpLFxuICAgICAgICB2aWRlbzogYm90aEhhdmVUcmFja3MuY2FsbCh0aGlzLCAnZ2V0VmlkZW9UcmFja3MnKVxuICAgICAgfVxuICAgIH07XG4gIH19LFxuXG4gIHVwZGF0ZUljZVNlcnZlcnM6IHt3cml0ZWFibGU6dHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlcnZlcnMgPSB0aGlzLnByZXBhcmVJY2VTZXJ2ZXJzKG9wdGlvbnMuc3R1blNlcnZlcnMsIG9wdGlvbnMudHVyblNlcnZlcnMpO1xuICAgIHRoaXMuUlRDQ29uc3RyYWludHMgPSBvcHRpb25zLlJUQ0NvbnN0cmFpbnRzIHx8IHRoaXMuUlRDQ29uc3RyYWludHM7XG5cbiAgICB0aGlzLmluaXRQZWVyQ29ubmVjdGlvbihzZXJ2ZXJzLCB0aGlzLlJUQ0NvbnN0cmFpbnRzKTtcblxuICAgIC8qIG9uY2UgdXBkYXRlSWNlIGlzIGltcGxlbWVudGVkIGNvcnJlY3RseSwgdGhpcyBpcyBiZXR0ZXIgdGhhbiBhYm92ZVxuICAgIC8vbm8gb3AgaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoaXNcbiAgICBpZiAoIXRoaXMucGVlckNvbm5lY3Rpb24udXBkYXRlSWNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi51cGRhdGVJY2UoeydpY2VTZXJ2ZXJzJzogc2VydmVyc30sIHRoaXMuUlRDQ29uc3RyYWludHMpO1xuICAgICovXG4gIH19LFxuXG4vLyBGdW5jdGlvbnMgdGhlIHNlc3Npb24gY2FuIHVzZSwgYnV0IG9ubHkgYmVjYXVzZSBpdCdzIGNvbnZlbmllbnQgZm9yIHRoZSBhcHBsaWNhdGlvblxuICBpc011dGVkOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBpc011dGVkICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW86IHRoaXMuYXVkaW9NdXRlZCxcbiAgICAgIHZpZGVvOiB0aGlzLnZpZGVvTXV0ZWRcbiAgICB9O1xuICB9fSxcblxuICBtdXRlOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBtdXRlIChvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuZ2V0TG9jYWxTdHJlYW1zKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgYXVkaW86IHRoaXMuZ2V0TG9jYWxTdHJlYW1zKClbMF0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwLFxuICAgICAgdmlkZW86IHRoaXMuZ2V0TG9jYWxTdHJlYW1zKClbMF0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwXG4gICAgfTtcblxuICAgIHZhciBhdWRpb011dGVkID0gZmFsc2UsXG4gICAgICAgIHZpZGVvTXV0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmF1ZGlvICYmICF0aGlzLmF1ZGlvTXV0ZWQpIHtcbiAgICAgIGF1ZGlvTXV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5hdWRpb011dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZUF1ZGlvKHRydWUpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnZpZGVvICYmICF0aGlzLnZpZGVvTXV0ZWQpIHtcbiAgICAgIHZpZGVvTXV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy52aWRlb011dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZVZpZGVvKHRydWUpO1xuICAgIH1cblxuICAgIC8vUkVWSVNJVFxuICAgIGlmIChhdWRpb011dGVkIHx8IHZpZGVvTXV0ZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1ZGlvOiBhdWRpb011dGVkLFxuICAgICAgICB2aWRlbzogdmlkZW9NdXRlZFxuICAgICAgfTtcbiAgICAgIC8qdGhpcy5zZXNzaW9uLm9ubXV0ZSh7XG4gICAgICAgIGF1ZGlvOiBhdWRpb011dGVkLFxuICAgICAgICB2aWRlbzogdmlkZW9NdXRlZFxuICAgICAgfSk7Ki9cbiAgICB9XG4gIH19LFxuXG4gIHVubXV0ZToge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gdW5tdXRlIChvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuZ2V0TG9jYWxTdHJlYW1zKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgYXVkaW86IHRoaXMuZ2V0TG9jYWxTdHJlYW1zKClbMF0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwLFxuICAgICAgdmlkZW86IHRoaXMuZ2V0TG9jYWxTdHJlYW1zKClbMF0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwXG4gICAgfTtcblxuICAgIHZhciBhdWRpb1VuTXV0ZWQgPSBmYWxzZSxcbiAgICAgICAgdmlkZW9Vbk11dGVkID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hdWRpbyAmJiB0aGlzLmF1ZGlvTXV0ZWQpIHtcbiAgICAgIGF1ZGlvVW5NdXRlZCA9IHRydWU7XG4gICAgICB0aGlzLmF1ZGlvTXV0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZUF1ZGlvKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy52aWRlbyAmJiB0aGlzLnZpZGVvTXV0ZWQpIHtcbiAgICAgIHZpZGVvVW5NdXRlZCA9IHRydWU7XG4gICAgICB0aGlzLnZpZGVvTXV0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZVZpZGVvKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvL1JFVklTSVRcbiAgICBpZiAoYXVkaW9Vbk11dGVkIHx8IHZpZGVvVW5NdXRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW86IGF1ZGlvVW5NdXRlZCxcbiAgICAgICAgdmlkZW86IHZpZGVvVW5NdXRlZFxuICAgICAgfTtcbiAgICAgIC8qdGhpcy5zZXNzaW9uLm9udW5tdXRlKHtcbiAgICAgICAgYXVkaW86IGF1ZGlvVW5NdXRlZCxcbiAgICAgICAgdmlkZW86IHZpZGVvVW5NdXRlZFxuICAgICAgfSk7Ki9cbiAgICB9XG4gIH19LFxuXG4gIGhvbGQ6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGhvbGQgKCkge1xuICAgIHRoaXMudG9nZ2xlTXV0ZUF1ZGlvKHRydWUpO1xuICAgIHRoaXMudG9nZ2xlTXV0ZVZpZGVvKHRydWUpO1xuICB9fSxcblxuICB1bmhvbGQ6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHVuaG9sZCAoKSB7XG4gICAgaWYgKCF0aGlzLmF1ZGlvTXV0ZWQpIHtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZUF1ZGlvKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudmlkZW9NdXRlZCkge1xuICAgICAgdGhpcy50b2dnbGVNdXRlVmlkZW8oZmFsc2UpO1xuICAgIH1cbiAgfX0sXG5cbi8vIEZ1bmN0aW9ucyB0aGUgYXBwbGljYXRpb24gY2FuIHVzZSwgYnV0IG5vdCB0aGUgc2Vzc2lvblxuICBnZXRMb2NhbFN0cmVhbXM6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcyAoKSB7XG4gICAgdmFyIHBjID0gdGhpcy5wZWVyQ29ubmVjdGlvbjtcbiAgICBpZiAocGMgJiYgcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdwZWVyQ29ubmVjdGlvbiBpcyBjbG9zZWQsIGdldExvY2FsU3RyZWFtcyByZXR1cm5pbmcgW10nKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIChwYy5nZXRMb2NhbFN0cmVhbXMgJiYgcGMuZ2V0TG9jYWxTdHJlYW1zKCkpIHx8XG4gICAgICBwYy5sb2NhbFN0cmVhbXMgfHwgW107XG4gIH19LFxuXG4gIGdldFJlbW90ZVN0cmVhbXM6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGdldFJlbW90ZVN0cmVhbXMgKCkge1xuICAgIHZhciBwYyA9IHRoaXMucGVlckNvbm5lY3Rpb247XG4gICAgaWYgKHBjICYmIHBjLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhpcy5sb2dnZXIud2FybigncGVlckNvbm5lY3Rpb24gaXMgY2xvc2VkLCBnZXRSZW1vdGVTdHJlYW1zIHJldHVybmluZyB0aGlzLl9yZW1vdGVTdHJlYW1zJyk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3RlU3RyZWFtcztcbiAgICB9XG4gICAgcmV0dXJuKHBjLmdldFJlbW90ZVN0cmVhbXMgJiYgcGMuZ2V0UmVtb3RlU3RyZWFtcygpKSB8fFxuICAgICAgcGMucmVtb3RlU3RyZWFtcyB8fCBbXTtcbiAgfX0sXG5cbiAgcmVuZGVyOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIgKHJlbmRlckhpbnQpIHtcbiAgICByZW5kZXJIaW50ID0gcmVuZGVySGludCB8fCAodGhpcy5tZWRpYUhpbnQgJiYgdGhpcy5tZWRpYUhpbnQucmVuZGVyKTtcbiAgICBpZiAoIXJlbmRlckhpbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHN0cmVhbUdldHRlcnMgPSB7XG4gICAgICBsb2NhbDogJ2dldExvY2FsU3RyZWFtcycsXG4gICAgICByZW1vdGU6ICdnZXRSZW1vdGVTdHJlYW1zJ1xuICAgIH07XG4gICAgT2JqZWN0LmtleXMoc3RyZWFtR2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAobG9jKSB7XG4gICAgICB2YXIgc3RyZWFtR2V0dGVyID0gc3RyZWFtR2V0dGVyc1tsb2NdO1xuICAgICAgdmFyIHN0cmVhbXMgPSB0aGlzW3N0cmVhbUdldHRlcl0oKTtcbiAgICAgIFNJUC5XZWJSVEMuTWVkaWFTdHJlYW1NYW5hZ2VyLnJlbmRlcihzdHJlYW1zLCByZW5kZXJIaW50W2xvY10pO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH19LFxuXG4vLyBJbnRlcm5hbCBmdW5jdGlvbnNcbiAgaGFzT2ZmZXI6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGhhc09mZmVyICh3aGVyZSkge1xuICAgIHZhciBvZmZlclN0YXRlID0gJ2hhdmUtJyArIHdoZXJlICsgJy1vZmZlcic7XG4gICAgcmV0dXJuIHRoaXMucGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgPT09IG9mZmVyU3RhdGU7XG4gICAgLy8gVE9ETyBjb25zaWRlciBzaWduYWxpbmdTdGF0ZXMgd2l0aCAncHJhbnN3ZXInP1xuICB9fSxcblxuICBwcmVwYXJlSWNlU2VydmVyczoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZUljZVNlcnZlcnMgKHN0dW5TZXJ2ZXJzLCB0dXJuU2VydmVycykge1xuICAgIHZhciBzZXJ2ZXJzID0gW10sXG4gICAgICBjb25maWcgPSB0aGlzLnNlc3Npb24udWEuY29uZmlndXJhdGlvbjtcblxuICAgIHN0dW5TZXJ2ZXJzID0gc3R1blNlcnZlcnMgfHwgY29uZmlnLnN0dW5TZXJ2ZXJzO1xuICAgIHR1cm5TZXJ2ZXJzID0gdHVyblNlcnZlcnMgfHwgY29uZmlnLnR1cm5TZXJ2ZXJzO1xuXG4gICAgW10uY29uY2F0KHN0dW5TZXJ2ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICAgIHNlcnZlcnMucHVzaCh7J3VybHMnOiBzZXJ2ZXJ9KTtcbiAgICB9KTtcblxuICAgIFtdLmNvbmNhdCh0dXJuU2VydmVycykuZm9yRWFjaChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICBzZXJ2ZXJzLnB1c2goe1xuICAgICAgICAndXJscyc6IHNlcnZlci51cmxzLFxuICAgICAgICAndXNlcm5hbWUnOiBzZXJ2ZXIudXNlcm5hbWUsXG4gICAgICAgICdjcmVkZW50aWFsJzogc2VydmVyLnBhc3N3b3JkXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzZXJ2ZXJzO1xuICB9fSxcblxuICBpbml0UGVlckNvbm5lY3Rpb246IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGluaXRQZWVyQ29ubmVjdGlvbihzZXJ2ZXJzLCBSVENDb25zdHJhaW50cykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGNvbmZpZyA9IHRoaXMuc2Vzc2lvbi51YS5jb25maWd1cmF0aW9uO1xuXG4gICAgdGhpcy5vbkljZUNvbXBsZXRlZCA9IFNJUC5VdGlscy5kZWZlcigpO1xuICAgIHRoaXMub25JY2VDb21wbGV0ZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uKHBjKSB7XG4gICAgICBzZWxmLmVtaXQoJ2ljZUdhdGhlcmluZ0NvbXBsZXRlJywgcGMpO1xuICAgICAgaWYgKHNlbGYuaWNlQ2hlY2tpbmdUaW1lcikge1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dChzZWxmLmljZUNoZWNraW5nVGltZXIpO1xuICAgICAgICBzZWxmLmljZUNoZWNraW5nVGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMucGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uID0gbmV3IFNJUC5XZWJSVEMuUlRDUGVlckNvbm5lY3Rpb24oeydpY2VTZXJ2ZXJzJzogc2VydmVyc30sIFJUQ0NvbnN0cmFpbnRzKTtcblxuICAgIC8vIEZpcmVmb3ggKDM1LjAuMSkgc29tZXRpbWVzIHRocm93cyBvbiBjYWxscyB0byBwZWVyQ29ubmVjdGlvbi5nZXRSZW1vdGVTdHJlYW1zXG4gICAgLy8gZXZlbiBpZiBwZWVyQ29ubmVjdGlvbi5vbmFkZHN0cmVhbSB3YXMganVzdCBjYWxsZWQuIEluIG9yZGVyIHRvIG1ha2VcbiAgICAvLyBNZWRpYUhhbmRsZXIucHJvdG90eXBlLmdldFJlbW90ZVN0cmVhbXMgd29yaywga2VlcCB0cmFjayBvZiB0aGVtIG1hbnVhbGx5XG4gICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmFkZHN0cmVhbSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHNlbGYubG9nZ2VyLmxvZygnc3RyZWFtIGFkZGVkOiAnKyBlLnN0cmVhbS5pZCk7XG4gICAgICBzZWxmLl9yZW1vdGVTdHJlYW1zLnB1c2goZS5zdHJlYW0pO1xuICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICAgIHNlbGYuZW1pdCgnYWRkU3RyZWFtJywgZSk7XG4gICAgfTtcblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25yZW1vdmVzdHJlYW0gPSBmdW5jdGlvbihlKSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ3N0cmVhbSByZW1vdmVkOiAnKyBlLnN0cmVhbS5pZCk7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnRJY2VDaGVja2luZ1RpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzZWxmLmljZUNoZWNraW5nVGltZXIpIHtcbiAgICAgICAgc2VsZi5pY2VDaGVja2luZ1RpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmxvZygnUlRDSWNlQ2hlY2tpbmcgVGltZW91dCBUcmlnZ2VyZWQgYWZ0ZXIgJytjb25maWcuaWNlQ2hlY2tpbmdUaW1lb3V0KycgbWlsbGlzZWNvbmRzJyk7XG4gICAgICAgICAgc2VsZi5vbkljZUNvbXBsZXRlZC5yZXNvbHZlKHRoaXMpO1xuICAgICAgICB9LmJpbmQodGhpcy5wZWVyQ29ubmVjdGlvbiksIGNvbmZpZy5pY2VDaGVja2luZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5lbWl0KCdpY2VDYW5kaWRhdGUnLCBlKTtcbiAgICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgICBzZWxmLmxvZ2dlci5sb2coJ0lDRSBjYW5kaWRhdGUgcmVjZWl2ZWQ6ICcrIChlLmNhbmRpZGF0ZS5jYW5kaWRhdGUgPT09IG51bGwgPyBudWxsIDogZS5jYW5kaWRhdGUuY2FuZGlkYXRlLnRyaW0oKSkpO1xuICAgICAgICBzZWxmLnN0YXJ0SWNlQ2hlY2tpbmdUaW1lcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5vbkljZUNvbXBsZXRlZC5yZXNvbHZlKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ1JUQ0ljZUdhdGhlcmluZ1N0YXRlIGNoYW5nZWQ6ICcgKyB0aGlzLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgIGlmICh0aGlzLmljZUdhdGhlcmluZ1N0YXRlID09PSAnZ2F0aGVyaW5nJykge1xuICAgICAgICBzZWxmLmVtaXQoJ2ljZUdhdGhlcmluZycsIHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaWNlR2F0aGVyaW5nU3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgc2VsZi5vbkljZUNvbXBsZXRlZC5yZXNvbHZlKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7ICAvL25lZWQgZSBmb3IgY29tbWVudGVkIG91dCBjYXNlXG4gICAgICB2YXIgc3RhdGVFdmVudDtcblxuICAgICAgaWYgKHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY2hlY2tpbmcnKSB7XG4gICAgICAgIHNlbGYuc3RhcnRJY2VDaGVja2luZ1RpbWVyKCk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodGhpcy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgIGNhc2UgJ25ldyc6XG4gICAgICAgIHN0YXRlRXZlbnQgPSAnaWNlQ29ubmVjdGlvbic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2hlY2tpbmcnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb25DaGVja2luZyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uQ29ubmVjdGVkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb25Db21wbGV0ZWQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgIHN0YXRlRXZlbnQgPSAnaWNlQ29ubmVjdGlvbkZhaWxlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb25DbG9zZWQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oJ1Vua25vd24gaWNlQ29ubmVjdGlvbiBzdGF0ZTonLCB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW1pdChzdGF0ZUV2ZW50LCB0aGlzKTtcblxuICAgICAgLy9CcmlhIHN0YXRlIGNoYW5nZXMgYXJlIGFsd2F5cyBjb25uZWN0ZWQgLT4gZGlzY29ubmVjdGVkIC0+IGNvbm5lY3RlZCBvbiBhY2NlcHQsIHNvIHNlc3Npb24gZ2V0cyB0ZXJtaW5hdGVkXG4gICAgICAvL25vcm1hbCBjYWxscyBzd2l0Y2ggZnJvbSBmYWlsZWQgdG8gY29ubmVjdGVkIGluIHNvbWUgY2FzZXMsIHNvIGNoZWNraW5nIGZvciBmYWlsZWQgYW5kIHRlcm1pbmF0ZWRcbiAgICAgIC8qaWYgKHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICBzZWxmLnNlc3Npb24udGVybWluYXRlKHtcbiAgICAgICAgY2F1c2U6IFNJUC5DLmNhdXNlcy5SVFBfVElNRU9VVCxcbiAgICAgICAgc3RhdHVzX2NvZGU6IDIwMCxcbiAgICAgICAgcmVhc29uX3BocmFzZTogU0lQLkMuY2F1c2VzLlJUUF9USU1FT1VUXG4gICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZS5jdXJyZW50VGFyZ2V0LmljZUdhdGhlcmluZ1N0YXRlID09PSAnY29tcGxldGUnICYmIHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgc2VsZi5vbkljZUNvbXBsZXRlZCh0aGlzKTtcbiAgICAgIH0qL1xuICAgIH07XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYubG9nZ2VyLmxvZygnUGVlckNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZCB0byBcIicrIHRoaXMucmVhZHlTdGF0ZSArJ1wiJyk7XG4gICAgfTtcbiAgfX0sXG5cbiAgY3JlYXRlT2ZmZXJPckFuc3dlcjoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlT2ZmZXJPckFuc3dlciAoY29uc3RyYWludHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1ldGhvZE5hbWU7XG4gICAgdmFyIHBjID0gc2VsZi5wZWVyQ29ubmVjdGlvbjtcblxuICAgIHNlbGYucmVhZHkgPSBmYWxzZTtcbiAgICBtZXRob2ROYW1lID0gc2VsZi5oYXNPZmZlcigncmVtb3RlJykgPyAnY3JlYXRlQW5zd2VyJyA6ICdjcmVhdGVPZmZlcic7XG5cbiAgICByZXR1cm4gU0lQLlV0aWxzLnByb21pc2lmeShwYywgbWV0aG9kTmFtZSwgdHJ1ZSkoY29uc3RyYWludHMpXG4gICAgICAudGhlbihTSVAuVXRpbHMucHJvbWlzaWZ5KHBjLCAnc2V0TG9jYWxEZXNjcmlwdGlvbicpKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gb25TZXRMb2NhbERlc2NyaXB0aW9uU3VjY2VzcygpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gU0lQLlV0aWxzLmRlZmVyKCk7XG4gICAgICAgIGlmIChwYy5pY2VHYXRoZXJpbmdTdGF0ZSA9PT0gJ2NvbXBsZXRlJyAmJiAocGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJyB8fCBwYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb21wbGV0ZWQnKSkge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLm9uSWNlQ29tcGxldGVkLnByb21pc2UudGhlbihkZWZlcnJlZC5yZXNvbHZlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbiByZWFkeVN1Y2Nlc3MgKCkge1xuICAgICAgICB2YXIgc2RwID0gcGMubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG5cbiAgICAgICAgc2RwID0gU0lQLkhhY2tzLkNocm9tZS5uZWVkc0V4cGxpY2l0bHlJbmFjdGl2ZVNEUChzZHApO1xuICAgICAgICBzZHAgPSBTSVAuSGFja3MuQWxsQnJvd3NlcnMudW5tYXNrRHRscyhzZHApO1xuXG4gICAgICAgIHZhciBzZHBXcmFwcGVyID0ge1xuICAgICAgICAgIHR5cGU6IG1ldGhvZE5hbWUgPT09ICdjcmVhdGVPZmZlcicgPyAnb2ZmZXInIDogJ2Fuc3dlcicsXG4gICAgICAgICAgc2RwOiBzZHBcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLmVtaXQoJ2dldERlc2NyaXB0aW9uJywgc2RwV3JhcHBlcik7XG5cbiAgICAgICAgc2VsZi5yZWFkeSA9IHRydWU7XG4gICAgICAgIHJldHVybiBzZHBXcmFwcGVyLnNkcDtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gbWV0aG9kRmFpbGVkIChlKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICBzZWxmLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkdldERlc2NyaXB0aW9uRXJyb3IoZSk7XG4gICAgICB9KVxuICAgIDtcbiAgfX0sXG5cbiAgYWRkU3RyZWFtczoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gYWRkU3RyZWFtcyAoc3RyZWFtcykge1xuICAgIHRyeSB7XG4gICAgICBzdHJlYW1zID0gW10uY29uY2F0KHN0cmVhbXMpO1xuICAgICAgc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5hZGRTdHJlYW0oc3RyZWFtKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ2Vycm9yIGFkZGluZyBzdHJlYW0nKTtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgcmV0dXJuIFNJUC5VdGlscy5Qcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU0lQLlV0aWxzLlByb21pc2UucmVzb2x2ZSgpO1xuICB9fSxcblxuICB0b2dnbGVNdXRlSGVscGVyOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNdXRlSGVscGVyICh0cmFja0dldHRlciwgbXV0ZSkge1xuICAgIHRoaXMuZ2V0TG9jYWxTdHJlYW1zKCkuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICBzdHJlYW1bdHJhY2tHZXR0ZXJdKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdHJhY2suZW5hYmxlZCA9ICFtdXRlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH19LFxuXG4gIHRvZ2dsZU11dGVBdWRpbzoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlTXV0ZUF1ZGlvIChtdXRlKSB7XG4gICAgdGhpcy50b2dnbGVNdXRlSGVscGVyKCdnZXRBdWRpb1RyYWNrcycsIG11dGUpO1xuICB9fSxcblxuICB0b2dnbGVNdXRlVmlkZW86IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZU11dGVWaWRlbyAobXV0ZSkge1xuICAgIHRoaXMudG9nZ2xlTXV0ZUhlbHBlcignZ2V0VmlkZW9UcmFja3MnLCBtdXRlKTtcbiAgfX1cbn0pO1xuXG4vLyBSZXR1cm4gc2luY2UgaXQgd2lsbCBiZSBhc3NpZ25lZCB0byBhIHZhcmlhYmxlLlxucmV0dXJuIE1lZGlhSGFuZGxlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYUhhbmRsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1lZGlhU3RyZWFtTWFuYWdlclxuICovXG5cbi8qIE1lZGlhU3RyZWFtTWFuYWdlclxuICogQGNsYXNzIE1hbmFnZXMgdGhlIGFjcXVpc2l0aW9uIGFuZCByZWxlYXNlIG9mIE1lZGlhU3RyZWFtcy5cbiAqIEBwYXJhbSB7bWVkaWFIaW50fSBbZGVmYXVsdE1lZGlhSGludF0gVGhlIG1lZGlhSGludCB0byB1c2UgaWYgbm9uZSBpcyBwcm92aWRlZCB0byBhY3F1aXJlKClcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQLCBlbnZpcm9ubWVudCkge1xuXG4vLyBEZWZhdWx0IE1lZGlhU3RyZWFtTWFuYWdlciBwcm92aWRlcyBzaW5nbGUtdXNlIHN0cmVhbXMgY3JlYXRlZCB3aXRoIGdldFVzZXJNZWRpYVxudmFyIE1lZGlhU3RyZWFtTWFuYWdlciA9IGZ1bmN0aW9uIE1lZGlhU3RyZWFtTWFuYWdlciAobG9nZ2VyLCBkZWZhdWx0TWVkaWFIaW50KSB7XG4gIGlmICghU0lQLldlYlJUQy5pc1N1cHBvcnRlZCgpKSB7XG4gICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLk5vdFN1cHBvcnRlZEVycm9yKCdNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICB0aGlzLm1lZGlhSGludCA9IGRlZmF1bHRNZWRpYUhpbnQgfHwge1xuICAgIGNvbnN0cmFpbnRzOiB7YXVkaW86IHRydWUsIHZpZGVvOiB0cnVlfVxuICB9O1xuXG4gIC8vIG1hcCBvZiBzdHJlYW1zIHRvIGFjcXVpc2l0aW9uIG1hbm5lcjpcbiAgLy8gdHJ1ZSAtPiBwYXNzZWQgaW4gYXMgbWVkaWFIaW50LnN0cmVhbVxuICAvLyBmYWxzZSAtPiBnZXRVc2VyTWVkaWFcbiAgdGhpcy5hY3F1aXNpdGlvbnMgPSB7fTtcbn07XG5NZWRpYVN0cmVhbU1hbmFnZXIuc3RyZWFtSWQgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5jb25jYXQoc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkpXG4gICAgLm1hcChmdW5jdGlvbiB0cmFja0lkICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrLmlkO1xuICAgIH0pXG4gICAgLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyhBcnJheSBvZikgTWVkaWFTdHJlYW19IHN0cmVhbXMgLSBUaGUgc3RyZWFtcyB0byByZW5kZXJcbiAqXG4gKiBAcGFyYW0geyhBcnJheSBvZikgSFRNTE1lZGlhRWxlbWVudH0gZWxlbWVudHNcbiAqICAgICAgICAtIFRoZSA8YXVkaW8+Lzx2aWRlbz4gZWxlbWVudChzKSB0aGF0IHNob3VsZCByZW5kZXIgdGhlIHN0cmVhbXNcbiAqXG4gKiBFYWNoIHN0cmVhbSBpbiBzdHJlYW1zIHJlbmRlcnMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBlbGVtZW50cyxcbiAqIHdyYXBwaW5nIGFyb3VuZCBlbGVtZW50cyBpZiBuZWVkZWQuXG4gKi9cbk1lZGlhU3RyZWFtTWFuYWdlci5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHN0cmVhbXMsIGVsZW1lbnRzKSB7XG4gIGlmICghZWxlbWVudHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudHMpICYmICFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbGVtZW50cyBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0YWNoTWVkaWFTdHJlYW0oZWxlbWVudCwgc3RyZWFtKSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LnNyYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVudmlyb25tZW50LnJldm9rZU9iamVjdFVSTChlbGVtZW50LnNyYyk7XG4gICAgICBlbGVtZW50LnNyYyA9IGVudmlyb25tZW50LmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIChlbGVtZW50LnNyY09iamVjdCB8fCBlbGVtZW50Lm1velNyY09iamVjdCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbGVtZW50LnNyY09iamVjdCA9IGVsZW1lbnQubW96U3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVNZWRpYVBsYXlpbmcgKG1lZGlhRWxlbWVudCkge1xuICAgIHZhciBpbnRlcnZhbCA9IDEwMDtcbiAgICBtZWRpYUVsZW1lbnQuZW5zdXJlUGxheWluZ0ludGVydmFsSWQgPSBTSVAuVGltZXJzLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtZWRpYUVsZW1lbnQucGF1c2VkKSB7XG4gICAgICAgIG1lZGlhRWxlbWVudC5wbGF5KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhckludGVydmFsKG1lZGlhRWxlbWVudC5lbnN1cmVQbGF5aW5nSW50ZXJ2YWxJZCk7XG4gICAgICB9XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0YWNoQW5kUGxheSAoZWxlbWVudHMsIHN0cmVhbSwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlbGVtZW50cyA9IGVsZW1lbnRzKCk7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXggJSBlbGVtZW50cy5sZW5ndGhdO1xuICAgIChlbnZpcm9ubWVudC5hdHRhY2hNZWRpYVN0cmVhbSB8fCBhdHRhY2hNZWRpYVN0cmVhbSkoZWxlbWVudCwgc3RyZWFtKTtcbiAgICBlbnN1cmVNZWRpYVBsYXlpbmcoZWxlbWVudCk7XG4gIH1cblxuICAvLyBbXS5jb25jYXQgXCJjYXN0c1wiIGBlbGVtZW50c2AgaW50byBhbiBhcnJheVxuICAvLyBzbyBmb3JFYWNoIHdvcmtzIGV2ZW4gaWYgYGVsZW1lbnRzYCB3YXMgYSBzaW5nbGUgZWxlbWVudFxuICBlbGVtZW50cyA9IFtdLmNvbmNhdChlbGVtZW50cyk7XG4gIFtdLmNvbmNhdChzdHJlYW1zKS5mb3JFYWNoKGF0dGFjaEFuZFBsYXkuYmluZChudWxsLCBlbGVtZW50cykpO1xufTtcblxuTWVkaWFTdHJlYW1NYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUsIHtcbiAgJ2FjcXVpcmUnOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBhY3F1aXJlIChtZWRpYUhpbnQpIHtcbiAgICBtZWRpYUhpbnQgPSBPYmplY3Qua2V5cyhtZWRpYUhpbnQgfHwge30pLmxlbmd0aCA/IG1lZGlhSGludCA6IHRoaXMubWVkaWFIaW50O1xuXG4gICAgdmFyIHNhdmVTdWNjZXNzID0gZnVuY3Rpb24gKGlzSGludFN0cmVhbSwgc3RyZWFtcykge1xuICAgICAgc3RyZWFtcyA9IFtdLmNvbmNhdChzdHJlYW1zKTtcbiAgICAgIHN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHZhciBzdHJlYW1JZCA9IE1lZGlhU3RyZWFtTWFuYWdlci5zdHJlYW1JZChzdHJlYW0pO1xuICAgICAgICB0aGlzLmFjcXVpc2l0aW9uc1tzdHJlYW1JZF0gPSAhIWlzSGludFN0cmVhbTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIFNJUC5VdGlscy5Qcm9taXNlLnJlc29sdmUoc3RyZWFtcyk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKG1lZGlhSGludC5zdHJlYW0pIHtcbiAgICAgIHJldHVybiBzYXZlU3VjY2Vzcyh0cnVlLCBtZWRpYUhpbnQuc3RyZWFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gYXVkaW8vdmlkZW8gZW5hYmxlZCBpZiBubyBtZWRpYUhpbnQgY2FuIGJlIGZvdW5kLlxuICAgICAgdmFyIGNvbnN0cmFpbnRzID0gbWVkaWFIaW50LmNvbnN0cmFpbnRzIHx8XG4gICAgICAgICh0aGlzLm1lZGlhSGludCAmJiB0aGlzLm1lZGlhSGludC5jb25zdHJhaW50cykgfHxcbiAgICAgICAge2F1ZGlvOiB0cnVlLCB2aWRlbzogdHJ1ZX07XG5cbiAgICAgIHZhciBkZWZlcnJlZCA9IFNJUC5VdGlscy5kZWZlcigpO1xuXG4gICAgICAvKlxuICAgICAgICogTWFrZSB0aGUgY2FsbCBhc3luY2hyb25vdXMsIHNvIHRoYXQgSUNDcyBoYXZlIGEgY2hhbmNlXG4gICAgICAgKiB0byBkZWZpbmUgY2FsbGJhY2tzIHRvIGB1c2VyTWVkaWFSZXF1ZXN0YFxuICAgICAgICovXG4gICAgICBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3VzZXJNZWRpYVJlcXVlc3QnLCBjb25zdHJhaW50cyk7XG5cbiAgICAgICAgdmFyIGVtaXRUaGVuQ2FsbCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgLy8gRW1pdCB3aXRoIGFsbCBvZiB0aGUgYXJndW1lbnRzIGZyb20gdGhlIHJlYWwgY2FsbGJhY2suXG4gICAgICAgICAgdmFyIG5ld0FyZ3MgPSBbZXZlbnROYW1lXS5jb25jYXQoY2FsbGJhY2tBcmdzKTtcblxuICAgICAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBuZXdBcmdzKTtcblxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3MpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmF1ZGlvIHx8IGNvbnN0cmFpbnRzLnZpZGVvKSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShcbiAgICAgICAgICAgIFNJUC5XZWJSVEMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgIGVtaXRUaGVuQ2FsbC5iaW5kKHRoaXMsICd1c2VyTWVkaWEnLCBzYXZlU3VjY2Vzcy5iaW5kKG51bGwsIGZhbHNlKSksXG4gICAgICAgICAgICAgIGVtaXRUaGVuQ2FsbC5iaW5kKHRoaXMsICd1c2VyTWVkaWFGYWlsZWQnLCBmdW5jdGlvbihlKXt0aHJvdyBlO30pXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMb2NhbCBzdHJlYW1zIHdlcmUgZXhwbGljaXRseSBleGNsdWRlZC5cbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKFtdKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcblxuICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICB9fSxcblxuICAncmVsZWFzZSc6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHJlbGVhc2UgKHN0cmVhbXMpIHtcbiAgICBzdHJlYW1zID0gW10uY29uY2F0KHN0cmVhbXMpO1xuICAgIHN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICB2YXIgc3RyZWFtSWQgPSBNZWRpYVN0cmVhbU1hbmFnZXIuc3RyZWFtSWQoc3RyZWFtKTtcbiAgICAgIGlmICh0aGlzLmFjcXVpc2l0aW9uc1tzdHJlYW1JZF0gPT09IGZhbHNlKSB7XG4gICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5hY3F1aXNpdGlvbnNbc3RyZWFtSWRdO1xuICAgIH0sIHRoaXMpO1xuICB9fSxcbn0pO1xuXG4vLyBSZXR1cm4gc2luY2UgaXQgd2lsbCBiZSBhc3NpZ25lZCB0byBhIHZhcmlhYmxlLlxucmV0dXJuIE1lZGlhU3RyZWFtTWFuYWdlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYVN0cmVhbU1hbmFnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSBTSVAgVXNlciBBZ2VudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24gcmV0dXJuaW5nIFNJUC5NZWRpYUhhbmRsZXJ9IFtjb25maWd1cmF0aW9uLm1lZGlhSGFuZGxlckZhY3RvcnldXG4gKiAgICAgICAgQSBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYnkgZWFjaCBvZiB0aGUgVUEncyBTZXNzaW9ucyB0byBidWlsZCB0aGUgTWVkaWFIYW5kbGVyIGZvciB0aGF0IFNlc3Npb24uXG4gKiAgICAgICAgSWYgbm8gKG9yIGEgZmFsc3kpIHZhbHVlIGlzIHByb3ZpZGVkLCBlYWNoIFNlc3Npb24gd2lsbCB1c2UgYSBkZWZhdWx0IChXZWJSVEMpIE1lZGlhSGFuZGxlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ3VyYXRpb24ubWVkaWFdIGdldHMgcGFzc2VkIHRvIFNJUC5NZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24gYXMgbWVkaWFIaW50XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgZW52aXJvbm1lbnQpIHtcbnZhciBVQSxcbiAgQyA9IHtcbiAgICAvLyBVQSBzdGF0dXMgY29kZXNcbiAgICBTVEFUVVNfSU5JVDogICAgICAgICAgICAgICAgMCxcbiAgICBTVEFUVVNfU1RBUlRJTkc6ICAgICAgICAgICAgMSxcbiAgICBTVEFUVVNfUkVBRFk6ICAgICAgICAgICAgICAgMixcbiAgICBTVEFUVVNfVVNFUl9DTE9TRUQ6ICAgICAgICAgMyxcbiAgICBTVEFUVVNfTk9UX1JFQURZOiAgICAgICAgICAgNCxcblxuICAgIC8vIFVBIGVycm9yIGNvZGVzXG4gICAgQ09ORklHVVJBVElPTl9FUlJPUjogIDEsXG4gICAgTkVUV09SS19FUlJPUjogICAgICAgIDIsXG5cbiAgICBBTExPV0VEX01FVEhPRFM6IFtcbiAgICAgICdBQ0snLFxuICAgICAgJ0NBTkNFTCcsXG4gICAgICAnSU5WSVRFJyxcbiAgICAgICdNRVNTQUdFJyxcbiAgICAgICdCWUUnLFxuICAgICAgJ09QVElPTlMnLFxuICAgICAgJ0lORk8nLFxuICAgICAgJ05PVElGWScsXG4gICAgICAnUkVGRVInXG4gICAgXSxcblxuICAgIEFDQ0VQVEVEX0JPRFlfVFlQRVM6IFtcbiAgICAgICdhcHBsaWNhdGlvbi9zZHAnLFxuICAgICAgJ2FwcGxpY2F0aW9uL2R0bWYtcmVsYXknXG4gICAgXSxcblxuICAgIE1BWF9GT1JXQVJEUzogNzAsXG4gICAgVEFHX0xFTkdUSDogMTBcbiAgfTtcblxuVUEgPSBmdW5jdGlvbihjb25maWd1cmF0aW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGZvcndhcmRpbmcgZXZlbnRzXG4gIGZ1bmN0aW9uIHNlbGZFbWl0KHR5cGUpIHtcbiAgICAvL3JlZ2lzdHJhdGlvbkZhaWxlZCBoYW5kbGVyIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzLiBBbGxvdyBldmVudCBoYW5kbGVycyB0byBiZSBpbnZva2VkIHdpdGggYSB2YXJpYWJsZSBuby4gb2YgYXJndW1lbnRzXG4gICAgcmV0dXJuIHNlbGYuZW1pdC5iaW5kKHNlbGYsIHR5cGUpO1xuICB9XG5cbiAgLy8gU2V0IEFjY2VwdGVkIEJvZHkgVHlwZXNcbiAgQy5BQ0NFUFRFRF9CT0RZX1RZUEVTID0gQy5BQ0NFUFRFRF9CT0RZX1RZUEVTLnRvU3RyaW5nKCk7XG5cbiAgdGhpcy5sb2cgPSBuZXcgU0lQLkxvZ2dlckZhY3RvcnkoKTtcbiAgdGhpcy5sb2dnZXIgPSB0aGlzLmdldExvZ2dlcignc2lwLnVhJyk7XG5cbiAgdGhpcy5jYWNoZSA9IHtcbiAgICBjcmVkZW50aWFsczoge31cbiAgfTtcblxuICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgdGhpcy5kaWFsb2dzID0ge307XG5cbiAgLy9Vc2VyIGFjdGlvbnMgb3V0c2lkZSBhbnkgc2Vzc2lvbi9kaWFsb2cgKE1FU1NBR0UpXG4gIHRoaXMuYXBwbGljYW50cyA9IHt9O1xuXG4gIHRoaXMuZGF0YSA9IHt9O1xuICB0aGlzLnNlc3Npb25zID0ge307XG4gIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHt9O1xuICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIHRoaXMuY29udGFjdCA9IG51bGw7XG4gIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfSU5JVDtcbiAgdGhpcy5lcnJvciA9IG51bGw7XG4gIHRoaXMudHJhbnNhY3Rpb25zID0ge1xuICAgIG5pc3Q6IHt9LFxuICAgIG5pY3Q6IHt9LFxuICAgIGlzdDoge30sXG4gICAgaWN0OiB7fVxuICB9O1xuXG4gIHRoaXMudHJhbnNwb3J0UmVjb3ZlckF0dGVtcHRzID0gMDtcbiAgdGhpcy50cmFuc3BvcnRSZWNvdmVyeVRpbWVyID0gbnVsbDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgdHJhbnNhY3Rpb25zQ291bnQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0eXBlLFxuICAgICAgICAgIHRyYW5zYWN0aW9ucyA9IFsnbmlzdCcsJ25pY3QnLCdpc3QnLCdpY3QnXSxcbiAgICAgICAgICBjb3VudCA9IDA7XG5cbiAgICAgICAgZm9yICh0eXBlIGluIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgIGNvdW50ICs9IE9iamVjdC5rZXlzKHRoaXMudHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uc1t0eXBlXV0pLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmljdFRyYW5zYWN0aW9uc0NvdW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50cmFuc2FjdGlvbnNbJ25pY3QnXSkubGVuZ3RoO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuaXN0VHJhbnNhY3Rpb25zQ291bnQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRyYW5zYWN0aW9uc1snbmlzdCddKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGljdFRyYW5zYWN0aW9uc0NvdW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50cmFuc2FjdGlvbnNbJ2ljdCddKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzdFRyYW5zYWN0aW9uc0NvdW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50cmFuc2FjdGlvbnNbJ2lzdCddKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogTG9hZCBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEB0aHJvd3Mge1NJUC5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcn1cbiAgICogQHRocm93cyB7VHlwZUVycm9yfVxuICAgKi9cblxuICBpZihjb25maWd1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25maWd1cmF0aW9uID0ge307XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24gPT09ICdzdHJpbmcnIHx8IGNvbmZpZ3VyYXRpb24gaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICBjb25maWd1cmF0aW9uID0ge1xuICAgICAgdXJpOiBjb25maWd1cmF0aW9uXG4gICAgfTtcbiAgfVxuXG4gIC8vIEFwcGx5IGxvZyBjb25maWd1cmF0aW9uIGlmIHByZXNlbnRcbiAgaWYgKGNvbmZpZ3VyYXRpb24ubG9nKSB7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24ubG9nLmhhc093blByb3BlcnR5KCdidWlsdGluRW5hYmxlZCcpKSB7XG4gICAgICB0aGlzLmxvZy5idWlsdGluRW5hYmxlZCA9IGNvbmZpZ3VyYXRpb24ubG9nLmJ1aWx0aW5FbmFibGVkO1xuICAgIH1cblxuICAgIGlmIChjb25maWd1cmF0aW9uLmxvZy5oYXNPd25Qcm9wZXJ0eSgnbGV2ZWwnKSkge1xuICAgICAgdGhpcy5sb2cubGV2ZWwgPSBjb25maWd1cmF0aW9uLmxvZy5sZXZlbDtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlndXJhdGlvbi5sb2cuaGFzT3duUHJvcGVydHkoJ2Nvbm5lY3RvcicpKSB7XG4gICAgICB0aGlzLmxvZy5jb25uZWN0b3IgPSBjb25maWd1cmF0aW9uLmxvZy5jb25uZWN0b3I7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmxvYWRDb25maWcoY29uZmlndXJhdGlvbik7XG4gIH0gY2F0Y2goZSkge1xuICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfTk9UX1JFQURZO1xuICAgIHRoaXMuZXJyb3IgPSBDLkNPTkZJR1VSQVRJT05fRVJST1I7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgcmVnaXN0ZXJDb250ZXh0XG4gIHRoaXMucmVnaXN0ZXJDb250ZXh0ID0gbmV3IFNJUC5SZWdpc3RlckNvbnRleHQodGhpcyk7XG4gIHRoaXMucmVnaXN0ZXJDb250ZXh0Lm9uKCdmYWlsZWQnLCBzZWxmRW1pdCgncmVnaXN0cmF0aW9uRmFpbGVkJykpO1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5vbigncmVnaXN0ZXJlZCcsIHNlbGZFbWl0KCdyZWdpc3RlcmVkJykpO1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5vbigndW5yZWdpc3RlcmVkJywgc2VsZkVtaXQoJ3VucmVnaXN0ZXJlZCcpKTtcblxuICBpZih0aGlzLmNvbmZpZ3VyYXRpb24uYXV0b3N0YXJ0KSB7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnZpcm9ubWVudC5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gR29vZ2xlIENocm9tZSBQYWNrYWdlZCBBcHBzIGRvbid0IGFsbG93ICd1bmxvYWQnIGxpc3RlbmVyczpcbiAgICAvLyB1bmxvYWQgaXMgbm90IGF2YWlsYWJsZSBpbiBwYWNrYWdlZCBhcHBzXG4gICAgaWYgKCEoZ2xvYmFsLmNocm9tZSAmJiBnbG9iYWwuY2hyb21lLmFwcCAmJiBnbG9iYWwuY2hyb21lLmFwcC5ydW50aW1lKSkge1xuICAgICAgZW52aXJvbm1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgdGhpcy5zdG9wLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxufTtcblVBLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG4vLz09PT09PT09PT09PT09PT09XG4vLyAgSGlnaCBMZXZlbCBBUElcbi8vPT09PT09PT09PT09PT09PT1cblxuVUEucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLmNvbmZpZ3VyYXRpb24ucmVnaXN0ZXIgPSB0cnVlO1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5yZWdpc3RlcihvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVW5yZWdpc3Rlci5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxdIHVucmVnaXN0ZXIgYWxsIHVzZXIgYmluZGluZ3MuXG4gKlxuICovXG5VQS5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5jb25maWd1cmF0aW9uLnJlZ2lzdGVyID0gZmFsc2U7XG5cbiAgdmFyIGNvbnRleHQgPSB0aGlzLnJlZ2lzdGVyQ29udGV4dDtcbiAgdGhpcy5hZnRlckNvbm5lY3RlZChjb250ZXh0LnVucmVnaXN0ZXIuYmluZChjb250ZXh0LCBvcHRpb25zKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5VQS5wcm90b3R5cGUuaXNSZWdpc3RlcmVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlZ2lzdGVyQ29udGV4dC5yZWdpc3RlcmVkO1xufTtcblxuLyoqXG4gKiBDb25uZWN0aW9uIHN0YXRlLlxuICogQHBhcmFtIHtCb29sZWFufVxuICovXG5VQS5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHJhbnNwb3J0ID8gdGhpcy50cmFuc3BvcnQuY29ubmVjdGVkIDogZmFsc2U7XG59O1xuXG5VQS5wcm90b3R5cGUuYWZ0ZXJDb25uZWN0ZWQgPSBmdW5jdGlvbiBhZnRlckNvbm5lY3RlZCAoY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgIGNhbGxiYWNrKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vbmNlKCdjb25uZWN0ZWQnLCBjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFrZSBhbiBvdXRnb2luZyBjYWxsLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3c1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1lZGlhXSBnZXRzIHBhc3NlZCB0byBTSVAuTWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uIGFzIG1lZGlhSGludFxuICpcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqXG4gKi9cblVBLnByb3RvdHlwZS5pbnZpdGUgPSBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgU0lQLkludml0ZUNsaWVudENvbnRleHQodGhpcywgdGFyZ2V0LCBvcHRpb25zKTtcblxuICB0aGlzLmFmdGVyQ29ubmVjdGVkKGNvbnRleHQuaW52aXRlLmJpbmQoY29udGV4dCkpO1xuICByZXR1cm4gY29udGV4dDtcbn07XG5cblVBLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50LCBvcHRpb25zKSB7XG4gIHZhciBzdWIgPSBuZXcgU0lQLlN1YnNjcmlwdGlvbih0aGlzLCB0YXJnZXQsIGV2ZW50LCBvcHRpb25zKTtcblxuICB0aGlzLmFmdGVyQ29ubmVjdGVkKHN1Yi5zdWJzY3JpYmUuYmluZChzdWIpKTtcbiAgcmV0dXJuIHN1Yjtcbn07XG5cbi8qKlxuICogU2VuZCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKlxuICovXG5VQS5wcm90b3R5cGUubWVzc2FnZSA9IGZ1bmN0aW9uKHRhcmdldCwgYm9keSwgb3B0aW9ucykge1xuICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgfVxuXG4gIC8vIFRoZXJlIGlzIG5vIE1lc3NhZ2UgbW9kdWxlLCBzbyBpdCBpcyBva2F5IHRoYXQgdGhlIFVBIGhhbmRsZXMgZGVmYXVsdHMgaGVyZS5cbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgb3B0aW9ucy5jb250ZW50VHlwZSB8fCAob3B0aW9ucy5jb250ZW50VHlwZSA9ICd0ZXh0L3BsYWluJyk7XG4gIG9wdGlvbnMuYm9keSA9IGJvZHk7XG5cbiAgcmV0dXJuIHRoaXMucmVxdWVzdChTSVAuQy5NRVNTQUdFLCB0YXJnZXQsIG9wdGlvbnMpO1xufTtcblxuVUEucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlcSA9IG5ldyBTSVAuQ2xpZW50Q29udGV4dCh0aGlzLCBtZXRob2QsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgdGhpcy5hZnRlckNvbm5lY3RlZChyZXEuc2VuZC5iaW5kKHJlcSkpO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBHcmFjZWZ1bGx5IGNsb3NlLlxuICpcbiAqL1xuVUEucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlc3Npb24sIHN1YnNjcmlwdGlvbiwgYXBwbGljYW50LFxuICAgIHVhID0gdGhpcztcblxuICBmdW5jdGlvbiB0cmFuc2FjdGlvbnNMaXN0ZW5lcigpIHtcbiAgICBpZiAodWEubmlzdFRyYW5zYWN0aW9uc0NvdW50ID09PSAwICYmIHVhLm5pY3RUcmFuc2FjdGlvbnNDb3VudCA9PT0gMCkge1xuICAgICAgICB1YS5yZW1vdmVMaXN0ZW5lcigndHJhbnNhY3Rpb25EZXN0cm95ZWQnLCB0cmFuc2FjdGlvbnNMaXN0ZW5lcik7XG4gICAgICAgIHVhLnRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5sb2dnZXIubG9nKCd1c2VyIHJlcXVlc3RlZCBjbG9zdXJlLi4uJyk7XG5cbiAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1VTRVJfQ0xPU0VEKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignVUEgYWxyZWFkeSBjbG9zZWQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIENsZWFyIHRyYW5zcG9ydFJlY292ZXJ5VGltZXJcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50cmFuc3BvcnRSZWNvdmVyeVRpbWVyKTtcblxuICAvLyBDbG9zZSByZWdpc3RlckNvbnRleHRcbiAgdGhpcy5sb2dnZXIubG9nKCdjbG9zaW5nIHJlZ2lzdGVyQ29udGV4dCcpO1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5jbG9zZSgpO1xuXG4gIC8vIFJ1biAgX3Rlcm1pbmF0ZV8gb24gZXZlcnkgU2Vzc2lvblxuICBmb3Ioc2Vzc2lvbiBpbiB0aGlzLnNlc3Npb25zKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdjbG9zaW5nIHNlc3Npb24gJyArIHNlc3Npb24pO1xuICAgIHRoaXMuc2Vzc2lvbnNbc2Vzc2lvbl0udGVybWluYXRlKCk7XG4gIH1cblxuICAvL1J1biBfY2xvc2VfIG9uIGV2ZXJ5IFN1YnNjcmlwdGlvblxuICBmb3Ioc3Vic2NyaXB0aW9uIGluIHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyLmxvZygndW5zdWJzY3JpYmluZyBmcm9tIHN1YnNjcmlwdGlvbiAnICsgc3Vic2NyaXB0aW9uKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnNbc3Vic2NyaXB0aW9uXS5jbG9zZSgpO1xuICB9XG5cbiAgLy8gUnVuICBfY2xvc2VfIG9uIGV2ZXJ5IGFwcGxpY2FudFxuICBmb3IoYXBwbGljYW50IGluIHRoaXMuYXBwbGljYW50cykge1xuICAgIHRoaXMuYXBwbGljYW50c1thcHBsaWNhbnRdLmNsb3NlKCk7XG4gIH1cblxuICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX1VTRVJfQ0xPU0VEO1xuXG4gIC8qXG4gICAqIElmIHRoZSByZW1haW5pbmcgdHJhbnNhY3Rpb25zIGFyZSBhbGwgSU5WSVRFIHRyYW5zYWN0aW9ucywgdGhlcmUgaXMgbm8gbmVlZCB0b1xuICAgKiB3YWl0IGFueW1vcmUgYmVjYXVzZSBldmVyeSBzZXNzaW9uIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ5IHRoaXMgbWV0aG9kLlxuICAgKiAtIGxvY2FsbHkgb3JpZ2luYXRlZCBzZXNzaW9ucyB3aGVyZSB0ZXJtaW5hdGVkIChDQU5DRUwgb3IgQllFKVxuICAgKiAtIHJlbW90ZWx5IG9yaWdpbmF0ZWQgc2Vzc2lvbnMgd2hlcmUgcmVqZWN0ZWQgKDRYWCkgb3IgdGVybWluYXRlZCAoQllFKVxuICAgKiBSZW1haW5pbmcgSU5WSVRFIHRyYW5zYWN0aW9ucyBiZWxvbmcgdGhvIHNlc3Npb25zIHRoYXQgd2hlcmUgYW5zd2VyZWQuIFRoaXMgYXJlIGluXG4gICAqICdhY2NlcHRlZCcgc3RhdGUgZHVlIHRvIHRpbWVycyAnTCcgYW5kICdNJyBkZWZpbmVkIGluIFtSRkMgNjAyNl1cbiAgICovXG4gIGlmICh0aGlzLm5pc3RUcmFuc2FjdGlvbnNDb3VudCA9PT0gMCAmJiB0aGlzLm5pY3RUcmFuc2FjdGlvbnNDb3VudCA9PT0gMCkge1xuICAgIHRoaXMudHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9uKCd0cmFuc2FjdGlvbkRlc3Ryb3llZCcsIHRyYW5zYWN0aW9uc0xpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb25uZWN0IHRvIHRoZSBXUyBzZXJ2ZXIgaWYgc3RhdHVzID0gU1RBVFVTX0lOSVQuXG4gKiBSZXN1bWUgVUEgYWZ0ZXIgYmVpbmcgY2xvc2VkLlxuICpcbiAqL1xuVUEucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZXJ2ZXI7XG5cbiAgdGhpcy5sb2dnZXIubG9nKCd1c2VyIHJlcXVlc3RlZCBzdGFydHVwLi4uJyk7XG4gIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfSU5JVCkge1xuICAgIHNlcnZlciA9IHRoaXMuZ2V0TmV4dFdzU2VydmVyKCk7XG4gICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19TVEFSVElORztcbiAgICBuZXcgU0lQLlRyYW5zcG9ydCh0aGlzLCBzZXJ2ZXIpO1xuICB9IGVsc2UgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1VTRVJfQ0xPU0VEKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdyZXN1bWluZycpO1xuICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfUkVBRFk7XG4gICAgdGhpcy50cmFuc3BvcnQuY29ubmVjdCgpO1xuICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19TVEFSVElORykge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnVUEgaXMgaW4gU1RBUlRJTkcgc3RhdHVzLCBub3Qgb3BlbmluZyBuZXcgY29ubmVjdGlvbicpO1xuICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19SRUFEWSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnVUEgaXMgaW4gUkVBRFkgc3RhdHVzLCBub3QgcmVzdW1pbmcnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxvZ2dlci5lcnJvcignQ29ubmVjdGlvbiBpcyBkb3duLiBBdXRvLVJlY292ZXJ5IHN5c3RlbSBpcyB0cnlpbmcgdG8gY29ubmVjdCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHN0cmluZyBpbnRvIGEgdmFsaWQgU0lQIHJlcXVlc3QgVVJJXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICpcbiAqIEByZXR1cm5zIHtTSVAuVVJJfHVuZGVmaW5lZH1cbiAqL1xuVUEucHJvdG90eXBlLm5vcm1hbGl6ZVRhcmdldCA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICByZXR1cm4gU0lQLlV0aWxzLm5vcm1hbGl6ZVRhcmdldCh0YXJnZXQsIHRoaXMuY29uZmlndXJhdGlvbi5ob3N0cG9ydFBhcmFtcyk7XG59O1xuXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gIFByaXZhdGUgKEZvciBpbnRlcm5hbCB1c2UpXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuVUEucHJvdG90eXBlLnNhdmVDcmVkZW50aWFscyA9IGZ1bmN0aW9uKGNyZWRlbnRpYWxzKSB7XG4gIHRoaXMuY2FjaGUuY3JlZGVudGlhbHNbY3JlZGVudGlhbHMucmVhbG1dID0gdGhpcy5jYWNoZS5jcmVkZW50aWFsc1tjcmVkZW50aWFscy5yZWFsbV0gfHwge307XG4gIHRoaXMuY2FjaGUuY3JlZGVudGlhbHNbY3JlZGVudGlhbHMucmVhbG1dW2NyZWRlbnRpYWxzLnVyaV0gPSBjcmVkZW50aWFscztcblxuICByZXR1cm4gdGhpcztcbn07XG5cblVBLnByb3RvdHlwZS5nZXRDcmVkZW50aWFscyA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgdmFyIHJlYWxtLCBjcmVkZW50aWFscztcblxuICByZWFsbSA9IHJlcXVlc3QucnVyaS5ob3N0O1xuXG4gIGlmICh0aGlzLmNhY2hlLmNyZWRlbnRpYWxzW3JlYWxtXSAmJiB0aGlzLmNhY2hlLmNyZWRlbnRpYWxzW3JlYWxtXVtyZXF1ZXN0LnJ1cmldKSB7XG4gICAgY3JlZGVudGlhbHMgPSB0aGlzLmNhY2hlLmNyZWRlbnRpYWxzW3JlYWxtXVtyZXF1ZXN0LnJ1cmldO1xuICAgIGNyZWRlbnRpYWxzLm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICB9XG5cbiAgcmV0dXJuIGNyZWRlbnRpYWxzO1xufTtcblxuVUEucHJvdG90eXBlLmdldExvZ2dlciA9IGZ1bmN0aW9uKGNhdGVnb3J5LCBsYWJlbCkge1xuICByZXR1cm4gdGhpcy5sb2cuZ2V0TG9nZ2VyKGNhdGVnb3J5LCBsYWJlbCk7XG59O1xuXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFdmVudCBIYW5kbGVyc1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBUcmFuc3BvcnQgQ2xvc2UgZXZlbnRcbiAqIEBwcml2YXRlXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0LlxuICovXG5VQS5wcm90b3R5cGUub25UcmFuc3BvcnRDbG9zZWQgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcbiAgLy8gUnVuIF9vblRyYW5zcG9ydEVycm9yXyBjYWxsYmFjayBvbiBldmVyeSBjbGllbnQgdHJhbnNhY3Rpb24gdXNpbmcgX3RyYW5zcG9ydF9cbiAgdmFyIHR5cGUsIGlkeCwgbGVuZ3RoLFxuICAgIGNsaWVudF90cmFuc2FjdGlvbnMgPSBbJ25pY3QnLCAnaWN0JywgJ25pc3QnLCAnaXN0J107XG5cbiAgdHJhbnNwb3J0LnNlcnZlci5zdGF0dXMgPSBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX0RJU0NPTk5FQ1RFRDtcbiAgdGhpcy5sb2dnZXIubG9nKCdjb25uZWN0aW9uIHN0YXRlIHNldCB0byAnKyBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX0RJU0NPTk5FQ1RFRCk7XG5cbiAgbGVuZ3RoID0gY2xpZW50X3RyYW5zYWN0aW9ucy5sZW5ndGg7XG4gIGZvciAodHlwZSA9IDA7IHR5cGUgPCBsZW5ndGg7IHR5cGUrKykge1xuICAgIGZvcihpZHggaW4gdGhpcy50cmFuc2FjdGlvbnNbY2xpZW50X3RyYW5zYWN0aW9uc1t0eXBlXV0pIHtcbiAgICAgIHRoaXMudHJhbnNhY3Rpb25zW2NsaWVudF90cmFuc2FjdGlvbnNbdHlwZV1dW2lkeF0ub25UcmFuc3BvcnRFcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENsb3NlIHNlc3Npb25zIGlmIEdSVVUgaXMgbm90IGJlaW5nIHVzZWRcbiAgaWYgKCF0aGlzLmNvbnRhY3QucHViX2dydXUpIHtcbiAgICB0aGlzLmNsb3NlU2Vzc2lvbnNPblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBVbnJlY292ZXJhYmxlIHRyYW5zcG9ydCBldmVudC5cbiAqIENvbm5lY3Rpb24gcmVhdHRlbXB0IGxvZ2ljIGhhcyBiZWVuIGRvbmUgYW5kIGRpZG4ndCBzdWNjZXNzLlxuICogQHByaXZhdGVcbiAqIEBldmVudFxuICogQHBhcmFtIHtTSVAuVHJhbnNwb3J0fSB0cmFuc3BvcnQuXG4gKi9cblVBLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG4gIHZhciBzZXJ2ZXI7XG5cbiAgdGhpcy5sb2dnZXIubG9nKCd0cmFuc3BvcnQgJyArIHRyYW5zcG9ydC5zZXJ2ZXIud3NfdXJpICsgJyBmYWlsZWQgfCBjb25uZWN0aW9uIHN0YXRlIHNldCB0byAnKyBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX0VSUk9SKTtcblxuICAvLyBDbG9zZSBzZXNzaW9ucy5cbiAgLy9NYXJrIHRoaXMgdHJhbnNwb3J0IGFzICdkb3duJ1xuICB0cmFuc3BvcnQuc2VydmVyLnN0YXR1cyA9IFNJUC5UcmFuc3BvcnQuQy5TVEFUVVNfRVJST1I7XG5cbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0ZWQnLCB7XG4gICAgdHJhbnNwb3J0OiB0cmFuc3BvcnRcbiAgfSk7XG5cbiAgLy8gdHJ5IHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgVUEgaXNuJ3QgY2xvc2VkXG4gIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19VU0VSX0NMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlcnZlciA9IHRoaXMuZ2V0TmV4dFdzU2VydmVyKCk7XG5cbiAgaWYoc2VydmVyKSB7XG4gICAgbmV3IFNJUC5UcmFuc3BvcnQodGhpcywgc2VydmVyKTtcbiAgfWVsc2Uge1xuICAgIHRoaXMuY2xvc2VTZXNzaW9uc09uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICBpZiAoIXRoaXMuZXJyb3IgfHwgdGhpcy5lcnJvciAhPT0gQy5ORVRXT1JLX0VSUk9SKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX05PVF9SRUFEWTtcbiAgICAgIHRoaXMuZXJyb3IgPSBDLk5FVFdPUktfRVJST1I7XG4gICAgfVxuICAgIC8vIFRyYW5zcG9ydCBSZWNvdmVyeSBwcm9jZXNzXG4gICAgdGhpcy5yZWNvdmVyVHJhbnNwb3J0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogVHJhbnNwb3J0IGNvbm5lY3Rpb24gZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICogQGV2ZW50XG4gKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydC5cbiAqL1xuVUEucHJvdG90eXBlLm9uVHJhbnNwb3J0Q29ubmVjdGVkID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIFJlc2V0IHRyYW5zcG9ydCByZWNvdmVyeSBjb3VudGVyXG4gIHRoaXMudHJhbnNwb3J0UmVjb3ZlckF0dGVtcHRzID0gMDtcblxuICB0cmFuc3BvcnQuc2VydmVyLnN0YXR1cyA9IFNJUC5UcmFuc3BvcnQuQy5TVEFUVVNfUkVBRFk7XG4gIHRoaXMubG9nZ2VyLmxvZygnY29ubmVjdGlvbiBzdGF0ZSBzZXQgdG8gJysgU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19SRUFEWSk7XG5cbiAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1VTRVJfQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19SRUFEWTtcbiAgdGhpcy5lcnJvciA9IG51bGw7XG5cbiAgaWYodGhpcy5jb25maWd1cmF0aW9uLnJlZ2lzdGVyKSB7XG4gICAgdGhpcy5jb25maWd1cmF0aW9uLmF1dGhlbnRpY2F0aW9uRmFjdG9yeS5pbml0aWFsaXplKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5vblRyYW5zcG9ydENvbm5lY3RlZCgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICB0aGlzLmVtaXQoJ2Nvbm5lY3RlZCcsIHtcbiAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydFxuICB9KTtcbn07XG5cblxuLyoqXG4gKiBUcmFuc3BvcnQgY29ubmVjdGluZyBldmVudFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0LlxuICogI3BhcmFtIHtJbnRlZ2VyfSBhdHRlbXB0cy5cbiAqL1xuICBVQS5wcm90b3R5cGUub25UcmFuc3BvcnRDb25uZWN0aW5nID0gZnVuY3Rpb24odHJhbnNwb3J0LCBhdHRlbXB0cykge1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdGluZycsIHtcbiAgICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0LFxuICAgICAgYXR0ZW1wdHM6IGF0dGVtcHRzXG4gICAgfSk7XG4gIH07XG5cblxuLyoqXG4gKiBuZXcgVHJhbnNhY3Rpb25cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5UcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24uXG4gKi9cblVBLnByb3RvdHlwZS5uZXdUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIHRoaXMudHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uLnR5cGVdW3RyYW5zYWN0aW9uLmlkXSA9IHRyYW5zYWN0aW9uO1xuICB0aGlzLmVtaXQoJ25ld1RyYW5zYWN0aW9uJywge3RyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbn0pO1xufTtcblxuXG4vKipcbiAqIGRlc3Ryb3kgVHJhbnNhY3Rpb25cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5UcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24uXG4gKi9cblVBLnByb3RvdHlwZS5kZXN0cm95VHJhbnNhY3Rpb24gPSBmdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICBkZWxldGUgdGhpcy50cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb24udHlwZV1bdHJhbnNhY3Rpb24uaWRdO1xuICB0aGlzLmVtaXQoJ3RyYW5zYWN0aW9uRGVzdHJveWVkJywge1xuICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICB9KTtcbn07XG5cblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyByZWNlaXZlUmVxdWVzdFxuLy89PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogUmVxdWVzdCByZWNlcHRpb25cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3QuXG4gKi9cblVBLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgdmFyIGRpYWxvZywgc2Vzc2lvbiwgbWVzc2FnZSxcbiAgICBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZCxcbiAgICB0cmFuc2FjdGlvbixcbiAgICByZXBsYWNlcyxcbiAgICByZXBsYWNlZERpYWxvZyxcbiAgICBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBydXJpTWF0Y2hlcyAodXJpKSB7XG4gICAgcmV0dXJuIHVyaSAmJiB1cmkudXNlciA9PT0gcmVxdWVzdC5ydXJpLnVzZXI7XG4gIH1cblxuICAvLyBDaGVjayB0aGF0IHJlcXVlc3QgVVJJIHBvaW50cyB0byB1c1xuICBpZighKHJ1cmlNYXRjaGVzKHRoaXMuY29uZmlndXJhdGlvbi51cmkpIHx8XG4gICAgICAgcnVyaU1hdGNoZXModGhpcy5jb250YWN0LnVyaSkgfHxcbiAgICAgICBydXJpTWF0Y2hlcyh0aGlzLmNvbnRhY3QucHViX2dydXUpIHx8XG4gICAgICAgcnVyaU1hdGNoZXModGhpcy5jb250YWN0LnRlbXBfZ3J1dSkpKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignUmVxdWVzdC1VUkkgZG9lcyBub3QgcG9pbnQgdG8gdXMnKTtcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFNJUC5DLkFDSykge1xuICAgICAgcmVxdWVzdC5yZXBseV9zbCg0MDQpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDaGVjayByZXF1ZXN0IFVSSSBzY2hlbWVcbiAgaWYocmVxdWVzdC5ydXJpLnNjaGVtZSA9PT0gU0lQLkMuU0lQUykge1xuICAgIHJlcXVlc3QucmVwbHlfc2woNDE2KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDaGVjayB0cmFuc2FjdGlvblxuICBpZihTSVAuVHJhbnNhY3Rpb25zLmNoZWNrVHJhbnNhY3Rpb24odGhpcywgcmVxdWVzdCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBSRkMzMjYxIDEyLjIuMlxuICAgKiBSZXF1ZXN0cyB0aGF0IGRvIG5vdCBjaGFuZ2UgaW4gYW55IHdheSB0aGUgc3RhdGUgb2YgYSBkaWFsb2cgbWF5IGJlXG4gICAqIHJlY2VpdmVkIHdpdGhpbiBhIGRpYWxvZyAoZm9yIGV4YW1wbGUsIGFuIE9QVElPTlMgcmVxdWVzdCkuXG4gICAqIFRoZXkgYXJlIHByb2Nlc3NlZCBhcyBpZiB0aGV5IGhhZCBiZWVuIHJlY2VpdmVkIG91dHNpZGUgdGhlIGRpYWxvZy5cbiAgICovXG4gIGlmKG1ldGhvZCA9PT0gU0lQLkMuT1BUSU9OUykge1xuICAgIG5ldyBTSVAuVHJhbnNhY3Rpb25zLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uKHJlcXVlc3QsIHRoaXMpO1xuICAgIHJlcXVlc3QucmVwbHkoMjAwLCBudWxsLCBbXG4gICAgICAnQWxsb3c6ICcrIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpLFxuICAgICAgJ0FjY2VwdDogJysgQy5BQ0NFUFRFRF9CT0RZX1RZUEVTXG4gICAgXSk7XG4gIH0gZWxzZSBpZiAobWV0aG9kID09PSBTSVAuQy5NRVNTQUdFKSB7XG4gICAgbWVzc2FnZSA9IG5ldyBTSVAuU2VydmVyQ29udGV4dCh0aGlzLCByZXF1ZXN0KTtcbiAgICBtZXNzYWdlLmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgbWVzc2FnZS5jb250ZW50X3R5cGUgPSByZXF1ZXN0LmdldEhlYWRlcignQ29udGVudC1UeXBlJykgfHwgJ3RleHQvcGxhaW4nO1xuXG4gICAgcmVxdWVzdC5yZXBseSgyMDAsIG51bGwpO1xuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICB9IGVsc2UgaWYgKG1ldGhvZCAhPT0gU0lQLkMuSU5WSVRFICYmXG4gICAgICAgICAgICAgbWV0aG9kICE9PSBTSVAuQy5BQ0spIHtcbiAgICAvLyBMZXQgdGhvc2UgbWV0aG9kcyBwYXNzIHRocm91Z2ggdG8gbm9ybWFsIHByb2Nlc3NpbmcgZm9yIG5vdy5cbiAgICB0cmFuc2FjdGlvbiA9IG5ldyBTSVAuU2VydmVyQ29udGV4dCh0aGlzLCByZXF1ZXN0KTtcbiAgfVxuXG4gIC8vIEluaXRpYWwgUmVxdWVzdFxuICBpZighcmVxdWVzdC50b190YWcpIHtcbiAgICBzd2l0Y2gobWV0aG9kKSB7XG4gICAgICBjYXNlIFNJUC5DLklOVklURTpcbiAgICAgICAgcmVwbGFjZXMgPVxuICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5yZXBsYWNlcyAhPT0gU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEICYmXG4gICAgICAgICAgcmVxdWVzdC5wYXJzZUhlYWRlcigncmVwbGFjZXMnKTtcblxuICAgICAgICBpZiAocmVwbGFjZXMpIHtcbiAgICAgICAgICByZXBsYWNlZERpYWxvZyA9IHRoaXMuZGlhbG9nc1tyZXBsYWNlcy5jYWxsX2lkICsgcmVwbGFjZXMucmVwbGFjZXNfdG9fdGFnICsgcmVwbGFjZXMucmVwbGFjZXNfZnJvbV90YWddO1xuXG4gICAgICAgICAgaWYgKCFyZXBsYWNlZERpYWxvZykge1xuICAgICAgICAgICAgLy9SZXBsYWNlZCBoZWFkZXIgd2l0aG91dCBhIG1hdGNoaW5nIGRpYWxvZywgcmVqZWN0XG4gICAgICAgICAgICByZXF1ZXN0LnJlcGx5X3NsKDQ4MSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlZERpYWxvZy5vd25lci5zdGF0dXMgPT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVwbHlfc2woNjAzLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcGxhY2VkRGlhbG9nLnN0YXRlID09PSBTSVAuRGlhbG9nLkMuU1RBVFVTX0NPTkZJUk1FRCAmJiByZXBsYWNlcy5lYXJseV9vbmx5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlcGx5X3NsKDQ4NiwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzTWVkaWFTdXBwb3J0ZWQgPSB0aGlzLmNvbmZpZ3VyYXRpb24ubWVkaWFIYW5kbGVyRmFjdG9yeS5pc1N1cHBvcnRlZDtcbiAgICAgICAgaWYoIWlzTWVkaWFTdXBwb3J0ZWQgfHwgaXNNZWRpYVN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgc2Vzc2lvbiA9IG5ldyBTSVAuSW52aXRlU2VydmVyQ29udGV4dCh0aGlzLCByZXF1ZXN0KTtcbiAgICAgICAgICBzZXNzaW9uLnJlcGxhY2VlID0gcmVwbGFjZWREaWFsb2cgJiYgcmVwbGFjZWREaWFsb2cub3duZXI7XG4gICAgICAgICAgc2Vzc2lvbi5vbignaW52aXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2ludml0ZScsIHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0lOVklURSByZWNlaXZlZCBidXQgV2ViUlRDIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICByZXF1ZXN0LnJlcGx5KDQ4OCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLkJZRTpcbiAgICAgICAgLy8gT3V0IG9mIGRpYWxvZyBCWUUgcmVjZWl2ZWRcbiAgICAgICAgcmVxdWVzdC5yZXBseSg0ODEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuQ0FOQ0VMOlxuICAgICAgICBzZXNzaW9uID0gdGhpcy5maW5kU2Vzc2lvbihyZXF1ZXN0KTtcbiAgICAgICAgaWYoc2Vzc2lvbikge1xuICAgICAgICAgIHNlc3Npb24ucmVjZWl2ZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybigncmVjZWl2ZWQgQ0FOQ0VMIHJlcXVlc3QgZm9yIGEgbm9uIGV4aXN0ZW50IHNlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuQUNLOlxuICAgICAgICAvKiBBYnNvcmIgaXQuXG4gICAgICAgICAqIEFDSyByZXF1ZXN0IHdpdGhvdXQgYSBjb3JyZXNwb25kaW5nIEludml0ZSBUcmFuc2FjdGlvblxuICAgICAgICAgKiBhbmQgd2l0aG91dCBUbyB0YWcuXG4gICAgICAgICAqL1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlcXVlc3QucmVwbHkoNDA1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8vIEluLWRpYWxvZyByZXF1ZXN0XG4gIGVsc2Uge1xuICAgIGRpYWxvZyA9IHRoaXMuZmluZERpYWxvZyhyZXF1ZXN0KTtcblxuICAgIGlmKGRpYWxvZykge1xuICAgICAgaWYgKG1ldGhvZCA9PT0gU0lQLkMuSU5WSVRFKSB7XG4gICAgICAgIG5ldyBTSVAuVHJhbnNhY3Rpb25zLkludml0ZVNlcnZlclRyYW5zYWN0aW9uKHJlcXVlc3QsIHRoaXMpO1xuICAgICAgfVxuICAgICAgZGlhbG9nLnJlY2VpdmVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBTSVAuQy5OT1RJRlkpIHtcbiAgICAgIHNlc3Npb24gPSB0aGlzLmZpbmRTZXNzaW9uKHJlcXVlc3QpO1xuICAgICAgaWYoc2Vzc2lvbikge1xuICAgICAgICBzZXNzaW9uLnJlY2VpdmVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybigncmVjZWl2ZWQgTk9USUZZIHJlcXVlc3QgZm9yIGEgbm9uIGV4aXN0ZW50IHNlc3Npb24nKTtcbiAgICAgICAgcmVxdWVzdC5yZXBseSg0ODEsICdTdWJzY3JpcHRpb24gZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogUkZDMzI2MSAxMi4yLjJcbiAgICAgKiBSZXF1ZXN0IHdpdGggdG8gdGFnLCBidXQgbm8gbWF0Y2hpbmcgZGlhbG9nIGZvdW5kLlxuICAgICAqIEV4Y2VwdGlvbjogQUNLIGZvciBhbiBJbnZpdGUgcmVxdWVzdCBmb3Igd2hpY2ggYSBkaWFsb2cgaGFzIG5vdFxuICAgICAqIGJlZW4gY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbHNlIHtcbiAgICAgIGlmKG1ldGhvZCAhPT0gU0lQLkMuQUNLKSB7XG4gICAgICAgIHJlcXVlc3QucmVwbHkoNDgxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vPT09PT09PT09PT09PT09PT1cbi8vIFV0aWxzXG4vLz09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogR2V0IHRoZSBzZXNzaW9uIHRvIHdoaWNoIHRoZSByZXF1ZXN0IGJlbG9uZ3MgdG8sIGlmIGFueS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3QuXG4gKiBAcmV0dXJucyB7U0lQLk91dGdvaW5nU2Vzc2lvbnxTSVAuSW5jb21pbmdTZXNzaW9ufG51bGx9XG4gKi9cblVBLnByb3RvdHlwZS5maW5kU2Vzc2lvbiA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHRoaXMuc2Vzc2lvbnNbcmVxdWVzdC5jYWxsX2lkICsgcmVxdWVzdC5mcm9tX3RhZ10gfHxcbiAgICAgICAgICB0aGlzLnNlc3Npb25zW3JlcXVlc3QuY2FsbF9pZCArIHJlcXVlc3QudG9fdGFnXSB8fFxuICAgICAgICAgIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZGlhbG9nIHRvIHdoaWNoIHRoZSByZXF1ZXN0IGJlbG9uZ3MgdG8sIGlmIGFueS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9XG4gKiBAcmV0dXJucyB7U0lQLkRpYWxvZ3xudWxsfVxuICovXG5VQS5wcm90b3R5cGUuZmluZERpYWxvZyA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHRoaXMuZGlhbG9nc1tyZXF1ZXN0LmNhbGxfaWQgKyByZXF1ZXN0LmZyb21fdGFnICsgcmVxdWVzdC50b190YWddIHx8XG4gICAgICAgICAgdGhpcy5kaWFsb2dzW3JlcXVlc3QuY2FsbF9pZCArIHJlcXVlc3QudG9fdGFnICsgcmVxdWVzdC5mcm9tX3RhZ10gfHxcbiAgICAgICAgICBudWxsO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbmV4dCBzZXJ2ZXIgdG8gd2hpY2ggY29ubmVjdC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB3c19zZXJ2ZXJcbiAqL1xuVUEucHJvdG90eXBlLmdldE5leHRXc1NlcnZlciA9IGZ1bmN0aW9uKCkge1xuICAvLyBPcmRlciBzZXJ2ZXJzIGJ5IHdlaWdodFxuICB2YXIgaWR4LCBsZW5ndGgsIHdzX3NlcnZlcixcbiAgICBjYW5kaWRhdGVzID0gW107XG5cbiAgbGVuZ3RoID0gdGhpcy5jb25maWd1cmF0aW9uLndzU2VydmVycy5sZW5ndGg7XG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgIHdzX3NlcnZlciA9IHRoaXMuY29uZmlndXJhdGlvbi53c1NlcnZlcnNbaWR4XTtcblxuICAgIGlmICh3c19zZXJ2ZXIuc3RhdHVzID09PSBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX0VSUk9SKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYW5kaWRhdGVzLnB1c2god3Nfc2VydmVyKTtcbiAgICB9IGVsc2UgaWYgKHdzX3NlcnZlci53ZWlnaHQgPiBjYW5kaWRhdGVzWzBdLndlaWdodCkge1xuICAgICAgY2FuZGlkYXRlcyA9IFt3c19zZXJ2ZXJdO1xuICAgIH0gZWxzZSBpZiAod3Nfc2VydmVyLndlaWdodCA9PT0gY2FuZGlkYXRlc1swXS53ZWlnaHQpIHtcbiAgICAgIGNhbmRpZGF0ZXMucHVzaCh3c19zZXJ2ZXIpO1xuICAgIH1cbiAgfVxuXG4gIGlkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNhbmRpZGF0ZXMubGVuZ3RoKTtcblxuICByZXR1cm4gY2FuZGlkYXRlc1tpZHhdO1xufTtcblxuLyoqXG4gKiBDbG9zZSBhbGwgc2Vzc2lvbnMgb24gdHJhbnNwb3J0IGVycm9yLlxuICogQHByaXZhdGVcbiAqL1xuVUEucHJvdG90eXBlLmNsb3NlU2Vzc2lvbnNPblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpZHg7XG5cbiAgLy8gUnVuIF90cmFuc3BvcnRFcnJvcl8gZm9yIGV2ZXJ5IFNlc3Npb25cbiAgZm9yKGlkeCBpbiB0aGlzLnNlc3Npb25zKSB7XG4gICAgdGhpcy5zZXNzaW9uc1tpZHhdLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxuICAvLyBDYWxsIHJlZ2lzdGVyQ29udGV4dCBfb25UcmFuc3BvcnRDbG9zZWRfXG4gIHRoaXMucmVnaXN0ZXJDb250ZXh0Lm9uVHJhbnNwb3J0Q2xvc2VkKCk7XG59O1xuXG5VQS5wcm90b3R5cGUucmVjb3ZlclRyYW5zcG9ydCA9IGZ1bmN0aW9uKHVhKSB7XG4gIHZhciBpZHgsIGxlbmd0aCwgaywgbmV4dFJldHJ5LCBjb3VudCwgc2VydmVyO1xuXG4gIHVhID0gdWEgfHwgdGhpcztcbiAgY291bnQgPSB1YS50cmFuc3BvcnRSZWNvdmVyQXR0ZW1wdHM7XG5cbiAgbGVuZ3RoID0gdWEuY29uZmlndXJhdGlvbi53c1NlcnZlcnMubGVuZ3RoO1xuICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICB1YS5jb25maWd1cmF0aW9uLndzU2VydmVyc1tpZHhdLnN0YXR1cyA9IDA7XG4gIH1cblxuICBzZXJ2ZXIgPSB1YS5nZXROZXh0V3NTZXJ2ZXIoKTtcblxuICBrID0gTWF0aC5mbG9vcigoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsY291bnQpKSArMSk7XG4gIG5leHRSZXRyeSA9IGsgKiB1YS5jb25maWd1cmF0aW9uLmNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsO1xuXG4gIGlmIChuZXh0UmV0cnkgPiB1YS5jb25maWd1cmF0aW9uLmNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCd0aW1lIGZvciBuZXh0IGNvbm5lY3Rpb24gYXR0ZW1wdCBleGNlZWRzIGNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsLCByZXNldHRpbmcgY291bnRlcicpO1xuICAgIG5leHRSZXRyeSA9IHVhLmNvbmZpZ3VyYXRpb24uY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWw7XG4gICAgY291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5sb2dnZXIubG9nKCduZXh0IGNvbm5lY3Rpb24gYXR0ZW1wdCBpbiAnKyBuZXh0UmV0cnkgKycgc2Vjb25kcycpO1xuXG4gIHRoaXMudHJhbnNwb3J0UmVjb3ZlcnlUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChcbiAgICBmdW5jdGlvbigpe1xuICAgICAgdWEudHJhbnNwb3J0UmVjb3ZlckF0dGVtcHRzID0gY291bnQgKyAxO1xuICAgICAgbmV3IFNJUC5UcmFuc3BvcnQodWEsIHNlcnZlcik7XG4gICAgfSwgbmV4dFJldHJ5ICogMTAwMCk7XG59O1xuXG5mdW5jdGlvbiBjaGVja0F1dGhlbnRpY2F0aW9uRmFjdG9yeSAoYXV0aGVudGljYXRpb25GYWN0b3J5KSB7XG4gIGlmICghKGF1dGhlbnRpY2F0aW9uRmFjdG9yeSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWF1dGhlbnRpY2F0aW9uRmFjdG9yeS5pbml0aWFsaXplKSB7XG4gICAgYXV0aGVudGljYXRpb25GYWN0b3J5LmluaXRpYWxpemUgPSBmdW5jdGlvbiBpbml0aWFsaXplICgpIHtcbiAgICAgIHJldHVybiBTSVAuVXRpbHMuUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYXV0aGVudGljYXRpb25GYWN0b3J5O1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gbG9hZC5cbiAqIEBwcml2YXRlXG4gKiByZXR1cm5zIHtCb29sZWFufVxuICovXG5VQS5wcm90b3R5cGUubG9hZENvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgLy8gU2V0dGluZ3MgYW5kIGRlZmF1bHQgdmFsdWVzXG4gIHZhciBwYXJhbWV0ZXIsIHZhbHVlLCBjaGVja2VkX3ZhbHVlLCBob3N0cG9ydFBhcmFtcywgcmVnaXN0cmFyU2VydmVyLFxuICAgIHNldHRpbmdzID0ge1xuICAgICAgLyogSG9zdCBhZGRyZXNzXG4gICAgICAqIFZhbHVlIHRvIGJlIHNldCBpbiBWaWEgc2VudF9ieSBhbmQgaG9zdCBwYXJ0IG9mIENvbnRhY3QgRlFETlxuICAgICAgKi9cbiAgICAgIHZpYUhvc3Q6IFNJUC5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbigxMikgKyAnLmludmFsaWQnLFxuXG4gICAgICB1cmk6IG5ldyBTSVAuVVJJKCdzaXAnLCAnYW5vbnltb3VzLicgKyBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oNiksICdhbm9ueW1vdXMuaW52YWxpZCcsIG51bGwsIG51bGwpLFxuICAgICAgd3NTZXJ2ZXJzOiBbe1xuICAgICAgICBzY2hlbWU6ICdXU1MnLFxuICAgICAgICBzaXBfdXJpOiAnPHNpcDplZGdlLnNpcC5vbnNpcC5jb207dHJhbnNwb3J0PXdzO2xyPicsXG4gICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgd2VpZ2h0OiAwLFxuICAgICAgICB3c191cmk6ICd3c3M6Ly9lZGdlLnNpcC5vbnNpcC5jb20nXG4gICAgICB9XSxcblxuICAgICAgLy8gUGFzc3dvcmRcbiAgICAgIHBhc3N3b3JkOiBudWxsLFxuXG4gICAgICAvLyBSZWdpc3RyYXRpb24gcGFyYW1ldGVyc1xuICAgICAgcmVnaXN0ZXJFeHBpcmVzOiA2MDAsXG4gICAgICByZWdpc3RlcjogdHJ1ZSxcbiAgICAgIHJlZ2lzdHJhclNlcnZlcjogbnVsbCxcblxuICAgICAgLy8gVHJhbnNwb3J0IHJlbGF0ZWQgcGFyYW1ldGVyc1xuICAgICAgd3NTZXJ2ZXJNYXhSZWNvbm5lY3Rpb246IDMsXG4gICAgICB3c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXQ6IDQsXG5cbiAgICAgIGNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsOiAyLFxuICAgICAgY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWw6IDMwLFxuXG4gICAgICBrZWVwQWxpdmVJbnRlcnZhbDogMCxcblxuICAgICAgZXh0cmFTdXBwb3J0ZWQ6IFtdLFxuXG4gICAgICB1c2VQcmVsb2FkZWRSb3V0ZTogZmFsc2UsXG5cbiAgICAgIC8vc3RyaW5nIHRvIGJlIGluc2VydGVkIGludG8gVXNlci1BZ2VudCByZXF1ZXN0IGhlYWRlclxuICAgICAgdXNlckFnZW50U3RyaW5nOiBTSVAuQy5VU0VSX0FHRU5ULFxuXG4gICAgICAvLyBTZXNzaW9uIHBhcmFtZXRlcnNcbiAgICAgIGljZUNoZWNraW5nVGltZW91dDogNTAwMCxcbiAgICAgIG5vQW5zd2VyVGltZW91dDogNjAsXG4gICAgICBzdHVuU2VydmVyczogWydzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJ10sXG4gICAgICB0dXJuU2VydmVyczogW10sXG5cbiAgICAgIC8vIExvZ2dpbmcgcGFyYW1ldGVyc1xuICAgICAgdHJhY2VTaXA6IGZhbHNlLFxuXG4gICAgICAvLyBIYWNrc1xuICAgICAgaGFja1ZpYVRjcDogZmFsc2UsXG4gICAgICBoYWNrSXBJbkNvbnRhY3Q6IGZhbHNlLFxuICAgICAgaGFja1dzc0luVHJhbnNwb3J0OiBmYWxzZSxcbiAgICAgIGhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3M6IGZhbHNlLFxuXG4gICAgICBjb250YWN0VHJhbnNwb3J0OiAnd3MnLFxuICAgICAgZm9yY2VScG9ydDogZmFsc2UsXG5cbiAgICAgIC8vYXV0b3N0YXJ0aW5nXG4gICAgICBhdXRvc3RhcnQ6IHRydWUsXG5cbiAgICAgIC8vUmVsaWFibGUgUHJvdmlzaW9uYWwgUmVzcG9uc2VzXG4gICAgICByZWwxMDA6IFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRCxcblxuICAgICAgLy8gUmVwbGFjZXMgaGVhZGVyIChSRkMgMzg5MSlcbiAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM4OTFcbiAgICAgIHJlcGxhY2VzOiBTSVAuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQsXG5cbiAgICAgIG1lZGlhSGFuZGxlckZhY3Rvcnk6IFNJUC5XZWJSVEMuTWVkaWFIYW5kbGVyLmRlZmF1bHRGYWN0b3J5LFxuXG4gICAgICBhdXRoZW50aWNhdGlvbkZhY3Rvcnk6IGNoZWNrQXV0aGVudGljYXRpb25GYWN0b3J5KGZ1bmN0aW9uIGF1dGhlbnRpY2F0aW9uRmFjdG9yeSAodWEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTSVAuRGlnZXN0QXV0aGVudGljYXRpb24odWEpO1xuICAgICAgfSlcbiAgICB9O1xuXG4gIC8vIFByZS1Db25maWd1cmF0aW9uXG4gIGZ1bmN0aW9uIGFsaWFzVW5kZXJzY29yZWQgKHBhcmFtZXRlciwgbG9nZ2VyKSB7XG4gICAgdmFyIHVuZGVyc2NvcmVkID0gcGFyYW1ldGVyLnJlcGxhY2UoLyhbYS16XVtBLVpdKS9nLCBmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG1bMF0gKyAnXycgKyBtWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICBpZiAocGFyYW1ldGVyID09PSB1bmRlcnNjb3JlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoYXNQYXJhbWV0ZXIgPSBjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KHBhcmFtZXRlcik7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkodW5kZXJzY29yZWQpKSB7XG4gICAgICBsb2dnZXIud2Fybih1bmRlcnNjb3JlZCArICcgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAnICsgcGFyYW1ldGVyKTtcbiAgICAgIGlmIChoYXNQYXJhbWV0ZXIpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4ocGFyYW1ldGVyICsgJyBvdmVycmlkaW5nICcgKyB1bmRlcnNjb3JlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdID0gaGFzUGFyYW1ldGVyID8gY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdIDogY29uZmlndXJhdGlvblt1bmRlcnNjb3JlZF07XG4gIH1cblxuICAvLyBDaGVjayBNYW5kYXRvcnkgcGFyYW1ldGVyc1xuICBmb3IocGFyYW1ldGVyIGluIFVBLmNvbmZpZ3VyYXRpb25fY2hlY2subWFuZGF0b3J5KSB7XG4gICAgYWxpYXNVbmRlcnNjb3JlZChwYXJhbWV0ZXIsIHRoaXMubG9nZ2VyKTtcbiAgICBpZighY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdO1xuICAgICAgY2hlY2tlZF92YWx1ZSA9IFVBLmNvbmZpZ3VyYXRpb25fY2hlY2subWFuZGF0b3J5W3BhcmFtZXRlcl0odmFsdWUpO1xuICAgICAgaWYgKGNoZWNrZWRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXR0aW5nc1twYXJhbWV0ZXJdID0gY2hlY2tlZF92YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IocGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgU0lQLlV0aWxzLm9wdGlvbnNPdmVycmlkZShjb25maWd1cmF0aW9uLCAncmVsMTAwJywgJ3JlbGlhYmxlJywgdHJ1ZSwgdGhpcy5sb2dnZXIsIFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRCk7XG5cbiAgdmFyIGVtcHR5QXJyYXlzQWxsb3dlZCA9IFsnc3R1blNlcnZlcnMnLCAndHVyblNlcnZlcnMnXTtcblxuICAvLyBDaGVjayBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gIGZvcihwYXJhbWV0ZXIgaW4gVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbCkge1xuICAgIGFsaWFzVW5kZXJzY29yZWQocGFyYW1ldGVyLCB0aGlzLmxvZ2dlcik7XG4gICAgaWYoY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICB2YWx1ZSA9IGNvbmZpZ3VyYXRpb25bcGFyYW1ldGVyXTtcblxuICAgICAgLy8gSWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSwgYnV0IHNob3VsZG4ndCBiZSwgYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSAmJiB2YWx1ZS5sZW5ndGggPT09IDAgJiYgZW1wdHlBcnJheXNBbGxvd2VkLmluZGV4T2YocGFyYW1ldGVyKSA8IDApIHsgY29udGludWU7IH1cblxuICAgICAgLy8gSWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBudWxsLCBlbXB0eSBzdHJpbmcsIG9yIHVuZGVmaW5lZCB0aGVuIGFwcGx5IGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgaWYodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgeyBjb250aW51ZTsgfVxuICAgICAgLy8gSWYgaXQncyBhIG51bWJlciB3aXRoIE5hTiB2YWx1ZSB0aGVuIGFsc28gYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICAvLyBOT1RFOiBKUyBkb2VzIG5vdCBhbGxvdyBcInZhbHVlID09PSBOYU5cIiwgdGhlIGZvbGxvd2luZyBkb2VzIHRoZSB3b3JrOlxuICAgICAgZWxzZSBpZih0eXBlb2YodmFsdWUpID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHsgY29udGludWU7IH1cblxuICAgICAgY2hlY2tlZF92YWx1ZSA9IFVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbcGFyYW1ldGVyXSh2YWx1ZSk7XG4gICAgICBpZiAoY2hlY2tlZF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldHRpbmdzW3BhcmFtZXRlcl0gPSBjaGVja2VkX3ZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcihwYXJhbWV0ZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTYW5pdHkgQ2hlY2tzXG5cbiAgLy8gQ29ubmVjdGlvbiByZWNvdmVyeSBpbnRlcnZhbHNcbiAgaWYoc2V0dGluZ3MuY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWwgPCBzZXR0aW5ncy5jb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbCkge1xuICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IoJ2Nvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsJywgc2V0dGluZ3MuY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWwpO1xuICB9XG5cbiAgLy8gUG9zdCBDb25maWd1cmF0aW9uIFByb2Nlc3NcblxuICAvLyBBbGxvdyBwYXNzaW5nIDAgbnVtYmVyIGFzIGRpc3BsYXlOYW1lLlxuICBpZiAoc2V0dGluZ3MuZGlzcGxheU5hbWUgPT09IDApIHtcbiAgICBzZXR0aW5ncy5kaXNwbGF5TmFtZSA9ICcwJztcbiAgfVxuXG4gIC8vIEluc3RhbmNlLWlkIGZvciBHUlVVXG4gIGlmICghc2V0dGluZ3MuaW5zdGFuY2VJZCkge1xuICAgIHNldHRpbmdzLmluc3RhbmNlSWQgPSBTSVAuVXRpbHMubmV3VVVJRCgpO1xuICB9XG5cbiAgLy8gc2lwanNJZCBpbnN0YW5jZSBwYXJhbWV0ZXIuIFN0YXRpYyByYW5kb20gdGFnIG9mIGxlbmd0aCA1XG4gIHNldHRpbmdzLnNpcGpzSWQgPSBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oNSk7XG5cbiAgLy8gU3RyaW5nIGNvbnRhaW5pbmcgc2V0dGluZ3MudXJpIHdpdGhvdXQgc2NoZW1lIGFuZCB1c2VyLlxuICBob3N0cG9ydFBhcmFtcyA9IHNldHRpbmdzLnVyaS5jbG9uZSgpO1xuICBob3N0cG9ydFBhcmFtcy51c2VyID0gbnVsbDtcbiAgc2V0dGluZ3MuaG9zdHBvcnRQYXJhbXMgPSBob3N0cG9ydFBhcmFtcy50b1JhdygpLnJlcGxhY2UoL15zaXA6L2ksICcnKTtcblxuICAvKiBDaGVjayB3aGV0aGVyIGF1dGhvcml6YXRpb25Vc2VyIGlzIGV4cGxpY2l0bHkgZGVmaW5lZC5cbiAgICogVGFrZSAnc2V0dGluZ3MudXJpLnVzZXInIHZhbHVlIGlmIG5vdC5cbiAgICovXG4gIGlmICghc2V0dGluZ3MuYXV0aG9yaXphdGlvblVzZXIpIHtcbiAgICBzZXR0aW5ncy5hdXRob3JpemF0aW9uVXNlciA9IHNldHRpbmdzLnVyaS51c2VyO1xuICB9XG5cbiAgLyogSWYgbm8gJ3JlZ2lzdHJhclNlcnZlcicgaXMgc2V0IHVzZSB0aGUgJ3VyaScgdmFsdWUgd2l0aG91dCB1c2VyIHBvcnRpb24uICovXG4gIGlmICghc2V0dGluZ3MucmVnaXN0cmFyU2VydmVyKSB7XG4gICAgcmVnaXN0cmFyU2VydmVyID0gc2V0dGluZ3MudXJpLmNsb25lKCk7XG4gICAgcmVnaXN0cmFyU2VydmVyLnVzZXIgPSBudWxsO1xuICAgIHNldHRpbmdzLnJlZ2lzdHJhclNlcnZlciA9IHJlZ2lzdHJhclNlcnZlcjtcbiAgfVxuXG4gIC8vIFVzZXIgbm9BbnN3ZXJUaW1lb3V0XG4gIHNldHRpbmdzLm5vQW5zd2VyVGltZW91dCA9IHNldHRpbmdzLm5vQW5zd2VyVGltZW91dCAqIDEwMDA7XG5cbiAgLy8gVmlhIEhvc3RcbiAgaWYgKHNldHRpbmdzLmhhY2tJcEluQ29udGFjdCkge1xuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuaGFja0lwSW5Db250YWN0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHNldHRpbmdzLnZpYUhvc3QgPSBTSVAuVXRpbHMuZ2V0UmFuZG9tVGVzdE5ldElQKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzZXR0aW5ncy5oYWNrSXBJbkNvbnRhY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZXR0aW5ncy52aWFIb3N0ID0gc2V0dGluZ3MuaGFja0lwSW5Db250YWN0O1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbnRhY3QgdHJhbnNwb3J0IHBhcmFtZXRlclxuICBpZiAoc2V0dGluZ3MuaGFja1dzc0luVHJhbnNwb3J0KSB7XG4gICAgc2V0dGluZ3MuY29udGFjdFRyYW5zcG9ydCA9ICd3c3MnO1xuICB9XG5cbiAgdGhpcy5jb250YWN0ID0ge1xuICAgIHB1Yl9ncnV1OiBudWxsLFxuICAgIHRlbXBfZ3J1dTogbnVsbCxcbiAgICB1cmk6IG5ldyBTSVAuVVJJKCdzaXAnLCBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oOCksIHNldHRpbmdzLnZpYUhvc3QsIG51bGwsIHt0cmFuc3BvcnQ6IHNldHRpbmdzLmNvbnRhY3RUcmFuc3BvcnR9KSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyXG4gICAgICAgIGFub255bW91cyA9IG9wdGlvbnMuYW5vbnltb3VzIHx8IG51bGwsXG4gICAgICAgIG91dGJvdW5kID0gb3B0aW9ucy5vdXRib3VuZCB8fCBudWxsLFxuICAgICAgICBjb250YWN0ID0gJzwnO1xuXG4gICAgICBpZiAoYW5vbnltb3VzKSB7XG4gICAgICAgIGNvbnRhY3QgKz0gKHRoaXMudGVtcF9ncnV1IHx8ICgnc2lwOmFub255bW91c0Bhbm9ueW1vdXMuaW52YWxpZDt0cmFuc3BvcnQ9JytzZXR0aW5ncy5jb250YWN0VHJhbnNwb3J0KSkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhY3QgKz0gKHRoaXMucHViX2dydXUgfHwgdGhpcy51cmkpLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdXRib3VuZCkge1xuICAgICAgICBjb250YWN0ICs9ICc7b2InO1xuICAgICAgfVxuXG4gICAgICBjb250YWN0ICs9ICc+JztcblxuICAgICAgcmV0dXJuIGNvbnRhY3Q7XG4gICAgfVxuICB9O1xuXG4gIC8vIG1lZGlhIG92ZXJyaWRlcyBtZWRpYUNvbnN0cmFpbnRzXG4gIFNJUC5VdGlscy5vcHRpb25zT3ZlcnJpZGUoc2V0dGluZ3MsICdtZWRpYScsICdtZWRpYUNvbnN0cmFpbnRzJywgdHJ1ZSwgdGhpcy5sb2dnZXIpO1xuXG4gIC8vIEZpbGwgdGhlIHZhbHVlIG9mIHRoZSBjb25maWd1cmF0aW9uX3NrZWxldG9uXG4gIGZvcihwYXJhbWV0ZXIgaW4gc2V0dGluZ3MpIHtcbiAgICBVQS5jb25maWd1cmF0aW9uX3NrZWxldG9uW3BhcmFtZXRlcl0udmFsdWUgPSBzZXR0aW5nc1twYXJhbWV0ZXJdO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5jb25maWd1cmF0aW9uLCBVQS5jb25maWd1cmF0aW9uX3NrZWxldG9uKTtcblxuICAvLyBDbGVhbiBVQS5jb25maWd1cmF0aW9uX3NrZWxldG9uXG4gIGZvcihwYXJhbWV0ZXIgaW4gc2V0dGluZ3MpIHtcbiAgICBVQS5jb25maWd1cmF0aW9uX3NrZWxldG9uW3BhcmFtZXRlcl0udmFsdWUgPSAnJztcbiAgfVxuXG4gIHRoaXMubG9nZ2VyLmxvZygnY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGFmdGVyIHZhbGlkYXRpb246Jyk7XG4gIGZvcihwYXJhbWV0ZXIgaW4gc2V0dGluZ3MpIHtcbiAgICBzd2l0Y2gocGFyYW1ldGVyKSB7XG4gICAgICBjYXNlICd1cmknOlxuICAgICAgY2FzZSAncmVnaXN0cmFyU2VydmVyJzpcbiAgICAgIGNhc2UgJ21lZGlhSGFuZGxlckZhY3RvcnknOlxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ8K3ICcgKyBwYXJhbWV0ZXIgKyAnOiAnICsgc2V0dGluZ3NbcGFyYW1ldGVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGFzc3dvcmQnOlxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ8K3ICcgKyBwYXJhbWV0ZXIgKyAnOiAnICsgJ05PVCBTSE9XTicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnwrcgJyArIHBhcmFtZXRlciArICc6ICcgKyBKU09OLnN0cmluZ2lmeShzZXR0aW5nc1twYXJhbWV0ZXJdKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIE9iamVjdCBza2VsZXRvbi5cbiAqIEBwcml2YXRlXG4gKi9cblVBLmNvbmZpZ3VyYXRpb25fc2tlbGV0b24gPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBpZHgsICBwYXJhbWV0ZXIsXG4gICAgc2tlbGV0b24gPSB7fSxcbiAgICBwYXJhbWV0ZXJzID0gW1xuICAgICAgLy8gSW50ZXJuYWwgcGFyYW1ldGVyc1xuICAgICAgXCJzaXBqc0lkXCIsXG4gICAgICBcImhvc3Rwb3J0UGFyYW1zXCIsXG5cbiAgICAgIC8vIE9wdGlvbmFsIHVzZXIgY29uZmlndXJhYmxlIHBhcmFtZXRlcnNcbiAgICAgIFwidXJpXCIsXG4gICAgICBcIndzU2VydmVyc1wiLFxuICAgICAgXCJhdXRob3JpemF0aW9uVXNlclwiLFxuICAgICAgXCJjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbFwiLFxuICAgICAgXCJjb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbFwiLFxuICAgICAgXCJrZWVwQWxpdmVJbnRlcnZhbFwiLFxuICAgICAgXCJleHRyYVN1cHBvcnRlZFwiLFxuICAgICAgXCJkaXNwbGF5TmFtZVwiLFxuICAgICAgXCJoYWNrVmlhVGNwXCIsIC8vIGZhbHNlLlxuICAgICAgXCJoYWNrSXBJbkNvbnRhY3RcIiwgLy9mYWxzZVxuICAgICAgXCJoYWNrV3NzSW5UcmFuc3BvcnRcIiwgLy9mYWxzZVxuICAgICAgXCJoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzXCIsIC8vZmFsc2VcbiAgICAgIFwiY29udGFjdFRyYW5zcG9ydFwiLCAvLyAnd3MnXG4gICAgICBcImZvcmNlUnBvcnRcIiwgLy8gZmFsc2VcbiAgICAgIFwiaWNlQ2hlY2tpbmdUaW1lb3V0XCIsXG4gICAgICBcImluc3RhbmNlSWRcIixcbiAgICAgIFwibm9BbnN3ZXJUaW1lb3V0XCIsIC8vIDMwIHNlY29uZHMuXG4gICAgICBcInBhc3N3b3JkXCIsXG4gICAgICBcInJlZ2lzdGVyRXhwaXJlc1wiLCAvLyA2MDAgc2Vjb25kcy5cbiAgICAgIFwicmVnaXN0cmFyU2VydmVyXCIsXG4gICAgICBcInJlbGlhYmxlXCIsXG4gICAgICBcInJlbDEwMFwiLFxuICAgICAgXCJyZXBsYWNlc1wiLFxuICAgICAgXCJ1c2VyQWdlbnRTdHJpbmdcIiwgLy9TSVAuQy5VU0VSX0FHRU5UXG4gICAgICBcImF1dG9zdGFydFwiLFxuICAgICAgXCJzdHVuU2VydmVyc1wiLFxuICAgICAgXCJ0cmFjZVNpcFwiLFxuICAgICAgXCJ0dXJuU2VydmVyc1wiLFxuICAgICAgXCJ1c2VQcmVsb2FkZWRSb3V0ZVwiLFxuICAgICAgXCJ3c1NlcnZlck1heFJlY29ubmVjdGlvblwiLFxuICAgICAgXCJ3c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXRcIixcbiAgICAgIFwibWVkaWFIYW5kbGVyRmFjdG9yeVwiLFxuICAgICAgXCJtZWRpYVwiLFxuICAgICAgXCJtZWRpYUNvbnN0cmFpbnRzXCIsXG4gICAgICBcImF1dGhlbnRpY2F0aW9uRmFjdG9yeVwiLFxuXG4gICAgICAvLyBQb3N0LWNvbmZpZ3VyYXRpb24gZ2VuZXJhdGVkIHBhcmFtZXRlcnNcbiAgICAgIFwidmlhX2NvcmVfdmFsdWVcIixcbiAgICAgIFwidmlhSG9zdFwiXG4gICAgXTtcblxuICBmb3IoaWR4IGluIHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzW2lkeF07XG4gICAgc2tlbGV0b25bcGFyYW1ldGVyXSA9IHtcbiAgICAgIHZhbHVlOiAnJyxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgc2tlbGV0b25bJ3JlZ2lzdGVyJ10gPSB7XG4gICAgdmFsdWU6ICcnLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfTtcblxuICByZXR1cm4gc2tlbGV0b247XG59KCkpO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gY2hlY2tlci5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5VQS5jb25maWd1cmF0aW9uX2NoZWNrID0ge1xuICBtYW5kYXRvcnk6IHtcbiAgfSxcblxuICBvcHRpb25hbDoge1xuXG4gICAgdXJpOiBmdW5jdGlvbih1cmkpIHtcbiAgICAgIHZhciBwYXJzZWQ7XG5cbiAgICAgIGlmICghKC9ec2lwOi9pKS50ZXN0KHVyaSkpIHtcbiAgICAgICAgdXJpID0gU0lQLkMuU0lQICsgJzonICsgdXJpO1xuICAgICAgfVxuICAgICAgcGFyc2VkID0gU0lQLlVSSS5wYXJzZSh1cmkpO1xuXG4gICAgICBpZighcGFyc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZighcGFyc2VkLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy9Ob3RlOiB0aGlzIGZ1bmN0aW9uIHVzZWQgdG8gY2FsbCAndGhpcy5sb2dnZXIuZXJyb3InIGJ1dCBjYWxsaW5nICd0aGlzJyB3aXRoIGFueXRoaW5nIGhlcmUgaXMgaW52YWxpZFxuICAgIHdzU2VydmVyczogZnVuY3Rpb24od3NTZXJ2ZXJzKSB7XG4gICAgICB2YXIgaWR4LCBsZW5ndGgsIHVybDtcblxuICAgICAgLyogQWxsb3cgZGVmaW5pbmcgd3NTZXJ2ZXJzIHBhcmFtZXRlciBhczpcbiAgICAgICAqICBTdHJpbmc6IFwiaG9zdFwiXG4gICAgICAgKiAgQXJyYXkgb2YgU3RyaW5nczogW1wiaG9zdDFcIiwgXCJob3N0MlwiXVxuICAgICAgICogIEFycmF5IG9mIE9iamVjdHM6IFt7d3NfdXJpOlwiaG9zdDFcIiwgd2VpZ2h0OjF9LCB7d3NfdXJpOlwiaG9zdDJcIiwgd2VpZ2h0OjB9XVxuICAgICAgICogIEFycmF5IG9mIE9iamVjdHMgYW5kIFN0cmluZ3M6IFt7d3NfdXJpOlwiaG9zdDFcIn0sIFwiaG9zdDJcIl1cbiAgICAgICAqL1xuICAgICAgaWYgKHR5cGVvZiB3c1NlcnZlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHdzU2VydmVycyA9IFt7d3NfdXJpOiB3c1NlcnZlcnN9XTtcbiAgICAgIH0gZWxzZSBpZiAod3NTZXJ2ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgbGVuZ3RoID0gd3NTZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3c1NlcnZlcnNbaWR4XSA9PT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgd3NTZXJ2ZXJzW2lkeF0gPSB7d3NfdXJpOiB3c1NlcnZlcnNbaWR4XX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh3c1NlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoID0gd3NTZXJ2ZXJzLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAoIXdzU2VydmVyc1tpZHhdLndzX3VyaSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3NTZXJ2ZXJzW2lkeF0ud2VpZ2h0ICYmICFOdW1iZXIod3NTZXJ2ZXJzW2lkeF0ud2VpZ2h0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybCA9IFNJUC5HcmFtbWFyLnBhcnNlKHdzU2VydmVyc1tpZHhdLndzX3VyaSwgJ2Fic29sdXRlVVJJJyk7XG5cbiAgICAgICAgaWYodXJsID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmKFsnd3NzJywgJ3dzJywgJ3VkcCddLmluZGV4T2YodXJsLnNjaGVtZSkgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdzU2VydmVyc1tpZHhdLnNpcF91cmkgPSAnPHNpcDonICsgdXJsLmhvc3QgKyAodXJsLnBvcnQgPyAnOicgKyB1cmwucG9ydCA6ICcnKSArICc7dHJhbnNwb3J0PScgKyB1cmwuc2NoZW1lLnJlcGxhY2UoL153c3MkL2ksICd3cycpICsgJztscj4nO1xuXG4gICAgICAgICAgaWYgKCF3c1NlcnZlcnNbaWR4XS53ZWlnaHQpIHtcbiAgICAgICAgICAgIHdzU2VydmVyc1tpZHhdLndlaWdodCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd3NTZXJ2ZXJzW2lkeF0uc3RhdHVzID0gMDtcbiAgICAgICAgICB3c1NlcnZlcnNbaWR4XS5zY2hlbWUgPSB1cmwuc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB3c1NlcnZlcnM7XG4gICAgfSxcblxuICAgIGF1dGhvcml6YXRpb25Vc2VyOiBmdW5jdGlvbihhdXRob3JpemF0aW9uVXNlcikge1xuICAgICAgaWYoU0lQLkdyYW1tYXIucGFyc2UoJ1wiJysgYXV0aG9yaXphdGlvblVzZXIgKydcIicsICdxdW90ZWRfc3RyaW5nJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhdXRob3JpemF0aW9uVXNlcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWw6IGZ1bmN0aW9uKGNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZihTSVAuVXRpbHMuaXNEZWNpbWFsKGNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsKSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcihjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCk7XG4gICAgICAgIGlmKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbDogZnVuY3Rpb24oY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmKFNJUC5VdGlscy5pc0RlY2ltYWwoY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWwpKSB7XG4gICAgICAgIHZhbHVlID0gTnVtYmVyKGNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsKTtcbiAgICAgICAgaWYodmFsdWUgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRpc3BsYXlOYW1lOiBmdW5jdGlvbihkaXNwbGF5TmFtZSkge1xuICAgICAgaWYoU0lQLkdyYW1tYXIucGFyc2UoJ1wiJyArIGRpc3BsYXlOYW1lICsgJ1wiJywgJ2Rpc3BsYXlOYW1lJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFja1ZpYVRjcDogZnVuY3Rpb24oaGFja1ZpYVRjcCkge1xuICAgICAgaWYgKHR5cGVvZiBoYWNrVmlhVGNwID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGhhY2tWaWFUY3A7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhY2tJcEluQ29udGFjdDogZnVuY3Rpb24oaGFja0lwSW5Db250YWN0KSB7XG4gICAgICBpZiAodHlwZW9mIGhhY2tJcEluQ29udGFjdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBoYWNrSXBJbkNvbnRhY3Q7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgaGFja0lwSW5Db250YWN0ID09PSAnc3RyaW5nJyAmJiBTSVAuR3JhbW1hci5wYXJzZShoYWNrSXBJbkNvbnRhY3QsICdob3N0JykgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBoYWNrSXBJbkNvbnRhY3Q7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGljZUNoZWNraW5nVGltZW91dDogZnVuY3Rpb24oaWNlQ2hlY2tpbmdUaW1lb3V0KSB7XG4gICAgICBpZihTSVAuVXRpbHMuaXNEZWNpbWFsKGljZUNoZWNraW5nVGltZW91dCkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDUwMCwgaWNlQ2hlY2tpbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFja1dzc0luVHJhbnNwb3J0OiBmdW5jdGlvbihoYWNrV3NzSW5UcmFuc3BvcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFja1dzc0luVHJhbnNwb3J0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGhhY2tXc3NJblRyYW5zcG9ydDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFnczogZnVuY3Rpb24oaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncykge1xuICAgICAgaWYgKHR5cGVvZiBoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbnRhY3RUcmFuc3BvcnQ6IGZ1bmN0aW9uKGNvbnRhY3RUcmFuc3BvcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29udGFjdFRyYW5zcG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhY3RUcmFuc3BvcnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZvcmNlUnBvcnQ6IGZ1bmN0aW9uKGZvcmNlUnBvcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZm9yY2VScG9ydCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBmb3JjZVJwb3J0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbnN0YW5jZUlkOiBmdW5jdGlvbihpbnN0YW5jZUlkKSB7XG4gICAgICBpZih0eXBlb2YgaW5zdGFuY2VJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoKC9edXVpZDovaS50ZXN0KGluc3RhbmNlSWQpKSkge1xuICAgICAgICBpbnN0YW5jZUlkID0gaW5zdGFuY2VJZC5zdWJzdHIoNSk7XG4gICAgICB9XG5cbiAgICAgIGlmKFNJUC5HcmFtbWFyLnBhcnNlKGluc3RhbmNlSWQsICd1dWlkJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZUlkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBrZWVwQWxpdmVJbnRlcnZhbDogZnVuY3Rpb24oa2VlcEFsaXZlSW50ZXJ2YWwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChTSVAuVXRpbHMuaXNEZWNpbWFsKGtlZXBBbGl2ZUludGVydmFsKSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcihrZWVwQWxpdmVJbnRlcnZhbCk7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZXh0cmFTdXBwb3J0ZWQ6IGZ1bmN0aW9uKG9wdGlvblRhZ3MpIHtcbiAgICAgIHZhciBpZHgsIGxlbmd0aDtcblxuICAgICAgaWYgKCEob3B0aW9uVGFncyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IG9wdGlvblRhZ3MubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uVGFnc1tpZHhdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9uVGFncztcbiAgICB9LFxuXG4gICAgbm9BbnN3ZXJUaW1lb3V0OiBmdW5jdGlvbihub0Fuc3dlclRpbWVvdXQpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChTSVAuVXRpbHMuaXNEZWNpbWFsKG5vQW5zd2VyVGltZW91dCkpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIobm9BbnN3ZXJUaW1lb3V0KTtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXNzd29yZDogZnVuY3Rpb24ocGFzc3dvcmQpIHtcbiAgICAgIHJldHVybiBTdHJpbmcocGFzc3dvcmQpO1xuICAgIH0sXG5cbiAgICByZWwxMDA6IGZ1bmN0aW9uKHJlbDEwMCkge1xuICAgICAgaWYocmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRDtcbiAgICAgIH0gZWxzZSBpZiAocmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgICAgIHJldHVybiBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEO1xuICAgICAgfSBlbHNlICB7XG4gICAgICAgIHJldHVybiBTSVAuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlcGxhY2VzOiBmdW5jdGlvbihyZXBsYWNlcykge1xuICAgICAgaWYocmVwbGFjZXMgPT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgICAgICByZXR1cm4gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEO1xuICAgICAgfSBlbHNlIGlmIChyZXBsYWNlcyA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCkge1xuICAgICAgICByZXR1cm4gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRDtcbiAgICAgIH0gZWxzZSAge1xuICAgICAgICByZXR1cm4gU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZWdpc3RlcjogZnVuY3Rpb24ocmVnaXN0ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVnaXN0ZXIgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyRXhwaXJlczogZnVuY3Rpb24ocmVnaXN0ZXJFeHBpcmVzKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAoU0lQLlV0aWxzLmlzRGVjaW1hbChyZWdpc3RlckV4cGlyZXMpKSB7XG4gICAgICAgIHZhbHVlID0gTnVtYmVyKHJlZ2lzdGVyRXhwaXJlcyk7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVnaXN0cmFyU2VydmVyOiBmdW5jdGlvbihyZWdpc3RyYXJTZXJ2ZXIpIHtcbiAgICAgIHZhciBwYXJzZWQ7XG5cbiAgICAgIGlmKHR5cGVvZiByZWdpc3RyYXJTZXJ2ZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCEvXnNpcDovaS50ZXN0KHJlZ2lzdHJhclNlcnZlcikpIHtcbiAgICAgICAgcmVnaXN0cmFyU2VydmVyID0gU0lQLkMuU0lQICsgJzonICsgcmVnaXN0cmFyU2VydmVyO1xuICAgICAgfVxuICAgICAgcGFyc2VkID0gU0lQLlVSSS5wYXJzZShyZWdpc3RyYXJTZXJ2ZXIpO1xuXG4gICAgICBpZighcGFyc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZihwYXJzZWQudXNlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdHVuU2VydmVyczogZnVuY3Rpb24oc3R1blNlcnZlcnMpIHtcbiAgICAgIHZhciBpZHgsIGxlbmd0aCwgc3R1bl9zZXJ2ZXI7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3R1blNlcnZlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0dW5TZXJ2ZXJzID0gW3N0dW5TZXJ2ZXJzXTtcbiAgICAgIH0gZWxzZSBpZiAoIShzdHVuU2VydmVycyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IHN0dW5TZXJ2ZXJzLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBzdHVuX3NlcnZlciA9IHN0dW5TZXJ2ZXJzW2lkeF07XG4gICAgICAgIGlmICghKC9ec3R1bnM/Oi8udGVzdChzdHVuX3NlcnZlcikpKSB7XG4gICAgICAgICAgc3R1bl9zZXJ2ZXIgPSAnc3R1bjonICsgc3R1bl9zZXJ2ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZihTSVAuR3JhbW1hci5wYXJzZShzdHVuX3NlcnZlciwgJ3N0dW5fVVJJJykgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0dW5TZXJ2ZXJzW2lkeF0gPSBzdHVuX3NlcnZlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0dW5TZXJ2ZXJzO1xuICAgIH0sXG5cbiAgICB0cmFjZVNpcDogZnVuY3Rpb24odHJhY2VTaXApIHtcbiAgICAgIGlmICh0eXBlb2YgdHJhY2VTaXAgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gdHJhY2VTaXA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHR1cm5TZXJ2ZXJzOiBmdW5jdGlvbih0dXJuU2VydmVycykge1xuICAgICAgdmFyIGlkeCwgamR4LCBsZW5ndGgsIHR1cm5fc2VydmVyLCBudW1fdHVybl9zZXJ2ZXJfdXJscywgdXJsO1xuXG4gICAgICBpZiAodHVyblNlcnZlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0dXJuU2VydmVycyA9IFt0dXJuU2VydmVyc107XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IHR1cm5TZXJ2ZXJzLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB0dXJuX3NlcnZlciA9IHR1cm5TZXJ2ZXJzW2lkeF07XG4gICAgICAgIC8vQmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IEFsbG93IGRlZmluaW5nIHRoZSB0dXJuX3NlcnZlciB1cmwgd2l0aCB0aGUgJ3NlcnZlcicgcHJvcGVydHkuXG4gICAgICAgIGlmICh0dXJuX3NlcnZlci5zZXJ2ZXIpIHtcbiAgICAgICAgICB0dXJuX3NlcnZlci51cmxzID0gW3R1cm5fc2VydmVyLnNlcnZlcl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXR1cm5fc2VydmVyLnVybHMgfHwgIXR1cm5fc2VydmVyLnVzZXJuYW1lIHx8ICF0dXJuX3NlcnZlci5wYXNzd29yZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0dXJuX3NlcnZlci51cmxzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBudW1fdHVybl9zZXJ2ZXJfdXJscyA9IHR1cm5fc2VydmVyLnVybHMubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR1cm5fc2VydmVyLnVybHMgPSBbdHVybl9zZXJ2ZXIudXJsc107XG4gICAgICAgICAgbnVtX3R1cm5fc2VydmVyX3VybHMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqZHggPSAwOyBqZHggPCBudW1fdHVybl9zZXJ2ZXJfdXJsczsgamR4KyspIHtcbiAgICAgICAgICB1cmwgPSB0dXJuX3NlcnZlci51cmxzW2pkeF07XG5cbiAgICAgICAgICBpZiAoISgvXnR1cm5zPzovLnRlc3QodXJsKSkpIHtcbiAgICAgICAgICAgIHVybCA9ICd0dXJuOicgKyB1cmw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoU0lQLkdyYW1tYXIucGFyc2UodXJsLCAndHVybl9VUkknKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0dXJuU2VydmVycztcbiAgICB9LFxuXG4gICAgdXNlckFnZW50U3RyaW5nOiBmdW5jdGlvbih1c2VyQWdlbnRTdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2YgdXNlckFnZW50U3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdXNlckFnZW50U3RyaW5nO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1c2VQcmVsb2FkZWRSb3V0ZTogZnVuY3Rpb24odXNlUHJlbG9hZGVkUm91dGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdXNlUHJlbG9hZGVkUm91dGUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gdXNlUHJlbG9hZGVkUm91dGU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHdzU2VydmVyTWF4UmVjb25uZWN0aW9uOiBmdW5jdGlvbih3c1NlcnZlck1heFJlY29ubmVjdGlvbikge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKFNJUC5VdGlscy5pc0RlY2ltYWwod3NTZXJ2ZXJNYXhSZWNvbm5lY3Rpb24pKSB7XG4gICAgICAgIHZhbHVlID0gTnVtYmVyKHdzU2VydmVyTWF4UmVjb25uZWN0aW9uKTtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB3c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXQ6IGZ1bmN0aW9uKHdzU2VydmVyUmVjb25uZWN0aW9uVGltZW91dCkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKFNJUC5VdGlscy5pc0RlY2ltYWwod3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0KSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcih3c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGF1dG9zdGFydDogZnVuY3Rpb24oYXV0b3N0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGF1dG9zdGFydCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBhdXRvc3RhcnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG1lZGlhSGFuZGxlckZhY3Rvcnk6IGZ1bmN0aW9uKG1lZGlhSGFuZGxlckZhY3RvcnkpIHtcbiAgICAgIGlmIChtZWRpYUhhbmRsZXJGYWN0b3J5IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHByb21pc2lmaWVkRmFjdG9yeSA9IGZ1bmN0aW9uIHByb21pc2lmaWVkRmFjdG9yeSAoKSB7XG4gICAgICAgICAgdmFyIG1lZGlhSGFuZGxlciA9IG1lZGlhSGFuZGxlckZhY3RvcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHBhdGNoTWV0aG9kIChtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gbWVkaWFIYW5kbGVyW21ldGhvZE5hbWVdO1xuICAgICAgICAgICAgaWYgKG1ldGhvZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHZhciBjYWxsYmFja3NGaXJzdCA9IG1ldGhvZE5hbWUgPT09ICdnZXREZXNjcmlwdGlvbic7XG4gICAgICAgICAgICAgIG1lZGlhSGFuZGxlclttZXRob2ROYW1lXSA9IFNJUC5VdGlscy5wcm9taXNpZnkobWVkaWFIYW5kbGVyLCBtZXRob2ROYW1lLCBjYWxsYmFja3NGaXJzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0Y2hNZXRob2QoJ2dldERlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgcGF0Y2hNZXRob2QoJ3NldERlc2NyaXB0aW9uJyk7XG5cbiAgICAgICAgICByZXR1cm4gbWVkaWFIYW5kbGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHByb21pc2lmaWVkRmFjdG9yeS5pc1N1cHBvcnRlZCA9IG1lZGlhSGFuZGxlckZhY3RvcnkuaXNTdXBwb3J0ZWQ7XG4gICAgICAgIHJldHVybiBwcm9taXNpZmllZEZhY3Rvcnk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGF1dGhlbnRpY2F0aW9uRmFjdG9yeTogY2hlY2tBdXRoZW50aWNhdGlvbkZhY3RvcnlcbiAgfVxufTtcblxuVUEuQyA9IEM7XG5TSVAuVUEgPSBVQTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1VBLmpzXG4gKiogbW9kdWxlIGlkID0gMjM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBIYWNrcyAtIFRoaXMgZmlsZSBjb250YWlucyBhbGwgb2YgdGhlIHRoaW5ncyB3ZVxuICogd2lzaCB3ZSBkaWRuJ3QgaGF2ZSB0byBkbywganVzdCBmb3IgaW50ZXJvcC4gIEl0IGlzIHNpbWlsYXIgdG9cbiAqIFV0aWxzLCB3aGljaCBwcm92aWRlcyBhY3R1YWxseSB1c2VmdWwgYW5kIHJlbGV2YW50IGZ1bmN0aW9ucyBmb3JcbiAqIGEgU0lQIGxpYnJhcnkuIE1ldGhvZHMgaW4gdGhpcyBmaWxlIGFyZSBncm91cGVkIGJ5IHZlbmRvciwgc29cbiAqIGFzIHRvIG1vc3QgZWFzaWx5IHRyYWNrIHdoZW4gcGFydGljdWxhciBoYWNrcyBtYXkgbm90IGJlIG5lY2Vzc2FyeSBhbnltb3JlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuXG4vL2tlZXAgdG8gcXVpZXQganNoaW50LCBhbmQgcmVtYWluIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBmaWxlc1xuU0lQID0gU0lQO1xuXG52YXIgSGFja3MgPSB7XG4gIEFsbEJyb3dzZXJzOiB7XG4gICAgbWFza0R0bHM6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAobWVzc2FnZS5ib2R5KSB7XG4gICAgICAgIG1lc3NhZ2UuYm9keSA9IG1lc3NhZ2UuYm9keS5yZXBsYWNlKC8gVURQXFwvVExTXFwvUlRQXFwvU0FWUC9nbWksIFwiIFJUUC9TQVZQXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdW5tYXNrRHRsczogZnVuY3Rpb24gKHNkcCkge1xuICAgICAgLyoqXG4gICAgICAgKiBDaHJvbWUgZG9lcyBub3QgaGFuZGxlIERUTFMgY29ycmVjdGx5IChDYW5hcmF5IGRvZXMsIGJ1dCBub3QgcHJvZHVjdGlvbilcbiAgICAgICAqIGtlZXBpbmcgQ2hyb21lIGFzIFNERVMgdW50aWwgRFRMUyBpcyBmaXhlZCAoY29tbWVudCBvdXQgJ2lzX29wZXJhJyBjb25kaXRpb24pXG4gICAgICAgKlxuICAgICAgICogVVBEQVRFOiBNYXkgMjEsIDIwMTRcbiAgICAgICAqIENocm9tZSAzNSBub3cgcHJvcGVybHkgZGVmYXVsdHMgdG8gRFRMUy4gIE9ubHkgT3BlcmEgcmVtYWlucyB1c2luZyBTREVTXG4gICAgICAgKlxuICAgICAgICogVVBEQVRFOiAyMDE0LTA5LTI0XG4gICAgICAgKiBPcGVyYSBub3cgc3VwcG9ydHMgRFRMUyBieSBkZWZhdWx0IGFzIHdlbGwuXG4gICAgICAgKlxuICAgICAgICoqL1xuICAgICAgcmV0dXJuIHNkcC5yZXBsYWNlKC8gUlRQXFwvU0FWUC9nbWksIFwiIFVEUC9UTFMvUlRQL1NBVlBcIik7XG4gICAgfVxuICB9LFxuICBGaXJlZm94OiB7XG4gICAgLyogQ29uZGl0aW9uIHRvIGRldGVjdCBpZiBoYWNrcyBhcmUgYXBwbGljYWJsZSAqL1xuICAgIGlzRmlyZWZveDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBtb3pSVENQZWVyQ29ubmVjdGlvbiAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfSxcblxuICAgIGNhbm5vdEhhbmRsZUV4dHJhV2hpdGVzcGFjZTogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0aGlzLmlzRmlyZWZveCgpICYmIG1lc3NhZ2UuYm9keSkge1xuICAgICAgICBtZXNzYWdlLmJvZHkgPSBtZXNzYWdlLmJvZHkucmVwbGFjZSgvIFxcclxcbi9nLCBcIlxcclxcblwiKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFzTWlzc2luZ0NMaW5lSW5TRFA6IGZ1bmN0aW9uIChzZHApIHtcbiAgICAgIC8qXG4gICAgICAgKiBUaGlzIGlzIGEgRmlyZWZveCBoYWNrIHRvIGluc2VydCB2YWxpZCBzZHAgd2hlbiBnZXREZXNjcmlwdGlvbiBpc1xuICAgICAgICogY2FsbGVkIHdpdGggdGhlIGNvbnN0cmFpbnQgb2ZmZXJUb1JlY2VpdmVWaWRlbyA9IGZhbHNlLlxuICAgICAgICogV2Ugc2VhcmNoIGZvciBlaXRoZXIgYSBjLWxpbmUgYXQgdGhlIHRvcCBvZiB0aGUgc2RwIGFib3ZlIGFsbFxuICAgICAgICogbS1saW5lcy4gSWYgdGhhdCBkb2VzIG5vdCBleGlzdCB0aGVuIHdlIHNlYXJjaCBmb3IgYSBjLWxpbmVcbiAgICAgICAqIGJlbmVhdGggZWFjaCBtLWxpbmUuIElmIGl0IGlzIG1pc3NpbmcgYSBjLWxpbmUsIHdlIGluc2VydFxuICAgICAgICogYSBmYWtlIGMtbGluZSB3aXRoIHRoZSBpcCBhZGRyZXNzIDAuMC4wLjAuIFRoaXMgaXMgdGhlbiB2YWxpZFxuICAgICAgICogc2RwIGFuZCBubyBtZWRpYSB3aWxsIGJlIHNlbnQgZm9yIHRoYXQgbS1saW5lLlxuICAgICAgICpcbiAgICAgICAqIFZhbGlkIFNEUCBpczpcbiAgICAgICAqIG09XG4gICAgICAgKiBpPVxuICAgICAgICogYz1cbiAgICAgICAqL1xuICAgICAgdmFyIGluc2VydEF0LCBtbGluZXM7XG4gICAgICBpZiAoc2RwLmluZGV4T2YoJ2M9JykgPiBzZHAuaW5kZXhPZignbT0nKSkge1xuXG4gICAgICAgIC8vIEZpbmQgYWxsIG09IGxpbmVzXG4gICAgICAgIG1saW5lcyA9IHNkcC5tYXRjaCgvbT0uKlxcclxcbi4qL2cpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8bWxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAvLyBJZiBpdCBoYXMgYW4gaT0gbGluZSwgY2hlY2sgaWYgdGhlIG5leHQgbGluZSBpcyB0aGUgYz0gbGluZVxuICAgICAgICAgIGlmIChtbGluZXNbaV0udG9TdHJpbmcoKS5zZWFyY2goL2k9LiovKSA+PSAwKSB7XG4gICAgICAgICAgICBpbnNlcnRBdCA9IHNkcC5pbmRleE9mKG1saW5lc1tpXS50b1N0cmluZygpKSttbGluZXNbaV0udG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc2RwLnN1YnN0cihpbnNlcnRBdCwyKSE9PSdjPScpIHtcbiAgICAgICAgICAgICAgc2RwID0gc2RwLnN1YnN0cigwLGluc2VydEF0KSArICdcXHJcXG5jPUlOIElQNCAwLjAuMC4wJyArIHNkcC5zdWJzdHIoaW5zZXJ0QXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZWxzZSBhZGQgdGhlIEMgbGluZSBpZiBpdCdzIG1pc3NpbmdcbiAgICAgICAgICB9IGVsc2UgaWYgKG1saW5lc1tpXS50b1N0cmluZygpLnNlYXJjaCgvYz0uKi8pIDwgMCkge1xuICAgICAgICAgICAgaW5zZXJ0QXQgPSBzZHAuaW5kZXhPZihtbGluZXNbaV0udG9TdHJpbmcoKS5tYXRjaCgvLiovKSkrbWxpbmVzW2ldLnRvU3RyaW5nKCkubWF0Y2goLy4qLykudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICBzZHAgPSBzZHAuc3Vic3RyKDAsaW5zZXJ0QXQpICsgJ1xcclxcbmM9SU4gSVA0IDAuMC4wLjAnICsgc2RwLnN1YnN0cihpbnNlcnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2RwO1xuICAgIH0sXG4gIH0sXG5cbiAgQ2hyb21lOiB7XG4gICAgbmVlZHNFeHBsaWNpdGx5SW5hY3RpdmVTRFA6IGZ1bmN0aW9uIChzZHApIHtcbiAgICAgIHZhciBzdWIsIGluZGV4O1xuXG4gICAgICBpZiAoSGFja3MuRmlyZWZveC5pc0ZpcmVmb3goKSkgeyAvLyBGaXggdGhpcyBpbiBGaXJlZm94IGJlZm9yZSBzZW5kaW5nXG4gICAgICAgIGluZGV4ID0gc2RwLmluZGV4T2YoJ209dmlkZW8gMCcpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgc3ViID0gc2RwLnN1YnN0cihpbmRleCk7XG4gICAgICAgICAgc3ViID0gc3ViLnJlcGxhY2UoL1xcclxcbmM9SU4gSVA0LipcXHJcXG4kLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxyXFxuYz1JTiBJUDQgMC4wLjAuMFxcclxcbmE9aW5hY3RpdmVcXHJcXG4nKTtcbiAgICAgICAgICByZXR1cm4gc2RwLnN1YnN0cigwLCBpbmRleCkgKyBzdWI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZHA7XG4gICAgfSxcblxuICAgIGdldHNDb25mdXNlZEFib3V0R1VNOiBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgaWYgKHNlc3Npb24ubWVkaWFIYW5kbGVyKSB7XG4gICAgICAgIHNlc3Npb24ubWVkaWFIYW5kbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xucmV0dXJuIEhhY2tzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0hhY2tzLmpzXG4gKiogbW9kdWxlIGlkID0gMjQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBJbmNvbWluZyBTSVAgTWVzc2FnZSBTYW5pdHkgQ2hlY2tcbiAqL1xuXG4vKipcbiAqIFNJUCBtZXNzYWdlIHNhbml0eSBjaGVjay5cbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTSVAuSW5jb21pbmdNZXNzYWdlfSBtZXNzYWdlXG4gKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgc2FuaXR5Q2hlY2ssXG4gbG9nZ2VyLFxuIG1lc3NhZ2UsIHVhLCB0cmFuc3BvcnQsXG4gcmVxdWVzdHMgPSBbXSxcbiByZXNwb25zZXMgPSBbXSxcbiBhbGwgPSBbXTtcblxuLy8gUmVwbHlcbmZ1bmN0aW9uIHJlcGx5KHN0YXR1c19jb2RlKSB7XG4gIHZhciB0byxcbiAgICByZXNwb25zZSA9IFNJUC5VdGlscy5idWlsZFN0YXR1c0xpbmUoc3RhdHVzX2NvZGUpLFxuICAgIHZpYXMgPSBtZXNzYWdlLmdldEhlYWRlcnMoJ3ZpYScpLFxuICAgIGxlbmd0aCA9IHZpYXMubGVuZ3RoLFxuICAgIGlkeCA9IDA7XG5cbiAgZm9yKGlkeDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgIHJlc3BvbnNlICs9IFwiVmlhOiBcIiArIHZpYXNbaWR4XSArIFwiXFxyXFxuXCI7XG4gIH1cblxuICB0byA9IG1lc3NhZ2UuZ2V0SGVhZGVyKCdUbycpO1xuXG4gIGlmKCFtZXNzYWdlLnRvX3RhZykge1xuICAgIHRvICs9ICc7dGFnPScgKyBTSVAuVXRpbHMubmV3VGFnKCk7XG4gIH1cblxuICByZXNwb25zZSArPSBcIlRvOiBcIiArIHRvICsgXCJcXHJcXG5cIjtcbiAgcmVzcG9uc2UgKz0gXCJGcm9tOiBcIiArIG1lc3NhZ2UuZ2V0SGVhZGVyKCdGcm9tJykgKyBcIlxcclxcblwiO1xuICByZXNwb25zZSArPSBcIkNhbGwtSUQ6IFwiICsgbWVzc2FnZS5jYWxsX2lkICsgXCJcXHJcXG5cIjtcbiAgcmVzcG9uc2UgKz0gXCJDU2VxOiBcIiArIG1lc3NhZ2UuY3NlcSArIFwiIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIlxcclxcblwiO1xuICByZXNwb25zZSArPSBcIlxcclxcblwiO1xuXG4gIHRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKTtcbn1cblxuLypcbiAqIFNhbml0eSBDaGVjayBmb3IgaW5jb21pbmcgTWVzc2FnZXNcbiAqXG4gKiBSZXF1ZXN0czpcbiAqICAtIF9yZmMzMjYxXzhfMl8yXzFfIFJlY2VpdmUgYSBSZXF1ZXN0IHdpdGggYSBub24gc3VwcG9ydGVkIFVSSSBzY2hlbWVcbiAqICAtIF9yZmMzMjYxXzE2XzNfNF8gUmVjZWl2ZSBhIFJlcXVlc3QgYWxyZWFkeSBzZW50IGJ5IHVzXG4gKiAgIERvZXMgbm90IGxvb2sgYXQgdmlhIHNlbnQtYnkgYnV0IGF0IHNpcGpzSWQsIHdoaWNoIGlzIGluc2VydGVkIGFzXG4gKiAgIGEgcHJlZml4IGluIGFsbCBpbml0aWFsIHJlcXVlc3RzIGdlbmVyYXRlZCBieSB0aGUgdWFcbiAqICAtIF9yZmMzMjYxXzE4XzNfcmVxdWVzdF8gQm9keSBDb250ZW50LUxlbmd0aFxuICogIC0gX3JmYzMyNjFfOF8yXzJfMl8gTWVyZ2VkIFJlcXVlc3RzXG4gKlxuICogUmVzcG9uc2VzOlxuICogIC0gX3JmYzMyNjFfOF8xXzNfM18gTXVsdGlwbGUgVmlhIGhlYWRlcnNcbiAqICAtIF9yZmMzMjYxXzE4XzFfMl8gc2VudC1ieSBtaXNtYXRjaFxuICogIC0gX3JmYzMyNjFfMThfM19yZXNwb25zZV8gQm9keSBDb250ZW50LUxlbmd0aFxuICpcbiAqIEFsbDpcbiAqICAtIE1pbmltdW0gaGVhZGVycyBpbiBhIFNJUCBtZXNzYWdlXG4gKi9cblxuLy8gU2FuaXR5IENoZWNrIGZ1bmN0aW9ucyBmb3IgcmVxdWVzdHNcbmZ1bmN0aW9uIHJmYzMyNjFfOF8yXzJfMSgpIHtcbiAgaWYoIW1lc3NhZ2UucnVyaSB8fCBtZXNzYWdlLnJ1cmkuc2NoZW1lICE9PSAnc2lwJykge1xuICAgIHJlcGx5KDQxNik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJmYzMyNjFfMTZfM180KCkge1xuICBpZighbWVzc2FnZS50b190YWcpIHtcbiAgICBpZihtZXNzYWdlLmNhbGxfaWQuc3Vic3RyKDAsIDUpID09PSB1YS5jb25maWd1cmF0aW9uLnNpcGpzSWQpIHtcbiAgICAgIHJlcGx5KDQ4Mik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJmYzMyNjFfMThfM19yZXF1ZXN0KCkge1xuICB2YXIgbGVuID0gU0lQLlV0aWxzLnN0cl91dGY4X2xlbmd0aChtZXNzYWdlLmJvZHkpLFxuICBjb250ZW50TGVuZ3RoID0gbWVzc2FnZS5nZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cbiAgaWYobGVuIDwgY29udGVudExlbmd0aCkge1xuICAgIHJlcGx5KDQwMCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJmYzMyNjFfOF8yXzJfMigpIHtcbiAgdmFyIHRyLCBpZHgsXG4gICAgZnJvbVRhZyA9IG1lc3NhZ2UuZnJvbV90YWcsXG4gICAgY2FsbF9pZCA9IG1lc3NhZ2UuY2FsbF9pZCxcbiAgICBjc2VxID0gbWVzc2FnZS5jc2VxO1xuXG4gIGlmKCFtZXNzYWdlLnRvX3RhZykge1xuICAgIGlmKG1lc3NhZ2UubWV0aG9kID09PSBTSVAuQy5JTlZJVEUpIHtcbiAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLmlzdFttZXNzYWdlLnZpYV9icmFuY2hdO1xuICAgICAgaWYodHIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKGlkeCBpbiB1YS50cmFuc2FjdGlvbnMuaXN0KSB7XG4gICAgICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMuaXN0W2lkeF07XG4gICAgICAgICAgaWYodHIucmVxdWVzdC5mcm9tX3RhZyA9PT0gZnJvbVRhZyAmJiB0ci5yZXF1ZXN0LmNhbGxfaWQgPT09IGNhbGxfaWQgJiYgdHIucmVxdWVzdC5jc2VxID09PSBjc2VxKSB7XG4gICAgICAgICAgICByZXBseSg0ODIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5uaXN0W21lc3NhZ2UudmlhX2JyYW5jaF07XG4gICAgICBpZih0cikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IoaWR4IGluIHVhLnRyYW5zYWN0aW9ucy5uaXN0KSB7XG4gICAgICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMubmlzdFtpZHhdO1xuICAgICAgICAgIGlmKHRyLnJlcXVlc3QuZnJvbV90YWcgPT09IGZyb21UYWcgJiYgdHIucmVxdWVzdC5jYWxsX2lkID09PSBjYWxsX2lkICYmIHRyLnJlcXVlc3QuY3NlcSA9PT0gY3NlcSkge1xuICAgICAgICAgICAgcmVwbHkoNDgyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gU2FuaXR5IENoZWNrIGZ1bmN0aW9ucyBmb3IgcmVzcG9uc2VzXG5mdW5jdGlvbiByZmMzMjYxXzhfMV8zXzMoKSB7XG4gIGlmKG1lc3NhZ2UuZ2V0SGVhZGVycygndmlhJykubGVuZ3RoID4gMSkge1xuICAgIGxvZ2dlci53YXJuKCdNb3JlIHRoYW4gb25lIFZpYSBoZWFkZXIgZmllbGQgcHJlc2VudCBpbiB0aGUgcmVzcG9uc2UuIERyb3BwaW5nIHRoZSByZXNwb25zZScpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZmMzMjYxXzE4XzFfMigpIHtcbiAgdmFyIHZpYUhvc3QgPSB1YS5jb25maWd1cmF0aW9uLnZpYUhvc3Q7XG4gIGlmKG1lc3NhZ2UudmlhLmhvc3QgIT09IHZpYUhvc3QgfHwgbWVzc2FnZS52aWEucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbG9nZ2VyLndhcm4oJ1ZpYSBzZW50LWJ5IGluIHRoZSByZXNwb25zZSBkb2VzIG5vdCBtYXRjaCBVQSBWaWEgaG9zdCB2YWx1ZS4gRHJvcHBpbmcgdGhlIHJlc3BvbnNlJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJmYzMyNjFfMThfM19yZXNwb25zZSgpIHtcbiAgdmFyXG4gICAgbGVuID0gU0lQLlV0aWxzLnN0cl91dGY4X2xlbmd0aChtZXNzYWdlLmJvZHkpLFxuICAgIGNvbnRlbnRMZW5ndGggPSBtZXNzYWdlLmdldEhlYWRlcignY29udGVudC1sZW5ndGgnKTtcblxuICAgIGlmKGxlbiA8IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdNZXNzYWdlIGJvZHkgbGVuZ3RoIGlzIGxvd2VyIHRoYW4gdGhlIHZhbHVlIGluIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZC4gRHJvcHBpbmcgdGhlIHJlc3BvbnNlJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBTYW5pdHkgQ2hlY2sgZnVuY3Rpb25zIGZvciByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzXG5mdW5jdGlvbiBtaW5pbXVtSGVhZGVycygpIHtcbiAgdmFyXG4gICAgbWFuZGF0b3J5SGVhZGVycyA9IFsnZnJvbScsICd0bycsICdjYWxsX2lkJywgJ2NzZXEnLCAndmlhJ10sXG4gICAgaWR4ID0gbWFuZGF0b3J5SGVhZGVycy5sZW5ndGg7XG5cbiAgd2hpbGUoaWR4LS0pIHtcbiAgICBpZighbWVzc2FnZS5oYXNIZWFkZXIobWFuZGF0b3J5SGVhZGVyc1tpZHhdKSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ01pc3NpbmcgbWFuZGF0b3J5IGhlYWRlciBmaWVsZCA6ICcrIG1hbmRhdG9yeUhlYWRlcnNbaWR4XSArJy4gRHJvcHBpbmcgdGhlIHJlc3BvbnNlJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbnJlcXVlc3RzLnB1c2gocmZjMzI2MV84XzJfMl8xKTtcbnJlcXVlc3RzLnB1c2gocmZjMzI2MV8xNl8zXzQpO1xucmVxdWVzdHMucHVzaChyZmMzMjYxXzE4XzNfcmVxdWVzdCk7XG5yZXF1ZXN0cy5wdXNoKHJmYzMyNjFfOF8yXzJfMik7XG5cbnJlc3BvbnNlcy5wdXNoKHJmYzMyNjFfOF8xXzNfMyk7XG5yZXNwb25zZXMucHVzaChyZmMzMjYxXzE4XzFfMik7XG5yZXNwb25zZXMucHVzaChyZmMzMjYxXzE4XzNfcmVzcG9uc2UpO1xuXG5hbGwucHVzaChtaW5pbXVtSGVhZGVycyk7XG5cbnNhbml0eUNoZWNrID0gZnVuY3Rpb24obSwgdSwgdCkge1xuICB2YXIgbGVuLCBwYXNzO1xuXG4gIG1lc3NhZ2UgPSBtO1xuICB1YSA9IHU7XG4gIHRyYW5zcG9ydCA9IHQ7XG5cbiAgbG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuc2FuaXR5Y2hlY2snKTtcblxuICBsZW4gPSBhbGwubGVuZ3RoO1xuICB3aGlsZShsZW4tLSkge1xuICAgIHBhc3MgPSBhbGxbbGVuXShtZXNzYWdlKTtcbiAgICBpZihwYXNzID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXF1ZXN0KSB7XG4gICAgbGVuID0gcmVxdWVzdHMubGVuZ3RoO1xuICAgIHdoaWxlKGxlbi0tKSB7XG4gICAgICBwYXNzID0gcmVxdWVzdHNbbGVuXShtZXNzYWdlKTtcbiAgICAgIGlmKHBhc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXNwb25zZSkge1xuICAgIGxlbiA9IHJlc3BvbnNlcy5sZW5ndGg7XG4gICAgd2hpbGUobGVuLS0pIHtcbiAgICAgIHBhc3MgPSByZXNwb25zZXNbbGVuXShtZXNzYWdlKTtcbiAgICAgIGlmKHBhc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvL0V2ZXJ5dGhpbmcgaXMgT0tcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5TSVAuc2FuaXR5Q2hlY2sgPSBzYW5pdHlDaGVjaztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1Nhbml0eUNoZWNrLmpzXG4gKiogbW9kdWxlIGlkID0gMjQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBEaWdlc3QgQXV0aGVudGljYXRpb25cbiAqL1xuXG4vKipcbiAqIFNJUCBEaWdlc3QgQXV0aGVudGljYXRpb24uXG4gKiBAYXVnbWVudHMgU0lQLlxuICogQGZ1bmN0aW9uIERpZ2VzdCBBdXRoZW50aWNhdGlvblxuICogQHBhcmFtIHtTSVAuVUF9IHVhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFV0aWxzKSB7XG52YXIgRGlnZXN0QXV0aGVudGljYXRpb247XG5cbkRpZ2VzdEF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24odWEpIHtcbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcGpzLmRpZ2VzdGF1dGhlbnRpY2F0aW9uJyk7XG4gIHRoaXMudXNlcm5hbWUgPSB1YS5jb25maWd1cmF0aW9uLmF1dGhvcml6YXRpb25Vc2VyO1xuICB0aGlzLnBhc3N3b3JkID0gdWEuY29uZmlndXJhdGlvbi5wYXNzd29yZDtcbiAgdGhpcy5jbm9uY2UgPSBudWxsO1xuICB0aGlzLm5jID0gMDtcbiAgdGhpcy5uY0hleCA9ICcwMDAwMDAwMCc7XG4gIHRoaXMucmVzcG9uc2UgPSBudWxsO1xufTtcblxuXG4vKipcbiogUGVyZm9ybXMgRGlnZXN0IGF1dGhlbnRpY2F0aW9uIGdpdmVuIGEgU0lQIHJlcXVlc3QgYW5kIHRoZSBjaGFsbGVuZ2VcbiogcmVjZWl2ZWQgaW4gYSByZXNwb25zZSB0byB0aGF0IHJlcXVlc3QuXG4qIFJldHVybnMgdHJ1ZSBpZiBjcmVkZW50aWFscyB3ZXJlIHN1Y2Nlc3NmdWxseSBnZW5lcmF0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbipcbiogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fSByZXF1ZXN0XG4qIEBwYXJhbSB7T2JqZWN0fSBjaGFsbGVuZ2VcbiovXG5EaWdlc3RBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24ocmVxdWVzdCwgY2hhbGxlbmdlKSB7XG4gIC8vIEluc3BlY3QgYW5kIHZhbGlkYXRlIHRoZSBjaGFsbGVuZ2UuXG5cbiAgdGhpcy5hbGdvcml0aG0gPSBjaGFsbGVuZ2UuYWxnb3JpdGhtO1xuICB0aGlzLnJlYWxtID0gY2hhbGxlbmdlLnJlYWxtO1xuICB0aGlzLm5vbmNlID0gY2hhbGxlbmdlLm5vbmNlO1xuICB0aGlzLm9wYXF1ZSA9IGNoYWxsZW5nZS5vcGFxdWU7XG4gIHRoaXMuc3RhbGUgPSBjaGFsbGVuZ2Uuc3RhbGU7XG5cbiAgaWYgKHRoaXMuYWxnb3JpdGhtKSB7XG4gICAgaWYgKHRoaXMuYWxnb3JpdGhtICE9PSAnTUQ1Jykge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignY2hhbGxlbmdlIHdpdGggRGlnZXN0IGFsZ29yaXRobSBkaWZmZXJlbnQgdGhhbiBcIk1ENVwiLCBhdXRoZW50aWNhdGlvbiBhYm9ydGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuYWxnb3JpdGhtID0gJ01ENSc7XG4gIH1cblxuICBpZiAoISB0aGlzLnJlYWxtKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignY2hhbGxlbmdlIHdpdGhvdXQgRGlnZXN0IHJlYWxtLCBhdXRoZW50aWNhdGlvbiBhYm9ydGVkJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCEgdGhpcy5ub25jZSkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ2NoYWxsZW5nZSB3aXRob3V0IERpZ2VzdCBub25jZSwgYXV0aGVudGljYXRpb24gYWJvcnRlZCcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vICdxb3AnIGNhbiBjb250YWluIGEgbGlzdCBvZiB2YWx1ZXMgKEFycmF5KS4gTGV0J3MgY2hvb3NlIGp1c3Qgb25lLlxuICBpZiAoY2hhbGxlbmdlLnFvcCkge1xuICAgIGlmIChjaGFsbGVuZ2UucW9wLmluZGV4T2YoJ2F1dGgnKSA+IC0xKSB7XG4gICAgICB0aGlzLnFvcCA9ICdhdXRoJztcbiAgICB9IGVsc2UgaWYgKGNoYWxsZW5nZS5xb3AuaW5kZXhPZignYXV0aC1pbnQnKSA+IC0xKSB7XG4gICAgICB0aGlzLnFvcCA9ICdhdXRoLWludCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSAncW9wJyBpcyBwcmVzZW50IGJ1dCBkb2VzIG5vdCBjb250YWluICdhdXRoJyBvciAnYXV0aC1pbnQnLCBzbyBhYm9ydCBoZXJlLlxuICAgICAgdGhpcy5sb2dnZXIud2FybignY2hhbGxlbmdlIHdpdGhvdXQgRGlnZXN0IHFvcCBkaWZmZXJlbnQgdGhhbiBcImF1dGhcIiBvciBcImF1dGgtaW50XCIsIGF1dGhlbnRpY2F0aW9uIGFib3J0ZWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5xb3AgPSBudWxsO1xuICB9XG5cbiAgLy8gRmlsbCBvdGhlciBhdHRyaWJ1dGVzLlxuXG4gIHRoaXMubWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gIHRoaXMudXJpID0gcmVxdWVzdC5ydXJpO1xuICB0aGlzLmNub25jZSA9IFV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDEyKTtcbiAgdGhpcy5uYyArPSAxO1xuICB0aGlzLnVwZGF0ZU5jSGV4KCk7XG5cbiAgLy8gbmMtdmFsdWUgPSA4TEhFWC4gTWF4IHZhbHVlID0gJ0ZGRkZGRkZGJy5cbiAgaWYgKHRoaXMubmMgPT09IDQyOTQ5NjcyOTYpIHtcbiAgICB0aGlzLm5jID0gMTtcbiAgICB0aGlzLm5jSGV4ID0gJzAwMDAwMDAxJztcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSB0aGUgRGlnZXN0IFwicmVzcG9uc2VcIiB2YWx1ZS5cbiAgdGhpcy5jYWxjdWxhdGVSZXNwb25zZSgpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiogR2VuZXJhdGUgRGlnZXN0ICdyZXNwb25zZScgdmFsdWUuXG4qIEBwcml2YXRlXG4qL1xuRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLmNhbGN1bGF0ZVJlc3BvbnNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYTEsIGhhMjtcblxuICAvLyBIQTEgPSBNRDUoQTEpID0gTUQ1KHVzZXJuYW1lOnJlYWxtOnBhc3N3b3JkKVxuICBoYTEgPSBVdGlscy5jYWxjdWxhdGVNRDUodGhpcy51c2VybmFtZSArIFwiOlwiICsgdGhpcy5yZWFsbSArIFwiOlwiICsgdGhpcy5wYXNzd29yZCk7XG5cbiAgaWYgKHRoaXMucW9wID09PSAnYXV0aCcpIHtcbiAgICAvLyBIQTIgPSBNRDUoQTIpID0gTUQ1KG1ldGhvZDpkaWdlc3RVUkkpXG4gICAgaGEyID0gVXRpbHMuY2FsY3VsYXRlTUQ1KHRoaXMubWV0aG9kICsgXCI6XCIgKyB0aGlzLnVyaSk7XG4gICAgLy8gcmVzcG9uc2UgPSBNRDUoSEExOm5vbmNlOm5vbmNlQ291bnQ6Y3JlZGVudGlhbHNOb25jZTpxb3A6SEEyKVxuICAgIHRoaXMucmVzcG9uc2UgPSBVdGlscy5jYWxjdWxhdGVNRDUoaGExICsgXCI6XCIgKyB0aGlzLm5vbmNlICsgXCI6XCIgKyB0aGlzLm5jSGV4ICsgXCI6XCIgKyB0aGlzLmNub25jZSArIFwiOmF1dGg6XCIgKyBoYTIpO1xuXG4gIH0gZWxzZSBpZiAodGhpcy5xb3AgPT09ICdhdXRoLWludCcpIHtcbiAgICAvLyBIQTIgPSBNRDUoQTIpID0gTUQ1KG1ldGhvZDpkaWdlc3RVUkk6TUQ1KGVudGl0eUJvZHkpKVxuICAgIGhhMiA9IFV0aWxzLmNhbGN1bGF0ZU1ENSh0aGlzLm1ldGhvZCArIFwiOlwiICsgdGhpcy51cmkgKyBcIjpcIiArIFV0aWxzLmNhbGN1bGF0ZU1ENSh0aGlzLmJvZHkgPyB0aGlzLmJvZHkgOiBcIlwiKSk7XG4gICAgLy8gcmVzcG9uc2UgPSBNRDUoSEExOm5vbmNlOm5vbmNlQ291bnQ6Y3JlZGVudGlhbHNOb25jZTpxb3A6SEEyKVxuICAgIHRoaXMucmVzcG9uc2UgPSBVdGlscy5jYWxjdWxhdGVNRDUoaGExICsgXCI6XCIgKyB0aGlzLm5vbmNlICsgXCI6XCIgKyB0aGlzLm5jSGV4ICsgXCI6XCIgKyB0aGlzLmNub25jZSArIFwiOmF1dGgtaW50OlwiICsgaGEyKTtcblxuICB9IGVsc2UgaWYgKHRoaXMucW9wID09PSBudWxsKSB7XG4gICAgLy8gSEEyID0gTUQ1KEEyKSA9IE1ENShtZXRob2Q6ZGlnZXN0VVJJKVxuICAgIGhhMiA9IFV0aWxzLmNhbGN1bGF0ZU1ENSh0aGlzLm1ldGhvZCArIFwiOlwiICsgdGhpcy51cmkpO1xuICAgIC8vIHJlc3BvbnNlID0gTUQ1KEhBMTpub25jZTpIQTIpXG4gICAgdGhpcy5yZXNwb25zZSA9IFV0aWxzLmNhbGN1bGF0ZU1ENShoYTEgKyBcIjpcIiArIHRoaXMubm9uY2UgKyBcIjpcIiArIGhhMik7XG4gIH1cbn07XG5cblxuLyoqXG4qIFJldHVybiB0aGUgUHJveHktQXV0aG9yaXphdGlvbiBvciBXV1ctQXV0aG9yaXphdGlvbiBoZWFkZXIgdmFsdWUuXG4qL1xuRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoX3BhcmFtcyA9IFtdO1xuXG4gIGlmICghIHRoaXMucmVzcG9uc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3BvbnNlIGZpZWxkIGRvZXMgbm90IGV4aXN0LCBjYW5ub3QgZ2VuZXJhdGUgQXV0aG9yaXphdGlvbiBoZWFkZXInKTtcbiAgfVxuXG4gIGF1dGhfcGFyYW1zLnB1c2goJ2FsZ29yaXRobT0nICsgdGhpcy5hbGdvcml0aG0pO1xuICBhdXRoX3BhcmFtcy5wdXNoKCd1c2VybmFtZT1cIicgKyB0aGlzLnVzZXJuYW1lICsgJ1wiJyk7XG4gIGF1dGhfcGFyYW1zLnB1c2goJ3JlYWxtPVwiJyArIHRoaXMucmVhbG0gKyAnXCInKTtcbiAgYXV0aF9wYXJhbXMucHVzaCgnbm9uY2U9XCInICsgdGhpcy5ub25jZSArICdcIicpO1xuICBhdXRoX3BhcmFtcy5wdXNoKCd1cmk9XCInICsgdGhpcy51cmkgKyAnXCInKTtcbiAgYXV0aF9wYXJhbXMucHVzaCgncmVzcG9uc2U9XCInICsgdGhpcy5yZXNwb25zZSArICdcIicpO1xuICBpZiAodGhpcy5vcGFxdWUpIHtcbiAgICBhdXRoX3BhcmFtcy5wdXNoKCdvcGFxdWU9XCInICsgdGhpcy5vcGFxdWUgKyAnXCInKTtcbiAgfVxuICBpZiAodGhpcy5xb3ApIHtcbiAgICBhdXRoX3BhcmFtcy5wdXNoKCdxb3A9JyArIHRoaXMucW9wKTtcbiAgICBhdXRoX3BhcmFtcy5wdXNoKCdjbm9uY2U9XCInICsgdGhpcy5jbm9uY2UgKyAnXCInKTtcbiAgICBhdXRoX3BhcmFtcy5wdXNoKCduYz0nICsgdGhpcy5uY0hleCk7XG4gIH1cblxuICByZXR1cm4gJ0RpZ2VzdCAnICsgYXV0aF9wYXJhbXMuam9pbignLCAnKTtcbn07XG5cblxuLyoqXG4qIEdlbmVyYXRlIHRoZSAnbmMnIHZhbHVlIGFzIHJlcXVpcmVkIGJ5IERpZ2VzdCBpbiB0aGlzLm5jSGV4IGJ5IHJlYWRpbmcgdGhpcy5uYy5cbiogQHByaXZhdGVcbiovXG5EaWdlc3RBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUudXBkYXRlTmNIZXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhleCA9IE51bWJlcih0aGlzLm5jKS50b1N0cmluZygxNik7XG4gIHRoaXMubmNIZXggPSAnMDAwMDAwMDAnLnN1YnN0cigwLCA4LWhleC5sZW5ndGgpICsgaGV4O1xufTtcblxucmV0dXJuIERpZ2VzdEF1dGhlbnRpY2F0aW9uO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvRGlnZXN0QXV0aGVudGljYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIEdyYW1tYXIgPSByZXF1aXJlKCcuL0dyYW1tYXIvZGlzdC9HcmFtbWFyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuXG5yZXR1cm4ge1xuICBwYXJzZTogZnVuY3Rpb24gcGFyc2VDdXN0b20gKGlucHV0LCBzdGFydFJ1bGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtzdGFydFJ1bGU6IHN0YXJ0UnVsZSwgU0lQOiBTSVB9O1xuICAgIHRyeSB7XG4gICAgICBHcmFtbWFyLnBhcnNlKGlucHV0LCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMuZGF0YTtcbiAgfVxufTtcblxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvR3JhbW1hci5qc1xuICoqIG1vZHVsZSBpZCA9IDI0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIC8qXG4gICAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC44LjAuXG4gICAqXG4gICAqIGh0dHA6Ly9wZWdqcy5tYWpkYS5jei9cbiAgICovXG5cbiAgZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgICBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH1cbiAgICBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHtcbiAgICB0aGlzLm1lc3NhZ2UgID0gbWVzc2FnZTtcbiAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICAgIHRoaXMub2Zmc2V0ICAgPSBvZmZzZXQ7XG4gICAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gICA9IGNvbHVtbjtcblxuICAgIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7XG4gIH1cblxuICBwZWckc3ViY2xhc3MoU3ludGF4RXJyb3IsIEVycm9yKTtcblxuICBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB7fSxcblxuICAgICAgICBwZWckRkFJTEVEID0ge30sXG5cbiAgICAgICAgcGVnJHN0YXJ0UnVsZUluZGljZXMgPSB7IENvbnRhY3Q6IDExOCwgTmFtZV9BZGRyX0hlYWRlcjogMTU1LCBSZWNvcmRfUm91dGU6IDE3NSwgUmVxdWVzdF9SZXNwb25zZTogODEsIFNJUF9VUkk6IDQ1LCBTdWJzY3JpcHRpb25fU3RhdGU6IDE4NSwgU3VwcG9ydGVkOiAxOTAsIFJlcXVpcmU6IDE4MSwgVmlhOiAxOTMsIGFic29sdXRlVVJJOiA4NCwgQ2FsbF9JRDogMTE3LCBDb250ZW50X0Rpc3Bvc2l0aW9uOiAxMjksIENvbnRlbnRfTGVuZ3RoOiAxMzQsIENvbnRlbnRfVHlwZTogMTM1LCBDU2VxOiAxNDUsIGRpc3BsYXlOYW1lOiAxMjEsIEV2ZW50OiAxNDgsIEZyb206IDE1MCwgaG9zdDogNTIsIE1heF9Gb3J3YXJkczogMTUzLCBNaW5fU0U6IDIxMiwgUHJveHlfQXV0aGVudGljYXRlOiAxNTYsIHF1b3RlZF9zdHJpbmc6IDQwLCBSZWZlcl9UbzogMTc3LCBSZXBsYWNlczogMTc4LCBTZXNzaW9uX0V4cGlyZXM6IDIwOSwgc3R1bl9VUkk6IDIxNiwgVG86IDE5MSwgdHVybl9VUkk6IDIyMywgdXVpZDogMjI2LCBXV1dfQXV0aGVudGljYXRlOiAyMDgsIGNoYWxsZW5nZTogMTU3IH0sXG4gICAgICAgIHBlZyRzdGFydFJ1bGVJbmRleCAgID0gMTE4LFxuXG4gICAgICAgIHBlZyRjb25zdHMgPSBbXG4gICAgICAgICAgXCJcXHJcXG5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXHJcXG5cIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxyXFxcXG5cXFwiXCIgfSxcbiAgICAgICAgICAvXlswLTldLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzAtOV1cIiwgZGVzY3JpcHRpb246IFwiWzAtOV1cIiB9LFxuICAgICAgICAgIC9eW2EtekEtWl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aXVwiLCBkZXNjcmlwdGlvbjogXCJbYS16QS1aXVwiIH0sXG4gICAgICAgICAgL15bMC05YS1mQS1GXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlswLTlhLWZBLUZdXCIsIGRlc2NyaXB0aW9uOiBcIlswLTlhLWZBLUZdXCIgfSxcbiAgICAgICAgICAvXltcXDAtXFx4RkZdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFwwLVxcXFx4RkZdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxcMC1cXFxceEZGXVwiIH0sXG4gICAgICAgICAgL15bXCJdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXCJdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFwiXVwiIH0sXG4gICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiIFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiIFxcXCJcIiB9LFxuICAgICAgICAgIFwiXFx0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFx0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcdFxcXCJcIiB9LFxuICAgICAgICAgIC9eW2EtekEtWjAtOV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aMC05XVwiLCBkZXNjcmlwdGlvbjogXCJbYS16QS1aMC05XVwiIH0sXG4gICAgICAgICAgXCI7XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiO1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiO1xcXCJcIiB9LFxuICAgICAgICAgIFwiL1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi9cIiwgZGVzY3JpcHRpb246IFwiXFxcIi9cXFwiXCIgfSxcbiAgICAgICAgICBcIj9cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI/XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI/XFxcIlwiIH0sXG4gICAgICAgICAgXCI6XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiOlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiOlxcXCJcIiB9LFxuICAgICAgICAgIFwiQFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIkBcIiwgZGVzY3JpcHRpb246IFwiXFxcIkBcXFwiXCIgfSxcbiAgICAgICAgICBcIiZcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCImXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCImXFxcIlwiIH0sXG4gICAgICAgICAgXCI9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPVxcXCJcIiB9LFxuICAgICAgICAgIFwiK1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIitcIiwgZGVzY3JpcHRpb246IFwiXFxcIitcXFwiXCIgfSxcbiAgICAgICAgICBcIiRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIkXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIkXFxcIlwiIH0sXG4gICAgICAgICAgXCIsXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiLFxcXCJcIiB9LFxuICAgICAgICAgIFwiLVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi1cIiwgZGVzY3JpcHRpb246IFwiXFxcIi1cXFwiXCIgfSxcbiAgICAgICAgICBcIl9cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJfXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJfXFxcIlwiIH0sXG4gICAgICAgICAgXCIuXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiLlxcXCJcIiB9LFxuICAgICAgICAgIFwiIVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiFcIiwgZGVzY3JpcHRpb246IFwiXFxcIiFcXFwiXCIgfSxcbiAgICAgICAgICBcIn5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ+XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ+XFxcIlwiIH0sXG4gICAgICAgICAgXCIqXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKlxcXCJcIiB9LFxuICAgICAgICAgIFwiJ1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIidcIiwgZGVzY3JpcHRpb246IFwiXFxcIidcXFwiXCIgfSxcbiAgICAgICAgICBcIihcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIoXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIoXFxcIlwiIH0sXG4gICAgICAgICAgXCIpXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKVxcXCJcIiB9LFxuICAgICAgICAgIHBlZyRGQUlMRUQsXG4gICAgICAgICAgXCIlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiJVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiJVxcXCJcIiB9LFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgW10sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiIFwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiAnOic7IH0sXG4gICAgICAgICAgL15bIS1+XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlshLX5dXCIsIGRlc2NyaXB0aW9uOiBcIlshLX5dXCIgfSxcbiAgICAgICAgICAvXltcXHg4MC1cXHVGRkZGXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxceDgwLVxcXFx1RkZGRl1cIiwgZGVzY3JpcHRpb246IFwiW1xcXFx4ODAtXFxcXHVGRkZGXVwiIH0sXG4gICAgICAgICAgL15bXFx4ODAtXFx4QkZdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFx4ODAtXFxcXHhCRl1cIiwgZGVzY3JpcHRpb246IFwiW1xcXFx4ODAtXFxcXHhCRl1cIiB9LFxuICAgICAgICAgIC9eW2EtZl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS1mXVwiLCBkZXNjcmlwdGlvbjogXCJbYS1mXVwiIH0sXG4gICAgICAgICAgXCJgXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYFxcXCJcIiB9LFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjxcIiwgZGVzY3JpcHRpb246IFwiXFxcIjxcXFwiXCIgfSxcbiAgICAgICAgICBcIj5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI+XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI+XFxcIlwiIH0sXG4gICAgICAgICAgXCJcXFxcXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxcXFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFxcXFwiXCIgfSxcbiAgICAgICAgICBcIltcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJbXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJbXFxcIlwiIH0sXG4gICAgICAgICAgXCJdXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXVxcXCJcIiB9LFxuICAgICAgICAgIFwie1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIntcIiwgZGVzY3JpcHRpb246IFwiXFxcIntcXFwiXCIgfSxcbiAgICAgICAgICBcIn1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ9XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiKlwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIi9cIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCI9XCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiKFwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIilcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCI+XCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiPFwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIixcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCI7XCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiOlwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIlxcXCJcIjsgfSxcbiAgICAgICAgICAvXlshLSddLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyEtJ11cIiwgZGVzY3JpcHRpb246IFwiWyEtJ11cIiB9LFxuICAgICAgICAgIC9eWyotW10vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbKi1bXVwiLCBkZXNjcmlwdGlvbjogXCJbKi1bXVwiIH0sXG4gICAgICAgICAgL15bXFxdLX5dLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFxdLX5dXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxcXS1+XVwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oY29udGVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudHM7IH0sXG4gICAgICAgICAgL15bIy1bXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsjLVtdXCIsIGRlc2NyaXB0aW9uOiBcIlsjLVtdXCIgfSxcbiAgICAgICAgICAvXltcXDAtXFx0XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxcMC1cXFxcdF1cIiwgZGVzY3JpcHRpb246IFwiW1xcXFwwLVxcXFx0XVwiIH0sXG4gICAgICAgICAgL15bXFx4MEItXFxmXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxceDBCLVxcXFxmXVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcXHgwQi1cXFxcZl1cIiB9LFxuICAgICAgICAgIC9eW1xceDBFLX9dLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFx4MEUtf11cIiwgZGVzY3JpcHRpb246IFwiW1xcXFx4MEUtf11cIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmkgPSBuZXcgb3B0aW9ucy5TSVAuVVJJKG9wdGlvbnMuZGF0YS5zY2hlbWUsIG9wdGlvbnMuZGF0YS51c2VyLCBvcHRpb25zLmRhdGEuaG9zdCwgb3B0aW9ucy5kYXRhLnBvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuc2NoZW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5wb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmkgPSBuZXcgb3B0aW9ucy5TSVAuVVJJKG9wdGlvbnMuZGF0YS5zY2hlbWUsIG9wdGlvbnMuZGF0YS51c2VyLCBvcHRpb25zLmRhdGEuaG9zdCwgb3B0aW9ucy5kYXRhLnBvcnQsIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zLCBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuc2NoZW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5wb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1NJUF9VUkknKSB7IG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YS51cmk7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwic2lwc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInNpcHNcIiwgZGVzY3JpcHRpb246IFwiXFxcInNpcHNcXFwiXCIgfSxcbiAgICAgICAgICBcInNpcFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInNpcFwiLCBkZXNjcmlwdGlvbjogXCJcXFwic2lwXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odXJpX3NjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNjaGVtZSA9IHVyaV9zY2hlbWU7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXNlciA9IGRlY29kZVVSSUNvbXBvbmVudCh0ZXh0KCkuc2xpY2UoMCwgLTEpKTt9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhc3N3b3JkID0gdGV4dCgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3QgPSB0ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXRhLmhvc3Q7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZSA9ICdkb21haW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0KCk7IH0sXG4gICAgICAgICAgL15bYS16QS1aMC05X1xcLV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aMC05X1xcXFwtXVwiLCBkZXNjcmlwdGlvbjogXCJbYS16QS1aMC05X1xcXFwtXVwiIH0sXG4gICAgICAgICAgL15bYS16QS1aMC05XFwtXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlthLXpBLVowLTlcXFxcLV1cIiwgZGVzY3JpcHRpb246IFwiW2EtekEtWjAtOVxcXFwtXVwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdF90eXBlID0gJ0lQdjYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQoKTsgfSxcbiAgICAgICAgICBcIjo6XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiOjpcIiwgZGVzY3JpcHRpb246IFwiXFxcIjo6XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZSA9ICdJUHY2JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZSA9ICdJUHY0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0KCk7IH0sXG4gICAgICAgICAgXCIyNVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjI1XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIyNVxcXCJcIiB9LFxuICAgICAgICAgIC9eWzAtNV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC01XVwiLCBkZXNjcmlwdGlvbjogXCJbMC01XVwiIH0sXG4gICAgICAgICAgXCIyXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiMlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiMlxcXCJcIiB9LFxuICAgICAgICAgIC9eWzAtNF0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC00XVwiLCBkZXNjcmlwdGlvbjogXCJbMC00XVwiIH0sXG4gICAgICAgICAgXCIxXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiMVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiMVxcXCJcIiB9LFxuICAgICAgICAgIC9eWzEtOV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMS05XVwiLCBkZXNjcmlwdGlvbjogXCJbMS05XVwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydCA9IHBhcnNlSW50KHBvcnQuam9pbignJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBvcnQgPSBwb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcnQ7IH0sXG4gICAgICAgICAgXCJ0cmFuc3BvcnQ9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidHJhbnNwb3J0PVwiLCBkZXNjcmlwdGlvbjogXCJcXFwidHJhbnNwb3J0PVxcXCJcIiB9LFxuICAgICAgICAgIFwidWRwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidWRwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ1ZHBcXFwiXCIgfSxcbiAgICAgICAgICBcInRjcFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRjcFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidGNwXFxcIlwiIH0sXG4gICAgICAgICAgXCJzY3RwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic2N0cFwiLCBkZXNjcmlwdGlvbjogXCJcXFwic2N0cFxcXCJcIiB9LFxuICAgICAgICAgIFwidGxzXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidGxzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0bHNcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ3RyYW5zcG9ydCddID0gdHJhbnNwb3J0LnRvTG93ZXJDYXNlKCk7IH0sXG4gICAgICAgICAgXCJ1c2VyPVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInVzZXI9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ1c2VyPVxcXCJcIiB9LFxuICAgICAgICAgIFwicGhvbmVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJwaG9uZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwicGhvbmVcXFwiXCIgfSxcbiAgICAgICAgICBcImlwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiaXBcIiwgZGVzY3JpcHRpb246IFwiXFxcImlwXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zPXt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1sndXNlciddID0gdXNlci50b0xvd2VyQ2FzZSgpOyB9LFxuICAgICAgICAgIFwibWV0aG9kPVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1ldGhvZD1cIiwgZGVzY3JpcHRpb246IFwiXFxcIm1ldGhvZD1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ21ldGhvZCddID0gbWV0aG9kOyB9LFxuICAgICAgICAgIFwidHRsPVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInR0bD1cIiwgZGVzY3JpcHRpb246IFwiXFxcInR0bD1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih0dGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5wYXJhbXMpIG9wdGlvbnMuZGF0YS5wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXNbJ3R0bCddID0gdHRsOyB9LFxuICAgICAgICAgIFwibWFkZHI9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibWFkZHI9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtYWRkcj1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihtYWRkcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zPXt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1snbWFkZHInXSA9IG1hZGRyOyB9LFxuICAgICAgICAgIFwibHJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJsclwiLCBkZXNjcmlwdGlvbjogXCJcXFwibHJcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ2xyJ10gPSB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgZnVuY3Rpb24ocGFyYW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zW3BhcmFtLnRvTG93ZXJDYXNlKCldID0gdmFsdWUgJiYgdmFsdWUudG9Mb3dlckNhc2UoKTt9LFxuICAgICAgICAgIGZ1bmN0aW9uKGhuYW1lLCBodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG5hbWUgPSBobmFtZS5qb2luKCcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodmFsdWUgPSBodmFsdWUuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX2hlYWRlcnMpIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YS51cmlfaGVhZGVyc1tobmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnNbaG5hbWVdID0gW2h2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzW2huYW1lXS5wdXNoKGh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb3RzIG9mIHRlc3RzIGZhaWwgaWYgdGhpcyBpc24ndCBndWFyZGVkLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1JlZmVyX1RvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmkgPSBuZXcgb3B0aW9ucy5TSVAuVVJJKG9wdGlvbnMuZGF0YS5zY2hlbWUsIG9wdGlvbnMuZGF0YS51c2VyLCBvcHRpb25zLmRhdGEuaG9zdCwgb3B0aW9ucy5kYXRhLnBvcnQsIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zLCBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuc2NoZW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5wb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcIi8vXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLy9cIiwgZGVzY3JpcHRpb246IFwiXFxcIi8vXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuc2NoZW1lPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiU0lQXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJTSVBcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zaXBfdmVyc2lvbiA9IHRleHQoKTsgfSxcbiAgICAgICAgICBcIklOVklURVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIklOVklURVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiSU5WSVRFXFxcIlwiIH0sXG4gICAgICAgICAgXCJBQ0tcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJBQ0tcIiwgZGVzY3JpcHRpb246IFwiXFxcIkFDS1xcXCJcIiB9LFxuICAgICAgICAgIFwiVlhBQ0hcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJWWEFDSFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiVlhBQ0hcXFwiXCIgfSxcbiAgICAgICAgICBcIk9QVElPTlNcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJPUFRJT05TXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJPUFRJT05TXFxcIlwiIH0sXG4gICAgICAgICAgXCJCWUVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJCWUVcIiwgZGVzY3JpcHRpb246IFwiXFxcIkJZRVxcXCJcIiB9LFxuICAgICAgICAgIFwiQ0FOQ0VMXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiQ0FOQ0VMXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJDQU5DRUxcXFwiXCIgfSxcbiAgICAgICAgICBcIlJFR0lTVEVSXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiUkVHSVNURVJcIiwgZGVzY3JpcHRpb246IFwiXFxcIlJFR0lTVEVSXFxcIlwiIH0sXG4gICAgICAgICAgXCJTVUJTQ1JJQkVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJTVUJTQ1JJQkVcIiwgZGVzY3JpcHRpb246IFwiXFxcIlNVQlNDUklCRVxcXCJcIiB9LFxuICAgICAgICAgIFwiTk9USUZZXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiTk9USUZZXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJOT1RJRllcXFwiXCIgfSxcbiAgICAgICAgICBcIlJFRkVSXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiUkVGRVJcIiwgZGVzY3JpcHRpb246IFwiXFxcIlJFRkVSXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tZXRob2QgPSB0ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXRhLm1ldGhvZDsgfSxcbiAgICAgICAgICBmdW5jdGlvbihzdGF0dXNfY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zdGF0dXNfY29kZSA9IHBhcnNlSW50KHN0YXR1c19jb2RlLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmVhc29uX3BocmFzZSA9IHRleHQoKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHRleHQoKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4LCBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcltpZHhdLnBhcnNlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcikgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlci5wdXNoKCB7ICdwb3NpdGlvbic6IHBlZyRjdXJyUG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29mZnNldCc6IG9mZnNldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BhcnNlZCc6IGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO30sXG4gICAgICAgICAgZnVuY3Rpb24oZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZSA9IHRleHQoKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3BsYXlOYW1lWzBdID09PSAnXFxcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWUuc3Vic3RyaW5nKDEsIGRpc3BsYXlOYW1lLmxlbmd0aC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7IH0sXG4gICAgICAgICAgXCJxXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicVwiLCBkZXNjcmlwdGlvbjogXCJcXFwicVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnBhcmFtcykgb3B0aW9ucy5kYXRhLnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXNbJ3EnXSA9IHE7IH0sXG4gICAgICAgICAgXCJleHBpcmVzXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZXhwaXJlc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiZXhwaXJlc1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGV4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnBhcmFtcykgb3B0aW9ucy5kYXRhLnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXNbJ2V4cGlyZXMnXSA9IGV4cGlyZXM7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZGVsdGFfc2Vjb25kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChkZWx0YV9zZWNvbmRzLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBcIjBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIwXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGV4dCgpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihwYXJhbSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnBhcmFtcykgb3B0aW9ucy5kYXRhLnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zW3BhcmFtLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7fSxcbiAgICAgICAgICBcInJlbmRlclwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJlbmRlclwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVuZGVyXFxcIlwiIH0sXG4gICAgICAgICAgXCJzZXNzaW9uXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic2Vzc2lvblwiLCBkZXNjcmlwdGlvbjogXCJcXFwic2Vzc2lvblxcXCJcIiB9LFxuICAgICAgICAgIFwiaWNvblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImljb25cIiwgZGVzY3JpcHRpb246IFwiXFxcImljb25cXFwiXCIgfSxcbiAgICAgICAgICBcImFsZXJ0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYWxlcnRcIiwgZGVzY3JpcHRpb246IFwiXFxcImFsZXJ0XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ0NvbnRlbnRfRGlzcG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnR5cGUgPSB0ZXh0KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcImhhbmRsaW5nXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiaGFuZGxpbmdcIiwgZGVzY3JpcHRpb246IFwiXFxcImhhbmRsaW5nXFxcIlwiIH0sXG4gICAgICAgICAgXCJvcHRpb25hbFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm9wdGlvbmFsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJvcHRpb25hbFxcXCJcIiB9LFxuICAgICAgICAgIFwicmVxdWlyZWRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZXF1aXJlZFwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVxdWlyZWRcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBwYXJzZUludChsZW5ndGguam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHRleHQoKTsgfSxcbiAgICAgICAgICBcInRleHRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0ZXh0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0ZXh0XFxcIlwiIH0sXG4gICAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImltYWdlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJpbWFnZVxcXCJcIiB9LFxuICAgICAgICAgIFwiYXVkaW9cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhdWRpb1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiYXVkaW9cXFwiXCIgfSxcbiAgICAgICAgICBcInZpZGVvXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidmlkZW9cIiwgZGVzY3JpcHRpb246IFwiXFxcInZpZGVvXFxcIlwiIH0sXG4gICAgICAgICAgXCJhcHBsaWNhdGlvblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImFwcGxpY2F0aW9uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhcHBsaWNhdGlvblxcXCJcIiB9LFxuICAgICAgICAgIFwibWVzc2FnZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1lc3NhZ2VcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1lc3NhZ2VcXFwiXCIgfSxcbiAgICAgICAgICBcIm11bHRpcGFydFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm11bHRpcGFydFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibXVsdGlwYXJ0XFxcIlwiIH0sXG4gICAgICAgICAgXCJ4LVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIngtXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ4LVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGNzZXFfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudmFsdWU9cGFyc2VJbnQoY3NlcV92YWx1ZS5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXhwaXJlcykge29wdGlvbnMuZGF0YSA9IGV4cGlyZXM7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXZlbnRfdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmV2ZW50ID0gZXZlbnRfdHlwZS50b0xvd2VyQ2FzZSgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gb3B0aW9ucy5kYXRhLnRhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnKSB7b3B0aW9ucy5kYXRhLnNldFBhcmFtKCd0YWcnLHRhZyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0YWdcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0YWdcIiwgZGVzY3JpcHRpb246IFwiXFxcInRhZ1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHRhZykge29wdGlvbnMuZGF0YS50YWcgPSB0YWc7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZm9yd2FyZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBwYXJzZUludChmb3J3YXJkcy5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24obWluX2V4cGlyZXMpIHtvcHRpb25zLmRhdGEgPSBtaW5fZXhwaXJlczsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcImRpZ2VzdFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIkRpZ2VzdFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiRGlnZXN0XFxcIlwiIH0sXG4gICAgICAgICAgXCJyZWFsbVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJlYWxtXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyZWFsbVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHJlYWxtKSB7IG9wdGlvbnMuZGF0YS5yZWFsbSA9IHJlYWxtOyB9LFxuICAgICAgICAgIFwiZG9tYWluXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZG9tYWluXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJkb21haW5cXFwiXCIgfSxcbiAgICAgICAgICBcIm5vbmNlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibm9uY2VcIiwgZGVzY3JpcHRpb246IFwiXFxcIm5vbmNlXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24obm9uY2UpIHsgb3B0aW9ucy5kYXRhLm5vbmNlPW5vbmNlOyB9LFxuICAgICAgICAgIFwib3BhcXVlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwib3BhcXVlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJvcGFxdWVcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihvcGFxdWUpIHsgb3B0aW9ucy5kYXRhLm9wYXF1ZT1vcGFxdWU7IH0sXG4gICAgICAgICAgXCJzdGFsZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInN0YWxlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzdGFsZVxcXCJcIiB9LFxuICAgICAgICAgIFwidHJ1ZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRydWVcIiwgZGVzY3JpcHRpb246IFwiXFxcInRydWVcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgb3B0aW9ucy5kYXRhLnN0YWxlPXRydWU7IH0sXG4gICAgICAgICAgXCJmYWxzZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImZhbHNlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJmYWxzZVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyBvcHRpb25zLmRhdGEuc3RhbGU9ZmFsc2U7IH0sXG4gICAgICAgICAgXCJhbGdvcml0aG1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhbGdvcml0aG1cIiwgZGVzY3JpcHRpb246IFwiXFxcImFsZ29yaXRobVxcXCJcIiB9LFxuICAgICAgICAgIFwibWQ1XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiTUQ1XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJNRDVcXFwiXCIgfSxcbiAgICAgICAgICBcIm1kNS1zZXNzXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiTUQ1LXNlc3NcIiwgZGVzY3JpcHRpb246IFwiXFxcIk1ENS1zZXNzXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5hbGdvcml0aG09YWxnb3JpdGhtLnRvVXBwZXJDYXNlKCk7IH0sXG4gICAgICAgICAgXCJxb3BcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJxb3BcIiwgZGVzY3JpcHRpb246IFwiXFxcInFvcFxcXCJcIiB9LFxuICAgICAgICAgIFwiYXV0aC1pbnRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhdXRoLWludFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYXV0aC1pbnRcXFwiXCIgfSxcbiAgICAgICAgICBcImF1dGhcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhdXRoXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhdXRoXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocW9wX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnFvcCB8fCAob3B0aW9ucy5kYXRhLnFvcD1bXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnFvcC5wdXNoKHFvcF92YWx1ZS50b0xvd2VyQ2FzZSgpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihyYWNrX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnZhbHVlPXBhcnNlSW50KHJhY2tfdmFsdWUuam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHgsIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyW2lkeF0ucGFyc2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyKSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IG5ldyBvcHRpb25zLlNJUC5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51cmk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyLnB1c2goIHsgJ3Bvc2l0aW9uJzogcGVnJGN1cnJQb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0Jzogb2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyc2VkJzogaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7fSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG5ldyBvcHRpb25zLlNJUC5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG9wdGlvbnMuZGF0YS5yZXBsYWNlc19mcm9tX3RhZyAmJiBvcHRpb25zLmRhdGEucmVwbGFjZXNfdG9fdGFnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbF9pZDogb3B0aW9ucy5kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwiZnJvbS10YWdcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJmcm9tLXRhZ1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiZnJvbS10YWdcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihmcm9tX3RhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmVwbGFjZXNfZnJvbV90YWcgPSBmcm9tX3RhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0by10YWdcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0by10YWdcIiwgZGVzY3JpcHRpb246IFwiXFxcInRvLXRhZ1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHRvX3RhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmVwbGFjZXNfdG9fdGFnID0gdG9fdGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcImVhcmx5LW9ubHlcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJlYXJseS1vbmx5XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJlYXJseS1vbmx5XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5lYXJseV9vbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocikge3JldHVybiByO30sXG4gICAgICAgICAgZnVuY3Rpb24oZmlyc3QsIHJlc3QpIHsgcmV0dXJuIGxpc3QoZmlyc3QsIHJlc3QpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1JlcXVpcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gdmFsdWUgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocnNlcV92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS52YWx1ZT1wYXJzZUludChyc2VxX3ZhbHVlLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBcImFjdGl2ZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImFjdGl2ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYWN0aXZlXFxcIlwiIH0sXG4gICAgICAgICAgXCJwZW5kaW5nXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicGVuZGluZ1wiLCBkZXNjcmlwdGlvbjogXCJcXFwicGVuZGluZ1xcXCJcIiB9LFxuICAgICAgICAgIFwidGVybWluYXRlZFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRlcm1pbmF0ZWRcIiwgZGVzY3JpcHRpb246IFwiXFxcInRlcm1pbmF0ZWRcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuc3RhdGUgPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgXCJyZWFzb25cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZWFzb25cIiwgZGVzY3JpcHRpb246IFwiXFxcInJlYXNvblxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhc29uICE9PSAndW5kZWZpbmVkJykgb3B0aW9ucy5kYXRhLnJlYXNvbiA9IHJlYXNvbjsgfSxcbiAgICAgICAgICBmdW5jdGlvbihleHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBpcmVzICE9PSAndW5kZWZpbmVkJykgb3B0aW9ucy5kYXRhLmV4cGlyZXMgPSBleHBpcmVzOyB9LFxuICAgICAgICAgIFwicmV0cnlfYWZ0ZXJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZXRyeV9hZnRlclwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmV0cnlfYWZ0ZXJcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihyZXRyeV9hZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0cnlfYWZ0ZXIgIT09ICd1bmRlZmluZWQnKSBvcHRpb25zLmRhdGEucmV0cnlfYWZ0ZXIgPSByZXRyeV9hZnRlcjsgfSxcbiAgICAgICAgICBcImRlYWN0aXZhdGVkXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZGVhY3RpdmF0ZWRcIiwgZGVzY3JpcHRpb246IFwiXFxcImRlYWN0aXZhdGVkXFxcIlwiIH0sXG4gICAgICAgICAgXCJwcm9iYXRpb25cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJwcm9iYXRpb25cIiwgZGVzY3JpcHRpb246IFwiXFxcInByb2JhdGlvblxcXCJcIiB9LFxuICAgICAgICAgIFwicmVqZWN0ZWRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZWplY3RlZFwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVqZWN0ZWRcXFwiXCIgfSxcbiAgICAgICAgICBcInRpbWVvdXRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0aW1lb3V0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0aW1lb3V0XFxcIlwiIH0sXG4gICAgICAgICAgXCJnaXZldXBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJnaXZldXBcIiwgZGVzY3JpcHRpb246IFwiXFxcImdpdmV1cFxcXCJcIiB9LFxuICAgICAgICAgIFwibm9yZXNvdXJjZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm5vcmVzb3VyY2VcIiwgZGVzY3JpcHRpb246IFwiXFxcIm5vcmVzb3VyY2VcXFwiXCIgfSxcbiAgICAgICAgICBcImludmFyaWFudFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImludmFyaWFudFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiaW52YXJpYW50XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnU3VwcG9ydGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHZhbHVlIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IG9wdGlvbnMuZGF0YS50YWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG5ldyBvcHRpb25zLlNJUC5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnKSB7b3B0aW9ucy5kYXRhLnNldFBhcmFtKCd0YWcnLHRhZyl9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwidHRsXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidHRsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0dGxcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih2aWFfdHRsX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS50dGwgPSB2aWFfdHRsX3ZhbHVlOyB9LFxuICAgICAgICAgIFwibWFkZHJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtYWRkclwiLCBkZXNjcmlwdGlvbjogXCJcXFwibWFkZHJcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih2aWFfbWFkZHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm1hZGRyID0gdmlhX21hZGRyOyB9LFxuICAgICAgICAgIFwicmVjZWl2ZWRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZWNlaXZlZFwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVjZWl2ZWRcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih2aWFfcmVjZWl2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlY2VpdmVkID0gdmlhX3JlY2VpdmVkOyB9LFxuICAgICAgICAgIFwiYnJhbmNoXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYnJhbmNoXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJicmFuY2hcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih2aWFfYnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5icmFuY2ggPSB2aWFfYnJhbmNoOyB9LFxuICAgICAgICAgIFwicnBvcnRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJycG9ydFwiLCBkZXNjcmlwdGlvbjogXCJcXFwicnBvcnRcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHJlc3BvbnNlX3BvcnQgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ycG9ydCA9IHJlc3BvbnNlX3BvcnQuam9pbignJyk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX3Byb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wcm90b2NvbCA9IHZpYV9wcm90b2NvbDsgfSxcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJVRFBcIiwgZGVzY3JpcHRpb246IFwiXFxcIlVEUFxcXCJcIiB9LFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlRDUFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiVENQXFxcIlwiIH0sXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiVExTXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJUTFNcXFwiXCIgfSxcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJTQ1RQXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJTQ1RQXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX3RyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudHJhbnNwb3J0ID0gdmlhX3RyYW5zcG9ydDsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3QgPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX3NlbnRfYnlfcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucG9ydCA9IHBhcnNlSW50KHZpYV9zZW50X2J5X3BvcnQuam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHR0bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodHRsLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihkZWx0YVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnU2Vzc2lvbl9FeHBpcmVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5kZWx0YVNlY29uZHMgPSBkZWx0YVNlY29uZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZWZyZXNoZXJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZWZyZXNoZXJcIiwgZGVzY3JpcHRpb246IFwiXFxcInJlZnJlc2hlclxcXCJcIiB9LFxuICAgICAgICAgIFwidWFzXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidWFzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ1YXNcXFwiXCIgfSxcbiAgICAgICAgICBcInVhY1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInVhY1wiLCBkZXNjcmlwdGlvbjogXCJcXFwidWFjXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnU2Vzc2lvbl9FeHBpcmVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZWZyZXNoZXIgPSBlbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihkZWx0YVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnTWluX1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IGRlbHRhU2Vjb25kcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcInN0dW5zXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic3R1bnNcIiwgZGVzY3JpcHRpb246IFwiXFxcInN0dW5zXFxcIlwiIH0sXG4gICAgICAgICAgXCJzdHVuXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic3R1blwiLCBkZXNjcmlwdGlvbjogXCJcXFwic3R1blxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuc2NoZW1lID0gc2NoZW1lOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3QgPSBob3N0OyB9LFxuICAgICAgICAgIFwiP3RyYW5zcG9ydD1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI/dHJhbnNwb3J0PVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiP3RyYW5zcG9ydD1cXFwiXCIgfSxcbiAgICAgICAgICBcInR1cm5zXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidHVybnNcIiwgZGVzY3JpcHRpb246IFwiXFxcInR1cm5zXFxcIlwiIH0sXG4gICAgICAgICAgXCJ0dXJuXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidHVyblwiLCBkZXNjcmlwdGlvbjogXCJcXFwidHVyblxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudHJhbnNwb3J0ID0gdHJhbnNwb3J0OyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHRleHQoKTsgfVxuICAgICAgICBdLFxuXG4gICAgICAgIHBlZyRieXRlY29kZSA9IFtcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLiBcXFwiXFxcIjIgMyFcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjBcXFwiXFxcIlxcXCIxITMjXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwJFxcXCJcXFwiMSEzJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMCZcXFwiXFxcIjEhMydcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcnKiMgXFxcIjcoXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwKFxcXCJcXFwiMSEzKVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMCpcXFwiXFxcIjEhMytcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi4sXFxcIlxcXCIyLDMtXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuLlxcXCJcXFwiMi4zL1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMDBcXFwiXFxcIjEhMzFcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi4yXFxcIlxcXCIyMjMzKlxceDg5IFxcXCIuNFxcXCJcXFwiMjQzNSp9IFxcXCIuNlxcXCJcXFwiMjYzNypxIFxcXCIuOFxcXCJcXFwiMjgzOSplIFxcXCIuOlxcXCJcXFwiMjozOypZIFxcXCIuPFxcXCJcXFwiMjwzPSpNIFxcXCIuPlxcXCJcXFwiMj4zPypBIFxcXCIuQFxcXCJcXFwiMkAzQSo1IFxcXCIuQlxcXCJcXFwiMkIzQyopIFxcXCIuRFxcXCJcXFwiMkQzRVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNykqIyBcXFwiNyxcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5GXFxcIlxcXCIyRjNHKn0gXFxcIi5IXFxcIlxcXCIySDNJKnEgXFxcIi5KXFxcIlxcXCIySjNLKmUgXFxcIi5MXFxcIlxcXCIyTDNNKlkgXFxcIi5OXFxcIlxcXCIyTjNPKk0gXFxcIi5QXFxcIlxcXCIyUDNRKkEgXFxcIi5SXFxcIlxcXCIyUjNTKjUgXFxcIi5UXFxcIlxcXCIyVDNVKikgXFxcIi5WXFxcIlxcXCIyVjNXXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIS5ZXFxcIlxcXCIyWTNaKzckNyMrLSU3IysjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhIFxcXFw3JCwjJjckXFxcIistJDcgKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK0AkIFxcXFw3JCsmJCwjJjckXFxcIlxcXCJcXFwiIFgrJyU0XFxcIjZdXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3LiojIFxcXCIgW1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNycqIyBcXFwiNygsKSY3JyojIFxcXCI3KFxcXCIrQSQuOFxcXCJcXFwiMjgzOSsxJTcvKyclNCM2XiMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhISBcXFxcNzIrJiQsIyY3MlxcXCJcXFwiXFxcIiBYK28kIFxcXFwhIFxcXFw3LiwjJjcuXFxcIistJDcyKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLEAmISBcXFxcNy4sIyY3LlxcXCIrLSQ3MisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMF9cXFwiXFxcIjEhM2AqIyBcXFwiNzNcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjBhXFxcIlxcXCIxITNiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwY1xcXCJcXFwiMSEzZFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNyEqKSBcXFwiMGVcXFwiXFxcIjEhM2ZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDcpKlxceDk1IFxcXCIuRlxcXCJcXFwiMkYzRypcXHg4OSBcXFwiLkpcXFwiXFxcIjJKM0sqfSBcXFwiLkxcXFwiXFxcIjJMM00qcSBcXFwiLllcXFwiXFxcIjJZM1oqZSBcXFwiLlBcXFwiXFxcIjJQM1EqWSBcXFwiLkhcXFwiXFxcIjJIM0kqTSBcXFwiLkBcXFwiXFxcIjJAM0EqQSBcXFwiLmdcXFwiXFxcIjJnM2gqNSBcXFwiLlJcXFwiXFxcIjJSM1MqKSBcXFwiLk5cXFwiXFxcIjJOM08rXFx4OUUkLFxceDlCJjcpKlxceDk1IFxcXCIuRlxcXCJcXFwiMkYzRypcXHg4OSBcXFwiLkpcXFwiXFxcIjJKM0sqfSBcXFwiLkxcXFwiXFxcIjJMM00qcSBcXFwiLllcXFwiXFxcIjJZM1oqZSBcXFwiLlBcXFwiXFxcIjJQM1EqWSBcXFwiLkhcXFwiXFxcIjJIM0kqTSBcXFwiLkBcXFwiXFxcIjJAM0EqQSBcXFwiLmdcXFwiXFxcIjJnM2gqNSBcXFwiLlJcXFwiXFxcIjJSM1MqKSBcXFwiLk5cXFwiXFxcIjJOM09cXFwiXFxcIlxcXCIgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3KSpcXHg4OSBcXFwiLkZcXFwiXFxcIjJGM0cqfSBcXFwiLkxcXFwiXFxcIjJMM00qcSBcXFwiLllcXFwiXFxcIjJZM1oqZSBcXFwiLlBcXFwiXFxcIjJQM1EqWSBcXFwiLkhcXFwiXFxcIjJIM0kqTSBcXFwiLkBcXFwiXFxcIjJAM0EqQSBcXFwiLmdcXFwiXFxcIjJnM2gqNSBcXFwiLlJcXFwiXFxcIjJSM1MqKSBcXFwiLk5cXFwiXFxcIjJOM08rXFx4OTIkLFxceDhGJjcpKlxceDg5IFxcXCIuRlxcXCJcXFwiMkYzRyp9IFxcXCIuTFxcXCJcXFwiMkwzTSpxIFxcXCIuWVxcXCJcXFwiMlkzWiplIFxcXCIuUFxcXCJcXFwiMlAzUSpZIFxcXCIuSFxcXCJcXFwiMkgzSSpNIFxcXCIuQFxcXCJcXFwiMkAzQSpBIFxcXCIuZ1xcXCJcXFwiMmczaCo1IFxcXCIuUlxcXCJcXFwiMlIzUyopIFxcXCIuTlxcXCJcXFwiMk4zT1xcXCJcXFwiXFxcIiBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5UXFxcIlxcXCIyVDNVKlxceEUzIFxcXCIuVlxcXCJcXFwiMlYzVypcXHhENyBcXFwiLmlcXFwiXFxcIjJpM2oqXFx4Q0IgXFxcIi5rXFxcIlxcXCIyazNsKlxceEJGIFxcXCIuOlxcXCJcXFwiMjozOypcXHhCMyBcXFwiLkRcXFwiXFxcIjJEM0UqXFx4QTcgXFxcIi4yXFxcIlxcXCIyMjMzKlxceDlCIFxcXCIuOFxcXCJcXFwiMjgzOSpcXHg4RiBcXFwiLm1cXFwiXFxcIjJtM24qXFx4ODMgXFxcIjcmKn0gXFxcIi40XFxcIlxcXCIyNDM1KnEgXFxcIi5vXFxcIlxcXCIybzNwKmUgXFxcIi5xXFxcIlxcXCIycTNyKlkgXFxcIi42XFxcIlxcXCIyNjM3Kk0gXFxcIi4+XFxcIlxcXCIyPjM/KkEgXFxcIi5zXFxcIlxcXCIyczN0KjUgXFxcIi51XFxcIlxcXCIydTN2KikgXFxcIjcnKiMgXFxcIjcoXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3KSpcXHUwMTJCIFxcXCIuRlxcXCJcXFwiMkYzRypcXHUwMTFGIFxcXCIuSlxcXCJcXFwiMkozSypcXHUwMTEzIFxcXCIuTFxcXCJcXFwiMkwzTSpcXHUwMTA3IFxcXCIuWVxcXCJcXFwiMlkzWipcXHhGQiBcXFwiLlBcXFwiXFxcIjJQM1EqXFx4RUYgXFxcIi5IXFxcIlxcXCIySDNJKlxceEUzIFxcXCIuQFxcXCJcXFwiMkAzQSpcXHhENyBcXFwiLmdcXFwiXFxcIjJnM2gqXFx4Q0IgXFxcIi5SXFxcIlxcXCIyUjNTKlxceEJGIFxcXCIuTlxcXCJcXFwiMk4zTypcXHhCMyBcXFwiLlRcXFwiXFxcIjJUM1UqXFx4QTcgXFxcIi5WXFxcIlxcXCIyVjNXKlxceDlCIFxcXCIuaVxcXCJcXFwiMmkzaipcXHg4RiBcXFwiLmtcXFwiXFxcIjJrM2wqXFx4ODMgXFxcIi44XFxcIlxcXCIyODM5KncgXFxcIi5tXFxcIlxcXCIybTNuKmsgXFxcIjcmKmUgXFxcIi40XFxcIlxcXCIyNDM1KlkgXFxcIi5vXFxcIlxcXCIybzNwKk0gXFxcIi5xXFxcIlxcXCIycTNyKkEgXFxcIi42XFxcIlxcXCIyNjM3KjUgXFxcIi5zXFxcIlxcXCIyczN0KikgXFxcIi51XFxcIlxcXCIydTN2K1xcdTAxMzQkLFxcdTAxMzEmNykqXFx1MDEyQiBcXFwiLkZcXFwiXFxcIjJGM0cqXFx1MDExRiBcXFwiLkpcXFwiXFxcIjJKM0sqXFx1MDExMyBcXFwiLkxcXFwiXFxcIjJMM00qXFx1MDEwNyBcXFwiLllcXFwiXFxcIjJZM1oqXFx4RkIgXFxcIi5QXFxcIlxcXCIyUDNRKlxceEVGIFxcXCIuSFxcXCJcXFwiMkgzSSpcXHhFMyBcXFwiLkBcXFwiXFxcIjJAM0EqXFx4RDcgXFxcIi5nXFxcIlxcXCIyZzNoKlxceENCIFxcXCIuUlxcXCJcXFwiMlIzUypcXHhCRiBcXFwiLk5cXFwiXFxcIjJOM08qXFx4QjMgXFxcIi5UXFxcIlxcXCIyVDNVKlxceEE3IFxcXCIuVlxcXCJcXFwiMlYzVypcXHg5QiBcXFwiLmlcXFwiXFxcIjJpM2oqXFx4OEYgXFxcIi5rXFxcIlxcXCIyazNsKlxceDgzIFxcXCIuOFxcXCJcXFwiMjgzOSp3IFxcXCIubVxcXCJcXFwiMm0zbiprIFxcXCI3JiplIFxcXCIuNFxcXCJcXFwiMjQzNSpZIFxcXCIub1xcXCJcXFwiMm8zcCpNIFxcXCIucVxcXCJcXFwiMnEzcipBIFxcXCIuNlxcXCJcXFwiMjYzNyo1IFxcXCIuc1xcXCJcXFwiMnMzdCopIFxcXCIudVxcXCJcXFwiMnUzdlxcXCJcXFwiXFxcIiBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC5QXFxcIlxcXCIyUDNRKzElNy8rJyU0IzZ3IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC40XFxcIlxcXCIyNDM1KzElNy8rJyU0IzZ4IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC4+XFxcIlxcXCIyPjM/KzElNy8rJyU0IzZ5IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC5UXFxcIlxcXCIyVDNVKzElNy8rJyU0IzZ6IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC5WXFxcIlxcXCIyVjNXKzElNy8rJyU0IzZ7IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEua1xcXCJcXFwiMmszbCsxJDcvKyclNFxcXCI2fFxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvKzckLmlcXFwiXFxcIjJpM2orJyU0XFxcIjZ9XFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuRFxcXCJcXFwiMkQzRSsxJTcvKyclNCM2fiMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuMlxcXCJcXFwiMjIzMysxJTcvKyclNCM2fyMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuOFxcXCJcXFwiMjgzOSsxJTcvKyclNCM2XFx4ODAjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvKzEkNyYrJyU0XFxcIjZcXHg4MVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcmKzEkNy8rJyU0XFxcIjZcXHg4MVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc9K1ckIFxcXFw3RyopIFxcXCI3SyojIFxcXCI3RiwvJjdHKikgXFxcIjdLKiMgXFxcIjdGXFxcIistJTc+KyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjBcXHg4MlxcXCJcXFwiMSEzXFx4ODMqQSBcXFwiMFxceDg0XFxcIlxcXCIxITNcXHg4NSo1IFxcXCIwXFx4ODZcXFwiXFxcIjEhM1xceDg3KikgXFxcIjczKiMgXFxcIjcuXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITcvK1UkNyYrSyUgXFxcXDdKKiMgXFxcIjdLLCkmN0oqIyBcXFwiN0tcXFwiKy0lNyYrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytgJDcmK1YlISBcXFxcN0oqIyBcXFwiN0ssKSY3SiojIFxcXCI3S1xcXCIrISAoJSsyJTcmKyglNCQ2XFx4ODgkISElJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNy4qRyBcXFwiLkxcXFwiXFxcIjJMM00qOyBcXFwiMFxceDg5XFxcIlxcXCIxITNcXHg4QSovIFxcXCIwXFx4ODZcXFwiXFxcIjEhM1xceDg3KiMgXFxcIjczXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLm1cXFwiXFxcIjJtM24rSyQwXFx4OEJcXFwiXFxcIjEhM1xceDhDKjUgXFxcIjBcXHg4RFxcXCJcXFwiMSEzXFx4OEUqKSBcXFwiMFxceDhGXFxcIlxcXCIxITNcXHg5MCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdOK1EkLjhcXFwiXFxcIjI4MzkrQSU3TyojIFxcXCIgWysxJTdTKyclNCQ2XFx4OTEkICUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN04rayQuOFxcXCJcXFwiMjgzOStbJTdPKiMgXFxcIiBbK0slN1MrQSU3Xys3JTdsKiMgXFxcIiBbKyclNCY2XFx4OTImICUkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHg5M1xcXCJcXFwiMSQzXFx4OTQqKSBcXFwiL1xceDk1XFxcIlxcXCIxIzNcXHg5NisnIDQhNlxceDk3ISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdQK2IkIS44XFxcIlxcXCIyODM5Ky0kN1IrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrNyUuOlxcXCJcXFwiMjozOysnJTQjNlxceDk4IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcNysqKSBcXFwiNy0qIyBcXFwiN1ErMiQsLyY3KyopIFxcXCI3LSojIFxcXCI3UVxcXCJcXFwiXFxcIiBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuPFxcXCJcXFwiMjwzPSpxIFxcXCIuPlxcXCJcXFwiMj4zPyplIFxcXCIuQFxcXCJcXFwiMkAzQSpZIFxcXCIuQlxcXCJcXFwiMkIzQypNIFxcXCIuRFxcXCJcXFwiMkQzRSpBIFxcXCIuMlxcXCJcXFwiMjIzMyo1IFxcXCIuNlxcXCJcXFwiMjYzNyopIFxcXCIuNFxcXCJcXFwiMjQzNVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNysqXyBcXFwiNy0qWSBcXFwiLjxcXFwiXFxcIjI8Mz0qTSBcXFwiLj5cXFwiXFxcIjI+Mz8qQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkJcXFwiXFxcIjJCM0MqKSBcXFwiLkRcXFwiXFxcIjJEM0UsZSY3KypfIFxcXCI3LSpZIFxcXCIuPFxcXCJcXFwiMjwzPSpNIFxcXCIuPlxcXCJcXFwiMj4zPypBIFxcXCIuQFxcXCJcXFwiMkAzQSo1IFxcXCIuQlxcXCJcXFwiMkIzQyopIFxcXCIuRFxcXCJcXFwiMkQzRVxcXCIrJiA0ITZcXHg5OSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdUK04kIS44XFxcIlxcXCIyODM5Ky0kN14rIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3VSopIFxcXCI3XFxcXCojIFxcXCI3WCsmIDQhNlxceDlBISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFwhN1YrMyQuSlxcXCJcXFwiMkozSysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw+JiE3ViszJC5KXFxcIlxcXCIySjNLKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIitHJDdXKz0lLkpcXFwiXFxcIjJKM0sqIyBcXFwiIFsrJyU0IzZcXHg5QiMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDBcXHg5Q1xcXCJcXFwiMSEzXFx4OUQrLCQsKSYwXFx4OUNcXFwiXFxcIjEhM1xceDlEXFxcIlxcXCJcXFwiIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEwJFxcXCJcXFwiMSEzJStBJCBcXFxcMFxceDlFXFxcIlxcXCIxITNcXHg5RiwpJjBcXHg5RVxcXCJcXFwiMSEzXFx4OUZcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLm9cXFwiXFxcIjJvM3ArQSQ3WSs3JS5xXFxcIlxcXCIycTNyKyclNCM2XFx4QTAjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3WitcXHhCRiQuOFxcXCJcXFwiMjgzOStcXHhBRiU3WitcXHhBNSUuOFxcXCJcXFwiMjgzOStcXHg5NSU3WitcXHg4QiUuOFxcXCJcXFwiMjgzOSt7JTdaK3ElLjhcXFwiXFxcIjI4MzkrYSU3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJy0lJC0jIFgkLCMgWCQrIyBYJCojIFgkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwODM4IFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrXFx4QUYkN1orXFx4QTUlLjhcXFwiXFxcIjI4MzkrXFx4OTUlN1orXFx4OEIlLjhcXFwiXFxcIjI4MzkreyU3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScsJSQsIyBYJCsjIFgkKiMgWCQpIyBYJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTA3OTUgXFxcIiEuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMitcXHg5NSQ3WitcXHg4QiUuOFxcXCJcXFwiMjgzOSt7JTdaK3ElLjhcXFwiXFxcIjI4MzkrYSU3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyolJCojIFgkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNzBDIFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIreyQ3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScoJSQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNjlEIFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrYSQ3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyYlJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDY0OCBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK0ckN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNjBEIFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrLSQ3WysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCpcXHUwNUVDIFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCpcXHUwNUNCIFxcXCIhN1orXFx4QTUkLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrXFx4OTUlN1orXFx4OEIlLjhcXFwiXFxcIjI4MzkreyU3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScrJSQrIyBYJCojIFgkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNTM4IFxcXCIhN1orXFx4QjYkIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4OEIlLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIreyU3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScqJSQqIyBYJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDQ5NCBcXFwiITdaK1xceEM3JCEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceDlDJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK3ElLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrYSU3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyklJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDNERiBcXFwiITdaK1xceEQ4JCEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceEFEJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceDgyJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1clLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnKCUkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDMxOSBcXFwiITdaK1xceEU5JCEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceEJFJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceDkzJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK2glIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrPSUuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMistJTdbKyMlJyclJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwMjQyIFxcXCIhN1orXFx1MDExNCQhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhFOSUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhCRSUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHg5MyUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytoJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKz0lLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrLSU3WisjJScoJSQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwMTQwIFxcXCIhN1orXFx1MDEzNSQhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHUwMTBBJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceERGJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceEI0JSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceDg5JSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK14lIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrMyUuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMisjJScoJSQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCsmIDQhNlxceEEzISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNyMrUyQ3IyojIFxcXCIgWytDJTcjKiMgXFxcIiBbKzMlNyMqIyBcXFwiIFsrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1orPSQuOFxcXCJcXFwiMjgzOSstJTdaKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFgqIyBcXFwiN1xcXFxcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XSt1JC5KXFxcIlxcXCIySjNLK2UlN10rWyUuSlxcXCJcXFwiMkozSytLJTddK0ElLkpcXFwiXFxcIjJKM0srMSU3XSsnJTQnNlxceEE0JyAlJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHhBNVxcXCJcXFwiMlxceEE1M1xceEE2KzMkMFxceEE3XFxcIlxcXCIxITNcXHhBOCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCpcXHhBMCBcXFwiIS5cXHhBOVxcXCJcXFwiMlxceEE5M1xceEFBKz0kMFxceEFCXFxcIlxcXCIxITNcXHhBQystJTchKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFgqbyBcXFwiIS5cXHhBRFxcXCJcXFwiMlxceEFEM1xceEFFKzckNyErLSU3ISsjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYKkQgXFxcIiEwXFx4QUZcXFwiXFxcIjEhM1xceEIwKy0kNyErIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiNyFcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhNyEqIyBcXFwiIFsrYyQ3ISojIFxcXCIgWytTJTchKiMgXFxcIiBbK0MlNyEqIyBcXFwiIFsrMyU3ISojIFxcXCIgWysjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCsnIDQhNlxceEIxISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFwhLjJcXFwiXFxcIjIyMzMrLSQ3YCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw+JiEuMlxcXCJcXFwiMjIzMystJDdgKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN2EqQSBcXFwiN2IqOyBcXFwiN2MqNSBcXFwiN2QqLyBcXFwiN2UqKSBcXFwiN2YqIyBcXFwiN2dcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4QjJcXFwiXFxcIjEqM1xceEIzK2IkL1xceEI0XFxcIlxcXCIxIzNcXHhCNSpHIFxcXCIvXFx4QjZcXFwiXFxcIjEjM1xceEI3KjsgXFxcIi9cXHhCOFxcXCJcXFwiMSQzXFx4QjkqLyBcXFwiL1xceEJBXFxcIlxcXCIxIzNcXHhCQiojIFxcXCI3NisoJTRcXFwiNlxceEJDXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhCRFxcXCJcXFwiMSUzXFx4QkUrSiQvXFx4QkZcXFwiXFxcIjElM1xceEMwKi8gXFxcIi9cXHhDMVxcXCJcXFwiMVxcXCIzXFx4QzIqIyBcXFwiNzYrKCU0XFxcIjZcXHhDM1xcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4QzRcXFwiXFxcIjEnM1xceEM1KzIkN1xceDhGKyglNFxcXCI2XFx4QzZcXFwiISAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEM3XFxcIlxcXCIxJDNcXHhDOCsyJDdcXHhFRisoJTRcXFwiNlxceEM5XFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhDQVxcXCJcXFwiMSYzXFx4Q0IrMiQ3VCsoJTRcXFwiNlxceENDXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhDRFxcXCJcXFwiMVxcXCIzXFx4Q0UrUiQhLj5cXFwiXFxcIjI+Mz8rLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysnJTRcXFwiNlxceENGXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN2grVCQhLj5cXFwiXFxcIjI+Mz8rLSQ3aSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWyspJTRcXFwiNlxceEQwXFxcIlxcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDdqKyYkLCMmN2pcXFwiXFxcIlxcXCIgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3aismJCwjJjdqXFxcIlxcXCJcXFwiIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN2sqKSBcXFwiNysqIyBcXFwiNy1cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5vXFxcIlxcXCIybzNwKmUgXFxcIi5xXFxcIlxcXCIycTNyKlkgXFxcIi40XFxcIlxcXCIyNDM1Kk0gXFxcIi44XFxcIlxcXCIyODM5KkEgXFxcIi48XFxcIlxcXCIyPDM9KjUgXFxcIi5AXFxcIlxcXCIyQDNBKikgXFxcIi5CXFxcIlxcXCIyQjNDXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLjZcXFwiXFxcIjI2MzcrdSQ3bStrJSBcXFxcIS48XFxcIlxcXCIyPDM9Ky0kN20rIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLjxcXFwiXFxcIjI8Mz0rLSQ3bSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITduK0MkLj5cXFwiXFxcIjI+Mz8rMyU3byspJTQjNlxceEQxI1xcXCJcXFwiICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3cCopIFxcXCI3KyojIFxcXCI3LSsyJCwvJjdwKikgXFxcIjcrKiMgXFxcIjctXFxcIlxcXCJcXFwiIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcN3AqKSBcXFwiNysqIyBcXFwiNy0sLyY3cCopIFxcXCI3KyojIFxcXCI3LVxcXCJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5vXFxcIlxcXCIybzNwKmUgXFxcIi5xXFxcIlxcXCIycTNyKlkgXFxcIi40XFxcIlxcXCIyNDM1Kk0gXFxcIi42XFxcIlxcXCIyNjM3KkEgXFxcIi44XFxcIlxcXCIyODM5KjUgXFxcIi5AXFxcIlxcXCIyQDNBKikgXFxcIi5CXFxcIlxcXCIyQjNDXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4OTAqIyBcXFwiN3JcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OEYrSyQ3JytBJTdzKzclNycrLSU3XFx4ODQrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdNKiMgXFxcIjd0XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN38rRyQuOFxcXCJcXFwiMjgzOSs3JTd1KiMgXFxcIjd4KyclNCM2XFx4RDIjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITd2KiMgXFxcIjd3K04kIS42XFxcIlxcXCIyNjM3Ky0kN1xceDgzKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEQzXFxcIlxcXCIyXFx4RDMzXFx4RDQrPSQ3XFx4ODArMyU3dyojIFxcXCIgWysjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLjRcXFwiXFxcIjI0MzUrLSQ3eysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITd6KzUkIFxcXFw3eSwjJjd5XFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNyoqKSBcXFwiNysqIyBcXFwiNy1cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcrKlxceDhGIFxcXCI3LSpcXHg4OSBcXFwiLjJcXFwiXFxcIjIyMzMqfSBcXFwiLjZcXFwiXFxcIjI2MzcqcSBcXFwiLjhcXFwiXFxcIjI4MzkqZSBcXFwiLjpcXFwiXFxcIjI6MzsqWSBcXFwiLjxcXFwiXFxcIjI8Mz0qTSBcXFwiLj5cXFwiXFxcIjI+Mz8qQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkJcXFwiXFxcIjJCM0MqKSBcXFwiLkRcXFwiXFxcIjJEM0VcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3fCtrJCBcXFxcIS40XFxcIlxcXCIyNDM1Ky0kN3wrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLjRcXFwiXFxcIjI0MzUrLSQ3fCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDd+LCMmN35cXFwiK2skIFxcXFwhLjJcXFwiXFxcIjIyMzMrLSQ3fSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw+JiEuMlxcXCJcXFwiMjIzMystJDd9KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3fiwjJjd+XFxcIlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNysqdyBcXFwiNy0qcSBcXFwiLjhcXFwiXFxcIjI4MzkqZSBcXFwiLjpcXFwiXFxcIjI6MzsqWSBcXFwiLjxcXFwiXFxcIjI8Mz0qTSBcXFwiLj5cXFwiXFxcIjI+Mz8qQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkJcXFwiXFxcIjJCM0MqKSBcXFwiLkRcXFwiXFxcIjJEM0VcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFxcIitcXHg4RCQgXFxcXDdcXFwiKkcgXFxcIjchKkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5GXFxcIlxcXCIyRjNHKikgXFxcIi5KXFxcIlxcXCIySjNLLE0mN1xcXCIqRyBcXFwiNyEqQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkZcXFwiXFxcIjJGM0cqKSBcXFwiLkpcXFwiXFxcIjJKM0tcXFwiKyclNFxcXCI2XFx4RDVcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHg4MSojIFxcXCI3XFx4ODJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhN08rMyQuOlxcXCJcXFwiMjozOysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWystJDdTKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDcrKlxceDgzIFxcXCI3LSp9IFxcXCIuQlxcXCJcXFwiMkIzQypxIFxcXCIuRFxcXCJcXFwiMkQzRSplIFxcXCIuMlxcXCJcXFwiMjIzMypZIFxcXCIuOFxcXCJcXFwiMjgzOSpNIFxcXCIuOlxcXCJcXFwiMjozOypBIFxcXCIuPFxcXCJcXFwiMjwzPSo1IFxcXCIuPlxcXCJcXFwiMj4zPyopIFxcXCIuQFxcXCJcXFwiMkAzQStcXHg4QyQsXFx4ODkmNysqXFx4ODMgXFxcIjctKn0gXFxcIi5CXFxcIlxcXCIyQjNDKnEgXFxcIi5EXFxcIlxcXCIyRDNFKmUgXFxcIi4yXFxcIlxcXCIyMjMzKlkgXFxcIi44XFxcIlxcXCIyODM5Kk0gXFxcIi46XFxcIlxcXCIyOjM7KkEgXFxcIi48XFxcIlxcXCIyPDM9KjUgXFxcIi4+XFxcIlxcXCIyPjM/KikgXFxcIi5AXFxcIlxcXCIyQDNBXFxcIlxcXCJcXFwiIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcN3ksIyY3eVxcXCJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4OTVcXFwiXFxcIjEjM1xceEQ2K3kkLjRcXFwiXFxcIjI0MzUraSUgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCtQJS5KXFxcIlxcXCIySjNLK0AlIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrJyU0JTZcXHhENyUgJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEQ4XFxcIlxcXCIyXFx4RDgzXFx4RDlcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhEQVxcXCJcXFwiMlxceERBM1xceERCXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RENcXFwiXFxcIjJcXHhEQzNcXHhERFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceERFXFxcIlxcXCIyXFx4REUzXFx4REZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhFMFxcXCJcXFwiMlxceEUwM1xceEUxXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RTJcXFwiXFxcIjJcXHhFMjNcXHhFM1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEU0XFxcIlxcXCIyXFx4RTQzXFx4RTVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhFNlxcXCJcXFwiMlxceEU2M1xceEU3XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RThcXFwiXFxcIjJcXHhFODNcXHhFOVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEVBXFxcIlxcXCIyXFx4RUEzXFx4RUJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4ODUqUyBcXFwiN1xceDg2Kk0gXFxcIjdcXHg4OCpHIFxcXCI3XFx4ODkqQSBcXFwiN1xceDhBKjsgXFxcIjdcXHg4Qio1IFxcXCI3XFx4OEMqLyBcXFwiN1xceDhEKikgXFxcIjdcXHg4RSojIFxcXCI3NismIDQhNlxceEVDISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDg0K0skNycrQSU3XFx4OTErNyU3JystJTdcXHg5MysjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5MisnIDQhNlxceEVEISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITchKzckNyErLSU3ISsjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3KipBIFxcXCI3Kyo7IFxcXCI3LSo1IFxcXCI3MyovIFxcXCI3NCopIFxcXCI3JyojIFxcXCI3KCxHJjcqKkEgXFxcIjcrKjsgXFxcIjctKjUgXFxcIjczKi8gXFxcIjc0KikgXFxcIjcnKiMgXFxcIjcoXFxcIismIDQhNlxceEVFISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEI1K18kIFxcXFwhN0ErLSQ3XFx4QjUrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3XFx4QjUrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzkrUiQhLjpcXFwiXFxcIjI6MzsrLSQ3OSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysnJTRcXFwiNlxceEVGXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzoqaiBcXFwiITdcXHg5NytfJCBcXFxcITdBKy0kN1xceDk3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceDk3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCsmIDQhNlxceEYwISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN0wqIyBcXFwiN1xceDk4K2MkIFxcXFwhN0IrLSQ3XFx4OUErIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4OUErIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx4RjFcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTkqIyBcXFwiIFsrQSQ3QCs3JTdNKy0lNz8rIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITc2K18kIFxcXFwhNy4rLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3ListJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCI3SCsnIDQhNlxceEYyISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceDlCKikgXFxcIjdcXHg5QyojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4RjNcXFwiXFxcIjEhM1xceEY0KzwkNzwrMiU3XFx4OUUrKCU0IzZcXHhGNSMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhGNlxcXCJcXFwiMSczXFx4RjcrPCQ3PCsyJTdcXHg5RCsoJTQjNlxceEY4IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrJyA0ITZcXHhGOSEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4RkFcXFwiXFxcIjJcXHhGQTNcXHhGQit4JCEuSlxcXCJcXFwiMkozSytTJDchKiMgXFxcIiBbK0MlNyEqIyBcXFwiIFsrMyU3ISojIFxcXCIgWysjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyU0XFxcIjZcXHhGQ1xcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2K04kITc8Ky0kN1xceEEwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyklNFxcXCI2XFx4RkRcXFwiXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNzYqKSBcXFwiN1QqIyBcXFwiN0hcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QTIrXyQgXFxcXCE3QistJDdcXHhBMysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhBMysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4RkVcXFwiXFxcIjEmM1xceEZGKkcgXFxcIi9cXHUwMTAwXFxcIlxcXCIxJzNcXHUwMTAxKjsgXFxcIi9cXHUwMTAyXFxcIlxcXCIxJDNcXHUwMTAzKi8gXFxcIi9cXHUwMTA0XFxcIlxcXCIxJTNcXHUwMTA1KiMgXFxcIjc2KyYgNCE2XFx1MDEwNiEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEE0KiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTA3XFxcIlxcXCIxKDNcXHUwMTA4K08kNzwrRSUvXFx1MDEwOVxcXCJcXFwiMSgzXFx1MDEwQSovIFxcXCIvXFx1MDEwQlxcXCJcXFwiMSgzXFx1MDEwQyojIFxcXCI3NisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrXyQgXFxcXCE3QSstJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrJyA0ITZcXHUwMTBEISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhBOCsmIDQhNlxcdTAxMEUhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QTkrcyQ3OytpJTdcXHhBRStfJSBcXFxcITdCKy0kN1xceEFGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEFGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhBQSojIFxcXCI3XFx4QUJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi9cXHUwMTBGXFxcIlxcXCIxJDNcXHUwMTEwKlMgXFxcIi9cXHUwMTExXFxcIlxcXCIxJTNcXHUwMTEyKkcgXFxcIi9cXHUwMTEzXFxcIlxcXCIxJTNcXHUwMTE0KjsgXFxcIi9cXHUwMTE1XFxcIlxcXCIxJTNcXHUwMTE2Ki8gXFxcIi9cXHUwMTE3XFxcIlxcXCIxKzNcXHUwMTE4KiMgXFxcIjdcXHhBQ1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiL1xcdTAxMTlcXFwiXFxcIjEnM1xcdTAxMUEqLyBcXFwiL1xcdTAxMUJcXFwiXFxcIjEpM1xcdTAxMUMqIyBcXFwiN1xceEFDXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3NiojIFxcXCI3XFx4QURcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDExRFxcXCJcXFwiMVxcXCIzXFx1MDExRSstJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QUMqIyBcXFwiNzZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3Nis3JDc8Ky0lN1xceEIwKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjc2KiMgXFxcIjdIXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEIyKzckNy4rLSU3XFx4OEYrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKycgNCE2XFx1MDExRiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OUQrJyA0ITZcXHUwMTIwISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhCNStkJCBcXFxcITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisoJTRcXFwiNlxcdTAxMjFcXFwiISElJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITc3K2skIFxcXFwhLkpcXFwiXFxcIjJKM0srLSQ3NysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw+JiEuSlxcXCJcXFwiMkozSystJDc3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN0wqIyBcXFwiN1xceDk4K2MkIFxcXFwhN0IrLSQ3XFx4QjcrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4QjcrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx1MDEyMlxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEI4KiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTIzXFxcIlxcXCIxIzNcXHUwMTI0KzwkNzwrMiU3NisoJTQjNlxcdTAxMjUjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCsnIDQhNlxcdTAxMjYhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDlEKycgNCE2XFx1MDEyNyEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDdcXHg5OSwjJjdcXHg5OVxcXCIrXFx4ODEkN0ArdyU3TSttJTc/K2MlIFxcXFwhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNCU2XFx1MDEyOCUgJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEJEXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMjlcXFwiXFxcIjEmM1xcdTAxMkErcyQ3LitpJTdcXHhDMCtfJSBcXFxcITdBKy0kN1xceEMwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceEMwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqIyBcXFwiN1xceEJFXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrcyQ3LitpJTdcXHhCRitfJSBcXFxcITdBKy0kN1xceEJGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceEJGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3Nis9JDc8KzMlNzYqIyBcXFwiN0grIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEMxKkcgXFxcIjdcXHhDMypBIFxcXCI3XFx4QzUqOyBcXFwiN1xceEM3KjUgXFxcIjdcXHhDOCovIFxcXCI3XFx4QzkqKSBcXFwiN1xceENBKiMgXFxcIjdcXHhCRlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTJCXFxcIlxcXCIxJTNcXHUwMTJDKzckNzwrLSU3XFx4QzIrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdJKycgNCE2XFx1MDEyRCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEyRVxcXCJcXFwiMSYzXFx1MDEyRitcXHhBNSQ3PCtcXHg5QiU3RCtcXHg5MSU3XFx4QzQrXFx4ODclIFxcXFwhIFxcXFw3JysmJCwjJjcnXFxcIlxcXCJcXFwiIFgrLSQ3XFx4QzQrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsRyYhIFxcXFw3JysmJCwjJjcnXFxcIlxcXCJcXFwiIFgrLSQ3XFx4QzQrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKy0lN0UrIyUnJiUkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN3QqIyBcXFwiN3dcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEzMFxcXCJcXFwiMSUzXFx1MDEzMSs3JDc8Ky0lN1xceEM2KyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3SSsnIDQhNlxcdTAxMzIhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMzNcXFwiXFxcIjEmM1xcdTAxMzQrPCQ3PCsyJTdJKyglNCM2XFx1MDEzNSMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTM2XFxcIlxcXCIxJTNcXHUwMTM3K18kNzwrVSUhL1xcdTAxMzhcXFwiXFxcIjEkM1xcdTAxMzkrJiA0ITZcXHUwMTNBISAlKjQgXFxcIiEvXFx1MDEzQlxcXCJcXFwiMSUzXFx1MDEzQysmIDQhNlxcdTAxM0QhICUrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTNFXFxcIlxcXCIxKTNcXHUwMTNGK1QkNzwrSiUvXFx1MDE0MFxcXCJcXFwiMSMzXFx1MDE0MSovIFxcXCIvXFx1MDE0MlxcXCJcXFwiMSgzXFx1MDE0MyojIFxcXCI3NisoJTQjNlxcdTAxNDQjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE0NVxcXCJcXFwiMSMzXFx1MDE0NitcXHg5RSQ3PCtcXHg5NCU3RCtcXHg4QSUhN1xceENCK2skIFxcXFwhLkRcXFwiXFxcIjJEM0UrLSQ3XFx4Q0IrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLkRcXFwiXFxcIjJEM0UrLSQ3XFx4Q0IrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKy0lN0UrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE0N1xcXCJcXFwiMSgzXFx1MDE0OCovIFxcXCIvXFx1MDE0OVxcXCJcXFwiMSQzXFx1MDE0QSojIFxcXCI3NisnIDQhNlxcdTAxNEIhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrXyQgXFxcXCE3QSstJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceENFK0skNy4rQSU3XFx4Q0UrNyU3ListJTdcXHg4RisjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKycgNCE2XFx1MDE0QyEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RDArYyQgXFxcXCE3QSstJDdcXHhEMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHhEMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrJyU0XFxcIjZcXHUwMTREXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDk4K2MkIFxcXFwhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx1MDE0RVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdMKlQgXFxcIjdcXHg5OCpOIFxcXCIhN0AqIyBcXFwiIFsrPSQ3dCszJTc/KiMgXFxcIiBbKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFgrYyQgXFxcXCE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrJyU0XFxcIjZcXHUwMTRGXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEQzK2MkIFxcXFwhN0IrLSQ3XFx4RDQrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4RDQrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx1MDE1MFxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5NSsmIDQhNlxcdTAxNTEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE1MlxcXCJcXFwiMSgzXFx1MDE1Mys8JDc8KzIlNzYrKCU0IzZcXHUwMTU0IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYKmogXFxcIiEvXFx1MDE1NVxcXCJcXFwiMSYzXFx1MDE1Nis8JDc8KzIlNzYrKCU0IzZcXHUwMTU3IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYKjogXFxcIiEvXFx1MDE1OFxcXCJcXFwiMSozXFx1MDE1OSsmIDQhNlxcdTAxNUEhICUqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITc2K28kIFxcXFwhN0ErMiQ3NisoJTRcXFwiNlxcdTAxNUJcXFwiISAlJFxcXCIjIFhcXFwiIyBYLD0mITdBKzIkNzYrKCU0XFxcIjZcXHUwMTVCXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFxcXCIrKSU0XFxcIjZcXHUwMTVDXFxcIlxcXCIhICUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyA0ITZcXHUwMTVEISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhENytfJCBcXFxcITdBKy0kN1xceEQ3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceEQ3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5OCtfJCBcXFxcITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKycgNCE2XFx1MDE1RSEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4REErXyQgXFxcXCE3QistJDdcXHhEQisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhEQisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE1RlxcXCJcXFwiMSYzXFx1MDE2MCo7IFxcXCIvXFx1MDE2MVxcXCJcXFwiMSczXFx1MDE2MiovIFxcXCIvXFx1MDE2M1xcXCJcXFwiMSozXFx1MDE2NCojIFxcXCI3NismIDQhNlxcdTAxNjUhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE2NlxcXCJcXFwiMSYzXFx1MDE2Nys8JDc8KzIlN1xceERDKyglNCM2XFx1MDE2OCMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHg4MyBcXFwiIS9cXHhGNlxcXCJcXFwiMSczXFx4RjcrPCQ3PCsyJTdcXHg5RCsoJTQjNlxcdTAxNjkjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFgqUyBcXFwiIS9cXHUwMTZBXFxcIlxcXCIxKzNcXHUwMTZCKzwkNzwrMiU3XFx4OUQrKCU0IzZcXHUwMTZDIyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYKiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiL1xcdTAxNkRcXFwiXFxcIjErM1xcdTAxNkUqayBcXFwiL1xcdTAxNkZcXFwiXFxcIjEpM1xcdTAxNzAqXyBcXFwiL1xcdTAxNzFcXFwiXFxcIjEoM1xcdTAxNzIqUyBcXFwiL1xcdTAxNzNcXFwiXFxcIjEnM1xcdTAxNzQqRyBcXFwiL1xcdTAxNzVcXFwiXFxcIjEmM1xcdTAxNzYqOyBcXFwiL1xcdTAxNzdcXFwiXFxcIjEqM1xcdTAxNzgqLyBcXFwiL1xcdTAxNzlcXFwiXFxcIjEpM1xcdTAxN0EqIyBcXFwiNzZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcxKiMgXFxcIiBbXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITc2K28kIFxcXFwhN0ErMiQ3NisoJTRcXFwiNlxcdTAxNUJcXFwiISAlJFxcXCIjIFhcXFwiIyBYLD0mITdBKzIkNzYrKCU0XFxcIjZcXHUwMTVCXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFxcXCIrKSU0XFxcIjZcXHUwMTVDXFxcIlxcXCIhICUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyA0ITZcXHUwMTdCISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdMKiMgXFxcIjdcXHg5OCtjJCBcXFxcITdCKy0kN1xceEUwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEUwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxcdTAxN0NcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhCOCojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RTIrXyQgXFxcXCE3QSstJDdcXHhFMisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHhFMisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RTkrcyQ3LitpJTdcXHhFQytfJSBcXFxcITdCKy0kN1xceEUzKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEUzKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhFNCo7IFxcXCI3XFx4RTUqNSBcXFwiN1xceEU2Ki8gXFxcIjdcXHhFNyopIFxcXCI3XFx4RTgqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxN0RcXFwiXFxcIjEjM1xcdTAxN0UrPCQ3PCsyJTdcXHhFRisoJTQjNlxcdTAxN0YjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE4MFxcXCJcXFwiMSUzXFx1MDE4MSs8JDc8KzIlN1QrKCU0IzZcXHUwMTgyIyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxODNcXFwiXFxcIjEoM1xcdTAxODQrQiQ3PCs4JTdcXFxcKiMgXFxcIjdZKyglNCM2XFx1MDE4NSMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTg2XFxcIlxcXCIxJjNcXHUwMTg3KzwkNzwrMiU3NisoJTQjNlxcdTAxODgjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE4OVxcXCJcXFwiMSUzXFx1MDE4QStUJCE3PCs1JCBcXFxcNyEsIyY3IVxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyU0XFxcIjZcXHUwMThCXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEVBK0skNzsrQSU3Nis3JTc7Ky0lN1xceEVCKyMlJyUlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceDk1XFxcIlxcXCIxIzNcXHhENiojIFxcXCI3NisnIDQhNlxcdTAxOEMhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEI0XFxcIlxcXCIxIzNcXHUwMThEKkcgXFxcIi9cXHhCNlxcXCJcXFwiMSMzXFx1MDE4RSo7IFxcXCIvXFx4QkFcXFwiXFxcIjEjM1xcdTAxOEYqLyBcXFwiL1xceEI4XFxcIlxcXCIxJDNcXHUwMTkwKiMgXFxcIjc2KycgNCE2XFx1MDE5MSEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RUQrSCQhN0MrLSQ3XFx4RUUrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3VSopIFxcXCI3XFxcXCojIFxcXCI3WCsmIDQhNlxcdTAxOTIhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhNyEqIyBcXFwiIFsrYyQ3ISojIFxcXCIgWytTJTchKiMgXFxcIiBbK0MlNyEqIyBcXFwiIFsrMyU3ISojIFxcXCIgWysjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCsnIDQhNlxcdTAxOTMhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITchK0MkNyEqIyBcXFwiIFsrMyU3ISojIFxcXCIgWysjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYKycgNCE2XFx1MDE5NCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhCRFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5RCtkJCBcXFxcITdCKy0kN1xceEYyKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEYyKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisoJTRcXFwiNlxcdTAxOTVcXFwiISElJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4RjMqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxcdTAxOTZcXFwiXFxcIjJcXHUwMTk2M1xcdTAxOTcrTiQ3PCtEJS5cXHUwMTk4XFxcIlxcXCIyXFx1MDE5ODNcXHUwMTk5KikgXFxcIi5cXHUwMTlBXFxcIlxcXCIyXFx1MDE5QTNcXHUwMTlCKyglNCM2XFx1MDE5QyMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5RCtkJCBcXFxcITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisoJTRcXFwiNlxcdTAxOURcXFwiISElJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrNyQ3MCstJTdcXHhGNisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDcyKikgXFxcIjc0KiMgXFxcIjcuLC8mNzIqKSBcXFwiNzQqIyBcXFwiNy5cXFwiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDclLCMmNyVcXFwiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEY5Kz0kLjhcXFwiXFxcIjI4MzkrLSU3XFx4RkErIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTlFXFxcIlxcXCIxJTNcXHUwMTlGKikgXFxcIi9cXHUwMUEwXFxcIlxcXCIxJDNcXHUwMUExKycgNCE2XFx1MDFBMiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RkIrTiQhLjhcXFwiXFxcIjI4MzkrLSQ3XisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXFxcKikgXFxcIjdYKiMgXFxcIjdcXHg4MisnIDQhNlxcdTAxQTMhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3XFx4RkQqKSBcXFwiNy0qIyBcXFwiN1xceEZFLC8mN1xceEZEKikgXFxcIjctKiMgXFxcIjdcXHhGRVxcXCIrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xcXCIqUyBcXFwiNyEqTSBcXFwiLkZcXFwiXFxcIjJGM0cqQSBcXFwiLkpcXFwiXFxcIjJKM0sqNSBcXFwiLkhcXFwiXFxcIjJIM0kqKSBcXFwiLk5cXFwiXFxcIjJOM09cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5MXFxcIlxcXCIyTDNNKlxceDk1IFxcXCIuQlxcXCJcXFwiMkIzQypcXHg4OSBcXFwiLjxcXFwiXFxcIjI8Mz0qfSBcXFwiLlJcXFwiXFxcIjJSM1MqcSBcXFwiLlRcXFwiXFxcIjJUM1UqZSBcXFwiLlZcXFwiXFxcIjJWM1cqWSBcXFwiLlBcXFwiXFxcIjJQM1EqTSBcXFwiLkBcXFwiXFxcIjJAM0EqQSBcXFwiLkRcXFwiXFxcIjJEM0UqNSBcXFwiLjJcXFwiXFxcIjIyMzMqKSBcXFwiLj5cXFwiXFxcIjI+Mz9cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx1MDEwMCtoJC44XFxcIlxcXCIyODM5K1glN1xceEZBK04lIS5cXHUwMUE0XFxcIlxcXCIyXFx1MDFBNDNcXHUwMUE1Ky0kN1xceEVCKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMUE2XFxcIlxcXCIxJTNcXHUwMUE3KikgXFxcIi9cXHUwMUE4XFxcIlxcXCIxJDNcXHUwMUE5KycgNCE2XFx1MDFBMiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RUIrUSQvXFx4QjRcXFwiXFxcIjEjM1xceEI1KjcgXFxcIi9cXHhCNlxcXCJcXFwiMSMzXFx4QjcqKyBcXFwiIFxcXFw3KywjJjcrXFxcIisnJTRcXFwiNlxcdTAxQUFcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx1MDEwNCtcXHg4RiQuRlxcXCJcXFwiMkYzRyt/JTdcXHUwMTAzK3UlLkZcXFwiXFxcIjJGM0crZSU3XFx1MDEwMytbJS5GXFxcIlxcXCIyRjNHK0slN1xcdTAxMDMrQSUuRlxcXCJcXFwiMkYzRysxJTdcXHUwMTA1KyclNCk2XFx1MDFBQikgJSQpIyBYJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNyMrQSQ3Iys3JTcjKy0lNyMrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xcdTAxMDMrLSQ3XFx1MDEwMysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHUwMTAzKzckN1xcdTAxMDMrLSU3XFx1MDEwMysjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpXG4gICAgICAgIF0sXG5cbiAgICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLFxuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgICAgICA9IDAsXG4gICAgICAgIHBlZyRjYWNoZWRQb3MgICAgICAgID0gMCxcbiAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9LFxuICAgICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXG4gICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgID0gW10sXG4gICAgICAgIHBlZyRzaWxlbnRGYWlscyAgICAgID0gMCxcblxuICAgICAgICBwZWckcmVzdWx0O1xuXG4gICAgaWYgKFwic3RhcnRSdWxlXCIgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUluZGljZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcbiAgICAgIH1cblxuICAgICAgcGVnJHN0YXJ0UnVsZUluZGV4ID0gcGVnJHN0YXJ0UnVsZUluZGljZXNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRyZXBvcnRlZFBvcywgcGVnJGN1cnJQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICAgIHJldHVybiBwZWckcmVwb3J0ZWRQb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZSgpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5saW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtbigpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5jb2x1bW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24pIHtcbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihcbiAgICAgICAgbnVsbCxcbiAgICAgICAgW3sgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfV0sXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgbnVsbCwgcGVnJHJlcG9ydGVkUG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgICBmdW5jdGlvbiBhZHZhbmNlKGRldGFpbHMsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgICAgdmFyIHAsIGNoO1xuXG4gICAgICAgIGZvciAocCA9IHN0YXJ0UG9zOyBwIDwgZW5kUG9zOyBwKyspIHtcbiAgICAgICAgICBjaCA9IGlucHV0LmNoYXJBdChwKTtcbiAgICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGlmICghZGV0YWlscy5zZWVuQ1IpIHsgZGV0YWlscy5saW5lKys7IH1cbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwZWckY2FjaGVkUG9zICE9PSBwb3MpIHtcbiAgICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgPiBwb3MpIHtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zID0gMDtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZShwZWckY2FjaGVkUG9zRGV0YWlscywgcGVnJGNhY2hlZFBvcywgcG9zKTtcbiAgICAgICAgcGVnJGNhY2hlZFBvcyA9IHBvcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlZyRjYWNoZWRQb3NEZXRhaWxzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgICAgfVxuXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBleHBlY3RlZCwgcG9zKSB7XG4gICAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuXG4gICAgICAgIGV4cGVjdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIGlmIChhLmRlc2NyaXB0aW9uIDwgYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYS5kZXNjcmlwdGlvbiA+IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoaWxlIChpIDwgZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkW2kgLSAxXSA9PT0gZXhwZWN0ZWRbaV0pIHtcbiAgICAgICAgICAgIGV4cGVjdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ0VzY2FwZShzKSB7XG4gICAgICAgICAgZnVuY3Rpb24gaGV4KGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG5cbiAgICAgICAgICByZXR1cm4gc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgICAnXFxcXFxcXFwnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICAgICdcXFxcXCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICAgJ1xcXFx0JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgICAnXFxcXG4nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCAgICdcXFxcZicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICAgJ1xcXFxyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4ODAtXFx4RkZdL2csICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgnICArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTAxODAtXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUxMDgwLVxcdUZGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdScgICsgaGV4KGNoKTsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWREZXNjcyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICAgICAgZXhwZWN0ZWREZXNjLCBmb3VuZERlc2MsIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZXhwZWN0ZWREZXNjc1tpXSA9IGV4cGVjdGVkW2ldLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0ZWREZXNjID0gZXhwZWN0ZWQubGVuZ3RoID4gMVxuICAgICAgICAgID8gZXhwZWN0ZWREZXNjcy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICAgKyBleHBlY3RlZERlc2NzW2V4cGVjdGVkLmxlbmd0aCAtIDFdXG4gICAgICAgICAgOiBleHBlY3RlZERlc2NzWzBdO1xuXG4gICAgICAgIGZvdW5kRGVzYyA9IGZvdW5kID8gXCJcXFwiXCIgKyBzdHJpbmdFc2NhcGUoZm91bmQpICsgXCJcXFwiXCIgOiBcImVuZCBvZiBpbnB1dFwiO1xuXG4gICAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWREZXNjICsgXCIgYnV0IFwiICsgZm91bmREZXNjICsgXCIgZm91bmQuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcyksXG4gICAgICAgICAgZm91bmQgICAgICA9IHBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwb3MpIDogbnVsbDtcblxuICAgICAgaWYgKGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgIG1lc3NhZ2UgIT09IG51bGwgPyBtZXNzYWdlIDogYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgcG9zLFxuICAgICAgICBwb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIHBvc0RldGFpbHMuY29sdW1uXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRkZWNvZGUocykge1xuICAgICAgdmFyIGJjID0gbmV3IEFycmF5KHMubGVuZ3RoKSwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmNbaV0gPSBzLmNoYXJDb2RlQXQoaSkgLSAzMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVJ1bGUoaW5kZXgpIHtcbiAgICAgIHZhciBiYyAgICA9IHBlZyRieXRlY29kZVtpbmRleF0sXG4gICAgICAgICAgaXAgICAgPSAwLFxuICAgICAgICAgIGlwcyAgID0gW10sXG4gICAgICAgICAgZW5kICAgPSBiYy5sZW5ndGgsXG4gICAgICAgICAgZW5kcyAgPSBbXSxcbiAgICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICAgIHBhcmFtcywgaTtcblxuICAgICAgZnVuY3Rpb24gcHJvdGVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2JqZWN0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiID8gW10gOiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHdoaWxlIChpcCA8IGVuZCkge1xuICAgICAgICAgIHN3aXRjaCAoYmNbaXBdKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocHJvdGVjdChwZWckY29uc3RzW2JjW2lwICsgMV1dKSk7XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgc3RhY2subGVuZ3RoIC09IGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHN0YWNrLnNwbGljZSgtMiwgMSk7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnB1c2goc3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSBiY1tpcCArIDFdLCBiY1tpcCArIDFdKSk7XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKGlucHV0LnN1YnN0cmluZyhzdGFja1tzdGFjay5sZW5ndGggLSAxXSwgcGVnJGN1cnJQb3MpKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgICAgaXBzLnB1c2goaXApO1xuXG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAyICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlwICs9IDIgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBlZyRjdXJyUG9zKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5sZW5ndGgpID09PSBwZWckY29uc3RzW2JjW2lwICsgMV1dKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM107XG4gICAgICAgICAgICAgICAgaXAgKz0gNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdKTtcblxuICAgICAgICAgICAgICBpZiAocGVnJGNvbnN0c1tiY1tpcCArIDFdXS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCBiY1tpcCArIDFdKSk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSBwZWckY29uc3RzW2JjW2lwICsgMV1dLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJEZBSUxFRCk7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckY29uc3RzW2JjW2lwICsgMV1dKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIGJjW2lwICsgMV1dO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBwYXJhbXMgPSBiYy5zbGljZShpcCArIDQsIGlwICsgNCArIGJjW2lwICsgM10pO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmNbaXAgKyAzXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2ldID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIHBhcmFtc1tpXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdGFjay5zcGxpY2UoXG4gICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoIC0gYmNbaXAgKyAyXSxcbiAgICAgICAgICAgICAgICBiY1tpcCArIDJdLFxuICAgICAgICAgICAgICAgIHBlZyRjb25zdHNbYmNbaXAgKyAxXV0uYXBwbHkobnVsbCwgcGFyYW1zKVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChwZWckcGFyc2VSdWxlKGJjW2lwICsgMV0pKTtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wY29kZTogXCIgKyBiY1tpcF0gKyBcIi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVuZCA9IGVuZHMucG9wKCk7XG4gICAgICAgICAgaXAgPSBpcHMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YWNrWzBdO1xuICAgIH1cblxuXG4gICAgICBvcHRpb25zLmRhdGEgPSB7fTsgLy8gT2JqZWN0IHRvIHdoaWNoIGhlYWRlciBhdHRyaWJ1dGVzIHdpbGwgYmUgYXNzaWduZWQgZHVyaW5nIHBhcnNpbmdcblxuICAgICAgZnVuY3Rpb24gbGlzdCAoZmlyc3QsIHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIFtmaXJzdF0uY29uY2F0KHJlc3QpO1xuICAgICAgfVxuXG5cbiAgICBwZWckcmVzdWx0ID0gcGVnJHBhcnNlUnVsZShwZWckc3RhcnRSdWxlSW5kZXgpO1xuXG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHBlZyRmYWlsKHsgdHlwZTogXCJlbmRcIiwgZGVzY3JpcHRpb246IFwiZW5kIG9mIGlucHV0XCIgfSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihudWxsLCBwZWckbWF4RmFpbEV4cGVjdGVkLCBwZWckbWF4RmFpbFBvcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBTeW50YXhFcnJvcjogU3ludGF4RXJyb3IsXG4gICAgcGFyc2U6ICAgICAgIHBhcnNlXG4gIH07XG59KSgpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9HcmFtbWFyL2Rpc3QvR3JhbW1hci5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0b3BsZXZlbCA9IGdsb2JhbC53aW5kb3cgfHwgZ2xvYmFsO1xuXG5mdW5jdGlvbiBnZXRQcmVmaXhlZFByb3BlcnR5IChvYmplY3QsIG5hbWUpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjYXBpdGFsaXplZE5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgdmFyIHByZWZpeGVkTmFtZXMgPSBbbmFtZSwgJ3dlYmtpdCcgKyBjYXBpdGFsaXplZE5hbWUsICdtb3onICsgY2FwaXRhbGl6ZWROYW1lXTtcbiAgZm9yICh2YXIgaSBpbiBwcmVmaXhlZE5hbWVzKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gb2JqZWN0W3ByZWZpeGVkTmFtZXNbaV1dO1xuICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHByb3BlcnR5LmJpbmQob2JqZWN0KTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYlNvY2tldDogdG9wbGV2ZWwuV2ViU29ja2V0LFxuICBUcmFuc3BvcnQ6IHJlcXVpcmUoJy4vVHJhbnNwb3J0JyksXG4gIG9wZW46IHRvcGxldmVsLm9wZW4sXG4gIFByb21pc2U6IHRvcGxldmVsLlByb21pc2UsXG4gIHRpbWVyczogdG9wbGV2ZWwsXG5cbiAgLy8gQ29uc29sZSBpcyBub3QgZGVmaW5lZCBpbiBFQ01BU2NyaXB0LCBzbyBqdXN0IGluIGNhc2UuLi5cbiAgY29uc29sZTogdG9wbGV2ZWwuY29uc29sZSB8fCB7XG4gICAgZGVidWc6IGZ1bmN0aW9uICgpIHt9LFxuICAgIGxvZzogZnVuY3Rpb24gKCkge30sXG4gICAgd2FybjogZnVuY3Rpb24gKCkge30sXG4gICAgZXJyb3I6IGZ1bmN0aW9uICgpIHt9XG4gIH0sXG5cbiAgTWVkaWFTdHJlYW06IGdldFByZWZpeGVkUHJvcGVydHkodG9wbGV2ZWwsICdNZWRpYVN0cmVhbScpLFxuICBnZXRVc2VyTWVkaWE6IGdldFByZWZpeGVkUHJvcGVydHkodG9wbGV2ZWwubmF2aWdhdG9yLCAnZ2V0VXNlck1lZGlhJyksXG4gIFJUQ1BlZXJDb25uZWN0aW9uOiBnZXRQcmVmaXhlZFByb3BlcnR5KHRvcGxldmVsLCAnUlRDUGVlckNvbm5lY3Rpb24nKSxcbiAgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uOiBnZXRQcmVmaXhlZFByb3BlcnR5KHRvcGxldmVsLCAnUlRDU2Vzc2lvbkRlc2NyaXB0aW9uJyksXG5cbiAgYWRkRXZlbnRMaXN0ZW5lcjogZ2V0UHJlZml4ZWRQcm9wZXJ0eSh0b3BsZXZlbCwgJ2FkZEV2ZW50TGlzdGVuZXInKSxcbiAgSFRNTE1lZGlhRWxlbWVudDogdG9wbGV2ZWwuSFRNTE1lZGlhRWxlbWVudCxcblxuICBhdHRhY2hNZWRpYVN0cmVhbTogdG9wbGV2ZWwuYXR0YWNoTWVkaWFTdHJlYW0sXG4gIGNyZWF0ZU9iamVjdFVSTDogdG9wbGV2ZWwuVVJMICYmIHRvcGxldmVsLlVSTC5jcmVhdGVPYmplY3RVUkwsXG4gIHJldm9rZU9iamVjdFVSTDogdG9wbGV2ZWwuVVJMICYmIHRvcGxldmVsLlVSTC5yZXZva2VPYmplY3RVUkxcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL2Vudmlyb25tZW50X2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRyYW5zcG9ydFxuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIFRyYW5zcG9ydFxuICogQHBhcmFtIHtTSVAuVUF9IHVhXG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmVyIHdzX3NlcnZlciBPYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQLCBXZWJTb2NrZXQpIHtcbnZhciBUcmFuc3BvcnQsXG4gIEMgPSB7XG4gICAgLy8gVHJhbnNwb3J0IHN0YXR1cyBjb2Rlc1xuICAgIFNUQVRVU19SRUFEWTogICAgICAgIDAsXG4gICAgU1RBVFVTX0RJU0NPTk5FQ1RFRDogMSxcbiAgICBTVEFUVVNfRVJST1I6ICAgICAgICAyXG4gIH07XG5cbi8qKlxuICogQ29tcHV0ZSBhbiBhbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHNlbmRpbmcgYW5vdGhlclxuICoga2VlcC1hbGl2ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVLZWVwQWxpdmVUaW1lb3V0KHVwcGVyQm91bmQpIHtcbiAgdmFyIGxvd2VyQm91bmQgPSB1cHBlckJvdW5kICogMC44O1xuICByZXR1cm4gMTAwMCAqIChNYXRoLnJhbmRvbSgpICogKHVwcGVyQm91bmQgLSBsb3dlckJvdW5kKSArIGxvd2VyQm91bmQpO1xufVxuXG5UcmFuc3BvcnQgPSBmdW5jdGlvbih1YSwgc2VydmVyKSB7XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC50cmFuc3BvcnQnKTtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLndzID0gbnVsbDtcbiAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gIHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzID0gMDtcbiAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gIHRoaXMubGFzdFRyYW5zcG9ydEVycm9yID0ge307XG5cbiAgdGhpcy5rZWVwQWxpdmVJbnRlcnZhbCA9IHVhLmNvbmZpZ3VyYXRpb24ua2VlcEFsaXZlSW50ZXJ2YWw7XG4gIHRoaXMua2VlcEFsaXZlVGltZW91dCA9IG51bGw7XG4gIHRoaXMua2VlcEFsaXZlVGltZXIgPSBudWxsO1xuXG4gIHRoaXMudWEudHJhbnNwb3J0ID0gdGhpcztcblxuICAvLyBDb25uZWN0XG4gIHRoaXMuY29ubmVjdCgpO1xufTtcblxuVHJhbnNwb3J0LnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge1NJUC5PdXRnb2luZ1JlcXVlc3R8U3RyaW5nfSBtc2dcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBzZW5kOiBmdW5jdGlvbihtc2cpIHtcbiAgICB2YXIgbWVzc2FnZSA9IG1zZy50b1N0cmluZygpO1xuXG4gICAgaWYodGhpcy53cyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBpZiAodGhpcy51YS5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnc2VuZGluZyBXZWJTb2NrZXQgbWVzc2FnZTpcXG5cXG4nICsgbWVzc2FnZSArICdcXG4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud3Muc2VuZChtZXNzYWdlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCd1bmFibGUgdG8gc2VuZCBtZXNzYWdlLCBXZWJTb2NrZXQgaXMgbm90IG9wZW4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgYSBrZWVwLWFsaXZlIChhIGRvdWJsZS1DUkxGIHNlcXVlbmNlKS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBzZW5kS2VlcEFsaXZlOiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLmtlZXBBbGl2ZVRpbWVvdXQpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLmtlZXBBbGl2ZVRpbWVvdXQgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnVhLmVtaXQoJ2tlZXBBbGl2ZVRpbWVvdXQnKTtcbiAgICB9LmJpbmQodGhpcyksIDEwMDAwKTtcblxuICAgIHJldHVybiB0aGlzLnNlbmQoJ1xcclxcblxcclxcbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdGFydCBzZW5kaW5nIGtlZXAtYWxpdmVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRTZW5kaW5nS2VlcEFsaXZlczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwgJiYgIXRoaXMua2VlcEFsaXZlVGltZXIpIHtcbiAgICAgIHRoaXMua2VlcEFsaXZlVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VuZEtlZXBBbGl2ZSgpO1xuICAgICAgICB0aGlzLmtlZXBBbGl2ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydFNlbmRpbmdLZWVwQWxpdmVzKCk7XG4gICAgICB9LmJpbmQodGhpcyksIGNvbXB1dGVLZWVwQWxpdmVUaW1lb3V0KHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3Agc2VuZGluZyBrZWVwLWFsaXZlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0b3BTZW5kaW5nS2VlcEFsaXZlczogZnVuY3Rpb24oKSB7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5rZWVwQWxpdmVUaW1lcik7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5rZWVwQWxpdmVUaW1lb3V0KTtcbiAgICB0aGlzLmtlZXBBbGl2ZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLmtlZXBBbGl2ZVRpbWVvdXQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAqIERpc2Nvbm5lY3Qgc29ja2V0LlxuICAqL1xuICBkaXNjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLndzKSB7XG4gICAgICAvLyBDbGVhciByZWNvbm5lY3RUaW1lclxuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lcik7XG5cbiAgICAgIHRoaXMuc3RvcFNlbmRpbmdLZWVwQWxpdmVzKCk7XG5cbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnY2xvc2luZyBXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSk7XG4gICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZXIpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgICB0aGlzLnVhLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcsIHtcbiAgICAgICAgdHJhbnNwb3J0OiB0aGlzLFxuICAgICAgICBjb2RlOiB0aGlzLmxhc3RUcmFuc3BvcnRFcnJvci5jb2RlLFxuICAgICAgICByZWFzb246IHRoaXMubGFzdFRyYW5zcG9ydEVycm9yLnJlYXNvblxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIENvbm5lY3Qgc29ja2V0LlxuICAqL1xuICBjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcztcblxuICAgIGlmKHRoaXMud3MgJiYgKHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4gfHwgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkgKyAnIGlzIGFscmVhZHkgY29ubmVjdGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodGhpcy53cykge1xuICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZygnY29ubmVjdGluZyB0byBXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSk7XG4gICAgdGhpcy51YS5vblRyYW5zcG9ydENvbm5lY3RpbmcodGhpcyxcbiAgICAgICh0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyA9PT0gMCk/MTp0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyk7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodGhpcy5zZXJ2ZXIud3NfdXJpLCAnc2lwJyk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdlcnJvciBjb25uZWN0aW5nIHRvIFdlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpICsgJzogJyArIGUpO1xuICAgIH1cblxuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdHJhbnNwb3J0Lm9uT3BlbigpO1xuICAgIH07XG5cbiAgICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICB0cmFuc3BvcnQub25DbG9zZShlKTtcbiAgICB9O1xuXG4gICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICB0cmFuc3BvcnQub25NZXNzYWdlKGUpO1xuICAgIH07XG5cbiAgICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICB0cmFuc3BvcnQub25FcnJvcihlKTtcbiAgICB9O1xuICB9LFxuXG4gIC8vIFRyYW5zcG9ydCBFdmVudCBIYW5kbGVyc1xuXG4gIC8qKlxuICAqIEBldmVudFxuICAqIEBwYXJhbSB7ZXZlbnR9IGVcbiAgKi9cbiAgb25PcGVuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ1dlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpICsgJyBjb25uZWN0ZWQnKTtcbiAgICAvLyBDbGVhciByZWNvbm5lY3RUaW1lciBzaW5jZSB3ZSBhcmUgbm90IGRpc2Nvbm5lY3RlZFxuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVyKTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICAgIH1cbiAgICAvLyBSZXNldCByZWNvbm5lY3Rpb25fYXR0ZW1wdHNcbiAgICB0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyA9IDA7XG4gICAgLy8gRGlzYWJsZSBjbG9zZWRcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIC8vIFRyaWdnZXIgb25UcmFuc3BvcnRDb25uZWN0ZWQgY2FsbGJhY2tcbiAgICB0aGlzLnVhLm9uVHJhbnNwb3J0Q29ubmVjdGVkKHRoaXMpO1xuICAgIC8vIFN0YXJ0IHNlbmRpbmcga2VlcC1hbGl2ZXNcbiAgICB0aGlzLnN0YXJ0U2VuZGluZ0tlZXBBbGl2ZXMoKTtcbiAgfSxcblxuICAvKipcbiAgKiBAZXZlbnRcbiAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICovXG4gIG9uQ2xvc2U6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY29ubmVjdGVkX2JlZm9yZSA9IHRoaXMuY29ubmVjdGVkO1xuXG4gICAgdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IuY29kZSA9IGUuY29kZTtcbiAgICB0aGlzLmxhc3RUcmFuc3BvcnRFcnJvci5yZWFzb24gPSBlLnJlYXNvbjtcblxuICAgIHRoaXMuc3RvcFNlbmRpbmdLZWVwQWxpdmVzKCk7XG5cbiAgICBpZiAodGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgPiAwKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ1JlY29ubmVjdGlvbiBhdHRlbXB0ICcgKyB0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyArICcgZmFpbGVkIChjb2RlOiAnICsgZS5jb2RlICsgKGUucmVhc29uPyAnfCByZWFzb246ICcgKyBlLnJlYXNvbiA6ICcnKSArJyknKTtcbiAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ1dlYlNvY2tldCBkaXNjb25uZWN0ZWQgKGNvZGU6ICcgKyBlLmNvZGUgKyAoZS5yZWFzb24/ICd8IHJlYXNvbjogJyArIGUucmVhc29uIDogJycpICsnKScpO1xuXG4gICAgICBpZihlLndhc0NsZWFuID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdXZWJTb2NrZXQgYWJydXB0IGRpc2Nvbm5lY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIC8vIFRyYW5zcG9ydCB3YXMgY29ubmVjdGVkXG4gICAgICBpZihjb25uZWN0ZWRfYmVmb3JlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudWEub25UcmFuc3BvcnRDbG9zZWQodGhpcyk7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgcmVxdWVzdGVkIHRvIGNsb3NlLlxuICAgICAgICBpZighdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudWEuZW1pdCgnZGlzY29ubmVjdGVkJywge1xuICAgICAgICAgICAgdHJhbnNwb3J0OiB0aGlzLFxuICAgICAgICAgICAgY29kZTogdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IuY29kZSxcbiAgICAgICAgICAgIHJlYXNvbjogdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IucmVhc29uXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgY29ubmVjdGlvbiBhdHRlbXB0XG4gICAgICAgIC8vTmV0d29yayBlcnJvclxuICAgICAgICB0aGlzLnVhLm9uVHJhbnNwb3J0RXJyb3IodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBldmVudFxuICAqIEBwYXJhbSB7ZXZlbnR9IGVcbiAgKi9cbiAgb25NZXNzYWdlOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG1lc3NhZ2UsIHRyYW5zYWN0aW9uLFxuICAgICAgZGF0YSA9IGUuZGF0YTtcblxuICAgIC8vIENSTEYgS2VlcCBBbGl2ZSByZXNwb25zZSBmcm9tIHNlcnZlci4gSWdub3JlIGl0LlxuICAgIGlmKGRhdGEgPT09ICdcXHJcXG4nKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLmtlZXBBbGl2ZVRpbWVvdXQpO1xuICAgICAgdGhpcy5rZWVwQWxpdmVUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMudWEuY29uZmlndXJhdGlvbi50cmFjZVNpcCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3JlY2VpdmVkIFdlYlNvY2tldCBtZXNzYWdlIHdpdGggQ1JMRiBLZWVwIEFsaXZlIHJlc3BvbnNlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZWJTb2NrZXQgYmluYXJ5IG1lc3NhZ2UuXG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgICB9IGNhdGNoKGV2dCkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdyZWNlaXZlZCBXZWJTb2NrZXQgYmluYXJ5IG1lc3NhZ2UgZmFpbGVkIHRvIGJlIGNvbnZlcnRlZCBpbnRvIHN0cmluZywgbWVzc2FnZSBkaXNjYXJkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51YS5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygncmVjZWl2ZWQgV2ViU29ja2V0IGJpbmFyeSBtZXNzYWdlOlxcblxcbicgKyBkYXRhICsgJ1xcbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlYlNvY2tldCB0ZXh0IG1lc3NhZ2UuXG4gICAgZWxzZSB7XG4gICAgICBpZiAodGhpcy51YS5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygncmVjZWl2ZWQgV2ViU29ja2V0IHRleHQgbWVzc2FnZTpcXG5cXG4nICsgZGF0YSArICdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZXNzYWdlID0gU0lQLlBhcnNlci5wYXJzZU1lc3NhZ2UoZGF0YSwgdGhpcy51YSk7XG5cbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZih0aGlzLnVhLnN0YXR1cyA9PT0gU0lQLlVBLkMuU1RBVFVTX1VTRVJfQ0xPU0VEICYmIG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRG8gc29tZSBzYW5pdHkgY2hlY2tcbiAgICBpZihTSVAuc2FuaXR5Q2hlY2sobWVzc2FnZSwgdGhpcy51YSwgdGhpcykpIHtcbiAgICAgIGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXF1ZXN0KSB7XG4gICAgICAgIG1lc3NhZ2UudHJhbnNwb3J0ID0gdGhpcztcbiAgICAgICAgdGhpcy51YS5yZWNlaXZlUmVxdWVzdChtZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZihtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVzcG9uc2UpIHtcbiAgICAgICAgLyogVW5pa2Ugc3RhdGVkIGluIDE4LjEuMiwgaWYgYSByZXNwb25zZSBkb2VzIG5vdCBtYXRjaFxuICAgICAgICAqIGFueSB0cmFuc2FjdGlvbiwgaXQgaXMgZGlzY2FyZGVkIGhlcmUgYW5kIG5vIHBhc3NlZCB0byB0aGUgY29yZVxuICAgICAgICAqIGluIG9yZGVyIHRvIGJlIGRpc2NhcmRlZCB0aGVyZS5cbiAgICAgICAgKi9cbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UubWV0aG9kKSB7XG4gICAgICAgICAgY2FzZSBTSVAuQy5JTlZJVEU6XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRoaXMudWEudHJhbnNhY3Rpb25zLmljdFttZXNzYWdlLnZpYV9icmFuY2hdO1xuICAgICAgICAgICAgaWYodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBTSVAuQy5BQ0s6XG4gICAgICAgICAgICAvLyBKdXN0IGluIGNhc2UgOy0pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB0aGlzLnVhLnRyYW5zYWN0aW9ucy5uaWN0W21lc3NhZ2UudmlhX2JyYW5jaF07XG4gICAgICAgICAgICBpZih0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5yZWNlaXZlUmVzcG9uc2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAZXZlbnRcbiAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICovXG4gIG9uRXJyb3I6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdXZWJTb2NrZXQgY29ubmVjdGlvbiBlcnJvcjogJyArIEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgfSxcblxuICAvKipcbiAgKiBSZWNvbm5lY3Rpb24gYXR0ZW1wdCBsb2dpYy5cbiAgKiBAcHJpdmF0ZVxuICAqL1xuICByZWNvbm5lY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzO1xuXG4gICAgdGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgKz0gMTtcblxuICAgIGlmKHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzID4gdGhpcy51YS5jb25maWd1cmF0aW9uLndzU2VydmVyTWF4UmVjb25uZWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdtYXhpbXVtIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBmb3IgV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkpO1xuICAgICAgdGhpcy51YS5vblRyYW5zcG9ydEVycm9yKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgPT09IDEpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnQ29ubmVjdGlvbiB0byBXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSArICcgc2V2ZXJlZCwgYXR0ZW1wdGluZyBmaXJzdCByZWNvbm5lY3QnKTtcbiAgICAgIHRyYW5zcG9ydC5jb25uZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygndHJ5aW5nIHRvIHJlY29ubmVjdCB0byBXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSArICcgKHJlY29ubmVjdGlvbiBhdHRlbXB0ICcgKyB0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyArICcpJyk7XG5cbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyYW5zcG9ydC5jb25uZWN0KCk7XG4gICAgICAgIHRyYW5zcG9ydC5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgICB9LCB0aGlzLnVhLmNvbmZpZ3VyYXRpb24ud3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0ICogMTAwMCk7XG4gICAgfVxuICB9XG59O1xuXG5UcmFuc3BvcnQuQyA9IEM7XG5yZXR1cm4gVHJhbnNwb3J0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvVHJhbnNwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9