(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RcPhone"] = factory();
	else
		root["RcPhone"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _slicedToArray2 = __webpack_require__(45);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _addModule = __webpack_require__(119);
	
	var _addModule2 = _interopRequireDefault(_addModule);
	
	var _ringcentral = __webpack_require__(120);
	
	var _ringcentral2 = _interopRequireDefault(_ringcentral);
	
	var _ringcentralClient = __webpack_require__(132);
	
	var _ringcentralClient2 = _interopRequireDefault(_ringcentralClient);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _settings = __webpack_require__(152);
	
	var _settings2 = _interopRequireDefault(_settings);
	
	var _brand = __webpack_require__(166);
	
	var _brand2 = _interopRequireDefault(_brand);
	
	var _auth = __webpack_require__(169);
	
	var _auth2 = _interopRequireDefault(_auth);
	
	var _subscription = __webpack_require__(192);
	
	var _subscription2 = _interopRequireDefault(_subscription);
	
	var _user = __webpack_require__(199);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _webphone = __webpack_require__(203);
	
	var _webphone2 = _interopRequireDefault(_webphone);
	
	var _redux = __webpack_require__(153);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var REDUCER = (0, _symbol2.default)();
	
	function getStoreRegisterAndResolver() {
	  var handlers = new _set2.default();
	  return [function (fn) {
	    return handlers.add(fn);
	  }, function (store) {
	    return handlers.forEach(function (fn) {
	      return fn(store);
	    });
	  }];
	}
	
	var RcPhone = function (_RcModule) {
	  (0, _inherits3.default)(RcPhone, _RcModule);
	
	  function RcPhone(_ref) {
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var getStore = _ref.getStore;
	    var _stateMapper = _ref.stateMapper;
	    var _ref$prefix = _ref.prefix;
	    var prefix = _ref$prefix === undefined ? 'rc' : _ref$prefix;
	    var sdkSettings = _ref.sdkSettings;
	    var defaultBrand = _ref.defaultBrand;
	    (0, _classCallCheck3.default)(this, RcPhone);
	
	    var register = registerStoreHandler;
	    var resolve = void 0;
	    if (!register) {
	      var _getStoreRegisterAndR = getStoreRegisterAndResolver();
	
	      var _getStoreRegisterAndR2 = (0, _slicedToArray3.default)(_getStoreRegisterAndR, 2);
	
	      register = _getStoreRegisterAndR2[0];
	      resolve = _getStoreRegisterAndR2[1];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RcPhone).call(this, {
	      registerStoreHandler: register,
	      stateMapper: _stateMapper
	    }));
	
	    _addModule2.default.call(_this, 'sdk', new _ringcentral2.default((0, _extends3.default)({
	
	      cachePrefix: prefix + '-'
	    }, sdkSettings)));
	
	    _addModule2.default.call(_this, 'platform', _this.sdk.platform());
	
	    _addModule2.default.call(_this, 'api', new _ringcentralClient2.default(_this.sdk));
	
	    _addModule2.default.call(_this, 'auth', new _auth2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).auth;
	      },
	      prefix: prefix,
	      platform: _this.platform
	    }));
	
	    _addModule2.default.call(_this, 'settings', new _settings2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).settings;
	      }
	    }));
	
	    _addModule2.default.call(_this, 'defaultBrand', new _brand2.default((0, _extends3.default)({
	      registerStoreHandler: register,
	      prefix: prefix + '-default',
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).defaultBrand;
	      }
	    }, defaultBrand)));
	
	    _addModule2.default.call(_this, 'subscription', new _subscription2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).subscription;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      sdk: _this.sdk,
	      auth: _this.auth
	    }));
	
	    _addModule2.default.call(_this, 'user', new _user2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).user;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      settings: _this.settings
	    }));
	
	    _addModule2.default.call(_this, 'webphone', new _webphone2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).webphone;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      settings: _this.settings
	    }));
	
	    // combine reducers
	    _this[REDUCER] = (0, _redux.combineReducers)({
	      auth: _this.auth.reducer,
	      defaultBrand: _this.defaultBrand.reducer,
	      subscription: _this.subscription.reducer,
	      user: _this.user.reducer,
	      webphone: _this.webphone.reducer,
	      settings: _this.settings.reducer
	    });
	
	    if (resolve) {
	      resolve(getStore(_this.reducer));
	      // resolve(createStore(this.reducer));
	    }
	    return _this;
	  }
	
	  (0, _createClass3.default)(RcPhone, [{
	    key: 'reducer',
	    get: function get() {
	      return this[REDUCER];
	    }
	  }]);
	  return RcPhone;
	}(_rcModule2.default);
	
	exports.default = RcPhone;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	
	  return target;
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(4), __esModule: true };

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(5);
	module.exports = __webpack_require__(8).Object.assign;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(6);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(21)});

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(7)
	  , core      = __webpack_require__(8)
	  , ctx       = __webpack_require__(9)
	  , hide      = __webpack_require__(11)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 7 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 8 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(10);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(12)
	  , createDesc = __webpack_require__(20);
	module.exports = __webpack_require__(16) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(13)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , toPrimitive    = __webpack_require__(19)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(16) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(16) && !__webpack_require__(17)(function(){
	  return Object.defineProperty(__webpack_require__(18)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(17)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , document = __webpack_require__(7).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(14);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(22)
	  , gOPS     = __webpack_require__(37)
	  , pIE      = __webpack_require__(38)
	  , toObject = __webpack_require__(39)
	  , IObject  = __webpack_require__(26)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(17)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(23)
	  , enumBugKeys = __webpack_require__(36);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(24)
	  , toIObject    = __webpack_require__(25)
	  , arrayIndexOf = __webpack_require__(29)(false)
	  , IE_PROTO     = __webpack_require__(33)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(26)
	  , defined = __webpack_require__(28);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(27);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(25)
	  , toLength  = __webpack_require__(30)
	  , toIndex   = __webpack_require__(32);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(31)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(34)('keys')
	  , uid    = __webpack_require__(35);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(7)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 37 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 38 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(28);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(41), __esModule: true };

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(42);
	module.exports = __webpack_require__(8).Object.getPrototypeOf;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(39)
	  , $getPrototypeOf = __webpack_require__(43);
	
	__webpack_require__(44)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(24)
	  , toObject    = __webpack_require__(39)
	  , IE_PROTO    = __webpack_require__(33)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(6)
	  , core    = __webpack_require__(8)
	  , fails   = __webpack_require__(17);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(46);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(66);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(47), __esModule: true };

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(62);
	module.exports = __webpack_require__(64);

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(49);
	var global        = __webpack_require__(7)
	  , hide          = __webpack_require__(11)
	  , Iterators     = __webpack_require__(52)
	  , TO_STRING_TAG = __webpack_require__(61)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(50)
	  , step             = __webpack_require__(51)
	  , Iterators        = __webpack_require__(52)
	  , toIObject        = __webpack_require__(25);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(53)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(54)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(55)
	  , hide           = __webpack_require__(11)
	  , has            = __webpack_require__(24)
	  , Iterators      = __webpack_require__(52)
	  , $iterCreate    = __webpack_require__(56)
	  , setToStringTag = __webpack_require__(60)
	  , getPrototypeOf = __webpack_require__(43)
	  , ITERATOR       = __webpack_require__(61)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11);

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(57)
	  , descriptor     = __webpack_require__(20)
	  , setToStringTag = __webpack_require__(60)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(11)(IteratorPrototype, __webpack_require__(61)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(13)
	  , dPs         = __webpack_require__(58)
	  , enumBugKeys = __webpack_require__(36)
	  , IE_PROTO    = __webpack_require__(33)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(18)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(59).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(12)
	  , anObject = __webpack_require__(13)
	  , getKeys  = __webpack_require__(22);
	
	module.exports = __webpack_require__(16) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(7).document && document.documentElement;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(12).f
	  , has = __webpack_require__(24)
	  , TAG = __webpack_require__(61)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(34)('wks')
	  , uid        = __webpack_require__(35)
	  , Symbol     = __webpack_require__(7).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(63)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(53)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31)
	  , defined   = __webpack_require__(28);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(65)
	  , ITERATOR  = __webpack_require__(61)('iterator')
	  , Iterators = __webpack_require__(52);
	module.exports = __webpack_require__(8).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(27)
	  , TAG = __webpack_require__(61)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(67), __esModule: true };

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(62);
	module.exports = __webpack_require__(68);

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(13)
	  , get      = __webpack_require__(69);
	module.exports = __webpack_require__(8).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(65)
	  , ITERATOR  = __webpack_require__(61)('iterator')
	  , Iterators = __webpack_require__(52);
	module.exports = __webpack_require__(8).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 70 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(73), __esModule: true };

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(74);
	var $Object = __webpack_require__(8).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(16), 'Object', {defineProperty: __webpack_require__(12).f});

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(77);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(78), __esModule: true };

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(48);
	module.exports = __webpack_require__(79).f('iterator');

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(61);

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(81), __esModule: true };

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(82);
	__webpack_require__(91);
	__webpack_require__(92);
	__webpack_require__(93);
	module.exports = __webpack_require__(8).Symbol;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(7)
	  , has            = __webpack_require__(24)
	  , DESCRIPTORS    = __webpack_require__(16)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(55)
	  , META           = __webpack_require__(83).KEY
	  , $fails         = __webpack_require__(17)
	  , shared         = __webpack_require__(34)
	  , setToStringTag = __webpack_require__(60)
	  , uid            = __webpack_require__(35)
	  , wks            = __webpack_require__(61)
	  , wksExt         = __webpack_require__(79)
	  , wksDefine      = __webpack_require__(84)
	  , keyOf          = __webpack_require__(85)
	  , enumKeys       = __webpack_require__(86)
	  , isArray        = __webpack_require__(87)
	  , anObject       = __webpack_require__(13)
	  , toIObject      = __webpack_require__(25)
	  , toPrimitive    = __webpack_require__(19)
	  , createDesc     = __webpack_require__(20)
	  , _create        = __webpack_require__(57)
	  , gOPNExt        = __webpack_require__(88)
	  , $GOPD          = __webpack_require__(90)
	  , $DP            = __webpack_require__(12)
	  , $keys          = __webpack_require__(22)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(89).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(38).f  = $propertyIsEnumerable;
	  __webpack_require__(37).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(54)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(35)('meta')
	  , isObject = __webpack_require__(14)
	  , has      = __webpack_require__(24)
	  , setDesc  = __webpack_require__(12).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(17)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(7)
	  , core           = __webpack_require__(8)
	  , LIBRARY        = __webpack_require__(54)
	  , wksExt         = __webpack_require__(79)
	  , defineProperty = __webpack_require__(12).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(22)
	  , toIObject = __webpack_require__(25);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(22)
	  , gOPS    = __webpack_require__(37)
	  , pIE     = __webpack_require__(38);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(27);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(25)
	  , gOPN      = __webpack_require__(89).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(23)
	  , hiddenKeys = __webpack_require__(36).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(38)
	  , createDesc     = __webpack_require__(20)
	  , toIObject      = __webpack_require__(25)
	  , toPrimitive    = __webpack_require__(19)
	  , has            = __webpack_require__(24)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(16) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 91 */
/***/ function(module, exports) {



/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(84)('asyncIterator');

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(84)('observable');

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(95);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(99);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(96), __esModule: true };

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(97);
	module.exports = __webpack_require__(8).Object.setPrototypeOf;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(6);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(98).set});

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(14)
	  , anObject = __webpack_require__(13);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(9)(Function.call, __webpack_require__(90).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(100), __esModule: true };

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(101);
	var $Object = __webpack_require__(8).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(57)});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(103), __esModule: true };

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	__webpack_require__(62);
	__webpack_require__(48);
	__webpack_require__(104);
	__webpack_require__(116);
	module.exports = __webpack_require__(8).Set;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(105);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(112)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(12).f
	  , create      = __webpack_require__(57)
	  , hide        = __webpack_require__(11)
	  , redefineAll = __webpack_require__(106)
	  , ctx         = __webpack_require__(9)
	  , anInstance  = __webpack_require__(107)
	  , defined     = __webpack_require__(28)
	  , forOf       = __webpack_require__(108)
	  , $iterDefine = __webpack_require__(53)
	  , step        = __webpack_require__(51)
	  , setSpecies  = __webpack_require__(111)
	  , DESCRIPTORS = __webpack_require__(16)
	  , fastKey     = __webpack_require__(83).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(11);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(9)
	  , call        = __webpack_require__(109)
	  , isArrayIter = __webpack_require__(110)
	  , anObject    = __webpack_require__(13)
	  , toLength    = __webpack_require__(30)
	  , getIterFn   = __webpack_require__(69)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(13);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(52)
	  , ITERATOR   = __webpack_require__(61)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(7)
	  , core        = __webpack_require__(8)
	  , dP          = __webpack_require__(12)
	  , DESCRIPTORS = __webpack_require__(16)
	  , SPECIES     = __webpack_require__(61)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(7)
	  , $export        = __webpack_require__(6)
	  , meta           = __webpack_require__(83)
	  , fails          = __webpack_require__(17)
	  , hide           = __webpack_require__(11)
	  , redefineAll    = __webpack_require__(106)
	  , forOf          = __webpack_require__(108)
	  , anInstance     = __webpack_require__(107)
	  , isObject       = __webpack_require__(14)
	  , setToStringTag = __webpack_require__(60)
	  , dP             = __webpack_require__(12).f
	  , each           = __webpack_require__(113)(0)
	  , DESCRIPTORS    = __webpack_require__(16);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    C = wrapper(function(target, iterable){
	      anInstance(target, C, NAME, '_c');
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        anInstance(this, C, KEY);
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)dP(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(9)
	  , IObject  = __webpack_require__(26)
	  , toObject = __webpack_require__(39)
	  , toLength = __webpack_require__(30)
	  , asc      = __webpack_require__(114);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(115);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , isArray  = __webpack_require__(87)
	  , SPECIES  = __webpack_require__(61)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(6);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(117)('Set')});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(65)
	  , from    = __webpack_require__(118);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(108);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	exports.default = addModule;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function addModule(name, module) {
	  if (Object.prototype.hasOwnProperty.call(this, name)) {
	    throw new Error("module '" + name + "' already exists...");
	  }
	
	  (0, _defineProperty2.default)(this, name, {
	    get: function get() {
	      return module;
	    },
	
	    enumerable: true
	  });
	}

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(126), __webpack_require__(130), __webpack_require__(131));
		else if(typeof define === 'function' && define.amd)
			define([, , "pubnub"], factory);
		else if(typeof exports === 'object')
			exports["SDK"] = factory(require("es6-promise"), require("node-fetch"), require("pubnub"));
		else
			root["RingCentral"] = root["RingCentral"] || {}, root["RingCentral"]["SDK"] = factory(root[undefined], root[undefined], root[undefined]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "/build/";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(1);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	__webpack_require__(2);
	
	var _Utils = __webpack_require__(3);
	
	var Utils = _interopRequireWildcard(_Utils);
	
	var _Cache = __webpack_require__(8);
	
	var _Cache2 = _interopRequireDefault(_Cache);
	
	var _Externals = __webpack_require__(4);
	
	var Externals = _interopRequireWildcard(_Externals);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Client = __webpack_require__(10);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	var _ClientMock = __webpack_require__(12);
	
	var _ClientMock2 = _interopRequireDefault(_ClientMock);
	
	var _Mock = __webpack_require__(14);
	
	var _Mock2 = _interopRequireDefault(_Mock);
	
	var _Registry = __webpack_require__(13);
	
	var _Registry2 = _interopRequireDefault(_Registry);
	
	var _Platform = __webpack_require__(15);
	
	var _Platform2 = _interopRequireDefault(_Platform);
	
	var _Auth = __webpack_require__(16);
	
	var _Auth2 = _interopRequireDefault(_Auth);
	
	var _PubnubFactory = __webpack_require__(17);
	
	var _PubnubFactory2 = _interopRequireDefault(_PubnubFactory);
	
	var _Subscription = __webpack_require__(19);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _CachedSubscription = __webpack_require__(20);
	
	var _CachedSubscription2 = _interopRequireDefault(_CachedSubscription);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SDK = function () {
	
	    /**
	     * @namespace RingCentral
	     * @constructor
	     * @param {object} [options]
	     * @param {string} [options.server]
	     * @param {string} [options.cachePrefix]
	     * @param {string} [options.appSecret]
	     * @param {string} [options.appKey]
	     * @param {string} [options.appName]
	     * @param {string} [options.appVersion]
	     * @param {string} [options.pubnubFactory]
	     * @param {string} [options.client]
	     */
	
	    function SDK(options) {
	        _classCallCheck(this, SDK);
	
	        options = options || {};
	
	        if (!Externals.fetch) {
	            throw new Error('Native Fetch is missing, set RingCentral.SDK.core.Externals.fetch to your favorite alternative');
	        }
	
	        if (!Externals.Promise) {
	            throw new Error('Native Promise is missing, set RingCentral.SDK.core.Externals.Promise to your favorite alternative');
	        }
	
	        this._cache = new _Cache2.default(Externals.localStorage, options.cachePrefix);
	
	        this._client = options.client || new _Client2.default();
	
	        this._platform = new _Platform2.default(this._client, this._cache, options.server, options.appKey, options.appSecret, options.appName, options.appVersion, SDK.version);
	
	        this._pubnubFactory = options.pubnubFactory || Externals.PUBNUB;
	    }
	
	    /**
	     * @return {Platform}
	     */
	
	
	    SDK.prototype.platform = function platform() {
	        return this._platform;
	    };
	
	    /**
	     * @return {Subscription}
	     */
	
	
	    SDK.prototype.createSubscription = function createSubscription() {
	        return new _Subscription2.default(this._pubnubFactory, this._platform);
	    };
	
	    /**
	     * @return {CachedSubscription}
	     */
	
	
	    SDK.prototype.createCachedSubscription = function createCachedSubscription(cacheKey) {
	        return new _CachedSubscription2.default(this._pubnubFactory, this._platform, this._cache, cacheKey);
	    };
	
	    /**
	     * @return {Cache}
	     */
	
	
	    SDK.prototype.cache = function cache() {
	        return this._cache;
	    };
	
	    SDK.handleLoginRedirect = function handleLoginRedirect(origin) {
	        window.opener.postMessage({ RCAuthorizationCode: window.location.search }, origin || window.location.origin);
	    };
	
	    return SDK;
	}();
	
	SDK.version =  true ? ("3.0.0-rc1") : 'x.x.x';
	SDK.server = {
	    sandbox: 'https://platform.devtest.ringcentral.com',
	    production: 'https://platform.ringcentral.com'
	};
	SDK.core = {
	    Cache: _Cache2.default,
	    EventEmitter: _events2.default,
	    Utils: Utils,
	    Externals: Externals
	};
	SDK.http = {
	    Client: _Client2.default,
	    ApiResponse: _ApiResponse2.default
	};
	SDK.platform = {
	    Auth: _Auth2.default,
	    Platform: _Platform2.default
	};
	SDK.subscription = {
	    Subscription: _Subscription2.default
	};
	SDK.mocks = {
	    Client: _ClientMock2.default,
	    Registry: _Registry2.default,
	    Mock: _Mock2.default
	};
	SDK.pubnub = {
	    PubnubMockFactory: _PubnubFactory2.default
	};
	
	
	module.exports = SDK;
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var iteratorSymbol =
	    typeof Symbol === "function" && Symbol.iterator || "@@iterator";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    // This invoke function is written in a style that assumes some
	    // calling function (or Promise) will handle exceptions.
	    function invoke(method, arg) {
	      var result = generator[method](arg);
	      var value = result.value;
	      return value instanceof AwaitArgument
	        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
	        : Promise.resolve(value).then(function(unwrapped) {
	            // When a yielded Promise is resolved, its final value becomes
	            // the .value of the Promise<{value,done}> result for the
	            // current iteration. If the Promise is rejected, however, the
	            // result for this iteration will be rejected with the same
	            // reason. Note that rejections of yielded Promises are not
	            // thrown back into the generator function, as is the case
	            // when an awaited Promise is rejected. This difference in
	            // behavior between yield and await is important, because it
	            // allows the consumer to decide what to do with the yielded
	            // rejection (swallow it and continue, manually .throw it back
	            // into the generator, abandon iteration, whatever). With
	            // await, by contrast, there is no opportunity to examine the
	            // rejection reason outside the generator function, so the
	            // only option is to throw it from the await expression, and
	            // let the generator function handle the exception.
	            result.value = unwrapped;
	            return result;
	          });
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var invokeNext = invoke.bind(generator, "next");
	    var invokeThrow = invoke.bind(generator, "throw");
	    var invokeReturn = invoke.bind(generator, "return");
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return invoke(method, arg);
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : new Promise(function (resolve) {
	          resolve(callInvokeWithMethodAndArg());
	        });
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          context._sent = arg;
	
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            context.sent = undefined;
	          }
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.queryStringify = queryStringify;
	exports.parseQueryString = parseQueryString;
	exports.isFunction = isFunction;
	exports.isArray = isArray;
	exports.isObject = isObject;
	exports.isObjectObject = isObjectObject;
	exports.isPlainObject = isPlainObject;
	exports.isNodeJS = isNodeJS;
	exports.isBrowser = isBrowser;
	exports.delay = delay;
	
	var _Externals = __webpack_require__(4);
	
	/**
	 * TODO Replace with something better
	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js
	 * @param {object} parameters
	 * @returns {string}
	 */
	function queryStringify(parameters) {
	
	    var array = [];
	
	    parameters = parameters || {};
	
	    Object.keys(parameters).forEach(function (k) {
	
	        var v = parameters[k];
	
	        if (isArray(v)) {
	            v.forEach(function (vv) {
	                array.push(encodeURIComponent(k) + '=' + encodeURIComponent(vv));
	            });
	        } else {
	            array.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));
	        }
	    });
	
	    return array.join('&');
	}
	
	/**
	 * TODO Replace with something better
	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js
	 * @param {string} queryString
	 * @returns {object}
	 */
	function parseQueryString(queryString) {
	
	    var argsParsed = {};
	
	    queryString.split('&').forEach(function (arg) {
	
	        arg = decodeURIComponent(arg);
	
	        if (arg.indexOf('=') == -1) {
	
	            argsParsed[arg.trim()] = true;
	        } else {
	
	            var pair = arg.split('='),
	                key = pair[0].trim(),
	                value = pair[1].trim();
	
	            if (key in argsParsed) {
	                if (key in argsParsed && !isArray(argsParsed[key])) argsParsed[key] = [argsParsed[key]];
	                argsParsed[key].push(value);
	            } else {
	                argsParsed[key] = value;
	            }
	        }
	    });
	
	    return argsParsed;
	}
	
	/**
	 * @param obj
	 * @return {boolean}
	 */
	function isFunction(obj) {
	    return typeof obj === "function";
	}
	
	/**
	 * @param obj
	 * @return {boolean}
	 */
	function isArray(obj) {
	    return Array.isArray ? Array.isArray(obj) : typeof obj === "array";
	}
	
	function isObject(o) {
	    return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && !isArray(o);
	}
	
	function isObjectObject(o) {
	    return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';
	}
	
	function isPlainObject(o) {
	    var ctor, prot;
	
	    if (isObjectObject(o) === false) return false;
	
	    // If has modified constructor
	    ctor = o.constructor;
	    if (typeof ctor !== 'function') return false;
	
	    // If has modified prototype
	    prot = ctor.prototype;
	    if (isObjectObject(prot) === false) return false;
	
	    // If constructor does not have an Object-specific method
	    if (prot.hasOwnProperty('isPrototypeOf') === false) {
	        return false;
	    }
	
	    // Most likely a plain Object
	    return true;
	}
	
	function isNodeJS() {
	    return typeof process !== 'undefined';
	}
	
	function isBrowser() {
	    return typeof window !== 'undefined';
	}
	
	function delay(timeout) {
	    return new _Externals.Promise(function (resolve, reject) {
	        setTimeout(function () {
	            resolve(null);
	        }, timeout);
	    });
	}
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	exports.__esModule = true;
	exports.localStorage = exports.PUBNUB = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.Promise = undefined;
	
	var _es6Promise = __webpack_require__(5);
	
	var _es6Promise2 = _interopRequireDefault(_es6Promise);
	
	var _nodeFetch = __webpack_require__(6);
	
	var _nodeFetch2 = _interopRequireDefault(_nodeFetch);
	
	var _pubnub = __webpack_require__(7);
	
	var _pubnub2 = _interopRequireDefault(_pubnub);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var root = typeof window !== "undefined" && window || typeof global !== "undefined" && global || Function("return this;")();
	
	var Promise = _es6Promise2.default && _es6Promise2.default.Promise || root.Promise;
	
	var fetch = _nodeFetch2.default && typeof _nodeFetch2.default == 'function' ? _nodeFetch2.default : root.fetch;
	var Request = fetch.Request || root.Request;
	var Response = fetch.Response || root.Response;
	var Headers = fetch.Headers || root.Headers;
	
	var PUBNUB = _pubnub2.default || root.PUBNUB;
	
	var localStorage = typeof root.localStorage !== 'undefined' ? root.localStorage : {};
	
	exports.Promise = Promise;
	exports.fetch = fetch;
	exports.Request = Request;
	exports.Response = Response;
	exports.Headers = Headers;
	exports.PUBNUB = PUBNUB;
	exports.localStorage = localStorage;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_6__;
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_7__;
	
	/***/ },
	/* 8 */
	/***/ function(module, exports) {
	
	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Cache = function () {
	    function Cache(storage, prefix) {
	        _classCallCheck(this, Cache);
	
	        this.setPrefix(prefix);
	        this._storage = storage;
	    }
	
	    Cache.prototype.setPrefix = function setPrefix(prefix) {
	        this._prefix = prefix || Cache.defaultPrefix;
	        return this;
	    };
	
	    Cache.prototype.setItem = function setItem(key, data) {
	        this._storage[this._prefixKey(key)] = JSON.stringify(data);
	        return this;
	    };
	
	    Cache.prototype.removeItem = function removeItem(key) {
	        delete this._storage[this._prefixKey(key)];
	        return this;
	    };
	
	    Cache.prototype.getItem = function getItem(key) {
	        var item = this._storage[this._prefixKey(key)];
	        if (!item) return null;
	        return JSON.parse(item);
	    };
	
	    Cache.prototype.clean = function clean() {
	
	        for (var key in this._storage) {
	
	            if (!this._storage.hasOwnProperty(key)) continue;
	
	            if (key.indexOf(this._prefix) === 0) {
	                delete this._storage[key];
	            }
	        }
	
	        return this;
	    };
	
	    Cache.prototype._prefixKey = function _prefixKey(key) {
	        return this._prefix + key;
	    };
	
	    return Cache;
	}();
	
	Cache.defaultPrefix = 'rc-';
	exports.default = Cache;
	
	/***/ },
	/* 9 */
	/***/ function(module, exports) {
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	exports.findHeaderName = findHeaderName;
	
	var _Externals = __webpack_require__(4);
	
	var _Utils = __webpack_require__(3);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Client = function (_EventEmitter) {
	    _inherits(Client, _EventEmitter);
	
	    function Client() {
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Client);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _EventEmitter.call.apply(_EventEmitter, [this].concat(args))), _this), _this.events = {
	            beforeRequest: 'beforeRequest',
	            requestSuccess: 'requestSuccess',
	            requestError: 'requestError'
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    /**
	     * @param {Request} request
	     * @return {Promise<ApiResponse>}
	     */
	
	    Client.prototype.sendRequest = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            var apiResponse;
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            apiResponse = new _ApiResponse2.default(request);
	                            _context.prev = 1;
	
	
	                            //TODO Stop request if listeners return false
	                            this.emit(this.events.beforeRequest, apiResponse);
	
	                            _context.next = 5;
	                            return this._loadResponse(request);
	
	                        case 5:
	                            apiResponse._response = _context.sent;
	                            _context.next = 8;
	                            return apiResponse._init();
	
	                        case 8:
	                            if (apiResponse.ok()) {
	                                _context.next = 10;
	                                break;
	                            }
	
	                            throw new Error('Response has unsuccessful status');
	
	                        case 10:
	
	                            this.emit(this.events.requestSuccess, apiResponse);
	
	                            return _context.abrupt("return", apiResponse);
	
	                        case 14:
	                            _context.prev = 14;
	                            _context.t0 = _context["catch"](1);
	
	
	                            if (!_context.t0.apiResponse) _context.t0 = this.makeError(_context.t0, apiResponse);
	
	                            this.emit(this.events.requestError, _context.t0);
	
	                            throw _context.t0;
	
	                        case 19:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this, [[1, 14]]);
	        }));
	
	        function sendRequest(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return sendRequest;
	    }();
	
	    /**
	     * @param {Request} request
	     * @return {Promise<Response>}
	     * @private
	     */
	
	
	    Client.prototype._loadResponse = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(request) {
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.next = 2;
	                            return _Externals.fetch.call(null, request);
	
	                        case 2:
	                            return _context2.abrupt("return", _context2.sent);
	
	                        case 3:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this);
	        }));
	
	        function _loadResponse(_x2) {
	            return _ref2.apply(this, arguments);
	        }
	
	        return _loadResponse;
	    }();
	
	    /**
	     * Wraps the JS Error object with transaction information
	     * @param {Error|IApiError} e
	     * @param {ApiResponse} apiResponse
	     * @return {IApiError}
	     */
	
	
	    Client.prototype.makeError = function makeError(e, apiResponse) {
	
	        // Wrap only if regular error
	        if (!e.hasOwnProperty('apiResponse') && !e.hasOwnProperty('originalMessage')) {
	
	            e.apiResponse = apiResponse;
	            e.originalMessage = e.message;
	            e.message = apiResponse && apiResponse.error(true) || e.originalMessage;
	        }
	
	        return e;
	    };
	
	    /**
	     *
	     * @param {object} init
	     * @param {object} [init.url]
	     * @param {object} [init.body]
	     * @param {string} [init.method]
	     * @param {object} [init.query]
	     * @param {object} [init.headers]
	     * @return {Request}
	     */
	
	
	    Client.prototype.createRequest = function createRequest(init) {
	
	        init = init || {};
	        init.headers = init.headers || {};
	
	        // Sanity checks
	        if (!init.url) throw new Error('Url is not defined');
	        if (!init.method) init.method = 'GET';
	        if (init.method && Client._allowedMethods.indexOf(init.method.toUpperCase()) < 0) {
	            throw new Error('Method has wrong value: ' + init.method);
	        }
	
	        // Defaults
	        init.credentials = init.credentials || 'include';
	        init.mode = init.mode || 'cors';
	
	        // Append Query String
	        if (init.query) {
	            init.url = init.url + (init.url.indexOf('?') > -1 ? '&' : '?') + (0, _Utils.queryStringify)(init.query);
	        }
	
	        if (!findHeaderName('Accept', init.headers)) {
	            init.headers['Accept'] = _ApiResponse2.default._jsonContentType;
	        }
	
	        // Serialize body
	        if ((0, _Utils.isPlainObject)(init.body) || !init.body) {
	
	            var contentTypeHeaderName = findHeaderName(_ApiResponse2.default._contentType, init.headers);
	
	            if (!contentTypeHeaderName) {
	                contentTypeHeaderName = _ApiResponse2.default._contentType;
	                init.headers[contentTypeHeaderName] = _ApiResponse2.default._jsonContentType;
	            }
	
	            var contentType = init.headers[contentTypeHeaderName];
	
	            // Assign a new encoded body
	            if (contentType.indexOf(_ApiResponse2.default._jsonContentType) > -1) {
	                init.body = JSON.stringify(init.body);
	            } else if (contentType.indexOf(_ApiResponse2.default._urlencodedContentType) > -1) {
	                init.body = (0, _Utils.queryStringify)(init.body);
	            }
	        }
	
	        // Create a request with encoded body
	        var req = new _Externals.Request(init.url, init);
	
	        // Keep the original body accessible directly (for mocks)
	        req.originalBody = init.body;
	
	        return req;
	    };
	
	    return Client;
	}(_events2.default);
	
	Client._allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];
	exports.default = Client;
	function findHeaderName(name, headers) {
	    name = name.toLowerCase();
	    return Object.keys(headers).reduce(function (res, key) {
	        if (res) return res;
	        if (name == key.toLowerCase()) return key;
	        return res;
	    }, null);
	}
	
	/**
	 * @name IApiError
	 * @property {string} stack
	 * @property {string} originalMessage
	 * @property {ApiResponse} apiResponse
	 */
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ApiResponse = function () {
	
	    /**
	     * @param {Request} request
	     * @param {Response} response
	     * @param {string} responseText
	     */
	
	    function ApiResponse(request, response, responseText) {
	        _classCallCheck(this, ApiResponse);
	
	        /** @type {Request} */
	        this._request = request;
	
	        /** @type {Response} */
	        this._response = response;
	
	        this._text = responseText;
	        this._json = null;
	        this._multipart = [];
	    }
	
	    ApiResponse.prototype._init = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!(this._isMultipart() || this._isJson())) {
	                                _context.next = 4;
	                                break;
	                            }
	
	                            _context.next = 3;
	                            return this.response().text();
	
	                        case 3:
	                            this._text = _context.sent;
	
	                        case 4:
	                            return _context.abrupt('return', this);
	
	                        case 5:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function _init() {
	            return _ref.apply(this, arguments);
	        }
	
	        return _init;
	    }();
	
	    /**
	     * @return {Response}
	     */
	
	
	    ApiResponse.prototype.response = function response() {
	        return this._response;
	    };
	
	    /**
	     * @return {Request}
	     */
	
	
	    ApiResponse.prototype.request = function request() {
	        return this._request;
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    ApiResponse.prototype.ok = function ok() {
	        return this._response && this._response.ok;
	    };
	
	    /**
	     * @return {string}
	     */
	
	
	    ApiResponse.prototype.text = function text() {
	        if (!this._isJson() && !this._isMultipart()) throw new Error('Response is not text');
	        return this._text;
	    };
	
	    /**
	     * @return {object}
	     */
	
	
	    ApiResponse.prototype.json = function json() {
	        if (!this._isJson()) throw new Error('Response is not JSON');
	        if (!this._json) {
	            this._json = this._text ? JSON.parse(this._text) : null;
	        }
	        return this._json;
	    };
	
	    /**
	     * @param [skipOKCheck]
	     * @return {string}
	     */
	
	
	    ApiResponse.prototype.error = function error(skipOKCheck) {
	
	        if (this.ok() && !skipOKCheck) return null;
	
	        var message = (this._response && this._response.status ? this._response.status + ' ' : '') + (this._response && this._response.statusText ? this._response.statusText : '');
	
	        try {
	
	            if (this.json().message) message = this.json().message;
	            if (this.json().error_description) message = this.json().error_description;
	            if (this.json().description) message = this.json().description;
	        } catch (e) {}
	
	        return message;
	    };
	
	    /**
	     * @return {ApiResponse[]}
	     */
	
	
	    ApiResponse.prototype.multipart = function multipart() {
	
	        if (!this._isMultipart()) throw new Error('Response is not multipart');
	
	        if (!this._multipart.length) {
	
	            // Step 1. Split multipart response
	
	            var text = this.text();
	
	            if (!text) throw new Error('No response body');
	
	            var boundary = this._getContentType().match(/boundary=([^;]+)/i)[1];
	
	            if (!boundary) throw new Error('Cannot find boundary');
	
	            var parts = text.toString().split(ApiResponse._boundarySeparator + boundary);
	
	            if (parts[0].trim() === '') parts.shift();
	            if (parts[parts.length - 1].trim() == ApiResponse._boundarySeparator) parts.pop();
	
	            if (parts.length < 1) throw new Error('No parts in body');
	
	            // Step 2. Parse status info
	
	            var statusInfo = ApiResponse.create(parts.shift(), this._response.status, this._response.statusText).json();
	
	            // Step 3. Parse all other parts
	
	            this._multipart = parts.map(function (part, i) {
	
	                var status = statusInfo.response[i].status;
	
	                return ApiResponse.create(part, status);
	            });
	        }
	
	        return this._multipart;
	    };
	
	    ApiResponse.prototype._isContentType = function _isContentType(contentType) {
	        return this._getContentType().indexOf(contentType) > -1;
	    };
	
	    ApiResponse.prototype._getContentType = function _getContentType() {
	        return this._response.headers.get(ApiResponse._contentType) || '';
	    };
	
	    ApiResponse.prototype._isMultipart = function _isMultipart() {
	        return this._isContentType(ApiResponse._multipartContentType);
	    };
	
	    ApiResponse.prototype._isUrlEncoded = function _isUrlEncoded() {
	        return this._isContentType(ApiResponse._urlencodedContentType);
	    };
	
	    ApiResponse.prototype._isJson = function _isJson() {
	        return this._isContentType(ApiResponse._jsonContentType);
	    };
	
	    /**
	     * Method is used to create ApiResponse object from string parts of multipart/mixed response
	     * @param {string} [text]
	     * @param {number} [status]
	     * @param {string} [statusText]
	     * @return {ApiResponse}
	     */
	
	
	    ApiResponse.create = function create(text, status, statusText) {
	
	        text = text || '';
	        status = status || 200;
	        statusText = statusText || 'OK';
	
	        text = text.replace(/\r/g, '');
	
	        var headers = new _Externals.Headers(),
	            headersAndBody = text.split(ApiResponse._bodySeparator),
	            headersText = headersAndBody.length > 1 ? headersAndBody.shift() : '';
	
	        text = headersAndBody.length > 0 ? headersAndBody.join(ApiResponse._bodySeparator) : null;
	
	        (headersText || '').split('\n').forEach(function (header) {
	
	            var split = header.trim().split(ApiResponse._headerSeparator),
	                key = split.shift().trim(),
	                value = split.join(ApiResponse._headerSeparator).trim();
	
	            if (key) headers.append(key, value);
	        });
	
	        return new ApiResponse(null, new _Externals.Response(text ? text : undefined, {
	            headers: headers,
	            status: status,
	            statusText: statusText
	        }), text);
	    };
	
	    return ApiResponse;
	}();
	
	ApiResponse._contentType = 'Content-Type';
	ApiResponse._jsonContentType = 'application/json';
	ApiResponse._multipartContentType = 'multipart/mixed';
	ApiResponse._urlencodedContentType = 'application/x-www-form-urlencoded';
	ApiResponse._headerSeparator = ':';
	ApiResponse._bodySeparator = '\n\n';
	ApiResponse._boundarySeparator = '--';
	exports.default = ApiResponse;
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Registry = __webpack_require__(13);
	
	var _Registry2 = _interopRequireDefault(_Registry);
	
	var _Client = __webpack_require__(10);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Client = function (_HttpClient) {
	    _inherits(Client, _HttpClient);
	
	    function Client() {
	        _classCallCheck(this, Client);
	
	        var _this = _possibleConstructorReturn(this, _HttpClient.call(this));
	
	        _this._registry = new _Registry2.default();
	        return _this;
	    }
	
	    Client.prototype.registry = function registry() {
	        return this._registry;
	    };
	
	    Client.prototype._loadResponse = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            var mock;
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            mock = this._registry.find(request);
	                            _context.next = 3;
	                            return mock.getResponse(request);
	
	                        case 3:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 4:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function _loadResponse(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return _loadResponse;
	    }();
	
	    return Client;
	}(_Client2.default);
	
	exports.default = Client;
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Mock = __webpack_require__(14);
	
	var _Mock2 = _interopRequireDefault(_Mock);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Registry = function () {
	    function Registry() {
	        _classCallCheck(this, Registry);
	
	        this._mocks = [];
	    }
	
	    Registry.prototype.add = function add(mock) {
	        this._mocks.push(mock);
	        return this;
	    };
	
	    Registry.prototype.clear = function clear() {
	        this._mocks = [];
	        return this;
	    };
	
	    Registry.prototype.find = function find(request) {
	
	        //console.log('Registry is looking for', request);
	
	        var mock = this._mocks.shift();
	
	        if (!mock) throw new Error('No mock in registry for request ' + request.method + ' ' + request.url);
	
	        if (!mock.test(request)) throw new Error('Wrong request ' + request.method + ' ' + request.url + ' for expected mock ' + mock.method() + ' ' + mock.path());
	
	        return mock;
	    };
	
	    Registry.prototype.apiCall = function apiCall(method, path, response, status, statusText, delay) {
	
	        this.add(new _Mock2.default(method, path, response, status, statusText, delay));
	
	        return this;
	    };
	
	    Registry.prototype.authentication = function authentication() {
	
	        this.apiCall('POST', '/restapi/oauth/token', {
	            'access_token': 'ACCESS_TOKEN',
	            'token_type': 'bearer',
	            'expires_in': 3600,
	            'refresh_token': 'REFRESH_TOKEN',
	            'refresh_token_expires_in': 60480,
	            'scope': 'SMS RCM Foo Boo',
	            'expireTime': new Date().getTime() + 3600000
	        });
	
	        return this;
	    };
	
	    Registry.prototype.logout = function logout() {
	
	        this.apiCall('POST', '/restapi/oauth/revoke', {});
	
	        return this;
	    };
	
	    Registry.prototype.presenceLoad = function presenceLoad(id) {
	
	        this.apiCall('GET', '/restapi/v1.0/account/~/extension/' + id + '/presence', {
	            "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id + "/presence",
	            "extension": {
	                "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id,
	                "id": id,
	                "extensionNumber": "101"
	            },
	            "activeCalls": [],
	            "presenceStatus": "Available",
	            "telephonyStatus": "Ringing",
	            "userStatus": "Available",
	            "dndStatus": "TakeAllCalls",
	            "extensionId": id
	        });
	
	        return this;
	    };
	
	    Registry.prototype.subscribeGeneric = function subscribeGeneric(expiresIn) {
	
	        expiresIn = expiresIn || 15 * 60 * 60;
	
	        var date = new Date();
	
	        this.apiCall('POST', '/restapi/v1.0/subscription', {
	            'eventFilters': ['/restapi/v1.0/account/~/extension/~/presence'],
	            'expirationTime': new Date(date.getTime() + expiresIn * 1000).toISOString(),
	            'expiresIn': expiresIn,
	            'deliveryMode': {
	                'transportType': 'PubNub',
	                'encryption': false,
	                'address': '123_foo',
	                'subscriberKey': 'sub-c-foo',
	                'secretKey': 'sec-c-bar'
	            },
	            'id': 'foo-bar-baz',
	            'creationTime': date.toISOString(),
	            'status': 'Active',
	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
	        });
	
	        return this;
	    };
	
	    Registry.prototype.subscribeOnPresence = function subscribeOnPresence(id, detailed) {
	
	        id = id || '1';
	
	        var date = new Date();
	
	        this.apiCall('POST', '/restapi/v1.0/subscription', {
	            'eventFilters': ['/restapi/v1.0/account/~/extension/' + id + '/presence' + (detailed ? '?detailedTelephonyState=true' : '')],
	            'expirationTime': new Date(date.getTime() + 15 * 60 * 60 * 1000).toISOString(),
	            'deliveryMode': {
	                'transportType': 'PubNub',
	                'encryption': true,
	                'address': '123_foo',
	                'subscriberKey': 'sub-c-foo',
	                'secretKey': 'sec-c-bar',
	                'encryptionAlgorithm': 'AES',
	                'encryptionKey': 'VQwb6EVNcQPBhE/JgFZ2zw=='
	            },
	            'creationTime': date.toISOString(),
	            'id': 'foo-bar-baz',
	            'status': 'Active',
	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
	        });
	
	        return this;
	    };
	
	    Registry.prototype.tokenRefresh = function tokenRefresh(failure) {
	
	        if (!failure) {
	
	            this.apiCall('POST', '/restapi/oauth/token', {
	                'access_token': 'ACCESS_TOKEN_FROM_REFRESH',
	                'token_type': 'bearer',
	                'expires_in': 3600,
	                'refresh_token': 'REFRESH_TOKEN_FROM_REFRESH',
	                'refresh_token_expires_in': 60480,
	                'scope': 'SMS RCM Foo Boo'
	            });
	        } else {
	
	            this.apiCall('POST', '/restapi/oauth/token', {
	                'message': 'Wrong token',
	                'error_description': 'Wrong token',
	                'description': 'Wrong token'
	            }, 400);
	        }
	
	        return this;
	    };
	
	    return Registry;
	}();
	
	exports.default = Registry;
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	var _Utils = __webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Mock = function () {
	    function Mock(method, path, json, status, statusText, delay) {
	        _classCallCheck(this, Mock);
	
	        this._method = method.toUpperCase();
	        this._path = path;
	        this._json = json || {};
	        this._delay = delay || 10;
	        this._status = status || 200;
	        this._statusText = statusText || 'OK';
	    }
	
	    Mock.prototype.path = function path() {
	        return this._path;
	    };
	
	    Mock.prototype.method = function method() {
	        return this._method;
	    };
	
	    Mock.prototype.test = function test(request) {
	
	        return request.url.indexOf(this._path) > -1 && request.method.toUpperCase() == this._method;
	    };
	
	    Mock.prototype.getResponse = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return (0, _Utils.delay)(this._delay);
	
	                        case 2:
	                            return _context.abrupt('return', this.createResponse(this._json));
	
	                        case 3:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function getResponse(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return getResponse;
	    }();
	
	    Mock.prototype.createResponse = function createResponse(json, init) {
	
	        init = init || {};
	
	        init.status = init.status || this._status;
	        init.statusText = init.statusText || this._statusText;
	
	        var str = JSON.stringify(json),
	            res = new _Externals.Response(str, init);
	
	        res.headers.set(_ApiResponse2.default._contentType, _ApiResponse2.default._jsonContentType);
	
	        return res;
	    };
	
	    return Mock;
	}();
	
	exports.default = Mock;
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Auth = __webpack_require__(16);
	
	var _Auth2 = _interopRequireDefault(_Auth);
	
	var _Utils = __webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Platform = function (_EventEmitter) {
	    _inherits(Platform, _EventEmitter);
	
	    function Platform(client, cache, server, appKey, appSecret, appName, appVersion, sdkVersion) {
	        _classCallCheck(this, Platform);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.events = {
	            beforeLogin: 'beforeLogin',
	            loginSuccess: 'loginSuccess',
	            loginError: 'loginError',
	            beforeRefresh: 'beforeRefresh',
	            refreshSuccess: 'refreshSuccess',
	            refreshError: 'refreshError',
	            beforeLogout: 'beforeLogout',
	            logoutSuccess: 'logoutSuccess',
	            logoutError: 'logoutError'
	        };
	
	
	        _this._server = server;
	        _this._appKey = appKey;
	        _this._appSecret = appSecret;
	
	        /** @type {Cache} */
	        _this._cache = cache;
	
	        /** @type {Client} */
	        _this._client = client;
	
	        /** @type {Promise<ApiResponse>} */
	        _this._refreshPromise = null;
	
	        _this._auth = new _Auth2.default(_this._cache, Platform._cacheId);
	
	        _this._userAgent = (appName ? appName + (appVersion ? '/' + appVersion : '') + ' ' : '') + 'RCJSSDK/' + sdkVersion;
	
	        return _this;
	    }
	
	    /**
	     * @return {Auth}
	     */
	
	
	    Platform.prototype.auth = function auth() {
	        return this._auth;
	    };
	
	    /**
	     * @return {Client}
	     */
	
	
	    Platform.prototype.client = function client() {
	        return this._client;
	    };
	
	    /**
	     * @param {string} path
	     * @param {object} [options]
	     * @param {boolean} [options.addServer]
	     * @param {string} [options.addMethod]
	     * @param {boolean} [options.addToken]
	     * @return {string}
	     */
	
	
	    Platform.prototype.createUrl = function createUrl(path, options) {
	
	        path = path || '';
	        options = options || {};
	
	        var builtUrl = '',
	            hasHttp = path.indexOf('http://') != -1 || path.indexOf('https://') != -1;
	
	        if (options.addServer && !hasHttp) builtUrl += this._server;
	
	        if (path.indexOf(Platform._urlPrefix) == -1 && !hasHttp) builtUrl += Platform._urlPrefix + '/' + Platform._apiVersion;
	
	        builtUrl += path;
	
	        if (options.addMethod || options.addToken) builtUrl += path.indexOf('?') > -1 ? '&' : '?';
	
	        if (options.addMethod) builtUrl += '_method=' + options.addMethod;
	        if (options.addToken) builtUrl += (options.addMethod ? '&' : '') + 'access_token=' + this._auth.accessToken();
	
	        return builtUrl;
	    };
	
	    /**
	     * @param {string} options.redirectUri
	     * @param {string} options.state
	     * @param {string} options.brandId
	     * @param {string} options.display
	     * @param {string} options.prompt
	     * @param {object} [options]
	     * @return {string}
	     */
	
	
	    Platform.prototype.loginUrl = function loginUrl(options) {
	
	        options = options || {};
	
	        return this.createUrl(Platform._authorizeEndpoint + '?' + (0, _Utils.queryStringify)({
	            'response_type': 'code',
	            'redirect_uri': options.redirectUri || '',
	            'client_id': this._appKey,
	            'state': options.state || '',
	            'brand_id': options.brandId || '',
	            'display': options.display || '',
	            'prompt': options.prompt || ''
	        }), { addServer: true });
	    };
	
	    /**
	     * @param {string} url
	     * @return {Object}
	     */
	
	
	    Platform.prototype.parseLoginRedirectUrl = function parseLoginRedirectUrl(url) {
	
	        var qs = (0, _Utils.parseQueryString)(url.split('?').reverse()[0]),
	            error = qs.error_description || qs.error;
	
	        if (error) {
	            var e = new Error(error);
	            e.error = qs.error;
	            throw e;
	        }
	
	        return qs;
	    };
	
	    /**
	     * Convenience method to handle 3-legged OAuth
	     *
	     * Attention! This is an experimental method and it's signature and behavior may change without notice.
	     *
	     * @experimental
	     * @param {number} [options.width]
	     * @param {number} [options.height]
	     * @param {object} [options.login] additional options for login()
	     * @param {string} [options.origin]
	     * @param {string} [options.property] name of window.postMessage's event data property
	     * @param {string} [options.target] target for window.open()
	     * @param {string} options.url
	     * @return {Promise}
	     */
	
	
	    Platform.prototype.loginWindow = function loginWindow(options) {
	        var _this2 = this;
	
	        return new _Externals.Promise(function (resolve, reject) {
	
	            if (!(0, _Utils.isBrowser)()) throw new Error('This method can be used only in browser');
	
	            if (!options.url) throw new Error('Missing mandatory URL parameter');
	
	            options = options || {};
	            options.url = options.url || 400;
	            options.width = options.width || 400;
	            options.height = options.height || 600;
	            options.origin = options.origin || window.location.origin;
	            options.property = options.property || 'RCAuthorizationCode';
	            options.target = options.target || '_blank';
	
	            var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
	            var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;
	
	            var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
	            var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;
	
	            var left = width / 2 - options.width / 2 + dualScreenLeft;
	            var top = height / 2 - options.height / 2 + dualScreenTop;
	            var win = window.open(options.url, '_blank', options.target == '_blank' ? 'scrollbars=yes, status=yes, width=' + options.width + ', height=' + options.height + ', left=' + left + ', top=' + top : '');
	
	            if (window.focus) win.focus();
	
	            var eventMethod = window.addEventListener ? 'addEventListener' : 'attachEvent';
	            var eventRemoveMethod = eventMethod == 'addEventListener' ? 'removeEventListener' : 'detachEvent';
	            var messageEvent = eventMethod == 'addEventListener' ? 'message' : 'onmessage';
	
	            var eventListener = function eventListener(e) {
	
	                if (e.origin != options.origin) return;
	                if (!e.data || !e.data[options.property]) return; // keep waiting
	
	                win.close();
	                window[eventRemoveMethod](messageEvent, eventListener);
	
	                try {
	
	                    var loginOptions = _this2.parseLoginRedirectUrl(e.data[options.property]);
	
	                    if (!loginOptions.code) throw new Error('No authorization code');
	
	                    resolve(loginOptions);
	                } catch (e) {
	                    reject(e);
	                }
	            };
	
	            window[eventMethod](messageEvent, eventListener, false);
	        });
	    };
	
	    /**
	     * @return {Promise<boolean>}
	     */
	
	
	    Platform.prototype.loggedIn = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.prev = 0;
	                            _context.next = 3;
	                            return this.ensureLoggedIn();
	
	                        case 3:
	                            return _context.abrupt("return", true);
	
	                        case 6:
	                            _context.prev = 6;
	                            _context.t0 = _context["catch"](0);
	                            return _context.abrupt("return", false);
	
	                        case 9:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this, [[0, 6]]);
	        }));
	
	        function loggedIn() {
	            return _ref.apply(this, arguments);
	        }
	
	        return loggedIn;
	    }();
	
	    /**
	     * @param {string} options.username
	     * @param {string} options.password
	     * @param {string} options.extension
	     * @param {string} options.code
	     * @param {string} options.redirectUri
	     * @param {string} options.endpointId
	     * @param {string} options.remember
	     * @param {string} options.accessTokenTtl
	     * @param {string} options.refreshTokenTtl
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.login = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(options) {
	            var body, apiResponse, json;
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.prev = 0;
	
	
	                            options = options || {};
	
	                            this.emit(this.events.beforeLogin);
	
	                            body = {};
	
	
	                            if (!options.code) {
	
	                                body.grant_type = 'password';
	                                body.username = options.username;
	                                body.password = options.password;
	                                body.extension = options.extension || '';
	                            } else if (options.code) {
	
	                                body.grant_type = 'authorization_code';
	                                body.code = options.code;
	                                body.redirect_uri = options.redirectUri;
	                                //body.client_id = this.getCredentials().key; // not needed
	                            }
	
	                            if (options.endpointId) body.endpoint_id = options.endpointId;
	                            if (options.accessTokenTtl) body.accessTokenTtl = options.accessTokenTtl;
	                            if (options.refreshTokenTtl) body.refreshTokenTtl = options.refreshTokenTtl;
	
	                            _context2.next = 10;
	                            return this._tokenRequest(Platform._tokenEndpoint, body);
	
	                        case 10:
	                            apiResponse = _context2.sent;
	                            json = apiResponse.json();
	
	
	                            this._auth.setData(json);
	
	                            this.emit(this.events.loginSuccess, apiResponse);
	
	                            return _context2.abrupt("return", apiResponse);
	
	                        case 17:
	                            _context2.prev = 17;
	                            _context2.t0 = _context2["catch"](0);
	
	
	                            this._cache.clean();
	
	                            this.emit(this.events.loginError, _context2.t0);
	
	                            throw _context2.t0;
	
	                        case 22:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this, [[0, 17]]);
	        }));
	
	        function login(_x) {
	            return _ref2.apply(this, arguments);
	        }
	
	        return login;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     * @private
	     */
	
	
	    Platform.prototype._refresh = function () {
	        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	            var res, json;
	            return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.prev = 0;
	
	
	                            this.emit(this.events.beforeRefresh);
	
	                            _context3.next = 4;
	                            return (0, _Utils.delay)(Platform._refreshDelayMs);
	
	                        case 4:
	                            if (this._auth.refreshToken()) {
	                                _context3.next = 6;
	                                break;
	                            }
	
	                            throw new Error('Refresh token is missing');
	
	                        case 6:
	                            if (this._auth.refreshTokenValid()) {
	                                _context3.next = 8;
	                                break;
	                            }
	
	                            throw new Error('Refresh token has expired');
	
	                        case 8:
	                            _context3.next = 10;
	                            return this._tokenRequest(Platform._tokenEndpoint, {
	                                "grant_type": "refresh_token",
	                                "refresh_token": this._auth.refreshToken(),
	                                "access_token_ttl": this._auth.data().expires_in + 1,
	                                "refresh_token_ttl": this._auth.data().refresh_token_expires_in + 1
	                            });
	
	                        case 10:
	                            res = _context3.sent;
	                            json = res.json();
	
	                            if (json.access_token) {
	                                _context3.next = 14;
	                                break;
	                            }
	
	                            throw this._client.makeError(new Error('Malformed OAuth response'), res);
	
	                        case 14:
	
	                            this._auth.setData(json);
	
	                            this.emit(this.events.refreshSuccess, res);
	
	                            return _context3.abrupt("return", res);
	
	                        case 19:
	                            _context3.prev = 19;
	                            _context3.t0 = _context3["catch"](0);
	
	
	                            _context3.t0 = this._client.makeError(_context3.t0);
	
	                            if (Platform._clearCacheOnRefreshError) {
	                                this._cache.clean();
	                            }
	
	                            this.emit(this.events.refreshError, _context3.t0);
	
	                            throw _context3.t0;
	
	                        case 25:
	                        case "end":
	                            return _context3.stop();
	                    }
	                }
	            }, _callee3, this, [[0, 19]]);
	        }));
	
	        function _refresh() {
	            return _ref3.apply(this, arguments);
	        }
	
	        return _refresh;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.refresh = function () {
	        var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	            var _this3 = this;
	
	            return regeneratorRuntime.wrap(function _callee4$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            if (!this._refreshPromise) {
	                                _context4.next = 2;
	                                break;
	                            }
	
	                            return _context4.abrupt("return", this._refreshPromise);
	
	                        case 2:
	                            _context4.prev = 2;
	
	
	                            this._refreshPromise = this._refresh().then(function (res) {
	                                _this3._refreshPromise = null;
	                                return res;
	                            });
	
	                            return _context4.abrupt("return", this._refreshPromise);
	
	                        case 7:
	                            _context4.prev = 7;
	                            _context4.t0 = _context4["catch"](2);
	
	
	                            this._refreshPromise = null;
	                            throw _context4.t0;
	
	                        case 11:
	                        case "end":
	                            return _context4.stop();
	                    }
	                }
	            }, _callee4, this, [[2, 7]]);
	        }));
	
	        function refresh() {
	            return _ref4.apply(this, arguments);
	        }
	
	        return refresh;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.logout = function () {
	        var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
	            var res;
	            return regeneratorRuntime.wrap(function _callee5$(_context5) {
	                while (1) {
	                    switch (_context5.prev = _context5.next) {
	                        case 0:
	                            _context5.prev = 0;
	
	
	                            this.emit(this.events.beforeLogout);
	
	                            _context5.next = 4;
	                            return this._tokenRequest(Platform._revokeEndpoint, {
	                                token: this._auth.accessToken()
	                            });
	
	                        case 4:
	                            res = _context5.sent;
	
	
	                            this._cache.clean();
	
	                            this.emit(this.events.logoutSuccess, res);
	
	                            return _context5.abrupt("return", res);
	
	                        case 10:
	                            _context5.prev = 10;
	                            _context5.t0 = _context5["catch"](0);
	
	
	                            this.emit(this.events.logoutError, _context5.t0);
	
	                            throw _context5.t0;
	
	                        case 14:
	                        case "end":
	                            return _context5.stop();
	                    }
	                }
	            }, _callee5, this, [[0, 10]]);
	        }));
	
	        function logout() {
	            return _ref5.apply(this, arguments);
	        }
	
	        return logout;
	    }();
	
	    /**
	     * @param {Request} request
	     * @param {object} [options]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<Request>}
	     */
	
	
	    Platform.prototype.inflateRequest = function () {
	        var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(request, options) {
	            return regeneratorRuntime.wrap(function _callee6$(_context6) {
	                while (1) {
	                    switch (_context6.prev = _context6.next) {
	                        case 0:
	
	                            options = options || {};
	
	                            if (!options.skipAuthCheck) {
	                                _context6.next = 3;
	                                break;
	                            }
	
	                            return _context6.abrupt("return", request);
	
	                        case 3:
	                            _context6.next = 5;
	                            return this.ensureLoggedIn();
	
	                        case 5:
	
	                            request.headers.set('X-User-Agent', this._userAgent);
	                            request.headers.set('Client-Id', this._appKey);
	                            request.headers.set('Authorization', this._authHeader());
	                            //request.url = this.createUrl(request.url, {addServer: true}); //FIXME Spec prevents this...
	
	                            return _context6.abrupt("return", request);
	
	                        case 9:
	                        case "end":
	                            return _context6.stop();
	                    }
	                }
	            }, _callee6, this);
	        }));
	
	        function inflateRequest(_x2, _x3) {
	            return _ref6.apply(this, arguments);
	        }
	
	        return inflateRequest;
	    }();
	
	    /**
	     * @param {Request} request
	     * @param {object} [options]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.sendRequest = function () {
	        var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(request, options) {
	            return regeneratorRuntime.wrap(function _callee7$(_context7) {
	                while (1) {
	                    switch (_context7.prev = _context7.next) {
	                        case 0:
	                            _context7.prev = 0;
	                            _context7.next = 3;
	                            return this.inflateRequest(request, options);
	
	                        case 3:
	                            request = _context7.sent;
	                            _context7.next = 6;
	                            return this._client.sendRequest(request);
	
	                        case 6:
	                            return _context7.abrupt("return", _context7.sent);
	
	                        case 9:
	                            _context7.prev = 9;
	                            _context7.t0 = _context7["catch"](0);
	
	                            if (!(!_context7.t0.apiResponse || !_context7.t0.apiResponse.response() || _context7.t0.apiResponse.response().status != 401)) {
	                                _context7.next = 13;
	                                break;
	                            }
	
	                            throw _context7.t0;
	
	                        case 13:
	
	                            this._auth.cancelAccessToken();
	
	                            _context7.next = 16;
	                            return this.sendRequest(request, options);
	
	                        case 16:
	                            return _context7.abrupt("return", _context7.sent);
	
	                        case 17:
	                        case "end":
	                            return _context7.stop();
	                    }
	                }
	            }, _callee7, this, [[0, 9]]);
	        }));
	
	        function sendRequest(_x4, _x5) {
	            return _ref7.apply(this, arguments);
	        }
	
	        return sendRequest;
	    }();
	
	    /**
	     * General purpose function to send anything to server
	     * @param {string} options.url
	     * @param {object} [options.body]
	     * @param {string} [options.method]
	     * @param {object} [options.query]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.send = function () {
	        var _ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
	            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	            return regeneratorRuntime.wrap(function _callee8$(_context8) {
	                while (1) {
	                    switch (_context8.prev = _context8.next) {
	                        case 0:
	
	                            //FIXME https://github.com/bitinn/node-fetch/issues/43
	                            options.url = this.createUrl(options.url, { addServer: true });
	
	                            _context8.next = 3;
	                            return this.sendRequest(this._client.createRequest(options), options);
	
	                        case 3:
	                            return _context8.abrupt("return", _context8.sent);
	
	                        case 4:
	                        case "end":
	                            return _context8.stop();
	                    }
	                }
	            }, _callee8, this);
	        }));
	
	        function send(_x6) {
	            return _ref8.apply(this, arguments);
	        }
	
	        return send;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.get = function () {
	        var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(url, query, options) {
	            return regeneratorRuntime.wrap(function _callee9$(_context9) {
	                while (1) {
	                    switch (_context9.prev = _context9.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'GET';
	                            options.url = url;
	                            options.query = query;
	                            _context9.next = 6;
	                            return this.send(options);
	
	                        case 6:
	                            return _context9.abrupt("return", _context9.sent);
	
	                        case 7:
	                        case "end":
	                            return _context9.stop();
	                    }
	                }
	            }, _callee9, this);
	        }));
	
	        function get(_x8, _x9, _x10) {
	            return _ref9.apply(this, arguments);
	        }
	
	        return get;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} body
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.post = function () {
	        var _ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(url, body, query, options) {
	            return regeneratorRuntime.wrap(function _callee10$(_context10) {
	                while (1) {
	                    switch (_context10.prev = _context10.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'POST';
	                            options.url = url;
	                            options.query = query;
	                            options.body = body;
	                            _context10.next = 7;
	                            return this.send(options);
	
	                        case 7:
	                            return _context10.abrupt("return", _context10.sent);
	
	                        case 8:
	                        case "end":
	                            return _context10.stop();
	                    }
	                }
	            }, _callee10, this);
	        }));
	
	        function post(_x11, _x12, _x13, _x14) {
	            return _ref10.apply(this, arguments);
	        }
	
	        return post;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} [body]
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.put = function () {
	        var _ref11 = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(url, body, query, options) {
	            return regeneratorRuntime.wrap(function _callee11$(_context11) {
	                while (1) {
	                    switch (_context11.prev = _context11.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'PUT';
	                            options.url = url;
	                            options.query = query;
	                            options.body = body;
	                            _context11.next = 7;
	                            return this.send(options);
	
	                        case 7:
	                            return _context11.abrupt("return", _context11.sent);
	
	                        case 8:
	                        case "end":
	                            return _context11.stop();
	                    }
	                }
	            }, _callee11, this);
	        }));
	
	        function put(_x15, _x16, _x17, _x18) {
	            return _ref11.apply(this, arguments);
	        }
	
	        return put;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {string} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype['delete'] = function () {
	        var _ref12 = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(url, query, options) {
	            return regeneratorRuntime.wrap(function _callee12$(_context12) {
	                while (1) {
	                    switch (_context12.prev = _context12.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'DELETE';
	                            options.url = url;
	                            options.query = query;
	                            _context12.next = 6;
	                            return this.send(options);
	
	                        case 6:
	                            return _context12.abrupt("return", _context12.sent);
	
	                        case 7:
	                        case "end":
	                            return _context12.stop();
	                    }
	                }
	            }, _callee12, this);
	        }));
	
	        function _delete(_x19, _x20, _x21) {
	            return _ref12.apply(this, arguments);
	        }
	
	        return _delete;
	    }();
	
	    Platform.prototype._tokenRequest = function () {
	        var _ref13 = _asyncToGenerator(regeneratorRuntime.mark(function _callee13(path, body) {
	            return regeneratorRuntime.wrap(function _callee13$(_context13) {
	                while (1) {
	                    switch (_context13.prev = _context13.next) {
	                        case 0:
	                            _context13.next = 2;
	                            return this.send({
	                                url: path,
	                                skipAuthCheck: true,
	                                body: body,
	                                method: 'POST',
	                                headers: {
	                                    'Authorization': 'Basic ' + this._apiKey(),
	                                    'Content-Type': 'application/x-www-form-urlencoded'
	                                }
	                            });
	
	                        case 2:
	                            return _context13.abrupt("return", _context13.sent);
	
	                        case 3:
	                        case "end":
	                            return _context13.stop();
	                    }
	                }
	            }, _callee13, this);
	        }));
	
	        function _tokenRequest(_x22, _x23) {
	            return _ref13.apply(this, arguments);
	        }
	
	        return _tokenRequest;
	    }();
	
	    Platform.prototype.ensureLoggedIn = function () {
	        var _ref14 = _asyncToGenerator(regeneratorRuntime.mark(function _callee14() {
	            return regeneratorRuntime.wrap(function _callee14$(_context14) {
	                while (1) {
	                    switch (_context14.prev = _context14.next) {
	                        case 0:
	                            if (!this._isAccessTokenValid()) {
	                                _context14.next = 2;
	                                break;
	                            }
	
	                            return _context14.abrupt("return", null);
	
	                        case 2:
	                            _context14.next = 4;
	                            return this.refresh();
	
	                        case 4:
	                            return _context14.abrupt("return", _context14.sent);
	
	                        case 5:
	                        case "end":
	                            return _context14.stop();
	                    }
	                }
	            }, _callee14, this);
	        }));
	
	        function ensureLoggedIn() {
	            return _ref14.apply(this, arguments);
	        }
	
	        return ensureLoggedIn;
	    }();
	
	    Platform.prototype._isAccessTokenValid = function _isAccessTokenValid() {
	        return this._auth.accessTokenValid();
	    };
	
	    Platform.prototype._apiKey = function _apiKey() {
	        var apiKey = this._appKey + ':' + this._appSecret;
	        return typeof btoa == 'function' ? btoa(apiKey) : new Buffer(apiKey).toString('base64');
	    };
	
	    Platform.prototype._authHeader = function _authHeader() {
	        var token = this._auth.accessToken();
	        return this._auth.tokenType() + (token ? ' ' + token : '');
	    };
	
	    return Platform;
	}(_events2.default);
	
	Platform._urlPrefix = '/restapi';
	Platform._apiVersion = 'v1.0';
	Platform._tokenEndpoint = '/restapi/oauth/token';
	Platform._revokeEndpoint = '/restapi/oauth/revoke';
	Platform._authorizeEndpoint = '/restapi/oauth/authorize';
	Platform._refreshDelayMs = 100;
	Platform._cacheId = 'platform';
	Platform._clearCacheOnRefreshError = false;
	exports.default = Platform;
	
	/***/ },
	/* 16 */
	/***/ function(module, exports) {
	
	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Auth = function () {
	    function Auth(cache, cacheId) {
	        _classCallCheck(this, Auth);
	
	        /** @type {Cache} */
	        this._cache = cache;
	        this._cacheId = cacheId;
	    } // 1 minute
	
	
	    Auth.prototype.accessToken = function accessToken() {
	        return this.data().access_token;
	    };
	
	    Auth.prototype.refreshToken = function refreshToken() {
	        return this.data().refresh_token;
	    };
	
	    Auth.prototype.tokenType = function tokenType() {
	        return this.data().token_type;
	    };
	
	    /**
	     * @return {{token_type: string, access_token: string, expires_in: number, refresh_token: string, refresh_token_expires_in: number}}
	     */
	
	
	    Auth.prototype.data = function data() {
	
	        return this._cache.getItem(this._cacheId) || {
	            token_type: '',
	            access_token: '',
	            expires_in: 0,
	            refresh_token: '',
	            refresh_token_expires_in: 0
	        };
	    };
	
	    /**
	     * @param {object} newData
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.setData = function setData(newData) {
	
	        newData = newData || {};
	
	        var data = this.data();
	
	        Object.keys(newData).forEach(function (key) {
	            data[key] = newData[key];
	        });
	
	        data.expire_time = Date.now() + data.expires_in * 1000;
	        data.refresh_token_expire_time = Date.now() + data.refresh_token_expires_in * 1000;
	
	        this._cache.setItem(this._cacheId, data);
	
	        return this;
	    };
	
	    /**
	     * Check if there is a valid (not expired) access token
	     * @return {boolean}
	     */
	
	
	    Auth.prototype.accessTokenValid = function accessTokenValid() {
	
	        var authData = this.data();
	        return authData.token_type === Auth.forcedTokenType || authData.expire_time - Auth.refreshHandicapMs > Date.now();
	    };
	
	    /**
	     * Check if there is a valid (not expired) access token
	     * @return {boolean}
	     */
	
	
	    Auth.prototype.refreshTokenValid = function refreshTokenValid() {
	
	        return this.data().refresh_token_expire_time > Date.now();
	    };
	
	    /**
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.cancelAccessToken = function cancelAccessToken() {
	
	        return this.setData({
	            access_token: '',
	            expires_in: 0
	        });
	    };
	
	    /**
	     * This method sets a special authentication mode used in Service Web
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.forceAuthentication = function forceAuthentication() {
	
	        this.setData({
	            token_type: Auth.forcedTokenType,
	            access_token: '',
	            expires_in: 0,
	            refresh_token: '',
	            refresh_token_expires_in: 0
	        });
	
	        return this;
	    };
	
	    return Auth;
	}();
	
	//export interface IAuthData {
	//    remember?:boolean;
	//    token_type?:string;
	//    access_token?:string;
	//    expires_in?:number; // actually it's string
	//    expire_time?:number;
	//    refresh_token?:string;
	//    refresh_token_expires_in?:number; // actually it's string
	//    refresh_token_expire_time?:number;
	//    scope?:string;
	//}
	
	
	Auth.refreshHandicapMs = 60 * 1000;
	Auth.forcedTokenType = 'forced';
	exports.default = Auth;
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _PubnubMock = __webpack_require__(18);
	
	var _PubnubMock2 = _interopRequireDefault(_PubnubMock);
	
	var _Externals = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PubnubMockFactory = function () {
	    function PubnubMockFactory() {
	        _classCallCheck(this, PubnubMockFactory);
	
	        this.crypto_obj = _Externals.PUBNUB.crypto_obj;
	    }
	
	    PubnubMockFactory.prototype.init = function init(options) {
	        return new _PubnubMock2.default(options);
	    };
	
	    return PubnubMockFactory;
	}();
	
	exports.default = PubnubMockFactory;
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Externals = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PubnubMock = function (_EventEmitter) {
	    _inherits(PubnubMock, _EventEmitter);
	
	    function PubnubMock(options) {
	        _classCallCheck(this, PubnubMock);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.options = options;
	        _this.crypto_obj = _Externals.PUBNUB.crypto_obj;
	        return _this;
	    }
	
	    PubnubMock.prototype.init = function init(options) {
	        this.options = options;
	    };
	
	    PubnubMock.prototype.ready = function ready() {};
	
	    PubnubMock.prototype.subscribe = function subscribe(options) {
	        this.on('message-' + options.channel, options.message);
	    };
	
	    PubnubMock.prototype.unsubscribe = function unsubscribe(options) {
	        this.removeAllListeners('message-' + options.channel);
	    };
	
	    PubnubMock.prototype.receiveMessage = function receiveMessage(msg, channel) {
	        this.emit('message-' + channel, msg, 'env', channel);
	    };
	
	    return PubnubMock;
	}(_events2.default);
	
	exports.default = PubnubMock;
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Subscription = function (_EventEmitter) {
	    _inherits(Subscription, _EventEmitter);
	
	    function Subscription(pubnubFactory, platform) {
	        _classCallCheck(this, Subscription);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.events = {
	            notification: 'notification',
	            removeSuccess: 'removeSuccess',
	            removeError: 'removeError',
	            renewSuccess: 'renewSuccess',
	            renewError: 'renewError',
	            subscribeSuccess: 'subscribeSuccess',
	            subscribeError: 'subscribeError'
	        };
	
	
	        _this._pubnubFactory = pubnubFactory;
	        _this._platform = platform;
	        _this._pubnub = null;
	        _this._pubnubLastChannel = null;
	        _this._timeout = null;
	        _this._subscription = null;
	
	        return _this;
	    }
	
	    Subscription.prototype.subscribed = function subscribed() {
	
	        var subscription = this.subscription();
	
	        return !!(subscription.id && subscription.deliveryMode && subscription.deliveryMode.subscriberKey && subscription.deliveryMode.address);
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    Subscription.prototype.alive = function alive() {
	        return this.subscribed() && Date.now() < this.expirationTime();
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    Subscription.prototype.expired = function expired() {
	        if (!this.subscribed()) return true;
	        return !this.subscribed() || Date.now() > this.subscription().expirationTime;
	    };
	
	    Subscription.prototype.expirationTime = function expirationTime() {
	        return new Date(this.subscription().expirationTime || 0).getTime() - Subscription._renewHandicapMs;
	    };
	
	    Subscription.prototype.setSubscription = function setSubscription(subscription) {
	
	        subscription = subscription || {};
	
	        this._clearTimeout();
	        this._setSubscription(subscription);
	        this._subscribeAtPubnub();
	        this._setTimeout();
	
	        return this;
	    };
	
	    Subscription.prototype.subscription = function subscription() {
	        return this._subscription || {};
	    };
	
	    /**
	     * Creates or updates subscription if there is an active one
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.register = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!this.alive()) {
	                                _context.next = 6;
	                                break;
	                            }
	
	                            _context.next = 3;
	                            return this.renew();
	
	                        case 3:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 6:
	                            _context.next = 8;
	                            return this.subscribe();
	
	                        case 8:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 9:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function register() {
	            return _ref.apply(this, arguments);
	        }
	
	        return register;
	    }();
	
	    Subscription.prototype.eventFilters = function eventFilters() {
	        return this.subscription().eventFilters || [];
	    };
	
	    /**
	     * @param {string[]} events
	     * @return {Subscription}
	     */
	
	
	    Subscription.prototype.addEventFilters = function addEventFilters(events) {
	        this.setEventFilters(this.eventFilters().concat(events));
	        return this;
	    };
	
	    /**
	     * @param {string[]} events
	     * @return {Subscription}
	     */
	
	
	    Subscription.prototype.setEventFilters = function setEventFilters(events) {
	        var subscription = this.subscription();
	        subscription.eventFilters = events;
	        this._setSubscription(subscription);
	        return this;
	    };
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.subscribe = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	            var response, json;
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.prev = 0;
	
	
	                            this._clearTimeout();
	
	                            if (this.eventFilters().length) {
	                                _context2.next = 4;
	                                break;
	                            }
	
	                            throw new Error('Events are undefined');
	
	                        case 4:
	                            _context2.next = 6;
	                            return this._platform.post('/subscription', {
	                                eventFilters: this._getFullEventFilters(),
	                                deliveryMode: {
	                                    transportType: 'PubNub'
	                                }
	                            });
	
	                        case 6:
	                            response = _context2.sent;
	                            json = response.json();
	
	
	                            this.setSubscription(json).emit(this.events.subscribeSuccess, response);
	
	                            return _context2.abrupt('return', response);
	
	                        case 12:
	                            _context2.prev = 12;
	                            _context2.t0 = _context2['catch'](0);
	
	
	                            _context2.t0 = this._platform.client().makeError(_context2.t0);
	
	                            this.reset().emit(this.events.subscribeError, _context2.t0);
	
	                            throw _context2.t0;
	
	                        case 17:
	                        case 'end':
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this, [[0, 12]]);
	        }));
	
	        function subscribe() {
	            return _ref2.apply(this, arguments);
	        }
	
	        return subscribe;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.renew = function () {
	        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	            var response, json;
	            return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.prev = 0;
	
	
	                            this._clearTimeout();
	
	                            if (this.subscribed()) {
	                                _context3.next = 4;
	                                break;
	                            }
	
	                            throw new Error('No subscription');
	
	                        case 4:
	                            if (this.eventFilters().length) {
	                                _context3.next = 6;
	                                break;
	                            }
	
	                            throw new Error('Events are undefined');
	
	                        case 6:
	                            _context3.next = 8;
	                            return this._platform.put('/subscription/' + this.subscription().id, {
	                                eventFilters: this._getFullEventFilters()
	                            });
	
	                        case 8:
	                            response = _context3.sent;
	                            json = response.json();
	
	
	                            this.setSubscription(json).emit(this.events.renewSuccess, response);
	
	                            return _context3.abrupt('return', response);
	
	                        case 14:
	                            _context3.prev = 14;
	                            _context3.t0 = _context3['catch'](0);
	
	
	                            _context3.t0 = this._platform.client().makeError(_context3.t0);
	
	                            this.reset().emit(this.events.renewError, _context3.t0);
	
	                            throw _context3.t0;
	
	                        case 19:
	                        case 'end':
	                            return _context3.stop();
	                    }
	                }
	            }, _callee3, this, [[0, 14]]);
	        }));
	
	        function renew() {
	            return _ref3.apply(this, arguments);
	        }
	
	        return renew;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.remove = function () {
	        var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	            var response;
	            return regeneratorRuntime.wrap(function _callee4$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            _context4.prev = 0;
	
	                            if (this.subscribed()) {
	                                _context4.next = 3;
	                                break;
	                            }
	
	                            throw new Error('No subscription');
	
	                        case 3:
	                            _context4.next = 5;
	                            return this._platform.delete('/subscription/' + this.subscription().id);
	
	                        case 5:
	                            response = _context4.sent;
	
	
	                            this.reset().emit(this.events.removeSuccess, response);
	
	                            return _context4.abrupt('return', response);
	
	                        case 10:
	                            _context4.prev = 10;
	                            _context4.t0 = _context4['catch'](0);
	
	
	                            _context4.t0 = this._platform.client().makeError(_context4.t0);
	
	                            this.emit(this.events.removeError, _context4.t0);
	
	                            throw _context4.t0;
	
	                        case 15:
	                        case 'end':
	                            return _context4.stop();
	                    }
	                }
	            }, _callee4, this, [[0, 10]]);
	        }));
	
	        function remove() {
	            return _ref4.apply(this, arguments);
	        }
	
	        return remove;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.resubscribe = function resubscribe() {
	        var filters = this.eventFilters();
	        return this.reset().setEventFilters(filters).subscribe();
	    };
	
	    /**
	     * Remove subscription and disconnect from PUBNUB
	     * This method resets subscription at client side but backend is not notified
	     */
	
	
	    Subscription.prototype.reset = function reset() {
	        this._clearTimeout();
	        if (this.subscribed() && this._pubnub) this._pubnub.unsubscribe({ channel: this.subscription().deliveryMode.address });
	        this._setSubscription(null);
	        return this;
	    };
	
	    Subscription.prototype._setSubscription = function _setSubscription(subscription) {
	        this._subscription = subscription;
	    };
	
	    Subscription.prototype._getFullEventFilters = function _getFullEventFilters() {
	        var _this2 = this;
	
	        return this.eventFilters().map(function (event) {
	            return _this2._platform.createUrl(event);
	        });
	    };
	
	    Subscription.prototype._setTimeout = function _setTimeout() {
	        var _this3 = this;
	
	        this._clearTimeout();
	
	        if (!this.alive()) throw new Error('Subscription is not alive');
	
	        this._timeout = setInterval(function () {
	
	            if (_this3.alive()) return;
	
	            if (_this3.expired()) {
	                _this3.subscribe();
	            } else {
	                _this3.renew();
	            }
	        }, Subscription._pollInterval);
	
	        return this;
	    };
	
	    Subscription.prototype._clearTimeout = function _clearTimeout() {
	        clearInterval(this._timeout);
	        return this;
	    };
	
	    Subscription.prototype._decrypt = function _decrypt(message) {
	
	        if (!this.subscribed()) throw new Error('No subscription');
	
	        if (this.subscription().deliveryMode.encryptionKey) {
	
	            message = this._pubnubFactory.crypto_obj.decrypt(message, this.subscription().deliveryMode.encryptionKey, {
	                encryptKey: false,
	                keyEncoding: 'base64',
	                keyLength: 128,
	                mode: 'ecb'
	            });
	        }
	
	        return message;
	    };
	
	    Subscription.prototype._notify = function _notify(message) {
	        this.emit(this.events.notification, this._decrypt(message));
	        return this;
	    };
	
	    Subscription.prototype._subscribeAtPubnub = function _subscribeAtPubnub() {
	
	        if (!this.alive()) throw new Error('Subscription is not alive');
	
	        var deliveryMode = this.subscription().deliveryMode;
	
	        if (this._pubnub) {
	
	            if (this._pubnubLastChannel == deliveryMode.address) {
	                // Nothing to update, keep listening to same channel
	                return this;
	            } else if (this._pubnubLastChannel) {
	                // Need to subscribe to new channel
	                this._pubnub.unsubscribe({ channel: this._pubnubLastChannel });
	            }
	
	            // Re-init for new data
	            this._pubnub = this._pubnub.init({
	                ssl: true,
	                subscribe_key: deliveryMode.subscriberKey
	            });
	        } else {
	
	            // Init from scratch
	            this._pubnub = this._pubnubFactory.init({
	                ssl: true,
	                subscribe_key: deliveryMode.subscriberKey
	            });
	
	            this._pubnub.ready(); //TODO This may be not needed anymore
	        }
	
	        this._pubnubLastChannel = deliveryMode.address;
	
	        this._pubnub.subscribe({
	            channel: deliveryMode.address,
	            message: this._notify.bind(this),
	            connect: function connect() {}
	        });
	
	        return this;
	    };
	
	    return Subscription;
	}(_events2.default);
	
	//export interface ISubscription {
	//    id?:string;
	//    uri?: string;
	//    eventFilters?:string[];
	//    expirationTime?:string; // 2014-03-12T19:54:35.613Z
	//    expiresIn?:number;
	//    deliveryMode?: {
	//        transportType?:string;
	//        encryption?:boolean;
	//        address?:string;
	//        subscriberKey?:string;
	//        encryptionKey?:string;
	//        secretKey?:string;
	//    };
	//    creationTime?:string; // 2014-03-12T19:54:35.613Z
	//    status?:string; // Active
	//}
	
	
	Subscription._renewHandicapMs = 2 * 60 * 1000;
	Subscription._pollInterval = 10 * 1000;
	exports.default = Subscription;
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _Subscription2 = __webpack_require__(19);
	
	var _Subscription3 = _interopRequireDefault(_Subscription2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CachedSubscription = function (_Subscription) {
	    _inherits(CachedSubscription, _Subscription);
	
	    function CachedSubscription(pubnubFactory, platform, cache, cacheKey) {
	        _classCallCheck(this, CachedSubscription);
	
	        /** @type {Cache} */
	
	        var _this = _possibleConstructorReturn(this, _Subscription.call(this, pubnubFactory, platform));
	
	        _this._cache = cache;
	        _this._cacheKey = cacheKey;
	
	        return _this;
	    }
	
	    CachedSubscription.prototype.subscription = function subscription() {
	        return this._cache.getItem(this._cacheKey) || {};
	    };
	
	    CachedSubscription.prototype._setSubscription = function _setSubscription(subscription) {
	        return this._cache.setItem(this._cacheKey, subscription);
	    };
	
	    /**
	     * This function checks whether there are any pre-defined eventFilters in cache and if not -- uses provided as defaults
	     * @param {string[]} events
	     * @return {CachedSubscription}
	     */
	
	
	    CachedSubscription.prototype.restore = function restore(events) {
	
	        if (!this.eventFilters().length) {
	            this.setEventFilters(events);
	        }
	
	        return this;
	    };
	
	    return CachedSubscription;
	}(_Subscription3.default);
	
	exports.default = CachedSubscription;
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=ringcentral.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121), __webpack_require__(122).Buffer))

/***/ },
/* 121 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(123)
	var ieee754 = __webpack_require__(124)
	var isArray = __webpack_require__(125)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(122).Buffer, (function() { return this; }())))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 124 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 125 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.2.1
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(128);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	      var parent = this;
	
	      var child = new this.constructor(lib$es6$promise$$internal$$noop);
	
	      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
	        lib$es6$promise$$internal$$makePromise(child);
	      }
	
	      var state = parent._state;
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$es6$promise$asap$$asap(function(){
	          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
	        });
	      } else {
	        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$es6$promise$then$$default &&
	          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    var lib$es6$promise$$internal$$id = 0;
	    function lib$es6$promise$$internal$$nextId() {
	      return lib$es6$promise$$internal$$id++;
	    }
	
	    function lib$es6$promise$$internal$$makePromise(promise) {
	      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
	      promise._state = undefined;
	      promise._result = undefined;
	      promise._subscribers = [];
	    }
	
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        return new Constructor(function(resolve, reject) {
	          reject(new TypeError('You must pass an array to race.'));
	        });
	      } else {
	        return new Constructor(function(resolve, reject) {
	          var length = entries.length;
	          for (var i = 0; i < length; i++) {
	            Constructor.resolve(entries[i]).then(resolve, reject);
	          }
	        });
	      }
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
	      this._result = this._state = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$es6$promise$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
	        lib$es6$promise$$internal$$makePromise(this.promise);
	      }
	
	      if (lib$es6$promise$utils$$isArray(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._result = new Array(this.length);
	
	        if (this.length === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
	      }
	    }
	
	    function lib$es6$promise$enumerator$$validationError() {
	      return new Error('Array Methods must be provided an Array');
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length  = this.length;
	      var input   = this._input;
	
	      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$es6$promise$promise$resolve$$default) {
	        var then = lib$es6$promise$$internal$$getThen(entry);
	
	        if (then === lib$es6$promise$then$$default &&
	            entry._state !== lib$es6$promise$$internal$$PENDING) {
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = entry;
	        } else if (c === lib$es6$promise$promise$$default) {
	          var promise = new c(lib$es6$promise$$internal$$noop);
	          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        this._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = value;
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(129)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121), (function() { return this; }()), __webpack_require__(127)(module)))

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 128 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 130 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var list = this.map[name]
	    if (!list) {
	      list = []
	      this.map[name] = list
	    }
	    list.push(value)
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    var values = this.map[normalizeName(name)]
	    return values ? values[0] : null
	  }
	
	  Headers.prototype.getAll = function(name) {
	    return this.map[normalizeName(name)] || []
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = [normalizeValue(value)]
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    Object.getOwnPropertyNames(this.map).forEach(function(name) {
	      this.map[name].forEach(function(value) {
	        callback.call(thisArg, value, name, this)
	      }, this)
	    }, this)
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    reader.readAsArrayBuffer(blob)
	    return fileReaderReady(reader)
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    reader.readAsText(blob)
	    return fileReaderReady(reader)
	  }
	
	  var support = {
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (!body) {
	        this._bodyText = ''
	      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
	        // Only support ArrayBuffers for POST method.
	        // Receiving ArrayBuffers happens via Blobs, instead.
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        return this.blob().then(readBlobAsArrayBuffer)
	      }
	
	      this.text = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return readBlobAsText(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as text')
	        } else {
	          return Promise.resolve(this._bodyText)
	        }
	      }
	    } else {
	      this.text = function() {
	        var rejected = consumed(this)
	        return rejected ? rejected : Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	    if (Request.prototype.isPrototypeOf(input)) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = input
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this)
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function headers(xhr) {
	    var head = new Headers()
	    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
	    pairs.forEach(function(header) {
	      var split = header.trim().split(':')
	      var key = split.shift().trim()
	      var value = split.join(':').trim()
	      head.append(key, value)
	    })
	    return head
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = options.status
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = options.statusText
	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request
	      if (Request.prototype.isPrototypeOf(input) && !init) {
	        request = input
	      } else {
	        request = new Request(input, init)
	      }
	
	      var xhr = new XMLHttpRequest()
	
	      function responseURL() {
	        if ('responseURL' in xhr) {
	          return xhr.responseURL
	        }
	
	        // Avoid security warnings on getResponseHeader when not allowed by CORS
	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	          return xhr.getResponseHeader('X-Request-URL')
	        }
	
	        return
	      }
	
	      xhr.onload = function() {
	        var status = (xhr.status === 1223) ? 204 : xhr.status
	        if (status < 100 || status > 599) {
	          reject(new TypeError('Network request failed'))
	          return
	        }
	        var options = {
	          status: status,
	          statusText: xhr.statusText,
	          headers: headers(xhr),
	          url: responseURL()
	        }
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/*! 3.15.2 / modern */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["PUBNUB"] = factory();
		else
			root["PUBNUB"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* globals 'Modern' */
		/* eslint curly: 0, camelcase: 0, dot-notation: 0 */
	
		var packageJSON = __webpack_require__(1);
		var pubNubCore = __webpack_require__(2);
		var crypto_obj = __webpack_require__(5);
		var CryptoJS = __webpack_require__(6);
		var WS = __webpack_require__(7);
	
		/**
		 * UTIL LOCALS
		 */
		var PNSDK = 'PubNub-JS-' + 'Modern' + '/' + packageJSON.version;
	
		/**
		 * LOCAL STORAGE
		 */
		var db = (function () {
		  var ls = typeof localStorage !== 'undefined' && localStorage;
		  return {
		    get: function (key) {
		      try {
		        if (ls) return ls.getItem(key);
		        if (document.cookie.indexOf(key) === -1) return null;
		        return ((document.cookie || '').match(
		            RegExp(key + '=([^;]+)')
		          ) || [])[1] || null;
		      } catch (e) {
		        return;
		      }
		    },
		    set: function (key, value) {
		      try {
		        if (ls) return ls.setItem(key, value) && 0;
		        document.cookie = key + '=' + value +
		          '; expires=Thu, 1 Aug 2030 20:00:00 UTC; path=/';
		      } catch (e) {
		        return;
		      }
		    }
		  };
		})();
	
	
		/**
		 * CORS XHR Request
		 * ================
		 *  xdr({
		 *     url     : ['http://www.blah.com/url'],
		 *     success : function(response) {},
		 *     fail    : function() {}
		 *  });
		 */
		function xdr(setup) {
		  var xhr;
		  var timer;
		  var complete = 0;
		  var loaded = 0;
		  var async = true; /* do not allow sync operations in modern builds */
		  var xhrtme = setup.timeout || pubNubCore.DEF_TIMEOUT;
		  var data = setup.data || {};
		  var fail = setup.fail || function () {};
		  var success = setup.success || function () {};
	
		  var done = function (failed, response) {
		    if (complete) return;
		    complete = 1;
	
		    clearTimeout(timer);
	
		    if (xhr) {
		      xhr.onerror = xhr.onload = null;
		      if (xhr.abort) xhr.abort();
		      xhr = null;
		    }
	
		    if (failed) fail(response);
		  };
	
		  var finished = function () {
		    if (loaded) return;
		    var response;
		    loaded = 1;
	
		    clearTimeout(timer);
	
		    try {
		      response = JSON.parse(xhr.responseText);
		    } catch (r) {
		      return done(1);
		    }
	
		    success(response);
		  };
	
		  timer = pubNubCore.timeout(function () {
		    done(1);
		  }, xhrtme);
	
		  // Send
		  try {
		    xhr = typeof XDomainRequest !== 'undefined' &&
		      new XDomainRequest() ||
		      new XMLHttpRequest();
	
		    xhr.onerror = xhr.onabort = function () {
		      done(1, xhr.responseText || { error: 'Network Connection Error' });
		    };
		    xhr.onload = xhr.onloadend = finished;
	
		    data.pnsdk = PNSDK;
		    var url = pubNubCore.build_url(setup.url, data);
		    xhr.open('GET', url, async);
		    if (async) xhr.timeout = xhrtme;
		    xhr.send();
		  } catch (eee) {
		    done(1, { error: 'XHR Failed', stacktrace: eee });
		  }
	
		  // Return 'done'
		  return done;
		}
	
		/**
		 * BIND
		 * ====
		 * bind( 'keydown', search('a')[0], function(element) {
		 *     ...
		 * } );
		 */
		function bind(type, el, fun) {
		  pubNubCore.each(type.split(','), function (etype) {
		    var rapfun = function (e) {
		      if (!e) e = window.event;
		      if (!fun(e)) {
		        e.cancelBubble = true;
		        e.returnValue = false;
		        if (e.preventDefault) e.preventDefault();
		        if (e.stopPropagation) e.stopPropagation();
		      }
		    };
	
		    if (el.addEventListener) el.addEventListener(etype, rapfun, false);
		    else if (el.attachEvent) el.attachEvent('on' + etype, rapfun);
		    else el['on' + etype] = rapfun;
		  });
		}
	
		/**
		 * ERROR
		 * ===
		 * error('message');
		 */
		function error(message) {
		  console.error(message); // eslint-disable-line no-console
		}
	
		/**
		 * EVENTS
		 * ======
		 * PUBNUB.events.bind( 'you-stepped-on-flower', function(message) {
		 *     // Do Stuff with message
		 * } );
		 *
		 * PUBNUB.events.fire( 'you-stepped-on-flower', "message-data" );
		 * PUBNUB.events.fire( 'you-stepped-on-flower', {message:"data"} );
		 * PUBNUB.events.fire( 'you-stepped-on-flower', [1,2,3] );
		 *
		 */
		var events = {
		  list: {},
		  unbind: function (name) {
		    events.list[name] = [];
		  },
		  bind: function (name, fun) {
		    (events.list[name] = events.list[name] || []).push(fun);
		  },
		  fire: function (name, data) {
		    pubNubCore.each(
		      events.list[name] || [],
		      function (fun) {
		        fun(data);
		      }
		    );
		  }
		};
	
		/**
		 * ATTR
		 * ====
		 * var attribute = attr( node, 'attribute' );
		 */
		function attr(node, attribute, value) {
		  if (value) node.setAttribute(attribute, value);
		  else return node && node.getAttribute && node.getAttribute(attribute);
		}
	
		/**
		 * $
		 * =
		 * var div = $('divid');
		 */
		function $(id) {
		  return document.getElementById(id);
		}
	
	
		/**
		 * SEARCH
		 * ======
		 * var elements = search('a div span');
		 */
		function search(elements, start) {
		  var list = [];
		  pubNubCore.each(elements.split(/\s+/), function (el) {
		    pubNubCore.each((start || document).getElementsByTagName(el), function (node) {
		      list.push(node);
		    });
		  });
		  return list;
		}
	
		/**
		 * CSS
		 * ===
		 * var obj = create('div');
		 */
		function css(element, styles) {
		  for (var style in styles) if (styles.hasOwnProperty(style))
		    try {
		      element.style[style] = styles[style] + (
		          '|width|height|top|left|'.indexOf(style) > 0 &&
		          typeof styles[style] === 'number'
		            ? 'px' : ''
		        );
		    } catch (e) {
		      return;
		    }
		}
	
		/**
		 * CREATE
		 * ======
		 * var obj = create('div');
		 */
		function create(element) {
		  return document.createElement(element);
		}
	
	
		function get_hmac_SHA256(data, key) {
		  var hash = CryptoJS['HmacSHA256'](data, key);
		  return hash.toString(CryptoJS['enc']['Base64']);
		}
	
		/* =-====================================================================-= */
		/* =-====================================================================-= */
		/* =-=========================     PUBNUB     ===========================-= */
		/* =-====================================================================-= */
		/* =-====================================================================-= */
	
		function CREATE_PUBNUB(setup) {
		  setup.db = db;
		  setup.xdr = xdr;
		  setup.error = setup.error || error;
		  setup.hmac_SHA256 = get_hmac_SHA256;
		  setup.crypto_obj = crypto_obj();
		  setup.WS = WS;
		  setup.params = { pnsdk: PNSDK };
	
		  var SELF = function (setup) {
		    return CREATE_PUBNUB(setup);
		  };
	
		  var PN = pubNubCore.PN_API(setup);
		  for (var prop in PN) {
		    if (PN.hasOwnProperty(prop)) {
		      SELF[prop] = PN[prop];
		    }
		  }
	
		  SELF.init = SELF;
		  SELF.$ = $;
		  SELF.attr = attr;
		  SELF.search = search;
		  SELF.bind = bind;
		  SELF.css = css;
		  SELF.create = create;
		  SELF.crypto_obj = crypto_obj();
		  SELF.WS = WS;
		  SELF.PNmessage = pubNubCore.PNmessage;
		  SELF.supplant = pubNubCore.supplant;
	
		  if (typeof(window) !== 'undefined') {
		    bind('beforeunload', window, function () {
		      SELF['each-channel'](function (ch) {
		        SELF['LEAVE'](ch.name, 1);
		      });
		      return true;
		    });
		  }
	
		  SELF.ready();
	
		  // Return without Testing
		  if (setup.notest) return SELF;
	
		  if (typeof(window) !== 'undefined') {
		    bind('offline', window, SELF['offline']);
		  }
	
		  if (typeof(document) !== 'undefined') {
		    bind('offline', document, SELF['offline']);
		  }
	
		  return SELF;
		}
	
		CREATE_PUBNUB.init = CREATE_PUBNUB;
		CREATE_PUBNUB.secure = CREATE_PUBNUB;
		CREATE_PUBNUB.crypto_obj = crypto_obj();
		CREATE_PUBNUB.WS = WS;
		CREATE_PUBNUB.db = db;
		CREATE_PUBNUB.PNmessage = pubNubCore.PNmessage;
		CREATE_PUBNUB.uuid = pubNubCore.uuid;
	
		CREATE_PUBNUB.css = css;
		CREATE_PUBNUB.$ = $;
		CREATE_PUBNUB.create = $;
		CREATE_PUBNUB.bind = bind;
		CREATE_PUBNUB.search = search;
		CREATE_PUBNUB.attr = attr;
		CREATE_PUBNUB.events = events;
	
		CREATE_PUBNUB.map = pubNubCore.map;
		CREATE_PUBNUB.each = pubNubCore.each;
		CREATE_PUBNUB.grep = pubNubCore.grep;
		CREATE_PUBNUB.supplant = pubNubCore.supplant;
		CREATE_PUBNUB.now = pubNubCore.now;
		CREATE_PUBNUB.unique = pubNubCore.unique;
		CREATE_PUBNUB.updater = pubNubCore.updater;
	
		module.exports = CREATE_PUBNUB;
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
		module.exports = {
			"name": "pubnub",
			"preferGlobal": false,
			"version": "3.15.2",
			"author": "PubNub <support@pubnub.com>",
			"description": "Publish & Subscribe Real-time Messaging with PubNub",
			"contributors": [
				{
					"name": "Stephen Blum",
					"email": "stephen@pubnub.com"
				}
			],
			"bin": {},
			"scripts": {
				"test": "grunt test --force"
			},
			"main": "./node.js/pubnub.js",
			"browser": "./modern/dist/pubnub.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/pubnub/javascript.git"
			},
			"keywords": [
				"cloud",
				"publish",
				"subscribe",
				"websockets",
				"comet",
				"bosh",
				"xmpp",
				"real-time",
				"messaging"
			],
			"dependencies": {
				"agentkeepalive": "~0.2",
				"lodash": "^4.1.0"
			},
			"noAnalyze": false,
			"devDependencies": {
				"chai": "^3.5.0",
				"eslint": "2.4.0",
				"eslint-config-airbnb": "^6.0.2",
				"eslint-plugin-flowtype": "^2.1.0",
				"eslint-plugin-mocha": "^2.0.0",
				"eslint-plugin-react": "^4.1.0",
				"flow-bin": "^0.22.0",
				"grunt": "^0.4.5",
				"grunt-contrib-clean": "^1.0.0",
				"grunt-contrib-copy": "^0.8.2",
				"grunt-contrib-uglify": "^0.11.1",
				"grunt-env": "^0.4.4",
				"grunt-eslint": "^18.0.0",
				"grunt-flow": "^1.0.3",
				"grunt-karma": "^0.12.1",
				"grunt-mocha-istanbul": "^3.0.1",
				"grunt-text-replace": "^0.4.0",
				"grunt-webpack": "^1.0.11",
				"imports-loader": "^0.6.5",
				"isparta": "^4.0.0",
				"json-loader": "^0.5.4",
				"karma": "^0.13.21",
				"karma-chai": "^0.1.0",
				"karma-mocha": "^0.2.1",
				"karma-phantomjs-launcher": "^1.0.0",
				"karma-spec-reporter": "0.0.24",
				"load-grunt-tasks": "^3.4.0",
				"mocha": "^2.4.5",
				"nock": "^1.1.0",
				"node-uuid": "^1.4.7",
				"nodeunit": "^0.9.0",
				"phantomjs-prebuilt": "^2.1.4",
				"proxyquire": "^1.7.4",
				"sinon": "^1.17.2",
				"uglify-js": "^2.6.1",
				"underscore": "^1.7.0",
				"webpack": "^1.12.13",
				"webpack-dev-server": "^1.14.1"
			},
			"bundleDependencies": [],
			"license": "MIT",
			"engine": {
				"node": ">=0.8"
			},
			"files": [
				"core",
				"node.js",
				"modern",
				"CHANGELOG",
				"FUTURE.md",
				"LICENSE",
				"README.md"
			]
		};
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint camelcase: 0, no-use-before-define: 0, no-unused-expressions: 0  */
		/* eslint eqeqeq: 0, one-var: 0 */
		/* eslint no-redeclare: 0 */
		/* eslint guard-for-in: 0 */
		/* eslint block-scoped-var: 0 space-return-throw-case: 0, no-unused-vars: 0 */
	
		var packageJSON = __webpack_require__(1);
		var defaultConfiguration = __webpack_require__(3);
		var utils = __webpack_require__(4);
	
		var NOW = 1;
		var READY = false;
		var READY_BUFFER = [];
		var PRESENCE_SUFFIX = '-pnpres';
		var DEF_WINDOWING = 10; // MILLISECONDS.
		var DEF_TIMEOUT = 15000; // MILLISECONDS.
		var DEF_SUB_TIMEOUT = 310; // SECONDS.
		var DEF_KEEPALIVE = 60; // SECONDS (FOR TIMESYNC).
		var SECOND = 1000; // A THOUSAND MILLISECONDS.
		var PRESENCE_HB_THRESHOLD = 5;
		var PRESENCE_HB_DEFAULT = 30;
		var SDK_VER = packageJSON.version;
	
		/**
		 * UTILITIES
		 */
		function unique() {
		  return 'x' + ++NOW + '' + (+new Date);
		}
	
		/**
		 * NEXTORIGIN
		 * ==========
		 * var next_origin = nextorigin();
		 */
		var nextorigin = (function () {
		  var max = 20;
		  var ori = Math.floor(Math.random() * max);
		  return function (origin, failover) {
		    return origin.indexOf('pubsub.') > 0
		      && origin.replace(
		        'pubsub', 'ps' + (
		          failover ? utils.generateUUID().split('-')[0] :
		            (++ori < max ? ori : ori = 1)
		        )) || origin;
		  };
		})();
	
	
		/**
		 * Generate Subscription Channel List
		 * ==================================
		 * generate_channel_list(channels_object);
		 */
		function generate_channel_list(channels, nopresence) {
		  var list = [];
		  utils.each(channels, function (channel, status) {
		    if (nopresence) {
		      if (channel.search('-pnpres') < 0) {
		        if (status.subscribed) list.push(channel);
		      }
		    } else {
		      if (status.subscribed) list.push(channel);
		    }
		  });
		  return list.sort();
		}
	
		/**
		 * Generate Subscription Channel Groups List
		 * ==================================
		 * generate_channel_group_list(channels_groups object);
		 */
		function generate_channel_group_list(channel_groups, nopresence) {
		  var list = [];
		  utils.each(channel_groups, function (channel_group, status) {
		    if (nopresence) {
		      if (channel_group.search('-pnpres') < 0) {
		        if (status.subscribed) list.push(channel_group);
		      }
		    } else {
		      if (status.subscribed) list.push(channel_group);
		    }
		  });
		  return list.sort();
		}
	
		// PUBNUB READY TO CONNECT
		function ready() {
		  if (READY) return;
		  READY = 1;
		  utils.each(READY_BUFFER, function (connect) {
		    connect();
		  });
		}
	
		function PNmessage(args) {
		  var msg = args || { apns: {} };
	
		  msg['getPubnubMessage'] = function () {
		    var m = {};
	
		    if (Object.keys(msg['apns']).length) {
		      m['pn_apns'] = {
		        aps: {
		          alert: msg['apns']['alert'],
		          badge: msg['apns']['badge']
		        }
		      };
		      for (var k in msg['apns']) {
		        m['pn_apns'][k] = msg['apns'][k];
		      }
		      var exclude1 = ['badge', 'alert'];
		      for (var k in exclude1) {
		        delete m['pn_apns'][exclude1[k]];
		      }
		    }
	
		    if (msg['gcm']) {
		      m['pn_gcm'] = {
		        data: msg['gcm']
		      };
		    }
	
		    for (var k in msg) {
		      m[k] = msg[k];
		    }
		    var exclude = ['apns', 'gcm', 'publish', 'channel', 'callback', 'error'];
		    for (var k in exclude) {
		      delete m[exclude[k]];
		    }
	
		    return m;
		  };
		  msg['publish'] = function () {
		    var m = msg.getPubnubMessage();
	
		    if (msg['pubnub'] && msg['channel']) {
		      msg['pubnub'].publish({
		        message: m,
		        channel: msg['channel'],
		        callback: msg['callback'],
		        error: msg['error']
		      });
		    }
		  };
		  return msg;
		}
	
		function PN_API(setup) {
		  var SUB_WINDOWING = +setup['windowing'] || DEF_WINDOWING;
		  var SUB_TIMEOUT = (+setup['timeout'] || DEF_SUB_TIMEOUT) * SECOND;
		  var KEEPALIVE = (+setup['keepalive'] || DEF_KEEPALIVE) * SECOND;
		  var TIME_CHECK = setup['timecheck'] || 0;
		  var NOLEAVE = setup['noleave'] || 0;
		  var PUBLISH_KEY = setup['publish_key'];
		  var SUBSCRIBE_KEY = setup['subscribe_key'];
		  var AUTH_KEY = setup['auth_key'] || '';
		  var SECRET_KEY = setup['secret_key'] || '';
		  var hmac_SHA256 = setup['hmac_SHA256'];
		  var SSL = setup['ssl'] ? 's' : '';
		  var ORIGIN = 'http' + SSL + '://' + (setup['origin'] || 'pubsub.pubnub.com');
		  var STD_ORIGIN = nextorigin(ORIGIN);
		  var SUB_ORIGIN = nextorigin(ORIGIN);
		  var CONNECT = function () {
		  };
		  var PUB_QUEUE = [];
		  var CLOAK = true;
		  var TIME_DRIFT = 0;
		  var SUB_CALLBACK = 0;
		  var SUB_CHANNEL = 0;
		  var SUB_RECEIVER = 0;
		  var SUB_RESTORE = setup['restore'] || 0;
		  var SUB_BUFF_WAIT = 0;
		  var TIMETOKEN = 0;
		  var RESUMED = false;
		  var CHANNELS = {};
		  var CHANNEL_GROUPS = {};
		  var SUB_ERROR = function () {
		  };
		  var STATE = {};
		  var PRESENCE_HB_TIMEOUT = null;
		  var PRESENCE_HB = validate_presence_heartbeat(
		    setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']
		  );
		  var PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || (PRESENCE_HB / 2) - 1;
		  var PRESENCE_HB_RUNNING = false;
		  var NO_WAIT_FOR_PENDING = setup['no_wait_for_pending'];
		  var COMPATIBLE_35 = setup['compatible_3.5'] || false;
		  var xdr = setup['xdr'];
		  var params = setup['params'] || {};
		  var error = setup['error'] || function () {};
		  var _is_online = setup['_is_online'] || function () { return 1;};
		  var jsonp_cb = setup['jsonp_cb'] || function () { return 0; };
		  var db = setup['db'] || { get: function () {}, set: function () {} };
		  var CIPHER_KEY = setup['cipher_key'];
		  var UUID = setup['uuid'] || (!setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY + 'uuid') || '');
		  var USE_INSTANCEID = setup['instance_id'] || false;
		  var INSTANCEID = '';
		  var shutdown = setup['shutdown'];
		  var use_send_beacon = (typeof setup['use_send_beacon'] != 'undefined') ? setup['use_send_beacon'] : true;
		  var sendBeacon = (use_send_beacon) ? setup['sendBeacon'] : null;
		  var _poll_timer;
		  var _poll_timer2;
	
		  if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;
	
		  var crypto_obj = setup['crypto_obj'] || {
		    encrypt: function (a, key) {
		      return a;
		    },
		    decrypt: function (b, key) {
		      return b;
		    }
		  };
	
		  function _get_url_params(data) {
		    if (!data) data = {};
		    utils.each(params, function (key, value) {
		      if (!(key in data)) data[key] = value;
		    });
		    return data;
		  }
	
		  function _object_to_key_list(o) {
		    var l = [];
		    utils.each(o, function (key, value) {
		      l.push(key);
		    });
		    return l;
		  }
	
		  function _object_to_key_list_sorted(o) {
		    return _object_to_key_list(o).sort();
		  }
	
		  function _get_pam_sign_input_from_params(params) {
		    var si = '';
		    var l = _object_to_key_list_sorted(params);
	
		    for (var i in l) {
		      var k = l[i];
		      si += k + '=' + utils.pamEncode(params[k]);
		      if (i != l.length - 1) si += '&';
		    }
		    return si;
		  }
	
		  function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {
		    var err = false;
	
		    if (typeof heartbeat === 'undefined') {
		      return cur_heartbeat;
		    }
	
		    if (typeof heartbeat === 'number') {
		      if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0) {
		        err = false;
		      } else {
		        err = true;
		      }
		    } else if (typeof heartbeat === 'boolean') {
		      if (!heartbeat) {
		        return 0;
		      } else {
		        return PRESENCE_HB_DEFAULT;
		      }
		    } else {
		      err = true;
		    }
	
		    if (err) {
		      error && error('Presence Heartbeat value invalid. Valid range ( x > ' + PRESENCE_HB_THRESHOLD + ' or x = 0). Current Value : ' + (cur_heartbeat || PRESENCE_HB_THRESHOLD));
		      return cur_heartbeat || PRESENCE_HB_THRESHOLD;
		    } else return heartbeat;
		  }
	
		  function encrypt(input, key) {
		    return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;
		  }
	
		  function decrypt(input, key) {
		    return crypto_obj['decrypt'](input, key || CIPHER_KEY) ||
		      crypto_obj['decrypt'](input, CIPHER_KEY) ||
		      input;
		  }
	
		  function error_common(message, callback) {
		    callback && callback({ error: message || 'error occurred' });
		    error && error(message);
		  }
	
		  function _presence_heartbeat() {
		    clearTimeout(PRESENCE_HB_TIMEOUT);
	
		    if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 ||
		      PRESENCE_HB_INTERVAL < 1 ||
		      (!generate_channel_list(CHANNELS, true).length && !generate_channel_group_list(CHANNEL_GROUPS, true).length)) {
		      PRESENCE_HB_RUNNING = false;
		      return;
		    }
	
		    PRESENCE_HB_RUNNING = true;
		    SELF['presence_heartbeat']({
		      callback: function (r) {
		        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND);
		      },
		      error: function (e) {
		        error && error('Presence Heartbeat unable to reach Pubnub servers.' + JSON.stringify(e));
		        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND);
		      }
		    });
		  }
	
		  function start_presence_heartbeat() {
		    !PRESENCE_HB_RUNNING && _presence_heartbeat();
		  }
	
		  function publish(next) {
		    if (NO_WAIT_FOR_PENDING) {
		      if (!PUB_QUEUE.length) return;
		    } else {
		      if (next) PUB_QUEUE.sending = 0;
		      if (PUB_QUEUE.sending || !PUB_QUEUE.length) return;
		      PUB_QUEUE.sending = 1;
		    }
	
		    xdr(PUB_QUEUE.shift());
		  }
	
		  function each_channel_group(callback) {
		    var count = 0;
	
		    utils.each(generate_channel_group_list(CHANNEL_GROUPS), function (channel_group) {
		      var chang = CHANNEL_GROUPS[channel_group];
	
		      if (!chang) return;
	
		      count++;
		      (callback || function () {
		      })(chang);
		    });
	
		    return count;
		  }
	
		  function each_channel(callback) {
		    var count = 0;
	
		    utils.each(generate_channel_list(CHANNELS), function (channel) {
		      var chan = CHANNELS[channel];
	
		      if (!chan) return;
	
		      count++;
		      (callback || function () {
		      })(chan);
		    });
	
		    return count;
		  }
	
		  function _invoke_callback(response, callback, err) {
		    if (typeof response == 'object') {
		      if (response['error']) {
		        var callback_data = {};
	
		        if (response['message']) {
		          callback_data['message'] = response['message'];
		        }
	
		        if (response['payload']) {
		          callback_data['payload'] = response['payload'];
		        }
	
		        err && err(callback_data);
		        return;
		      }
		      if (response['payload']) {
		        if (response['next_page']) {
		          callback && callback(response['payload'], response['next_page']);
		        } else {
		          callback && callback(response['payload']);
		        }
		        return;
		      }
		    }
		    callback && callback(response);
		  }
	
		  function _invoke_error(response, err) {
		    if (typeof response == 'object' && response['error']) {
		      var callback_data = {};
	
		      if (response['message']) {
		        callback_data['message'] = response['message'];
		      }
	
		      if (response['payload']) {
		        callback_data['payload'] = response['payload'];
		      }
	
		      err && err(callback_data);
		      return;
		    } else {
		      err && err(response);
		    }
		  }
	
		  function CR(args, callback, url1, data) {
		    var callback = args['callback'] || callback;
		    var err = args['error'] || error;
		    var jsonp = jsonp_cb();
	
		    data = data || {};
	
		    if (!data['auth']) {
		      data['auth'] = args['auth_key'] || AUTH_KEY;
		    }
	
		    var url = [
		      STD_ORIGIN, 'v1', 'channel-registration',
		      'sub-key', SUBSCRIBE_KEY
		    ];
	
		    url.push.apply(url, url1);
	
		    if (jsonp) data['callback'] = jsonp;
	
		    xdr({
		      callback: jsonp,
		      data: _get_url_params(data),
		      success: function (response) {
		        _invoke_callback(response, callback, err);
		      },
		      fail: function (response) {
		        _invoke_error(response, err);
		      },
		      url: url
		    });
		  }
	
		  // Announce Leave Event
		  var SELF = {
		    LEAVE: function (channel, blocking, auth_key, callback, error) {
		      var data = { uuid: UUID, auth: auth_key || AUTH_KEY };
		      var origin = nextorigin(ORIGIN);
		      var callback = callback || function () {};
		      var err = error || function () {};
		      var url;
		      var params;
		      var jsonp = jsonp_cb();
	
		      // Prevent Leaving a Presence Channel
		      if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;
	
	
		      if (COMPATIBLE_35) {
		        if (!SSL) return false;
		        if (jsonp == '0') return false;
		      }
	
		      if (NOLEAVE) return false;
	
		      if (jsonp != '0') data['callback'] = jsonp;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      url = [
		        origin, 'v2', 'presence', 'sub_key',
		        SUBSCRIBE_KEY, 'channel', utils.encode(channel), 'leave'
		      ];
	
		      params = _get_url_params(data);
	
	
		      if (sendBeacon) {
		        var url_string = utils.buildURL(url, params);
		        if (sendBeacon(url_string)) {
		          callback && callback({ status: 200, action: 'leave', message: 'OK', service: 'Presence' });
		          return true;
		        }
		      }
	
	
		      xdr({
		        blocking: blocking || SSL,
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		      return true;
		    },
	
		    LEAVE_GROUP: function (channel_group, blocking, auth_key, callback, error) {
		      var data = { uuid: UUID, auth: auth_key || AUTH_KEY };
		      var origin = nextorigin(ORIGIN);
		      var url;
		      var params;
		      var callback = callback || function () {};
		      var err = error || function () {};
		      var jsonp = jsonp_cb();
	
		      // Prevent Leaving a Presence Channel Group
		      if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;
	
		      if (COMPATIBLE_35) {
		        if (!SSL) return false;
		        if (jsonp == '0') return false;
		      }
	
		      if (NOLEAVE) return false;
	
		      if (jsonp != '0') data['callback'] = jsonp;
	
		      if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      url = [
		        origin, 'v2', 'presence', 'sub_key',
		        SUBSCRIBE_KEY, 'channel', utils.encode(','), 'leave'
		      ];
	
		      params = _get_url_params(data);
	
		      if (sendBeacon) {
		        var url_string = utils.buildURL(url, params);
		        if (sendBeacon(url_string)) {
		          callback && callback({ status: 200, action: 'leave', message: 'OK', service: 'Presence' });
		          return true;
		        }
		      }
	
		      xdr({
		        blocking: blocking || SSL,
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		      return true;
		    },
	
		    set_resumed: function (resumed) {
		      RESUMED = resumed;
		    },
	
		    get_cipher_key: function () {
		      return CIPHER_KEY;
		    },
	
		    set_cipher_key: function (key) {
		      CIPHER_KEY = key;
		    },
	
		    raw_encrypt: function (input, key) {
		      return encrypt(input, key);
		    },
	
		    raw_decrypt: function (input, key) {
		      return decrypt(input, key);
		    },
	
		    get_heartbeat: function () {
		      return PRESENCE_HB;
		    },
	
		    set_heartbeat: function (heartbeat, heartbeat_interval) {
		      PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, error);
		      PRESENCE_HB_INTERVAL = heartbeat_interval || (PRESENCE_HB / 2) - 1;
		      if (PRESENCE_HB == 2) {
		        PRESENCE_HB_INTERVAL = 1;
		      }
		      CONNECT();
		      _presence_heartbeat();
		    },
	
		    get_heartbeat_interval: function () {
		      return PRESENCE_HB_INTERVAL;
		    },
	
		    set_heartbeat_interval: function (heartbeat_interval) {
		      PRESENCE_HB_INTERVAL = heartbeat_interval;
		      _presence_heartbeat();
		    },
	
		    get_version: function () {
		      return SDK_VER;
		    },
	
		    getGcmMessageObject: function (obj) {
		      return {
		        data: obj
		      };
		    },
	
		    getApnsMessageObject: function (obj) {
		      var x = {
		        aps: { badge: 1, alert: '' }
		      };
		      for (var k in obj) {
		        k[x] = obj[k];
		      }
		      return x;
		    },
	
		    _add_param: function (key, val) {
		      params[key] = val;
		    },
	
		    channel_group: function (args, callback) {
		      var ns_ch = args['channel_group'];
		      var callback = callback || args['callback'];
		      var channels = args['channels'] || args['channel'];
		      var cloak = args['cloak'];
		      var namespace;
		      var channel_group;
		      var url = [];
		      var data = {};
		      var mode = args['mode'] || 'add';
	
	
		      if (ns_ch) {
		        var ns_ch_a = ns_ch.split(':');
	
		        if (ns_ch_a.length > 1) {
		          namespace = (ns_ch_a[0] === '*') ? null : ns_ch_a[0];
	
		          channel_group = ns_ch_a[1];
		        } else {
		          channel_group = ns_ch_a[0];
		        }
		      }
	
		      namespace && url.push('namespace') && url.push(utils.encode(namespace));
	
		      url.push('channel-group');
	
		      if (channel_group && channel_group !== '*') {
		        url.push(channel_group);
		      }
	
		      if (channels) {
		        if (utils.isArray(channels)) {
		          channels = channels.join(',');
		        }
		        data[mode] = channels;
		        data['cloak'] = (CLOAK) ? 'true' : 'false';
		      } else {
		        if (mode === 'remove') url.push('remove');
		      }
	
		      if (typeof cloak != 'undefined') data['cloak'] = (cloak) ? 'true' : 'false';
	
		      CR(args, callback, url, data);
		    },
	
		    channel_group_list_groups: function (args, callback) {
		      var namespace;
	
		      namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;
		      if (namespace) {
		        args['channel_group'] = namespace + ':*';
		      }
	
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_list_channels: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_remove_channel: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (!args['channel'] && !args['channels']) return error('Missing Channel');
	
		      args['mode'] = 'remove';
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_remove_group: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (args['channel']) return error('Use channel_group_remove_channel if you want to remove a channel from a group.');
	
		      args['mode'] = 'remove';
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_add_channel: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (!args['channel'] && !args['channels']) return error('Missing Channel');
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_cloak: function (args, callback) {
		      if (typeof args['cloak'] == 'undefined') {
		        callback(CLOAK);
		        return;
		      }
		      CLOAK = args['cloak'];
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_list_namespaces: function (args, callback) {
		      var url = ['namespace'];
		      CR(args, callback, url);
		    },
	
		    channel_group_remove_namespace: function (args, callback) {
		      var url = ['namespace', args['namespace'], 'remove'];
		      CR(args, callback, url);
		    },
	
		    /*
		     PUBNUB.history({
		     channel  : 'my_chat_channel',
		     limit    : 100,
		     callback : function(history) { }
		     });
		     */
		    history: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var count = args['count'] || args['limit'] || 100;
		      var reverse = args['reverse'] || 'false';
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var cipher_key = args['cipher_key'];
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var start = args['start'];
		      var end = args['end'];
		      var include_token = args['include_token'];
		      var string_msg_token = args['string_message_token'] || false;
		      var params = {};
		      var jsonp = jsonp_cb();
	
		      // Make sure we have a Channel
		      if (!channel && !channel_group) return error('Missing Channel');
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      params['stringtoken'] = 'true';
		      params['count'] = count;
		      params['reverse'] = reverse;
		      params['auth'] = auth_key;
	
		      if (channel_group) {
		        params['channel-group'] = channel_group;
		        if (!channel) {
		          channel = ',';
		        }
		      }
		      if (jsonp) params['callback'] = jsonp;
		      if (start) params['start'] = start;
		      if (end) params['end'] = end;
		      if (include_token) params['include_token'] = 'true';
		      if (string_msg_token) params['string_message_token'] = 'true';
	
		      // Send Message
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(params),
		        success: function (response) {
		          if (typeof response == 'object' && response['error']) {
		            err({ message: response['message'], payload: response['payload'] });
		            return;
		          }
		          var messages = response[0];
		          var decrypted_messages = [];
		          for (var a = 0; a < messages.length; a++) {
		            if (include_token) {
		              var new_message = decrypt(messages[a]['message'], cipher_key);
		              var timetoken = messages[a]['timetoken'];
		              try {
		                decrypted_messages['push']({ message: JSON['parse'](new_message), timetoken: timetoken });
		              } catch (e) {
		                decrypted_messages['push'](({ message: new_message, timetoken: timetoken }));
		              }
		            } else {
		              var new_message = decrypt(messages[a], cipher_key);
		              try {
		                decrypted_messages['push'](JSON['parse'](new_message));
		              } catch (e) {
		                decrypted_messages['push']((new_message));
		              }
		            }
		          }
		          callback([decrypted_messages, response[1], response[2]]);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v2', 'history', 'sub-key',
		          SUBSCRIBE_KEY, 'channel', utils.encode(channel)
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.replay({
		     source      : 'my_channel',
		     destination : 'new_channel'
		     });
		     */
		    replay: function (args, callback) {
		      var callback = callback || args['callback'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var source = args['source'];
		      var destination = args['destination'];
		      var err = args['error'] || args['error'] || function () {};
		      var stop = args['stop'];
		      var start = args['start'];
		      var end = args['end'];
		      var reverse = args['reverse'];
		      var limit = args['limit'];
		      var jsonp = jsonp_cb();
		      var data = {};
		      var url;
	
		      // Check User Input
		      if (!source) return error('Missing Source Channel');
		      if (!destination) return error('Missing Destination Channel');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      // Setup URL Params
		      if (jsonp != '0') data['callback'] = jsonp;
		      if (stop) data['stop'] = 'all';
		      if (reverse) data['reverse'] = 'true';
		      if (start) data['start'] = start;
		      if (end) data['end'] = end;
		      if (limit) data['count'] = limit;
	
		      data['auth'] = auth_key;
	
		      // Compose URL Parts
		      url = [
		        STD_ORIGIN, 'v1', 'replay',
		        PUBLISH_KEY, SUBSCRIBE_KEY,
		        source, destination
		      ];
	
		      // Start (or Stop) Replay!
		      xdr({
		        callback: jsonp,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function () {
		          callback([0, 'Disconnected']);
		        },
		        url: url,
		        data: _get_url_params(data)
		      });
		    },
	
		    /*
		     PUBNUB.auth('AJFLKAJSDKLA');
		     */
		    auth: function (auth) {
		      AUTH_KEY = auth;
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.time(function(time){ });
		     */
		    time: function (callback) {
		      var jsonp = jsonp_cb();
	
		      var data = { uuid: UUID, auth: AUTH_KEY };
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        url: [STD_ORIGIN, 'time', jsonp],
		        success: function (response) {
		          callback(response[0]);
		        },
		        fail: function () {
		          callback(0);
		        }
		      });
		    },
	
		    /*
		     PUBNUB.publish({
		     channel : 'my_chat_channel',
		     message : 'hello!'
		     });
		     */
		    publish: function (args, callback) {
		      var msg = args['message'];
		      if (!msg) return error('Missing Message');
	
		      var callback = callback || args['callback'] || msg['callback'] || args['success'] || function () {};
		      var channel = args['channel'] || msg['channel'];
		      var meta = args['meta'] || args['metadata'];
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var cipher_key = args['cipher_key'];
		      var err = args['error'] || msg['error'] || function () {};
		      var post = args['post'] || false;
		      var store = ('store_in_history' in args) ? args['store_in_history'] : true;
		      var replicate = ('replicate' in args) ? args['replicate'] : true;
		      var jsonp = jsonp_cb();
		      var add_msg = 'push';
		      var params;
		      var url;
	
		      if (args['prepend']) add_msg = 'unshift';
	
		      if (!channel) return error('Missing Channel');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (msg['getPubnubMessage']) {
		        msg = msg['getPubnubMessage']();
		      }
	
		      // If trying to send Object
		      msg = JSON['stringify'](encrypt(msg, cipher_key));
	
		      // Create URL
		      url = [
		        STD_ORIGIN, 'publish',
		        PUBLISH_KEY, SUBSCRIBE_KEY,
		        0, utils.encode(channel),
		        jsonp, utils.encode(msg)
		      ];
	
		      params = { uuid: UUID, auth: auth_key };
	
		      if (meta && typeof meta === 'object') {
		        params['meta'] = JSON.stringify(meta);
		      }
	
		      if (!store) params['store'] = '0';
		      if (!replicate) params['norep'] = 'true';
	
		      if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;
	
		      // Queue Message Send
		      PUB_QUEUE[add_msg]({
		        callback: jsonp,
		        url: url,
		        data: _get_url_params(params),
		        fail: function (response) {
		          _invoke_error(response, err);
		          publish(1);
		        },
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		          publish(1);
		        },
		        mode: (post) ? 'POST' : 'GET'
		      });
	
		      // Send Message
		      publish();
		    },
	
		    fire: function (args, callback) {
		      args.store_in_history = false;
		      args.replicate = false;
		      SELF['publish'](args, callback);
		    },
	
		    /*
		     PUBNUB.unsubscribe({ channel : 'my_chat' });
		     */
		    unsubscribe: function (args, callback) {
		      var channelArg = args['channel'];
		      var channelGroupArg = args['channel_group'];
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var callback = callback || args['callback'] || function () {};
		      var err = args['error'] || function () {};
	
		      if (!channelArg && !channelGroupArg) return error('Missing Channel or Channel Group');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (channelArg) {
		        var channels = utils.isArray(channelArg) ? channelArg : ('' + channelArg).split(',');
		        var existingChannels = [];
		        var presenceChannels = [];
	
		        utils.each(channels, function (channel) {
		          if (CHANNELS[channel]) existingChannels.push(channel);
		        });
	
		        // if we do not have any channels to unsubscribe from, trigger a callback.
		        if (existingChannels.length == 0) {
		          callback({ action: 'leave' });
		          return;
		        }
	
		        // Prepare presence channels
		        utils.each(existingChannels, function (channel) {
		          presenceChannels.push(channel + PRESENCE_SUFFIX);
		        });
	
		        utils.each(existingChannels.concat(presenceChannels), function (channel) {
		          if (channel in CHANNELS) delete CHANNELS[channel];
		          if (channel in STATE) delete STATE[channel];
		        });
	
		        if (CHANNELS.length === 0 && CHANNEL_GROUPS.length === 0) {
		          TIMETOKEN = 0;
		        }
	
		        var CB_CALLED = true;
		        if (READY) {
		          CB_CALLED = SELF['LEAVE'](existingChannels.join(','), 0, auth_key, callback, err);
		        }
		        if (!CB_CALLED) callback({ action: 'leave' });
		      }
	
		      if (channelGroupArg) {
		        var channelGroups = utils.isArray(channelGroupArg) ? channelGroupArg : ('' + channelGroupArg).split(',');
		        var existingChannelGroups = [];
		        var presenceChannelGroups = [];
	
		        utils.each(channelGroups, function (channelGroup) {
		          if (CHANNEL_GROUPS[channelGroup]) existingChannelGroups.push(channelGroup);
		        });
	
		        // if we do not have any channel groups to unsubscribe from, trigger a callback.
		        if (existingChannelGroups.length == 0) {
		          callback({ action: 'leave' });
		          return;
		        }
	
		        // Prepare presence channels
		        utils.each(existingChannelGroups, function (channelGroup) {
		          presenceChannelGroups.push(channelGroup + PRESENCE_SUFFIX);
		        });
	
		        utils.each(existingChannelGroups.concat(presenceChannelGroups), function (channelGroup) {
		          if (channelGroup in CHANNEL_GROUPS) delete CHANNEL_GROUPS[channelGroup];
		          if (channelGroup in STATE) delete STATE[channelGroup];
		        });
	
		        if (CHANNELS.length === 0 && CHANNEL_GROUPS.length === 0) {
		          TIMETOKEN = 0;
		        }
	
		        var CB_CALLED = true;
		        if (READY) {
		          CB_CALLED = SELF['LEAVE_GROUP'](existingChannelGroups.join(','), 0, auth_key, callback, err);
		        }
		        if (!CB_CALLED) callback({ action: 'leave' });
		      }
	
		      // Reset Connection if Count Less
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.subscribe({
		     channel  : 'my_chat'
		     callback : function(message) { }
		     });
		     */
		    subscribe: function (args, callback) {
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var callback = callback || args['callback'];
		      var callback = callback || args['message'];
		      var connect = args['connect'] || function () {};
		      var reconnect = args['reconnect'] || function () {};
		      var disconnect = args['disconnect'] || function () {};
		      var SUB_ERROR = args['error'] || SUB_ERROR || function () {};
		      var idlecb = args['idle'] || function () {};
		      var presence = args['presence'] || 0;
		      var noheresync = args['noheresync'] || 0;
		      var backfill = args['backfill'] || 0;
		      var timetoken = args['timetoken'] || 0;
		      var sub_timeout = args['timeout'] || SUB_TIMEOUT;
		      var windowing = args['windowing'] || SUB_WINDOWING;
		      var state = args['state'];
		      var heartbeat = args['heartbeat'] || args['pnexpires'];
		      var heartbeat_interval = args['heartbeat_interval'];
		      var restore = args['restore'] || SUB_RESTORE;
	
		      AUTH_KEY = args['auth_key'] || AUTH_KEY;
	
		      // Restore Enabled?
		      SUB_RESTORE = restore;
	
		      // Always Reset the TT
		      TIMETOKEN = timetoken;
	
		      // Make sure we have a Channel
		      if (!channel && !channel_group) {
		        return error('Missing Channel');
		      }
	
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {
		        SELF['set_heartbeat'](heartbeat, heartbeat_interval);
		      }
	
		      // Setup Channel(s)
		      if (channel) {
		        utils.each((channel.join ? channel.join(',') : '' + channel).split(','),
		          function (channel) {
		            var settings = CHANNELS[channel] || {};
	
		            // Store Channel State
		            CHANNELS[SUB_CHANNEL = channel] = {
		              name: channel,
		              connected: settings.connected,
		              disconnected: settings.disconnected,
		              subscribed: 1,
		              callback: SUB_CALLBACK = callback,
		              cipher_key: args['cipher_key'],
		              connect: connect,
		              disconnect: disconnect,
		              reconnect: reconnect
		            };
	
		            if (state) {
		              if (channel in state) {
		                STATE[channel] = state[channel];
		              } else {
		                STATE[channel] = state;
		              }
		            }
	
		            // Presence Enabled?
		            if (!presence) return;
	
		            // Subscribe Presence Channel
		            SELF['subscribe']({
		              channel: channel + PRESENCE_SUFFIX,
		              callback: presence,
		              restore: restore
		            });
	
		            // Presence Subscribed?
		            if (settings.subscribed) return;
	
		            // See Who's Here Now?
		            if (noheresync) return;
		            SELF['here_now']({
		              channel: channel,
		              data: _get_url_params({ uuid: UUID, auth: AUTH_KEY }),
		              callback: function (here) {
		                utils.each('uuids' in here ? here['uuids'] : [], function (uid) {
		                  presence({
		                    action: 'join',
		                    uuid: uid,
		                    timestamp: Math.floor(utils.rnow() / 1000),
		                    occupancy: here['occupancy'] || 1
		                  }, here, channel);
		                });
		              }
		            });
		          });
		      }
	
		      // Setup Channel Groups
		      if (channel_group) {
		        utils.each((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','),
		          function (channel_group) {
		            var settings = CHANNEL_GROUPS[channel_group] || {};
	
		            CHANNEL_GROUPS[channel_group] = {
		              name: channel_group,
		              connected: settings.connected,
		              disconnected: settings.disconnected,
		              subscribed: 1,
		              callback: SUB_CALLBACK = callback,
		              cipher_key: args['cipher_key'],
		              connect: connect,
		              disconnect: disconnect,
		              reconnect: reconnect
		            };
	
		            // Presence Enabled?
		            if (!presence) return;
	
		            // Subscribe Presence Channel
		            SELF['subscribe']({
		              channel_group: channel_group + PRESENCE_SUFFIX,
		              callback: presence,
		              restore: restore,
		              auth_key: AUTH_KEY
		            });
	
		            // Presence Subscribed?
		            if (settings.subscribed) return;
	
		            // See Who's Here Now?
		            if (noheresync) return;
		            SELF['here_now']({
		              channel_group: channel_group,
		              data: _get_url_params({ uuid: UUID, auth: AUTH_KEY }),
		              callback: function (here) {
		                utils.each('uuids' in here ? here['uuids'] : [], function (uid) {
		                  presence({
		                    action: 'join',
		                    uuid: uid,
		                    timestamp: Math.floor(utils.rnow() / 1000),
		                    occupancy: here['occupancy'] || 1
		                  }, here, channel_group);
		                });
		              }
		            });
		          });
		      }
	
	
		      // Test Network Connection
		      function _test_connection(success) {
		        if (success) {
		          // Begin Next Socket Connection
		          utils.timeout(CONNECT, windowing);
		        } else {
		          // New Origin on Failed Connection
		          STD_ORIGIN = nextorigin(ORIGIN, 1);
		          SUB_ORIGIN = nextorigin(ORIGIN, 1);
	
		          // Re-test Connection
		          utils.timeout(function () {
		            SELF['time'](_test_connection);
		          }, SECOND);
		        }
	
		        // Disconnect & Reconnect
		        each_channel(function (channel) {
		          // Reconnect
		          if (success && channel.disconnected) {
		            channel.disconnected = 0;
		            return channel.reconnect(channel.name);
		          }
	
		          // Disconnect
		          if (!success && !channel.disconnected) {
		            channel.disconnected = 1;
		            channel.disconnect(channel.name);
		          }
		        });
	
		        // Disconnect & Reconnect for channel groups
		        each_channel_group(function (channel_group) {
		          // Reconnect
		          if (success && channel_group.disconnected) {
		            channel_group.disconnected = 0;
		            return channel_group.reconnect(channel_group.name);
		          }
	
		          // Disconnect
		          if (!success && !channel_group.disconnected) {
		            channel_group.disconnected = 1;
		            channel_group.disconnect(channel_group.name);
		          }
		        });
		      }
	
		      // Evented Subscribe
		      function _connect() {
		        var jsonp = jsonp_cb();
		        var channels = generate_channel_list(CHANNELS).join(',');
		        var channel_groups = generate_channel_group_list(CHANNEL_GROUPS).join(',');
	
		        // Stop Connection
		        if (!channels && !channel_groups) return;
	
		        if (!channels) channels = ',';
	
		        // Connect to PubNub Subscribe Servers
		        _reset_offline();
	
		        var data = _get_url_params({ uuid: UUID, auth: AUTH_KEY });
	
		        if (channel_groups) {
		          data['channel-group'] = channel_groups;
		        }
	
	
		        var st = JSON.stringify(STATE);
		        if (st.length > 2) data['state'] = JSON.stringify(STATE);
	
		        if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;
	
		        if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		        start_presence_heartbeat();
		        SUB_RECEIVER = xdr({
		          timeout: sub_timeout,
		          callback: jsonp,
		          fail: function (response) {
		            if (response && response['error'] && response['service']) {
		              _invoke_error(response, SUB_ERROR);
		              _test_connection(false);
		            } else {
		              SELF['time'](function (success) {
		                !success && (_invoke_error(response, SUB_ERROR));
		                _test_connection(success);
		              });
		            }
		          },
		          data: _get_url_params(data),
		          url: [
		            SUB_ORIGIN, 'subscribe',
		            SUBSCRIBE_KEY, utils.encode(channels),
		            jsonp, TIMETOKEN
		          ],
		          success: function (messages) {
		            // Check for Errors
		            if (!messages || (typeof messages == 'object' && 'error' in messages && messages['error'])) {
		              SUB_ERROR(messages);
		              return utils.timeout(CONNECT, SECOND);
		            }
	
		            // User Idle Callback
		            idlecb(messages[1]);
	
		            // Restore Previous Connection Point if Needed
		            TIMETOKEN = !TIMETOKEN && SUB_RESTORE && db['get'](SUBSCRIBE_KEY) || messages[1];
	
		            /*
		             // Connect
		             each_channel_registry(function(registry){
		             if (registry.connected) return;
		             registry.connected = 1;
		             registry.connect(channel.name);
		             });
		             */
	
		            // Connect
		            each_channel(function (channel) {
		              if (channel.connected) return;
		              channel.connected = 1;
		              channel.connect(channel.name);
		            });
	
		            // Connect for channel groups
		            each_channel_group(function (channel_group) {
		              if (channel_group.connected) return;
		              channel_group.connected = 1;
		              channel_group.connect(channel_group.name);
		            });
	
		            if (RESUMED && !SUB_RESTORE) {
		              TIMETOKEN = 0;
		              RESUMED = false;
		              // Update Saved Timetoken
		              db['set'](SUBSCRIBE_KEY, 0);
		              utils.timeout(_connect, windowing);
		              return;
		            }
	
		            // Invoke Memory Catchup and Receive Up to 100
		            // Previous Messages from the Queue.
		            if (backfill) {
		              TIMETOKEN = 10000;
		              backfill = 0;
		            }
	
		            // Update Saved Timetoken
		            db['set'](SUBSCRIBE_KEY, messages[1]);
	
		            // Route Channel <---> Callback for Message
		            var next_callback = (function () {
		              var channels = '';
		              var channels2 = '';
	
		              if (messages.length > 3) {
		                channels = messages[3];
		                channels2 = messages[2];
		              } else if (messages.length > 2) {
		                channels = messages[2];
		              } else {
		                channels = utils.map(
		                  generate_channel_list(CHANNELS), function (chan) {
		                    return utils.map(
		                      Array(messages[0].length)
		                        .join(',').split(','),
		                      function () {
		                        return chan;
		                      }
		                    );
		                  }).join(',');
		              }
	
		              var list = channels.split(',');
		              var list2 = (channels2) ? channels2.split(',') : [];
	
		              return function () {
		                var channel = list.shift() || SUB_CHANNEL;
		                var channel2 = list2.shift();
	
		                var chobj = {};
	
		                if (channel2) {
		                  if (channel && channel.indexOf('-pnpres') >= 0
		                    && channel2.indexOf('-pnpres') < 0) {
		                    channel2 += '-pnpres';
		                  }
		                  chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || { callback: function () {} };
		                } else {
		                  chobj = CHANNELS[channel];
		                }
	
		                var r = [
		                  chobj
		                    .callback || SUB_CALLBACK,
		                  channel.split(PRESENCE_SUFFIX)[0]
		                ];
		                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);
		                return r;
		              };
		            })();
	
		            var latency = detect_latency(+messages[1]);
		            utils.each(messages[0], function (msg) {
		              var next = next_callback();
		              var decrypted_msg = decrypt(msg,
		                (CHANNELS[next[1]]) ? CHANNELS[next[1]]['cipher_key'] : null);
		              next[0] && next[0](decrypted_msg, messages, next[2] || next[1], latency, next[1]);
		            });
	
		            utils.timeout(_connect, windowing);
		          }
		        });
		      }
	
		      CONNECT = function () {
		        _reset_offline();
		        utils.timeout(_connect, windowing);
		      };
	
		      // Reduce Status Flicker
		      if (!READY) return READY_BUFFER.push(CONNECT);
	
		      // Connect Now
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.here_now({ channel : 'my_chat', callback : fun });
		     */
		    here_now: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var debug = args['debug'];
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var jsonp = jsonp_cb();
		      var uuids = ('uuids' in args) ? args['uuids'] : true;
		      var state = args['state'];
		      var data = { uuid: UUID, auth: auth_key };
	
		      if (!uuids) data['disable_uuids'] = 1;
		      if (state) data['state'] = 1;
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      var url = [
		        STD_ORIGIN, 'v2', 'presence',
		        'sub_key', SUBSCRIBE_KEY
		      ];
	
		      channel && url.push('channel') && url.push(utils.encode(channel));
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (channel_group) {
		        data['channel-group'] = channel_group;
		        !channel && url.push('channel') && url.push(',');
		      }
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        debug: debug,
		        url: url
		      });
		    },
	
		    /*
		     PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });
		     */
		    where_now: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var jsonp = jsonp_cb();
		      var uuid = args['uuid'] || UUID;
		      var data = { auth: auth_key };
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub_key', SUBSCRIBE_KEY,
		          'uuid', utils.encode(uuid)
		        ]
		      });
		    },
	
		    state: function (args, callback) {
		      var callback = args['callback'] || callback || function (r) {};
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var jsonp = jsonp_cb();
		      var state = args['state'];
		      var uuid = args['uuid'] || UUID;
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var url;
		      var data = _get_url_params({ auth: auth_key });
	
		      // Make sure we have a Channel
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!uuid) return error('Missing UUID');
		      if (!channel && !channel_group) return error('Missing Channel');
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (typeof channel != 'undefined'
		        && CHANNELS[channel] && CHANNELS[channel].subscribed) {
		        if (state) STATE[channel] = state;
		      }
	
		      if (typeof channel_group != 'undefined'
		        && CHANNEL_GROUPS[channel_group]
		        && CHANNEL_GROUPS[channel_group].subscribed
		      ) {
		        if (state) STATE[channel_group] = state;
		        data['channel-group'] = channel_group;
	
		        if (!channel) {
		          channel = ',';
		        }
		      }
	
		      data['state'] = JSON.stringify(state);
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      if (state) {
		        url = [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channel,
		          'uuid', uuid, 'data'
		        ];
		      } else {
		        url = [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channel,
		          'uuid', utils.encode(uuid)
		        ];
		      }
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
	
		      });
		    },
	
		    /*
		     PUBNUB.grant({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     ttl      : 24 * 60, // Minutes
		     read     : true,
		     write    : true,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    grant: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var channel = args['channel'] || args['channels'];
		      var channel_group = args['channel_group'];
		      var jsonp = jsonp_cb();
		      var ttl = args['ttl'];
		      var r = (args['read']) ? '1' : '0';
		      var w = (args['write']) ? '1' : '0';
		      var m = (args['manage']) ? '1' : '0';
		      var auth_key = args['auth_key'] || args['auth_keys'];
	
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SECRET_KEY) return error('Missing Secret Key');
	
		      var timestamp = Math.floor(new Date().getTime() / 1000);
		      var sign_input = SUBSCRIBE_KEY + '\n' + PUBLISH_KEY + '\n' + 'grant' + '\n';
	
		      var data = { w: w, r: r, timestamp: timestamp };
	
		      if (args['manage']) {
		        data['m'] = m;
		      }
		      if (utils.isArray(channel)) {
		        channel = channel['join'](',');
		      }
		      if (utils.isArray(auth_key)) {
		        auth_key = auth_key['join'](',');
		      }
		      if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;
		      if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {
		        data['channel-group'] = channel_group;
		      }
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
		      if (ttl || ttl === 0) data['ttl'] = ttl;
	
		      if (auth_key) data['auth'] = auth_key;
	
		      data = _get_url_params(data);
	
		      if (!auth_key) delete data['auth'];
	
		      sign_input += _get_pam_sign_input_from_params(data);
	
		      var signature = hmac_SHA256(sign_input, SECRET_KEY);
	
		      signature = signature.replace(/\+/g, '-');
		      signature = signature.replace(/\//g, '_');
	
		      data['signature'] = signature;
	
		      xdr({
		        callback: jsonp,
		        data: data,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v1', 'auth', 'grant',
		          'sub-key', SUBSCRIBE_KEY
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.mobile_gw_provision ({
		     device_id: 'A655FBA9931AB',
		     op       : 'add' | 'remove',
		     gw_type  : 'apns' | 'gcm',
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     });
		     */
	
		    mobile_gw_provision: function (args) {
		      var callback = args['callback'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var err = args['error'] || function () {};
		      var jsonp = jsonp_cb();
		      var channel = args['channel'];
		      var op = args['op'];
		      var gw_type = args['gw_type'];
		      var device_id = args['device_id'];
		      var params;
		      var url;
	
		      if (!device_id) return error('Missing Device ID (device_id)');
		      if (!gw_type) return error('Missing GW Type (gw_type: gcm or apns)');
		      if (!op) return error('Missing GW Operation (op: add or remove)');
		      if (!channel) return error('Missing gw destination Channel (channel)');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      // Create URL
		      url = [
		        STD_ORIGIN, 'v1/push/sub-key',
		        SUBSCRIBE_KEY, 'devices', device_id
		      ];
	
		      params = { uuid: UUID, auth: auth_key, type: gw_type };
	
		      if (op == 'add') {
		        params['add'] = channel;
		      } else if (op == 'remove') {
		        params['remove'] = channel;
		      }
	
		      if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		    },
	
		    /*
		     PUBNUB.audit({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     read     : true,
		     write    : true,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    audit: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var auth_key = args['auth_key'];
		      var jsonp = jsonp_cb();
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SECRET_KEY) return error('Missing Secret Key');
	
		      var timestamp = Math.floor(new Date().getTime() / 1000);
		      var sign_input = SUBSCRIBE_KEY + '\n' + PUBLISH_KEY + '\n' + 'audit' + '\n';
	
		      var data = { timestamp: timestamp };
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
		      if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;
		      if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {
		        data['channel-group'] = channel_group;
		      }
		      if (auth_key) data['auth'] = auth_key;
	
		      data = _get_url_params(data);
	
		      if (!auth_key) delete data['auth'];
	
		      sign_input += _get_pam_sign_input_from_params(data);
	
		      var signature = hmac_SHA256(sign_input, SECRET_KEY);
	
		      signature = signature.replace(/\+/g, '-');
		      signature = signature.replace(/\//g, '_');
	
		      data['signature'] = signature;
		      xdr({
		        callback: jsonp,
		        data: data,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v1', 'auth', 'audit',
		          'sub-key', SUBSCRIBE_KEY
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.revoke({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    revoke: function (args, callback) {
		      args['read'] = false;
		      args['write'] = false;
		      SELF['grant'](args, callback);
		    },
	
		    set_uuid: function (uuid) {
		      UUID = uuid;
		      CONNECT();
		    },
	
		    get_uuid: function () {
		      return UUID;
		    },
	
		    isArray: function (arg) {
		      return utils.isArray(arg);
		    },
	
		    get_subscribed_channels: function () {
		      return generate_channel_list(CHANNELS, true);
		    },
	
		    presence_heartbeat: function (args) {
		      var callback = args['callback'] || function () {};
		      var err = args['error'] || function () {};
		      var jsonp = jsonp_cb();
		      var data = { uuid: UUID, auth: AUTH_KEY };
	
		      var st = JSON['stringify'](STATE);
		      if (st.length > 2) data['state'] = JSON['stringify'](STATE);
	
		      if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      var channels = utils.encode(generate_channel_list(CHANNELS, true)['join'](','));
		      var channel_groups = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');
	
		      if (!channels) channels = ',';
		      if (channel_groups) data['channel-group'] = channel_groups;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        url: [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channels,
		          'heartbeat'
		        ],
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        }
		      });
		    },
	
		    stop_timers: function () {
		      clearTimeout(_poll_timer);
		      clearTimeout(_poll_timer2);
		      clearTimeout(PRESENCE_HB_TIMEOUT);
		    },
	
		    shutdown: function () {
		      SELF['stop_timers']();
		      shutdown && shutdown();
		    },
	
		    // Expose PUBNUB Functions
		    xdr: xdr,
		    ready: ready,
		    db: db,
		    uuid: utils.generateUUID,
		    map: utils.map,
		    each: utils.each,
		    'each-channel': each_channel,
		    grep: utils.grep,
		    offline: function () {
		      _reset_offline(1, { message: 'Offline. Please check your network settings.' });
		    },
		    supplant: utils.supplant,
		    now: utils.rnow,
		    unique: unique,
		    updater: utils.updater
		  };
	
		  function _poll_online() {
		    _is_online() || _reset_offline(1, { error: 'Offline. Please check your network settings.' });
		    _poll_timer && clearTimeout(_poll_timer);
		    _poll_timer = utils.timeout(_poll_online, SECOND);
		  }
	
		  function _poll_online2() {
		    if (!TIME_CHECK) return;
		    SELF['time'](function (success) {
		      detect_time_detla(function () {
		      }, success);
		      success || _reset_offline(1, {
		        error: 'Heartbeat failed to connect to Pubnub Servers.' +
		        'Please check your network settings.'
		      });
		      _poll_timer2 && clearTimeout(_poll_timer2);
		      _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE);
		    });
		  }
	
		  function _reset_offline(err, msg) {
		    SUB_RECEIVER && SUB_RECEIVER(err, msg);
		    SUB_RECEIVER = null;
	
		    clearTimeout(_poll_timer);
		    clearTimeout(_poll_timer2);
		  }
	
		  if (!UUID) UUID = SELF['uuid']();
		  if (!INSTANCEID) INSTANCEID = SELF['uuid']();
		  db['set'](SUBSCRIBE_KEY + 'uuid', UUID);
	
		  _poll_timer = utils.timeout(_poll_online, SECOND);
		  _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE);
		  PRESENCE_HB_TIMEOUT = utils.timeout(
		    start_presence_heartbeat,
		    (PRESENCE_HB_INTERVAL - 3) * SECOND
		  );
	
		  // Detect Age of Message
		  function detect_latency(tt) {
		    var adjusted_time = utils.rnow() - TIME_DRIFT;
		    return adjusted_time - tt / 10000;
		  }
	
		  detect_time_detla();
		  function detect_time_detla(cb, time) {
		    var stime = utils.rnow();
	
		    time && calculate(time) || SELF['time'](calculate);
	
		    function calculate(time) {
		      if (!time) return;
		      var ptime = time / 10000;
		      var latency = (utils.rnow() - stime) / 2;
		      TIME_DRIFT = utils.rnow() - (ptime + latency);
		      cb && cb(TIME_DRIFT);
		    }
		  }
	
		  return SELF;
		}
	
		module.exports = {
		  PN_API: PN_API,
		  unique: unique,
		  PNmessage: PNmessage,
		  DEF_TIMEOUT: DEF_TIMEOUT,
		  timeout: utils.timeout,
		  build_url: utils.buildURL,
		  each: utils.each,
		  uuid: utils.generateUUID,
		  URLBIT: defaultConfiguration.URLBIT,
		  grep: utils.grep,
		  supplant: utils.supplant,
		  now: utils.rnow,
		  updater: utils.updater,
		  map: utils.map
		};
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		module.exports = {
			"PARAMSBIT": "&",
			"URLBIT": "/"
		};
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint no-unused-expressions: 0, block-scoped-var: 0, no-redeclare: 0, guard-for-in: 0 */
	
		var defaultConfiguration = __webpack_require__(3);
		var REPL = /{([\w\-]+)}/g;
	
		function rnow() {
		  return +new Date;
		}
	
		function isArray(arg) {
		  return !!arg && typeof arg !== 'string' && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === 'number');
		  // return !!arg && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === "number")
		}
	
		/**
		 * EACH
		 * ====
		 * each( [1,2,3], function(item) { } )
		 */
		function each(o, f) {
		  if (!o || !f) {
		    return;
		  }
	
		  if (isArray(o)) {
		    for (var i = 0, l = o.length; i < l;) {
		      f.call(o[i], o[i], i++);
		    }
		  } else {
		    for (var i in o) {
		      o.hasOwnProperty &&
		      o.hasOwnProperty(i) &&
		      f.call(o[i], i, o[i]);
		    }
		  }
		}
	
		/**
		 * ENCODE
		 * ======
		 * var encoded_data = encode('path');
		 */
		function encode(path) { return encodeURIComponent(path); }
	
		/**
		 * Build Url
		 * =======
		 *
		 */
		function buildURL(urlComponents, urlParams) {
		  var url = urlComponents.join(defaultConfiguration.URLBIT);
		  var params = [];
	
		  if (!urlParams) return url;
	
		  each(urlParams, function (key, value) {
		    var valueStr = (typeof value === 'object') ? JSON['stringify'](value) : value;
		    (typeof value !== 'undefined' &&
		      value !== null && encode(valueStr).length > 0
		    ) && params.push(key + '=' + encode(valueStr));
		  });
	
		  url += '?' + params.join(defaultConfiguration.PARAMSBIT);
		  return url;
		}
	
		/**
		 * UPDATER
		 * =======
		 * var timestamp = unique();
		 */
		function updater(fun, rate) {
		  var timeout;
		  var last = 0;
		  var runnit = function () {
		    if (last + rate > rnow()) {
		      clearTimeout(timeout);
		      timeout = setTimeout(runnit, rate);
		    } else {
		      last = rnow();
		      fun();
		    }
		  };
	
		  return runnit;
		}
	
		/**
		 * GREP
		 * ====
		 * var list = grep( [1,2,3], function(item) { return item % 2 } )
		 */
		function grep(list, fun) {
		  var fin = [];
		  each(list || [], function (l) {
		    fun(l) && fin.push(l);
		  });
		  return fin;
		}
	
		/**
		 * SUPPLANT
		 * ========
		 * var text = supplant( 'Hello {name}!', { name : 'John' } )
		 */
		function supplant(str, values) {
		  return str.replace(REPL, function (_, match) {
		    return values[match] || _;
		  });
		}
	
		/**
		 * timeout
		 * =======
		 * timeout( function(){}, 100 );
		 */
		function timeout(fun, wait) {
		  if (typeof setTimeout === 'undefined') {
		    return;
		  }
	
		  return setTimeout(fun, wait);
		}
	
		/**
		 * uuid
		 * ====
		 * var my_uuid = generateUUID();
		 */
		function generateUUID(callback) {
		  var u = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,
		    function (c) {
		      var r = Math.random() * 16 | 0;
		      var v = c === 'x' ? r : (r & 0x3 | 0x8);
		      return v.toString(16);
		    });
		  if (callback) callback(u);
		  return u;
		}
	
		/**
		 * MAP
		 * ===
		 * var list = map( [1,2,3], function(item) { return item + 1 } )
		 */
		function map(list, fun) {
		  var fin = [];
		  each(list || [], function (k, v) {
		    fin.push(fun(k, v));
		  });
		  return fin;
		}
	
	
		function pamEncode(str) {
		  return encodeURIComponent(str).replace(/[!'()*~]/g, function (c) {
		    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		  });
		}
	
	
		module.exports = {
		  buildURL: buildURL,
		  encode: encode,
		  each: each,
		  updater: updater,
		  rnow: rnow,
		  isArray: isArray,
		  map: map,
		  pamEncode: pamEncode,
		  generateUUID: generateUUID,
		  timeout: timeout,
		  supplant: supplant,
		  grep: grep
		};
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint camelcase: 0 eqeqeq: 0 */
	
		var CryptoJS = __webpack_require__(6);
	
		function crypto_obj() {
		  function SHA256(s) {
		    return CryptoJS['SHA256'](s)['toString'](CryptoJS['enc']['Hex']);
		  }
	
		  var iv = '0123456789012345';
	
		  var allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];
		  var allowedKeyLengths = [128, 256];
		  var allowedModes = ['ecb', 'cbc'];
	
		  var defaultOptions = {
		    encryptKey: true,
		    keyEncoding: 'utf8',
		    keyLength: 256,
		    mode: 'cbc'
		  };
	
		  function parse_options(options) {
		    // Defaults
		    options = options || {};
		    if (!options['hasOwnProperty']('encryptKey')) options['encryptKey'] = defaultOptions['encryptKey'];
		    if (!options['hasOwnProperty']('keyEncoding')) options['keyEncoding'] = defaultOptions['keyEncoding'];
		    if (!options['hasOwnProperty']('keyLength')) options['keyLength'] = defaultOptions['keyLength'];
		    if (!options['hasOwnProperty']('mode')) options['mode'] = defaultOptions['mode'];
	
		    // Validation
		    if (allowedKeyEncodings['indexOf'](options['keyEncoding']['toLowerCase']()) == -1) options['keyEncoding'] = defaultOptions['keyEncoding'];
		    if (allowedKeyLengths['indexOf'](parseInt(options['keyLength'], 10)) == -1) options['keyLength'] = defaultOptions['keyLength'];
		    if (allowedModes['indexOf'](options['mode']['toLowerCase']()) == -1) options['mode'] = defaultOptions['mode'];
	
		    return options;
		  }
	
		  function decode_key(key, options) {
		    if (options['keyEncoding'] === 'base64') {
		      return CryptoJS['enc']['Base64']['parse'](key);
		    } else if (options['keyEncoding'] === 'hex') {
		      return CryptoJS['enc']['Hex']['parse'](key);
		    } else {
		      return key;
		    }
		  }
	
		  function get_padded_key(key, options) {
		    key = decode_key(key, options);
		    if (options['encryptKey']) {
		      return CryptoJS['enc']['Utf8']['parse'](SHA256(key)['slice'](0, 32));
		    } else {
		      return key;
		    }
		  }
	
		  function get_mode(options) {
		    if (options['mode'] === 'ecb') {
		      return CryptoJS['mode']['ECB'];
		    } else {
		      return CryptoJS['mode']['CBC'];
		    }
		  }
	
		  function get_iv(options) {
		    return (options['mode'] === 'cbc') ? CryptoJS['enc']['Utf8']['parse'](iv) : null;
		  }
	
		  return {
		    encrypt: function (data, key, options) {
		      if (!key) return data;
		      options = parse_options(options);
		      var iv = get_iv(options);
		      var mode = get_mode(options);
		      var cipher_key = get_padded_key(key, options);
		      var hex_message = JSON['stringify'](data);
		      var encryptedHexArray = CryptoJS['AES']['encrypt'](hex_message, cipher_key, { iv: iv, mode: mode })['ciphertext'];
		      var base_64_encrypted = encryptedHexArray['toString'](CryptoJS['enc']['Base64']);
		      return base_64_encrypted || data;
		    },
	
		    decrypt: function (data, key, options) {
		      if (!key) return data;
		      options = parse_options(options);
		      var iv = get_iv(options);
		      var mode = get_mode(options);
		      var cipher_key = get_padded_key(key, options);
		      try {
		        var binary_enc = CryptoJS['enc']['Base64']['parse'](data);
		        var json_plain = CryptoJS['AES']['decrypt']({ ciphertext: binary_enc }, cipher_key, { iv: iv, mode: mode })['toString'](CryptoJS['enc']['Utf8']);
		        var plaintext = JSON['parse'](json_plain);
		        return plaintext;
		      } catch (e) {
		        return undefined;
		      }
		    }
		  };
		}
	
		module.exports = crypto_obj;
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
		/*
		 CryptoJS v3.1.2
		 code.google.com/p/crypto-js
		 (c) 2009-2013 by Jeff Mott. All rights reserved.
		 code.google.com/p/crypto-js/wiki/License
		 */
		var CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
		    r=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
		      32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
		        2),16)<<24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},
		    u=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);
		      a._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,
		    d)).finalize(c)}}});var t=f.algo={};return f}(Math);
	
		// SHA256
		(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64>n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t<=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64>p;p++){if(16>p)a[p]=
		  c[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+a[p-7]+((l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10)+a[p-16]}k=q+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&m^~h&n)+r[p]+a[p];l=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
		  d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);
	
		// HMAC SHA256
		(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;"string"==typeof g&&(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes>m&&(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j<h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=
		  this._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();
	
		// Base64
		(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<
		l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
	
		// BlockCipher
		(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
		  _doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
		    f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
		      m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
		      E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/
		    4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
		(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
		  l)}})();
	
		// Cipher
		CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
		  finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return("string"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return("string"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=
		  c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
		  e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
		  this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
		  1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
		  decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
		  b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
	
		// AES
		(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
		  16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>
		8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=
		  d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();
	
		// Mode ECB
		CryptoJS.mode.ECB = (function () {
		  var ECB = CryptoJS.lib.BlockCipherMode.extend();
	
		  ECB.Encryptor = ECB.extend({
		    processBlock: function (words, offset) {
		      this._cipher.encryptBlock(words, offset);
		    }
		  });
	
		  ECB.Decryptor = ECB.extend({
		    processBlock: function (words, offset) {
		      this._cipher.decryptBlock(words, offset);
		    }
		  });
	
		  return ECB;
		}());
	
		module.exports = CryptoJS;
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET INTERFACE
		// ---------------------------------------------------------------------------
		var WS = function( url, protocols ) {
		  if (!(this instanceof WS)) return new WS( url, protocols );
	
		  var self     = this
		    ,   url      = self.url      = url || ''
		    ,   protocol = self.protocol = protocols || 'Sec-WebSocket-Protocol'
		    ,   bits     = url.split('/')
		    ,   setup    = {
		    'ssl'           : bits[0] === 'wss:'
		    ,'origin'        : bits[2]
		    ,'publish_key'   : bits[3]
		    ,'subscribe_key' : bits[4]
		    ,'channel'       : bits[5]
		  };
	
		  // READY STATES
		  self['CONNECTING'] = 0; // The connection is not yet open.
		  self['OPEN']       = 1; // The connection is open and ready to communicate.
		  self['CLOSING']    = 2; // The connection is in the process of closing.
		  self['CLOSED']     = 3; // The connection is closed or couldn't be opened.
	
		  // CLOSE STATES
		  self['CLOSE_NORMAL']         = 1000; // Normal Intended Close; completed.
		  self['CLOSE_GOING_AWAY']     = 1001; // Closed Unexpecttedly.
		  self['CLOSE_PROTOCOL_ERROR'] = 1002; // Server: Not Supported.
		  self['CLOSE_UNSUPPORTED']    = 1003; // Server: Unsupported Protocol.
		  self['CLOSE_TOO_LARGE']      = 1004; // Server: Too Much Data.
		  self['CLOSE_NO_STATUS']      = 1005; // Server: No reason.
		  self['CLOSE_ABNORMAL']       = 1006; // Abnormal Disconnect.
	
		  // Events Default
		  self['onclose']   = self['onerror'] =
		    self['onmessage'] = self['onopen']  =
		      self['onsend']    =  function(){};
	
		  // Attributes
		  self['binaryType']     = '';
		  self['extensions']     = '';
		  self['bufferedAmount'] = 0;
		  self['trasnmitting']   = false;
		  self['buffer']         = [];
		  self['readyState']     = self['CONNECTING'];
	
		  // Close if no setup.
		  if (!url) {
		    self['readyState'] = self['CLOSED'];
		    self['onclose']({
		      'code'     : self['CLOSE_ABNORMAL'],
		      'reason'   : 'Missing URL',
		      'wasClean' : true
		    });
		    return self;
		  }
	
		  // PubNub WebSocket Emulation
		  self.pubnub       = PUBNUB['init'](setup);
		  self.pubnub.setup = setup;
		  self.setup        = setup;
	
		  self.pubnub['subscribe']({
		    'restore'    : false,
		    'channel'    : setup['channel'],
		    'disconnect' : self['onerror'],
		    'reconnect'  : self['onopen'],
		    'error'      : function() {
		      self['onclose']({
		        'code'     : self['CLOSE_ABNORMAL'],
		        'reason'   : 'Missing URL',
		        'wasClean' : false
		      });
		    },
		    'callback'   : function(message) {
		      self['onmessage']({ 'data' : message });
		    },
		    'connect'    : function() {
		      self['readyState'] = self['OPEN'];
		      self['onopen']();
		    }
		  });
		};
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET SEND
		// ---------------------------------------------------------------------------
		WS.prototype.send = function(data) {
		  var self = this;
		  self.pubnub['publish']({
		    'channel'  : self.pubnub.setup['channel'],
		    'message'  : data,
		    'callback' : function(response) {
		      self['onsend']({ 'data' : response });
		    }
		  });
		};
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET CLOSE
		// ---------------------------------------------------------------------------
		WS.prototype.close = function() {
		  var self = this;
		  self.pubnub['unsubscribe']({ 'channel' : self.pubnub.setup['channel'] });
		  self['readyState'] = self['CLOSED'];
		  self['onclose']({});
		};
	
		module.exports = WS;
	
	
	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["Client"] = factory();
		else
			root["RingCentral"] = root["RingCentral"] || {}, root["RingCentral"]["Client"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(1);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="./externals.d.ts" />
	"use strict";
	var accountClient = __webpack_require__(2);
	var callLogClient = __webpack_require__(40);
	var dictionaryClient = __webpack_require__(55);
	var extensionClient = __webpack_require__(70);
	var messagesClient = __webpack_require__(77);
	var notificationsClient = __webpack_require__(84);
	var presenceClient = __webpack_require__(87);
	var ringoutClient = __webpack_require__(93);
	var forwardingNumbersClient = __webpack_require__(96);
	var blockedNumbersClient = __webpack_require__(99);
	var Client = (function () {
	    function Client(sdk) {
	        this._sdk = sdk;
	        this._account = new accountClient.Account(sdk);
	        this._callLog = new callLogClient.CallLog(sdk);
	        this._dictionary = new dictionaryClient.Dictionary(sdk);
	        this._extension = new extensionClient.Extension(sdk);
	        this._messages = new messagesClient.Messages(sdk);
	        this._notifications = new notificationsClient.NotificationsSubscriptionAPI(sdk);
	        this._presence = new presenceClient.Presence(sdk);
	        this._ringout = new ringoutClient.RingOut(sdk);
	        this._forwardingNumbers = new forwardingNumbersClient.ForwardingNumbers(sdk);
	        this._blockedNumbers = new blockedNumbersClient.BlockedNumbers(sdk);
	    }
	    Client.prototype.account = function () { return this._account; };
	    Client.prototype.callLog = function () { return this._callLog; };
	    Client.prototype.dictionary = function () { return this._dictionary; };
	    Client.prototype.extension = function () { return this._extension; };
	    Client.prototype.messages = function () { return this._messages; };
	    Client.prototype.notifications = function () { return this._notifications; };
	    Client.prototype.presence = function () { return this._presence; };
	    Client.prototype.ringout = function () { return this._ringout; };
	    Client.prototype.forwardingNumbers = function () { return this._forwardingNumbers; };
	    Client.prototype.blockedNumbers = function () { return this._blockedNumbers; };
	    Client.version = '0.1.0';
	    return Client;
	}());
	module.exports = Client;
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var accountinfo = __webpack_require__(4);
	var accountbusinessaddress = __webpack_require__(28);
	var dialingplaninfo = __webpack_require__(30);
	var phonenumberinfo = __webpack_require__(34);
	var accountphonenumbers = __webpack_require__(36);
	var accountserviceinfo = __webpack_require__(37);
	var Account = (function (_super) {
	    __extends(Account, _super);
	    function Account() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Account
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Creates the account in Initial state.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>Accounts</td>
	     *             <td>Managing accounts: creating new accounts, viewing and updating account information, deleting existing accounts</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.createAccount = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account', options, exports.createAccountOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Get Account Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns basic information about a particular RingCentral customer account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccount = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}', options, exports.loadAccountOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Get Account Business Address
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccountBusinessAddress = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/business-address', options, exports.loadAccountBusinessAddressOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Update Account Business Address
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.updateAccountBusinessAddress = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/business-address', options, exports.updateAccountBusinessAddressOptions), accountbusinessaddress.AccountBusinessAddress);
	    };
	    /**
	     * Get Account Dialing Plan
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns list of countries which can be selected for a dialing plan (to call short numbers and special services).</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Account.prototype.listDialingPlans = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/dialing-plan', options, exports.listDialingPlansOptions), dialingplaninfo.DialingPlanInfo);
	    };
	    /**
	     * Provision Phone Numbers
	     *
	     * <p style='font-style:italic;'>Since 1.0.11 (Release 6.3)</p>
	     * <p>Provisions a phone number.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.provisionPhoneNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/phone-number', options, exports.provisionPhoneNumberOptions), phonenumberinfo.PhoneNumberInfo);
	    };
	    /**
	     * Get Account Phone Numbers
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers assigned to the RingCentral customer account. Both company-level and extension-level numbers are returned.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Account.prototype.listAccountPhoneNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/phone-number', options, exports.listAccountPhoneNumbersOptions), accountphonenumbers.AccountPhoneNumbers);
	    };
	    /**
	     * Get Phone Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccountPhoneNumber = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/phone-number/{phoneNumberId}', options, exports.loadAccountPhoneNumberOptions), phonenumberinfo.PhoneNumberInfo);
	    };
	    /**
	     * Get Account Service Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns the information about service plan, available features and limitations for a particular RingCentral customer account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadServiceInfo = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/service-info', options, exports.loadServiceInfoOptions), accountserviceinfo.AccountServiceInfo);
	    };
	    return Account;
	}(client.Client));
	exports.Account = Account;
	/**
	 * Definition of options for createAccount operation
	 */
	exports.createAccountOptions = [
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createaccountrequest.CreateAccountRequest"
	    }
	];
	/**
	 * Definition of options for loadAccount operation
	 */
	exports.loadAccountOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadAccountBusinessAddress operation
	 */
	exports.loadAccountBusinessAddressOptions = [];
	/**
	 * Definition of options for updateAccountBusinessAddress operation
	 */
	exports.updateAccountBusinessAddressOptions = [
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "modifyaccountbusinessaddressrequest.ModifyAccountBusinessAddressRequest"
	    }
	];
	/**
	 * Definition of options for listDialingPlans operation
	 */
	exports.listDialingPlansOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for provisionPhoneNumber operation
	 */
	exports.provisionPhoneNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "provisionphonenumbers.ProvisionPhoneNumbers"
	    }
	];
	/**
	 * Definition of options for listAccountPhoneNumbers operation
	 */
	exports.listAccountPhoneNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "usageType",
	        "type": "IListAccountPhoneNumbersUsageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "MainCompanyNumber",
	            "AdditionalCompanyNumber",
	            "CompanyNumber",
	            "DirectNumber",
	            "CompanyFaxNumber",
	            "ForwardedNumber"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountPhoneNumber operation
	 */
	exports.loadAccountPhoneNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "phoneNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for loadServiceInfo operation
	 */
	exports.loadServiceInfoOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	(function (IListAccountPhoneNumbersUsageType) {
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.IListAccountPhoneNumbersUsageType || (exports.IListAccountPhoneNumbersUsageType = {}));
	var IListAccountPhoneNumbersUsageType = exports.IListAccountPhoneNumbersUsageType;
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var Client = (function () {
	    function Client(sdk) {
	        this._sdk = sdk;
	    }
	    Client.prototype.parseOptions = function (method, url, options, operationParameters) {
	        options = options || {};
	        var request = {
	            url: url,
	            method: method,
	            query: {},
	            body: undefined
	        };
	        operationParameters.forEach(function (param) {
	            if (param.required && !param.default && !options.hasOwnProperty(param.name)) {
	                throw new Error('Required parameter "' + param.name + '" not found');
	            }
	            if (param.default && !options.hasOwnProperty(param.name)) {
	                options[param.name] = param.default;
	            }
	            if (param.in == 'path') {
	                request.url = request.url.replace('{' + param.name + '}', options[param.name]);
	            }
	            if (param.in == 'query' && options.hasOwnProperty(param.name)) {
	                request.query[param.name] = options[param.name];
	            }
	            if (param.in == 'body') {
	                request.body = options[param.name];
	            }
	        });
	        return request;
	    };
	    Client.prototype.send = function (apiOptions, Class) {
	        var _this = this;
	        return this._sdk.platform()
	            .send(apiOptions)
	            .then(function (res) {
	            //TODO Support multipart
	            //TODO Think how to pass headers&stuff to outside
	            if (Class && !res._isMultipart())
	                return new Class(_this._sdk, res.json());
	            return res;
	        });
	    };
	    return Client;
	}());
	exports.Client = Client;
	
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var serviceinfo = __webpack_require__(22);
	var accountstatusinfo = __webpack_require__(27);
	var AccountInfo = (function (_super) {
	    __extends(AccountInfo, _super);
	    function AccountInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'mainNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'operator', Class: extensioninfo.ExtensionInfo, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'serviceInfo', Class: serviceinfo.ServiceInfo, isArray: false, isRequired: false },
	            { property: 'setupWizardState', Class: AccountInfoSetupWizardState, isArray: false, isRequired: false },
	            { property: 'status', Class: AccountInfoStatus, isArray: false, isRequired: false },
	            { property: 'statusInfo', Class: accountstatusinfo.AccountStatusInfo, isArray: false, isRequired: false }
	        ];
	    };
	    AccountInfo.prototype.getClassName = function () {
	        return 'AccountInfo';
	    };
	    return AccountInfo;
	}(model.Model));
	exports.AccountInfo = AccountInfo;
	(function (AccountInfoSetupWizardState) {
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["NotStarted"] = 'NotStarted'] = "NotStarted";
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["Incomplete"] = 'Incomplete'] = "Incomplete";
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["Completed"] = 'Completed'] = "Completed";
	})(exports.AccountInfoSetupWizardState || (exports.AccountInfoSetupWizardState = {}));
	var AccountInfoSetupWizardState = exports.AccountInfoSetupWizardState;
	(function (AccountInfoStatus) {
	    AccountInfoStatus[AccountInfoStatus["Confirmed"] = 'Confirmed'] = "Confirmed";
	    AccountInfoStatus[AccountInfoStatus["Disabled"] = 'Disabled'] = "Disabled";
	})(exports.AccountInfoStatus || (exports.AccountInfoStatus = {}));
	var AccountInfoStatus = exports.AccountInfoStatus;
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var Model = (function () {
	    function Model(sdk, data) {
	        var _this = this;
	        this._sdk = sdk;
	        data = data || {};
	        this.getPropertyMappings().forEach(function (mapping) {
	            var Class = mapping.Class, prop = mapping.property;
	            if (!data.hasOwnProperty(prop)) {
	                if (mapping.isRequired)
	                    console.warn('Required property "' + prop + '" not defined');
	                return;
	            }
	            var processProperty = function (dataPart) {
	                if (!Class || typeof Class !== 'function') {
	                    return dataPart;
	                }
	                else {
	                    return new Class(_this._sdk, dataPart);
	                }
	            };
	            if (mapping.isArray) {
	                _this[prop] = data[prop].map(processProperty);
	            }
	            else {
	                _this[prop] = processProperty(data[prop]);
	            }
	        });
	    }
	    Model.prototype.getPropertyMappings = function () {
	        return [];
	    };
	    Model.prototype.getClassName = function () {
	        return 'Model';
	    };
	    Model.prototype.getId = function () {
	        return this['id'];
	    };
	    return Model;
	}());
	exports.Model = Model;
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var contactinfo = __webpack_require__(7);
	var departmentinfo = __webpack_require__(9);
	var extensionpermissions = __webpack_require__(10);
	var profileimageinfo = __webpack_require__(12);
	var referenceinfo = __webpack_require__(13);
	var regionalsettings = __webpack_require__(14);
	var extensionservicefeatureinfo = __webpack_require__(20);
	var extensionstatusinfo = __webpack_require__(21);
	var ExtensionInfo = (function (_super) {
	    __extends(ExtensionInfo, _super);
	    function ExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'contact', Class: contactinfo.ContactInfo, isArray: false, isRequired: false },
	            { property: 'departments', Class: departmentinfo.DepartmentInfo, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'permissions', Class: extensionpermissions.ExtensionPermissions, isArray: false, isRequired: false },
	            { property: 'profileImage', Class: profileimageinfo.ProfileImageInfo, isArray: false, isRequired: true },
	            { property: 'references', Class: referenceinfo.ReferenceInfo, isArray: true, isRequired: false },
	            { property: 'regionalSettings', Class: regionalsettings.RegionalSettings, isArray: false, isRequired: false },
	            { property: 'serviceFeatures', Class: extensionservicefeatureinfo.ExtensionServiceFeatureInfo, isArray: true, isRequired: false },
	            { property: 'setupWizardState', Class: ExtensionInfoSetupWizardState, isArray: false, isRequired: false },
	            { property: 'status', Class: ExtensionInfoStatus, isArray: false, isRequired: true },
	            { property: 'statusInfo', Class: extensionstatusinfo.ExtensionStatusInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionInfoType, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionInfo.prototype.getClassName = function () {
	        return 'ExtensionInfo';
	    };
	    return ExtensionInfo;
	}(model.Model));
	exports.ExtensionInfo = ExtensionInfo;
	(function (ExtensionInfoSetupWizardState) {
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["NotStarted"] = 'NotStarted'] = "NotStarted";
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["Incomplete"] = 'Incomplete'] = "Incomplete";
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["Completed"] = 'Completed'] = "Completed";
	})(exports.ExtensionInfoSetupWizardState || (exports.ExtensionInfoSetupWizardState = {}));
	var ExtensionInfoSetupWizardState = exports.ExtensionInfoSetupWizardState;
	(function (ExtensionInfoStatus) {
	    ExtensionInfoStatus[ExtensionInfoStatus["Enabled"] = 'Enabled'] = "Enabled";
	    ExtensionInfoStatus[ExtensionInfoStatus["Disabled"] = 'Disabled'] = "Disabled";
	    ExtensionInfoStatus[ExtensionInfoStatus["NotActivated"] = 'NotActivated'] = "NotActivated";
	    ExtensionInfoStatus[ExtensionInfoStatus["Unassigned"] = 'Unassigned'] = "Unassigned";
	})(exports.ExtensionInfoStatus || (exports.ExtensionInfoStatus = {}));
	var ExtensionInfoStatus = exports.ExtensionInfoStatus;
	(function (ExtensionInfoType) {
	    ExtensionInfoType[ExtensionInfoType["User"] = 'User'] = "User";
	    ExtensionInfoType[ExtensionInfoType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    ExtensionInfoType[ExtensionInfoType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    ExtensionInfoType[ExtensionInfoType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    ExtensionInfoType[ExtensionInfoType["Department"] = 'Department'] = "Department";
	    ExtensionInfoType[ExtensionInfoType["Announcement"] = 'Announcement'] = "Announcement";
	    ExtensionInfoType[ExtensionInfoType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionInfoType[ExtensionInfoType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    ExtensionInfoType[ExtensionInfoType["PagingOnlyGroup"] = 'PagingOnlyGroup'] = "PagingOnlyGroup";
	    ExtensionInfoType[ExtensionInfoType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    ExtensionInfoType[ExtensionInfoType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    ExtensionInfoType[ExtensionInfoType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.ExtensionInfoType || (exports.ExtensionInfoType = {}));
	var ExtensionInfoType = exports.ExtensionInfoType;
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var contactaddressinfo = __webpack_require__(8);
	var ContactInfo = (function (_super) {
	    __extends(ContactInfo, _super);
	    function ContactInfo() {
	        _super.apply(this, arguments);
	    }
	    ContactInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'firstName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'company', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'email', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessPhone', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessAddress', Class: contactaddressinfo.ContactAddressInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ContactInfo.prototype.getClassName = function () {
	        return 'ContactInfo';
	    };
	    return ContactInfo;
	}(model.Model));
	exports.ContactInfo = ContactInfo;
	
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ContactAddressInfo = (function (_super) {
	    __extends(ContactAddressInfo, _super);
	    function ContactAddressInfo() {
	        _super.apply(this, arguments);
	    }
	    ContactAddressInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'country', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'street', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'zip', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ContactAddressInfo.prototype.getClassName = function () {
	        return 'ContactAddressInfo';
	    };
	    return ContactAddressInfo;
	}(model.Model));
	exports.ContactAddressInfo = ContactAddressInfo;
	
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DepartmentInfo = (function (_super) {
	    __extends(DepartmentInfo, _super);
	    function DepartmentInfo() {
	        _super.apply(this, arguments);
	    }
	    DepartmentInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DepartmentInfo.prototype.getClassName = function () {
	        return 'DepartmentInfo';
	    };
	    return DepartmentInfo;
	}(model.Model));
	exports.DepartmentInfo = DepartmentInfo;
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var permissioninfo = __webpack_require__(11);
	var ExtensionPermissions = (function (_super) {
	    __extends(ExtensionPermissions, _super);
	    function ExtensionPermissions() {
	        _super.apply(this, arguments);
	    }
	    ExtensionPermissions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'admin', Class: permissioninfo.PermissionInfo, isArray: false, isRequired: false },
	            { property: 'internationalCalling', Class: permissioninfo.PermissionInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionPermissions.prototype.getClassName = function () {
	        return 'ExtensionPermissions';
	    };
	    return ExtensionPermissions;
	}(model.Model));
	exports.ExtensionPermissions = ExtensionPermissions;
	
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PermissionInfo = (function (_super) {
	    __extends(PermissionInfo, _super);
	    function PermissionInfo() {
	        _super.apply(this, arguments);
	    }
	    PermissionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'enabled', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    PermissionInfo.prototype.getClassName = function () {
	        return 'PermissionInfo';
	    };
	    return PermissionInfo;
	}(model.Model));
	exports.PermissionInfo = PermissionInfo;
	
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ProfileImageInfo = (function (_super) {
	    __extends(ProfileImageInfo, _super);
	    function ProfileImageInfo() {
	        _super.apply(this, arguments);
	    }
	    ProfileImageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'etag', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastModified', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'scales', Class: null /* string[] */, isArray: true, isRequired: false }
	        ];
	    };
	    ProfileImageInfo.prototype.getClassName = function () {
	        return 'ProfileImageInfo';
	    };
	    return ProfileImageInfo;
	}(model.Model));
	exports.ProfileImageInfo = ProfileImageInfo;
	
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ReferenceInfo = (function (_super) {
	    __extends(ReferenceInfo, _super);
	    function ReferenceInfo() {
	        _super.apply(this, arguments);
	    }
	    ReferenceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'ref', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: ReferenceInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    ReferenceInfo.prototype.getClassName = function () {
	        return 'ReferenceInfo';
	    };
	    return ReferenceInfo;
	}(model.Model));
	exports.ReferenceInfo = ReferenceInfo;
	(function (ReferenceInfoType) {
	    ReferenceInfoType[ReferenceInfoType["PartnerId"] = 'PartnerId'] = "PartnerId";
	    ReferenceInfoType[ReferenceInfoType["CustomerDirectoryId"] = 'CustomerDirectoryId'] = "CustomerDirectoryId";
	})(exports.ReferenceInfoType || (exports.ReferenceInfoType = {}));
	var ReferenceInfoType = exports.ReferenceInfoType;
	
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var timezoneinfo = __webpack_require__(16);
	var languageinfo = __webpack_require__(17);
	var greetinglanguageinfo = __webpack_require__(18);
	var formattinglocaleinfo = __webpack_require__(19);
	var RegionalSettings = (function (_super) {
	    __extends(RegionalSettings, _super);
	    function RegionalSettings() {
	        _super.apply(this, arguments);
	    }
	    RegionalSettings.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'homeCountry', Class: countryinfo.CountryInfo, isArray: false, isRequired: false },
	            { property: 'timezone', Class: timezoneinfo.TimezoneInfo, isArray: false, isRequired: false },
	            { property: 'language', Class: languageinfo.LanguageInfo, isArray: false, isRequired: false },
	            { property: 'greetingLanguage', Class: greetinglanguageinfo.GreetingLanguageInfo, isArray: false, isRequired: false },
	            { property: 'formattingLocale', Class: formattinglocaleinfo.FormattingLocaleInfo, isArray: false, isRequired: false }
	        ];
	    };
	    RegionalSettings.prototype.getClassName = function () {
	        return 'RegionalSettings';
	    };
	    return RegionalSettings;
	}(model.Model));
	exports.RegionalSettings = RegionalSettings;
	
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CountryInfo = (function (_super) {
	    __extends(CountryInfo, _super);
	    function CountryInfo() {
	        _super.apply(this, arguments);
	    }
	    CountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    CountryInfo.prototype.getClassName = function () {
	        return 'CountryInfo';
	    };
	    return CountryInfo;
	}(model.Model));
	exports.CountryInfo = CountryInfo;
	
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var TimezoneInfo = (function (_super) {
	    __extends(TimezoneInfo, _super);
	    function TimezoneInfo() {
	        _super.apply(this, arguments);
	    }
	    TimezoneInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'description', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    TimezoneInfo.prototype.getClassName = function () {
	        return 'TimezoneInfo';
	    };
	    return TimezoneInfo;
	}(model.Model));
	exports.TimezoneInfo = TimezoneInfo;
	
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var LanguageInfo = (function (_super) {
	    __extends(LanguageInfo, _super);
	    function LanguageInfo() {
	        _super.apply(this, arguments);
	    }
	    LanguageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'greeting', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'formattingLocale', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'ui', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    LanguageInfo.prototype.getClassName = function () {
	        return 'LanguageInfo';
	    };
	    return LanguageInfo;
	}(model.Model));
	exports.LanguageInfo = LanguageInfo;
	
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var GreetingLanguageInfo = (function (_super) {
	    __extends(GreetingLanguageInfo, _super);
	    function GreetingLanguageInfo() {
	        _super.apply(this, arguments);
	    }
	    GreetingLanguageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    GreetingLanguageInfo.prototype.getClassName = function () {
	        return 'GreetingLanguageInfo';
	    };
	    return GreetingLanguageInfo;
	}(model.Model));
	exports.GreetingLanguageInfo = GreetingLanguageInfo;
	
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var FormattingLocaleInfo = (function (_super) {
	    __extends(FormattingLocaleInfo, _super);
	    function FormattingLocaleInfo() {
	        _super.apply(this, arguments);
	    }
	    FormattingLocaleInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    FormattingLocaleInfo.prototype.getClassName = function () {
	        return 'FormattingLocaleInfo';
	    };
	    return FormattingLocaleInfo;
	}(model.Model));
	exports.FormattingLocaleInfo = FormattingLocaleInfo;
	
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionServiceFeatureInfo = (function (_super) {
	    __extends(ExtensionServiceFeatureInfo, _super);
	    function ExtensionServiceFeatureInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionServiceFeatureInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'enabled', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'featureName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionServiceFeatureInfo.prototype.getClassName = function () {
	        return 'ExtensionServiceFeatureInfo';
	    };
	    return ExtensionServiceFeatureInfo;
	}(model.Model));
	exports.ExtensionServiceFeatureInfo = ExtensionServiceFeatureInfo;
	
	
	/***/ },
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionStatusInfo = (function (_super) {
	    __extends(ExtensionStatusInfo, _super);
	    function ExtensionStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'comment', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: ExtensionStatusInfoReason, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionStatusInfo.prototype.getClassName = function () {
	        return 'ExtensionStatusInfo';
	    };
	    return ExtensionStatusInfo;
	}(model.Model));
	exports.ExtensionStatusInfo = ExtensionStatusInfo;
	(function (ExtensionStatusInfoReason) {
	    ExtensionStatusInfoReason[ExtensionStatusInfoReason["Voluntarily"] = 'Voluntarily'] = "Voluntarily";
	    ExtensionStatusInfoReason[ExtensionStatusInfoReason["Involuntarily"] = 'Involuntarily'] = "Involuntarily";
	})(exports.ExtensionStatusInfoReason || (exports.ExtensionStatusInfoReason = {}));
	var ExtensionStatusInfoReason = exports.ExtensionStatusInfoReason;
	
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var billingplaninfo = __webpack_require__(23);
	var brandinfo = __webpack_require__(24);
	var serviceplaninfo = __webpack_require__(25);
	var targetserviceplaninfo = __webpack_require__(26);
	var ServiceInfo = (function (_super) {
	    __extends(ServiceInfo, _super);
	    function ServiceInfo() {
	        _super.apply(this, arguments);
	    }
	    ServiceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'billingPlan', Class: billingplaninfo.BillingPlanInfo, isArray: false, isRequired: false },
	            { property: 'brand', Class: brandinfo.BrandInfo, isArray: false, isRequired: false },
	            { property: 'servicePlan', Class: serviceplaninfo.ServicePlanInfo, isArray: false, isRequired: false },
	            { property: 'targetServicePlan', Class: targetserviceplaninfo.TargetServicePlanInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ServiceInfo.prototype.getClassName = function () {
	        return 'ServiceInfo';
	    };
	    return ServiceInfo;
	}(model.Model));
	exports.ServiceInfo = ServiceInfo;
	
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BillingPlanInfo = (function (_super) {
	    __extends(BillingPlanInfo, _super);
	    function BillingPlanInfo() {
	        _super.apply(this, arguments);
	    }
	    BillingPlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'durationUnit', Class: BillingPlanInfoDurationUnit, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: BillingPlanInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    BillingPlanInfo.prototype.getClassName = function () {
	        return 'BillingPlanInfo';
	    };
	    return BillingPlanInfo;
	}(model.Model));
	exports.BillingPlanInfo = BillingPlanInfo;
	(function (BillingPlanInfoDurationUnit) {
	    BillingPlanInfoDurationUnit[BillingPlanInfoDurationUnit["Month"] = 'Month'] = "Month";
	    BillingPlanInfoDurationUnit[BillingPlanInfoDurationUnit["Day"] = 'Day'] = "Day";
	})(exports.BillingPlanInfoDurationUnit || (exports.BillingPlanInfoDurationUnit = {}));
	var BillingPlanInfoDurationUnit = exports.BillingPlanInfoDurationUnit;
	(function (BillingPlanInfoType) {
	    BillingPlanInfoType[BillingPlanInfoType["Initial"] = 'Initial'] = "Initial";
	    BillingPlanInfoType[BillingPlanInfoType["Regular"] = 'Regular'] = "Regular";
	    BillingPlanInfoType[BillingPlanInfoType["Suspended"] = 'Suspended'] = "Suspended";
	    BillingPlanInfoType[BillingPlanInfoType["Trial"] = 'Trial'] = "Trial";
	    BillingPlanInfoType[BillingPlanInfoType["TrialNoCC"] = 'TrialNoCC'] = "TrialNoCC";
	    BillingPlanInfoType[BillingPlanInfoType["Free"] = 'Free'] = "Free";
	})(exports.BillingPlanInfoType || (exports.BillingPlanInfoType = {}));
	var BillingPlanInfoType = exports.BillingPlanInfoType;
	
	
	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var BrandInfo = (function (_super) {
	    __extends(BrandInfo, _super);
	    function BrandInfo() {
	        _super.apply(this, arguments);
	    }
	    BrandInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'homeCountry', Class: countryinfo.CountryInfo, isArray: false, isRequired: false }
	        ];
	    };
	    BrandInfo.prototype.getClassName = function () {
	        return 'BrandInfo';
	    };
	    return BrandInfo;
	}(model.Model));
	exports.BrandInfo = BrandInfo;
	
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ServicePlanInfo = (function (_super) {
	    __extends(ServicePlanInfo, _super);
	    function ServicePlanInfo() {
	        _super.apply(this, arguments);
	    }
	    ServicePlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'edition', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ServicePlanInfo.prototype.getClassName = function () {
	        return 'ServicePlanInfo';
	    };
	    return ServicePlanInfo;
	}(model.Model));
	exports.ServicePlanInfo = ServicePlanInfo;
	
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var TargetServicePlanInfo = (function (_super) {
	    __extends(TargetServicePlanInfo, _super);
	    function TargetServicePlanInfo() {
	        _super.apply(this, arguments);
	    }
	    TargetServicePlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    TargetServicePlanInfo.prototype.getClassName = function () {
	        return 'TargetServicePlanInfo';
	    };
	    return TargetServicePlanInfo;
	}(model.Model));
	exports.TargetServicePlanInfo = TargetServicePlanInfo;
	
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var AccountStatusInfo = (function (_super) {
	    __extends(AccountStatusInfo, _super);
	    function AccountStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'comment', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: AccountStatusInfoReason, isArray: false, isRequired: false }
	        ];
	    };
	    AccountStatusInfo.prototype.getClassName = function () {
	        return 'AccountStatusInfo';
	    };
	    return AccountStatusInfo;
	}(model.Model));
	exports.AccountStatusInfo = AccountStatusInfo;
	(function (AccountStatusInfoReason) {
	    AccountStatusInfoReason[AccountStatusInfoReason["Voluntarily"] = 'Voluntarily'] = "Voluntarily";
	    AccountStatusInfoReason[AccountStatusInfoReason["Involuntarily"] = 'Involuntarily'] = "Involuntarily";
	})(exports.AccountStatusInfoReason || (exports.AccountStatusInfoReason = {}));
	var AccountStatusInfoReason = exports.AccountStatusInfoReason;
	
	
	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var businessaddressinfo = __webpack_require__(29);
	var AccountBusinessAddress = (function (_super) {
	    __extends(AccountBusinessAddress, _super);
	    function AccountBusinessAddress() {
	        _super.apply(this, arguments);
	    }
	    AccountBusinessAddress.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'company', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'email', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessAddress', Class: businessaddressinfo.BusinessAddressInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountBusinessAddress.prototype.getClassName = function () {
	        return 'AccountBusinessAddress';
	    };
	    return AccountBusinessAddress;
	}(model.Model));
	exports.AccountBusinessAddress = AccountBusinessAddress;
	
	
	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BusinessAddressInfo = (function (_super) {
	    __extends(BusinessAddressInfo, _super);
	    function BusinessAddressInfo() {
	        _super.apply(this, arguments);
	    }
	    BusinessAddressInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'country', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'street', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'zip', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    BusinessAddressInfo.prototype.getClassName = function () {
	        return 'BusinessAddressInfo';
	    };
	    return BusinessAddressInfo;
	}(model.Model));
	exports.BusinessAddressInfo = BusinessAddressInfo;
	
	
	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dialingplancountryinfo = __webpack_require__(31);
	var paginginfo = __webpack_require__(32);
	var navigationinfo = __webpack_require__(33);
	var DialingPlanInfo = (function (_super) {
	    __extends(DialingPlanInfo, _super);
	    function DialingPlanInfo() {
	        _super.apply(this, arguments);
	    }
	    DialingPlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dialingplancountryinfo.DialingPlanCountryInfo, isArray: true, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DialingPlanInfo.prototype.getClassName = function () {
	        return 'DialingPlanInfo';
	    };
	    return DialingPlanInfo;
	}(model.Model));
	exports.DialingPlanInfo = DialingPlanInfo;
	
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DialingPlanCountryInfo = (function (_super) {
	    __extends(DialingPlanCountryInfo, _super);
	    function DialingPlanCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    DialingPlanCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'callingCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DialingPlanCountryInfo.prototype.getClassName = function () {
	        return 'DialingPlanCountryInfo';
	    };
	    return DialingPlanCountryInfo;
	}(model.Model));
	exports.DialingPlanCountryInfo = DialingPlanCountryInfo;
	
	
	/***/ },
	/* 32 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PagingInfo = (function (_super) {
	    __extends(PagingInfo, _super);
	    function PagingInfo() {
	        _super.apply(this, arguments);
	    }
	    PagingInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'page', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'perPage', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'pageStart', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'pageEnd', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'totalPages', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'totalElements', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    PagingInfo.prototype.getClassName = function () {
	        return 'PagingInfo';
	    };
	    return PagingInfo;
	}(model.Model));
	exports.PagingInfo = PagingInfo;
	
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var NavigationInfo = (function (_super) {
	    __extends(NavigationInfo, _super);
	    function NavigationInfo() {
	        _super.apply(this, arguments);
	    }
	    NavigationInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'firstPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'nextPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'previousPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastPage', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    NavigationInfo.prototype.getClassName = function () {
	        return 'NavigationInfo';
	    };
	    return NavigationInfo;
	}(model.Model));
	exports.NavigationInfo = NavigationInfo;
	
	
	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var phonenumbersextensioninfo = __webpack_require__(35);
	var PhoneNumberInfo = (function (_super) {
	    __extends(PhoneNumberInfo, _super);
	    function PhoneNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    PhoneNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'country', Class: countryinfo.CountryInfo, isArray: false, isRequired: false },
	            { property: 'extension', Class: phonenumbersextensioninfo.PhoneNumbersExtensionInfo, isArray: false, isRequired: false },
	            { property: 'features', Class: null /* string[] */, isArray: true, isRequired: false },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'paymentType', Class: PhoneNumberInfoPaymentType, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'status', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: PhoneNumberInfoType, isArray: false, isRequired: false },
	            { property: 'usageType', Class: PhoneNumberInfoUsageType, isArray: false, isRequired: false }
	        ];
	    };
	    PhoneNumberInfo.prototype.getClassName = function () {
	        return 'PhoneNumberInfo';
	    };
	    return PhoneNumberInfo;
	}(model.Model));
	exports.PhoneNumberInfo = PhoneNumberInfo;
	(function (PhoneNumberInfoPaymentType) {
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["External"] = 'External'] = "External";
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["TollFree"] = 'TollFree'] = "TollFree";
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["Local"] = 'Local'] = "Local";
	})(exports.PhoneNumberInfoPaymentType || (exports.PhoneNumberInfoPaymentType = {}));
	var PhoneNumberInfoPaymentType = exports.PhoneNumberInfoPaymentType;
	(function (PhoneNumberInfoType) {
	    PhoneNumberInfoType[PhoneNumberInfoType["VoiceFax"] = 'VoiceFax'] = "VoiceFax";
	    PhoneNumberInfoType[PhoneNumberInfoType["FaxOnly"] = 'FaxOnly'] = "FaxOnly";
	    PhoneNumberInfoType[PhoneNumberInfoType["VoiceOnly"] = 'VoiceOnly'] = "VoiceOnly";
	})(exports.PhoneNumberInfoType || (exports.PhoneNumberInfoType = {}));
	var PhoneNumberInfoType = exports.PhoneNumberInfoType;
	(function (PhoneNumberInfoUsageType) {
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.PhoneNumberInfoUsageType || (exports.PhoneNumberInfoUsageType = {}));
	var PhoneNumberInfoUsageType = exports.PhoneNumberInfoUsageType;
	
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PhoneNumbersExtensionInfo = (function (_super) {
	    __extends(PhoneNumbersExtensionInfo, _super);
	    function PhoneNumbersExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    PhoneNumbersExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    PhoneNumbersExtensionInfo.prototype.getClassName = function () {
	        return 'PhoneNumbersExtensionInfo';
	    };
	    return PhoneNumbersExtensionInfo;
	}(model.Model));
	exports.PhoneNumbersExtensionInfo = PhoneNumbersExtensionInfo;
	
	
	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var phonenumberinfo = __webpack_require__(34);
	var paginginfo = __webpack_require__(32);
	var navigationinfo = __webpack_require__(33);
	var AccountPhoneNumbers = (function (_super) {
	    __extends(AccountPhoneNumbers, _super);
	    function AccountPhoneNumbers() {
	        _super.apply(this, arguments);
	    }
	    AccountPhoneNumbers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: phonenumberinfo.PhoneNumberInfo, isArray: true, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountPhoneNumbers.prototype.getClassName = function () {
	        return 'AccountPhoneNumbers';
	    };
	    return AccountPhoneNumbers;
	}(model.Model));
	exports.AccountPhoneNumbers = AccountPhoneNumbers;
	
	
	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var servicefeatureinfo = __webpack_require__(38);
	var accountlimits = __webpack_require__(39);
	var AccountServiceInfo = (function (_super) {
	    __extends(AccountServiceInfo, _super);
	    function AccountServiceInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountServiceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'servicePlanName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'serviceFeatures', Class: servicefeatureinfo.ServiceFeatureInfo, isArray: true, isRequired: false },
	            { property: 'limits', Class: accountlimits.AccountLimits, isArray: true, isRequired: false }
	        ];
	    };
	    AccountServiceInfo.prototype.getClassName = function () {
	        return 'AccountServiceInfo';
	    };
	    return AccountServiceInfo;
	}(model.Model));
	exports.AccountServiceInfo = AccountServiceInfo;
	
	
	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ServiceFeatureInfo = (function (_super) {
	    __extends(ServiceFeatureInfo, _super);
	    function ServiceFeatureInfo() {
	        _super.apply(this, arguments);
	    }
	    ServiceFeatureInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'featureName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'enabled', Class: ServiceFeatureInfoEnabled, isArray: false, isRequired: false }
	        ];
	    };
	    ServiceFeatureInfo.prototype.getClassName = function () {
	        return 'ServiceFeatureInfo';
	    };
	    return ServiceFeatureInfo;
	}(model.Model));
	exports.ServiceFeatureInfo = ServiceFeatureInfo;
	(function (ServiceFeatureInfoEnabled) {
	    ServiceFeatureInfoEnabled[ServiceFeatureInfoEnabled["True"] = 'True'] = "True";
	    ServiceFeatureInfoEnabled[ServiceFeatureInfoEnabled["False"] = 'False'] = "False";
	})(exports.ServiceFeatureInfoEnabled || (exports.ServiceFeatureInfoEnabled = {}));
	var ServiceFeatureInfoEnabled = exports.ServiceFeatureInfoEnabled;
	
	
	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var AccountLimits = (function (_super) {
	    __extends(AccountLimits, _super);
	    function AccountLimits() {
	        _super.apply(this, arguments);
	    }
	    AccountLimits.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'freeSoftPhoneLinesPerExtension', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'meetingSize', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'maxMonitoredExtensionsPerUser', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    AccountLimits.prototype.getClassName = function () {
	        return 'AccountLimits';
	    };
	    return AccountLimits;
	}(model.Model));
	exports.AccountLimits = AccountLimits;
	
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var accountactivecalls = __webpack_require__(41);
	var accountcalllog = __webpack_require__(47);
	var accountcalllogrecord = __webpack_require__(48);
	var extensionactivecalls = __webpack_require__(49);
	var extensioncalllog = __webpack_require__(50);
	var extensioncalllogrecord = __webpack_require__(51);
	var calllogsync = __webpack_require__(52);
	var callrecording = __webpack_require__(54);
	var CallLog = (function (_super) {
	    __extends(CallLog, _super);
	    function CallLog() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Account Active Calls
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns records of all calls that are in progress, ordered by start time in descending order.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.listAccountActiveCalls = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/active-calls', options, exports.listAccountActiveCallsOptions), accountactivecalls.AccountActiveCalls);
	    };
	    /**
	     * Get Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log records filtered by the specified parameters.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadAccountCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/call-log', options, exports.loadAccountCallLogOptions), accountcalllog.AccountCallLog);
	    };
	    /**
	     * Delete Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditCallLog</td>
	     *             <td>Viewing and updating user call logs</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.deleteAccountCallLog = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/call-log', options, exports.deleteAccountCallLogOptions), null);
	    };
	    /**
	     * Get Account Call Log Record(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns individual call log record(s) by ID(s). Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadAccountCallLogRecord = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/call-log/{callRecordId}', options, exports.loadAccountCallLogRecordOptions), accountcalllogrecord.AccountCallLogRecord);
	    };
	    /**
	     * Get Active Calls
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns records of all extension calls that are in progress, ordered by start time in descending order.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.listExtensionActiveCalls = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/active-calls', options, exports.listExtensionActiveCallsOptions), extensionactivecalls.ExtensionActiveCalls);
	    };
	    /**
	     * Get Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log records filtered by the specified parameters.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log', options, exports.loadExtensionCallLogOptions), extensioncalllog.ExtensionCallLog);
	    };
	    /**
	     * Delete Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditCallLog</td>
	     *             <td>Viewing and updating user call logs</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.deleteExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log', options, exports.deleteExtensionCallLogOptions), null);
	    };
	    /**
	     * Get Extension Call Log Record(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log record(s) by their ID(s). Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadExtensionCallLogRecord = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log/{callRecordId}', options, exports.loadExtensionCallLogRecordOptions), extensioncalllogrecord.ExtensionCallLogRecord);
	    };
	    /**
	     * Call Log Synchronization
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.syncExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log-sync', options, exports.syncExtensionCallLogOptions), calllogsync.CallLogSync);
	    };
	    /**
	     * Get Call Recording
	     *
	     * <p style='font-style:italic;'>Since 1.0.18</p>
	     * <p>Returns call recording metadata.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallRecording</td>
	     *             <td>Downloading call recording content</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadCallRecordingMetadata = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/recording/{recordingId}', options, exports.loadCallRecordingMetadataOptions), callrecording.CallRecording);
	    };
	    /**
	     * Get Call Recording Data
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallRecording</td>
	     *             <td>Downloading call recording content</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadCallRecordingContent = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/recording/{recordingId}/content', options, exports.loadCallRecordingContentOptions), null);
	    };
	    return CallLog;
	}(client.Client));
	exports.CallLog = CallLog;
	/**
	 * Definition of options for listAccountActiveCalls operation
	 */
	exports.listAccountActiveCallsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "direction",
	        "type": "IListAccountActiveCallsDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListAccountActiveCallsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountCallLog operation
	 */
	exports.loadAccountCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ILoadAccountCallLogDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "ILoadAccountCallLogType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "view",
	        "type": "ILoadAccountCallLogView",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Simple",
	            "Detailed"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withRecording",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for deleteAccountCallLog operation
	 */
	exports.deleteAccountCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountCallLogRecord operation
	 */
	exports.loadAccountCallLogRecordOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "callRecordId",
	        "type": "number",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listExtensionActiveCalls operation
	 */
	exports.listExtensionActiveCallsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "direction",
	        "type": "IListExtensionActiveCallsDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListExtensionActiveCallsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionCallLog operation
	 */
	exports.loadExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ILoadExtensionCallLogDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "ILoadExtensionCallLogType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "view",
	        "type": "ILoadExtensionCallLogView",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Simple",
	            "Detailed"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withRecording",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for deleteExtensionCallLog operation
	 */
	exports.deleteExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionCallLogRecord operation
	 */
	exports.loadExtensionCallLogRecordOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "callRecordId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for syncExtensionCallLog operation
	 */
	exports.syncExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "syncType",
	        "type": "ISyncExtensionCallLogSyncType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "FSync",
	            "ISync"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncToken",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "recordCount",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "statusGroup",
	        "type": "ISyncExtensionCallLogStatusGroup",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Missed",
	            "All"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadCallRecordingMetadata operation
	 */
	exports.loadCallRecordingMetadataOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "recordingId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for loadCallRecordingContent operation
	 */
	exports.loadCallRecordingContentOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "recordingId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	(function (IListAccountActiveCallsDirection) {
	    IListAccountActiveCallsDirection[IListAccountActiveCallsDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListAccountActiveCallsDirection[IListAccountActiveCallsDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListAccountActiveCallsDirection || (exports.IListAccountActiveCallsDirection = {}));
	var IListAccountActiveCallsDirection = exports.IListAccountActiveCallsDirection;
	(function (IListAccountActiveCallsType) {
	    IListAccountActiveCallsType[IListAccountActiveCallsType["Voice"] = 'Voice'] = "Voice";
	    IListAccountActiveCallsType[IListAccountActiveCallsType["Fax"] = 'Fax'] = "Fax";
	})(exports.IListAccountActiveCallsType || (exports.IListAccountActiveCallsType = {}));
	var IListAccountActiveCallsType = exports.IListAccountActiveCallsType;
	(function (ILoadAccountCallLogDirection) {
	    ILoadAccountCallLogDirection[ILoadAccountCallLogDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ILoadAccountCallLogDirection[ILoadAccountCallLogDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ILoadAccountCallLogDirection || (exports.ILoadAccountCallLogDirection = {}));
	var ILoadAccountCallLogDirection = exports.ILoadAccountCallLogDirection;
	(function (ILoadAccountCallLogType) {
	    ILoadAccountCallLogType[ILoadAccountCallLogType["Voice"] = 'Voice'] = "Voice";
	    ILoadAccountCallLogType[ILoadAccountCallLogType["Fax"] = 'Fax'] = "Fax";
	})(exports.ILoadAccountCallLogType || (exports.ILoadAccountCallLogType = {}));
	var ILoadAccountCallLogType = exports.ILoadAccountCallLogType;
	(function (ILoadAccountCallLogView) {
	    ILoadAccountCallLogView[ILoadAccountCallLogView["Simple"] = 'Simple'] = "Simple";
	    ILoadAccountCallLogView[ILoadAccountCallLogView["Detailed"] = 'Detailed'] = "Detailed";
	})(exports.ILoadAccountCallLogView || (exports.ILoadAccountCallLogView = {}));
	var ILoadAccountCallLogView = exports.ILoadAccountCallLogView;
	(function (IListExtensionActiveCallsDirection) {
	    IListExtensionActiveCallsDirection[IListExtensionActiveCallsDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListExtensionActiveCallsDirection[IListExtensionActiveCallsDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListExtensionActiveCallsDirection || (exports.IListExtensionActiveCallsDirection = {}));
	var IListExtensionActiveCallsDirection = exports.IListExtensionActiveCallsDirection;
	(function (IListExtensionActiveCallsType) {
	    IListExtensionActiveCallsType[IListExtensionActiveCallsType["Voice"] = 'Voice'] = "Voice";
	    IListExtensionActiveCallsType[IListExtensionActiveCallsType["Fax"] = 'Fax'] = "Fax";
	})(exports.IListExtensionActiveCallsType || (exports.IListExtensionActiveCallsType = {}));
	var IListExtensionActiveCallsType = exports.IListExtensionActiveCallsType;
	(function (ILoadExtensionCallLogDirection) {
	    ILoadExtensionCallLogDirection[ILoadExtensionCallLogDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ILoadExtensionCallLogDirection[ILoadExtensionCallLogDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ILoadExtensionCallLogDirection || (exports.ILoadExtensionCallLogDirection = {}));
	var ILoadExtensionCallLogDirection = exports.ILoadExtensionCallLogDirection;
	(function (ILoadExtensionCallLogType) {
	    ILoadExtensionCallLogType[ILoadExtensionCallLogType["Voice"] = 'Voice'] = "Voice";
	    ILoadExtensionCallLogType[ILoadExtensionCallLogType["Fax"] = 'Fax'] = "Fax";
	})(exports.ILoadExtensionCallLogType || (exports.ILoadExtensionCallLogType = {}));
	var ILoadExtensionCallLogType = exports.ILoadExtensionCallLogType;
	(function (ILoadExtensionCallLogView) {
	    ILoadExtensionCallLogView[ILoadExtensionCallLogView["Simple"] = 'Simple'] = "Simple";
	    ILoadExtensionCallLogView[ILoadExtensionCallLogView["Detailed"] = 'Detailed'] = "Detailed";
	})(exports.ILoadExtensionCallLogView || (exports.ILoadExtensionCallLogView = {}));
	var ILoadExtensionCallLogView = exports.ILoadExtensionCallLogView;
	(function (ISyncExtensionCallLogSyncType) {
	    ISyncExtensionCallLogSyncType[ISyncExtensionCallLogSyncType["FSync"] = 'FSync'] = "FSync";
	    ISyncExtensionCallLogSyncType[ISyncExtensionCallLogSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.ISyncExtensionCallLogSyncType || (exports.ISyncExtensionCallLogSyncType = {}));
	var ISyncExtensionCallLogSyncType = exports.ISyncExtensionCallLogSyncType;
	(function (ISyncExtensionCallLogStatusGroup) {
	    ISyncExtensionCallLogStatusGroup[ISyncExtensionCallLogStatusGroup["Missed"] = 'Missed'] = "Missed";
	    ISyncExtensionCallLogStatusGroup[ISyncExtensionCallLogStatusGroup["All"] = 'All'] = "All";
	})(exports.ISyncExtensionCallLogStatusGroup || (exports.ISyncExtensionCallLogStatusGroup = {}));
	var ISyncExtensionCallLogStatusGroup = exports.ISyncExtensionCallLogStatusGroup;
	
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var AccountActiveCalls = (function (_super) {
	    __extends(AccountActiveCalls, _super);
	    function AccountActiveCalls() {
	        _super.apply(this, arguments);
	    }
	    AccountActiveCalls.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountActiveCalls.prototype.getClassName = function () {
	        return 'AccountActiveCalls';
	    };
	    return AccountActiveCalls;
	}(model.Model));
	exports.AccountActiveCalls = AccountActiveCalls;
	
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var calllogrecordleginfo = __webpack_require__(45);
	var CallLogRecord = (function (_super) {
	    __extends(CallLogRecord, _super);
	    function CallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    CallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: CallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: CallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: CallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: CallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false },
	            { property: 'lastModifiedTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'transport', Class: CallLogRecordTransport, isArray: false, isRequired: false },
	            { property: 'legs', Class: calllogrecordleginfo.CallLogRecordLegInfo, isArray: true, isRequired: true }
	        ];
	    };
	    CallLogRecord.prototype.getClassName = function () {
	        return 'CallLogRecord';
	    };
	    return CallLogRecord;
	}(model.Model));
	exports.CallLogRecord = CallLogRecord;
	(function (CallLogRecordType) {
	    CallLogRecordType[CallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    CallLogRecordType[CallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.CallLogRecordType || (exports.CallLogRecordType = {}));
	var CallLogRecordType = exports.CallLogRecordType;
	(function (CallLogRecordDirection) {
	    CallLogRecordDirection[CallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    CallLogRecordDirection[CallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.CallLogRecordDirection || (exports.CallLogRecordDirection = {}));
	var CallLogRecordDirection = exports.CallLogRecordDirection;
	(function (CallLogRecordAction) {
	    CallLogRecordAction[CallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordAction[CallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    CallLogRecordAction[CallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    CallLogRecordAction[CallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    CallLogRecordAction[CallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    CallLogRecordAction[CallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    CallLogRecordAction[CallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    CallLogRecordAction[CallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    CallLogRecordAction[CallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    CallLogRecordAction[CallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    CallLogRecordAction[CallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    CallLogRecordAction[CallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    CallLogRecordAction[CallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    CallLogRecordAction[CallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    CallLogRecordAction[CallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    CallLogRecordAction[CallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    CallLogRecordAction[CallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    CallLogRecordAction[CallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    CallLogRecordAction[CallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    CallLogRecordAction[CallLogRecordAction["Support"] = 'Support'] = "Support";
	    CallLogRecordAction[CallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.CallLogRecordAction || (exports.CallLogRecordAction = {}));
	var CallLogRecordAction = exports.CallLogRecordAction;
	(function (CallLogRecordResult) {
	    CallLogRecordResult[CallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordResult[CallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    CallLogRecordResult[CallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    CallLogRecordResult[CallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    CallLogRecordResult[CallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    CallLogRecordResult[CallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    CallLogRecordResult[CallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    CallLogRecordResult[CallLogRecordResult["Received"] = 'Received'] = "Received";
	    CallLogRecordResult[CallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    CallLogRecordResult[CallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    CallLogRecordResult[CallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    CallLogRecordResult[CallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    CallLogRecordResult[CallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    CallLogRecordResult[CallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    CallLogRecordResult[CallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    CallLogRecordResult[CallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    CallLogRecordResult[CallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    CallLogRecordResult[CallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    CallLogRecordResult[CallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    CallLogRecordResult[CallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    CallLogRecordResult[CallLogRecordResult["Account"] = 'Account'] = "Account";
	    CallLogRecordResult[CallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    CallLogRecordResult[CallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    CallLogRecordResult[CallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    CallLogRecordResult[CallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    CallLogRecordResult[CallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    CallLogRecordResult[CallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    CallLogRecordResult[CallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    CallLogRecordResult[CallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    CallLogRecordResult[CallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    CallLogRecordResult[CallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    CallLogRecordResult[CallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    CallLogRecordResult[CallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    CallLogRecordResult[CallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    CallLogRecordResult[CallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    CallLogRecordResult[CallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    CallLogRecordResult[CallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.CallLogRecordResult || (exports.CallLogRecordResult = {}));
	var CallLogRecordResult = exports.CallLogRecordResult;
	(function (CallLogRecordTransport) {
	    CallLogRecordTransport[CallLogRecordTransport["PSTN"] = 'PSTN'] = "PSTN";
	    CallLogRecordTransport[CallLogRecordTransport["VoIP"] = 'VoIP'] = "VoIP";
	})(exports.CallLogRecordTransport || (exports.CallLogRecordTransport = {}));
	var CallLogRecordTransport = exports.CallLogRecordTransport;
	
	
	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CallLogCallerInfo = (function (_super) {
	    __extends(CallLogCallerInfo, _super);
	    function CallLogCallerInfo() {
	        _super.apply(this, arguments);
	    }
	    CallLogCallerInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogCallerInfo.prototype.getClassName = function () {
	        return 'CallLogCallerInfo';
	    };
	    return CallLogCallerInfo;
	}(model.Model));
	exports.CallLogCallerInfo = CallLogCallerInfo;
	
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var RecordingInfo = (function (_super) {
	    __extends(RecordingInfo, _super);
	    function RecordingInfo() {
	        _super.apply(this, arguments);
	    }
	    RecordingInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: RecordingInfoType, isArray: false, isRequired: false },
	            { property: 'contentUri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    RecordingInfo.prototype.getClassName = function () {
	        return 'RecordingInfo';
	    };
	    return RecordingInfo;
	}(model.Model));
	exports.RecordingInfo = RecordingInfo;
	(function (RecordingInfoType) {
	    RecordingInfoType[RecordingInfoType["Automatic"] = 'Automatic'] = "Automatic";
	    RecordingInfoType[RecordingInfoType["OnDemand"] = 'OnDemand'] = "OnDemand";
	})(exports.RecordingInfoType || (exports.RecordingInfoType = {}));
	var RecordingInfoType = exports.RecordingInfoType;
	
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfocalllog = __webpack_require__(46);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var CallLogRecordLegInfo = (function (_super) {
	    __extends(CallLogRecordLegInfo, _super);
	    function CallLogRecordLegInfo() {
	        _super.apply(this, arguments);
	    }
	    CallLogRecordLegInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'action', Class: CallLogRecordLegInfoAction, isArray: false, isRequired: false },
	            { property: 'direction', Class: CallLogRecordLegInfoDirection, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'extension', Class: extensioninfocalllog.ExtensionInfoCallLog, isArray: false, isRequired: false },
	            { property: 'legType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: CallLogRecordLegInfoType, isArray: false, isRequired: false },
	            { property: 'result', Class: CallLogRecordLegInfoResult, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'transport', Class: CallLogRecordLegInfoTransport, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogRecordLegInfo.prototype.getClassName = function () {
	        return 'CallLogRecordLegInfo';
	    };
	    return CallLogRecordLegInfo;
	}(model.Model));
	exports.CallLogRecordLegInfo = CallLogRecordLegInfo;
	(function (CallLogRecordLegInfoAction) {
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["FindMe"] = 'FindMe'] = "FindMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingMe"] = 'RingMe'] = "RingMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Transfer"] = 'Transfer'] = "Transfer";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction['411Info'] = '411 Info'] = '411Info';
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Emergency"] = 'Emergency'] = "Emergency";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Support"] = 'Support'] = "Support";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.CallLogRecordLegInfoAction || (exports.CallLogRecordLegInfoAction = {}));
	var CallLogRecordLegInfoAction = exports.CallLogRecordLegInfoAction;
	(function (CallLogRecordLegInfoDirection) {
	    CallLogRecordLegInfoDirection[CallLogRecordLegInfoDirection["Inbound"] = 'Inbound'] = "Inbound";
	    CallLogRecordLegInfoDirection[CallLogRecordLegInfoDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.CallLogRecordLegInfoDirection || (exports.CallLogRecordLegInfoDirection = {}));
	var CallLogRecordLegInfoDirection = exports.CallLogRecordLegInfoDirection;
	(function (CallLogRecordLegInfoType) {
	    CallLogRecordLegInfoType[CallLogRecordLegInfoType["Voice"] = 'Voice'] = "Voice";
	    CallLogRecordLegInfoType[CallLogRecordLegInfoType["Fax"] = 'Fax'] = "Fax";
	})(exports.CallLogRecordLegInfoType || (exports.CallLogRecordLegInfoType = {}));
	var CallLogRecordLegInfoType = exports.CallLogRecordLegInfoType;
	(function (CallLogRecordLegInfoResult) {
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Missed"] = 'Missed'] = "Missed";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Rejected"] = 'Rejected'] = "Rejected";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Reply"] = 'Reply'] = "Reply";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Received"] = 'Received'] = "Received";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Blocked"] = 'Blocked'] = "Blocked";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Busy"] = 'Busy'] = "Busy";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["SendError"] = 'Send Error'] = "SendError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Sent"] = 'Sent'] = "Sent";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Account"] = 'Account'] = "Account";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Suspended"] = 'Suspended'] = "Suspended";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternalError"] = 'Internal Error'] = "InternalError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Stopped"] = 'Stopped'] = "Stopped";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Hangup"] = 'Hang up'] = "Hangup";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Declined"] = 'Declined'] = "Declined";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.CallLogRecordLegInfoResult || (exports.CallLogRecordLegInfoResult = {}));
	var CallLogRecordLegInfoResult = exports.CallLogRecordLegInfoResult;
	(function (CallLogRecordLegInfoTransport) {
	    CallLogRecordLegInfoTransport[CallLogRecordLegInfoTransport["PSTN"] = 'PSTN'] = "PSTN";
	    CallLogRecordLegInfoTransport[CallLogRecordLegInfoTransport["VoIP"] = 'VoIP'] = "VoIP";
	})(exports.CallLogRecordLegInfoTransport || (exports.CallLogRecordLegInfoTransport = {}));
	var CallLogRecordLegInfoTransport = exports.CallLogRecordLegInfoTransport;
	
	
	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionInfoCallLog = (function (_super) {
	    __extends(ExtensionInfoCallLog, _super);
	    function ExtensionInfoCallLog() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfoCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionInfoCallLog.prototype.getClassName = function () {
	        return 'ExtensionInfoCallLog';
	    };
	    return ExtensionInfoCallLog;
	}(model.Model));
	exports.ExtensionInfoCallLog = ExtensionInfoCallLog;
	
	
	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var AccountCallLog = (function (_super) {
	    __extends(AccountCallLog, _super);
	    function AccountCallLog() {
	        _super.apply(this, arguments);
	    }
	    AccountCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountCallLog.prototype.getClassName = function () {
	        return 'AccountCallLog';
	    };
	    return AccountCallLog;
	}(model.Model));
	exports.AccountCallLog = AccountCallLog;
	
	
	/***/ },
	/* 48 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var AccountCallLogRecord = (function (_super) {
	    __extends(AccountCallLogRecord, _super);
	    function AccountCallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    AccountCallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: AccountCallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: AccountCallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: AccountCallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: AccountCallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    AccountCallLogRecord.prototype.getClassName = function () {
	        return 'AccountCallLogRecord';
	    };
	    return AccountCallLogRecord;
	}(model.Model));
	exports.AccountCallLogRecord = AccountCallLogRecord;
	(function (AccountCallLogRecordType) {
	    AccountCallLogRecordType[AccountCallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    AccountCallLogRecordType[AccountCallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.AccountCallLogRecordType || (exports.AccountCallLogRecordType = {}));
	var AccountCallLogRecordType = exports.AccountCallLogRecordType;
	(function (AccountCallLogRecordDirection) {
	    AccountCallLogRecordDirection[AccountCallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    AccountCallLogRecordDirection[AccountCallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.AccountCallLogRecordDirection || (exports.AccountCallLogRecordDirection = {}));
	var AccountCallLogRecordDirection = exports.AccountCallLogRecordDirection;
	(function (AccountCallLogRecordAction) {
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    AccountCallLogRecordAction[AccountCallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    AccountCallLogRecordAction[AccountCallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Support"] = 'Support'] = "Support";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.AccountCallLogRecordAction || (exports.AccountCallLogRecordAction = {}));
	var AccountCallLogRecordAction = exports.AccountCallLogRecordAction;
	(function (AccountCallLogRecordResult) {
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Received"] = 'Received'] = "Received";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Account"] = 'Account'] = "Account";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.AccountCallLogRecordResult || (exports.AccountCallLogRecordResult = {}));
	var AccountCallLogRecordResult = exports.AccountCallLogRecordResult;
	
	
	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionActiveCalls = (function (_super) {
	    __extends(ExtensionActiveCalls, _super);
	    function ExtensionActiveCalls() {
	        _super.apply(this, arguments);
	    }
	    ExtensionActiveCalls.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionActiveCalls.prototype.getClassName = function () {
	        return 'ExtensionActiveCalls';
	    };
	    return ExtensionActiveCalls;
	}(model.Model));
	exports.ExtensionActiveCalls = ExtensionActiveCalls;
	
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionCallLog = (function (_super) {
	    __extends(ExtensionCallLog, _super);
	    function ExtensionCallLog() {
	        _super.apply(this, arguments);
	    }
	    ExtensionCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionCallLog.prototype.getClassName = function () {
	        return 'ExtensionCallLog';
	    };
	    return ExtensionCallLog;
	}(model.Model));
	exports.ExtensionCallLog = ExtensionCallLog;
	
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var ExtensionCallLogRecord = (function (_super) {
	    __extends(ExtensionCallLogRecord, _super);
	    function ExtensionCallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    ExtensionCallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionCallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: ExtensionCallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: ExtensionCallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: ExtensionCallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionCallLogRecord.prototype.getClassName = function () {
	        return 'ExtensionCallLogRecord';
	    };
	    return ExtensionCallLogRecord;
	}(model.Model));
	exports.ExtensionCallLogRecord = ExtensionCallLogRecord;
	(function (ExtensionCallLogRecordType) {
	    ExtensionCallLogRecordType[ExtensionCallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    ExtensionCallLogRecordType[ExtensionCallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.ExtensionCallLogRecordType || (exports.ExtensionCallLogRecordType = {}));
	var ExtensionCallLogRecordType = exports.ExtensionCallLogRecordType;
	(function (ExtensionCallLogRecordDirection) {
	    ExtensionCallLogRecordDirection[ExtensionCallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ExtensionCallLogRecordDirection[ExtensionCallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ExtensionCallLogRecordDirection || (exports.ExtensionCallLogRecordDirection = {}));
	var ExtensionCallLogRecordDirection = exports.ExtensionCallLogRecordDirection;
	(function (ExtensionCallLogRecordAction) {
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Support"] = 'Support'] = "Support";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.ExtensionCallLogRecordAction || (exports.ExtensionCallLogRecordAction = {}));
	var ExtensionCallLogRecordAction = exports.ExtensionCallLogRecordAction;
	(function (ExtensionCallLogRecordResult) {
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Received"] = 'Received'] = "Received";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Account"] = 'Account'] = "Account";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.ExtensionCallLogRecordResult || (exports.ExtensionCallLogRecordResult = {}));
	var ExtensionCallLogRecordResult = exports.ExtensionCallLogRecordResult;
	
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var syncinfocalllog = __webpack_require__(53);
	var CallLogSync = (function (_super) {
	    __extends(CallLogSync, _super);
	    function CallLogSync() {
	        _super.apply(this, arguments);
	    }
	    CallLogSync.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'syncInfo', Class: syncinfocalllog.SyncInfoCallLog, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogSync.prototype.getClassName = function () {
	        return 'CallLogSync';
	    };
	    return CallLogSync;
	}(model.Model));
	exports.CallLogSync = CallLogSync;
	
	
	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var SyncInfoCallLog = (function (_super) {
	    __extends(SyncInfoCallLog, _super);
	    function SyncInfoCallLog() {
	        _super.apply(this, arguments);
	    }
	    SyncInfoCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'syncType', Class: SyncInfoCallLogSyncType, isArray: false, isRequired: false },
	            { property: 'syncToken', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'syncTime', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    SyncInfoCallLog.prototype.getClassName = function () {
	        return 'SyncInfoCallLog';
	    };
	    return SyncInfoCallLog;
	}(model.Model));
	exports.SyncInfoCallLog = SyncInfoCallLog;
	(function (SyncInfoCallLogSyncType) {
	    SyncInfoCallLogSyncType[SyncInfoCallLogSyncType["FSync"] = 'FSync'] = "FSync";
	    SyncInfoCallLogSyncType[SyncInfoCallLogSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.SyncInfoCallLogSyncType || (exports.SyncInfoCallLogSyncType = {}));
	var SyncInfoCallLogSyncType = exports.SyncInfoCallLogSyncType;
	
	
	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CallRecording = (function (_super) {
	    __extends(CallRecording, _super);
	    function CallRecording() {
	        _super.apply(this, arguments);
	    }
	    CallRecording.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentUri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    CallRecording.prototype.getClassName = function () {
	        return 'CallRecording';
	    };
	    return CallRecording;
	}(model.Model));
	exports.CallRecording = CallRecording;
	
	
	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var countrylist = __webpack_require__(56);
	var dictionarycountryinfo = __webpack_require__(57);
	var languagelist = __webpack_require__(58);
	var languageinfo = __webpack_require__(17);
	var dictionarylocationlist = __webpack_require__(59);
	var dictionarysecretquestionlist = __webpack_require__(61);
	var secretquestioninfo = __webpack_require__(62);
	var dictionaryshippingoptions = __webpack_require__(63);
	var dictionarystatelist = __webpack_require__(65);
	var dictionarystateinfo = __webpack_require__(66);
	var dictionarytimezonelist = __webpack_require__(68);
	var dictionarytimezoneinfo = __webpack_require__(69);
	var Dictionary = (function (_super) {
	    __extends(Dictionary, _super);
	    function Dictionary() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Country List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the countries available for calling.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listCountries = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/country', options, exports.listCountriesOptions), countrylist.CountryList);
	    };
	    /**
	     * Get Country
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on the required country.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadCountry = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/country/{countryId}', options, exports.loadCountryOptions), dictionarycountryinfo.DictionaryCountryInfo);
	    };
	    /**
	     * Get Language List
	     *
	     * <p style='font-style:italic;'>Since 1.0.14 (Release 6.6)</p>
	     * <p>Returns the information about supported languages.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listLanguages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/language', options, exports.listLanguagesOptions), languagelist.LanguageList);
	    };
	    /**
	     * Get Language
	     *
	     * <p style='font-style:italic;'>Since 1.0.14 (Release 6.6)</p>
	     * <p>Returns language by its respective ID.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadLanguage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/language/{languageId}', options, exports.loadLanguageOptions), languageinfo.LanguageInfo);
	    };
	    /**
	     * Get Location List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the available locations for the certain state.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listLocations = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/location', options, exports.listLocationsOptions), dictionarylocationlist.DictionaryLocationList);
	    };
	    /**
	     * Get Secret Question List
	     *
	     * <p style='font-style:italic;'>Since 1.0.20 (Release 7.4)</p>
	     * <p>Returns the list of secret questions for a specific language.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listSecretQuestions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/secret-question', options, exports.listSecretQuestionsOptions), dictionarysecretquestionlist.DictionarySecretQuestionList);
	    };
	    /**
	     * Get Secret Question
	     *
	     * <p style='font-style:italic;'>Since 1.0.20 (Release 7.4)</p>
	     * <p>Returns a particular secret question in specific language by question ID.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadSecretQuestion = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/secret-question/questionId', options, exports.loadSecretQuestionOptions), secretquestioninfo.SecretQuestionInfo);
	    };
	    /**
	     * Get Shipping Options
	     *
	     * <p style='font-style:italic;'>Since 1.0.16 (Release 7.1)</p>
	     * <p>Returns the list of device shipping options with their prices, according to brand, tier, number of ordered devices.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listShippingOptions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/shipping-options', options, exports.listShippingOptionsOptions), dictionaryshippingoptions.DictionaryShippingOptions);
	    };
	    /**
	     * Get State List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the states for a certain country.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadlistStates = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/state', options, exports.loadlistStatesOptions), dictionarystatelist.DictionaryStateList);
	    };
	    /**
	     * Get State
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on the required state.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadState = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/state/{stateId}', options, exports.loadStateOptions), dictionarystateinfo.DictionaryStateInfo);
	    };
	    /**
	     * Get Timezone List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all available timezones.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listTimezones = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/timezone', options, exports.listTimezonesOptions), dictionarytimezonelist.DictionaryTimezoneList);
	    };
	    /**
	     * Get Timezone
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on a certain timezone.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadTimezone = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/timezone/{timezoneId}', options, exports.loadTimezoneOptions), dictionarytimezoneinfo.DictionaryTimezoneInfo);
	    };
	    return Dictionary;
	}(client.Client));
	exports.Dictionary = Dictionary;
	/**
	 * Definition of options for listCountries operation
	 */
	exports.listCountriesOptions = [
	    {
	        "name": "loginAllowed",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "numberSelling",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadCountry operation
	 */
	exports.loadCountryOptions = [
	    {
	        "name": "countryId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listLanguages operation
	 */
	exports.listLanguagesOptions = [];
	/**
	 * Definition of options for loadLanguage operation
	 */
	exports.loadLanguageOptions = [
	    {
	        "name": "languageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listLocations operation
	 */
	exports.listLocationsOptions = [
	    {
	        "name": "orderBy",
	        "type": "IListLocationsOrderBy",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Npa",
	            "City"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "stateId",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withNxx",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for listSecretQuestions operation
	 */
	exports.listSecretQuestionsOptions = [];
	/**
	 * Definition of options for loadSecretQuestion operation
	 */
	exports.loadSecretQuestionOptions = [
	    {
	        "name": "questionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listShippingOptions operation
	 */
	exports.listShippingOptionsOptions = [];
	/**
	 * Definition of options for loadlistStates operation
	 */
	exports.loadlistStatesOptions = [
	    {
	        "name": "countryId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withPhoneNumbers",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadState operation
	 */
	exports.loadStateOptions = [
	    {
	        "name": "stateId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listTimezones operation
	 */
	exports.listTimezonesOptions = [
	    {
	        "name": "page",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadTimezone operation
	 */
	exports.loadTimezoneOptions = [
	    {
	        "name": "timezoneId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListLocationsOrderBy) {
	    IListLocationsOrderBy[IListLocationsOrderBy["Npa"] = 'Npa'] = "Npa";
	    IListLocationsOrderBy[IListLocationsOrderBy["City"] = 'City'] = "City";
	})(exports.IListLocationsOrderBy || (exports.IListLocationsOrderBy = {}));
	var IListLocationsOrderBy = exports.IListLocationsOrderBy;
	
	
	/***/ },
	/* 56 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarycountryinfo = __webpack_require__(57);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var CountryList = (function (_super) {
	    __extends(CountryList, _super);
	    function CountryList() {
	        _super.apply(this, arguments);
	    }
	    CountryList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarycountryinfo.DictionaryCountryInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    CountryList.prototype.getClassName = function () {
	        return 'CountryList';
	    };
	    return CountryList;
	}(model.Model));
	exports.CountryList = CountryList;
	
	
	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DictionaryCountryInfo = (function (_super) {
	    __extends(DictionaryCountryInfo, _super);
	    function DictionaryCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'callingCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'emergencyCalling', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'numberSelling', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'loginAllowed', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryCountryInfo.prototype.getClassName = function () {
	        return 'DictionaryCountryInfo';
	    };
	    return DictionaryCountryInfo;
	}(model.Model));
	exports.DictionaryCountryInfo = DictionaryCountryInfo;
	
	
	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var languageinfo = __webpack_require__(17);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var LanguageList = (function (_super) {
	    __extends(LanguageList, _super);
	    function LanguageList() {
	        _super.apply(this, arguments);
	    }
	    LanguageList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'records', Class: languageinfo.LanguageInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    LanguageList.prototype.getClassName = function () {
	        return 'LanguageList';
	    };
	    return LanguageList;
	}(model.Model));
	exports.LanguageList = LanguageList;
	
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var locationinfo = __webpack_require__(60);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryLocationList = (function (_super) {
	    __extends(DictionaryLocationList, _super);
	    function DictionaryLocationList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryLocationList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: locationinfo.LocationInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryLocationList.prototype.getClassName = function () {
	        return 'DictionaryLocationList';
	    };
	    return DictionaryLocationList;
	}(model.Model));
	exports.DictionaryLocationList = DictionaryLocationList;
	
	
	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var LocationInfo = (function (_super) {
	    __extends(LocationInfo, _super);
	    function LocationInfo() {
	        _super.apply(this, arguments);
	    }
	    LocationInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'areaCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'npa', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'nxx', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    LocationInfo.prototype.getClassName = function () {
	        return 'LocationInfo';
	    };
	    return LocationInfo;
	}(model.Model));
	exports.LocationInfo = LocationInfo;
	
	
	/***/ },
	/* 61 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var secretquestioninfo = __webpack_require__(62);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionarySecretQuestionList = (function (_super) {
	    __extends(DictionarySecretQuestionList, _super);
	    function DictionarySecretQuestionList() {
	        _super.apply(this, arguments);
	    }
	    DictionarySecretQuestionList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'records', Class: secretquestioninfo.SecretQuestionInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: false },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    DictionarySecretQuestionList.prototype.getClassName = function () {
	        return 'DictionarySecretQuestionList';
	    };
	    return DictionarySecretQuestionList;
	}(model.Model));
	exports.DictionarySecretQuestionList = DictionarySecretQuestionList;
	
	
	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var SecretQuestionInfo = (function (_super) {
	    __extends(SecretQuestionInfo, _super);
	    function SecretQuestionInfo() {
	        _super.apply(this, arguments);
	    }
	    SecretQuestionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'questionType', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'languageId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'questionText', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'showInSignUp', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    SecretQuestionInfo.prototype.getClassName = function () {
	        return 'SecretQuestionInfo';
	    };
	    return SecretQuestionInfo;
	}(model.Model));
	exports.SecretQuestionInfo = SecretQuestionInfo;
	
	
	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var shippingmethodinfo = __webpack_require__(64);
	var DictionaryShippingOptions = (function (_super) {
	    __extends(DictionaryShippingOptions, _super);
	    function DictionaryShippingOptions() {
	        _super.apply(this, arguments);
	    }
	    DictionaryShippingOptions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'quantity', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'price', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'method', Class: shippingmethodinfo.ShippingMethodInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryShippingOptions.prototype.getClassName = function () {
	        return 'DictionaryShippingOptions';
	    };
	    return DictionaryShippingOptions;
	}(model.Model));
	exports.DictionaryShippingOptions = DictionaryShippingOptions;
	
	
	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ShippingMethodInfo = (function (_super) {
	    __extends(ShippingMethodInfo, _super);
	    function ShippingMethodInfo() {
	        _super.apply(this, arguments);
	    }
	    ShippingMethodInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ShippingMethodInfo.prototype.getClassName = function () {
	        return 'ShippingMethodInfo';
	    };
	    return ShippingMethodInfo;
	}(model.Model));
	exports.ShippingMethodInfo = ShippingMethodInfo;
	
	
	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarystateinfo = __webpack_require__(66);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryStateList = (function (_super) {
	    __extends(DictionaryStateList, _super);
	    function DictionaryStateList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryStateList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarystateinfo.DictionaryStateInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryStateList.prototype.getClassName = function () {
	        return 'DictionaryStateList';
	    };
	    return DictionaryStateList;
	}(model.Model));
	exports.DictionaryStateList = DictionaryStateList;
	
	
	/***/ },
	/* 66 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var statecountryinfo = __webpack_require__(67);
	var DictionaryStateInfo = (function (_super) {
	    __extends(DictionaryStateInfo, _super);
	    function DictionaryStateInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryStateInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'country', Class: statecountryinfo.StateCountryInfo, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryStateInfo.prototype.getClassName = function () {
	        return 'DictionaryStateInfo';
	    };
	    return DictionaryStateInfo;
	}(model.Model));
	exports.DictionaryStateInfo = DictionaryStateInfo;
	
	
	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var StateCountryInfo = (function (_super) {
	    __extends(StateCountryInfo, _super);
	    function StateCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    StateCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    StateCountryInfo.prototype.getClassName = function () {
	        return 'StateCountryInfo';
	    };
	    return StateCountryInfo;
	}(model.Model));
	exports.StateCountryInfo = StateCountryInfo;
	
	
	/***/ },
	/* 68 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarytimezoneinfo = __webpack_require__(69);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryTimezoneList = (function (_super) {
	    __extends(DictionaryTimezoneList, _super);
	    function DictionaryTimezoneList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryTimezoneList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarytimezoneinfo.DictionaryTimezoneInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryTimezoneList.prototype.getClassName = function () {
	        return 'DictionaryTimezoneList';
	    };
	    return DictionaryTimezoneList;
	}(model.Model));
	exports.DictionaryTimezoneList = DictionaryTimezoneList;
	
	
	/***/ },
	/* 69 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DictionaryTimezoneInfo = (function (_super) {
	    __extends(DictionaryTimezoneInfo, _super);
	    function DictionaryTimezoneInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryTimezoneInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'description', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryTimezoneInfo.prototype.getClassName = function () {
	        return 'DictionaryTimezoneInfo';
	    };
	    return DictionaryTimezoneInfo;
	}(model.Model));
	exports.DictionaryTimezoneInfo = DictionaryTimezoneInfo;
	
	
	/***/ },
	/* 70 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var extensionlist = __webpack_require__(71);
	var extensioninfo = __webpack_require__(6);
	var extensionphonenumbers = __webpack_require__(72);
	var extensiongrantlist = __webpack_require__(73);
	var departmentmembers = __webpack_require__(76);
	var Extension = (function (_super) {
	    __extends(Extension, _super);
	    function Extension() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension List
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns the list of extensions created for a particular account. All types of extensions are included in this list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.listExtensions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension', options, exports.listExtensionsOptions), extensionlist.ExtensionList);
	    };
	    /**
	     * Get Extension Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns basic information about a particular extension of an account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.loadExtensionInfo = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}', options, exports.loadExtensionInfoOptions), extensioninfo.ExtensionInfo);
	    };
	    /**
	     * Get Extension Phone Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers that are used by a particular extension, and can be filtered by the phone number type. The returned list contains all numbers which are directly mapped to a given extension plus the features and also company-level numbers
	     *     which may be used when performing different operations on behalf of this extension.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listExtensionPhoneNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/phone-number', options, exports.listExtensionPhoneNumbersOptions), extensionphonenumbers.ExtensionPhoneNumbers);
	    };
	    /**
	     * Get Extension Grant List
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the list of extension grants.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listExtensionGrants = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/grant', options, exports.listExtensionGrantsOptions), extensiongrantlist.ExtensionGrantList);
	    };
	    /**
	     * Get Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.loadExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.loadExtensionProfileImageOptions), null);
	    };
	    /**
	     * Create Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>High</p>
	     */
	    Extension.prototype.createExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.createExtensionProfileImageOptions), null);
	    };
	    /**
	     * Update Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Updates the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>High</p>
	     */
	    Extension.prototype.updateExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.updateExtensionProfileImageOptions), null);
	    };
	    /**
	     * Get Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the scaled profile image of an extension.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.loadExtensionScaledProfileImage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image/{scaleSize}', options, exports.loadExtensionScaledProfileImageOptions), null);
	    };
	    /**
	     * Get Department Member List
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listDepartmentMembers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/department/{departmentId}/members', options, exports.listDepartmentMembersOptions), departmentmembers.DepartmentMembers);
	    };
	    return Extension;
	}(client.Client));
	exports.Extension = Extension;
	/**
	 * Definition of options for listExtensions operation
	 */
	exports.listExtensionsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "status",
	        "type": "IListExtensionsStatus",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Enabled",
	            "Disabled",
	            "NotActivated",
	            "Unassigned"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListExtensionsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "User",
	            "FaxUser",
	            "VirtualUser",
	            "DigitalUser",
	            "Department",
	            "Announcement",
	            "Voicemail",
	            "SharedLinesGroup",
	            "PagingOnlyGroup",
	            "IvrMenu",
	            "ApplicationExtension",
	            "ParkLocation"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionInfo operation
	 */
	exports.loadExtensionInfoOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listExtensionPhoneNumbers operation
	 */
	exports.listExtensionPhoneNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "usageType",
	        "type": "IListExtensionPhoneNumbersUsageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "MainCompanyNumber",
	            "AdditionalCompanyNumber",
	            "CompanyNumber",
	            "DirectNumber",
	            "CompanyFaxNumber",
	            "ForwardedNumber"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for listExtensionGrants operation
	 */
	exports.listExtensionGrantsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionProfileImage operation
	 */
	exports.loadExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for createExtensionProfileImage operation
	 */
	exports.createExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for updateExtensionProfileImage operation
	 */
	exports.updateExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadExtensionScaledProfileImage operation
	 */
	exports.loadExtensionScaledProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "scaleSize",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listDepartmentMembers operation
	 */
	exports.listDepartmentMembersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "departmentId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListExtensionsStatus) {
	    IListExtensionsStatus[IListExtensionsStatus["Enabled"] = 'Enabled'] = "Enabled";
	    IListExtensionsStatus[IListExtensionsStatus["Disabled"] = 'Disabled'] = "Disabled";
	    IListExtensionsStatus[IListExtensionsStatus["NotActivated"] = 'NotActivated'] = "NotActivated";
	    IListExtensionsStatus[IListExtensionsStatus["Unassigned"] = 'Unassigned'] = "Unassigned";
	})(exports.IListExtensionsStatus || (exports.IListExtensionsStatus = {}));
	var IListExtensionsStatus = exports.IListExtensionsStatus;
	(function (IListExtensionsType) {
	    IListExtensionsType[IListExtensionsType["User"] = 'User'] = "User";
	    IListExtensionsType[IListExtensionsType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    IListExtensionsType[IListExtensionsType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    IListExtensionsType[IListExtensionsType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    IListExtensionsType[IListExtensionsType["Department"] = 'Department'] = "Department";
	    IListExtensionsType[IListExtensionsType["Announcement"] = 'Announcement'] = "Announcement";
	    IListExtensionsType[IListExtensionsType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    IListExtensionsType[IListExtensionsType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    IListExtensionsType[IListExtensionsType["PagingOnlyGroup"] = 'PagingOnlyGroup'] = "PagingOnlyGroup";
	    IListExtensionsType[IListExtensionsType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    IListExtensionsType[IListExtensionsType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    IListExtensionsType[IListExtensionsType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.IListExtensionsType || (exports.IListExtensionsType = {}));
	var IListExtensionsType = exports.IListExtensionsType;
	(function (IListExtensionPhoneNumbersUsageType) {
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.IListExtensionPhoneNumbersUsageType || (exports.IListExtensionPhoneNumbersUsageType = {}));
	var IListExtensionPhoneNumbersUsageType = exports.IListExtensionPhoneNumbersUsageType;
	
	
	/***/ },
	/* 71 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionList = (function (_super) {
	    __extends(ExtensionList, _super);
	    function ExtensionList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: extensioninfo.ExtensionInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionList.prototype.getClassName = function () {
	        return 'ExtensionList';
	    };
	    return ExtensionList;
	}(model.Model));
	exports.ExtensionList = ExtensionList;
	
	
	/***/ },
	/* 72 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var phonenumberinfo = __webpack_require__(34);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionPhoneNumbers = (function (_super) {
	    __extends(ExtensionPhoneNumbers, _super);
	    function ExtensionPhoneNumbers() {
	        _super.apply(this, arguments);
	    }
	    ExtensionPhoneNumbers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: phonenumberinfo.PhoneNumberInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionPhoneNumbers.prototype.getClassName = function () {
	        return 'ExtensionPhoneNumbers';
	    };
	    return ExtensionPhoneNumbers;
	}(model.Model));
	exports.ExtensionPhoneNumbers = ExtensionPhoneNumbers;
	
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var grantinfo = __webpack_require__(74);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionGrantList = (function (_super) {
	    __extends(ExtensionGrantList, _super);
	    function ExtensionGrantList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionGrantList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: grantinfo.GrantInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionGrantList.prototype.getClassName = function () {
	        return 'ExtensionGrantList';
	    };
	    return ExtensionGrantList;
	}(model.Model));
	exports.ExtensionGrantList = ExtensionGrantList;
	
	
	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfogrants = __webpack_require__(75);
	var GrantInfo = (function (_super) {
	    __extends(GrantInfo, _super);
	    function GrantInfo() {
	        _super.apply(this, arguments);
	    }
	    GrantInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extension', Class: extensioninfogrants.ExtensionInfoGrants, isArray: false, isRequired: false },
	            { property: 'callPickup', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'callMonitoring', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    GrantInfo.prototype.getClassName = function () {
	        return 'GrantInfo';
	    };
	    return GrantInfo;
	}(model.Model));
	exports.GrantInfo = GrantInfo;
	
	
	/***/ },
	/* 75 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionInfoGrants = (function (_super) {
	    __extends(ExtensionInfoGrants, _super);
	    function ExtensionInfoGrants() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfoGrants.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionInfoGrantsType, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionInfoGrants.prototype.getClassName = function () {
	        return 'ExtensionInfoGrants';
	    };
	    return ExtensionInfoGrants;
	}(model.Model));
	exports.ExtensionInfoGrants = ExtensionInfoGrants;
	(function (ExtensionInfoGrantsType) {
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["User"] = 'User'] = "User";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["FaxUser"] = 'Fax User'] = "FaxUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Department"] = 'Department'] = "Department";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Announcement"] = 'Announcement'] = "Announcement";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["PagingOnly"] = 'PagingOnly'] = "PagingOnly";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["ParkLocation"] = 'Park Location'] = "ParkLocation";
	})(exports.ExtensionInfoGrantsType || (exports.ExtensionInfoGrantsType = {}));
	var ExtensionInfoGrantsType = exports.ExtensionInfoGrantsType;
	
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DepartmentMembers = (function (_super) {
	    __extends(DepartmentMembers, _super);
	    function DepartmentMembers() {
	        _super.apply(this, arguments);
	    }
	    DepartmentMembers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: extensioninfo.ExtensionInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DepartmentMembers.prototype.getClassName = function () {
	        return 'DepartmentMembers';
	    };
	    return DepartmentMembers;
	}(model.Model));
	exports.DepartmentMembers = DepartmentMembers;
	
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var messageinfo = __webpack_require__(78);
	var messagelist = __webpack_require__(81);
	var messagesync = __webpack_require__(82);
	var Messages = (function (_super) {
	    __extends(Messages, _super);
	    function Messages() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Pager Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends a pager message.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>InternalMessages</td>
	     *             <td>Sending and receiving intra-company text messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.sendInternalMessage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/company-pager', options, exports.sendInternalMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Create Fax Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends/resends new fax message. Resend can be done if sending failed.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>Faxes</td>
	     *             <td>Sending and receiving faxes</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Messages.prototype.sendFaxMessage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/fax', options, exports.sendFaxMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Create SMS Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends new SMS message. Sending SMS messages simultaneously to different recipients is limited up to 50 requests per minute; relevant for all client applications.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>SMS</td>
	     *             <td>Sending and receiving SMS (text) messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.sendSMS = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/sms', options, exports.sendSMSOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Get Message List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of messages from an extension mailbox.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.listMessages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store', options, exports.listMessagesOptions), messagelist.MessageList);
	    };
	    /**
	     * Get Message(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns individual message record(s) by the given message ID(s). The length of inbound messages is unlimited. Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.loadMessage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.loadMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Update Message(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Updates message(s) by ID(s). Batch request is supported, see Batch Requests for details. Currently, only the message read status updating is supported.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditMessages</td>
	     *             <td>Viewing and updating user messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.updateMessage = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.updateMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Delete Message(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Deletes message(s) by the given message ID(s). The first call of this method transfers the message to the 'Delete' status. The second call transfers the deleted message to the 'Purged' status. If it is required to make the message 'Purged' immediately
	     *     (from the first call), then set the query parameter purge to 'True'. Batch request is supported.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditMessages</td>
	     *             <td>Viewing and updating user messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.deleteMessage = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.deleteMessageOptions), null);
	    };
	    /**
	     * Get Message Attachment
	     *
	     * <p style='font-style:italic;'>Since 1.0.4 (Release 5.13)</p>
	     * <p>Returns particular message attachment data as a media stream.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.loadMessageAttachment = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}/content/{attachmentId}', options, exports.loadMessageAttachmentOptions), null);
	    };
	    /**
	     * Get Message Sync
	     *
	     * <p style='font-style:italic;'>Since 1.0.4 (Release 5.13)</p>
	     * <p>Provides facilities to synchronize mailbox content stored externally with server state.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.syncMessages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-sync', options, exports.syncMessagesOptions), messagesync.MessageSync);
	    };
	    return Messages;
	}(client.Client));
	exports.Messages = Messages;
	/**
	 * Definition of options for sendInternalMessage operation
	 */
	exports.sendInternalMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createpagermessagerequest.CreatePagerMessageRequest"
	    }
	];
	/**
	 * Definition of options for sendFaxMessage operation
	 */
	exports.sendFaxMessageOptions = [
	    {
	        "name": "accountId",
	        "in": "path",
	        "notes": "",
	        "paramType": "path",
	        "defaultValue": "~",
	        "required": true,
	        "allowMultiple": false,
	        "type": "string"
	    },
	    {
	        "name": "extensionId",
	        "in": "path",
	        "notes": "",
	        "paramType": "path",
	        "defaultValue": "~",
	        "required": true,
	        "allowMultiple": false,
	        "type": "string"
	    },
	    {
	        "name": "Content-Type",
	        "in": "header",
	        "default": "multipart/mixed; boundary=Boundary_1_14413901_1361871080888",
	        "type": "string"
	    },
	    {
	        "name": "Content-Length",
	        "in": "header",
	        "default": "",
	        "type": "string"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "consumes": [
	            "multipart/mixed; boundary=Boundary_1_14413901_1361871080888"
	        ],
	        "default": "--Boundary_1_14413901_1361871080888\nContent-Type: application/json\n\n{\n  \"to\":[{\"phoneNumber\":\"18005630003\"}],\n  \"faxResolution\":\"High\",\n  \"sendTime\":\"2013-02-26T09:31:20.882Z\"\n}\n\n--Boundary_1_14413901_1361871080888\nContent-Type: text/plain\n\nHello, World!\n\n--Boundary_1_14413901_1361871080888--",
	        "type": "string"
	    }
	];
	/**
	 * Definition of options for sendSMS operation
	 */
	exports.sendSMSOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createsmsmessage.CreateSMSMessage"
	    }
	];
	/**
	 * Definition of options for listMessages operation
	 */
	exports.listMessagesOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "availability",
	        "type": "IListMessagesAvailability",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Alive",
	            "Deleted",
	            "Purged"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "IListMessagesDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "distinctConversations",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "messageType",
	        "type": "IListMessagesMessageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Fax",
	            "SMS",
	            "VoiceMail",
	            "Pager",
	            "Text"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "readStatus",
	        "type": "IListMessagesReadStatus",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Read",
	            "Unread"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadMessage operation
	 */
	exports.loadMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "number",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for updateMessage operation
	 */
	exports.updateMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "updatemessagerequest.UpdateMessageRequest"
	    }
	];
	/**
	 * Definition of options for deleteMessage operation
	 */
	exports.deleteMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "purge",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadMessageAttachment operation
	 */
	exports.loadMessageAttachmentOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "attachmentId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for syncMessages operation
	 */
	exports.syncMessagesOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ISyncMessagesDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "distinctConversations",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "messageType",
	        "type": "ISyncMessagesMessageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Fax",
	            "SMS",
	            "VoiceMail",
	            "Pager",
	            "Text"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "recordCount",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncToken",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncType",
	        "type": "ISyncMessagesSyncType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "FSync",
	            "ISync"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListMessagesAvailability) {
	    IListMessagesAvailability[IListMessagesAvailability["Alive"] = 'Alive'] = "Alive";
	    IListMessagesAvailability[IListMessagesAvailability["Deleted"] = 'Deleted'] = "Deleted";
	    IListMessagesAvailability[IListMessagesAvailability["Purged"] = 'Purged'] = "Purged";
	})(exports.IListMessagesAvailability || (exports.IListMessagesAvailability = {}));
	var IListMessagesAvailability = exports.IListMessagesAvailability;
	(function (IListMessagesDirection) {
	    IListMessagesDirection[IListMessagesDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListMessagesDirection[IListMessagesDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListMessagesDirection || (exports.IListMessagesDirection = {}));
	var IListMessagesDirection = exports.IListMessagesDirection;
	(function (IListMessagesMessageType) {
	    IListMessagesMessageType[IListMessagesMessageType["Fax"] = 'Fax'] = "Fax";
	    IListMessagesMessageType[IListMessagesMessageType["SMS"] = 'SMS'] = "SMS";
	    IListMessagesMessageType[IListMessagesMessageType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    IListMessagesMessageType[IListMessagesMessageType["Pager"] = 'Pager'] = "Pager";
	    IListMessagesMessageType[IListMessagesMessageType["Text"] = 'Text'] = "Text";
	})(exports.IListMessagesMessageType || (exports.IListMessagesMessageType = {}));
	var IListMessagesMessageType = exports.IListMessagesMessageType;
	(function (IListMessagesReadStatus) {
	    IListMessagesReadStatus[IListMessagesReadStatus["Read"] = 'Read'] = "Read";
	    IListMessagesReadStatus[IListMessagesReadStatus["Unread"] = 'Unread'] = "Unread";
	})(exports.IListMessagesReadStatus || (exports.IListMessagesReadStatus = {}));
	var IListMessagesReadStatus = exports.IListMessagesReadStatus;
	(function (ISyncMessagesDirection) {
	    ISyncMessagesDirection[ISyncMessagesDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ISyncMessagesDirection[ISyncMessagesDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ISyncMessagesDirection || (exports.ISyncMessagesDirection = {}));
	var ISyncMessagesDirection = exports.ISyncMessagesDirection;
	(function (ISyncMessagesMessageType) {
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Fax"] = 'Fax'] = "Fax";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["SMS"] = 'SMS'] = "SMS";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Pager"] = 'Pager'] = "Pager";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Text"] = 'Text'] = "Text";
	})(exports.ISyncMessagesMessageType || (exports.ISyncMessagesMessageType = {}));
	var ISyncMessagesMessageType = exports.ISyncMessagesMessageType;
	(function (ISyncMessagesSyncType) {
	    ISyncMessagesSyncType[ISyncMessagesSyncType["FSync"] = 'FSync'] = "FSync";
	    ISyncMessagesSyncType[ISyncMessagesSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.ISyncMessagesSyncType || (exports.ISyncMessagesSyncType = {}));
	var ISyncMessagesSyncType = exports.ISyncMessagesSyncType;
	
	
	/***/ },
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageattachmentinfo = __webpack_require__(79);
	var messagestorecallerinfo = __webpack_require__(80);
	var MessageInfo = (function (_super) {
	    __extends(MessageInfo, _super);
	    function MessageInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'attachments', Class: messageattachmentinfo.MessageAttachmentInfo, isArray: true, isRequired: false },
	            { property: 'availability', Class: MessageInfoAvailability, isArray: false, isRequired: false },
	            { property: 'conversationId', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'creationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'deliveryErrorCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'direction', Class: MessageInfoDirection, isArray: false, isRequired: false },
	            { property: 'faxPageCount', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'faxResolution', Class: MessageInfoFaxResolution, isArray: false, isRequired: false },
	            { property: 'from', Class: messagestorecallerinfo.MessageStoreCallerInfo, isArray: false, isRequired: false },
	            { property: 'lastModifiedTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'messageStatus', Class: MessageInfoMessageStatus, isArray: false, isRequired: false },
	            { property: 'pgToDepartment', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'priority', Class: MessageInfoPriority, isArray: false, isRequired: false },
	            { property: 'readStatus', Class: MessageInfoReadStatus, isArray: false, isRequired: false },
	            { property: 'smsDeliveryTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'smsSendingAttemptsCount', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'subject', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'to', Class: messagestorecallerinfo.MessageStoreCallerInfo, isArray: true, isRequired: false },
	            { property: 'type', Class: MessageInfoType, isArray: false, isRequired: false },
	            { property: 'vmTranscriptionStatus', Class: MessageInfoVmTranscriptionStatus, isArray: false, isRequired: false }
	        ];
	    };
	    MessageInfo.prototype.getClassName = function () {
	        return 'MessageInfo';
	    };
	    return MessageInfo;
	}(model.Model));
	exports.MessageInfo = MessageInfo;
	(function (MessageInfoAvailability) {
	    MessageInfoAvailability[MessageInfoAvailability["Alive"] = 'Alive'] = "Alive";
	    MessageInfoAvailability[MessageInfoAvailability["Deleted"] = 'Deleted'] = "Deleted";
	    MessageInfoAvailability[MessageInfoAvailability["Purged"] = 'Purged'] = "Purged";
	})(exports.MessageInfoAvailability || (exports.MessageInfoAvailability = {}));
	var MessageInfoAvailability = exports.MessageInfoAvailability;
	(function (MessageInfoDirection) {
	    MessageInfoDirection[MessageInfoDirection["Inbound"] = 'Inbound'] = "Inbound";
	    MessageInfoDirection[MessageInfoDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.MessageInfoDirection || (exports.MessageInfoDirection = {}));
	var MessageInfoDirection = exports.MessageInfoDirection;
	(function (MessageInfoFaxResolution) {
	    MessageInfoFaxResolution[MessageInfoFaxResolution["High"] = 'High'] = "High";
	    MessageInfoFaxResolution[MessageInfoFaxResolution["Low"] = 'Low'] = "Low";
	})(exports.MessageInfoFaxResolution || (exports.MessageInfoFaxResolution = {}));
	var MessageInfoFaxResolution = exports.MessageInfoFaxResolution;
	(function (MessageInfoMessageStatus) {
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Queued"] = 'Queued'] = "Queued";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Sent"] = 'Sent'] = "Sent";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Delivered"] = 'Delivered'] = "Delivered";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["DeliveryFailed"] = 'DeliveryFailed'] = "DeliveryFailed";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["SendingFailed"] = 'SendingFailed'] = "SendingFailed";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Received"] = 'Received'] = "Received";
	})(exports.MessageInfoMessageStatus || (exports.MessageInfoMessageStatus = {}));
	var MessageInfoMessageStatus = exports.MessageInfoMessageStatus;
	(function (MessageInfoPriority) {
	    MessageInfoPriority[MessageInfoPriority["Normal"] = 'Normal'] = "Normal";
	    MessageInfoPriority[MessageInfoPriority["High"] = 'High'] = "High";
	})(exports.MessageInfoPriority || (exports.MessageInfoPriority = {}));
	var MessageInfoPriority = exports.MessageInfoPriority;
	(function (MessageInfoReadStatus) {
	    MessageInfoReadStatus[MessageInfoReadStatus["Read"] = 'Read'] = "Read";
	    MessageInfoReadStatus[MessageInfoReadStatus["Unread"] = 'Unread'] = "Unread";
	})(exports.MessageInfoReadStatus || (exports.MessageInfoReadStatus = {}));
	var MessageInfoReadStatus = exports.MessageInfoReadStatus;
	(function (MessageInfoType) {
	    MessageInfoType[MessageInfoType["Fax"] = 'Fax'] = "Fax";
	    MessageInfoType[MessageInfoType["SMS"] = 'SMS'] = "SMS";
	    MessageInfoType[MessageInfoType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    MessageInfoType[MessageInfoType["Pager"] = 'Pager'] = "Pager";
	    MessageInfoType[MessageInfoType["Text"] = 'Text'] = "Text";
	})(exports.MessageInfoType || (exports.MessageInfoType = {}));
	var MessageInfoType = exports.MessageInfoType;
	(function (MessageInfoVmTranscriptionStatus) {
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["NotAvailable"] = 'NotAvailable'] = "NotAvailable";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["InProgress"] = 'InProgress'] = "InProgress";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["TimedOut"] = 'TimedOut'] = "TimedOut";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["Completed"] = 'Completed'] = "Completed";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["CompletedPartially"] = 'CompletedPartially'] = "CompletedPartially";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["Failed"] = 'Failed'] = "Failed";
	})(exports.MessageInfoVmTranscriptionStatus || (exports.MessageInfoVmTranscriptionStatus = {}));
	var MessageInfoVmTranscriptionStatus = exports.MessageInfoVmTranscriptionStatus;
	
	
	/***/ },
	/* 79 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessageAttachmentInfo = (function (_super) {
	    __extends(MessageAttachmentInfo, _super);
	    function MessageAttachmentInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageAttachmentInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: MessageAttachmentInfoType, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'vmDuration', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    MessageAttachmentInfo.prototype.getClassName = function () {
	        return 'MessageAttachmentInfo';
	    };
	    return MessageAttachmentInfo;
	}(model.Model));
	exports.MessageAttachmentInfo = MessageAttachmentInfo;
	(function (MessageAttachmentInfoType) {
	    MessageAttachmentInfoType[MessageAttachmentInfoType["AudioRecording"] = 'AudioRecording'] = "AudioRecording";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["AudioTranscription"] = 'AudioTranscription'] = "AudioTranscription";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["Text"] = 'Text'] = "Text";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["SourceDocument"] = 'SourceDocument'] = "SourceDocument";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["RenderedDocument"] = 'RenderedDocument'] = "RenderedDocument";
	})(exports.MessageAttachmentInfoType || (exports.MessageAttachmentInfoType = {}));
	var MessageAttachmentInfoType = exports.MessageAttachmentInfoType;
	
	
	/***/ },
	/* 80 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessageStoreCallerInfo = (function (_super) {
	    __extends(MessageStoreCallerInfo, _super);
	    function MessageStoreCallerInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageStoreCallerInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'messageStatus', Class: MessageStoreCallerInfoMessageStatus, isArray: false, isRequired: false },
	            { property: 'faxErrorCode', Class: MessageStoreCallerInfoFaxErrorCode, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    MessageStoreCallerInfo.prototype.getClassName = function () {
	        return 'MessageStoreCallerInfo';
	    };
	    return MessageStoreCallerInfo;
	}(model.Model));
	exports.MessageStoreCallerInfo = MessageStoreCallerInfo;
	(function (MessageStoreCallerInfoMessageStatus) {
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Queued"] = 'Queued'] = "Queued";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Sent"] = 'Sent'] = "Sent";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Delivered"] = 'Delivered'] = "Delivered";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["DeliveryFailed"] = 'DeliveryFailed'] = "DeliveryFailed";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["SendingFailed"] = 'SendingFailed'] = "SendingFailed";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Received"] = 'Received'] = "Received";
	})(exports.MessageStoreCallerInfoMessageStatus || (exports.MessageStoreCallerInfoMessageStatus = {}));
	var MessageStoreCallerInfoMessageStatus = exports.MessageStoreCallerInfoMessageStatus;
	(function (MessageStoreCallerInfoFaxErrorCode) {
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["Undefined"] = 'Undefined'] = "Undefined";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoFaxSendPermission"] = 'NoFaxSendPermission'] = "NoFaxSendPermission";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoInternationalPermission"] = 'NoInternationalPermission'] = "NoInternationalPermission";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoFaxMachine"] = 'NoFaxMachine'] = "NoFaxMachine";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["OutgoingCallError"] = 'OutgoingCallError'] = "OutgoingCallError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["RenderingFailed"] = 'RenderingFailed'] = "RenderingFailed";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["TooManyPages"] = 'TooManyPages'] = "TooManyPages";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ReturnToDBQueue"] = 'ReturnToDBQueue'] = "ReturnToDBQueue";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoCallTime"] = 'NoCallTime'] = "NoCallTime";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["WrongNumber"] = 'WrongNumber'] = "WrongNumber";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ProhibitedNumber"] = 'ProhibitedNumber'] = "ProhibitedNumber";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["InternalError"] = 'InternalError'] = "InternalError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["FaxSendingProhibited"] = 'FaxSendingProhibited'] = "FaxSendingProhibited";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ThePhoneIsBlacklisted"] = 'ThePhoneIsBlacklisted'] = "ThePhoneIsBlacklisted";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["UserNotFound"] = 'UserNotFound'] = "UserNotFound";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ConvertError"] = 'ConvertError'] = "ConvertError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["DBGeneralError"] = 'DBGeneralError'] = "DBGeneralError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["SkypeBillingFailed"] = 'SkypeBillingFailed'] = "SkypeBillingFailed";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["AccountSuspended"] = 'AccountSuspended'] = "AccountSuspended";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ProhibitedDestination"] = 'ProhibitedDestination'] = "ProhibitedDestination";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	})(exports.MessageStoreCallerInfoFaxErrorCode || (exports.MessageStoreCallerInfoFaxErrorCode = {}));
	var MessageStoreCallerInfoFaxErrorCode = exports.MessageStoreCallerInfoFaxErrorCode;
	
	
	/***/ },
	/* 81 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageinfo = __webpack_require__(78);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var MessageList = (function (_super) {
	    __extends(MessageList, _super);
	    function MessageList() {
	        _super.apply(this, arguments);
	    }
	    MessageList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: messageinfo.MessageInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MessageList.prototype.getClassName = function () {
	        return 'MessageList';
	    };
	    return MessageList;
	}(model.Model));
	exports.MessageList = MessageList;
	
	
	/***/ },
	/* 82 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageinfo = __webpack_require__(78);
	var messagessyncinfo = __webpack_require__(83);
	var MessageSync = (function (_super) {
	    __extends(MessageSync, _super);
	    function MessageSync() {
	        _super.apply(this, arguments);
	    }
	    MessageSync.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: messageinfo.MessageInfo, isArray: true, isRequired: true },
	            { property: 'syncInfo', Class: messagessyncinfo.MessagesSyncInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MessageSync.prototype.getClassName = function () {
	        return 'MessageSync';
	    };
	    return MessageSync;
	}(model.Model));
	exports.MessageSync = MessageSync;
	
	
	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessagesSyncInfo = (function (_super) {
	    __extends(MessagesSyncInfo, _super);
	    function MessagesSyncInfo() {
	        _super.apply(this, arguments);
	    }
	    MessagesSyncInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'syncType', Class: MessagesSyncInfoSyncType, isArray: false, isRequired: false },
	            { property: 'syncToken', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'syncTime', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    MessagesSyncInfo.prototype.getClassName = function () {
	        return 'MessagesSyncInfo';
	    };
	    return MessagesSyncInfo;
	}(model.Model));
	exports.MessagesSyncInfo = MessagesSyncInfo;
	(function (MessagesSyncInfoSyncType) {
	    MessagesSyncInfoSyncType[MessagesSyncInfoSyncType["FSync"] = 'FSync'] = "FSync";
	    MessagesSyncInfoSyncType[MessagesSyncInfoSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.MessagesSyncInfoSyncType || (exports.MessagesSyncInfoSyncType = {}));
	var MessagesSyncInfoSyncType = exports.MessagesSyncInfoSyncType;
	
	
	/***/ },
	/* 84 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var getsubscriptioninforesponse = __webpack_require__(85);
	var NotificationsSubscriptionAPI = (function (_super) {
	    __extends(NotificationsSubscriptionAPI, _super);
	    function NotificationsSubscriptionAPI() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Subscription
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>Creates a new subscription. To call this method with APNS transport type you have to specify endpoint_id attribute in get token request at authorization.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.create = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/subscription', options, exports.createOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Get Subscription
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>Returns the requested subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Light</p>
	     */
	    NotificationsSubscriptionAPI.prototype.load = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.loadOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Renew Subscription / Modify Event Filters
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>With empty request body - renews the existent subscription. If event filters specified - modifies the event filters for the existing subscription. The client application can extend or narrow the events for which it receives notifications in the frame
	     *     of one subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.update = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.updateOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Cancel Subscription
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Cancels the existent subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.remove = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.removeOptions), null);
	    };
	    return NotificationsSubscriptionAPI;
	}(client.Client));
	exports.NotificationsSubscriptionAPI = NotificationsSubscriptionAPI;
	/**
	 * Definition of options for create operation
	 */
	exports.createOptions = [
	    {
	        "name": "body",
	        "type": "createsubscriptionrequest.CreateSubscriptionRequest",
	        "in": "body",
	        "required": true
	    }
	];
	/**
	 * Definition of options for load operation
	 */
	exports.loadOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for update operation
	 */
	exports.updateOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "type": "modifysubscriptionrequest.ModifySubscriptionRequest",
	        "in": "body",
	        "required": true
	    }
	];
	/**
	 * Definition of options for remove operation
	 */
	exports.removeOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var notificationdeliverymode = __webpack_require__(86);
	var GetSubscriptionInfoResponse = (function (_super) {
	    __extends(GetSubscriptionInfoResponse, _super);
	    function GetSubscriptionInfoResponse() {
	        _super.apply(this, arguments);
	    }
	    GetSubscriptionInfoResponse.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'eventFilters', Class: null /* string[] */, isArray: true, isRequired: false },
	            { property: 'expirationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'expiresIn', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'status', Class: GetSubscriptionInfoResponseStatus, isArray: false, isRequired: false },
	            { property: 'creationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'deliveryMode', Class: notificationdeliverymode.NotificationDeliveryMode, isArray: false, isRequired: true }
	        ];
	    };
	    GetSubscriptionInfoResponse.prototype.getClassName = function () {
	        return 'GetSubscriptionInfoResponse';
	    };
	    return GetSubscriptionInfoResponse;
	}(model.Model));
	exports.GetSubscriptionInfoResponse = GetSubscriptionInfoResponse;
	(function (GetSubscriptionInfoResponseStatus) {
	    GetSubscriptionInfoResponseStatus[GetSubscriptionInfoResponseStatus["Active"] = 'Active'] = "Active";
	    GetSubscriptionInfoResponseStatus[GetSubscriptionInfoResponseStatus["Suspended"] = 'Suspended'] = "Suspended";
	})(exports.GetSubscriptionInfoResponseStatus || (exports.GetSubscriptionInfoResponseStatus = {}));
	var GetSubscriptionInfoResponseStatus = exports.GetSubscriptionInfoResponseStatus;
	
	
	/***/ },
	/* 86 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var NotificationDeliveryMode = (function (_super) {
	    __extends(NotificationDeliveryMode, _super);
	    function NotificationDeliveryMode() {
	        _super.apply(this, arguments);
	    }
	    NotificationDeliveryMode.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'transportType', Class: NotificationDeliveryModeTransportType, isArray: false, isRequired: true },
	            { property: 'encryption', Class: null /* boolean */, isArray: false, isRequired: true },
	            { property: 'address', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'subscriberKey', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'encryptionAlgorithm', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'encryptionKey', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'registrationId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'certificateName', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    NotificationDeliveryMode.prototype.getClassName = function () {
	        return 'NotificationDeliveryMode';
	    };
	    return NotificationDeliveryMode;
	}(model.Model));
	exports.NotificationDeliveryMode = NotificationDeliveryMode;
	(function (NotificationDeliveryModeTransportType) {
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["PubNub"] = 'PubNub'] = "PubNub";
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["APNS"] = 'APNS'] = "APNS";
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType['PubNub/APNS/VoIP'] = 'PubNub/APNS/VoIP'] = 'PubNub/APNS/VoIP';
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["WebHook"] = 'WebHook'] = "WebHook";
	})(exports.NotificationDeliveryModeTransportType || (exports.NotificationDeliveryModeTransportType = {}));
	var NotificationDeliveryModeTransportType = exports.NotificationDeliveryModeTransportType;
	
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var presenceinfo = __webpack_require__(88);
	var monitoredextensions = __webpack_require__(90);
	var Presence = (function (_super) {
	    __extends(Presence, _super);
	    function Presence() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension(s) Presence Status by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns presence status of an extension or several extensions by their ID(s). Batch request is supported, see Batch Requests for details.The presenceStatus is returned as Offline (the parameters telephonyStatus, message, userStatus and dndStatus are not
	     *     returned at all) for the following extension types: Department/Announcement Only/Take Messages Only (Voicemail)/Fax User/Paging Only Group/Shared Lines Group/IVR Menu/Application Extension/Park Location.If the user requests his/her own presence status,
	     *     the response contains actual presence status even if the status publication is turned off.Batch request is supported. For batch requests the number of extensions in one request is limited to 30. If more extensions are included in the request, the
	     *     error code 400 Bad Request is returned with the logical error code InvalidMultipartRequest and the corresponding message 'Extension Presence Info multipart request is limited to 30 extensions'.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadPresence</td>
	     *             <td>Getting user presence information</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Presence.prototype.getPresenceStatus = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/presence', options, exports.getPresenceStatusOptions), presenceinfo.PresenceInfo);
	    };
	    /**
	     * Get Monitored Extensions
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns list of lines - extensions which presence status can be indicated and monitored on BLF-enabled (Busy Lamp Field) devices.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadPresence</td>
	     *             <td>Getting user presence information</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Presence.prototype.listMonitoredExtensions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/presence/line', options, exports.listMonitoredExtensionsOptions), monitoredextensions.MonitoredExtensions);
	    };
	    return Presence;
	}(client.Client));
	exports.Presence = Presence;
	/**
	 * Definition of options for getPresenceStatus operation
	 */
	exports.getPresenceStatusOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listMonitoredExtensions operation
	 */
	exports.listMonitoredExtensionsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	
	
	/***/ },
	/* 88 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var presenceextensioninfo = __webpack_require__(89);
	var PresenceInfo = (function (_super) {
	    __extends(PresenceInfo, _super);
	    function PresenceInfo() {
	        _super.apply(this, arguments);
	    }
	    PresenceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'allowSeeMyPresence', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'dndStatus', Class: PresenceInfoDndStatus, isArray: false, isRequired: false },
	            { property: 'extension', Class: presenceextensioninfo.PresenceExtensionInfo, isArray: false, isRequired: false },
	            { property: 'message', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'pickUpCallsOnHold', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'presenceStatus', Class: PresenceInfoPresenceStatus, isArray: false, isRequired: false },
	            { property: 'ringOnMonitoredCall', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'telephonyStatus', Class: PresenceInfoTelephonyStatus, isArray: false, isRequired: false },
	            { property: 'userStatus', Class: PresenceInfoUserStatus, isArray: false, isRequired: false }
	        ];
	    };
	    PresenceInfo.prototype.getClassName = function () {
	        return 'PresenceInfo';
	    };
	    return PresenceInfo;
	}(model.Model));
	exports.PresenceInfo = PresenceInfo;
	(function (PresenceInfoDndStatus) {
	    PresenceInfoDndStatus[PresenceInfoDndStatus["TakeAllCalls"] = 'TakeAllCalls'] = "TakeAllCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["DoNotAcceptAnyCalls"] = 'DoNotAcceptAnyCalls'] = "DoNotAcceptAnyCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["DoNotAcceptDepartmentCalls"] = 'DoNotAcceptDepartmentCalls'] = "DoNotAcceptDepartmentCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["TakeDepartmentCallsOnly"] = 'TakeDepartmentCallsOnly'] = "TakeDepartmentCallsOnly";
	})(exports.PresenceInfoDndStatus || (exports.PresenceInfoDndStatus = {}));
	var PresenceInfoDndStatus = exports.PresenceInfoDndStatus;
	(function (PresenceInfoPresenceStatus) {
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Offline"] = 'Offline'] = "Offline";
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Busy"] = 'Busy'] = "Busy";
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Available"] = 'Available'] = "Available";
	})(exports.PresenceInfoPresenceStatus || (exports.PresenceInfoPresenceStatus = {}));
	var PresenceInfoPresenceStatus = exports.PresenceInfoPresenceStatus;
	(function (PresenceInfoTelephonyStatus) {
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["NoCall"] = 'NoCall'] = "NoCall";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["CallConnected"] = 'CallConnected'] = "CallConnected";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["Ringing"] = 'Ringing'] = "Ringing";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["OnHold"] = 'OnHold'] = "OnHold";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["ParkedCall"] = 'ParkedCall'] = "ParkedCall";
	})(exports.PresenceInfoTelephonyStatus || (exports.PresenceInfoTelephonyStatus = {}));
	var PresenceInfoTelephonyStatus = exports.PresenceInfoTelephonyStatus;
	(function (PresenceInfoUserStatus) {
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Offline"] = 'Offline'] = "Offline";
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Busy"] = 'Busy'] = "Busy";
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Available"] = 'Available'] = "Available";
	})(exports.PresenceInfoUserStatus || (exports.PresenceInfoUserStatus = {}));
	var PresenceInfoUserStatus = exports.PresenceInfoUserStatus;
	
	
	/***/ },
	/* 89 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PresenceExtensionInfo = (function (_super) {
	    __extends(PresenceExtensionInfo, _super);
	    function PresenceExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    PresenceExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    PresenceExtensionInfo.prototype.getClassName = function () {
	        return 'PresenceExtensionInfo';
	    };
	    return PresenceExtensionInfo;
	}(model.Model));
	exports.PresenceExtensionInfo = PresenceExtensionInfo;
	
	
	/***/ },
	/* 90 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var lineinfo = __webpack_require__(91);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var MonitoredExtensions = (function (_super) {
	    __extends(MonitoredExtensions, _super);
	    function MonitoredExtensions() {
	        _super.apply(this, arguments);
	    }
	    MonitoredExtensions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'records', Class: lineinfo.LineInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MonitoredExtensions.prototype.getClassName = function () {
	        return 'MonitoredExtensions';
	    };
	    return MonitoredExtensions;
	}(model.Model));
	exports.MonitoredExtensions = MonitoredExtensions;
	
	
	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var monitoredlinesextensioninfo = __webpack_require__(92);
	var LineInfo = (function (_super) {
	    __extends(LineInfo, _super);
	    function LineInfo() {
	        _super.apply(this, arguments);
	    }
	    LineInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extension', Class: monitoredlinesextensioninfo.MonitoredLinesExtensionInfo, isArray: false, isRequired: false }
	        ];
	    };
	    LineInfo.prototype.getClassName = function () {
	        return 'LineInfo';
	    };
	    return LineInfo;
	}(model.Model));
	exports.LineInfo = LineInfo;
	
	
	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MonitoredLinesExtensionInfo = (function (_super) {
	    __extends(MonitoredLinesExtensionInfo, _super);
	    function MonitoredLinesExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    MonitoredLinesExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: MonitoredLinesExtensionInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    MonitoredLinesExtensionInfo.prototype.getClassName = function () {
	        return 'MonitoredLinesExtensionInfo';
	    };
	    return MonitoredLinesExtensionInfo;
	}(model.Model));
	exports.MonitoredLinesExtensionInfo = MonitoredLinesExtensionInfo;
	(function (MonitoredLinesExtensionInfoType) {
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["User"] = 'User'] = "User";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["Department"] = 'Department'] = "Department";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.MonitoredLinesExtensionInfoType || (exports.MonitoredLinesExtensionInfoType = {}));
	var MonitoredLinesExtensionInfoType = exports.MonitoredLinesExtensionInfoType;
	
	
	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var ringoutstatus = __webpack_require__(94);
	var RingOut = (function (_super) {
	    __extends(RingOut, _super);
	    function RingOut() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Make RingOut Call
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Makes a 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    RingOut.prototype.makeRingOutCall = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout', options, exports.makeRingOutCallOptions), ringoutstatus.RingOutStatus);
	    };
	    /**
	     * Get Status of RingOut Call
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Returns the status of a 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    RingOut.prototype.getRingOutCallStatus = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout/{ringoutId}', options, exports.getRingOutCallStatusOptions), ringoutstatus.RingOutStatus);
	    };
	    /**
	     * Cancel RingOut Call
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Cancels the 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    RingOut.prototype.cancelRingOutCall = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout/{ringoutId}', options, exports.cancelRingOutCallOptions), null);
	    };
	    return RingOut;
	}(client.Client));
	exports.RingOut = RingOut;
	/**
	 * Definition of options for makeRingOutCall operation
	 */
	exports.makeRingOutCallOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "makeringoutrequest.MakeRingOutRequest"
	    }
	];
	/**
	 * Definition of options for getRingOutCallStatus operation
	 */
	exports.getRingOutCallStatusOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "ringoutId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for cancelRingOutCall operation
	 */
	exports.cancelRingOutCallOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "ringoutId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 94 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ringoutstatusinfo = __webpack_require__(95);
	var RingOutStatus = (function (_super) {
	    __extends(RingOutStatus, _super);
	    function RingOutStatus() {
	        _super.apply(this, arguments);
	    }
	    RingOutStatus.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'status', Class: ringoutstatusinfo.RingOutStatusInfo, isArray: false, isRequired: false }
	        ];
	    };
	    RingOutStatus.prototype.getClassName = function () {
	        return 'RingOutStatus';
	    };
	    return RingOutStatus;
	}(model.Model));
	exports.RingOutStatus = RingOutStatus;
	
	
	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var RingOutStatusInfo = (function (_super) {
	    __extends(RingOutStatusInfo, _super);
	    function RingOutStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    RingOutStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'callStatus', Class: RingOutStatusInfoCallStatus, isArray: false, isRequired: false },
	            { property: 'callerStatus', Class: RingOutStatusInfoCallerStatus, isArray: false, isRequired: false },
	            { property: 'calleeStatus', Class: RingOutStatusInfoCalleeStatus, isArray: false, isRequired: false }
	        ];
	    };
	    RingOutStatusInfo.prototype.getClassName = function () {
	        return 'RingOutStatusInfo';
	    };
	    return RingOutStatusInfo;
	}(model.Model));
	exports.RingOutStatusInfo = RingOutStatusInfo;
	(function (RingOutStatusInfoCallStatus) {
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCallStatus || (exports.RingOutStatusInfoCallStatus = {}));
	var RingOutStatusInfoCallStatus = exports.RingOutStatusInfoCallStatus;
	(function (RingOutStatusInfoCallerStatus) {
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCallerStatus || (exports.RingOutStatusInfoCallerStatus = {}));
	var RingOutStatusInfoCallerStatus = exports.RingOutStatusInfoCallerStatus;
	(function (RingOutStatusInfoCalleeStatus) {
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCalleeStatus || (exports.RingOutStatusInfoCalleeStatus = {}));
	var RingOutStatusInfoCalleeStatus = exports.RingOutStatusInfoCalleeStatus;
	
	
	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var extensionforwardingnumberlist = __webpack_require__(97);
	var forwardingnumberinfo = __webpack_require__(98);
	var ForwardingNumbers = (function (_super) {
	    __extends(ForwardingNumbers, _super);
	    function ForwardingNumbers() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension Forwarding Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Returns the list of extension phone numbers used for call forwarding and call flip. The returned list contains all the extension phone numbers that are used for call forwarding and call flip.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    ForwardingNumbers.prototype.listExtensionForwardingNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number', options, exports.listExtensionForwardingNumbersOptions), extensionforwardingnumberlist.ExtensionForwardingNumberList);
	    };
	    /**
	     * Create Forwarding Number
	     *
	     * <p style='font-style:italic;'>Since 1.0.12 (Release 6.4)</p>
	     * <p>Adds a new forwarding number to the forwarding number list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.createExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number', options, exports.createExtensionForwardingNumberOptions), forwardingnumberinfo.ForwardingNumberInfo);
	    };
	    /**
	     * Update Forwarding Number by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.24 (Release 8.0)</p>
	     * <p>Updates an existent forwarding number from the forwarding number list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.updateExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number/{forwardingNumberId}', options, exports.updateExtensionForwardingNumberOptions), forwardingnumberinfo.ForwardingNumberInfo);
	    };
	    /**
	     * Delete Forwarding Number by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.24 (Release 8.0)</p>
	     * <p>Deletes a forwarding number from the forwarding number list by its ID.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.deleteExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number/{forwardingNumberId}', options, exports.deleteExtensionForwardingNumberOptions), null);
	    };
	    return ForwardingNumbers;
	}(client.Client));
	exports.ForwardingNumbers = ForwardingNumbers;
	/**
	 * Definition of options for listExtensionForwardingNumbers operation
	 */
	exports.listExtensionForwardingNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for createExtensionForwardingNumber operation
	 */
	exports.createExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createforwardingnumberrequest.CreateForwardingNumberRequest"
	    }
	];
	/**
	 * Definition of options for updateExtensionForwardingNumber operation
	 */
	exports.updateExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "forwardingNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "updateforwardingnumberrequest.UpdateForwardingNumberRequest"
	    }
	];
	/**
	 * Definition of options for deleteExtensionForwardingNumber operation
	 */
	exports.deleteExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "forwardingNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 97 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var forwardingnumberinfo = __webpack_require__(98);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionForwardingNumberList = (function (_super) {
	    __extends(ExtensionForwardingNumberList, _super);
	    function ExtensionForwardingNumberList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionForwardingNumberList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: forwardingnumberinfo.ForwardingNumberInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: false },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionForwardingNumberList.prototype.getClassName = function () {
	        return 'ExtensionForwardingNumberList';
	    };
	    return ExtensionForwardingNumberList;
	}(model.Model));
	exports.ExtensionForwardingNumberList = ExtensionForwardingNumberList;
	
	
	/***/ },
	/* 98 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ForwardingNumberInfo = (function (_super) {
	    __extends(ForwardingNumberInfo, _super);
	    function ForwardingNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    ForwardingNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'label', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'features', Class: ForwardingNumberInfoFeatures, isArray: false, isRequired: false },
	            { property: 'flipNumber', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    ForwardingNumberInfo.prototype.getClassName = function () {
	        return 'ForwardingNumberInfo';
	    };
	    return ForwardingNumberInfo;
	}(model.Model));
	exports.ForwardingNumberInfo = ForwardingNumberInfo;
	(function (ForwardingNumberInfoFeatures) {
	    ForwardingNumberInfoFeatures[ForwardingNumberInfoFeatures["CallFlip"] = 'CallFlip'] = "CallFlip";
	    ForwardingNumberInfoFeatures[ForwardingNumberInfoFeatures["CallForwarding"] = 'CallForwarding'] = "CallForwarding";
	})(exports.ForwardingNumberInfoFeatures || (exports.ForwardingNumberInfoFeatures = {}));
	var ForwardingNumberInfoFeatures = exports.ForwardingNumberInfoFeatures;
	
	
	/***/ },
	/* 99 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var blockednumberinfo = __webpack_require__(100);
	var blockednumberslist = __webpack_require__(101);
	var BlockedNumbers = (function (_super) {
	    __extends(BlockedNumbers, _super);
	    function BlockedNumbers() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Add Blocked Number
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.blockNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number', options, exports.blockNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Get Blocked Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers which are specified by the user to block inbound calls and SMS messages.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    BlockedNumbers.prototype.listBlockedNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number', options, exports.listBlockedNumbersOptions), blockednumberslist.BlockedNumbersList);
	    };
	    /**
	     * Get Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    BlockedNumbers.prototype.loadBlockedNumber = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.loadBlockedNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Update Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.updateBlockedNumber = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.updateBlockedNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Delete Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.unblockNumber = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.unblockNumberOptions), null);
	    };
	    return BlockedNumbers;
	}(client.Client));
	exports.BlockedNumbers = BlockedNumbers;
	/**
	 * Definition of options for blockNumber operation
	 */
	exports.blockNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listBlockedNumbers operation
	 */
	exports.listBlockedNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadBlockedNumber operation
	 */
	exports.loadBlockedNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for updateBlockedNumber operation
	 */
	exports.updateBlockedNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for unblockNumber operation
	 */
	exports.unblockNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 100 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BlockedNumberInfo = (function (_super) {
	    __extends(BlockedNumberInfo, _super);
	    function BlockedNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    BlockedNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    BlockedNumberInfo.prototype.getClassName = function () {
	        return 'BlockedNumberInfo';
	    };
	    return BlockedNumberInfo;
	}(model.Model));
	exports.BlockedNumberInfo = BlockedNumberInfo;
	
	
	/***/ },
	/* 101 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var blockednumberinfo = __webpack_require__(100);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var BlockedNumbersList = (function (_super) {
	    __extends(BlockedNumbersList, _super);
	    function BlockedNumbersList() {
	        _super.apply(this, arguments);
	    }
	    BlockedNumbersList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: blockednumberinfo.BlockedNumberInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    BlockedNumbersList.prototype.getClassName = function () {
	        return 'BlockedNumbersList';
	    };
	    return BlockedNumbersList;
	}(model.Model));
	exports.BlockedNumbersList = BlockedNumbersList;
	
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=ringcentral-client.js.map

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _reduxHelper = __webpack_require__(136);
	
	var _eventEmitter = __webpack_require__(137);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['store', 'mapper', 'prefix', 'actions', 'emitter']);
	
	/**
	 * @function
	 * @param {Object} state
	 * @return {Object}
	 * @description Default reducer if module does not has its own reducer.
	 */
	function defaultReducer(state) {
	  if (typeof state === 'undefined') return {};
	  return state;
	}
	/**
	 * @function
	 * @param {Object} state
	 * @return {Object}
	 * @description Default parent state to module state mapper.
	 */
	function defaultMapper(state) {
	  return state;
	}
	
	/**
	 * @class
	 * @default
	 * @description Base module class.
	 */
	
	var RcModule = function () {
	  /**
	   * @constructor
	   */
	
	  function RcModule(_ref) {
	    var _this = this;
	
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var _ref$stateMapper = _ref.stateMapper;
	    var stateMapper = _ref$stateMapper === undefined ? defaultMapper : _ref$stateMapper;
	    var prefix = _ref.prefix;
	    var actions = _ref.actions;
	    (0, _classCallCheck3.default)(this, RcModule);
	
	    // Extending EventEmitter breaks some mechanic, so we wire emitter up like this instead.
	    this[symbols.emitter] = new _eventEmitter2.default();
	    this[symbols.mapper] = stateMapper;
	    this[symbols.prefix] = prefix;
	    this[symbols.actions] = actions && (0, _reduxHelper.prefixActions)(actions, prefix);
	    registerStoreHandler(function (store) {
	      _this[symbols.store] = store;
	    });
	  }
	
	  /**
	   * @function
	   * @param {String} event
	   * @param {Function} handler
	   * @return {Function} Unregister function.
	   */
	
	
	  (0, _createClass3.default)(RcModule, [{
	    key: 'on',
	    value: function on(event, handler) {
	      var _this2 = this;
	
	      this[symbols.emitter].on(event, handler);
	      return function () {
	        _this2[symbols.emitter].off(event, handler);
	      };
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {Function)} handler
	     * @return {Function} Unregister function.
	     */
	
	  }, {
	    key: 'once',
	    value: function once(event, handler) {
	      var _this3 = this;
	
	      this[symbols.emitter].once(event, handler);
	      return function () {
	        _this3[symbols.emitter].off(event, handler);
	      };
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {...args} args
	     */
	
	  }, {
	    key: 'emit',
	    value: function emit(event) {
	      var _symbols$emitter;
	
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      (_symbols$emitter = this[symbols.emitter]).emit.apply(_symbols$emitter, [event].concat(args));
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {Function} handler
	     */
	
	  }, {
	    key: 'off',
	    value: function off(event, handler) {
	      this[symbols.emitter].off(event, handler);
	    }
	  }, {
	    key: 'state',
	    get: function get() {
	      return this[symbols.mapper](this[symbols.store].getState());
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return defaultReducer;
	    }
	  }, {
	    key: 'store',
	    get: function get() {
	      return this[symbols.store];
	    }
	  }, {
	    key: 'prefix',
	    get: function get() {
	      return this[symbols.prefix];
	    }
	  }, {
	    key: 'actions',
	    get: function get() {
	      return this[symbols.actions];
	    }
	  }]);
	  return RcModule;
	}();
	
	exports.default = RcModule;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class
	 * @description Helper class for creating a symbol mapping
	 */
	
	var SymbolMap = function (_Enum) {
	  (0, _inherits3.default)(SymbolMap, _Enum);
	
	  /**
	   * @constructor
	   * @param {String[]} keys
	   */
	
	  function SymbolMap(keys) {
	    (0, _classCallCheck3.default)(this, SymbolMap);
	
	    var definition = {};
	    keys.forEach(function (key) {
	      definition[key] = (0, _symbol2.default)();
	    });
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(SymbolMap).call(this, definition));
	  }
	
	  return SymbolMap;
	}(_enum2.default);
	
	exports.default = SymbolMap;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasOwnProperty = {}.hasOwnProperty;
	var DEFINITION = (0, _symbol2.default)();
	var VALUES = (0, _symbol2.default)();
	
	var Enum = function () {
	  function Enum(definition) {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, Enum);
	
	    this[DEFINITION] = (0, _assign2.default)({}, definition);
	    this[VALUES] = new _set2.default();
	
	    var _loop = function _loop(key) {
	      if (hasOwnProperty.call(definition, key)) {
	        (0, _defineProperty2.default)(_this, key, {
	          get: function get() {
	            return this[DEFINITION][key];
	          },
	
	          enumerable: true
	        });
	        _this[VALUES].add(_this[DEFINITION][key]);
	      }
	    };
	
	    for (var key in definition) {
	      _loop(key);
	    }
	  }
	
	  (0, _createClass3.default)(Enum, null, [{
	    key: "hasValue",
	    value: function hasValue(value) {
	      return this[VALUES].has(value);
	    }
	  }]);
	  return Enum;
	}();
	
	/*
	 * //with Proxy support
	 *const enumHandler = {
	 *  get(target, key) {
	 *    return target[key];
	 *  },
	 *  set() {
	 *    return;
	 *  }
	 *};
	 *Enum = class Enum extends Proxy {
	 *  constructor(definition) {
	 *    super(Object.assign({}, definition), enumHandler);
	 *  }
	 *}
	 */
	
	
	exports.default = Enum;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ActionMap = undefined;
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	exports.prefixActions = prefixActions;
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * @class
	 * @description helper class for creating redux action definition maps
	 */
	
	var ActionMap = exports.ActionMap = function (_Enum) {
	  (0, _inherits3.default)(ActionMap, _Enum);
	
	  /**
	   * @constructor
	   * @param {String[]} actions - list of action strings
	   * @extends Enum
	   */
	
	  function ActionMap() {
	    var actions = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
	    (0, _classCallCheck3.default)(this, ActionMap);
	
	    var definition = {};
	    actions.forEach(function (action) {
	      definition[action] = prefix !== '' ? prefix + '-' + action : action;
	    });
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ActionMap).call(this, definition));
	  }
	
	  return ActionMap;
	}(_enum2.default);
	
	/**
	 * @function
	 * @description helper function to return a prefixed action definition maps
	 */
	
	
	function prefixActions(actions, prefix) {
	  if (!prefix || prefix === '') return actions;
	  var definition = {};
	  for (var action in actions) {
	    if (hasOwnProperty.call(actions, action)) {
	      definition[action] = prefix + '-' + action;
	    }
	  }
	  return new _enum2.default(definition);
	}

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var d        = __webpack_require__(138)
	  , callable = __webpack_require__(151)
	
	  , apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }
	
	  , on, once, off, emit, methods, descriptors, base;
	
	on = function (type, listener) {
		var data;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];
	
		return this;
	};
	
	once = function (type, listener) {
		var once, self;
	
		callable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});
	
		once.__eeOnceListener__ = listener;
		return this;
	};
	
	off = function (type, listener) {
		var data, listeners, candidate, i;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];
	
		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}
	
		return this;
	};
	
	emit = function (type) {
		var i, l, listener, listeners, args;
	
		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;
	
		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];
	
			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};
	
	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};
	
	descriptors = {
		on: d(on),
		once: d(once),
		off: d(off),
		emit: d(emit)
	};
	
	base = defineProperties({}, descriptors);
	
	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign        = __webpack_require__(139)
	  , normalizeOpts = __webpack_require__(146)
	  , isCallable    = __webpack_require__(147)
	  , contains      = __webpack_require__(148)
	
	  , d;
	
	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}
	
		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};
	
	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}
	
		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(140)()
		? Object.assign
		: __webpack_require__(141);


/***/ },
/* 140 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== 'function') return false;
		obj = { foo: 'raz' };
		assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
		return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var keys  = __webpack_require__(142)
	  , value = __webpack_require__(145)
	
	  , max = Math.max;
	
	module.exports = function (dest, src/*, …srcn*/) {
		var error, i, l = max(arguments.length, 2), assign;
		dest = Object(value(dest));
		assign = function (key) {
			try { dest[key] = src[key]; } catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < l; ++i) {
			src = arguments[i];
			keys(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(143)()
		? Object.keys
		: __webpack_require__(144);


/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		try {
			Object.keys('primitive');
			return true;
		} catch (e) { return false; }
	};


/***/ },
/* 144 */
/***/ function(module, exports) {

	'use strict';
	
	var keys = Object.keys;
	
	module.exports = function (object) {
		return keys(object == null ? object : Object(object));
	};


/***/ },
/* 145 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (value) {
		if (value == null) throw new TypeError("Cannot use null or undefined");
		return value;
	};


/***/ },
/* 146 */
/***/ function(module, exports) {

	'use strict';
	
	var forEach = Array.prototype.forEach, create = Object.create;
	
	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};
	
	module.exports = function (options/*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (options == null) return;
			process(Object(options), result);
		});
		return result;
	};


/***/ },
/* 147 */
/***/ function(module, exports) {

	// Deprecated
	
	'use strict';
	
	module.exports = function (obj) { return typeof obj === 'function'; };


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(149)()
		? String.prototype.contains
		: __webpack_require__(150);


/***/ },
/* 149 */
/***/ function(module, exports) {

	'use strict';
	
	var str = 'razdwatrzy';
	
	module.exports = function () {
		if (typeof str.contains !== 'function') return false;
		return ((str.contains('dwa') === true) && (str.contains('foo') === false));
	};


/***/ },
/* 150 */
/***/ function(module, exports) {

	'use strict';
	
	var indexOf = String.prototype.indexOf;
	
	module.exports = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};


/***/ },
/* 151 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (fn) {
		if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
		return fn;
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _reduxHelper = __webpack_require__(136);
	
	var _redux = __webpack_require__(153);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['reducer']);
	
	function getSettingsReducer(prefix) {
	  return function (state, action) {
	    if (typeof state === 'undefined') return {};
	
	    return state;
	  };
	}
	
	var Settings = function (_RcModule) {
	  (0, _inherits3.default)(Settings, _RcModule);
	
	  function Settings(options) {
	    (0, _classCallCheck3.default)(this, Settings);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Settings).call(this, (0, _extends3.default)({}, options)));
	
	    _this[symbols.reducer] = {
	      base: getSettingsReducer(_this.prefix)
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(Settings, [{
	    key: 'registerReducer',
	    value: function registerReducer(name, reducer) {
	      this[symbols.reducer][name] = reducer;
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _redux.combineReducers)(this[symbols.reducer]);
	    }
	  }]);
	  return Settings;
	}(_rcModule2.default);
	
	exports.default = Settings;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(154);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(161);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(163);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(164);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(165);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(162);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(155);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(159);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var getPrototype = __webpack_require__(156),
	    isHostObject = __webpack_require__(157),
	    isObjectLike = __webpack_require__(158);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object,
	 *  else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ },
/* 156 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetPrototype = Object.getPrototypeOf;
	
	/**
	 * Gets the `[[Prototype]]` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {null|Object} Returns the `[[Prototype]]`.
	 */
	function getPrototype(value) {
	  return nativeGetPrototype(Object(value));
	}
	
	module.exports = getPrototype;


/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 158 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(160)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 160 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(154);
	
	var _isPlainObject = __webpack_require__(155);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(162);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ },
/* 162 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(165);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 165 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _brandActions = __webpack_require__(167);
	
	var _brandActions2 = _interopRequireDefault(_brandActions);
	
	var _brandReducer = __webpack_require__(168);
	
	var _brandReducer2 = _interopRequireDefault(_brandReducer);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['initialState']);
	
	var Brand = function (_RcModule) {
	  (0, _inherits3.default)(Brand, _RcModule);
	
	  function Brand(_ref) {
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var _ref$stateMapper = _ref.stateMapper;
	    var stateMapper = _ref$stateMapper === undefined ? function (state) {
	      return state.brand;
	    } : _ref$stateMapper;
	    var prefix = _ref.prefix;
	    var id = _ref.id;
	    var name = _ref.name;
	    (0, _classCallCheck3.default)(this, Brand);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Brand).call(this, {
	      registerStoreHandler: registerStoreHandler,
	      stateMapper: stateMapper,
	      prefix: prefix,
	      actions: _brandActions2.default
	    }));
	
	    _this[symbols.initialState] = {
	      id: id,
	      name: name
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(Brand, [{
	    key: 'reducer',
	    get: function get() {
	      return (0, _brandReducer2.default)(this[symbols.initialState], this.prefix);
	    }
	  }, {
	    key: 'id',
	    get: function get() {
	      return this.state.id;
	    }
	  }, {
	    key: 'name',
	    get: function get() {
	      return this.state.name;
	    }
	  }]);
	  return Brand;
	}(_rcModule2.default);
	
	exports.default = Brand;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['setBrand']);

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getReducer;
	
	var _brandActions = __webpack_require__(167);
	
	var _brandActions2 = _interopRequireDefault(_brandActions);
	
	var _reduxHelper = __webpack_require__(136);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getReducer(initialState, prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_brandActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	
	    if (!action) return state;
	    switch (action.type) {
	      case actions.setBrand:
	        return (0, _assign2.default)({}, state, {
	          name: action.payload.name,
	          id: action.payload.id
	        });
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getIterator2 = __webpack_require__(66);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _toConsumableArray2 = __webpack_require__(170);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	var _authActions = __webpack_require__(188);
	
	var _authActions2 = _interopRequireDefault(_authActions);
	
	var _authReducer = __webpack_require__(189);
	
	var _authReducer2 = _interopRequireDefault(_authReducer);
	
	var _authEvents = __webpack_require__(190);
	
	var _utils = __webpack_require__(191);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['platform', 'emitter', 'beforeLogoutHandlers']);
	
	var ENUMS = new _enum2.default({
	  loginStatus: _loginStatus2.default
	});
	
	/**
	 * @class
	 * @description Authentication module
	 */
	
	var Auth = function (_RcModule) {
	  (0, _inherits3.default)(Auth, _RcModule);
	
	  /**
	   * @function
	   */
	
	  function Auth(options) {
	    var _this2 = this;
	
	    (0, _classCallCheck3.default)(this, Auth);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Auth).call(this, (0, _extends3.default)({}, options, {
	      actions: _authActions2.default
	    })));
	
	    var platform = options.platform;
	
	
	    _this[symbols.platform] = platform;
	    _this[symbols.beforeLogoutHandlers] = new _set2.default();
	
	    // load info on login
	    platform.on(platform.events.loginSuccess, function () {
	      _this.store.dispatch({
	        type: _this.actions.loginSuccess
	      });
	      _utils.emit.call(_this, _authEvents.authEventTypes.loginStatusChanged, _this.state.status);
	    });
	    // loginError
	    platform.on(platform.events.loginError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.loginError,
	        error: error
	      });
	    });
	    // unload info on logout
	    platform.on(platform.events.logoutSuccess, function () {
	      _this.store.dispatch({
	        type: _this.actions.logoutSuccess
	      });
	      // this.emit(authEvents.userInfoCleared);
	    });
	
	    platform.on(platform.events.logoutError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.logoutError,
	        error: error
	      });
	    });
	
	    platform.on(platform.events.refreshError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.refreshError,
	        error: error
	      });
	    });
	
	    // load info if already logged in
	    (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	      var loggedIn;
	      return _regenerator2.default.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return platform.loggedIn();
	
	            case 2:
	              loggedIn = _context.sent;
	
	              _this.store.dispatch({
	                type: _this.actions.init,
	                status: loggedIn ? _loginStatus2.default.loggedIn : _loginStatus2.default.notLoggedIn
	              });
	              _this.emit(_authEvents.authEventTypes.authEventTypes, _this.state.status);
	
	            case 5:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this2);
	    }))();
	    return _this;
	  }
	
	  (0, _createClass3.default)(Auth, [{
	    key: 'login',
	
	    /**
	     * @function
	     * @async
	     * @description Login function using username and password
	     */
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(_ref) {
	        var username = _ref.username;
	        var password = _ref.password;
	        var extension = _ref.extension;
	        var remember = _ref.remember;
	        return _regenerator2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                this.store.dispatch({
	                  type: this.actions.login,
	                  payload: {
	                    username: username,
	                    password: password,
	                    extension: extension,
	                    remember: remember
	                  }
	                });
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingIn);
	                _context2.next = 4;
	                return this[symbols.platform].login({
	                  username: username,
	                  password: password,
	                  extension: extension,
	                  remember: remember
	                });
	
	              case 4:
	                return _context2.abrupt('return', _context2.sent);
	
	              case 5:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));
	
	      function login(_x) {
	        return ref.apply(this, arguments);
	      }
	
	      return login;
	    }()
	
	    /**
	     * @function
	     * @description get OAuth page url
	     */
	
	  }, {
	    key: 'loginUrl',
	    value: function loginUrl(_ref2) {
	      var redirectUri = _ref2.redirectUri;
	      var state = _ref2.state;
	      var brandId = _ref2.brandId;
	      var display = _ref2.display;
	      var prompt = _ref2.prompt;
	
	      return this[symbols.platform].loginUrl({
	        redirectUri: redirectUri,
	        state: state,
	        brandId: brandId,
	        display: display,
	        prompt: prompt
	      });
	    }
	
	    /**
	     * @function
	     * @param {string} url
	     * @return {Object}
	     */
	
	  }, {
	    key: 'parseLoginUrl',
	    value: function parseLoginUrl(url) {
	      return this[symbols.platform].parseLoginRedirectUrl(url);
	    }
	
	    /**
	     * @function
	     * @async
	     * @description Authorize using OAauth code
	     */
	
	  }, {
	    key: 'authorize',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(_ref3) {
	        var code = _ref3.code;
	        var redirectUri = _ref3.redirectUri;
	        return _regenerator2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                this.store.dispatch({
	                  type: this.actions.login,
	                  payload: {
	                    code: code,
	                    redirectUri: redirectUri
	                  }
	                });
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingIn);
	                _context3.next = 4;
	                return this[symbols.platform].login({
	                  code: code,
	                  redirectUri: redirectUri
	                });
	
	              case 4:
	                return _context3.abrupt('return', _context3.sent);
	
	              case 5:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));
	
	      function authorize(_x2) {
	        return ref.apply(this, arguments);
	      }
	
	      return authorize;
	    }()
	
	    /**
	     * @function
	     * @async
	     * @description Log the user out
	     */
	
	  }, {
	    key: 'logout',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	        var _this3 = this;
	
	        var handlers, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;
	
	        return _regenerator2.default.wrap(function _callee5$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                // deal with removing subscriptions
	
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingOut);
	                handlers = [].concat((0, _toConsumableArray3.default)(this[symbols.beforeLogoutHandlers]));
	                _iteratorNormalCompletion = true;
	                _didIteratorError = false;
	                _iteratorError = undefined;
	                _context6.prev = 5;
	                _loop = _regenerator2.default.mark(function _loop() {
	                  var handler;
	                  return _regenerator2.default.wrap(function _loop$(_context5) {
	                    while (1) {
	                      switch (_context5.prev = _context5.next) {
	                        case 0:
	                          handler = _step.value;
	                          _context5.prev = 1;
	                          _context5.next = 4;
	                          return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	                            return _regenerator2.default.wrap(function _callee4$(_context4) {
	                              while (1) {
	                                switch (_context4.prev = _context4.next) {
	                                  case 0:
	                                    return _context4.abrupt('return', handler());
	
	                                  case 1:
	                                  case 'end':
	                                    return _context4.stop();
	                                }
	                              }
	                            }, _callee4, _this3);
	                          }))();
	
	                        case 4:
	                          _context5.next = 8;
	                          break;
	
	                        case 6:
	                          _context5.prev = 6;
	                          _context5.t0 = _context5['catch'](1);
	
	                        case 8:
	                        case 'end':
	                          return _context5.stop();
	                      }
	                    }
	                  }, _loop, _this3, [[1, 6]]);
	                });
	                _iterator = (0, _getIterator3.default)(handlers);
	
	              case 8:
	                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
	                  _context6.next = 13;
	                  break;
	                }
	
	                return _context6.delegateYield(_loop(), 't0', 10);
	
	              case 10:
	                _iteratorNormalCompletion = true;
	                _context6.next = 8;
	                break;
	
	              case 13:
	                _context6.next = 19;
	                break;
	
	              case 15:
	                _context6.prev = 15;
	                _context6.t1 = _context6['catch'](5);
	                _didIteratorError = true;
	                _iteratorError = _context6.t1;
	
	              case 19:
	                _context6.prev = 19;
	                _context6.prev = 20;
	
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                  _iterator.return();
	                }
	
	              case 22:
	                _context6.prev = 22;
	
	                if (!_didIteratorError) {
	                  _context6.next = 25;
	                  break;
	                }
	
	                throw _iteratorError;
	
	              case 25:
	                return _context6.finish(22);
	
	              case 26:
	                return _context6.finish(19);
	
	              case 27:
	                _context6.next = 29;
	                return this[symbols.platform].logout();
	
	              case 29:
	                return _context6.abrupt('return', _context6.sent);
	
	              case 30:
	              case 'end':
	                return _context6.stop();
	            }
	          }
	        }, _callee5, this, [[5, 15, 19, 27], [20,, 22, 26]]);
	      }));
	
	      function logout() {
	        return ref.apply(this, arguments);
	      }
	
	      return logout;
	    }()
	    /**
	     * @function
	     * @param {Function} handler
	     * @returns {Function}
	     */
	
	  }, {
	    key: 'addBeforeLogoutHandler',
	    value: function addBeforeLogoutHandler(handler) {
	      var _this4 = this;
	
	      this[symbols.beforeLogoutHandlers].add(handler);
	      return function () {
	        _this4[symbols.beforeLogoutHandlers].remove(handler);
	      };
	    }
	    /**
	     * @function
	     * @param {Function} handler
	     */
	
	  }, {
	    key: 'removeBeforeLogoutHandler',
	    value: function removeBeforeLogoutHandler(handler) {
	      this[symbols.beforeLogoutHandlers].remove(handler);
	    }
	  }, {
	    key: 'isLoggedIn',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
	        return _regenerator2.default.wrap(function _callee6$(_context7) {
	          while (1) {
	            switch (_context7.prev = _context7.next) {
	              case 0:
	                _context7.next = 2;
	                return this[symbols.platform].loggedIn();
	
	              case 2:
	                return _context7.abrupt('return', _context7.sent);
	
	              case 3:
	              case 'end':
	                return _context7.stop();
	            }
	          }
	        }, _callee6, this);
	      }));
	
	      function isLoggedIn() {
	        return ref.apply(this, arguments);
	      }
	
	      return isLoggedIn;
	    }()
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _authReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'status',
	    get: function get() {
	      return this.state.status;
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _authEvents.authEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _authEvents.authEventTypes;
	    }
	  }, {
	    key: 'enums',
	    get: function get() {
	      return ENUMS;
	    }
	  }]);
	  return Auth;
	}(_rcModule2.default);
	
	exports.default = Auth;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(171);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(172), __esModule: true };

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(173);
	module.exports = __webpack_require__(8).Array.from;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(9)
	  , $export        = __webpack_require__(6)
	  , toObject       = __webpack_require__(39)
	  , call           = __webpack_require__(109)
	  , isArrayIter    = __webpack_require__(110)
	  , toLength       = __webpack_require__(30)
	  , createProperty = __webpack_require__(174)
	  , getIterFn      = __webpack_require__(69);
	
	$export($export.S + $export.F * !__webpack_require__(175)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(12)
	  , createDesc      = __webpack_require__(20);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(61)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(177);


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(178);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(121)))

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (fn) {
	  return function () {
	    var gen = fn.apply(this, arguments);
	    return new _promise2.default(function (resolve, reject) {
	      function step(key, arg) {
	        try {
	          var info = gen[key](arg);
	          var value = info.value;
	        } catch (error) {
	          reject(error);
	          return;
	        }
	
	        if (info.done) {
	          resolve(value);
	        } else {
	          return _promise2.default.resolve(value).then(function (value) {
	            return step("next", value);
	          }, function (err) {
	            return step("throw", err);
	          });
	        }
	      }
	
	      return step("next");
	    });
	  };
	};

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(181), __esModule: true };

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	__webpack_require__(62);
	__webpack_require__(48);
	__webpack_require__(182);
	module.exports = __webpack_require__(8).Promise;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(54)
	  , global             = __webpack_require__(7)
	  , ctx                = __webpack_require__(9)
	  , classof            = __webpack_require__(65)
	  , $export            = __webpack_require__(6)
	  , isObject           = __webpack_require__(14)
	  , anObject           = __webpack_require__(13)
	  , aFunction          = __webpack_require__(10)
	  , anInstance         = __webpack_require__(107)
	  , forOf              = __webpack_require__(108)
	  , setProto           = __webpack_require__(98).set
	  , speciesConstructor = __webpack_require__(183)
	  , task               = __webpack_require__(184).set
	  , microtask          = __webpack_require__(186)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(61)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(106)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(60)($Promise, PROMISE);
	__webpack_require__(111)(PROMISE);
	Wrapper = __webpack_require__(8)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(175)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(13)
	  , aFunction = __webpack_require__(10)
	  , SPECIES   = __webpack_require__(61)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(9)
	  , invoke             = __webpack_require__(185)
	  , html               = __webpack_require__(59)
	  , cel                = __webpack_require__(18)
	  , global             = __webpack_require__(7)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(27)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 185 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(7)
	  , macrotask = __webpack_require__(184).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(27)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  pending: 'PENDING', // after init, before status from platform is determined
	  notLoggedIn: 'NOT_LOGGED_IN',
	  loggingIn: 'LOGGING_IN',
	  loggedIn: 'LOGGED_IN',
	  loggingOut: 'LOGGING_OUT'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['login', 'loginSuccess', 'loginError', 'logout', 'logoutSuccess', 'logoutError', 'refresh', 'refreshSuccess', 'refreshError', 'init'], 'auth');

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getAuthReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _authActions = __webpack_require__(188);
	
	var _authActions2 = _interopRequireDefault(_authActions);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  status: _loginStatus2.default.pending,
	  authError: null
	};
	
	function getAuthReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_authActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      case actions.init:
	        return (0, _assign2.default)({}, state, { status: action.status });
	
	      case actions.login:
	        return {
	          status: _loginStatus2.default.loggingIn,
	          authError: null
	        };
	
	      case actions.loginSuccess:
	        return {
	          status: _loginStatus2.default.loggedIn,
	          authError: null
	        };
	
	      case actions.logoutSuccess:
	        return {
	          status: _loginStatus2.default.notLoggedIn,
	          authError: null
	        };
	
	      case actions.loginError:
	        return {
	          state: _loginStatus2.default.notLoggedIn,
	          authError: action.error
	        };
	
	      case actions.logoutError:
	        return {
	          status: _loginStatus2.default.loggedIn,
	          authError: action.error
	        };
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.authEventTypes = exports.authEvents = undefined;
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinitions = (0, _extends3.default)({}, _loginStatus2.default);
	
	var authEvents = exports.authEvents = new _enum2.default(eventDefinitions);
	
	var eventTypeDefinitions = {
	  loginStatusChanged: 'LOGIN_STATUS_CHANGED'
	};
	
	var authEventTypes = exports.authEventTypes = new _enum2.default(eventTypeDefinitions);

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.sleep = exports.fetchList = undefined;
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var fetchList = exports.fetchList = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(fn) {
	    var fetchedPages, totalPages, list, data;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            fetchedPages = 0;
	            totalPages = 1;
	            list = [];
	
	          case 3:
	            if (!(fetchedPages < totalPages)) {
	              _context.next = 12;
	              break;
	            }
	
	            fetchedPages++;
	            _context.next = 7;
	            return fn({
	              page: fetchedPages
	            });
	
	          case 7:
	            data = _context.sent;
	
	            totalPages = data.paging.totalPages;
	            list = list.concat(data.records);
	            _context.next = 3;
	            break;
	
	          case 12:
	            return _context.abrupt('return', list);
	
	          case 13:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	  return function fetchList(_x) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @param {String} eventType
	 * @param {String} event
	 * @description Helper function to emit eventTyped events and the event itself
	 */
	
	
	/**
	 * @function
	 * @param {Number} t
	 */
	
	var sleep = exports.sleep = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(t) {
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            return _context2.abrupt('return', new _promise2.default(function (resolve) {
	              setTimeout(resolve, t);
	            }));
	
	          case 1:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function sleep(_x2) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	exports.extractData = extractData;
	exports.emit = emit;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function extractData(model) {
	  if (Array.isArray(model)) {
	    return model.map(function (item) {
	      return extractData(item);
	    });
	  } else if ((typeof model === 'undefined' ? 'undefined' : (0, _typeof3.default)(model)) === 'object') {
	    var data = {};
	    for (var key in model) {
	      if (key[0] !== '_' && model.hasOwnProperty(key)) {
	        data[key] = extractData(model[key]);
	      }
	    }
	    return data;
	  }
	  return model;
	}
	
	function emit(eventType, event) {
	  for (var _len = arguments.length, payloads = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    payloads[_key - 2] = arguments[_key];
	  }
	
	  this.emit.apply(this, [event].concat(payloads));
	  this.emit.apply(this, [eventType, event].concat(payloads));
	}

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _stringify = __webpack_require__(193);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _subscriptionActions = __webpack_require__(195);
	
	var _subscriptionActions2 = _interopRequireDefault(_subscriptionActions);
	
	var _subscriptionReducer = __webpack_require__(196);
	
	var _subscriptionReducer2 = _interopRequireDefault(_subscriptionReducer);
	
	var _subscriptionEvents = __webpack_require__(197);
	
	var _subscriptionStatus = __webpack_require__(198);
	
	var _subscriptionStatus2 = _interopRequireDefault(_subscriptionStatus);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _utils = __webpack_require__(191);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['auth', 'sdk', 'platform', 'subscription', 'filterCache']);
	
	var filterRegex = {
	  message: /message-store$/,
	  presence: /presence(\?detailedTelephonyState=true)?$/,
	  telephony: /presence\?detailedTelephonyState=true$/,
	  line: /presence\/line$/,
	  linePresence: /presence\/line\/presence(\?detailedTelephonyState=true)?$/,
	  lineTelephony: /presence\/line\/presence\?detailedTelephonyState=true$/
	};
	
	/**
	 * @function
	 * @param {Object} message
	 * @description Handles messages delivered by the subscripton
	 */
	function messageHandler(message) {
	  var _this = this;
	
	  // determine which events the message falls under
	  var events = [];
	  if (filterRegex.message.test(message.event)) {
	    events.push('message');
	  } else if (filterRegex.line.test(message.event)) {
	    events.push('line');
	  } else if (filterRegex.linePresence.test(message.event)) {
	    events.push('linePresence');
	    if (filterRegex.lineTelephony.test(message.event)) events.push('lineTelephony');
	  } else if (filterRegex.presence.test(message.event)) {
	    events.push('presence');
	    if (filterRegex.telephony.test(message.event)) events.push('telephony');
	  }
	  // dispatch the message in redux manner
	  this.store.dispatch({
	    type: this.actions.notification,
	    eventTypes: events,
	    payload: message
	  });
	  // emit the messages as events
	  events.forEach(function (event) {
	    _utils.emit.call(_this, _subscriptionEvents.subscriptionEventTypes.notification, _subscriptionEvents.subscriptionEvents[event], message);
	  });
	}
	function init() {
	  var _this2 = this;
	
	  var platform = this[symbols.platform];
	  this[symbols.subscription] = this[symbols.sdk].createSubscription();
	  var ownerId = platform.auth().data().owner_id;
	  var cacheKey = null;
	  if (typeof localStorage !== 'undefined') {
	    cacheKey = this.prefix + '-sub-' + ownerId;
	    var cachedSubscription = localStorage.getItem(cacheKey);
	    if (cachedSubscription) {
	      try {
	        this.base.setSubscription(JSON.parse(cachedSubscription));
	      } catch (e) {
	        /* do nothing */
	      }
	    }
	  }
	
	  this.base.setEventFilters(this.filters);
	
	  this.base.on(this.base.events.notification, function (message) {
	    messageHandler.call(_this2, message);
	  });
	  this.base.on(this.base.events.removeSuccess, function () {
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.notSubscribed,
	      subscription: null
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	  });
	  this.base.on(this.base.events.removeError, function () {
	    // TODO
	  });
	  this.base.on(this.base.events.renewSuccess, function () {
	    if (cacheKey) {
	      localStorage.setItem(cacheKey, (0, _stringify2.default)(_this2.base.subscription()));
	    }
	    var oldStatus = _this2.status;
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.subscribed,
	      subscription: _this2.base.subscription()
	    });
	    if (oldStatus !== _this2.status) {
	      _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	    }
	  });
	  this.base.on(this.base.events.renewError, function (error) {
	    // TODO handle 429
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.notSubscribed,
	      subscription: null
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	    _this2.base.reset().setEventFilters(_this2.filters).register().catch(function (e) {});
	  });
	  this.base.on(this.base.events.subscribeSuccess, function () {
	    if (cacheKey) {
	      localStorage.setItem(cacheKey, (0, _stringify2.default)(_this2.base.subscription()));
	    }
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.subscribed,
	      subscription: _this2.base.subscription()
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	  });
	  this.base.on(this.base.events.subscribeError, function (error) {
	    // TODO
	    // handle 429
	    // handle subscription limit
	  });
	
	  if (this.filters.length) {
	    this.base.register().catch(function () {/* do nothing */});
	  }
	}
	
	var Subscription = function (_RcModule) {
	  (0, _inherits3.default)(Subscription, _RcModule);
	
	  function Subscription(options) {
	    var _this4 = this;
	
	    (0, _classCallCheck3.default)(this, Subscription);
	
	    var _this3 = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Subscription).call(this, (0, _extends3.default)({}, options, {
	      registerStoreHandler: function registerStoreHandler(handler) {
	        options.registerStoreHandler(function (store) {
	          // set store to self first
	          handler(store);
	
	          // update store with cachedFilters
	          _this3.store.dispatch({
	            type: _this3.actions.updateFilters,
	            filters: _this3.filters
	          });
	
	          _this3[symbols.filterCache] = null;
	        });
	      },
	      actions: _subscriptionActions2.default
	    })));
	
	    var auth = options.auth;
	    var platform = options.platform;
	    var sdk = options.sdk;
	
	    _this3[symbols.auth] = auth;
	    _this3[symbols.platform] = platform;
	    _this3[symbols.sdk] = sdk;
	    _this3[symbols.subscription] = null;
	
	    // caches filters before redux store is created
	    _this3[symbols.filterCache] = [];
	
	    auth.on(auth.events.loggedIn, function () {
	      init.call(_this3);
	    });
	
	    auth.on(auth.events.loggedOut, function () {
	      if (_this3.base) {
	        _this3.reset();
	      }
	    });
	
	    // platform.on(platform.events.loginSuccess, () => {
	    //   this::init();
	    // });
	    // platform.on(platform.events.logoutSuccess, async () => {
	    //   if (this.base) {
	    //     await this.reset();
	    //   }
	    //   this[symbols.subscription] = null;
	    // });
	
	    auth.addBeforeLogoutHandler((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	      return _regenerator2.default.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return _this3.reset();
	
	            case 2:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this4);
	    })));
	
	    // (async () => {
	    //   if (await platform.loggedIn()) {
	    //     this::init();
	    //   }
	    // })();
	    return _this3;
	  }
	
	  (0, _createClass3.default)(Subscription, [{
	    key: 'subscribe',
	    value: function subscribe(event) {
	      // TODO normalized error
	      if (!_enum2.default.hasValue.call(_subscriptionEvents.subscriptionEvents, event)) {
	        throw new Error('event is not recognized');
	      }
	
	      if (this.filters.indexOf(event) === -1) {
	        var newFilters = this.filters.slice();
	        newFilters.push(event);
	        if (this.base) {
	          this.base.setEventFilters(newFilters);
	          this.store.dispatch({
	            type: this.actions.updateFilters,
	            filters: newFilters
	          });
	          this.base.register().catch(function () {/* do nothing */});
	        } else {
	          this[symbols.filterCache] = newFilters;
	        }
	      }
	    }
	  }, {
	    key: 'unsubscribe',
	    value: function unsubscribe(event) {
	      // TODO normalized error
	      if (!_enum2.default.hasValue.call(_subscriptionEvents.subscriptionEvents, event)) {
	        throw new Error('event is not recognized');
	      }
	      var idx = this.filters.indexOf(event);
	      if (this.filters.indexOf(event) > -1) {
	        var newFilters = this.filters.slice();
	        newFilters.splice(idx, 1);
	        if (this.base) {
	          this.base.setEventFilters(newFilters);
	          this.store.dispatch({
	            type: this.actions.updateFilters,
	            filters: newFilters
	          });
	          if (newFilters.length) {
	            this.base.register().catch(function () {/* do nothing */});
	          } else {
	            this.base.remove();
	          }
	        } else {
	          this[symbols.filterCache] = newFilters;
	        }
	      }
	    }
	  }, {
	    key: 'reset',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	        var oldStatus;
	        return _regenerator2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.prev = 0;
	
	                if (!this.base) {
	                  _context2.next = 9;
	                  break;
	                }
	
	                if (!(this.status === _subscriptionStatus2.default.subscribed)) {
	                  _context2.next = 7;
	                  break;
	                }
	
	                _context2.next = 5;
	                return this.base.remove();
	
	              case 5:
	                _context2.next = 9;
	                break;
	
	              case 7:
	                _context2.next = 9;
	                return this.base.reset();
	
	              case 9:
	                _context2.next = 13;
	                break;
	
	              case 11:
	                _context2.prev = 11;
	                _context2.t0 = _context2['catch'](0);
	
	              case 13:
	                this[symbols.subscription] = null;
	                oldStatus = this.status;
	
	                this.store.dispatch({
	                  type: this.actions.updateStatus,
	                  status: _subscriptionStatus2.default.notSubscribed,
	                  subscription: null
	                });
	                if (oldStatus !== this.status) {
	                  _utils.emit.call(this, _subscriptionEvents.subscriptionEventTypes.statusChanged, this.status);
	                }
	
	              case 17:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this, [[0, 11]]);
	      }));
	
	      function reset() {
	        return ref.apply(this, arguments);
	      }
	
	      return reset;
	    }()
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _subscriptionReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'status',
	    get: function get() {
	      return this.state.status;
	    }
	  }, {
	    key: 'filters',
	    get: function get() {
	      return this[symbols.filterCache] || this.state.filters;
	    }
	  }, {
	    key: 'base',
	    get: function get() {
	      return this[symbols.subscription];
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _subscriptionEvents.subscriptionEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _subscriptionEvents.subscriptionEventTypes;
	    }
	  }]);
	  return Subscription;
	}(_rcModule2.default);
	
	exports.default = Subscription;

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(194), __esModule: true };

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(8)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['updateFilters', 'notification', 'updateStatus'], 'subscription');

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getSubscriptionReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _subscriptionActions = __webpack_require__(195);
	
	var _subscriptionActions2 = _interopRequireDefault(_subscriptionActions);
	
	var _subscriptionEvents = __webpack_require__(197);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  cacheKey: null,
	  filters: [],
	  status: _subscriptionEvents.subscriptionEvents.pending
	};
	
	function getSubscriptionReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_subscriptionActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	      case actions.updateStatus:
	        return (0, _assign2.default)({}, state, {
	          status: action.status,
	          subscription: actions.subscription
	        });
	
	      case actions.updateFilters:
	        return (0, _assign2.default)({}, state, {
	          filters: action.filters.slice()
	        });
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.subscriptionEventTypes = exports.subscriptionEvents = undefined;
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _subscriptionStatus = __webpack_require__(198);
	
	var _subscriptionStatus2 = _interopRequireDefault(_subscriptionStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinition = (0, _extends3.default)({
	  message: '/restapi/v1.0/account/~/extension/~/message-store',
	  presence: '/restapi/v1.0/account/~/extension/~/presence',
	  telephony: '/restapi/v1.0/account/~/extension/~/presence?detailedTelephonyState=true',
	  line: '/restapi/v1.0/account/~/extension/~/presence/line',
	  linePresence: '/restapi/v1.0/account/~/extension/~/presence/line/presence',
	  lineTelephony: '/restapi/v1.0/account/~/extension/~/presence/line/presence?detailedTelephonyState=true'
	}, _subscriptionStatus2.default);
	
	var subscriptionEvents = exports.subscriptionEvents = new _enum2.default(eventDefinition);
	
	var eventTypeDefinition = {
	  notification: 'NOTIFICATION',
	  statusChanged: 'STATUS_CHANGED'
	};
	
	var subscriptionEventTypes = exports.subscriptionEventTypes = new _enum2.default(eventTypeDefinition);

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  pending: 'PENDING',
	  subscribed: 'SUBSCRIBED',
	  notSubscribed: 'NOT_SUBSCRIBED'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	// const initialState = {
	//   test: true,
	// };
	
	// function getUserSettingsReducer(prefix) {
	//   return (state, action) => {
	//     if (typeof state === 'undefined') return Object.assign({}, initialState);
	//     if (!action) return state;
	//     switch (action.type) {
	//       default:
	//         return state;
	//     }
	//   };
	// }
	
	/**
	 * @function
	 * @param {String} dataType
	 * @param {function} loadFunction - async loader function returning a promise
	 * @return {Promise}
	 * @description Generic data loading logic with events
	 */
	
	var loadData = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(dataType, loadFunction) {
	    var payload;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            this.store.dispatch({
	              type: this.actions['load' + dataType]
	            });
	            this.emit(_userEvents.userEvents['load' + dataType]);
	            _context.prev = 2;
	            _context.next = 5;
	            return loadFunction.call(this);
	
	          case 5:
	            payload = _context.sent;
	
	            this.store.dispatch({
	              type: this.actions['load' + dataType + 'Success'],
	              payload: payload
	            });
	            _utils.emit.call(this, _userEvents.userEventTypes.userInfoChanged, _userEvents.userEvents['load' + dataType + 'Success']);
	            _context.next = 15;
	            break;
	
	          case 10:
	            _context.prev = 10;
	            _context.t0 = _context['catch'](2);
	
	            this.store.dispatch({
	              type: this.actions['load' + dataType + 'Failed']
	            });
	            this.emit(_userEvents.userEvents['load' + dataType + 'Failed']);
	            throw _context.t0;
	
	          case 15:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this, [[2, 10]]);
	  }));
	  return function loadData(_x, _x2) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @return {Promise<Object>}
	 * @description Fetch account info and extract the data
	 */
	
	
	var extractAccountInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return this[symbols.api].account().loadAccount();
	
	          case 2:
	            _context2.t0 = _context2.sent;
	            return _context2.abrupt('return', (0, _utils.extractData)(_context2.t0));
	
	          case 4:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function extractAccountInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadAccountInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	    return _regenerator2.default.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.next = 2;
	            return loadData.call(this, 'AccountInfo', extractAccountInfo);
	
	          case 2:
	            return _context3.abrupt('return', _context3.sent);
	
	          case 3:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	  return function loadAccountInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractExtensionInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	    return _regenerator2.default.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.next = 2;
	            return this[symbols.api].extension().loadExtensionInfo();
	
	          case 2:
	            _context4.t0 = _context4.sent;
	            return _context4.abrupt('return', (0, _utils.extractData)(_context4.t0));
	
	          case 4:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this);
	  }));
	  return function extractExtensionInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadExtensionInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	    return _regenerator2.default.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return loadData.call(this, 'ExtensionInfo', extractExtensionInfo);
	
	          case 2:
	            return _context5.abrupt('return', _context5.sent);
	
	          case 3:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this);
	  }));
	  return function loadExtensionInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractDialingPlans = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
	    var _this = this;
	
	    return _regenerator2.default.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            _context6.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this[symbols.api].account().listDialingPlans(options);
	            });
	
	          case 2:
	            _context6.t0 = _context6.sent;
	            return _context6.abrupt('return', (0, _utils.extractData)(_context6.t0));
	
	          case 4:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this);
	  }));
	  return function extractDialingPlans() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadDialingPlans = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7() {
	    return _regenerator2.default.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            _context7.next = 2;
	            return loadData.call(this, 'DialingPlans', extractDialingPlans);
	
	          case 2:
	            return _context7.abrupt('return', _context7.sent);
	
	          case 3:
	          case 'end':
	            return _context7.stop();
	        }
	      }
	    }, _callee7, this);
	  }));
	  return function loadDialingPlans() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractPhoneNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8() {
	    var _this2 = this;
	
	    return _regenerator2.default.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            _context8.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this2[symbols.api].extension().listExtensionPhoneNumbers(options);
	            });
	
	          case 2:
	            _context8.t0 = _context8.sent;
	            return _context8.abrupt('return', (0, _utils.extractData)(_context8.t0));
	
	          case 4:
	          case 'end':
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this);
	  }));
	  return function extractPhoneNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadPhoneNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9() {
	    return _regenerator2.default.wrap(function _callee9$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            _context9.next = 2;
	            return loadData.call(this, 'PhoneNumbers', extractPhoneNumbers);
	
	          case 2:
	            return _context9.abrupt('return', _context9.sent);
	
	          case 3:
	          case 'end':
	            return _context9.stop();
	        }
	      }
	    }, _callee9, this);
	  }));
	  return function loadPhoneNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractForwardingNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
	    var _this3 = this;
	
	    return _regenerator2.default.wrap(function _callee10$(_context10) {
	      while (1) {
	        switch (_context10.prev = _context10.next) {
	          case 0:
	            _context10.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this3[symbols.api].forwardingNumbers().listExtensionForwardingNumbers(options);
	            });
	
	          case 2:
	            _context10.t0 = _context10.sent;
	            return _context10.abrupt('return', (0, _utils.extractData)(_context10.t0));
	
	          case 4:
	          case 'end':
	            return _context10.stop();
	        }
	      }
	    }, _callee10, this);
	  }));
	  return function extractForwardingNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadForwardingNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11() {
	    return _regenerator2.default.wrap(function _callee11$(_context11) {
	      while (1) {
	        switch (_context11.prev = _context11.next) {
	          case 0:
	            _context11.next = 2;
	            return loadData.call(this, 'ForwardingNumbers', extractForwardingNumbers);
	
	          case 2:
	            return _context11.abrupt('return', _context11.sent);
	
	          case 3:
	          case 'end':
	            return _context11.stop();
	        }
	      }
	    }, _callee11, this);
	  }));
	  return function loadForwardingNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractBlockedNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12() {
	    var _this4 = this;
	
	    return _regenerator2.default.wrap(function _callee12$(_context12) {
	      while (1) {
	        switch (_context12.prev = _context12.next) {
	          case 0:
	            _context12.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this4[symbols.api].blockedNumbers().listBlockedNumbers(options);
	            });
	
	          case 2:
	            _context12.t0 = _context12.sent;
	            return _context12.abrupt('return', (0, _utils.extractData)(_context12.t0));
	
	          case 4:
	          case 'end':
	            return _context12.stop();
	        }
	      }
	    }, _callee12, this);
	  }));
	  return function extractBlockedNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadBlockedNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
	    return _regenerator2.default.wrap(function _callee13$(_context13) {
	      while (1) {
	        switch (_context13.prev = _context13.next) {
	          case 0:
	            _context13.next = 2;
	            return loadData.call(this, 'BlockedNumbers', extractBlockedNumbers);
	
	          case 2:
	            return _context13.abrupt('return', _context13.sent);
	
	          case 3:
	          case 'end':
	            return _context13.stop();
	        }
	      }
	    }, _callee13, this);
	  }));
	  return function loadBlockedNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @return {Promise}
	 */
	
	
	var loadInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14() {
	    return _regenerator2.default.wrap(function _callee14$(_context14) {
	      while (1) {
	        switch (_context14.prev = _context14.next) {
	          case 0:
	            _context14.prev = 0;
	            _context14.next = 3;
	            return _promise2.default.all([loadAccountInfo.call(this), loadExtensionInfo.call(this), loadDialingPlans.call(this), loadPhoneNumbers.call(this), loadForwardingNumbers.call(this), loadBlockedNumbers.call(this)]);
	
	          case 3:
	            _context14.next = 8;
	            break;
	
	          case 5:
	            _context14.prev = 5;
	            _context14.t0 = _context14['catch'](0);
	
	            // TODO send error out
	            console.log(_context14.t0);
	
	          case 8:
	          case 'end':
	            return _context14.stop();
	        }
	      }
	    }, _callee14, this, [[0, 5]]);
	  }));
	  return function loadInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @class User
	 * @extends RcModule
	 * @default
	 * @export
	 */
	
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _utils = __webpack_require__(191);
	
	var _userActions = __webpack_require__(200);
	
	var _userActions2 = _interopRequireDefault(_userActions);
	
	var _userReducer = __webpack_require__(201);
	
	var _userReducer2 = _interopRequireDefault(_userReducer);
	
	var _userEvents = __webpack_require__(202);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['api', 'platform', 'settings']);
	var User = function (_RcModule) {
	  (0, _inherits3.default)(User, _RcModule);
	
	  /**
	   * @function
	   * @param {Object} options
	   */
	
	  function User(options) {
	    var _this6 = this;
	
	    (0, _classCallCheck3.default)(this, User);
	
	    var _this5 = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(User).call(this, (0, _extends3.default)({}, options, {
	      actions: _userActions2.default
	    })));
	
	    var api = options.api;
	    var platform = options.platform;
	    var settings = options.settings;
	
	    _this5[symbols.api] = api;
	    _this5[symbols.platform] = platform;
	    _this5[symbols.settings] = settings;
	
	    // settings.registerReducer('user', getUserSettingsReducer());
	
	    // load info on login
	    platform.on(platform.events.loginSuccess, function () {
	      loadInfo.call(_this5);
	    });
	    // unload info on logout
	    platform.on(platform.events.logoutSuccess, function () {
	      _this5.store.dispatch({
	        type: _this5.actions.clearUserInfo
	      });
	      // this.emit(userEvents.userInfoCleared);
	    });
	
	    // load info if already logged in
	    (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15() {
	      return _regenerator2.default.wrap(function _callee15$(_context15) {
	        while (1) {
	          switch (_context15.prev = _context15.next) {
	            case 0:
	              _context15.next = 2;
	              return platform.loggedIn();
	
	            case 2:
	              if (!_context15.sent) {
	                _context15.next = 5;
	                break;
	              }
	
	              _context15.next = 5;
	              return loadInfo.call(_this5);
	
	            case 5:
	            case 'end':
	              return _context15.stop();
	          }
	        }
	      }, _callee15, _this6);
	    }))();
	
	    /**
	     * TODO:
	     *   1. Dialing Plan Checking
	     */
	    return _this5;
	  }
	
	  (0, _createClass3.default)(User, [{
	    key: 'reducer',
	    get: function get() {
	      return (0, _userReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _userEvents.userEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _userEvents.userEventTypes;
	    }
	  }, {
	    key: 'directNumbers',
	    get: function get() {
	      return this.state.phoneNumbers.filter(function (n) {
	        return n.usageType === 'DirectNumber';
	      });
	    }
	  }, {
	    key: 'mainCompanyNumber',
	    get: function get() {
	      return this.state.phoneNumbers.find(function (n) {
	        return n.usageType === 'MainCompanyNumber';
	      });
	    }
	  }, {
	    key: 'dialingPlans',
	    get: function get() {
	      return this.state.dialingPlans;
	    }
	  }, {
	    key: 'extensionNumber',
	    get: function get() {
	      return this.state.extensionInfo.extensionNumber;
	    }
	  }, {
	    key: 'smsNumbers',
	    get: function get() {
	      return this.state.phoneNumbers.filter(function (n) {
	        return n.features.indexOf('SmsSender') > -1;
	      });
	    }
	  }]);
	  return User;
	}(_rcModule2.default);
	
	exports.default = User;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['clearUserInfo', 'loadAccountInfo', 'loadAccountInfoSuccess', 'loadAccountInfoFailed', 'loadExtensionInfo', 'loadExtensionInfoSuccess', 'loadExtensionInfoFailed', 'loadDialingPlans', 'loadDialingPlansSuccess', 'loadDialingPlansFailed', 'loadPhoneNumbers', 'loadPhoneNumbersSuccess', 'loadPhoneNumbersFailed', 'loadForwardingNumbers', 'loadForwardingNumbersSuccess', 'loadForwardingNumbersFailed', 'loadBlockedNumbers', 'loadBlockedNumbersSuccess', 'loadBlockedNumbersFailed'], 'user');

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getUserReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _userActions = __webpack_require__(200);
	
	var _userActions2 = _interopRequireDefault(_userActions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  accountInfo: null,
	  accountInfoLoading: false,
	  accountInfoError: null,
	
	  extensionInfo: null,
	  extensionInfoLoading: false,
	  extensionInfoError: null,
	
	  dialingPlans: [],
	  dialingPlansLoading: false,
	  dialingPlansError: null,
	
	  phoneNumbers: [],
	  phoneNumbersLoading: false,
	  phoneNumbersError: null,
	
	  forwardingNumbers: [],
	  forwardingNumbersLoading: false,
	  forwardingNumbersError: null,
	
	  blockedNumbers: [],
	  blockedNumbersLoading: false,
	  blockedNumbersError: null
	};
	
	function getUserReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_userActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      // account info
	      case actions.loadAccountInfo:
	        return (0, _assign2.default)({}, state, {
	          accountInfoLoading: true
	        });
	      case actions.loadAccountInfoSuccess:
	        return (0, _assign2.default)({}, state, {
	          accountInfo: action.payload,
	          accountInfoLoading: false,
	          accountInfoError: null
	        });
	      case actions.loadAccountInfoFailed:
	        return (0, _assign2.default)({}, state, {
	          accountInfoLoading: false,
	          accountInfoError: action.error
	        });
	
	      // extension info
	      case actions.loadExtensionInfo:
	        return (0, _assign2.default)({}, state, {
	          extensionInfoLoading: true
	        });
	      case actions.loadExtensionInfoSuccess:
	        return (0, _assign2.default)({}, state, {
	          extensionInfo: action.payload,
	          extensionInfoLoading: false,
	          extensionInfoError: null
	        });
	      case actions.loadExtensionInfoFailed:
	        return (0, _assign2.default)({}, state, {
	          extensionInfoLoading: false,
	          extensionInfoError: action.error
	        });
	
	      // dialing plans
	      case actions.loadDialingPlans:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: true
	        });
	      case actions.loadDialingPlansSuccess:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: false,
	          dialingPlans: action.payload
	        });
	      case action.loadDialingPlansFailed:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: false,
	          dialingPlansError: action.error
	        });
	
	      // phone numbers
	      case actions.loadPhoneNumbers:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: true
	        });
	      case actions.loadPhoneNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: false,
	          phoneNumbers: action.payload
	        });
	      case action.loadPhoneNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: false,
	          phoneNumbersError: action.error
	        });
	
	      // forwarding numbers
	      case actions.loadForwardingNumbers:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: true
	        });
	      case actions.loadForwardingNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: false,
	          forwardingNumbers: action.payload
	        });
	      case action.loadForwardingNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: false,
	          forwardingNumbersError: action.error
	        });
	
	      // blocked numbers
	      case actions.loadBlockedNumbers:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: true
	        });
	      case actions.loadBlockedNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: false,
	          blockedNumbers: action.payload
	        });
	      case action.loadBlockedNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: false,
	          blockedNumbersError: action.error
	        });
	
	      case action.clearUserInfo:
	        return (0, _assign2.default)({}, initialState);
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.userEventTypes = exports.userEvents = undefined;
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinitions = {
	  userInfoLoaded: 'USER_INFO_LOADED',
	  userInfoCleared: 'USER_INFO_CLEARED',
	
	  loadAccountInfo: 'LOAD_ACCOUNT_INFO',
	  loadAccountInfoSuccess: 'LOAD_ACCOUNT_INFO_SUCCESS',
	  loadAccountInfoFailed: 'LOAD_ACCOUNT_INFO_FAILED',
	
	  loadExtensionInfo: 'LOAD_EXTENSION_INFO',
	  loadExtensionInfoSuccess: 'LOAD_EXTENSION_INFO_SUCCESS',
	  loadExtensionInfoFailed: 'LOAD_EXTENSION_INFO_FAILED',
	
	  loadDialingPlans: 'LOAD_DIALING_PLANS',
	  loadDialingPlansSuccess: 'LOAD_DIALING_PLANS_SUCCESS',
	  loadDialingPlansFailed: 'LOAD_DIALING_PLANS_FAILED',
	
	  loadPhoneNumbers: 'LOAD_PHONE_NUMBERS',
	  loadPhoneNumbersSuccess: 'LOAD_PHONE_NUMBERS_SUCCESS',
	  loadPhoneNumbersFailed: 'LOAD_PHONE_NUMBERS_FAILED',
	
	  loadForwardingNumbers: 'LOAD_FORWARDING_NUMBERS',
	  loadForwardingNumbersSuccess: 'LOAD_FORWARDING_NUMBERS_SUCCESS',
	  loadForwardingNumbersFailed: 'LOAD_FORWARDING_NUMBERS_FAILED',
	
	  loadBlockedNumbers: 'LOAD_BLOCKED_NUMBERS',
	  loadBlockedNumbersSuccess: 'LOAD_BLOCKED_NUMBERS_SUCCESS',
	  loadBlockedNumbersFailed: 'LOAD_BLOCKED_NUMBERS_FAILED'
	};
	
	var userEvents = exports.userEvents = new _enum2.default(eventDefinitions);
	
	var eventTypeDefinitions = {
	  userInfoChanged: 'USER_INFO_CHANGED'
	};
	
	var userEventTypes = exports.userEventTypes = new _enum2.default(eventTypeDefinitions);

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var initPhoneInstance = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	    var info;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return this[symbols.platform].post('/client-info/sip-provision', {
	              sipInfo: [{ transport: 'WSS' }]
	            }).then(function (res) {
	              return res.json();
	            });
	
	          case 2:
	            info = _context.sent;
	            return _context.abrupt('return', new _ringcentralWebPhone2.default(info, {
	              logLevel: 0,
	              audioHelper: {
	                enabled: false
	              }
	            }));
	
	          case 4:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	  return function initPhoneInstance() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var record = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            if (flag) {
	              _context2.next = 6;
	              break;
	            }
	
	            _context2.next = 3;
	            return this.currentSession.stopRecord();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.stopRecord
	              }
	            });
	            _context2.next = 9;
	            break;
	
	          case 6:
	            _context2.next = 8;
	            return this.currentSession.startRecord();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.record
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function record(_x) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var mute = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            if (flag) {
	              _context3.next = 6;
	              break;
	            }
	
	            _context3.next = 3;
	            return this.currentSession.unmute();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.unmute
	              }
	            });
	            _context3.next = 9;
	            break;
	
	          case 6:
	            _context3.next = 8;
	            return this.currentSession.mute();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.mute
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	  return function mute(_x3) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var hold = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            if (flag) {
	              _context4.next = 6;
	              break;
	            }
	
	            _context4.next = 3;
	            return this.currentSession.unhold();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.unhold
	              }
	            });
	            _context4.next = 9;
	            break;
	
	          case 6:
	            _context4.next = 8;
	            return this.currentSession.hold();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.hold
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this);
	  }));
	  return function hold(_x5) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var park = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	    return _regenerator2.default.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return this.currentSession.park();
	
	          case 2:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.park
	              }
	            });
	
	          case 3:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this);
	  }));
	  return function park() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var transfer = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(number) {
	    return _regenerator2.default.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            this.checkSession();
	            _context6.next = 3;
	            return this.currentSession.transfer(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.transfer,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this);
	  }));
	  return function transfer(_x7) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var flip = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(number) {
	    return _regenerator2.default.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            this.checkSession();
	            _context7.next = 3;
	            return this.currentSession.flip(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.flip,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context7.stop();
	        }
	      }
	    }, _callee7, this);
	  }));
	  return function flip(_x8) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var dtmf = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(number) {
	    return _regenerator2.default.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            this.checkSession();
	            _context8.next = 3;
	            return this.currentSession.dtmf(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.dtmf,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this);
	  }));
	  return function dtmf(_x9) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var operations = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(name) {
	    var actions,
	        _actions$name,
	        _len,
	        args,
	        _key,
	        _args9 = arguments;
	
	    return _regenerator2.default.wrap(function _callee9$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            actions = { record: record, mute: mute, hold: hold, park: park, transfer: transfer, flip: flip, dtmf: dtmf };
	
	            this.checkSession();
	            _context9.prev = 2;
	
	            for (_len = _args9.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	              args[_key - 1] = _args9[_key];
	            }
	
	            _context9.next = 6;
	            return (_actions$name = actions[name]).call.apply(_actions$name, [this].concat(args));
	
	          case 6:
	            _context9.next = 12;
	            break;
	
	          case 8:
	            _context9.prev = 8;
	            _context9.t0 = _context9['catch'](2);
	
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.error,
	                error: _context9.t0
	              }
	            });
	            // TODO: needed?
	            throw _context9.t0;
	
	          case 12:
	          case 'end':
	            return _context9.stop();
	        }
	      }
	    }, _callee9, this, [[2, 8]]);
	  }));
	  return function operations(_x10, _x11) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _webphoneActions = __webpack_require__(204);
	
	var _webphoneActions2 = _interopRequireDefault(_webphoneActions);
	
	var _callActions = __webpack_require__(205);
	
	var _callActions2 = _interopRequireDefault(_callActions);
	
	var _webphoneReducer = __webpack_require__(206);
	
	var _webphoneReducer2 = _interopRequireDefault(_webphoneReducer);
	
	var _eventEmitter = __webpack_require__(137);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _ringcentralWebPhone = __webpack_require__(210);
	
	var _ringcentralWebPhone2 = _interopRequireDefault(_ringcentralWebPhone);
	
	var _webphoneStatus = __webpack_require__(207);
	
	var _webphoneStatus2 = _interopRequireDefault(_webphoneStatus);
	
	var _callStatus = __webpack_require__(209);
	
	var _callStatus2 = _interopRequireDefault(_callStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['api', 'platform', 'emitter', 'settings', 'phoneInstance']);
	
	var ENUMS = new _enum2.default({
	  webphoneStatus: _webphoneStatus2.default,
	  callStatus: _callStatus2.default
	});
	
	var Webphone = function (_RcModule) {
	  (0, _inherits3.default)(Webphone, _RcModule);
	
	  function Webphone(options) {
	    var _this2 = this;
	
	    (0, _classCallCheck3.default)(this, Webphone);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Webphone).call(this, (0, _extends3.default)({}, options, {
	      actions: _webphoneActions2.default
	    })));
	
	    var api = options.api;
	    var platform = options.platform;
	    var settings = options.settings;
	
	    _this[symbols.api] = api;
	    _this[symbols.platform] = platform;
	    _this[symbols.emitter] = new _eventEmitter2.default();
	    _this[symbols.settings] = settings;
	
	    _this.currentSession = null;
	    _this.isRegistered = false;
	
	    // TODO: commented out until setting module completed
	    // settings.registerReducer('webphone', getWebphoneReducer())
	
	    platform.on(platform.events.loginSuccess, (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
	      return _regenerator2.default.wrap(function _callee10$(_context10) {
	        while (1) {
	          switch (_context10.prev = _context10.next) {
	            case 0:
	              _context10.next = 2;
	              return initPhoneInstance.call(_this);
	
	            case 2:
	              _this[symbols.phoneInstance] = _context10.sent;
	
	              _this[symbols.phoneInstance].userAgent.on('registered', function () {
	                // sip will fire multiple registered events, only dispatch one register action to state.
	                // TODO: is this isRegistered state needed to be store as instance variable
	                //       or just check store state
	                if (!_this.isRegistered) {
	                  _this.store.dispatch({
	                    type: _this.actions.registerSuccess
	                  });
	                }
	                _this.isRegistered = _this[symbols.phoneInstance].userAgent.isRegistered();
	              });
	              _this[symbols.phoneInstance].userAgent.on('unregistered', function () {
	                _this.isRegistered = _this[symbols.phoneInstance].userAgent.isRegistered();
	                _this.store.dispatch({
	                  type: _this.actions.unregister,
	                  operation: {
	                    type: _callActions2.default.clear
	                  }
	                });
	              });
	              _this[symbols.phoneInstance].userAgent.on('registrationFailed', function (error) {
	                _this.store.dispatch({
	                  type: _this.actions.registerError,
	                  error: error
	                });
	              });
	              _this[symbols.phoneInstance].userAgent.on('invite', function (session) {
	                _this.currentSession = session;
	                _this.listenSessionEvents();
	                console.log(session);
	                _this.store.dispatch({
	                  type: _this.actions.callIncoming,
	                  payload: {
	                    remoteIdentity: session.remoteIdentity,
	                    localIdentity: session.localIdentity
	                  }
	                });
	              });
	
	            case 7:
	            case 'end':
	              return _context10.stop();
	          }
	        }
	      }, _callee10, _this2);
	    })));
	    return _this;
	  }
	
	  (0, _createClass3.default)(Webphone, [{
	    key: 'call',
	
	
	    /**
	     * Make a phone call, this method should be called in registerSuccess state
	     * @param {string} toNumber
	     * @param {string} [fromNumber]
	     * @return {Session}
	     */
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11(_ref) {
	        var toNumber = _ref.toNumber;
	        var fromNumber = _ref.fromNumber;
	        var media = _ref.media;
	        return _regenerator2.default.wrap(function _callee11$(_context11) {
	          while (1) {
	            switch (_context11.prev = _context11.next) {
	              case 0:
	                if (this[symbols.phoneInstance]) {
	                  _context11.next = 2;
	                  break;
	                }
	
	                throw Error('not registered');
	
	              case 2:
	                this.store.dispatch({
	                  type: this.actions.call,
	                  payload: {
	                    toNumber: toNumber,
	                    fromNumber: fromNumber
	                  }
	                });
	                this.currentSession = this[symbols.phoneInstance].userAgent.invite(toNumber, {
	                  media: {
	                    render: media
	                  }
	                });
	                this.listenSessionEvents();
	                _context11.prev = 5;
	                _context11.next = 8;
	                return this.currentSession;
	
	              case 8:
	                _context11.next = 14;
	                break;
	
	              case 10:
	                _context11.prev = 10;
	                _context11.t0 = _context11['catch'](5);
	
	                console.error(_context11.t0);
	                this.store.dispatch({
	                  type: this.actions.callError,
	                  error: _context11.t0
	                });
	
	              case 14:
	                return _context11.abrupt('return', this.currentSession);
	
	              case 15:
	              case 'end':
	                return _context11.stop();
	            }
	          }
	        }, _callee11, this, [[5, 10]]);
	      }));
	
	      function call(_x12) {
	        return ref.apply(this, arguments);
	      }
	
	      return call;
	    }()
	
	    /**
	     * Accept a phone call, this method should be called when call is incoming
	     * @param {Object} media, see https://github.com/ringcentral/ringcentral-web-phone#accepting-incoming-call
	     * @return {Promise}
	     */
	
	  }, {
	    key: 'accept',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12(media) {
	        return _regenerator2.default.wrap(function _callee12$(_context12) {
	          while (1) {
	            switch (_context12.prev = _context12.next) {
	              case 0:
	                this.checkSession();
	                _context12.prev = 1;
	                _context12.next = 4;
	                return this.currentSession.accept(media);
	
	              case 4:
	                _context12.next = 9;
	                break;
	
	              case 6:
	                _context12.prev = 6;
	                _context12.t0 = _context12['catch'](1);
	
	                // TODO
	                console.error(_context12.t0);
	
	              case 9:
	              case 'end':
	                return _context12.stop();
	            }
	          }
	        }, _callee12, this, [[1, 6]]);
	      }));
	
	      function accept(_x13) {
	        return ref.apply(this, arguments);
	      }
	
	      return accept;
	    }()
	  }, {
	    key: 'bye',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
	        return _regenerator2.default.wrap(function _callee13$(_context13) {
	          while (1) {
	            switch (_context13.prev = _context13.next) {
	              case 0:
	                this.checkSession();
	                _context13.prev = 1;
	                _context13.next = 4;
	                return this.currentSession.terminate();
	
	              case 4:
	                _context13.next = 9;
	                break;
	
	              case 6:
	                _context13.prev = 6;
	                _context13.t0 = _context13['catch'](1);
	
	                // TODO
	                console.error(_context13.t0);
	
	              case 9:
	              case 'end':
	                return _context13.stop();
	            }
	          }
	        }, _callee13, this, [[1, 6]]);
	      }));
	
	      function bye() {
	        return ref.apply(this, arguments);
	      }
	
	      return bye;
	    }()
	  }, {
	    key: 'record',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14(flag) {
	        return _regenerator2.default.wrap(function _callee14$(_context14) {
	          while (1) {
	            switch (_context14.prev = _context14.next) {
	              case 0:
	                operations.call(this, 'record', flag);
	
	              case 1:
	              case 'end':
	                return _context14.stop();
	            }
	          }
	        }, _callee14, this);
	      }));
	
	      function record(_x14) {
	        return ref.apply(this, arguments);
	      }
	
	      return record;
	    }()
	  }, {
	    key: 'mute',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15(flag) {
	        return _regenerator2.default.wrap(function _callee15$(_context15) {
	          while (1) {
	            switch (_context15.prev = _context15.next) {
	              case 0:
	                operations.call(this, 'mute', flag);
	
	              case 1:
	              case 'end':
	                return _context15.stop();
	            }
	          }
	        }, _callee15, this);
	      }));
	
	      function mute(_x15) {
	        return ref.apply(this, arguments);
	      }
	
	      return mute;
	    }()
	  }, {
	    key: 'hold',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee16(flag) {
	        return _regenerator2.default.wrap(function _callee16$(_context16) {
	          while (1) {
	            switch (_context16.prev = _context16.next) {
	              case 0:
	                operations.call(this, 'hold', flag);
	
	              case 1:
	              case 'end':
	                return _context16.stop();
	            }
	          }
	        }, _callee16, this);
	      }));
	
	      function hold(_x16) {
	        return ref.apply(this, arguments);
	      }
	
	      return hold;
	    }()
	  }, {
	    key: 'park',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee17(flag) {
	        return _regenerator2.default.wrap(function _callee17$(_context17) {
	          while (1) {
	            switch (_context17.prev = _context17.next) {
	              case 0:
	                operations.call(this, 'park', flag);
	
	              case 1:
	              case 'end':
	                return _context17.stop();
	            }
	          }
	        }, _callee17, this);
	      }));
	
	      function park(_x17) {
	        return ref.apply(this, arguments);
	      }
	
	      return park;
	    }()
	  }, {
	    key: 'transfer',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee18(number) {
	        return _regenerator2.default.wrap(function _callee18$(_context18) {
	          while (1) {
	            switch (_context18.prev = _context18.next) {
	              case 0:
	                operations.call(this, 'transfer', number);
	
	              case 1:
	              case 'end':
	                return _context18.stop();
	            }
	          }
	        }, _callee18, this);
	      }));
	
	      function transfer(_x18) {
	        return ref.apply(this, arguments);
	      }
	
	      return transfer;
	    }()
	  }, {
	    key: 'flip',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee19(number) {
	        return _regenerator2.default.wrap(function _callee19$(_context19) {
	          while (1) {
	            switch (_context19.prev = _context19.next) {
	              case 0:
	                operations.call(this, 'flip', number);
	
	              case 1:
	              case 'end':
	                return _context19.stop();
	            }
	          }
	        }, _callee19, this);
	      }));
	
	      function flip(_x19) {
	        return ref.apply(this, arguments);
	      }
	
	      return flip;
	    }()
	  }, {
	    key: 'dtmf',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee20(number) {
	        return _regenerator2.default.wrap(function _callee20$(_context20) {
	          while (1) {
	            switch (_context20.prev = _context20.next) {
	              case 0:
	                operations.call(this, 'dtmf', number);
	
	              case 1:
	              case 'end':
	                return _context20.stop();
	            }
	          }
	        }, _callee20, this);
	      }));
	
	      function dtmf(_x20) {
	        return ref.apply(this, arguments);
	      }
	
	      return dtmf;
	    }()
	  }, {
	    key: 'checkSession',
	    value: function checkSession() {
	      if (!this.currentSession) {
	        this.store.dispatch({
	          type: this.actions.sessionError
	        });
	        throw Error('No active session');
	      }
	    }
	
	    /**
	     * Internal method for listen session events
	     */
	
	  }, {
	    key: 'listenSessionEvents',
	    value: function listenSessionEvents() {
	      var _this3 = this;
	
	      this.currentSession.on('accepted', function (response) {
	        console.log(response);
	        // accepted event for outbound call will returne a incomingResponse
	        if (response.data) {
	          _this3.store.dispatch({
	            type: _this3.actions.callConnect,
	            payload: {
	              remoteIdentity: response.to,
	              localIdentity: response.from
	            }
	          });
	          // accepted event for inbound call will only contain a row sip data
	        } else {
	          _this3.store.dispatch({
	            type: _this3.actions.callAccept
	          });
	        }
	      });
	      // all situation about call terminated except 'call cancel'
	      this.currentSession.on('terminated', function (response, cause) {
	        console.log(response);
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd,
	          error: cause
	        });
	        _this3.currentSession = null;
	      });
	      // when we call out and cancel the phone call
	      this.currentSession.on('cancel', function (response, cause) {
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd,
	          error: cause
	        });
	        _this3.currentSession = null;
	      });
	      // should not need
	      this.currentSession.on('bye', function (response) {
	        console.log(response);
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd
	        });
	        _this3.currentSession = null;
	      });
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _webphoneReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'enums',
	    get: function get() {
	      return ENUMS;
	    }
	  }]);
	  return Webphone;
	}(_rcModule2.default);
	
	exports.default = Webphone;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['register', 'registerSuccess', 'registerError', 'unregister',
	
	// outbound call
	'call', 'callConnect',
	// inbound call
	'callAccept', 'callIncoming', 'callEnd', 'callError', 'callOperation',
	// no active session
	'sessionError']);

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap([
	// operational error
	'error',
	// unregister, clear operational state
	'clear',
	// operation
	'flip', 'record', 'stopRecord', 'hold', 'unhold', 'mute', 'unmute', 'park', 'transfer', 'forward', 'dtmf']);

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _webphoneActions = __webpack_require__(204);
	
	var _webphoneActions2 = _interopRequireDefault(_webphoneActions);
	
	var _webphoneStatus = __webpack_require__(207);
	
	var _webphoneStatus2 = _interopRequireDefault(_webphoneStatus);
	
	var _callReducer = __webpack_require__(208);
	
	var _callReducer2 = _interopRequireDefault(_callReducer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  status: _webphoneStatus2.default.preRegister,
	  // assign from UI
	  toNumber: '',
	  fromNumber: '',
	  // sip info return from sip server
	  remoteIdentity: null,
	  localIdentity: null,
	  operation: (0, _callReducer2.default)(),
	  error: null
	};
	
	function getReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_webphoneActions2.default, prefix);
	
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      case actions.registerSuccess:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.registerSuccessed
	        });
	      case actions.registerError:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.registerFailed,
	          error: action.error
	        });
	      case actions.unregister:
	        return initialState;
	      case actions.call:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnecting,
	          toNumber: action.payload.toNumber,
	          fromNumber: action.payload.fromNumber
	        });
	      case actions.callIncoming:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callIncoming,
	          remoteIdentity: action.payload.remoteIdentity,
	          localIdentity: action.payload.localIdentity
	        });
	      // TODO: update fromNumber, toNumber
	      case actions.callConnect:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnected,
	          remoteIdentity: action.payload.remoteIdentity,
	          localIdentity: action.payload.localIdentity
	        });
	      case actions.callAccept:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnected
	        });
	      case actions.callEnd:
	        return (0, _assign2.default)({}, initialState, {
	          status: _webphoneStatus2.default.registerSuccessed,
	          error: action.error
	        });
	      case actions.callError:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callFailed,
	          error: action.error
	        });
	      case actions.callOperation:
	        return (0, _assign2.default)({}, state, {
	          operation: (0, _callReducer2.default)(state.operation, action.operation)
	        });
	      case actions.sessionError:
	        return (0, _assign2.default)({}, initialState, {
	          error: action.error
	        });
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  // For registering
	  preRegister: 'PRE_REGISTER',
	  registerSuccessed: 'REGISTER_SUCCESSED',
	  registerFailed: 'REGISTER_FAILED',
	  // For callout and active call
	  callConnecting: 'CALL_CONNECTING',
	  callConnected: 'CALL_CONNECTED',
	  callFailed: 'CALL_FAILED',
	  // For incoming call
	  callIncoming: 'CALL_INCOMING'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = function (state, action) {
	  if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	  if (!action) return state;
	  switch (action.type) {
	
	    case _callActions2.default.error:
	      return (0, _assign2.default)({}, state, {
	        error: action.error
	      });
	    case _callActions2.default.clear:
	      return (0, _assign2.default)({}, initialState);
	    case _callActions2.default.record:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.recording) ? state.status : state.status.concat(_callStatus2.default.recording)
	      });
	    case _callActions2.default.stopRecord:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.recording)
	      });
	    case _callActions2.default.mute:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.muted) ? state.status : state.status.concat(_callStatus2.default.muted)
	      });
	    case _callActions2.default.unmute:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.muted)
	      });
	    case _callActions2.default.hold:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.holding) ? state.status : state.status.concat(_callStatus2.default.holding),
	        disabled: ['park', 'record']
	      });
	    case _callActions2.default.unhold:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.holding),
	        disabled: []
	      });
	    case _callActions2.default.park:
	      // https://en.wikipedia.org/wiki/Call_parking
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.parker) ? state.status : state.status.concat(_callStatus2.default.parker)
	      });
	    case _callActions2.default.transfer:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.transfered) ? state.status : state.status.concat(_callStatus2.default.transfered),
	        transferTaget: action.payload.number
	      });
	    case _callActions2.default.flip:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.flip) ? state.status : state.status.concat(_callStatus2.default.flip),
	        flipTarget: action.payload.number
	      });
	    case _callActions2.default.dtmf:
	      // TODO: clarify park action
	      return (0, _assign2.default)({}, state, {
	        status: state.status.concat(_callStatus2.default.parked),
	        dtmfNumber: action.payload.number
	      });
	
	    default:
	      return state;
	  }
	};
	
	var _callActions = __webpack_require__(205);
	
	var _callActions2 = _interopRequireDefault(_callActions);
	
	var _callStatus = __webpack_require__(209);
	
	var _callStatus2 = _interopRequireDefault(_callStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function contain(arr, ele) {
	  return arr.indexOf(ele) > -1;
	}
	
	function remove(arr, ele) {
	  if (contain(arr, ele)) {
	    arr.splice(arr.indexOf(ele), 1);
	  }
	  return arr;
	}
	
	var initialState = {
	  // operations which is enable
	  status: [],
	  // some operations will disable another, such as 'hold'
	  disabled: [],
	  // some operations have infomation need to be stored
	  transferTaget: null,
	  flipTarget: null,
	  dtmfNumber: null,
	  // operation error
	  error: null
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  flip: 'FLIPED',
	  recording: 'RECORDING',
	  holding: 'HOLDING',
	  muted: 'MUTED',
	  parked: 'PARKED',
	  transfered: 'TRANSFERED',
	  forwarded: 'FOWARDED'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(211)], __WEBPACK_AMD_DEFINE_RESULT__ = function(SIP) {
	            return factory(SIP);
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === 'object') {
	        module.exports = factory(require('sip.js'));
	        module.exports.default = module.exports; //ES6
	    } else {
	        root.RingCentral = root.RingCentral || {};
	        root.RingCentral.WebPhone = factory(root.SIP);
	    }
	}(this, function(SIP) {
	
	    var messages = {
	        park: {reqid: 1, command: 'callpark'},
	        startRecord: {reqid: 2, command: 'startcallrecord'},
	        stopRecord: {reqid: 3, command: 'stopcallrecord'},
	        flip: {reqid: 3, command: 'callflip', target: ''},
	        monitor: {reqid: 4, command: 'monitor'},
	        barge: {reqid: 5, command: 'barge'},
	        whisper: {reqid: 6, command: 'whisper'},
	        takeover: {reqid: 7, command: 'takeover'}
	    };
	
	    var responseTimeout = 10000;
	
	    function uuid() {
	        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
	            return v.toString(16);
	        });
	    }
	
	    function delay(ms) {
	        return new Promise(function(resolve, reject) {
	            setTimeout(resolve, ms);
	        });
	    }
	
	    function extend(dst, src) {
	        src = src || {};
	        dst = dst || {};
	        Object.keys(src).forEach(function(k) {
	            dst[k] = src[k];
	        });
	        return dst;
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @param options
	     * @constructor
	     */
	    function AudioHelper(options) {
	
	        options = options || {};
	
	        this._enabled = !!options.enabled;
	        this._incoming = options.incoming || '../audio/incoming.ogg';
	        this._outgoing = options.outgoing || '../audio/outgoing.ogg';
	        this._audio = {};
	
	    }
	
	    AudioHelper.prototype._playSound = function(url, val, volume) {
	
	        if (!this._enabled) return this;
	
	        if (!this._audio[url]) {
	            if (val) {
	                this._audio[url] = new Audio();
	                this._audio[url].src = url;
	                this._audio[url].loop = true;
	                this._audio[url].volume = volume;
	                this._audio[url].play();
	            }
	        } else {
	            if (val) {
	                this._audio[url].currentTime = 0;
	                this._audio[url].play();
	            } else {
	                this._audio[url].pause();
	            }
	        }
	
	        return this;
	
	    };
	
	    AudioHelper.prototype.playIncoming = function(val) {
	        return this._playSound(this._incoming, val, 0.5);
	    };
	
	    AudioHelper.prototype.playOutgoing = function(val) {
	        return this._playSound(this._outgoing, val, 1);
	    };
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @param {object} regData
	     * @param {object} [options]
	     * @param {string} [options.uuid]
	     * @param {string} [options.appKey]
	     * @param {string} [options.appName]
	     * @param {string} [options.appVersion]
	     * @param {string} [options.audioHelper]
	     * @param {string} [options.onSession] fired each time UserAgent starts working with session
	     * @constructor
	     */
	    function WebPhone(regData, options) {
	
	        regData = regData || {};
	        options = options || {};
	
	        this.sipInfo = regData.sipInfo[0] || regData.sipInfo;
	        this.sipFlags = regData.sipFlags;
	
	        var id = options.uuid || localStorage.getItem('rc-webPhone-uuid') || uuid(); //TODO Make configurable
	        localStorage.setItem('rc-webPhone-uuid', id);
	
	        this.endpointHeader = 'P-rc-endpoint-id: ' + id;
	
	        var configuration = {
	            uri: 'sip:' + this.sipInfo.username + '@' + this.sipInfo.domain,
	            wsServers: this.sipInfo.outboundProxy && this.sipInfo.transport
	                ? this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxy
	                : this.sipInfo.wsServers,
	            authorizationUser: this.sipInfo.authorizationId,
	            password: this.sipInfo.password,
	            traceSip: true,
	            stunServers: this.sipInfo.stunServers || ['stun:74.125.194.127:19302'], //FIXME Hardcoded?
	            turnServers: [],
	            log: {
	                level: options.logLevel || 1 //FIXME LOG LEVEL 3
	            },
	            domain: this.sipInfo.domain,
	            autostart: true,
	            register: true,
	            iceGatheringTimeout: this.sipInfo.iceGatheringTimeout || 3000
	        };
	
	        this.appKey = options.appKey;
	        this.appName = options.appName;
	        this.appVersion = options.appVersion;
	        this.userAgentHeader = 'RC-User-Agent: ' +
	                               (options.appName ? (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' : '') +
	                               'RCWEBPHONE/' + WebPhone.version;
	
	        this.clientIdHeader = 'Client-id:' + options.appKey;
	
	        this.userAgent = new SIP.UA(configuration).register({
	            extraHeaders: [
	                this.endpointHeader,
	                this.userAgentHeader,
	                this.clientIdHeader
	            ]
	        });
	
	        this.userAgent.endpointHeader = this.endpointHeader;
	        this.userAgent.userAgentHeader = this.userAgentHeader;
	        this.userAgent.clientIdHeader = this.clientIdHeader;
	        this.userAgent.sipInfo = this.sipInfo;
	
	        this.userAgent.__invite = this.userAgent.invite;
	        this.userAgent.invite = invite;
	
	        this.userAgent.on('invite', function(session) {
	            this.userAgent.audioHelper.playIncoming(true);
	            patchSession(session);
	        }.bind(this));
	
	        this.userAgent.audioHelper = new AudioHelper(options.audioHelper);
	
	        this.userAgent.onSession = options.onSession || null;
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    WebPhone.version = '0.3.1';
	    WebPhone.uuid = uuid;
	    WebPhone.delay = delay;
	    WebPhone.extend = extend;
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    function patchSession(session) {
	
	        if (session.__patched) return session;
	
	        session.__patched = true;
	
	        session.__sendRequest = session.sendRequest;
	        session.__receiveRequest = session.receiveRequest;
	        session.__receiveInviteResponse = session.receiveInviteResponse;
	        session.__receiveResponse = session.receiveResponse;
	        session.__accept = session.accept;
	        session.__hold = session.hold;
	        session.__unhold = session.unhold;
	        session.__dtmf = session.dtmf;
	
	        session.sendRequest = sendRequest;
	        session.receiveRequest = receiveRequest;
	        session.receiveInviteResponse = receiveInviteResponse;
	        session.receiveResponse = receiveResponse;
	        session.accept = accept;
	        session.hold = hold;
	        session.unhold = unhold;
	        session.dtmf = dtmf;
	
	        session.blindTransfer = blindTransfer;
	        session.transfer = transfer;
	        session.park = park;
	        session.forward = forward;
	        session.startRecord = startRecord;
	        session.stopRecord = stopRecord;
	        session.flip = flip;
	
	        session.on('replaced', patchSession);
	        // session.on('connecting', onConnecting);
	
	        // Audio
	        session.on('accepted', stopPlaying);
	        session.on('rejected', stopPlaying);
	        session.on('bye', stopPlaying);
	        session.on('terminated', stopPlaying);
	        session.on('cancel', stopPlaying);
	        session.on('failed', stopPlaying);
	        session.on('replaced', stopPlaying);
	        session.mediaHandler.on('iceConnectionCompleted', stopPlaying);
	        session.mediaHandler.on('iceConnectionFailed', stopPlaying);
	
	        function stopPlaying() {
	            session.ua.audioHelper.playOutgoing(false);
	            session.ua.audioHelper.playIncoming(false);
	            session.removeListener('accepted', stopPlaying);
	            session.removeListener('rejected', stopPlaying);
	            session.removeListener('bye', stopPlaying);
	            session.removeListener('terminated', stopPlaying);
	            session.removeListener('cancel', stopPlaying);
	            session.removeListener('failed', stopPlaying);
	            session.removeListener('replaced', stopPlaying);
	            session.mediaHandler.removeListener('iceConnectionCompleted', stopPlaying);
	            session.mediaHandler.removeListener('iceConnectionFailed', stopPlaying);
	        }
	
	        if (session.ua.onSession) session.ua.onSession(session);
	
	        return session;
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {object} command
	     * @param {object} [options]
	     * @return {Promise}
	     */
	    function sendReceive(session, command, options) {
	
	        options = options || {};
	
	        extend(command, options);
	
	        var cseq = null;
	
	        return new Promise(function(resolve, reject) {
	
	            session.sendRequest(SIP.C.INFO, {
	                body: JSON.stringify({
	                    request: command
	                }),
	                extraHeaders: [
	                    "Content-Type: application/json;charset=utf-8",
	                    session.ua.userAgentHeader,
	                    session.ua.endpointHeader,
	                    session.ua.clientIdHeader
	                ],
	                receiveResponse: function(response) {
	                    var timeout = null;
	                    if (response.status_code === 200) {
	                        cseq = response.cseq;
	                        var onInfo = function(request) {
	                            if (response.cseq === cseq) {
	
	                                var body = request && request.body || '{}';
	                                var obj;
	
	                                try {
	                                    obj = JSON.parse(body);
	                                } catch (e) {
	                                    obj = {};
	                                }
	
	                                if (obj.response && obj.response.command === command.command) {
	                                    if (obj.response.result) {
	                                        if (obj.response.result.code == 0) {
	                                            return resolve(obj.response.result);
	                                        } else {
	                                            return reject(obj.response.result);
	                                        }
	                                    }
	                                }
	                                timeout && clearTimeout(timeout);
	                                session.removeListener('RC_SIP_INFO', onInfo);
	                                resolve(null); //FIXME What to resolve
	                            }
	                        };
	
	                        timeout = setTimeout(function() {
	                            reject(new Error('Timeout: no reply'));
	                            session.removeListener('RC_SIP_INFO', onInfo);
	                        }, responseTimeout);
	                        session.on('RC_SIP_INFO', onInfo);
	                    }
	                    else {
	                        reject(new Error('The INFO response status code is: ' + response.status_code + ' (waiting for 200)'));
	                    }
	                }
	            });
	
	        });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    function sendRequest(type, config) {
	        if (type == SIP.C.PRACK) {
	            type = SIP.C.ACK;
	        }
	        return this.__sendRequest(type, config);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * Fired each time a provisional (100-199) response is received.
	     * Early media is supported by SIP.js library
	     * But in case it is sent without 100rel support we play it manually
	     * STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported
	     *
	     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1072388
	     * @param {SIP.Session} session
	     * @param response
	     * @param {funciton} cb
	     */
	    function patch100rel(session, response, cb) {
	
	        //Early media is supported by SIP.js library
	        //But in case it is sent without 100rel support we play it manually
	        //STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported
	        if (session.status !== SIP.Session.C.STATUS_EARLY_MEDIA && response.status_code === 183 && typeof(response.body) === 'string' && response.body.indexOf('\n') !== -1) {
	            if (!response.hasHeader('require')) response.setHeader('require', '100rel');
	        }
	
	        return cb.call(session, response);
	
	    }
	
	    /**
	     * @this {SIP.Session}
	     * @param response
	     * @return {*}
	     */
	    function receiveInviteResponse(response) {
	        return patch100rel(this, response, this.__receiveInviteResponse);
	    }
	
	    /**
	     * @this {SIP.Session}
	     * @param response
	     * @return {*}
	     */
	    function receiveResponse(response) {
	        return patch100rel(this, response, this.__receiveResponse);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {boolean} flag
	     * @return {Promise}
	     */
	    function setRecord(session, flag) {
	
	        var message = !!flag
	            ? messages.startRecord
	            : messages.stopRecord;
	
	        if ((session.__onRecord && !flag) || (!session.__onRecord && flag)) {
	            return sendReceive(session, message)
	                .then(function(data) {
	                    session.__onRecord = !!flag;
	                    return data;
	                });
	        }
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {boolean} flag
	     * @return {Promise}
	     */
	    function setHold(session, flag) {
	        return new Promise(function(resolve, reject) {
	
	            var options = {
	                eventHandlers: {
	                    succeeded: resolve,
	                    failed: reject
	                }
	            };
	
	            if (flag) {
	                session.__hold(options);
	            } else {
	                session.__unhold(options);
	            }
	
	        });
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.UA}
	     * @param number
	     * @param options
	     * @return {SIP.Session}
	     */
	    function invite(number, options) {
	
	        var ua = this;
	
	        options = options || {};
	        options.extraHeaders = options.extraHeaders || [];
	
	        options.extraHeaders.push(ua.userAgentHeader);
	        options.extraHeaders.push(ua.endpointHeader);
	        options.extraHeaders.push(ua.clientIdHeader);
	
	        options.extraHeaders.push('P-Asserted-Identity: sip:' + (options.fromNumber || ua.sipInfo.username) + '@' + ua.sipInfo.domain); //FIXME Phone Number
	
	        //FIXME Backend should know it already
	        if (options.homeCountryId) { options.extraHeaders.push('P-rc-country-id: ' + options.homeCountryId); }
	
	        options.media = options.media || {};
	        options.media.constraints = options.media.constraints || {audio: true, video: false};
	
	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};
	
	        ua.audioHelper.playOutgoing(true);
	
	        return patchSession(ua.__invite(number, options));
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param request
	     * @return {*}
	     */
	    function receiveRequest(request) {
	        var session = this;
	        switch (request.method) {
	            case SIP.C.INFO:
	                session.emit('RC_SIP_INFO', request);
	                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case
	                if (session.status === SIP.Session.C.STATUS_CONFIRMED || session.status === SIP.Session.C.STATUS_WAITING_FOR_ACK) {
	                    var contentType = request.getHeader('content-type');
	                    if (contentType.match(/^application\/json/i)) {
	                        request.reply(200);
	                        return session;
	                    }
	                }
	                break;
	            //Refresh invite should not be rejected with 488
	            case SIP.C.INVITE:
	                if (session.status === SIP.Session.C.STATUS_CONFIRMED) {
	                    if (request.call_id && session.dialog && session.dialog.id && request.call_id == session.dialog.id.call_id) {
	                        //TODO: check that SDP did not change
	                        session.logger.log('re-INVITE received');
	                        var localSDP = session.mediaHandler.peerConnection.localDescription.sdp;
	                        request.reply(200, null, ['Contact: ' + session.contact], localSDP, function() {
	                            session.status = SIP.Session.C.STATUS_WAITING_FOR_ACK;
	                            session.setInvite2xxTimer(request, localSDP);
	                            session.setACKTimer();
	                        });
	                        return session;
	                    }
	                    //else will be rejected with 488 by SIP.js
	                }
	                break;
	            //We need to analize NOTIFY messages sometimes, so we fire an event
	            case SIP.C.NOTIFY:
	                session.emit('RC_SIP_NOTIFY', request);
	                break;
	        }
	        return session.__receiveRequest.apply(session, arguments);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {object} options
	     * @return {Promise}
	     */
	    function accept(options) {
	
	        var session = this;
	
	        options = options || {};
	        options.extraHeaders = options.extraHeaders || [];
	
	        options.extraHeaders.push(session.ua.userAgentHeader);
	        options.extraHeaders.push(session.ua.endpointHeader);
	        options.extraHeaders.push(session.ua.clientIdHeader);
	
	        options.media = options.media || {};
	        options.media.constraints = options.media.constraints || {audio: true, video: false};
	
	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};
	
	        return new Promise(function(resolve, reject) {
	
	            function onAnswered() {
	                resolve(session);
	                session.removeListener('failed', onFail);
	            }
	
	            function onFail(e) {
	                reject(e);
	                session.removeListener('accepted', onAnswered);
	            }
	
	            //TODO More events?
	            session.once('accepted', onAnswered);
	            session.once('failed', onFail);
	
	            session.__accept(options);
	
	        });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @param {string} dtmf
	     * @param {number} duration
	     * @return {Promise}
	     */
	    function dtmf(dtmf, duration) {
	        var session = this;
	        duration = parseInt(duration) || 1000;
	        var peer = session.mediaHandler.peerConnection;
	        var stream = session.getLocalStreams()[0];
	        var dtmfSender = peer.createDTMFSender(stream.getAudioTracks()[0]);
	        if (dtmfSender !== undefined && dtmfSender.canInsertDTMF) {
	            return dtmfSender.insertDTMF(dtmf, duration);
	        }
	        throw new Error('Send DTMF failed: ' + (!dtmfSender ? 'no sender' : (!dtmfSender.canInsertDTMF ? 'can\'t insert DTMF' : 'Unknown')));
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @return {Promise}
	     */
	    function hold() {
	        return setHold(this, true);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @return {Promise}
	     */
	    function unhold() {
	        return setHold(this, false);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @param {string} target
	     * @param {object} options
	     * @return {Promise}
	     */
	    function blindTransfer(target, options) {
	
	        options = options || {};
	
	        var session = this;
	        var extraHeaders = options.extraHeaders || [];
	        var originalTarget = target;
	
	        return new Promise(function(resolve, reject) {
	            //Blind Transfer is taken from SIP.js source
	
	            // Check Session Status
	            if (session.status !== SIP.Session.C.STATUS_CONFIRMED) {
	                throw new SIP.Exceptions.InvalidStateError(session.status);
	            }
	
	            // normalizeTarget allows instances of SIP.URI to pass through unaltered,
	            // so try to make one ahead of time
	            try {
	                target = SIP.Grammar.parse(target, 'Refer_To').uri || target;
	            } catch (e) {
	                session.logger.debug(".refer() cannot parse Refer_To from", target);
	                session.logger.debug("...falling through to normalizeTarget()");
	            }
	
	            // Check target validity
	            target = session.ua.normalizeTarget(target);
	            if (!target) {
	                throw new TypeError('Invalid target: ' + originalTarget);
	            }
	
	            extraHeaders.push('Contact: ' + session.contact);
	            extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	            extraHeaders.push('Refer-To: ' + target);
	            extraHeaders.push(session.ua.userAgentHeader);
	            extraHeaders.push(session.ua.endpointHeader);
	            extraHeaders.push(session.ua.clientIdHeader);
	
	            // Send the request
	            session.sendRequest(SIP.C.REFER, {
	                extraHeaders: extraHeaders,
	                body: options.body,
	                receiveResponse: function(response) {
	                    var timeout = null;
	                    if (response.status_code === 202) {
	                        var callId = response.call_id;
	
	                        var onNotify = function(request) {
	                            if (request.call_id === callId) {
	                                var body = request && request.body || '';
	                                switch (true) {
	                                    case /1[0-9]{2}/.test(body):
	                                        request.reply(200);
	                                        break;
	                                    case /2[0-9]{2}/.test(body):
	                                        session.terminate();
	                                        clearTimeout(timeout);
	                                        session.removeListener('RC_SIP_NOTIFY', onNotify);
	                                        resolve();
	                                        break;
	                                    default:
	                                        reject(body);
	                                        break;
	                                }
	                            }
	                        };
	
	                        timeout = setTimeout(function() {
	                            reject(new Error('Timeout: no reply'));
	                            session.removeListener('RC_SIP_NOTIFY', onNotify);
	                        }, responseTimeout);
	                        session.on('RC_SIP_NOTIFY', onNotify);
	                    }
	                    else {
	                        reject(new Error('The response status code is: ' + response.status_code + ' (waiting for 202)'));
	                    }
	                }
	            });
	
	        });
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {string} target
	     * @param {object} options
	     * @return {Promise}
	     */
	    function transfer(target, options) {
	
	        var session = this;
	
	        return (session.isOnHold() ? Promise.resolve(null) : session.hold())
	            .then(function() { return delay(300); })
	            .then(function() {
	                return session.blindTransfer(target, options);
	            });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {string} target
	     * @param {object} acceptOptions
	     * @param {object} [transferOptions]
	     * @return {Promise}
	     */
	    function forward(target, acceptOptions, transferOptions) {
	
	        var interval = null,
	            session = this;
	
	        return session.accept(acceptOptions)
	            .then(function() {
	
	                return new Promise(function(resolve, reject) {
	                    interval = setInterval(function() {
	                        if (session.status === 12) {
	                            clearInterval(interval);
	                            session.mute();
	                            setTimeout(function() {
	                                resolve(session.transfer(target, transferOptions));
	                            }, 700);
	                        }
	                    }, 50);
	                });
	
	            });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function startRecord() {
	        return setRecord(this, true);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function stopRecord() {
	        return setRecord(this, false);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param target
	     * @return {Promise}
	     */
	    function flip(target) {
	        return sendReceive(this, messages.flip, {target: target});
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function park() {
	        return sendReceive(this, messages.park);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    return WebPhone;
	
	}));

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = __webpack_require__(212)(__webpack_require__(245));


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name SIP
	 * @namespace
	 */
	"use strict";
	
	module.exports = function (environment) {
	
	var pkg = __webpack_require__(213);
	
	var SIP = Object.defineProperties({}, {
	  version: {
	    get: function(){ return pkg.version; }
	  },
	  name: {
	    get: function(){ return pkg.title; }
	  }
	});
	
	__webpack_require__(214)(SIP, environment);
	SIP.LoggerFactory = __webpack_require__(215)(environment.console);
	SIP.EventEmitter = __webpack_require__(216)(environment.console);
	SIP.C = __webpack_require__(218)(SIP.name, SIP.version);
	SIP.Exceptions = __webpack_require__(219);
	SIP.Timers = __webpack_require__(220)(environment.timers);
	SIP.Transport = environment.Transport(SIP, environment.WebSocket);
	__webpack_require__(221)(SIP);
	__webpack_require__(222)(SIP);
	__webpack_require__(223)(SIP);
	__webpack_require__(224)(SIP);
	__webpack_require__(225)(SIP);
	__webpack_require__(226)(SIP);
	__webpack_require__(228)(SIP);
	__webpack_require__(229)(SIP);
	SIP.MediaHandler = __webpack_require__(230)(SIP.EventEmitter);
	__webpack_require__(231)(SIP);
	__webpack_require__(232)(SIP);
	__webpack_require__(233)(SIP, environment);
	__webpack_require__(235)(SIP);
	SIP.WebRTC = __webpack_require__(236)(SIP, environment);
	__webpack_require__(239)(SIP, environment);
	SIP.Hacks = __webpack_require__(240)(SIP);
	__webpack_require__(241)(SIP);
	SIP.DigestAuthentication = __webpack_require__(242)(SIP.Utils);
	SIP.Grammar = __webpack_require__(243)(SIP);
	
	return SIP;
	};


/***/ },
/* 213 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				"sip.js@0.7.5",
				"/Users/howard.zhang/Sites/ringcentral-js-integration-commons/node_modules/ringcentral-web-phone"
			]
		],
		"_from": "sip.js@0.7.5",
		"_id": "sip.js@0.7.5",
		"_inCache": true,
		"_installable": true,
		"_location": "/sip.js",
		"_nodeVersion": "4.4.3",
		"_npmOperationalInternal": {
			"host": "packages-12-west.internal.npmjs.com",
			"tmp": "tmp/sip.js-0.7.5.tgz_1461594418690_0.5839933124370873"
		},
		"_npmUser": {
			"email": "1212jtraceur@gmail.com",
			"name": "josephfrazier"
		},
		"_npmVersion": "2.15.1",
		"_phantomChildren": {},
		"_requested": {
			"name": "sip.js",
			"raw": "sip.js@0.7.5",
			"rawSpec": "0.7.5",
			"scope": null,
			"spec": "0.7.5",
			"type": "version"
		},
		"_requiredBy": [
			"/ringcentral-web-phone"
		],
		"_resolved": "https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz",
		"_shasum": "86ace7051594f91b4551bdb8120a16c44962d3a2",
		"_shrinkwrap": null,
		"_spec": "sip.js@0.7.5",
		"_where": "/Users/howard.zhang/Sites/ringcentral-js-integration-commons/node_modules/ringcentral-web-phone",
		"author": {
			"email": "developer@onsip.com",
			"name": "OnSIP",
			"url": "http://sipjs.com/authors/"
		},
		"browser": {
			"./src/environment.js": "./src/environment_browser.js"
		},
		"bugs": {
			"url": "https://github.com/onsip/SIP.js/issues"
		},
		"contributors": [
			{
				"url": "https://github.com/onsip/SIP.js/blob/master/THANKS.md"
			}
		],
		"dependencies": {
			"promiscuous": "^0.6.0",
			"ws": "^0.6.4"
		},
		"description": "A simple, intuitive, and powerful JavaScript signaling library",
		"devDependencies": {
			"beefy": "^2.1.5",
			"browserify": "^4.1.8",
			"grunt": "~0.4.0",
			"grunt-browserify": "^4.0.1",
			"grunt-cli": "~0.1.6",
			"grunt-contrib-copy": "^0.5.0",
			"grunt-contrib-jasmine": "^0.9.2",
			"grunt-contrib-jshint": ">0.5.0",
			"grunt-contrib-uglify": "~0.2.0",
			"grunt-peg": "~1.3.1",
			"grunt-trimtrailingspaces": "^0.4.0",
			"pegjs": "^0.8.0"
		},
		"directories": {},
		"dist": {
			"shasum": "86ace7051594f91b4551bdb8120a16c44962d3a2",
			"tarball": "https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz"
		},
		"engines": {
			"node": ">=0.8"
		},
		"gitHead": "bae44bd0359f4d70ded309a32361f04a04e78d6e",
		"homepage": "http://sipjs.com",
		"keywords": [
			"sip",
			"websocket",
			"webrtc",
			"library",
			"javascript"
		],
		"license": "MIT",
		"main": "src/index.js",
		"maintainers": [
			{
				"email": "eric.green@onsip.com",
				"name": "egreen_onsip"
			},
			{
				"email": "james@onsip.com",
				"name": "james-criscuolo"
			},
			{
				"email": "1212jtraceur@gmail.com",
				"name": "josephfrazier"
			}
		],
		"name": "sip.js",
		"optionalDependencies": {
			"promiscuous": "^0.6.0"
		},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/onsip/SIP.js.git"
		},
		"scripts": {
			"build": "grunt build",
			"prepublish": "cd src/Grammar && mkdir -p dist && pegjs --extra-options-file peg.json src/Grammar.pegjs dist/Grammar.js",
			"repl": "beefy test/repl.js --open",
			"test": "grunt travis --verbose"
		},
		"title": "SIP.js",
		"version": "0.7.5"
	};

/***/ },
/* 214 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Utils
	 */
	
	module.exports = function (SIP, environment) {
	var Utils;
	
	Utils= {
	
	  Promise: environment.Promise,
	
	  defer: function defer () {
	    var deferred = {};
	    deferred.promise = new Utils.Promise(function (resolve, reject) {
	      deferred.resolve = resolve;
	      deferred.reject = reject;
	    });
	    return deferred;
	  },
	
	  promisify: function promisify (object, methodName, callbacksFirst) {
	    var oldMethod = object[methodName];
	    return function promisifiedMethod (arg, onSuccess, onFailure) {
	      return new Utils.Promise(function (resolve, reject) {
	        var oldArgs = [arg, resolve, reject];
	        if (callbacksFirst) {
	          oldArgs = [resolve, reject, arg];
	        }
	        oldMethod.apply(object, oldArgs);
	      }).then(onSuccess, onFailure);
	    };
	  },
	
	  augment: function (object, constructor, args, override) {
	    var idx, proto;
	
	    // Add public properties from constructor's prototype onto object
	    proto = constructor.prototype;
	    for (idx in proto) {
	      if (override || object[idx] === undefined) {
	        object[idx] = proto[idx];
	      }
	    }
	
	    // Construct the object as though it were just created by constructor
	    constructor.apply(object, args);
	  },
	
	  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {
	    if (isDeprecated && options[loser]) {
	      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');
	    }
	
	    if (options[winner] && options[loser]) {
	      logger.warn(winner + ' overriding ' + loser);
	    }
	
	    options[winner] = options[winner] || options[loser] || defaultValue;
	  },
	
	  str_utf8_length: function(string) {
	    return encodeURIComponent(string).replace(/%[A-F\d]{2}/g, 'U').length;
	  },
	
	  generateFakeSDP: function(body) {
	    if (!body) {
	      return;
	    }
	
	    var start = body.indexOf('o=');
	    var end = body.indexOf('\r\n', start);
	
	    return 'v=0\r\n' + body.slice(start, end) + '\r\ns=-\r\nt=0 0\r\nc=IN IP4 0.0.0.0';
	  },
	
	  isFunction: function(fn) {
	    if (fn !== undefined) {
	      return Object.prototype.toString.call(fn) === '[object Function]';
	    } else {
	      return false;
	    }
	  },
	
	  isDecimal: function (num) {
	    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));
	  },
	
	  createRandomToken: function(size, base) {
	    var i, r,
	      token = '';
	
	    base = base || 32;
	
	    for( i=0; i < size; i++ ) {
	      r = Math.random() * base|0;
	      token += r.toString(base);
	    }
	
	    return token;
	  },
	
	  newTag: function() {
	    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);
	  },
	
	  // http://stackoverflow.com/users/109538/broofa
	  newUUID: function() {
	    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
	      return v.toString(16);
	    });
	
	    return UUID;
	  },
	
	  hostType: function(host) {
	    if (!host) {
	      return;
	    } else {
	      host = SIP.Grammar.parse(host,'host');
	      if (host !== -1) {
	        return host.host_type;
	      }
	    }
	  },
	
	  /**
	  * Normalize SIP URI.
	  * NOTE: It does not allow a SIP URI without username.
	  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
	  * Detects the domain part (if given) and properly hex-escapes the user portion.
	  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
	  * @private
	  * @param {String} target
	  * @param {String} [domain]
	  */
	  normalizeTarget: function(target, domain) {
	    var uri, target_array, target_user, target_domain;
	
	    // If no target is given then raise an error.
	    if (!target) {
	      return;
	    // If a SIP.URI instance is given then return it.
	    } else if (target instanceof SIP.URI) {
	      return target;
	
	    // If a string is given split it by '@':
	    // - Last fragment is the desired domain.
	    // - Otherwise append the given domain argument.
	    } else if (typeof target === 'string') {
	      target_array = target.split('@');
	
	      switch(target_array.length) {
	        case 1:
	          if (!domain) {
	            return;
	          }
	          target_user = target;
	          target_domain = domain;
	          break;
	        case 2:
	          target_user = target_array[0];
	          target_domain = target_array[1];
	          break;
	        default:
	          target_user = target_array.slice(0, target_array.length-1).join('@');
	          target_domain = target_array[target_array.length-1];
	      }
	
	      // Remove the URI scheme (if present).
	      target_user = target_user.replace(/^(sips?|tel):/i, '');
	
	      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
	      if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(target_user)) {
	        target_user = target_user.replace(/[\-\.\(\)]/g, '');
	      }
	
	      // Build the complete SIP URI.
	      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;
	
	      // Finally parse the resulting URI.
	      if (uri = SIP.URI.parse(target)) {
	        return uri;
	      } else {
	        return;
	      }
	    } else {
	      return;
	    }
	  },
	
	  /**
	  * Hex-escape a SIP URI user.
	  * @private
	  * @param {String} user
	  */
	  escapeUser: function(user) {
	    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
	    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');
	  },
	
	  headerize: function(string) {
	    var exceptions = {
	      'Call-Id': 'Call-ID',
	      'Cseq': 'CSeq',
	      'Min-Se': 'Min-SE',
	      'Rack': 'RAck',
	      'Rseq': 'RSeq',
	      'Www-Authenticate': 'WWW-Authenticate'
	      },
	      name = string.toLowerCase().replace(/_/g,'-').split('-'),
	      hname = '',
	      parts = name.length, part;
	
	    for (part = 0; part < parts; part++) {
	      if (part !== 0) {
	        hname +='-';
	      }
	      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);
	    }
	    if (exceptions[hname]) {
	      hname = exceptions[hname];
	    }
	    return hname;
	  },
	
	  sipErrorCause: function(status_code) {
	    var cause;
	
	    for (cause in SIP.C.SIP_ERROR_CAUSES) {
	      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {
	        return SIP.C.causes[cause];
	      }
	    }
	
	    return SIP.C.causes.SIP_FAILURE_CODE;
	  },
	
	  getReasonPhrase: function getReasonPhrase (code, specific) {
	    return specific || SIP.C.REASON_PHRASE[code] || '';
	  },
	
	  getReasonHeaderValue: function getReasonHeaderValue (code, reason) {
	    reason = SIP.Utils.getReasonPhrase(code, reason);
	    return 'SIP ;cause=' + code + ' ;text="' + reason + '"';
	  },
	
	  getCancelReason: function getCancelReason (code, reason) {
	    if (code && code < 200 || code > 699) {
	      throw new TypeError('Invalid status_code: ' + code);
	    } else if (code) {
	      return SIP.Utils.getReasonHeaderValue(code, reason);
	    }
	  },
	
	  buildStatusLine: function buildStatusLine (code, reason) {
	    code = code || null;
	    reason = reason || null;
	
	    // Validate code and reason values
	    if (!code || (code < 100 || code > 699)) {
	      throw new TypeError('Invalid status_code: '+ code);
	    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
	      throw new TypeError('Invalid reason_phrase: '+ reason);
	    }
	
	    reason = Utils.getReasonPhrase(code, reason);
	
	    return 'SIP/2.0 ' + code + ' ' + reason + '\r\n';
	  },
	
	  /**
	  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)
	  * @private
	  */
	  getRandomTestNetIP: function() {
	    function getOctet(from,to) {
	      return Math.floor(Math.random()*(to-from+1)+from);
	    }
	    return '192.0.2.' + getOctet(1, 254);
	  },
	
	  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info
	  calculateMD5: function(string) {
	    function RotateLeft(lValue, iShiftBits) {
	      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
	    }
	
	    function AddUnsigned(lX,lY) {
	      var lX4,lY4,lX8,lY8,lResult;
	      lX8 = (lX & 0x80000000);
	      lY8 = (lY & 0x80000000);
	      lX4 = (lX & 0x40000000);
	      lY4 = (lY & 0x40000000);
	      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
	      if (lX4 & lY4) {
	        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
	      }
	      if (lX4 | lY4) {
	        if (lResult & 0x40000000) {
	          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
	        } else {
	          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
	        }
	      } else {
	        return (lResult ^ lX8 ^ lY8);
	      }
	    }
	
	    function F(x,y,z) {
	      return (x & y) | ((~x) & z);
	    }
	
	    function G(x,y,z) {
	      return (x & z) | (y & (~z));
	    }
	
	    function H(x,y,z) {
	      return (x ^ y ^ z);
	    }
	
	    function I(x,y,z) {
	      return (y ^ (x | (~z)));
	    }
	
	    function FF(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function GG(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function HH(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function II(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function ConvertToWordArray(string) {
	      var lWordCount;
	      var lMessageLength = string.length;
	      var lNumberOfWords_temp1=lMessageLength + 8;
	      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
	      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
	      var lWordArray=Array(lNumberOfWords-1);
	      var lBytePosition = 0;
	      var lByteCount = 0;
	      while ( lByteCount < lMessageLength ) {
	        lWordCount = (lByteCount-(lByteCount % 4))/4;
	        lBytePosition = (lByteCount % 4)*8;
	        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
	        lByteCount++;
	      }
	      lWordCount = (lByteCount-(lByteCount % 4))/4;
	      lBytePosition = (lByteCount % 4)*8;
	      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
	      lWordArray[lNumberOfWords-2] = lMessageLength<<3;
	      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
	      return lWordArray;
	    }
	
	    function WordToHex(lValue) {
	      var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
	      for (lCount = 0;lCount<=3;lCount++) {
	        lByte = (lValue>>>(lCount*8)) & 255;
	        WordToHexValue_temp = "0" + lByte.toString(16);
	        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
	      }
	      return WordToHexValue;
	    }
	
	    function Utf8Encode(string) {
	      string = string.replace(/\r\n/g,"\n");
	      var utftext = "";
	
	      for (var n = 0; n < string.length; n++) {
	        var c = string.charCodeAt(n);
	
	        if (c < 128) {
	          utftext += String.fromCharCode(c);
	        }
	        else if((c > 127) && (c < 2048)) {
	          utftext += String.fromCharCode((c >> 6) | 192);
	          utftext += String.fromCharCode((c & 63) | 128);
	        }
	        else {
	          utftext += String.fromCharCode((c >> 12) | 224);
	          utftext += String.fromCharCode(((c >> 6) & 63) | 128);
	          utftext += String.fromCharCode((c & 63) | 128);
	        }
	      }
	      return utftext;
	    }
	
	    var x=[];
	    var k,AA,BB,CC,DD,a,b,c,d;
	    var S11=7, S12=12, S13=17, S14=22;
	    var S21=5, S22=9 , S23=14, S24=20;
	    var S31=4, S32=11, S33=16, S34=23;
	    var S41=6, S42=10, S43=15, S44=21;
	
	    string = Utf8Encode(string);
	
	    x = ConvertToWordArray(string);
	
	    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;
	
	    for (k=0;k<x.length;k+=16) {
	      AA=a; BB=b; CC=c; DD=d;
	      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);
	      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
	      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
	      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
	      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
	      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
	      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
	      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
	      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
	      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
	      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
	      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
	      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
	      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
	      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
	      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
	      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
	      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
	      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
	      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);
	      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
	      d=GG(d,a,b,c,x[k+10],S22,0x2441453);
	      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
	      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
	      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
	      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
	      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
	      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
	      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
	      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
	      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
	      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
	      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
	      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
	      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
	      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
	      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
	      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
	      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
	      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
	      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
	      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);
	      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
	      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
	      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
	      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
	      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
	      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
	      a=II(a,b,c,d,x[k+0], S41,0xF4292244);
	      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
	      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
	      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
	      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
	      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
	      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
	      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
	      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
	      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
	      c=II(c,d,a,b,x[k+6], S43,0xA3014314);
	      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
	      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
	      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
	      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
	      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
	      a=AddUnsigned(a,AA);
	      b=AddUnsigned(b,BB);
	      c=AddUnsigned(c,CC);
	      d=AddUnsigned(d,DD);
	    }
	
	    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);
	
	    return temp.toLowerCase();
	  }
	};
	
	SIP.Utils = Utils;
	};


/***/ },
/* 215 */
/***/ function(module, exports) {

	"use strict";
	var levels = {
	  'error': 0,
	  'warn': 1,
	  'log': 2,
	  'debug': 3
	};
	
	module.exports = function (console) {
	
	var LoggerFactory = function () {
	  var logger,
	    level = 2,
	    builtinEnabled = true,
	    connector = null;
	
	    this.loggers = {};
	
	    logger = this.getLogger('sip.loggerfactory');
	
	
	  Object.defineProperties(this, {
	    builtinEnabled: {
	      get: function(){ return builtinEnabled; },
	      set: function(value){
	        if (typeof value === 'boolean') {
	          builtinEnabled = value;
	        } else {
	          logger.error('invalid "builtinEnabled" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    },
	
	    level: {
	      get: function() {return level; },
	      set: function(value) {
	        if (value >= 0 && value <=3) {
	          level = value;
	        } else if (value > 3) {
	          level = 3;
	        } else if (levels.hasOwnProperty(value)) {
	          level = levels[value];
	        } else {
	          logger.error('invalid "level" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    },
	
	    connector: {
	      get: function() {return connector; },
	      set: function(value){
	        if(value === null || value === "" || value === undefined) {
	          connector = null;
	        } else if (typeof value === 'function') {
	          connector = value;
	        } else {
	          logger.error('invalid "connector" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    }
	  });
	};
	
	LoggerFactory.prototype.print = function(target, category, label, content) {
	  if (typeof content === 'string') {
	    var prefix = [new Date(), category];
	    if (label) {
	      prefix.push(label);
	    }
	    content = prefix.concat(content).join(' | ');
	  }
	  target.call(console, content);
	};
	
	function Logger (logger, category, label) {
	  this.logger = logger;
	  this.category = category;
	  this.label = label;
	}
	
	Object.keys(levels).forEach(function (targetName) {
	  Logger.prototype[targetName] = function (content) {
	    this.logger[targetName](this.category, this.label, content);
	  };
	
	  LoggerFactory.prototype[targetName] = function (category, label, content) {
	    if (this.level >= levels[targetName]) {
	      if (this.builtinEnabled) {
	        this.print(console[targetName], category, label, content);
	      }
	
	      if (this.connector) {
	        this.connector(targetName, category, label, content);
	      }
	    }
	  };
	});
	
	LoggerFactory.prototype.getLogger = function(category, label) {
	  var logger;
	
	  if (label && this.level === 3) {
	    return new Logger(this, category, label);
	  } else if (this.loggers[category]) {
	    return this.loggers[category];
	  } else {
	    logger = new Logger(this, category);
	    this.loggers[category] = logger;
	    return logger;
	  }
	};
	
	return LoggerFactory;
	};


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var NodeEventEmitter = __webpack_require__(217).EventEmitter;
	
	module.exports = function (console) {
	
	// Don't use `new SIP.EventEmitter()` for inheriting.
	// Use Object.create(SIP.EventEmitter.prototoype);
	function EventEmitter () {
	  NodeEventEmitter.call(this);
	}
	
	EventEmitter.prototype = Object.create(NodeEventEmitter.prototype, {
	  constructor: {
	    value: EventEmitter,
	    enumerable: false,
	    writable: true,
	    configurable: true
	  }
	});
	
	EventEmitter.prototype.off = function off (eventName, listener) {
	  var warning = '';
	  warning += 'SIP.EventEmitter#off is deprecated and may be removed in future SIP.js versions.\n';
	  warning += 'Please use removeListener or removeAllListeners instead.\n';
	  warning += 'See here for more details:\n';
	  warning += 'http://nodejs.org/api/events.html#events_emitter_removelistener_event_listener';
	  console.warn(warning);
	
	  if (arguments.length < 2) {
	    return this.removeAllListeners.apply(this, arguments);
	  } else {
	    return this.removeListener(eventName, listener);
	  }
	};
	
	return EventEmitter;
	
	};


/***/ },
/* 217 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 218 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Constants
	 */
	
	/**
	 * SIP Constants.
	 * @augments SIP
	 */
	
	module.exports = function (name, version) {
	return {
	  USER_AGENT: name +'/'+ version,
	
	  // SIP scheme
	  SIP:  'sip',
	  SIPS: 'sips',
	
	  // End and Failure causes
	  causes: {
	    // Generic error causes
	    CONNECTION_ERROR:         'Connection Error',
	    REQUEST_TIMEOUT:          'Request Timeout',
	    SIP_FAILURE_CODE:         'SIP Failure Code',
	    INTERNAL_ERROR:           'Internal Error',
	
	    // SIP error causes
	    BUSY:                     'Busy',
	    REJECTED:                 'Rejected',
	    REDIRECTED:               'Redirected',
	    UNAVAILABLE:              'Unavailable',
	    NOT_FOUND:                'Not Found',
	    ADDRESS_INCOMPLETE:       'Address Incomplete',
	    INCOMPATIBLE_SDP:         'Incompatible SDP',
	    AUTHENTICATION_ERROR:     'Authentication Error',
	    DIALOG_ERROR:             'Dialog Error',
	
	    // Session error causes
	    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',
	    WEBRTC_ERROR:             'WebRTC Error',
	    CANCELED:                 'Canceled',
	    NO_ANSWER:                'No Answer',
	    EXPIRES:                  'Expires',
	    NO_ACK:                   'No ACK',
	    NO_PRACK:                 'No PRACK',
	    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
	    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',
	    RTP_TIMEOUT:              'RTP Timeout'
	  },
	
	  supported: {
	    UNSUPPORTED:        'none',
	    SUPPORTED:          'supported',
	    REQUIRED:           'required'
	  },
	
	  SIP_ERROR_CAUSES: {
	    REDIRECTED: [300,301,302,305,380],
	    BUSY: [486,600],
	    REJECTED: [403,603],
	    NOT_FOUND: [404,604],
	    UNAVAILABLE: [480,410,408,430],
	    ADDRESS_INCOMPLETE: [484],
	    INCOMPATIBLE_SDP: [488,606],
	    AUTHENTICATION_ERROR:[401,407]
	  },
	
	  // SIP Methods
	  ACK:        'ACK',
	  BYE:        'BYE',
	  CANCEL:     'CANCEL',
	  INFO:       'INFO',
	  INVITE:     'INVITE',
	  MESSAGE:    'MESSAGE',
	  NOTIFY:     'NOTIFY',
	  OPTIONS:    'OPTIONS',
	  REGISTER:   'REGISTER',
	  UPDATE:     'UPDATE',
	  SUBSCRIBE:  'SUBSCRIBE',
	  REFER:      'REFER',
	  PRACK:      'PRACK',
	
	  /* SIP Response Reasons
	   * DOC: http://www.iana.org/assignments/sip-parameters
	   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
	   */
	  REASON_PHRASE: {
	    100: 'Trying',
	    180: 'Ringing',
	    181: 'Call Is Being Forwarded',
	    182: 'Queued',
	    183: 'Session Progress',
	    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199
	    200: 'OK',
	    202: 'Accepted',  // RFC 3265
	    204: 'No Notification',  //RFC 5839
	    300: 'Multiple Choices',
	    301: 'Moved Permanently',
	    302: 'Moved Temporarily',
	    305: 'Use Proxy',
	    380: 'Alternative Service',
	    400: 'Bad Request',
	    401: 'Unauthorized',
	    402: 'Payment Required',
	    403: 'Forbidden',
	    404: 'Not Found',
	    405: 'Method Not Allowed',
	    406: 'Not Acceptable',
	    407: 'Proxy Authentication Required',
	    408: 'Request Timeout',
	    410: 'Gone',
	    412: 'Conditional Request Failed',  // RFC 3903
	    413: 'Request Entity Too Large',
	    414: 'Request-URI Too Long',
	    415: 'Unsupported Media Type',
	    416: 'Unsupported URI Scheme',
	    417: 'Unknown Resource-Priority',  // RFC 4412
	    420: 'Bad Extension',
	    421: 'Extension Required',
	    422: 'Session Interval Too Small',  // RFC 4028
	    423: 'Interval Too Brief',
	    428: 'Use Identity Header',  // RFC 4474
	    429: 'Provide Referrer Identity',  // RFC 3892
	    430: 'Flow Failed',  // RFC 5626
	    433: 'Anonymity Disallowed',  // RFC 5079
	    436: 'Bad Identity-Info',  // RFC 4474
	    437: 'Unsupported Certificate',  // RFC 4744
	    438: 'Invalid Identity Header',  // RFC 4744
	    439: 'First Hop Lacks Outbound Support',  // RFC 5626
	    440: 'Max-Breadth Exceeded',  // RFC 5393
	    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events
	    470: 'Consent Needed',  // RFC 5360
	    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.
	    480: 'Temporarily Unavailable',
	    481: 'Call/Transaction Does Not Exist',
	    482: 'Loop Detected',
	    483: 'Too Many Hops',
	    484: 'Address Incomplete',
	    485: 'Ambiguous',
	    486: 'Busy Here',
	    487: 'Request Terminated',
	    488: 'Not Acceptable Here',
	    489: 'Bad Event',  // RFC 3265
	    491: 'Request Pending',
	    493: 'Undecipherable',
	    494: 'Security Agreement Required',  // RFC 3329
	    500: 'Internal Server Error',
	    501: 'Not Implemented',
	    502: 'Bad Gateway',
	    503: 'Service Unavailable',
	    504: 'Server Time-out',
	    505: 'Version Not Supported',
	    513: 'Message Too Large',
	    580: 'Precondition Failure',  // RFC 3312
	    600: 'Busy Everywhere',
	    603: 'Decline',
	    604: 'Does Not Exist Anywhere',
	    606: 'Not Acceptable'
	  },
	
	  /* SIP Option Tags
	   * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4
	   */
	  OPTION_TAGS: {
	    '100rel':                   true,  // RFC 3262
	    199:                        true,  // RFC 6228
	    answermode:                 true,  // RFC 5373
	    'early-session':            true,  // RFC 3959
	    eventlist:                  true,  // RFC 4662
	    explicitsub:                true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
	    'from-change':              true,  // RFC 4916
	    'geolocation-http':         true,  // RFC 6442
	    'geolocation-sip':          true,  // RFC 6442
	    gin:                        true,  // RFC 6140
	    gruu:                       true,  // RFC 5627
	    histinfo:                   true,  // RFC 7044
	    ice:                        true,  // RFC 5768
	    join:                       true,  // RFC 3911
	    'multiple-refer':           true,  // RFC 5368
	    norefersub:                 true,  // RFC 4488
	    nosub:                      true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
	    outbound:                   true,  // RFC 5626
	    path:                       true,  // RFC 3327
	    policy:                     true,  // RFC 6794
	    precondition:               true,  // RFC 3312
	    pref:                       true,  // RFC 3840
	    privacy:                    true,  // RFC 3323
	    'recipient-list-invite':    true,  // RFC 5366
	    'recipient-list-message':   true,  // RFC 5365
	    'recipient-list-subscribe': true,  // RFC 5367
	    replaces:                   true,  // RFC 3891
	    'resource-priority':        true,  // RFC 4412
	    'sdp-anat':                 true,  // RFC 4092
	    'sec-agree':                true,  // RFC 3329
	    tdialog:                    true,  // RFC 4538
	    timer:                      true,  // RFC 4028
	    uui:                        true   // RFC 7433
	  }
	};
	};


/***/ },
/* 219 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Exceptions
	 */
	
	/**
	 * SIP Exceptions.
	 * @augments SIP
	 */
	module.exports = {
	  ConfigurationError: (function(){
	    var exception = function(parameter, value) {
	      this.code = 1;
	      this.name = 'CONFIGURATION_ERROR';
	      this.parameter = parameter;
	      this.value = value;
	      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter "'+ this.parameter +'"';
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  InvalidStateError: (function(){
	    var exception = function(status) {
	      this.code = 2;
	      this.name = 'INVALID_STATE_ERROR';
	      this.status = status;
	      this.message = 'Invalid status: ' + status;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  NotSupportedError: (function(){
	    var exception = function(message) {
	      this.code = 3;
	      this.name = 'NOT_SUPPORTED_ERROR';
	      this.message = message;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  GetDescriptionError: (function(){
	    var exception = function(message) {
	      this.code = 4;
	      this.name = 'GET_DESCRIPTION_ERROR';
	      this.message = message;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }())
	};


/***/ },
/* 220 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP TIMERS
	 */
	
	/**
	 * @augments SIP
	 */
	var
	  T1 = 500,
	  T2 = 4000,
	  T4 = 5000;
	module.exports = function (timers) {
	  var Timers = {
	    T1: T1,
	    T2: T2,
	    T4: T4,
	    TIMER_B: 64 * T1,
	    TIMER_D: 0  * T1,
	    TIMER_F: 64 * T1,
	    TIMER_H: 64 * T1,
	    TIMER_I: 0  * T1,
	    TIMER_J: 0  * T1,
	    TIMER_K: 0  * T4,
	    TIMER_L: 64 * T1,
	    TIMER_M: 64 * T1,
	    TIMER_N: 64 * T1,
	    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1
	  };
	
	  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']
	  .forEach(function (name) {
	    // can't just use timers[name].bind(timers) since it bypasses jasmine's
	    // clock-mocking
	    Timers[name] = function () {
	      return timers[name].apply(timers, arguments);
	    };
	  });
	
	  return Timers;
	};


/***/ },
/* 221 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Message Parser
	 */
	
	/**
	 * Extract and parse every header of a SIP message.
	 * @augments SIP
	 * @namespace
	 */
	module.exports = function (SIP) {
	var Parser;
	
	function getHeader(data, headerStart) {
	  var
	    // 'start' position of the header.
	    start = headerStart,
	    // 'end' position of the header.
	    end = 0,
	    // 'partial end' position of the header.
	    partialEnd = 0;
	
	  //End of message.
	  if (data.substring(start, start + 2).match(/(^\r\n)/)) {
	    return -2;
	  }
	
	  while(end === 0) {
	    // Partial End of Header.
	    partialEnd = data.indexOf('\r\n', start);
	
	    // 'indexOf' returns -1 if the value to be found never occurs.
	    if (partialEnd === -1) {
	      return partialEnd;
	    }
	
	    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
	      // Not the end of the message. Continue from the next position.
	      start = partialEnd + 2;
	    } else {
	      end = partialEnd;
	    }
	  }
	
	  return end;
	}
	
	function parseHeader(message, data, headerStart, headerEnd) {
	  var header, idx, length, parsed,
	    hcolonIndex = data.indexOf(':', headerStart),
	    headerName = data.substring(headerStart, hcolonIndex).trim(),
	    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
	
	  // If header-field is well-known, parse it.
	  switch(headerName.toLowerCase()) {
	    case 'via':
	    case 'v':
	      message.addHeader('via', headerValue);
	      if(message.getHeaders('via').length === 1) {
	        parsed = message.parseHeader('Via');
	        if(parsed) {
	          message.via = parsed;
	          message.via_branch = parsed.branch;
	        }
	      } else {
	        parsed = 0;
	      }
	      break;
	    case 'from':
	    case 'f':
	      message.setHeader('from', headerValue);
	      parsed = message.parseHeader('from');
	      if(parsed) {
	        message.from = parsed;
	        message.from_tag = parsed.getParam('tag');
	      }
	      break;
	    case 'to':
	    case 't':
	      message.setHeader('to', headerValue);
	      parsed = message.parseHeader('to');
	      if(parsed) {
	        message.to = parsed;
	        message.to_tag = parsed.getParam('tag');
	      }
	      break;
	    case 'record-route':
	      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');
	
	      if (parsed === -1) {
	        parsed = undefined;
	        break;
	      }
	
	      length = parsed.length;
	      for (idx = 0; idx < length; idx++) {
	        header = parsed[idx];
	        message.addHeader('record-route', headerValue.substring(header.position, header.offset));
	        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;
	      }
	      break;
	    case 'call-id':
	    case 'i':
	      message.setHeader('call-id', headerValue);
	      parsed = message.parseHeader('call-id');
	      if(parsed) {
	        message.call_id = headerValue;
	      }
	      break;
	    case 'contact':
	    case 'm':
	      parsed = SIP.Grammar.parse(headerValue, 'Contact');
	
	      if (parsed === -1) {
	        parsed = undefined;
	        break;
	      }
	
	      length = parsed.length;
	      for (idx = 0; idx < length; idx++) {
	        header = parsed[idx];
	        message.addHeader('contact', headerValue.substring(header.position, header.offset));
	        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;
	      }
	      break;
	    case 'content-length':
	    case 'l':
	      message.setHeader('content-length', headerValue);
	      parsed = message.parseHeader('content-length');
	      break;
	    case 'content-type':
	    case 'c':
	      message.setHeader('content-type', headerValue);
	      parsed = message.parseHeader('content-type');
	      break;
	    case 'cseq':
	      message.setHeader('cseq', headerValue);
	      parsed = message.parseHeader('cseq');
	      if(parsed) {
	        message.cseq = parsed.value;
	      }
	      if(message instanceof SIP.IncomingResponse) {
	        message.method = parsed.method;
	      }
	      break;
	    case 'max-forwards':
	      message.setHeader('max-forwards', headerValue);
	      parsed = message.parseHeader('max-forwards');
	      break;
	    case 'www-authenticate':
	      message.setHeader('www-authenticate', headerValue);
	      parsed = message.parseHeader('www-authenticate');
	      break;
	    case 'proxy-authenticate':
	      message.setHeader('proxy-authenticate', headerValue);
	      parsed = message.parseHeader('proxy-authenticate');
	      break;
	    case 'refer-to':
	    case 'r':
	      message.setHeader('refer-to', headerValue);
	      parsed = message.parseHeader('refer-to');
	      if (parsed) {
	        message.refer_to = parsed;
	      }
	      break;
	    default:
	      // Do not parse this header.
	      message.setHeader(headerName, headerValue);
	      parsed = 0;
	  }
	
	  if (parsed === undefined) {
	    return {
	      error: 'error parsing header "'+ headerName +'"'
	    };
	  } else {
	    return true;
	  }
	}
	
	/** Parse SIP Message
	 * @function
	 * @param {String} message SIP message.
	 * @param {Object} logger object.
	 * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}
	 */
	Parser = {};
	Parser.parseMessage = function(data, ua) {
	  var message, firstLine, contentLength, bodyStart, parsed,
	    headerStart = 0,
	    headerEnd = data.indexOf('\r\n'),
	    logger = ua.getLogger('sip.parser');
	
	  if(headerEnd === -1) {
	    logger.warn('no CRLF found, not a SIP message, discarded');
	    return;
	  }
	
	  // Parse first line. Check if it is a Request or a Reply.
	  firstLine = data.substring(0, headerEnd);
	  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');
	
	  if(parsed === -1) {
	    logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
	    return;
	  } else if(!parsed.status_code) {
	    message = new SIP.IncomingRequest(ua);
	    message.method = parsed.method;
	    message.ruri = parsed.uri;
	  } else {
	    message = new SIP.IncomingResponse(ua);
	    message.status_code = parsed.status_code;
	    message.reason_phrase = parsed.reason_phrase;
	  }
	
	  message.data = data;
	  headerStart = headerEnd + 2;
	
	  /* Loop over every line in data. Detect the end of each header and parse
	  * it or simply add to the headers collection.
	  */
	  while(true) {
	    headerEnd = getHeader(data, headerStart);
	
	    // The SIP message has normally finished.
	    if(headerEnd === -2) {
	      bodyStart = headerStart + 2;
	      break;
	    }
	    // data.indexOf returned -1 due to a malformed message.
	    else if(headerEnd === -1) {
	      logger.error('malformed message');
	      return;
	    }
	
	    parsed = parseHeader(message, data, headerStart, headerEnd);
	
	    if(parsed !== true) {
	      logger.error(parsed.error);
	      return;
	    }
	
	    headerStart = headerEnd + 2;
	  }
	
	  /* RFC3261 18.3.
	   * If there are additional bytes in the transport packet
	   * beyond the end of the body, they MUST be discarded.
	   */
	  if(message.hasHeader('content-length')) {
	    contentLength = message.getHeader('content-length');
	    message.body = data.substr(bodyStart, contentLength);
	  } else {
	    message.body = data.substring(bodyStart);
	  }
	
	  return message;
	};
	
	SIP.Parser = Parser;
	};


/***/ },
/* 222 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Message
	 */
	
	module.exports = function (SIP) {
	var
	  OutgoingRequest,
	  IncomingMessage,
	  IncomingRequest,
	  IncomingResponse;
	
	function getSupportedHeader (request) {
	  var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags;
	  var optionTags = [];
	  var optionTagSet = {};
	
	  if (request.method === SIP.C.REGISTER) {
	    optionTags.push('path', 'gruu');
	  } else if (request.method === SIP.C.INVITE &&
	             (request.ua.contact.pub_gruu || request.ua.contact.temp_gruu)) {
	    optionTags.push('gruu');
	  }
	
	  if (request.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {
	    optionTags.push('100rel');
	  }
	  if (request.ua.configuration.replaces === SIP.C.supported.SUPPORTED) {
	    optionTags.push('replaces');
	  }
	
	  optionTags.push('outbound');
	
	  optionTags = optionTags.concat(request.ua.configuration.extraSupported);
	
	  optionTags = optionTags.filter(function(optionTag) {
	    var registered = SIP.C.OPTION_TAGS[optionTag];
	    var unique = !optionTagSet[optionTag];
	    optionTagSet[optionTag] = true;
	    return (registered || allowUnregistered) && unique;
	  });
	
	  return 'Supported: ' + optionTags.join(', ') + '\r\n';
	}
	
	/**
	 * @augments SIP
	 * @class Class for outgoing SIP request.
	 * @param {String} method request method
	 * @param {String} ruri request uri
	 * @param {SIP.UA} ua
	 * @param {Object} params parameters that will have priority over ua.configuration parameters:
	 * <br>
	 *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set
	 * @param {Object} [headers] extra headers
	 * @param {String} [body]
	 */
	OutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {
	  var
	    to,
	    from,
	    call_id,
	    cseq,
	    to_uri,
	    from_uri;
	
	  params = params || {};
	
	  // Mandatory parameters check
	  if(!method || !ruri || !ua) {
	    return null;
	  }
	
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.ua = ua;
	  this.headers = {};
	  this.method = method;
	  this.ruri = ruri;
	  this.body = body;
	  this.extraHeaders = (extraHeaders || []).slice();
	  this.statusCode = params.status_code;
	  this.reasonPhrase = params.reason_phrase;
	
	  // Fill the Common SIP Request Headers
	
	  // Route
	  if (params.route_set) {
	    this.setHeader('route', params.route_set);
	  } else if (ua.configuration.usePreloadedRoute){
	    this.setHeader('route', ua.transport.server.sip_uri);
	  }
	
	  // Via
	  // Empty Via header. Will be filled by the client transaction.
	  this.setHeader('via', '');
	
	  // Max-Forwards
	  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);
	
	  // To
	  to_uri = params.to_uri || ruri;
	  to = (params.to_displayName || params.to_displayName === 0) ? '"' + params.to_displayName + '" ' : '';
	  to += '<' + (to_uri && to_uri.toRaw ? to_uri.toRaw() : to_uri) + '>';
	  to += params.to_tag ? ';tag=' + params.to_tag : '';
	  this.to = new SIP.NameAddrHeader.parse(to);
	  this.setHeader('to', to);
	
	  // From
	  from_uri = params.from_uri || ua.configuration.uri;
	  if (params.from_displayName || params.from_displayName === 0) {
	    from = '"' + params.from_displayName + '" ';
	  } else if (ua.configuration.displayName) {
	    from = '"' + ua.configuration.displayName + '" ';
	  } else {
	    from = '';
	  }
	  from += '<' + (from_uri && from_uri.toRaw ? from_uri.toRaw() : from_uri) + '>;tag=';
	  from += params.from_tag || SIP.Utils.newTag();
	  this.from = new SIP.NameAddrHeader.parse(from);
	  this.setHeader('from', from);
	
	  // Call-ID
	  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));
	  this.call_id = call_id;
	  this.setHeader('call-id', call_id);
	
	  // CSeq
	  cseq = params.cseq || Math.floor(Math.random() * 10000);
	  this.cseq = cseq;
	  this.setHeader('cseq', cseq + ' ' + method);
	};
	
	OutgoingRequest.prototype = {
	  /**
	   * Replace the the given header by the given value.
	   * @param {String} name header name
	   * @param {String | Array} value header value
	   */
	  setHeader: function(name, value) {
	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
	  },
	
	  /**
	   * Get the value of the given header name at the given position.
	   * @param {String} name header name
	   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.
	   */
	  getHeader: function(name) {
	    var regexp, idx,
	      length = this.extraHeaders.length,
	      header = this.headers[SIP.Utils.headerize(name)];
	
	    if(header) {
	      if(header[0]) {
	        return header[0];
	      }
	    } else {
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        header = this.extraHeaders[idx];
	        if (regexp.test(header)) {
	          return header.substring(header.indexOf(':')+1).trim();
	        }
	      }
	    }
	
	    return;
	  },
	
	  /**
	   * Get the header/s of the given name.
	   * @param {String} name header name
	   * @returns {Array} Array with all the headers of the specified name.
	   */
	  getHeaders: function(name) {
	    var idx, length, regexp,
	      header = this.headers[SIP.Utils.headerize(name)],
	      result = [];
	
	    if(header) {
	      length = header.length;
	      for (idx = 0; idx < length; idx++) {
	        result.push(header[idx]);
	      }
	      return result;
	    } else {
	      length = this.extraHeaders.length;
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        header = this.extraHeaders[idx];
	        if (regexp.test(header)) {
	          result.push(header.substring(header.indexOf(':')+1).trim());
	        }
	      }
	      return result;
	    }
	  },
	
	  /**
	   * Verify the existence of the given header.
	   * @param {String} name header name
	   * @returns {boolean} true if header with given name exists, false otherwise
	   */
	  hasHeader: function(name) {
	    var regexp, idx,
	      length = this.extraHeaders.length;
	
	    if (this.headers[SIP.Utils.headerize(name)]) {
	      return true;
	    } else {
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        if (regexp.test(this.extraHeaders[idx])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  },
	
	  toString: function() {
	    var msg = '', header, length, idx;
	
	    msg += this.method + ' ' + (this.ruri.toRaw ? this.ruri.toRaw() : this.ruri) + ' SIP/2.0\r\n';
	
	    for (header in this.headers) {
	      length = this.headers[header].length;
	      for (idx = 0; idx < length; idx++) {
	        msg += header + ': ' + this.headers[header][idx] + '\r\n';
	      }
	    }
	
	    length = this.extraHeaders.length;
	    for (idx = 0; idx < length; idx++) {
	      msg += this.extraHeaders[idx].trim() +'\r\n';
	    }
	
	    msg += getSupportedHeader(this);
	    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	
	    if(this.body) {
	      length = SIP.Utils.str_utf8_length(this.body);
	      msg += 'Content-Length: ' + length + '\r\n\r\n';
	      msg += this.body;
	    } else {
	      msg += 'Content-Length: 0\r\n\r\n';
	    }
	
	    return msg;
	  }
	};
	
	/**
	 * @augments SIP
	 * @class Class for incoming SIP message.
	 */
	IncomingMessage = function(){
	  this.data = null;
	  this.headers = null;
	  this.method =  null;
	  this.via = null;
	  this.via_branch = null;
	  this.call_id = null;
	  this.cseq = null;
	  this.from = null;
	  this.from_tag = null;
	  this.to = null;
	  this.to_tag = null;
	  this.body = null;
	};
	
	IncomingMessage.prototype = {
	  /**
	  * Insert a header of the given name and value into the last position of the
	  * header array.
	  * @param {String} name header name
	  * @param {String} value header value
	  */
	  addHeader: function(name, value) {
	    var header = { raw: value };
	
	    name = SIP.Utils.headerize(name);
	
	    if(this.headers[name]) {
	      this.headers[name].push(header);
	    } else {
	      this.headers[name] = [header];
	    }
	  },
	
	  /**
	   * Get the value of the given header name at the given position.
	   * @param {String} name header name
	   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.
	   */
	  getHeader: function(name) {
	    var header = this.headers[SIP.Utils.headerize(name)];
	
	    if(header) {
	      if(header[0]) {
	        return header[0].raw;
	      }
	    } else {
	      return;
	    }
	  },
	
	  /**
	   * Get the header/s of the given name.
	   * @param {String} name header name
	   * @returns {Array} Array with all the headers of the specified name.
	   */
	  getHeaders: function(name) {
	    var idx, length,
	      header = this.headers[SIP.Utils.headerize(name)],
	      result = [];
	
	    if(!header) {
	      return [];
	    }
	
	    length = header.length;
	    for (idx = 0; idx < length; idx++) {
	      result.push(header[idx].raw);
	    }
	
	    return result;
	  },
	
	  /**
	   * Verify the existence of the given header.
	   * @param {String} name header name
	   * @returns {boolean} true if header with given name exists, false otherwise
	   */
	  hasHeader: function(name) {
	    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;
	  },
	
	  /**
	  * Parse the given header on the given index.
	  * @param {String} name header name
	  * @param {Number} [idx=0] header index
	  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
	  */
	  parseHeader: function(name, idx) {
	    var header, value, parsed;
	
	    name = SIP.Utils.headerize(name);
	
	    idx = idx || 0;
	
	    if(!this.headers[name]) {
	      this.logger.log('header "' + name + '" not present');
	      return;
	    } else if(idx >= this.headers[name].length) {
	      this.logger.log('not so many "' + name + '" headers present');
	      return;
	    }
	
	    header = this.headers[name][idx];
	    value = header.raw;
	
	    if(header.parsed) {
	      return header.parsed;
	    }
	
	    //substitute '-' by '_' for grammar rule matching.
	    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));
	
	    if(parsed === -1) {
	      this.headers[name].splice(idx, 1); //delete from headers
	      this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
	      return;
	    } else {
	      header.parsed = parsed;
	      return parsed;
	    }
	  },
	
	  /**
	   * Message Header attribute selector. Alias of parseHeader.
	   * @param {String} name header name
	   * @param {Number} [idx=0] header index
	   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
	   *
	   * @example
	   * message.s('via',3).port
	   */
	  s: function(name, idx) {
	    return this.parseHeader(name, idx);
	  },
	
	  /**
	  * Replace the value of the given header by the value.
	  * @param {String} name header name
	  * @param {String} value header value
	  */
	  setHeader: function(name, value) {
	    var header = { raw: value };
	    this.headers[SIP.Utils.headerize(name)] = [header];
	  },
	
	  toString: function() {
	    return this.data;
	  }
	};
	
	/**
	 * @augments IncomingMessage
	 * @class Class for incoming SIP request.
	 */
	IncomingRequest = function(ua) {
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.ua = ua;
	  this.headers = {};
	  this.ruri = null;
	  this.transport = null;
	  this.server_transaction = null;
	};
	IncomingRequest.prototype = new IncomingMessage();
	
	/**
	* Stateful reply.
	* @param {Number} code status code
	* @param {String} reason reason phrase
	* @param {Object} headers extra headers
	* @param {String} body body
	* @param {Function} [onSuccess] onSuccess callback
	* @param {Function} [onFailure] onFailure callback
	*/
	IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {
	  var rr, vias, length, idx, response,
	    to = this.getHeader('To'),
	    r = 0,
	    v = 0;
	
	  response = SIP.Utils.buildStatusLine(code, reason);
	  extraHeaders = (extraHeaders || []).slice();
	
	  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {
	    rr = this.getHeaders('record-route');
	    length = rr.length;
	
	    for(r; r < length; r++) {
	      response += 'Record-Route: ' + rr[r] + '\r\n';
	    }
	  }
	
	  vias = this.getHeaders('via');
	  length = vias.length;
	
	  for(v; v < length; v++) {
	    response += 'Via: ' + vias[v] + '\r\n';
	  }
	
	  if(!this.to_tag && code > 100) {
	    to += ';tag=' + SIP.Utils.newTag();
	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
	    to += ';tag=' + this.to_tag;
	  }
	
	  response += 'To: ' + to + '\r\n';
	  response += 'From: ' + this.getHeader('From') + '\r\n';
	  response += 'Call-ID: ' + this.call_id + '\r\n';
	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
	
	  length = extraHeaders.length;
	  for (idx = 0; idx < length; idx++) {
	    response += extraHeaders[idx].trim() +'\r\n';
	  }
	
	  response += getSupportedHeader(this);
	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	
	  if(body) {
	    length = SIP.Utils.str_utf8_length(body);
	    response += 'Content-Type: application/sdp\r\n';
	    response += 'Content-Length: ' + length + '\r\n\r\n';
	    response += body;
	  } else {
	    response += 'Content-Length: ' + 0 + '\r\n\r\n';
	  }
	
	  this.server_transaction.receiveResponse(code, response).then(onSuccess, onFailure);
	
	  return response;
	};
	
	/**
	* Stateless reply.
	* @param {Number} code status code
	* @param {String} reason reason phrase
	*/
	IncomingRequest.prototype.reply_sl = function(code, reason) {
	  var to, response,
	    v = 0,
	    vias = this.getHeaders('via'),
	    length = vias.length;
	
	  response = SIP.Utils.buildStatusLine(code, reason);
	
	  for(v; v < length; v++) {
	    response += 'Via: ' + vias[v] + '\r\n';
	  }
	
	  to = this.getHeader('To');
	
	  if(!this.to_tag && code > 100) {
	    to += ';tag=' + SIP.Utils.newTag();
	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
	    to += ';tag=' + this.to_tag;
	  }
	
	  response += 'To: ' + to + '\r\n';
	  response += 'From: ' + this.getHeader('From') + '\r\n';
	  response += 'Call-ID: ' + this.call_id + '\r\n';
	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	  response += 'Content-Length: ' + 0 + '\r\n\r\n';
	
	  this.transport.send(response);
	};
	
	
	/**
	 * @augments IncomingMessage
	 * @class Class for incoming SIP response.
	 */
	IncomingResponse = function(ua) {
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.headers = {};
	  this.status_code = null;
	  this.reason_phrase = null;
	};
	IncomingResponse.prototype = new IncomingMessage();
	
	SIP.OutgoingRequest = OutgoingRequest;
	SIP.IncomingRequest = IncomingRequest;
	SIP.IncomingResponse = IncomingResponse;
	};


/***/ },
/* 223 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP URI
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP URI.
	 *
	 * @param {String} [scheme]
	 * @param {String} [user]
	 * @param {String} host
	 * @param {String} [port]
	 * @param {Object} [parameters]
	 * @param {Object} [headers]
	 *
	 */
	module.exports = function (SIP) {
	var URI;
	
	URI = function(scheme, user, host, port, parameters, headers) {
	  var param, header, raw, normal;
	
	  // Checks
	  if(!host) {
	    throw new TypeError('missing or invalid "host" parameter');
	  }
	
	  // Initialize parameters
	  scheme = scheme || SIP.C.SIP;
	  this.parameters = {};
	  this.headers = {};
	
	  for (param in parameters) {
	    this.setParam(param, parameters[param]);
	  }
	
	  for (header in headers) {
	    this.setHeader(header, headers[header]);
	  }
	
	  // Raw URI
	  raw = {
	    scheme: scheme,
	    user: user,
	    host: host,
	    port: port
	  };
	
	  // Normalized URI
	  normal = {
	    scheme: scheme.toLowerCase(),
	    user: user,
	    host: host.toLowerCase(),
	    port: port
	  };
	
	  Object.defineProperties(this, {
	    _normal: {
	      get: function() { return normal; }
	    },
	
	    _raw: {
	      get: function() { return raw; }
	    },
	
	    scheme: {
	      get: function() { return normal.scheme; },
	      set: function(value) {
	        raw.scheme = value;
	        normal.scheme = value.toLowerCase();
	      }
	    },
	
	    user: {
	      get: function() { return normal.user; },
	      set: function(value) {
	        normal.user = raw.user = value;
	      }
	    },
	
	    host: {
	      get: function() { return normal.host; },
	      set: function(value) {
	        raw.host = value;
	        normal.host = value.toLowerCase();
	      }
	    },
	
	    aor: {
	      get: function() { return normal.user + '@' + normal.host; }
	    },
	
	    port: {
	      get: function() { return normal.port; },
	      set: function(value) {
	        normal.port = raw.port = value === 0 ? value : (parseInt(value,10) || null);
	      }
	    }
	  });
	};
	
	URI.prototype = {
	  setParam: function(key, value) {
	    if(key) {
	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();
	    }
	  },
	
	  getParam: function(key) {
	    if(key) {
	      return this.parameters[key.toLowerCase()];
	    }
	  },
	
	  hasParam: function(key) {
	    if(key) {
	      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
	    }
	  },
	
	  deleteParam: function(parameter) {
	    var value;
	    parameter = parameter.toLowerCase();
	    if (this.parameters.hasOwnProperty(parameter)) {
	      value = this.parameters[parameter];
	      delete this.parameters[parameter];
	      return value;
	    }
	  },
	
	  clearParams: function() {
	    this.parameters = {};
	  },
	
	  setHeader: function(name, value) {
	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
	  },
	
	  getHeader: function(name) {
	    if(name) {
	      return this.headers[SIP.Utils.headerize(name)];
	    }
	  },
	
	  hasHeader: function(name) {
	    if(name) {
	      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;
	    }
	  },
	
	  deleteHeader: function(header) {
	    var value;
	    header = SIP.Utils.headerize(header);
	    if(this.headers.hasOwnProperty(header)) {
	      value = this.headers[header];
	      delete this.headers[header];
	      return value;
	    }
	  },
	
	  clearHeaders: function() {
	    this.headers = {};
	  },
	
	  clone: function() {
	    return new URI(
	      this._raw.scheme,
	      this._raw.user,
	      this._raw.host,
	      this._raw.port,
	      JSON.parse(JSON.stringify(this.parameters)),
	      JSON.parse(JSON.stringify(this.headers)));
	  },
	
	  toRaw: function() {
	    return this._toString(this._raw);
	  },
	
	  toString: function() {
	    return this._toString(this._normal);
	  },
	
	  _toString: function(uri) {
	    var header, parameter, idx, uriString, headers = [];
	
	    uriString  = uri.scheme + ':';
	    // add slashes if it's not a sip(s) URI
	    if (!uri.scheme.toLowerCase().match("^sips?$")) {
	      uriString += "//";
	    }
	    if (uri.user) {
	      uriString += SIP.Utils.escapeUser(uri.user) + '@';
	    }
	    uriString += uri.host;
	    if (uri.port || uri.port === 0) {
	      uriString += ':' + uri.port;
	    }
	
	    for (parameter in this.parameters) {
	      uriString += ';' + parameter;
	
	      if (this.parameters[parameter] !== null) {
	        uriString += '='+ this.parameters[parameter];
	      }
	    }
	
	    for(header in this.headers) {
	      for(idx in this.headers[header]) {
	        headers.push(header + '=' + this.headers[header][idx]);
	      }
	    }
	
	    if (headers.length > 0) {
	      uriString += '?' + headers.join('&');
	    }
	
	    return uriString;
	  }
	};
	
	
	/**
	  * Parse the given string and returns a SIP.URI instance or undefined if
	  * it is an invalid URI.
	  * @public
	  * @param {String} uri
	  */
	URI.parse = function(uri) {
	  uri = SIP.Grammar.parse(uri,'SIP_URI');
	
	  if (uri !== -1) {
	    return uri;
	  } else {
	    return undefined;
	  }
	};
	
	SIP.URI = URI;
	};


/***/ },
/* 224 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP NameAddrHeader
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a Name Address SIP header.
	 *
	 * @param {SIP.URI} uri
	 * @param {String} [displayName]
	 * @param {Object} [parameters]
	 *
	 */
	module.exports = function (SIP) {
	var NameAddrHeader;
	
	NameAddrHeader = function(uri, displayName, parameters) {
	  var param;
	
	  // Checks
	  if(!uri || !(uri instanceof SIP.URI)) {
	    throw new TypeError('missing or invalid "uri" parameter');
	  }
	
	  // Initialize parameters
	  this.uri = uri;
	  this.parameters = {};
	
	  for (param in parameters) {
	    this.setParam(param, parameters[param]);
	  }
	
	  Object.defineProperties(this, {
	    friendlyName: {
	      get: function() { return this.displayName || uri.aor; }
	    },
	
	    displayName: {
	      get: function() { return displayName; },
	      set: function(value) {
	        displayName = (value === 0) ? '0' : value;
	      }
	    }
	  });
	};
	NameAddrHeader.prototype = {
	  setParam: function (key, value) {
	    if(key) {
	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();
	    }
	  },
	  getParam: SIP.URI.prototype.getParam,
	  hasParam: SIP.URI.prototype.hasParam,
	  deleteParam: SIP.URI.prototype.deleteParam,
	  clearParams: SIP.URI.prototype.clearParams,
	
	  clone: function() {
	    return new NameAddrHeader(
	      this.uri.clone(),
	      this.displayName,
	      JSON.parse(JSON.stringify(this.parameters)));
	  },
	
	  toString: function() {
	    var body, parameter;
	
	    body  = (this.displayName || this.displayName === 0) ? '"' + this.displayName + '" ' : '';
	    body += '<' + this.uri.toString() + '>';
	
	    for (parameter in this.parameters) {
	      body += ';' + parameter;
	
	      if (this.parameters[parameter] !== null) {
	        body += '='+ this.parameters[parameter];
	      }
	    }
	
	    return body;
	  }
	};
	
	
	/**
	  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if
	  * it is an invalid NameAddrHeader.
	  * @public
	  * @param {String} name_addr_header
	  */
	NameAddrHeader.parse = function(name_addr_header) {
	  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');
	
	  if (name_addr_header !== -1) {
	    return name_addr_header;
	  } else {
	    return undefined;
	  }
	};
	
	SIP.NameAddrHeader = NameAddrHeader;
	};


/***/ },
/* 225 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Transactions
	 */
	
	/**
	 * SIP Transactions module.
	 * @augments SIP
	 */
	module.exports = function (SIP) {
	var
	  C = {
	    // Transaction states
	    STATUS_TRYING:     1,
	    STATUS_PROCEEDING: 2,
	    STATUS_CALLING:    3,
	    STATUS_ACCEPTED:   4,
	    STATUS_COMPLETED:  5,
	    STATUS_TERMINATED: 6,
	    STATUS_CONFIRMED:  7,
	
	    // Transaction types
	    NON_INVITE_CLIENT: 'nict',
	    NON_INVITE_SERVER: 'nist',
	    INVITE_CLIENT: 'ict',
	    INVITE_SERVER: 'ist'
	  };
	
	function buildViaHeader (request_sender, transport, id) {
	  var via;
	  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);
	  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;
	  if (request_sender.ua.configuration.forceRport) {
	    via += ';rport';
	  }
	  return via;
	}
	
	/**
	* @augments SIP.Transactions
	* @class Non Invite Client Transaction
	* @param {SIP.RequestSender} request_sender
	* @param {SIP.OutgoingRequest} request
	* @param {SIP.Transport} transport
	*/
	var NonInviteClientTransaction = function(request_sender, request, transport) {
	  var via;
	
	  this.type = C.NON_INVITE_CLIENT;
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	
	  this.request_sender.ua.newTransaction(this);
	};
	NonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	NonInviteClientTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	NonInviteClientTransaction.prototype.send = function() {
	  var tr = this;
	
	  this.stateChanged(C.STATUS_TRYING);
	  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);
	
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	NonInviteClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.F);
	  SIP.Timers.clearTimeout(this.K);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	  this.request_sender.onTransportError();
	};
	
	NonInviteClientTransaction.prototype.timer_F = function() {
	  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	  this.request_sender.onRequestTimeout();
	};
	
	NonInviteClientTransaction.prototype.timer_K = function() {
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	};
	
	NonInviteClientTransaction.prototype.receiveResponse = function(response) {
	  var
	    tr = this,
	    status_code = response.status_code;
	
	  if(status_code < 200) {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        SIP.Timers.clearTimeout(this.F);
	
	        if(status_code === 408) {
	          this.request_sender.onRequestTimeout();
	        } else {
	          this.request_sender.receiveResponse(response);
	        }
	
	        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);
	        break;
	      case C.STATUS_COMPLETED:
	        break;
	    }
	  }
	};
	
	
	
	/**
	* @augments SIP.Transactions
	* @class Invite Client Transaction
	* @param {SIP.RequestSender} request_sender
	* @param {SIP.OutgoingRequest} request
	* @param {SIP.Transport} transport
	*/
	var InviteClientTransaction = function(request_sender, request, transport) {
	  var via,
	    tr = this;
	
	  this.type = C.INVITE_CLIENT;
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	
	  this.request_sender.ua.newTransaction(this);
	
	  // Add the cancel property to the request.
	  //Will be called from the request instance, not the transaction itself.
	  this.request.cancel = function(reason) {
	    tr.cancel_request(tr, reason);
	  };
	};
	InviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	InviteClientTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	InviteClientTransaction.prototype.send = function() {
	  var tr = this;
	  this.stateChanged(C.STATUS_CALLING);
	  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);
	
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	InviteClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.B);
	  SIP.Timers.clearTimeout(this.D);
	  SIP.Timers.clearTimeout(this.M);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	
	  if (this.state !== C.STATUS_ACCEPTED) {
	    this.request_sender.onTransportError();
	  }
	};
	
	// RFC 6026 7.2
	InviteClientTransaction.prototype.timer_M = function() {
	  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);
	
	  if(this.state === C.STATUS_ACCEPTED) {
	    SIP.Timers.clearTimeout(this.B);
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.request_sender.ua.destroyTransaction(this);
	  }
	};
	
	// RFC 3261 17.1.1
	InviteClientTransaction.prototype.timer_B = function() {
	  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);
	  if(this.state === C.STATUS_CALLING) {
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.request_sender.ua.destroyTransaction(this);
	    this.request_sender.onRequestTimeout();
	  }
	};
	
	InviteClientTransaction.prototype.timer_D = function() {
	  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.B);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	};
	
	InviteClientTransaction.prototype.sendACK = function(response) {
	  var tr = this;
	
	  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\r\n';
	  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\r\n';
	
	  if(this.request.headers['Route']) {
	    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\r\n';
	  }
	
	  this.ack += 'To: ' + response.getHeader('to') + '\r\n';
	  this.ack += 'From: ' + this.request.headers['From'].toString() + '\r\n';
	  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\r\n';
	  this.ack += 'Content-Length: 0\r\n';
	  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];
	  this.ack += ' ACK\r\n\r\n';
	
	  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);
	
	  this.transport.send(this.ack);
	};
	
	InviteClientTransaction.prototype.cancel_request = function(tr, reason) {
	  var request = tr.request;
	
	  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\r\n';
	  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\r\n';
	
	  if(this.request.headers['Route']) {
	    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\r\n';
	  }
	
	  this.cancel += 'To: ' + request.headers['To'].toString() + '\r\n';
	  this.cancel += 'From: ' + request.headers['From'].toString() + '\r\n';
	  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\r\n';
	  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +
	  ' CANCEL\r\n';
	
	  if(reason) {
	    this.cancel += 'Reason: ' + reason + '\r\n';
	  }
	
	  this.cancel += 'Content-Length: 0\r\n\r\n';
	
	  // Send only if a provisional response (>100) has been received.
	  if(this.state === C.STATUS_PROCEEDING) {
	    this.transport.send(this.cancel);
	  }
	};
	
	InviteClientTransaction.prototype.receiveResponse = function(response) {
	  var
	  tr = this,
	  status_code = response.status_code;
	
	  if(status_code >= 100 && status_code <= 199) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        this.request_sender.receiveResponse(response);
	        if(this.cancel) {
	          this.transport.send(this.cancel);
	        }
	        break;
	      case C.STATUS_PROCEEDING:
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else if(status_code >= 200 && status_code <= 299) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_ACCEPTED);
	        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);
	        this.request_sender.receiveResponse(response);
	        break;
	      case C.STATUS_ACCEPTED:
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else if(status_code >= 300 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        this.sendACK(response);
	        this.request_sender.receiveResponse(response);
	        break;
	      case C.STATUS_COMPLETED:
	        this.sendACK(response);
	        break;
	    }
	  }
	};
	
	
	/**
	 * @augments SIP.Transactions
	 * @class ACK Client Transaction
	 * @param {SIP.RequestSender} request_sender
	 * @param {SIP.OutgoingRequest} request
	 * @param {SIP.Transport} transport
	 */
	var AckClientTransaction = function(request_sender, request, transport) {
	  var via;
	
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	};
	AckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	AckClientTransaction.prototype.send = function() {
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	AckClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);
	  this.request_sender.onTransportError();
	};
	
	
	/**
	* @augments SIP.Transactions
	* @class Non Invite Server Transaction
	* @param {SIP.IncomingRequest} request
	* @param {SIP.UA} ua
	*/
	var NonInviteServerTransaction = function(request, ua) {
	  this.type = C.NON_INVITE_SERVER;
	  this.id = request.via_branch;
	  this.request = request;
	  this.transport = request.transport;
	  this.ua = ua;
	  this.last_response = '';
	  request.server_transaction = this;
	
	  this.logger = ua.getLogger('sip.transaction.nist', this.id);
	
	  this.state = C.STATUS_TRYING;
	
	  ua.newTransaction(this);
	};
	NonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	NonInviteServerTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	NonInviteServerTransaction.prototype.timer_J = function() {
	  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	NonInviteServerTransaction.prototype.onTransportError = function() {
	  if (!this.transportError) {
	    this.transportError = true;
	
	    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);
	
	    SIP.Timers.clearTimeout(this.J);
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	NonInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
	  var tr = this;
	  var deferred = SIP.Utils.defer();
	
	  if(status_code === 100) {
	    /* RFC 4320 4.1
	     * 'A SIP element MUST NOT
	     * send any provisional response with a
	     * Status-Code other than 100 to a non-INVITE request.'
	     */
	    switch(this.state) {
	      case C.STATUS_TRYING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        if(!this.transport.send(response))  {
	          this.onTransportError();
	        }
	        break;
	      case C.STATUS_PROCEEDING:
	        this.last_response = response;
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          deferred.resolve();
	        }
	        break;
	    }
	  } else if(status_code >= 200 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        this.last_response = response;
	        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          deferred.resolve();
	        }
	        break;
	      case C.STATUS_COMPLETED:
	        break;
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	* @augments SIP.Transactions
	* @class Invite Server Transaction
	* @param {SIP.IncomingRequest} request
	* @param {SIP.UA} ua
	*/
	var InviteServerTransaction = function(request, ua) {
	  this.type = C.INVITE_SERVER;
	  this.id = request.via_branch;
	  this.request = request;
	  this.transport = request.transport;
	  this.ua = ua;
	  this.last_response = '';
	  request.server_transaction = this;
	
	  this.logger = ua.getLogger('sip.transaction.ist', this.id);
	
	  this.state = C.STATUS_PROCEEDING;
	
	  ua.newTransaction(this);
	
	  this.resendProvisionalTimer = null;
	
	  request.reply(100);
	};
	InviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	InviteServerTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	InviteServerTransaction.prototype.timer_H = function() {
	  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);
	
	  if(this.state === C.STATUS_COMPLETED) {
	    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');
	  }
	
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	InviteServerTransaction.prototype.timer_I = function() {
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	// RFC 6026 7.1
	InviteServerTransaction.prototype.timer_L = function() {
	  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);
	
	  if(this.state === C.STATUS_ACCEPTED) {
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	InviteServerTransaction.prototype.onTransportError = function() {
	  if (!this.transportError) {
	    this.transportError = true;
	
	    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);
	
	    if (this.resendProvisionalTimer !== null) {
	      SIP.Timers.clearInterval(this.resendProvisionalTimer);
	      this.resendProvisionalTimer = null;
	    }
	
	    SIP.Timers.clearTimeout(this.L);
	    SIP.Timers.clearTimeout(this.H);
	    SIP.Timers.clearTimeout(this.I);
	
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	InviteServerTransaction.prototype.resend_provisional = function() {
	  if(!this.transport.send(this.last_response)) {
	    this.onTransportError();
	  }
	};
	
	// INVITE Server Transaction RFC 3261 17.2.1
	InviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
	  var tr = this;
	  var deferred = SIP.Utils.defer();
	
	  if(status_code >= 100 && status_code <= 199) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	        }
	        this.last_response = response;
	        break;
	    }
	  }
	
	  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {
	    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.
	    if(this.resendProvisionalTimer === null) {
	      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),
	        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);
	    }
	  } else if(status_code >= 200 && status_code <= 299) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_ACCEPTED);
	        this.last_response = response;
	        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);
	
	        if (this.resendProvisionalTimer !== null) {
	          SIP.Timers.clearInterval(this.resendProvisionalTimer);
	          this.resendProvisionalTimer = null;
	        }
	        /* falls through */
	        case C.STATUS_ACCEPTED:
	          // Note that this point will be reached for proceeding tr.state also.
	          if(!this.transport.send(response)) {
	            this.onTransportError();
	            deferred.reject();
	          } else {
	            deferred.resolve();
	          }
	          break;
	    }
	  } else if(status_code >= 300 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        if (this.resendProvisionalTimer !== null) {
	          SIP.Timers.clearInterval(this.resendProvisionalTimer);
	          this.resendProvisionalTimer = null;
	        }
	
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          this.stateChanged(C.STATUS_COMPLETED);
	          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);
	          deferred.resolve();
	        }
	        break;
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	 * @function
	 * @param {SIP.UA} ua
	 * @param {SIP.IncomingRequest} request
	 *
	 * @return {boolean}
	 * INVITE:
	 *  _true_ if retransmission
	 *  _false_ new request
	 *
	 * ACK:
	 *  _true_  ACK to non2xx response
	 *  _false_ ACK must be passed to TU (accepted state)
	 *          ACK to 2xx response
	 *
	 * CANCEL:
	 *  _true_  no matching invite transaction
	 *  _false_ matching invite transaction and no final response sent
	 *
	 * OTHER:
	 *  _true_  retransmission
	 *  _false_ new request
	 */
	var checkTransaction = function(ua, request) {
	  var tr;
	
	  switch(request.method) {
	    case SIP.C.INVITE:
	      tr = ua.transactions.ist[request.via_branch];
	      if(tr) {
	        switch(tr.state) {
	          case C.STATUS_PROCEEDING:
	            tr.transport.send(tr.last_response);
	            break;
	
	            // RFC 6026 7.1 Invite retransmission
	            //received while in C.STATUS_ACCEPTED state. Absorb it.
	          case C.STATUS_ACCEPTED:
	            break;
	        }
	        return true;
	      }
	      break;
	    case SIP.C.ACK:
	      tr = ua.transactions.ist[request.via_branch];
	
	      // RFC 6026 7.1
	      if(tr) {
	        if(tr.state === C.STATUS_ACCEPTED) {
	          return false;
	        } else if(tr.state === C.STATUS_COMPLETED) {
	          tr.state = C.STATUS_CONFIRMED;
	          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);
	          return true;
	        }
	      }
	
	      // ACK to 2XX Response.
	      else {
	        return false;
	      }
	      break;
	    case SIP.C.CANCEL:
	      tr = ua.transactions.ist[request.via_branch];
	      if(tr) {
	        request.reply_sl(200);
	        if(tr.state === C.STATUS_PROCEEDING) {
	          return false;
	        } else {
	          return true;
	        }
	      } else {
	        request.reply_sl(481);
	        return true;
	      }
	      break;
	    default:
	
	      // Non-INVITE Server Transaction RFC 3261 17.2.2
	      tr = ua.transactions.nist[request.via_branch];
	      if(tr) {
	        switch(tr.state) {
	          case C.STATUS_TRYING:
	            break;
	          case C.STATUS_PROCEEDING:
	          case C.STATUS_COMPLETED:
	            tr.transport.send(tr.last_response);
	            break;
	        }
	        return true;
	      }
	      break;
	  }
	};
	
	SIP.Transactions = {
	  C: C,
	  checkTransaction: checkTransaction,
	  NonInviteClientTransaction: NonInviteClientTransaction,
	  InviteClientTransaction: InviteClientTransaction,
	  AckClientTransaction: AckClientTransaction,
	  NonInviteServerTransaction: NonInviteServerTransaction,
	  InviteServerTransaction: InviteServerTransaction
	};
	
	};


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileoverview SIP Dialog
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP dialog.
	 * @param {SIP.RTCSession} owner
	 * @param {SIP.IncomingRequest|SIP.IncomingResponse} message
	 * @param {Enum} type UAC / UAS
	 * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED
	 */
	module.exports = function (SIP) {
	
	var RequestSender = __webpack_require__(227)(SIP);
	
	var Dialog,
	  C = {
	    // Dialog states
	    STATUS_EARLY:       1,
	    STATUS_CONFIRMED:   2
	  };
	
	// RFC 3261 12.1
	Dialog = function(owner, message, type, state) {
	  var contact;
	
	  this.uac_pending_reply = false;
	  this.uas_pending_reply = false;
	
	  if(!message.hasHeader('contact')) {
	    return {
	      error: 'unable to create a Dialog without Contact header field'
	    };
	  }
	
	  if(message instanceof SIP.IncomingResponse) {
	    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;
	  } else {
	    // Create confirmed dialog if state is not defined
	    state = state || C.STATUS_CONFIRMED;
	  }
	
	  contact = message.parseHeader('contact');
	
	  // RFC 3261 12.1.1
	  if(type === 'UAS') {
	    this.id = {
	      call_id: message.call_id,
	      local_tag: message.to_tag,
	      remote_tag: message.from_tag,
	      toString: function() {
	        return this.call_id + this.local_tag + this.remote_tag;
	      }
	    };
	    this.state = state;
	    this.remote_seqnum = message.cseq;
	    this.local_uri = message.parseHeader('to').uri;
	    this.remote_uri = message.parseHeader('from').uri;
	    this.remote_target = contact.uri;
	    this.route_set = message.getHeaders('record-route');
	    this.invite_seqnum = message.cseq;
	    this.local_seqnum = message.cseq;
	  }
	  // RFC 3261 12.1.2
	  else if(type === 'UAC') {
	    this.id = {
	      call_id: message.call_id,
	      local_tag: message.from_tag,
	      remote_tag: message.to_tag,
	      toString: function() {
	        return this.call_id + this.local_tag + this.remote_tag;
	      }
	    };
	    this.state = state;
	    this.invite_seqnum = message.cseq;
	    this.local_seqnum = message.cseq;
	    this.local_uri = message.parseHeader('from').uri;
	    this.pracked = [];
	    this.remote_uri = message.parseHeader('to').uri;
	    this.remote_target = contact.uri;
	    this.route_set = message.getHeaders('record-route').reverse();
	
	    //RENDERBODY
	    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {
	      this.mediaHandler = owner.mediaHandlerFactory(owner);
	    }
	  }
	
	  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());
	  this.owner = owner;
	  owner.ua.dialogs[this.id.toString()] = this;
	  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));
	  owner.emit('dialog', this);
	};
	
	Dialog.prototype = {
	  /**
	   * @param {SIP.IncomingMessage} message
	   * @param {Enum} UAC/UAS
	   */
	  update: function(message, type) {
	    this.state = C.STATUS_CONFIRMED;
	
	    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');
	
	    if(type === 'UAC') {
	      // RFC 3261 13.2.2.4
	      this.route_set = message.getHeaders('record-route').reverse();
	    }
	  },
	
	  terminate: function() {
	    this.logger.log('dialog ' + this.id.toString() + ' deleted');
	    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {
	      this.mediaHandler.peerConnection.close();
	    }
	    delete this.owner.ua.dialogs[this.id.toString()];
	  },
	
	  /**
	  * @param {String} method request method
	  * @param {Object} extraHeaders extra headers
	  * @returns {SIP.OutgoingRequest}
	  */
	
	  // RFC 3261 12.2.1.1
	  createRequest: function(method, extraHeaders, body) {
	    var cseq, request;
	    extraHeaders = (extraHeaders || []).slice();
	
	    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }
	
	    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;
	
	    request = new SIP.OutgoingRequest(
	      method,
	      this.remote_target,
	      this.owner.ua, {
	        'cseq': cseq,
	        'call_id': this.id.call_id,
	        'from_uri': this.local_uri,
	        'from_tag': this.id.local_tag,
	        'to_uri': this.remote_uri,
	        'to_tag': this.id.remote_tag,
	        'route_set': this.route_set
	      }, extraHeaders, body);
	
	    request.dialog = this;
	
	    return request;
	  },
	
	  /**
	  * @param {SIP.IncomingRequest} request
	  * @returns {Boolean}
	  */
	
	  // RFC 3261 12.2.2
	  checkInDialogRequest: function(request) {
	    var self = this;
	
	    if(!this.remote_seqnum) {
	      this.remote_seqnum = request.cseq;
	    } else if(request.cseq < this.remote_seqnum) {
	        //Do not try to reply to an ACK request.
	        if (request.method !== SIP.C.ACK) {
	          request.reply(500);
	        }
	        if (request.cseq === this.invite_seqnum) {
	          return true;
	        }
	        return false;
	    } else if(request.cseq > this.remote_seqnum) {
	      this.remote_seqnum = request.cseq;
	    }
	
	    switch(request.method) {
	      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-
	      case SIP.C.INVITE:
	        if (this.uac_pending_reply === true) {
	          request.reply(491);
	        } else if (this.uas_pending_reply === true) {
	          var retryAfter = (Math.random() * 10 | 0) + 1;
	          request.reply(500, null, ['Retry-After:' + retryAfter]);
	          return false;
	        } else {
	          this.uas_pending_reply = true;
	          request.server_transaction.on('stateChanged', function stateChanged(){
	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
	                this.state === SIP.Transactions.C.STATUS_COMPLETED ||
	                this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	
	              this.removeListener('stateChanged', stateChanged);
	              self.uas_pending_reply = false;
	
	              if (self.uac_pending_reply === false) {
	                self.owner.onReadyToReinvite();
	              }
	            }
	          });
	        }
	
	        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted
	        if(request.hasHeader('contact')) {
	          request.server_transaction.on('stateChanged', function(){
	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {
	              self.remote_target = request.parseHeader('contact').uri;
	            }
	          });
	        }
	        break;
	      case SIP.C.NOTIFY:
	        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted
	        if(request.hasHeader('contact')) {
	          request.server_transaction.on('stateChanged', function(){
	            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {
	              self.remote_target = request.parseHeader('contact').uri;
	            }
	          });
	        }
	        break;
	    }
	
	    return true;
	  },
	
	  sendRequest: function(applicant, method, options) {
	    options = options || {};
	
	    var
	      extraHeaders = (options.extraHeaders || []).slice(),
	      body = options.body || null,
	      request = this.createRequest(method, extraHeaders, body),
	      request_sender = new RequestSender(this, applicant, request);
	
	    request_sender.send();
	
	    return request;
	  },
	
	  /**
	  * @param {SIP.IncomingRequest} request
	  */
	  receiveRequest: function(request) {
	    //Check in-dialog request
	    if(!this.checkInDialogRequest(request)) {
	      return;
	    }
	
	    this.owner.receiveRequest(request);
	  }
	};
	
	Dialog.C = C;
	SIP.Dialog = Dialog;
	};


/***/ },
/* 227 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview In-Dialog Request Sender
	 */
	
	/**
	 * @augments SIP.Dialog
	 * @class Class creating an In-dialog request sender.
	 * @param {SIP.Dialog} dialog
	 * @param {Object} applicant
	 * @param {SIP.OutgoingRequest} request
	 */
	/**
	 * @fileoverview in-Dialog Request Sender
	 */
	
	module.exports = function (SIP) {
	var RequestSender;
	
	RequestSender = function(dialog, applicant, request) {
	
	  this.dialog = dialog;
	  this.applicant = applicant;
	  this.request = request;
	
	  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.
	  this.reattempt = false;
	  this.reattemptTimer = null;
	};
	
	RequestSender.prototype = {
	  send: function() {
	    var self = this,
	      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);
	
	      request_sender.send();
	
	    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-
	    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
	      this.dialog.uac_pending_reply = true;
	      request_sender.clientTransaction.on('stateChanged', function stateChanged(){
	        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
	            this.state === SIP.Transactions.C.STATUS_COMPLETED ||
	            this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	
	          this.removeListener('stateChanged', stateChanged);
	          self.dialog.uac_pending_reply = false;
	
	          if (self.dialog.uas_pending_reply === false) {
	            self.dialog.owner.onReadyToReinvite();
	          }
	        }
	      });
	    }
	  },
	
	  onRequestTimeout: function() {
	    this.applicant.onRequestTimeout();
	  },
	
	  onTransportError: function() {
	    this.applicant.onTransportError();
	  },
	
	  receiveResponse: function(response) {
	    var self = this;
	
	    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.
	    if (response.status_code === 408 || response.status_code === 481) {
	      this.applicant.onDialogError(response);
	    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {
	      if (this.reattempt) {
	        this.applicant.receiveResponse(response);
	      } else {
	        this.request.cseq.value = this.dialog.local_seqnum += 1;
	        this.reattemptTimer = SIP.Timers.setTimeout(
	          function() {
	            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {
	              self.reattempt = true;
	              self.request_sender.send();
	            }
	          },
	          this.getReattemptTimeout()
	        );
	      }
	    } else {
	      this.applicant.receiveResponse(response);
	    }
	  }
	};
	
	return RequestSender;
	};


/***/ },
/* 228 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview Request Sender
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a request sender.
	 * @param {Object} applicant
	 * @param {SIP.UA} ua
	 */
	module.exports = function (SIP) {
	var RequestSender;
	
	RequestSender = function(applicant, ua) {
	  this.logger = ua.getLogger('sip.requestsender');
	  this.ua = ua;
	  this.applicant = applicant;
	  this.method = applicant.request.method;
	  this.request = applicant.request;
	  this.credentials = null;
	  this.challenged = false;
	  this.staled = false;
	
	  // If ua is in closing process or even closed just allow sending Bye and ACK
	  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {
	    this.onTransportError();
	  }
	};
	
	/**
	* Create the client transaction and send the message.
	*/
	RequestSender.prototype = {
	  send: function() {
	    switch(this.method) {
	      case "INVITE":
	        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);
	        break;
	      case "ACK":
	        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);
	        break;
	      default:
	        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);
	    }
	    this.clientTransaction.send();
	
	    return this.clientTransaction;
	  },
	
	  /**
	  * Callback fired when receiving a request timeout error from the client transaction.
	  * To be re-defined by the applicant.
	  * @event
	  */
	  onRequestTimeout: function() {
	    this.applicant.onRequestTimeout();
	  },
	
	  /**
	  * Callback fired when receiving a transport error from the client transaction.
	  * To be re-defined by the applicant.
	  * @event
	  */
	  onTransportError: function() {
	    this.applicant.onTransportError();
	  },
	
	  /**
	  * Called from client transaction when receiving a correct response to the request.
	  * Authenticate request if needed or pass the response back to the applicant.
	  * @param {SIP.IncomingResponse} response
	  */
	  receiveResponse: function(response) {
	    var cseq, challenge, authorization_header_name,
	      status_code = response.status_code;
	
	    /*
	    * Authentication
	    * Authenticate once. _challenged_ flag used to avoid infinite authentications.
	    */
	    if (status_code === 401 || status_code === 407) {
	
	      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
	      if (response.status_code === 401) {
	        challenge = response.parseHeader('www-authenticate');
	        authorization_header_name = 'authorization';
	      } else {
	        challenge = response.parseHeader('proxy-authenticate');
	        authorization_header_name = 'proxy-authorization';
	      }
	
	      // Verify it seems a valid challenge.
	      if (! challenge) {
	        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');
	        this.applicant.receiveResponse(response);
	        return;
	      }
	
	      if (!this.challenged || (!this.staled && challenge.stale === true)) {
	        if (!this.credentials) {
	          this.credentials = this.ua.configuration.authenticationFactory(this.ua);
	        }
	
	        // Verify that the challenge is really valid.
	        if (!this.credentials.authenticate(this.request, challenge)) {
	          this.applicant.receiveResponse(response);
	          return;
	        }
	        this.challenged = true;
	
	        if (challenge.stale) {
	          this.staled = true;
	        }
	
	        if (response.method === SIP.C.REGISTER) {
	          cseq = this.applicant.cseq += 1;
	        } else if (this.request.dialog){
	          cseq = this.request.dialog.local_seqnum += 1;
	        } else {
	          cseq = this.request.cseq + 1;
	          this.request.cseq = cseq;
	        }
	        this.request.setHeader('cseq', cseq +' '+ this.method);
	
	        this.request.setHeader(authorization_header_name, this.credentials.toString());
	        this.send();
	      } else {
	        this.applicant.receiveResponse(response);
	      }
	    } else {
	      this.applicant.receiveResponse(response);
	    }
	  }
	};
	
	SIP.RequestSender = RequestSender;
	};


/***/ },
/* 229 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	
	var RegisterContext;
	
	RegisterContext = function (ua) {
	  var params = {},
	      regId = 1;
	
	  this.registrar = ua.configuration.registrarServer;
	  this.expires = ua.configuration.registerExpires;
	
	
	  // Contact header
	  this.contact = ua.contact.toString();
	
	  if(regId) {
	    this.contact += ';reg-id='+ regId;
	    this.contact += ';+sip.instance="<urn:uuid:'+ ua.configuration.instanceId+'>"';
	  }
	
	  // Call-ID and CSeq values RFC3261 10.2
	  this.call_id = SIP.Utils.createRandomToken(22);
	  this.cseq = 80;
	
	  this.to_uri = ua.configuration.uri;
	
	  params.to_uri = this.to_uri;
	  params.to_displayName = ua.configuration.displayName;
	  params.call_id = this.call_id;
	  params.cseq = this.cseq;
	
	  // Extends ClientContext
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);
	
	  this.registrationTimer = null;
	  this.registrationExpiredTimer = null;
	
	  // Set status
	  this.registered = false;
	
	  this.logger = ua.getLogger('sip.registercontext');
	};
	
	RegisterContext.prototype = {
	  register: function (options) {
	    var self = this, extraHeaders;
	
	    // Handle Options
	    this.options = options || {};
	    extraHeaders = (this.options.extraHeaders || []).slice();
	    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);
	    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	
	    // Save original extraHeaders to be used in .close
	    this.closeHeaders = this.options.closeWithHeaders ?
	      (this.options.extraHeaders || []).slice() : [];
	
	    this.receiveResponse = function(response) {
	      var contact, expires,
	        contacts = response.getHeaders('contact').length,
	        cause;
	
	      // Discard responses to older REGISTER/un-REGISTER requests.
	      if(response.cseq !== this.cseq) {
	        return;
	      }
	
	      // Clear registration timer
	      if (this.registrationTimer !== null) {
	        SIP.Timers.clearTimeout(this.registrationTimer);
	        this.registrationTimer = null;
	      }
	
	      switch(true) {
	        case /^1[0-9]{2}$/.test(response.status_code):
	          this.emit('progress', response);
	          break;
	        case /^2[0-9]{2}$/.test(response.status_code):
	          this.emit('accepted', response);
	
	          if(response.hasHeader('expires')) {
	            expires = response.getHeader('expires');
	          }
	
	          if (this.registrationExpiredTimer !== null) {
	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	            this.registrationExpiredTimer = null;
	          }
	
	          // Search the Contact pointing to us and update the expires value accordingly.
	          if (!contacts) {
	            this.logger.warn('no Contact header in response to REGISTER, response ignored');
	            break;
	          }
	
	          while(contacts--) {
	            contact = response.parseHeader('contact', contacts);
	            if(contact.uri.user === this.ua.contact.uri.user) {
	              expires = contact.getParam('expires');
	              break;
	            } else {
	              contact = null;
	            }
	          }
	
	          if (!contact) {
	            this.logger.warn('no Contact header pointing to us, response ignored');
	            break;
	          }
	
	          if(!expires) {
	            expires = this.expires;
	          }
	
	          // Re-Register before the expiration interval has elapsed.
	          // For that, decrease the expires value. ie: 3 seconds
	          this.registrationTimer = SIP.Timers.setTimeout(function() {
	            self.registrationTimer = null;
	            self.register(self.options);
	          }, (expires * 1000) - 3000);
	          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {
	            self.logger.warn('registration expired');
	            if (self.registered) {
	              self.unregistered(null, SIP.C.causes.EXPIRES);
	            }
	          }, expires * 1000);
	
	          //Save gruu values
	          if (contact.hasParam('temp-gruu')) {
	            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/"/g,''));
	          }
	          if (contact.hasParam('pub-gruu')) {
	            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/"/g,''));
	          }
	
	          this.registered = true;
	          this.emit('registered', response || null);
	          break;
	        // Interval too brief RFC3261 10.2.8
	        case /^423$/.test(response.status_code):
	          if(response.hasHeader('min-expires')) {
	            // Increase our registration interval to the suggested minimum
	            this.expires = response.getHeader('min-expires');
	            // Attempt the registration again immediately
	            this.register(this.options);
	          } else { //This response MUST contain a Min-Expires header field
	            this.logger.warn('423 response received for REGISTER without Min-Expires');
	            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);
	          }
	          break;
	        default:
	          cause = SIP.Utils.sipErrorCause(response.status_code);
	          this.registrationFailure(response, cause);
	      }
	    };
	
	    this.onRequestTimeout = function() {
	      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);
	    };
	
	    this.onTransportError = function() {
	      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);
	    };
	
	    this.cseq++;
	    this.request.cseq = this.cseq;
	    this.request.setHeader('cseq', this.cseq + ' REGISTER');
	    this.request.extraHeaders = extraHeaders;
	    this.send();
	  },
	
	  registrationFailure: function (response, cause) {
	    this.emit('failed', response || null, cause || null);
	  },
	
	  onTransportClosed: function() {
	    this.registered_before = this.registered;
	    if (this.registrationTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationTimer);
	      this.registrationTimer = null;
	    }
	
	    if (this.registrationExpiredTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	      this.registrationExpiredTimer = null;
	    }
	
	    if(this.registered) {
	      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onTransportConnected: function() {
	    this.register(this.options);
	  },
	
	  close: function() {
	    var options = {
	      all: false,
	      extraHeaders: this.closeHeaders
	    };
	
	    this.registered_before = this.registered;
	    this.unregister(options);
	  },
	
	  unregister: function(options) {
	    var extraHeaders;
	
	    options = options || {};
	
	    if(!this.registered && !options.all) {
	      this.logger.warn('already unregistered');
	      return;
	    }
	
	    extraHeaders = (options.extraHeaders || []).slice();
	
	    this.registered = false;
	
	    // Clear the registration timer.
	    if (this.registrationTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationTimer);
	      this.registrationTimer = null;
	    }
	
	    if(options.all) {
	      extraHeaders.push('Contact: *');
	      extraHeaders.push('Expires: 0');
	    } else {
	      extraHeaders.push('Contact: '+ this.contact + ';expires=0');
	    }
	
	
	    this.receiveResponse = function(response) {
	      var cause;
	
	      switch(true) {
	        case /^1[0-9]{2}$/.test(response.status_code):
	          this.emit('progress', response);
	          break;
	        case /^2[0-9]{2}$/.test(response.status_code):
	          this.emit('accepted', response);
	          if (this.registrationExpiredTimer !== null) {
	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	            this.registrationExpiredTimer = null;
	          }
	          this.unregistered(response);
	          break;
	        default:
	          cause = SIP.Utils.sipErrorCause(response.status_code);
	          this.unregistered(response,cause);
	      }
	    };
	
	    this.onRequestTimeout = function() {
	      // Not actually unregistered...
	      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);
	    };
	
	    this.onTransportError = function() {
	      // Not actually unregistered...
	      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
	    };
	
	    this.cseq++;
	    this.request.cseq = this.cseq;
	    this.request.setHeader('cseq', this.cseq + ' REGISTER');
	    this.request.extraHeaders = extraHeaders;
	
	    this.send();
	  },
	
	  unregistered: function(response, cause) {
	    this.registered = false;
	    this.emit('unregistered', response || null, cause || null);
	  }
	
	};
	
	
	SIP.RegisterContext = RegisterContext;
	};


/***/ },
/* 230 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaHandler
	 */
	
	/* MediaHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 */
	module.exports = function (EventEmitter) {
	var MediaHandler = function(session, options) {
	  // keep jshint happy
	  session = session;
	  options = options;
	};
	
	MediaHandler.prototype = Object.create(EventEmitter.prototype, {
	  isReady: {value: function isReady () {}},
	
	  close: {value: function close () {}},
	
	  /**
	   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.
	   */
	  getDescription: {value: function getDescription (mediaHint) {
	    // keep jshint happy
	    mediaHint = mediaHint;
	  }},
	
	  /**
	  * Message reception.
	  * @param {String} type
	  * @param {String} description
	  */
	  setDescription: {value: function setDescription (description) {
	    // keep jshint happy
	    description = description;
	  }}
	});
	
	return MediaHandler;
	};


/***/ },
/* 231 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	var ClientContext;
	
	ClientContext = function (ua, method, target, options) {
	  var originalTarget = target;
	
	  // Validate arguments
	  if (target === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  this.ua = ua;
	  this.logger = ua.getLogger('sip.clientcontext');
	  this.method = method;
	  target = ua.normalizeTarget(target);
	  if (!target) {
	    throw new TypeError('Invalid target: ' + originalTarget);
	  }
	
	  /* Options
	   * - extraHeaders
	   * - params
	   * - contentType
	   * - body
	   */
	  options = Object.create(options || Object.prototype);
	  options.extraHeaders = (options.extraHeaders || []).slice();
	
	  if (options.contentType) {
	    this.contentType = options.contentType;
	    options.extraHeaders.push('Content-Type: ' + this.contentType);
	  }
	
	  // Build the request
	  this.request = new SIP.OutgoingRequest(this.method,
	                                         target,
	                                         this.ua,
	                                         options.params,
	                                         options.extraHeaders);
	  if (options.body) {
	    this.body = options.body;
	    this.request.body = this.body;
	  }
	
	  /* Set other properties from the request */
	  this.localIdentity = this.request.from;
	  this.remoteIdentity = this.request.to;
	
	  this.data = {};
	};
	ClientContext.prototype = Object.create(SIP.EventEmitter.prototype);
	
	ClientContext.prototype.send = function () {
	  (new SIP.RequestSender(this, this.ua)).send();
	  return this;
	};
	
	ClientContext.prototype.cancel = function (options) {
	  options = options || {};
	
	  var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
	  this.request.cancel(cancel_reason);
	
	  this.emit('cancel');
	};
	
	ClientContext.prototype.receiveResponse = function (response) {
	  var cause = SIP.Utils.getReasonPhrase(response.status_code);
	
	  switch(true) {
	    case /^1[0-9]{2}$/.test(response.status_code):
	      this.emit('progress', response, cause);
	      break;
	
	    case /^2[0-9]{2}$/.test(response.status_code):
	      if(this.ua.applicants[this]) {
	        delete this.ua.applicants[this];
	      }
	      this.emit('accepted', response, cause);
	      break;
	
	    default:
	      if(this.ua.applicants[this]) {
	        delete this.ua.applicants[this];
	      }
	      this.emit('rejected', response, cause);
	      this.emit('failed', response, cause);
	      break;
	  }
	
	};
	
	ClientContext.prototype.onRequestTimeout = function () {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	};
	
	ClientContext.prototype.onTransportError = function () {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	};
	
	SIP.ClientContext = ClientContext;
	};


/***/ },
/* 232 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	var ServerContext;
	
	ServerContext = function (ua, request) {
	  this.ua = ua;
	  this.logger = ua.getLogger('sip.servercontext');
	  this.request = request;
	  if (request.method === SIP.C.INVITE) {
	    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);
	  } else {
	    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);
	  }
	
	  if (request.body) {
	    this.body = request.body;
	  }
	  if (request.hasHeader('Content-Type')) {
	    this.contentType = request.getHeader('Content-Type');
	  }
	  this.method = request.method;
	
	  this.data = {};
	
	  this.localIdentity = request.to;
	  this.remoteIdentity = request.from;
	};
	
	ServerContext.prototype = Object.create(SIP.EventEmitter.prototype);
	
	ServerContext.prototype.progress = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 180);
	  options.minCode = 100;
	  options.maxCode = 199;
	  options.events = ['progress'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.accept = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 200);
	  options.minCode = 200;
	  options.maxCode = 299;
	  options.events = ['accepted'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.reject = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 480);
	  options.minCode = 300;
	  options.maxCode = 699;
	  options.events = ['rejected', 'failed'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.reply = function (options) {
	  options = options || {}; // This is okay, so long as we treat options as read-only in this method
	  var
	    statusCode = options.statusCode || 100,
	    minCode = options.minCode || 100,
	    maxCode = options.maxCode || 699,
	    reasonPhrase = SIP.Utils.getReasonPhrase(statusCode, options.reasonPhrase),
	    extraHeaders = options.extraHeaders || [],
	    body = options.body,
	    events = options.events || [],
	    response;
	
	  if (statusCode < minCode || statusCode > maxCode) {
	    throw new TypeError('Invalid statusCode: ' + statusCode);
	  }
	  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	  events.forEach(function (event) {
	    this.emit(event, response, reasonPhrase);
	  }, this);
	
	  return this;
	};
	
	ServerContext.prototype.onRequestTimeout = function () {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	};
	
	ServerContext.prototype.onTransportError = function () {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	};
	
	SIP.ServerContext = ServerContext;
	};


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function (SIP, environment) {
	
	var DTMF = __webpack_require__(234)(SIP);
	
	var Session, InviteServerContext, InviteClientContext,
	 C = {
	    //Session states
	    STATUS_NULL:                        0,
	    STATUS_INVITE_SENT:                 1,
	    STATUS_1XX_RECEIVED:                2,
	    STATUS_INVITE_RECEIVED:             3,
	    STATUS_WAITING_FOR_ANSWER:          4,
	    STATUS_ANSWERED:                    5,
	    STATUS_WAITING_FOR_PRACK:           6,
	    STATUS_WAITING_FOR_ACK:             7,
	    STATUS_CANCELED:                    8,
	    STATUS_TERMINATED:                  9,
	    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,
	    STATUS_EARLY_MEDIA:                11,
	    STATUS_CONFIRMED:                  12
	  };
	
	/*
	 * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]
	 *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)
	 */
	Session = function (mediaHandlerFactory) {
	  this.status = C.STATUS_NULL;
	  this.dialog = null;
	  this.earlyDialogs = {};
	  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;
	  // this.mediaHandler gets set by ICC/ISC constructors
	  this.hasOffer = false;
	  this.hasAnswer = false;
	
	  // Session Timers
	  this.timers = {
	    ackTimer: null,
	    expiresTimer: null,
	    invite2xxTimer: null,
	    userNoAnswerTimer: null,
	    rel1xxTimer: null,
	    prackTimer: null
	  };
	
	  // Session info
	  this.startTime = null;
	  this.endTime = null;
	  this.tones = null;
	
	  // Mute/Hold state
	  this.local_hold = false;
	  this.remote_hold = false;
	
	  this.pending_actions = {
	    actions: [],
	
	    length: function() {
	      return this.actions.length;
	    },
	
	    isPending: function(name){
	      var
	      idx = 0,
	      length = this.actions.length;
	
	      for (idx; idx<length; idx++) {
	        if (this.actions[idx].name === name) {
	          return true;
	        }
	      }
	      return false;
	    },
	
	    shift: function() {
	      return this.actions.shift();
	    },
	
	    push: function(name) {
	      this.actions.push({
	        name: name
	      });
	    },
	
	    pop: function(name) {
	      var
	      idx = 0,
	      length = this.actions.length;
	
	      for (idx; idx<length; idx++) {
	        if (this.actions[idx].name === name) {
	          this.actions.splice(idx,1);
	          length --;
	          idx--;
	        }
	      }
	    }
	   };
	
	  this.early_sdp = null;
	  this.rel100 = SIP.C.supported.UNSUPPORTED;
	};
	
	Session.prototype = {
	  dtmf: function(tones, options) {
	    var tone, dtmfs = [],
	        self = this;
	
	    options = options || {};
	
	    if (tones === undefined) {
	      throw new TypeError('Not enough arguments');
	    }
	
	    // Check Session Status
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    // Check tones
	    if ((typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {
	      throw new TypeError('Invalid tones: '+ tones);
	    }
	
	    tones = tones.toString().split('');
	
	    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }
	
	    if (this.tones) {
	      // Tones are already queued, just add to the queue
	      this.tones =  this.tones.concat(dtmfs);
	      return this;
	    }
	
	    var sendDTMF = function () {
	      var dtmf, timeout;
	
	      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {
	        // Stop sending DTMF
	        self.tones = null;
	        return this;
	      }
	
	      dtmf = self.tones.shift();
	
	      if (tone === ',') {
	        timeout = 2000;
	      } else {
	        dtmf.on('failed', function(){self.tones = null;});
	        dtmf.send(options);
	        timeout = dtmf.duration + dtmf.interToneGap;
	      }
	
	      // Set timeout for the next tone
	      SIP.Timers.setTimeout(sendDTMF, timeout);
	    };
	
	    this.tones = dtmfs;
	    sendDTMF();
	    return this;
	  },
	
	  bye: function(options) {
	    options = Object.create(options || Object.prototype);
	    var statusCode = options.statusCode;
	
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED) {
	      this.logger.error('Error: Attempted to send BYE in a terminated session.');
	      return this;
	    }
	
	    this.logger.log('terminating Session');
	
	    if (statusCode && (statusCode < 200 || statusCode >= 700)) {
	      throw new TypeError('Invalid statusCode: '+ statusCode);
	    }
	
	    options.receiveResponse = function () {};
	
	    return this.
	      sendRequest(SIP.C.BYE, options).
	      terminated();
	  },
	
	  refer: function(target, options) {
	    options = options || {};
	    var extraHeaders = (options.extraHeaders || []).slice(),
	        withReplaces =
	          target instanceof SIP.InviteServerContext ||
	          target instanceof SIP.InviteClientContext,
	        originalTarget = target;
	
	    if (target === undefined) {
	      throw new TypeError('Not enough arguments');
	    }
	
	    // Check Session Status
	    if (this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    // transform `target` so that it can be a Refer-To header value
	    if (withReplaces) {
	      //Attended Transfer
	      // B.transfer(C)
	      target = '"' + target.remoteIdentity.friendlyName + '" ' +
	        '<' + target.dialog.remote_target.toString() +
	        '?Replaces=' + target.dialog.id.call_id +
	        '%3Bto-tag%3D' + target.dialog.id.remote_tag +
	        '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';
	    } else {
	      //Blind Transfer
	      // normalizeTarget allows instances of SIP.URI to pass through unaltered,
	      // so try to make one ahead of time
	      try {
	        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;
	      } catch (e) {
	        this.logger.debug(".refer() cannot parse Refer_To from", target);
	        this.logger.debug("...falling through to normalizeTarget()");
	      }
	
	      // Check target validity
	      target = this.ua.normalizeTarget(target);
	      if (!target) {
	        throw new TypeError('Invalid target: ' + originalTarget);
	      }
	    }
	
	    extraHeaders.push('Contact: '+ this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	    extraHeaders.push('Refer-To: '+ target);
	
	    // Send the request
	    this.sendRequest(SIP.C.REFER, {
	      extraHeaders: extraHeaders,
	      body: options.body,
	      receiveResponse: function (response) {
	        if ( ! /^2[0-9]{2}$/.test(response.status_code) ) {
	          return;
	        }
	        // hang up only if we transferred to a SIP address
	        if (withReplaces || (target.scheme && target.scheme.match("^sips?$"))) {
	          this.terminate();
	        }
	      }.bind(this)
	    });
	    return this;
	  },
	
	  followRefer: function followRefer (callback) {
	    return function referListener (callback, request) {
	      // open non-SIP URIs if possible and keep session open
	      var referTo = request.parseHeader('refer-to');
	      var target = referTo.uri;
	      if (!target.scheme.match("^sips?$")) {
	        var targetString = target.toString();
	        if (typeof environment.open === "function") {
	          environment.open(targetString);
	        } else {
	          this.logger.warn("referred to non-SIP URI but `open` isn't in the environment: " + targetString);
	        }
	        return;
	      }
	
	      var extraHeaders = [];
	
	      /* Copy the Replaces query into a Replaces header */
	      /* TODO - make sure we don't copy a poorly formatted header? */
	      var replaces = target.getHeader('Replaces');
	      if (replaces !== undefined) {
	        extraHeaders.push('Replaces: ' + decodeURIComponent(replaces));
	      }
	
	      // don't embed headers into Request-URI of INVITE
	      target.clearHeaders();
	
	      /*
	        Harmless race condition.  Both sides of REFER
	        may send a BYE, but in the end the dialogs are destroyed.
	      */
	      var getReferMedia = this.mediaHandler.getReferMedia;
	      var mediaHint = getReferMedia ? getReferMedia.call(this.mediaHandler) : this.mediaHint;
	
	      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);
	
	      var referSession = this.ua.invite(target, {
	        media: mediaHint,
	        params: {
	          to_displayName: referTo.friendlyName
	        },
	        extraHeaders: extraHeaders
	      });
	
	      callback.call(this, request, referSession);
	
	      this.terminate();
	    }.bind(this, callback);
	  },
	
	  sendRequest: function(method,options) {
	    options = options || {};
	    var self = this;
	
	    var request = new SIP.OutgoingRequest(
	      method,
	      this.dialog.remote_target,
	      this.ua,
	      {
	        cseq: options.cseq || (this.dialog.local_seqnum += 1),
	        call_id: this.dialog.id.call_id,
	        from_uri: this.dialog.local_uri,
	        from_tag: this.dialog.id.local_tag,
	        to_uri: this.dialog.remote_uri,
	        to_tag: this.dialog.id.remote_tag,
	        route_set: this.dialog.route_set,
	        statusCode: options.statusCode,
	        reasonPhrase: options.reasonPhrase
	      },
	      options.extraHeaders || [],
	      options.body
	    );
	
	    new SIP.RequestSender({
	      request: request,
	      onRequestTimeout: function() {
	        self.onRequestTimeout();
	      },
	      onTransportError: function() {
	        self.onTransportError();
	      },
	      receiveResponse: options.receiveResponse || function(response) {
	        self.receiveNonInviteResponse(response);
	      }
	    }, this.ua).send();
	
	    // Emit the request event
	    this.emit(method.toLowerCase(), request);
	
	    return this;
	  },
	
	  close: function() {
	    var idx;
	
	    if(this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    this.logger.log('closing INVITE session ' + this.id);
	
	    // 1st Step. Terminate media.
	    if (this.mediaHandler){
	      this.mediaHandler.close();
	    }
	
	    // 2nd Step. Terminate signaling.
	
	    // Clear session timers
	    for(idx in this.timers) {
	      SIP.Timers.clearTimeout(this.timers[idx]);
	    }
	
	    // Terminate dialogs
	
	    // Terminate confirmed dialog
	    if(this.dialog) {
	      this.dialog.terminate();
	      delete this.dialog;
	    }
	
	    // Terminate early dialogs
	    for(idx in this.earlyDialogs) {
	      this.earlyDialogs[idx].terminate();
	      delete this.earlyDialogs[idx];
	    }
	
	    this.status = C.STATUS_TERMINATED;
	
	    delete this.ua.sessions[this.id];
	    return this;
	  },
	
	  createDialog: function(message, type, early) {
	    var dialog, early_dialog,
	      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],
	      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],
	      id = message.call_id + local_tag + remote_tag;
	
	    early_dialog = this.earlyDialogs[id];
	
	    // Early Dialog
	    if (early) {
	      if (early_dialog) {
	        return true;
	      } else {
	        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);
	
	        // Dialog has been successfully created.
	        if(early_dialog.error) {
	          this.logger.error(early_dialog.error);
	          this.failed(message, SIP.C.causes.INTERNAL_ERROR);
	          return false;
	        } else {
	          this.earlyDialogs[id] = early_dialog;
	          return true;
	        }
	      }
	    }
	    // Confirmed Dialog
	    else {
	      // In case the dialog is in _early_ state, update it
	      if (early_dialog) {
	        early_dialog.update(message, type);
	        this.dialog = early_dialog;
	        delete this.earlyDialogs[id];
	        for (var dia in this.earlyDialogs) {
	          this.earlyDialogs[dia].terminate();
	          delete this.earlyDialogs[dia];
	        }
	        return true;
	      }
	
	      // Otherwise, create a _confirmed_ dialog
	      dialog = new SIP.Dialog(this, message, type);
	
	      if(dialog.error) {
	        this.logger.error(dialog.error);
	        this.failed(message, SIP.C.causes.INTERNAL_ERROR);
	        return false;
	      } else {
	        this.to_tag = message.to_tag;
	        this.dialog = dialog;
	        return true;
	      }
	    }
	  },
	
	  /**
	  * Check if Session is ready for a re-INVITE
	  *
	  * @returns {Boolean}
	  */
	  isReadyToReinvite: function() {
	    return this.mediaHandler.isReady() &&
	      !this.dialog.uac_pending_reply &&
	      !this.dialog.uas_pending_reply;
	  },
	
	  /**
	   * Mute
	   */
	  mute: function(options) {
	    var ret = this.mediaHandler.mute(options);
	    if (ret) {
	      this.onmute(ret);
	    }
	  },
	
	  /**
	   * Unmute
	   */
	  unmute: function(options) {
	    var ret = this.mediaHandler.unmute(options);
	    if (ret) {
	      this.onunmute(ret);
	    }
	  },
	
	  /**
	   * Hold
	   */
	  hold: function(options) {
	
	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.mediaHandler.hold();
	
	    // Check if RTCSession is ready to send a reINVITE
	    if (!this.isReadyToReinvite()) {
	      /* If there is a pending 'unhold' action, cancel it and don't queue this one
	       * Else, if there isn't any 'hold' action, add this one to the queue
	       * Else, if there is already a 'hold' action, skip
	       */
	      if (this.pending_actions.isPending('unhold')) {
	        this.pending_actions.pop('unhold');
	      } else if (!this.pending_actions.isPending('hold')) {
	        this.pending_actions.push('hold');
	      }
	      return;
	    } else if (this.local_hold === true) {
	        return;
	    }
	
	    this.onhold('local');
	
	    options = options || {};
	    options.mangle = function(body){
	
	      // Don't receive media
	      // TODO - This will break for media streams with different directions.
	      if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(body)) {
	        body = body.replace(/(m=[^\r]*\r\n)/g, '$1a=sendonly\r\n');
	      } else {
	        body = body.replace(/a=sendrecv\r\n/g, 'a=sendonly\r\n');
	        body = body.replace(/a=recvonly\r\n/g, 'a=inactive\r\n');
	      }
	
	      return body;
	    };
	
	    this.sendReinvite(options);
	  },
	
	  /**
	   * Unhold
	   */
	  unhold: function(options) {
	
	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.mediaHandler.unhold();
	
	    if (!this.isReadyToReinvite()) {
	      /* If there is a pending 'hold' action, cancel it and don't queue this one
	       * Else, if there isn't any 'unhold' action, add this one to the queue
	       * Else, if there is already a 'unhold' action, skip
	       */
	      if (this.pending_actions.isPending('hold')) {
	        this.pending_actions.pop('hold');
	      } else if (!this.pending_actions.isPending('unhold')) {
	        this.pending_actions.push('unhold');
	      }
	      return;
	    } else if (this.local_hold === false) {
	      return;
	    }
	
	    this.onunhold('local');
	
	    this.sendReinvite(options);
	  },
	
	  /**
	   * isOnHold
	   */
	  isOnHold: function() {
	    return {
	      local: this.local_hold,
	      remote: this.remote_hold
	    };
	  },
	
	  /**
	   * In dialog INVITE Reception
	   * @private
	   */
	  receiveReinvite: function(request) {
	    var self = this;
	
	    if (!request.body) {
	      return;
	    }
	
	    if (request.getHeader('Content-Type') !== 'application/sdp') {
	      this.logger.warn('invalid Content-Type');
	      request.reply(415);
	      return;
	    }
	
	    this.mediaHandler.setDescription(request.body)
	    .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
	    .then(function(body) {
	      request.reply(200, null, ['Contact: ' + self.contact], body,
	        function() {
	          self.status = C.STATUS_WAITING_FOR_ACK;
	          self.setInvite2xxTimer(request, body);
	          self.setACKTimer();
	
	          // Are we holding?
	          var hold = (/a=(sendonly|inactive)/).test(request.body);
	
	          if (self.remote_hold && !hold) {
	            self.onunhold('remote');
	          } else if (!self.remote_hold && hold) {
	            self.onhold('remote');
	          }
	        });
	    })
	    .catch(function onFailure (e) {
	      var statusCode;
	      if (e instanceof SIP.Exceptions.GetDescriptionError) {
	        statusCode = 500;
	      } else {
	        self.logger.error(e);
	        statusCode = 488;
	      }
	      request.reply(statusCode);
	    });
	  },
	
	  sendReinvite: function(options) {
	    options = options || {};
	
	    var
	      self = this,
	      extraHeaders = (options.extraHeaders || []).slice(),
	      eventHandlers = options.eventHandlers || {},
	      mangle = options.mangle || null,
	      succeeded;
	
	    if (eventHandlers.succeeded) {
	      succeeded = eventHandlers.succeeded;
	    }
	    this.reinviteSucceeded = function(){
	      SIP.Timers.clearTimeout(self.timers.ackTimer);
	      SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
	      self.status = C.STATUS_CONFIRMED;
	      succeeded && succeeded.apply(this, arguments);
	    };
	    if (eventHandlers.failed) {
	      this.reinviteFailed = eventHandlers.failed;
	    } else {
	      this.reinviteFailed = function(){};
	    }
	
	    extraHeaders.push('Contact: ' + this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	    extraHeaders.push('Content-Type: application/sdp');
	
	    this.receiveResponse = this.receiveReinviteResponse;
	    //REVISIT
	    this.mediaHandler.getDescription(self.mediaHint)
	    .then(mangle)
	    .then(
	      function(body){
	        self.dialog.sendRequest(self, SIP.C.INVITE, {
	          extraHeaders: extraHeaders,
	          body: body
	        });
	      },
	      function() {
	        if (self.isReadyToReinvite()) {
	          self.onReadyToReinvite();
	        }
	        self.reinviteFailed();
	      }
	    );
	  },
	
	  receiveRequest: function (request) {
	    switch (request.method) {
	      case SIP.C.BYE:
	        request.reply(200);
	        if(this.status === C.STATUS_CONFIRMED) {
	          this.emit('bye', request);
	          this.terminated(request, SIP.C.causes.BYE);
	        }
	        break;
	      case SIP.C.INVITE:
	        if(this.status === C.STATUS_CONFIRMED) {
	          this.logger.log('re-INVITE received');
	          this.receiveReinvite(request);
	        }
	        break;
	      case SIP.C.INFO:
	        if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {
	          var body, tone, duration,
	              contentType = request.getHeader('content-type'),
	              reg_tone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/,
	              reg_duration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
	
	          if (contentType) {
	            if (contentType.match(/^application\/dtmf-relay/i)) {
	              if (request.body) {
	                body = request.body.split('\r\n', 2);
	                if (body.length === 2) {
	                  if (reg_tone.test(body[0])) {
	                    tone = body[0].replace(reg_tone,"$2");
	                  }
	                  if (reg_duration.test(body[1])) {
	                    duration = parseInt(body[1].replace(reg_duration,"$2"), 10);
	                  }
	                }
	              }
	
	              new DTMF(this, tone, {duration: duration}).init_incoming(request);
	            } else {
	              request.reply(415, null, ["Accept: application/dtmf-relay"]);
	            }
	          }
	        }
	        break;
	      case SIP.C.REFER:
	        if(this.status ===  C.STATUS_CONFIRMED) {
	          this.logger.log('REFER received');
	          var hasReferListener = this.listeners('refer').length,
	              notifyBody;
	
	          if (hasReferListener) {
	            request.reply(202, 'Accepted');
	            notifyBody = 'SIP/2.0 100 Trying';
	
	            this.sendRequest(SIP.C.NOTIFY, {
	              extraHeaders:[
	                'Event: refer',
	                'Subscription-State: terminated',
	                'Content-Type: message/sipfrag'
	              ],
	              body: notifyBody,
	              receiveResponse: function() {}
	            });
	
	            this.emit('refer', request);
	          } else {
	            // RFC 3515.2.4.2: 'the UA MAY decline the request.'
	            request.reply(603, 'Declined');
	          }
	        }
	        break;
	      case SIP.C.NOTIFY:
	        request.reply(200, 'OK');
	        this.emit('notify', request);
	        break;
	    }
	  },
	
	  /**
	   * Reception of Response for in-dialog INVITE
	   * @private
	   */
	  receiveReinviteResponse: function(response) {
	    var self = this,
	        contentType = response.getHeader('Content-Type');
	
	    if (this.status === C.STATUS_TERMINATED) {
	      return;
	    }
	
	    switch(true) {
	      case /^1[0-9]{2}$/.test(response.status_code):
	        break;
	      case /^2[0-9]{2}$/.test(response.status_code):
	        this.status = C.STATUS_CONFIRMED;
	
	        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});
	
	        if(!response.body) {
	          this.reinviteFailed();
	          break;
	        } else if (contentType !== 'application/sdp') {
	          this.reinviteFailed();
	          break;
	        }
	
	        //REVISIT
	        this.mediaHandler.setDescription(response.body)
	        .then(
	          function onSuccess () {
	            self.reinviteSucceeded();
	          },
	          function onFailure () {
	            self.reinviteFailed();
	          }
	        );
	        break;
	      default:
	        this.reinviteFailed();
	    }
	  },
	
	  acceptAndTerminate: function(response, status_code, reason_phrase) {
	    var extraHeaders = [];
	
	    if (status_code) {
	      extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));
	    }
	
	    // An error on dialog creation will fire 'failed' event
	    if (this.dialog || this.createDialog(response, 'UAC')) {
	      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
	      this.sendRequest(SIP.C.BYE, {
	        extraHeaders: extraHeaders
	      });
	    }
	
	    return this;
	  },
	
	  /**
	   * RFC3261 13.3.1.4
	   * Response retransmissions cannot be accomplished by transaction layer
	   *  since it is destroyed when receiving the first 2xx answer
	   */
	  setInvite2xxTimer: function(request, body) {
	    var self = this,
	        timeout = SIP.Timers.T1;
	
	    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {
	      if (self.status !== C.STATUS_WAITING_FOR_ACK) {
	        return;
	      }
	
	      self.logger.log('no ACK received, attempting to retransmit OK');
	
	      request.reply(200, null, ['Contact: ' + self.contact], body);
	
	      timeout = Math.min(timeout * 2, SIP.Timers.T2);
	
	      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);
	    }, timeout);
	  },
	
	  /**
	   * RFC3261 14.2
	   * If a UAS generates a 2xx response and never receives an ACK,
	   *  it SHOULD generate a BYE to terminate the dialog.
	   */
	  setACKTimer: function() {
	    var self = this;
	
	    this.timers.ackTimer = SIP.Timers.setTimeout(function() {
	      if(self.status === C.STATUS_WAITING_FOR_ACK) {
	        self.logger.log('no ACK received for an extended period of time, terminating the call');
	        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
	        self.sendRequest(SIP.C.BYE);
	        self.terminated(null, SIP.C.causes.NO_ACK);
	      }
	    }, SIP.Timers.TIMER_H);
	  },
	
	  /*
	   * @private
	   */
	  onReadyToReinvite: function() {
	    var action = this.pending_actions.shift();
	
	    if (!action || !this[action.name]) {
	      return;
	    }
	
	    this[action.name]();
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  },
	
	  onDialogError: function(response) {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(response, SIP.C.causes.DIALOG_ERROR);
	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
	    }
	  },
	
	  /**
	   * @private
	   */
	  onhold: function(originator) {
	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;
	    this.emit('hold', { originator: originator });
	  },
	
	  /**
	   * @private
	   */
	  onunhold: function(originator) {
	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;
	    this.emit('unhold', { originator: originator });
	  },
	
	  /*
	   * @private
	   */
	  onmute: function(options) {
	    this.emit('muted', {
	      audio: options.audio,
	      video: options.video
	    });
	  },
	
	  /*
	   * @private
	   */
	  onunmute: function(options) {
	    this.emit('unmuted', {
	      audio: options.audio,
	      video: options.video
	    });
	  },
	
	  failed: function(response, cause) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	    this.emit('failed', response || null, cause || null);
	    return this;
	  },
	
	  rejected: function(response, cause) {
	    this.emit('rejected',
	      response || null,
	      cause || null
	    );
	    return this;
	  },
	
	  canceled: function() {
	    this.emit('cancel');
	    return this;
	  },
	
	  accepted: function(response, cause) {
	    cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);
	
	    this.startTime = new Date();
	
	    if (this.replacee) {
	      this.replacee.emit('replaced', this);
	      this.replacee.terminate();
	    }
	    this.emit('accepted', response, cause);
	    return this;
	  },
	
	  terminated: function(message, cause) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    this.endTime = new Date();
	
	    this.close();
	    this.emit('terminated',
	      message || null,
	      cause || null
	    );
	    return this;
	  },
	
	  connecting: function(request) {
	    this.emit('connecting', { request: request });
	    return this;
	  }
	};
	
	Session.desugar = function desugar(options) {
	  if (environment.HTMLMediaElement && options instanceof environment.HTMLMediaElement) {
	    options = {
	      media: {
	        constraints: {
	          audio: true,
	          video: options.tagName === 'VIDEO'
	        },
	        render: {
	          remote: options
	        }
	      }
	    };
	  }
	  return options || {};
	};
	
	
	Session.C = C;
	SIP.Session = Session;
	
	
	InviteServerContext = function(ua, request) {
	  var expires,
	    self = this,
	    contentType = request.getHeader('Content-Type'),
	    contentDisp = request.parseHeader('Content-Disposition');
	
	  // Check body and content type
	  if ((!contentDisp && contentType !== 'application/sdp') || (contentDisp && contentDisp.type === 'render')) {
	    this.renderbody = request.body;
	    this.rendertype = contentType;
	  } else if (contentType !== 'application/sdp' && (contentDisp && contentDisp.type === 'session')) {
	    request.reply(415);
	    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it
	    return;
	  }
	
	  //TODO: move this into media handler
	  SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);
	  SIP.Hacks.AllBrowsers.maskDtls(request);
	
	  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);
	  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);
	
	  this.status = C.STATUS_INVITE_RECEIVED;
	  this.from_tag = request.from_tag;
	  this.id = request.call_id + this.from_tag;
	  this.request = request;
	  this.contact = this.ua.contact.toString();
	
	  this.receiveNonInviteResponse = function () {}; // intentional no-op
	
	  this.logger = ua.getLogger('sip.inviteservercontext', this.id);
	
	  //Save the session into the ua sessions collection.
	  this.ua.sessions[this.id] = this;
	
	  //Get the Expires header value if exists
	  if(request.hasHeader('expires')) {
	    expires = request.getHeader('expires') * 1000;
	  }
	
	  //Set 100rel if necessary
	  function set100rel(h,c) {
	    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {
	      self.rel100 = c;
	    }
	  }
	  set100rel('require', SIP.C.supported.REQUIRED);
	  set100rel('supported', SIP.C.supported.SUPPORTED);
	
	  /* Set the to_tag before
	   * replying a response code that will create a dialog.
	   */
	  request.to_tag = SIP.Utils.newTag();
	
	  // An error on dialog creation will fire 'failed' event
	  if(!this.createDialog(request, 'UAS', true)) {
	    request.reply(500, 'Missing Contact header field');
	    return;
	  }
	
	  //Initialize Media Session
	  this.mediaHandler = this.mediaHandlerFactory(this, {
	    RTCConstraints: {"optional": [{'DtlsSrtpKeyAgreement': 'true'}]}
	  });
	
	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
	  }
	
	  function fireNewSession() {
	    var options = {extraHeaders: ['Contact: ' + self.contact]};
	
	    if (self.rel100 !== SIP.C.supported.REQUIRED) {
	      self.progress(options);
	    }
	    self.status = C.STATUS_WAITING_FOR_ANSWER;
	
	    // Set userNoAnswerTimer
	    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {
	      request.reply(408);
	      self.failed(request, SIP.C.causes.NO_ANSWER);
	      self.terminated(request, SIP.C.causes.NO_ANSWER);
	    }, self.ua.configuration.noAnswerTimeout);
	
	    /* Set expiresTimer
	     * RFC3261 13.3.1
	     */
	    if (expires) {
	      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {
	        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {
	          request.reply(487);
	          self.failed(request, SIP.C.causes.EXPIRES);
	          self.terminated(request, SIP.C.causes.EXPIRES);
	        }
	      }, expires);
	    }
	
	    self.emit('invite',request);
	  }
	
	  if (!request.body || this.renderbody) {
	    SIP.Timers.setTimeout(fireNewSession, 0);
	  } else {
	    this.hasOffer = true;
	    this.mediaHandler.setDescription(request.body)
	    .then(
	      fireNewSession,
	      function onFailure (e) {
	        self.logger.warn('invalid SDP');
	        self.logger.warn(e);
	        request.reply(488);
	      }
	    );
	  }
	};
	
	InviteServerContext.prototype = {
	  reject: function(options) {
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.logger.log('rejecting RTCSession');
	
	    SIP.ServerContext.prototype.reject.call(this, options);
	    return this.terminated();
	  },
	
	  terminate: function(options) {
	    options = options || {};
	
	    var
	    extraHeaders = (options.extraHeaders || []).slice(),
	    body = options.body,
	    dialog,
	    self = this;
	
	    if (this.status === C.STATUS_WAITING_FOR_ACK &&
	       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
	      dialog = this.dialog;
	
	      this.receiveRequest = function(request) {
	        if (request.method === SIP.C.ACK) {
	          this.request(SIP.C.BYE, {
	            extraHeaders: extraHeaders,
	            body: body
	          });
	          dialog.terminate();
	        }
	      };
	
	      this.request.server_transaction.on('stateChanged', function(){
	        if (this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	          this.request = new SIP.OutgoingRequest(
	            SIP.C.BYE,
	            this.dialog.remote_target,
	            this.ua,
	            {
	              'cseq': this.dialog.local_seqnum+=1,
	              'call_id': this.dialog.id.call_id,
	              'from_uri': this.dialog.local_uri,
	              'from_tag': this.dialog.id.local_tag,
	              'to_uri': this.dialog.remote_uri,
	              'to_tag': this.dialog.id.remote_tag,
	              'route_set': this.dialog.route_set
	            },
	            extraHeaders,
	            body
	          );
	
	          new SIP.RequestSender(
	            {
	              request: this.request,
	              onRequestTimeout: function() {
	                self.onRequestTimeout();
	              },
	              onTransportError: function() {
	                self.onTransportError();
	              },
	              receiveResponse: function() {
	                return;
	              }
	            },
	            this.ua
	          ).send();
	          dialog.terminate();
	        }
	      });
	
	      this.emit('bye', this.request);
	      this.terminated();
	
	      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)
	      this.dialog = dialog;
	
	      // Restore the dialog into 'ua' so the ACK can reach 'this' session
	      this.ua.dialogs[dialog.id.toString()] = dialog;
	
	    } else if (this.status === C.STATUS_CONFIRMED) {
	      this.bye(options);
	    } else {
	      this.reject(options);
	    }
	
	    return this;
	  },
	
	  /*
	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	   */
	  progress: function (options) {
	    options = options || {};
	    var
	      statusCode = options.statusCode || 180,
	      reasonPhrase = options.reasonPhrase,
	      extraHeaders = (options.extraHeaders || []).slice(),
	      iceServers,
	      stunServers = options.stunServers || null,
	      turnServers = options.turnServers || null,
	      body = options.body,
	      response;
	
	    if (statusCode < 100 || statusCode > 199) {
	      throw new TypeError('Invalid statusCode: ' + statusCode);
	    }
	
	    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    if (stunServers || turnServers) {
	      if (stunServers) {
	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid stunServers: '+ stunServers);
	        } else {
	          this.stunServers = iceServers;
	        }
	      }
	
	      if (turnServers) {
	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid turnServers: '+ turnServers);
	        } else {
	          this.turnServers = iceServers;
	        }
	      }
	
	      this.mediaHandler.updateIceServers({
	        stunServers: this.stunServers,
	        turnServers: this.turnServers
	      });
	    }
	
	    function do100rel() {
	      /* jshint validthis: true */
	      statusCode = options.statusCode || 183;
	
	      // Set status and add extra headers
	      this.status = C.STATUS_WAITING_FOR_PRACK;
	      extraHeaders.push('Contact: '+ this.contact);
	      extraHeaders.push('Require: 100rel');
	      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));
	
	      // Save media hint for later (referred sessions)
	      this.mediaHint = options.media;
	
	      // Get the session description to add to preaccept with
	      this.mediaHandler.getDescription(options.media)
	      .then(
	        function onSuccess (body) {
	          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
	            return;
	          }
	
	          this.early_sdp = body;
	          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;
	
	          // Retransmit until we get a response or we time out (see prackTimer below)
	          var timeout = SIP.Timers.T1;
	          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {
	            this.request.reply(statusCode, null, extraHeaders, body);
	            timeout *= 2;
	            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);
	          }.bind(this), timeout);
	
	          // Timeout and reject INVITE if no response
	          this.timers.prackTimer = SIP.Timers.setTimeout(function () {
	            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {
	              return;
	            }
	
	            this.logger.log('no PRACK received, rejecting the call');
	            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	            this.request.reply(504);
	            this.terminated(null, SIP.C.causes.NO_PRACK);
	          }.bind(this), SIP.Timers.T1 * 64);
	
	          // Send the initial response
	          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	          this.emit('progress', response, reasonPhrase);
	        }.bind(this),
	
	        function onFailure () {
	          this.request.reply(480);
	          this.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          this.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	        }.bind(this)
	      );
	    } // end do100rel
	
	    function normalReply() {
	      /* jshint validthis:true */
	      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	      this.emit('progress', response, reasonPhrase);
	    }
	
	    if (options.statusCode !== 100 &&
	        (this.rel100 === SIP.C.supported.REQUIRED ||
	         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||
	         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {
	      do100rel.apply(this);
	    } else {
	      normalReply.apply(this);
	    }
	    return this;
	  },
	
	  /*
	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	   */
	  accept: function(options) {
	    options = Object.create(Session.desugar(options));
	    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
	    this.mediaHint = options.media;
	
	    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21
	    var
	      //idx, length, hasAudio, hasVideo,
	      self = this,
	      request = this.request,
	      extraHeaders = (options.extraHeaders || []).slice(),
	    //mediaStream = options.mediaStream || null,
	      iceServers,
	      stunServers = options.stunServers || null,
	      turnServers = options.turnServers || null,
	      sdpCreationSucceeded = function(body) {
	        var
	          response,
	          // run for reply success callback
	          replySucceeded = function() {
	            self.status = C.STATUS_WAITING_FOR_ACK;
	
	            self.setInvite2xxTimer(request, body);
	            self.setACKTimer();
	          },
	
	          // run for reply failure callback
	          replyFailed = function() {
	            self.failed(null, SIP.C.causes.CONNECTION_ERROR);
	            self.terminated(null, SIP.C.causes.CONNECTION_ERROR);
	          };
	
	        // Chrome might call onaddstream before accept() is called, which means
	        // mediaHandler.render() was called without a renderHint, so we need to
	        // re-render now that mediaHint.render has been set.
	        //
	        // Chrome seems to be in the right regarding this, see
	        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream
	        self.mediaHandler.render();
	
	        extraHeaders.push('Contact: ' + self.contact);
	        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	
	        if(!self.hasOffer) {
	          self.hasOffer = true;
	        } else {
	          self.hasAnswer = true;
	        }
	        response = request.reply(200, null, extraHeaders,
	                      body,
	                      replySucceeded,
	                      replyFailed
	                     );
	        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail
	          self.accepted(response, SIP.Utils.getReasonPhrase(200));
	        }
	      },
	
	      sdpCreationFailed = function() {
	        if (self.status === C.STATUS_TERMINATED) {
	          return;
	        }
	        // TODO - fail out on error
	        self.request.reply(480);
	        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
	        self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	        self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	      };
	
	    // Check Session Status
	    if (this.status === C.STATUS_WAITING_FOR_PRACK) {
	      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;
	      return this;
	    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {
	      this.status = C.STATUS_ANSWERED;
	    } else if (this.status !== C.STATUS_EARLY_MEDIA) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    if ((stunServers || turnServers) &&
	        (this.status !== C.STATUS_EARLY_MEDIA && this.status !== C.STATUS_ANSWERED_WAITING_FOR_PRACK)) {
	      if (stunServers) {
	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid stunServers: '+ stunServers);
	        } else {
	          this.stunServers = iceServers;
	        }
	      }
	
	      if (turnServers) {
	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid turnServers: '+ turnServers);
	        } else {
	          this.turnServers = iceServers;
	        }
	      }
	
	      this.mediaHandler.updateIceServers({
	        stunServers: this.stunServers,
	        turnServers: this.turnServers
	      });
	    }
	
	    // An error on dialog creation will fire 'failed' event
	    if(!this.createDialog(request, 'UAS')) {
	      request.reply(500, 'Missing Contact header field');
	      return this;
	    }
	
	    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);
	
	    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21
	    /*
	    length = this.getRemoteStreams().length;
	
	    for (idx = 0; idx < length; idx++) {
	      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {
	        hasVideo = true;
	      }
	      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {
	        hasAudio = true;
	      }
	    }
	
	    if (!hasAudio && this.mediaConstraints.audio === true) {
	      this.mediaConstraints.audio = false;
	      if (mediaStream) {
	        length = mediaStream.getAudioTracks().length;
	        for (idx = 0; idx < length; idx++) {
	          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);
	        }
	      }
	    }
	
	    if (!hasVideo && this.mediaConstraints.video === true) {
	      this.mediaConstraints.video = false;
	      if (mediaStream) {
	        length = mediaStream.getVideoTracks().length;
	        for (idx = 0; idx < length; idx++) {
	          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);
	        }
	      }
	    }
	    */
	
	    if (this.status === C.STATUS_EARLY_MEDIA) {
	      sdpCreationSucceeded();
	    } else {
	      this.mediaHandler.getDescription(self.mediaHint)
	      .then(
	        sdpCreationSucceeded,
	        sdpCreationFailed
	      );
	    }
	
	    return this;
	  },
	
	  receiveRequest: function(request) {
	
	    // ISC RECEIVE REQUEST
	
	    function confirmSession() {
	      /* jshint validthis:true */
	      var contentType;
	
	      SIP.Timers.clearTimeout(this.timers.ackTimer);
	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
	      this.status = C.STATUS_CONFIRMED;
	      this.unmute();
	
	      // TODO - this logic assumes Content-Disposition defaults
	      contentType = request.getHeader('Content-Type');
	      if (contentType !== 'application/sdp') {
	        this.renderbody = request.body;
	        this.rendertype = contentType;
	      }
	    }
	
	    switch(request.method) {
	    case SIP.C.CANCEL:
	      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
	       * was in progress and that the UAC MAY continue with the session established by
	       * any 2xx response, or MAY terminate with BYE. SIP does continue with the
	       * established session. So the CANCEL is processed only if the session is not yet
	       * established.
	       */
	
	      /*
	       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the
	       *request opening the session.
	       */
	      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||
	         this.status === C.STATUS_WAITING_FOR_PRACK ||
	         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||
	         this.status === C.STATUS_EARLY_MEDIA ||
	         this.status === C.STATUS_ANSWERED) {
	
	        this.status = C.STATUS_CANCELED;
	        this.request.reply(487);
	        this.canceled(request);
	        this.rejected(request, SIP.C.causes.CANCELED);
	        this.failed(request, SIP.C.causes.CANCELED);
	        this.terminated(request, SIP.C.causes.CANCELED);
	      }
	      break;
	    case SIP.C.ACK:
	      if(this.status === C.STATUS_WAITING_FOR_ACK) {
	        if (!this.hasAnswer) {
	          if(request.body && request.getHeader('content-type') === 'application/sdp') {
	            // ACK contains answer to an INVITE w/o SDP negotiation
	            SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);
	            SIP.Hacks.AllBrowsers.maskDtls(request);
	
	            this.hasAnswer = true;
	            this.mediaHandler.setDescription(request.body)
	            .then(
	              confirmSession.bind(this),
	              function onFailure (e) {
	                this.logger.warn(e);
	                this.terminate({
	                  statusCode: '488',
	                  reasonPhrase: 'Bad Media Description'
	                });
	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }.bind(this)
	            );
	          } else if (this.early_sdp) {
	            confirmSession.apply(this);
	          } else {
	            //TODO: Pass to mediahandler
	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	          }
	        } else {
	          confirmSession.apply(this);
	        }
	      }
	      break;
	    case SIP.C.PRACK:
	      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	        //localMedia = session.mediaHandler.localMedia;
	        if(!this.hasAnswer) {
	          if(request.body && request.getHeader('content-type') === 'application/sdp') {
	            this.hasAnswer = true;
	            this.mediaHandler.setDescription(request.body)
	            .then(
	              function onSuccess () {
	                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	                SIP.Timers.clearTimeout(this.timers.prackTimer);
	                request.reply(200);
	                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	                  this.status = C.STATUS_EARLY_MEDIA;
	                  this.accept();
	                }
	                this.status = C.STATUS_EARLY_MEDIA;
	                //REVISIT
	                this.mute();
	              }.bind(this),
	              function onFailure (e) {
	                //TODO: Send to media handler
	                this.logger.warn(e);
	                this.terminate({
	                  statusCode: '488',
	                  reasonPhrase: 'Bad Media Description'
	                });
	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }.bind(this)
	            );
	          } else {
	            this.terminate({
	              statusCode: '488',
	              reasonPhrase: 'Bad Media Description'
	            });
	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	          }
	        } else {
	          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	          SIP.Timers.clearTimeout(this.timers.prackTimer);
	          request.reply(200);
	
	          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	            this.status = C.STATUS_EARLY_MEDIA;
	            this.accept();
	          }
	          this.status = C.STATUS_EARLY_MEDIA;
	          //REVISIT
	          this.mute();
	        }
	      } else if(this.status === C.STATUS_EARLY_MEDIA) {
	        request.reply(200);
	      }
	      break;
	    default:
	      Session.prototype.receiveRequest.apply(this, [request]);
	      break;
	    }
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  }
	
	};
	
	SIP.InviteServerContext = InviteServerContext;
	
	InviteClientContext = function(ua, target, options) {
	  options = Object.create(Session.desugar(options));
	  options.params = Object.create(options.params || Object.prototype);
	
	  var iceServers,
	    extraHeaders = (options.extraHeaders || []).slice(),
	    stunServers = options.stunServers || null,
	    turnServers = options.turnServers || null,
	    mediaHandlerFactory = options.mediaHandlerFactory || ua.configuration.mediaHandlerFactory,
	    isMediaSupported = mediaHandlerFactory.isSupported;
	
	  // Check WebRTC support
	  if (isMediaSupported && !isMediaSupported()) {
	    throw new SIP.Exceptions.NotSupportedError('Media not supported');
	  }
	
	  this.RTCConstraints = options.RTCConstraints || {};
	  this.inviteWithoutSdp = options.inviteWithoutSdp || false;
	
	  // Set anonymous property
	  this.anonymous = options.anonymous || false;
	
	  // Custom data to be sent either in INVITE or in ACK
	  this.renderbody = options.renderbody || null;
	  this.rendertype = options.rendertype || 'text/plain';
	
	  options.params.from_tag = this.from_tag;
	
	  /* Do not add ;ob in initial forming dialog requests if the registration over
	   *  the current connection got a GRUU URI.
	   */
	  this.contact = ua.contact.toString({
	    anonymous: this.anonymous,
	    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu
	  });
	
	  if (this.anonymous) {
	    options.params.from_displayName = 'Anonymous';
	    options.params.from_uri = 'sip:anonymous@anonymous.invalid';
	
	    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());
	    extraHeaders.push('Privacy: id');
	  }
	  extraHeaders.push('Contact: '+ this.contact);
	  extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	  if (!this.inviteWithoutSdp) {
	    extraHeaders.push('Content-Type: application/sdp');
	  } else if (this.renderbody) {
	    extraHeaders.push('Content-Type: ' + this.rendertype);
	    extraHeaders.push('Content-Disposition: render;handling=optional');
	  }
	
	  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {
	    extraHeaders.push('Require: 100rel');
	  }
	  if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {
	    extraHeaders.push('Require: replaces');
	  }
	
	  options.extraHeaders = extraHeaders;
	
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);
	  SIP.Utils.augment(this, SIP.Session, [mediaHandlerFactory]);
	
	  // Check Session Status
	  if (this.status !== C.STATUS_NULL) {
	    throw new SIP.Exceptions.InvalidStateError(this.status);
	  }
	
	  // Session parameter initialization
	  this.from_tag = SIP.Utils.newTag();
	
	  // OutgoingSession specific parameters
	  this.isCanceled = false;
	  this.received_100 = false;
	
	  this.method = SIP.C.INVITE;
	
	  this.receiveNonInviteResponse = this.receiveResponse;
	  this.receiveResponse = this.receiveInviteResponse;
	
	  this.logger = ua.getLogger('sip.inviteclientcontext');
	
	  if (stunServers) {
	    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	    if (!iceServers) {
	      throw new TypeError('Invalid stunServers: '+ stunServers);
	    } else {
	      this.stunServers = iceServers;
	    }
	  }
	
	  if (turnServers) {
	    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	    if (!iceServers) {
	      throw new TypeError('Invalid turnServers: '+ turnServers);
	    } else {
	      this.turnServers = iceServers;
	    }
	  }
	
	  ua.applicants[this] = this;
	
	  this.id = this.request.call_id + this.from_tag;
	
	  //Initialize Media Session
	  this.mediaHandler = this.mediaHandlerFactory(this, {
	    RTCConstraints: this.RTCConstraints,
	    stunServers: this.stunServers,
	    turnServers: this.turnServers
	  });
	
	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
	  }
	
	  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
	  this.mediaHint = options.media;
	};
	
	InviteClientContext.prototype = {
	  invite: function () {
	    var self = this;
	
	    //Save the session into the ua sessions collection.
	    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway
	    this.ua.sessions[this.id] = this;
	
	    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level
	    // and hand sip.js a stream as the mediaHint
	    if (this.inviteWithoutSdp) {
	      //just send an invite with no sdp...
	      this.request.body = self.renderbody;
	      this.status = C.STATUS_INVITE_SENT;
	      this.send();
	    } else {
	      this.mediaHandler.getDescription(self.mediaHint)
	      .then(
	        function onSuccess(offer) {
	          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {
	            return;
	          }
	          self.hasOffer = true;
	          self.request.body = offer;
	          self.status = C.STATUS_INVITE_SENT;
	          self.send();
	        },
	        function onFailure() {
	          if (self.status === C.STATUS_TERMINATED) {
	            return;
	          }
	          // TODO...fail out
	          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
	          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	        }
	      );
	    }
	
	    return this;
	  },
	
	  receiveInviteResponse: function(response) {
	    var cause, //localMedia,
	      session = this,
	      id = response.call_id + response.from_tag + response.to_tag,
	      extraHeaders = [],
	      options = {};
	
	    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {
	      return;
	    }
	
	    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {
	      if (id !== this.dialog.id.toString() ) {
	        if (!this.createDialog(response, 'UAC', true)) {
	          return;
	        }
	        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,
	                                          {
	                                            body: SIP.Utils.generateFakeSDP(response.body)
	                                          });
	        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);
	
	        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable
	         * leg (due to peerConnection limitations) has been answered first. If your forking
	         * proxy does not hang up all unanswered branches on the first branch answered, remove this.
	         */
	        if(this.status !== C.STATUS_CONFIRMED) {
	          this.failed(response, SIP.C.causes.WEBRTC_ERROR);
	          this.terminated(response, SIP.C.causes.WEBRTC_ERROR);
	        }
	        return;
	      } else if (this.status === C.STATUS_CONFIRMED) {
	        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
	        return;
	      } else if (!this.hasAnswer) {
	        // invite w/o sdp is waiting for callback
	        //an invite with sdp must go on, and hasAnswer is true
	        return;
	      }
	    }
	
	    if (this.dialog && response.status_code < 200) {
	      /*
	        Early media has been set up with at least one other different branch,
	        but a final 2xx response hasn't been received
	      */
	      if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	          (this.dialog.pracked[this.dialog.pracked.length-1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0)) {
	        return;
	      }
	
	      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {
	        return;
	      }
	
	      if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	          (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
	        return;
	      }
	
	      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
	
	      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
	        extraHeaders: extraHeaders,
	        body: SIP.Utils.generateFakeSDP(response.body)
	      });
	      return;
	    }
	
	    // Proceed to cancellation if the user requested.
	    if(this.isCanceled) {
	      if(response.status_code >= 100 && response.status_code < 200) {
	        this.request.cancel(this.cancelReason);
	        this.canceled(null);
	      } else if(response.status_code >= 200 && response.status_code < 299) {
	        this.acceptAndTerminate(response);
	        this.emit('bye', this.request);
	      } else if (response.status_code >= 300) {
	        cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;
	        this.rejected(response, cause);
	        this.failed(response, cause);
	        this.terminated(response, cause);
	      }
	      return;
	    }
	
	    switch(true) {
	      case /^100$/.test(response.status_code):
	        this.received_100 = true;
	        this.emit('progress', response);
	        break;
	      case (/^1[0-9]{2}$/.test(response.status_code)):
	        // Do nothing with 1xx responses without To tag.
	        if(!response.to_tag) {
	          this.logger.warn('1xx response received without to tag');
	          break;
	        }
	
	        // Create Early Dialog if 1XX comes with contact
	        if(response.hasHeader('contact')) {
	          // An error on dialog creation will fire 'failed' event
	          if (!this.createDialog(response, 'UAC', true)) {
	            break;
	          }
	        }
	
	        this.status = C.STATUS_1XX_RECEIVED;
	
	        if(response.hasHeader('require') &&
	           response.getHeader('require').indexOf('100rel') !== -1) {
	
	          // Do nothing if this.dialog is already confirmed
	          if (this.dialog || !this.earlyDialogs[id]) {
	            break;
	          }
	
	          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
	            return;
	          }
	
	          SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);
	          SIP.Hacks.AllBrowsers.maskDtls(response);
	
	          if (!response.body) {
	            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
	            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
	              extraHeaders: extraHeaders
	            });
	            this.emit('progress', response);
	
	          } else if (this.hasOffer) {
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.hasAnswer = true;
	            this.dialog.pracked.push(response.getHeader('rseq'));
	
	            this.mediaHandler.setDescription(response.body)
	            .then(
	              function onSuccess () {
	                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	
	                session.sendRequest(SIP.C.PRACK, {
	                  extraHeaders: extraHeaders,
	                  receiveResponse: function() {}
	                });
	                session.status = C.STATUS_EARLY_MEDIA;
	                session.mute();
	                session.emit('progress', response);
	                /*
	                if (session.status === C.STATUS_EARLY_MEDIA) {
	                  localMedia = session.mediaHandler.localMedia;
	                  if (localMedia.getAudioTracks().length > 0) {
	                    localMedia.getAudioTracks()[0].enabled = false;
	                  }
	                  if (localMedia.getVideoTracks().length > 0) {
	                    localMedia.getVideoTracks()[0].enabled = false;
	                  }
	                }*/
	              },
	              function onFailure (e) {
	                session.logger.warn(e);
	                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
	                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }
	            );
	          } else {
	            var earlyDialog = this.earlyDialogs[id];
	            var earlyMedia = earlyDialog.mediaHandler;
	
	            earlyDialog.pracked.push(response.getHeader('rseq'));
	
	            earlyMedia.setDescription(response.body)
	            .then(earlyMedia.getDescription.bind(earlyMedia, session.mediaHint))
	            .then(function onSuccess(sdp) {
	              extraHeaders.push('Content-Type: application/sdp');
	              extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	              earlyDialog.sendRequest(session, SIP.C.PRACK, {
	                extraHeaders: extraHeaders,
	                body: sdp
	              });
	              session.status = C.STATUS_EARLY_MEDIA;
	              session.emit('progress', response);
	            })
	            .catch(function onFailure(e) {
	              if (e instanceof SIP.Exceptions.GetDescriptionError) {
	                earlyDialog.pracked.push(response.getHeader('rseq'));
	                if (session.status === C.STATUS_TERMINATED) {
	                  return;
	                }
	                // TODO - fail out on error
	                // session.failed(gum error);
	                session.failed(null, SIP.C.causes.WEBRTC_ERROR);
	                session.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	              } else {
	                earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1);
	                // Could not set remote description
	                session.logger.warn('invalid SDP');
	                session.logger.warn(e);
	              }
	            });
	          }
	        } else {
	          this.emit('progress', response);
	        }
	        break;
	      case /^2[0-9]{2}$/.test(response.status_code):
	        var cseq = this.request.cseq + ' ' + this.request.method;
	        if (cseq !== response.getHeader('cseq')) {
	          break;
	        }
	
	        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {
	          this.status = C.STATUS_CONFIRMED;
	          this.unmute();
	          /*localMedia = this.mediaHandler.localMedia;
	          if (localMedia.getAudioTracks().length > 0) {
	            localMedia.getAudioTracks()[0].enabled = true;
	          }
	          if (localMedia.getVideoTracks().length > 0) {
	            localMedia.getVideoTracks()[0].enabled = true;
	          }*/
	          options = {};
	          if (this.renderbody) {
	            extraHeaders.push('Content-Type: ' + this.rendertype);
	            options.extraHeaders = extraHeaders;
	            options.body = this.renderbody;
	          }
	          options.cseq = response.cseq;
	          this.sendRequest(SIP.C.ACK, options);
	          this.accepted(response);
	          break;
	        }
	        // Do nothing if this.dialog is already confirmed
	        if (this.dialog) {
	          break;
	        }
	
	        SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);
	        SIP.Hacks.AllBrowsers.maskDtls(response);
	
	        // This is an invite without sdp
	        if (!this.hasOffer) {
	          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {
	            //REVISIT
	            this.hasOffer = true;
	            this.hasAnswer = true;
	            this.mediaHandler = this.earlyDialogs[id].mediaHandler;
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.status = C.STATUS_CONFIRMED;
	            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});
	
	            this.unmute();
	            /*
	            localMedia = session.mediaHandler.localMedia;
	            if (localMedia.getAudioTracks().length > 0) {
	              localMedia.getAudioTracks()[0].enabled = true;
	            }
	            if (localMedia.getVideoTracks().length > 0) {
	              localMedia.getVideoTracks()[0].enabled = true;
	            }*/
	            this.accepted(response);
	          } else {
	            if(!response.body) {
	              this.acceptAndTerminate(response, 400, 'Missing session description');
	              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              break;
	            }
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.hasOffer = true;
	            this.mediaHandler.setDescription(response.body)
	            .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
	            .then(function onSuccess(sdp) {
	              //var localMedia;
	              if(session.isCanceled || session.status === C.STATUS_TERMINATED) {
	                return;
	              }
	
	              sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);
	
	              session.status = C.STATUS_CONFIRMED;
	              session.hasAnswer = true;
	
	              session.unmute();
	              /*localMedia = session.mediaHandler.localMedia;
	              if (localMedia.getAudioTracks().length > 0) {
	                localMedia.getAudioTracks()[0].enabled = true;
	              }
	              if (localMedia.getVideoTracks().length > 0) {
	                localMedia.getVideoTracks()[0].enabled = true;
	              }*/
	              session.sendRequest(SIP.C.ACK,{
	                body: sdp,
	                extraHeaders:['Content-Type: application/sdp'],
	                cseq:response.cseq
	              });
	              session.accepted(response);
	            })
	            .catch(function onFailure(e) {
	              if (e instanceof SIP.Exceptions.GetDescriptionError) {
	                // TODO do something here
	                session.logger.warn("there was a problem");
	              } else {
	                session.logger.warn('invalid SDP');
	                session.logger.warn(e);
	                response.reply(488);
	              }
	            });
	          }
	        } else if (this.hasAnswer){
	          if (this.renderbody) {
	            extraHeaders.push('Content-Type: ' + session.rendertype);
	            options.extraHeaders = extraHeaders;
	            options.body = this.renderbody;
	          }
	          this.sendRequest(SIP.C.ACK, options);
	        } else {
	          if(!response.body) {
	            this.acceptAndTerminate(response, 400, 'Missing session description');
	            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            break;
	          }
	          if (!this.createDialog(response, 'UAC')) {
	            break;
	          }
	          this.hasAnswer = true;
	          this.mediaHandler.setDescription(response.body)
	          .then(
	            function onSuccess () {
	              var options = {};//,localMedia;
	              session.status = C.STATUS_CONFIRMED;
	              session.unmute();
	              /*localMedia = session.mediaHandler.localMedia;
	              if (localMedia.getAudioTracks().length > 0) {
	                localMedia.getAudioTracks()[0].enabled = true;
	              }
	              if (localMedia.getVideoTracks().length > 0) {
	                localMedia.getVideoTracks()[0].enabled = true;
	              }*/
	              if (session.renderbody) {
	                extraHeaders.push('Content-Type: ' + session.rendertype);
	                options.extraHeaders = extraHeaders;
	                options.body = session.renderbody;
	              }
	              options.cseq = response.cseq;
	              session.sendRequest(SIP.C.ACK, options);
	              session.accepted(response);
	            },
	            function onFailure (e) {
	              session.logger.warn(e);
	              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
	              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            }
	          );
	        }
	        break;
	      default:
	        cause = SIP.Utils.sipErrorCause(response.status_code);
	        this.rejected(response, cause);
	        this.failed(response, cause);
	        this.terminated(response, cause);
	    }
	  },
	
	  cancel: function(options) {
	    options = options || {};
	
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.logger.log('canceling RTCSession');
	
	    var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
	
	    // Check Session Status
	    if (this.status === C.STATUS_NULL ||
	        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {
	      this.isCanceled = true;
	      this.cancelReason = cancel_reason;
	    } else if (this.status === C.STATUS_INVITE_SENT ||
	               this.status === C.STATUS_1XX_RECEIVED ||
	               this.status === C.STATUS_EARLY_MEDIA) {
	      this.request.cancel(cancel_reason);
	    }
	
	    return this.canceled();
	  },
	
	  terminate: function(options) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {
	      this.bye(options);
	    } else {
	      this.cancel(options);
	    }
	
	    return this;
	  },
	
	  receiveRequest: function(request) {
	    // ICC RECEIVE REQUEST
	
	    // Reject CANCELs
	    if (request.method === SIP.C.CANCEL) {
	      // TODO; make this a switch when it gets added
	    }
	
	    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {
	      SIP.Timers.clearTimeout(this.timers.ackTimer);
	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
	      this.status = C.STATUS_CONFIRMED;
	      this.unmute();
	
	      this.accepted();
	    }
	
	    return Session.prototype.receiveRequest.apply(this, [request]);
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  }
	
	};
	
	SIP.InviteClientContext = InviteClientContext;
	
	};


/***/ },
/* 234 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview DTMF
	 */
	
	/**
	 * @class DTMF
	 * @param {SIP.Session} session
	 */
	module.exports = function (SIP) {
	
	var DTMF,
	  C = {
	    MIN_DURATION:            70,
	    MAX_DURATION:            6000,
	    DEFAULT_DURATION:        100,
	    MIN_INTER_TONE_GAP:      50,
	    DEFAULT_INTER_TONE_GAP:  500
	  };
	
	DTMF = function(session, tone, options) {
	  var duration, interToneGap;
	
	  if (tone === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);
	  this.owner = session;
	  this.direction = null;
	
	  options = options || {};
	  duration = options.duration || null;
	  interToneGap = options.interToneGap || null;
	
	  // Check tone type
	  if (typeof tone === 'string' ) {
	    tone = tone.toUpperCase();
	  } else if (typeof tone === 'number') {
	    tone = tone.toString();
	  } else {
	    throw new TypeError('Invalid tone: '+ tone);
	  }
	
	  // Check tone value
	  if (!tone.match(/^[0-9A-D#*]$/)) {
	    throw new TypeError('Invalid tone: '+ tone);
	  } else {
	    this.tone = tone;
	  }
	
	  // Check duration
	  if (duration && !SIP.Utils.isDecimal(duration)) {
	    throw new TypeError('Invalid tone duration: '+ duration);
	  } else if (!duration) {
	    duration = DTMF.C.DEFAULT_DURATION;
	  } else if (duration < DTMF.C.MIN_DURATION) {
	    this.logger.warn('"duration" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');
	    duration = DTMF.C.MIN_DURATION;
	  } else if (duration > DTMF.C.MAX_DURATION) {
	    this.logger.warn('"duration" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');
	    duration = DTMF.C.MAX_DURATION;
	  } else {
	    duration = Math.abs(duration);
	  }
	  this.duration = duration;
	
	  // Check interToneGap
	  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {
	    throw new TypeError('Invalid interToneGap: '+ interToneGap);
	  } else if (!interToneGap) {
	    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;
	  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {
	    this.logger.warn('"interToneGap" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');
	    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;
	  } else {
	    interToneGap = Math.abs(interToneGap);
	  }
	  this.interToneGap = interToneGap;
	};
	DTMF.prototype = Object.create(SIP.EventEmitter.prototype);
	
	
	DTMF.prototype.send = function(options) {
	  var extraHeaders, body;
	
	  this.direction = 'outgoing';
	
	  // Check RTCSession Status
	  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&
	    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {
	    throw new SIP.Exceptions.InvalidStateError(this.owner.status);
	  }
	
	  // Get DTMF options
	  options = options || {};
	  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
	
	  extraHeaders.push('Content-Type: application/dtmf-relay');
	
	  body = "Signal= " + this.tone + "\r\n";
	  body += "Duration= " + this.duration;
	
	  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {
	    extraHeaders: extraHeaders,
	    body: body
	  });
	
	  this.owner.emit('dtmf', this.request, this);
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.receiveResponse = function(response) {
	  var cause;
	
	  switch(true) {
	    case /^1[0-9]{2}$/.test(response.status_code):
	      // Ignore provisional responses.
	      break;
	
	    case /^2[0-9]{2}$/.test(response.status_code):
	      this.emit('succeeded', {
	        originator: 'remote',
	        response: response
	      });
	      break;
	
	    default:
	      cause = SIP.Utils.sipErrorCause(response.status_code);
	      this.emit('failed', response, cause);
	      break;
	  }
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onRequestTimeout = function() {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	  this.owner.onRequestTimeout();
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onTransportError = function() {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	  this.owner.onTransportError();
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onDialogError = function(response) {
	  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);
	  this.owner.onDialogError(response);
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.init_incoming = function(request) {
	  this.direction = 'incoming';
	  this.request = request;
	
	  request.reply(200);
	
	  if (!this.tone || !this.duration) {
	    this.logger.warn('invalid INFO DTMF received, discarded');
	  } else {
	    this.owner.emit('dtmf', request, this);
	  }
	};
	
	DTMF.C = C;
	return DTMF;
	};


/***/ },
/* 235 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP Subscription.
	 */
	module.exports = function (SIP) {
	SIP.Subscription = function (ua, target, event, options) {
	  options = Object.create(options || Object.prototype);
	  this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();
	
	  this.id = null;
	  this.state = 'init';
	
	  if (!event) {
	    throw new TypeError('Event necessary to create a subscription.');
	  } else {
	    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?
	    //The check may need to/should probably occur on the other side,
	    this.event = event;
	  }
	
	  if(typeof options.expires !== 'number'){
	    ua.logger.warn('expires must be a number. Using default of 3600.');
	    this.expires = 3600;
	  } else {
	    this.expires = options.expires;
	  }
	
	  options.extraHeaders.push('Event: ' + this.event);
	  options.extraHeaders.push('Expires: ' + this.expires);
	
	  if (options.body) {
	    this.body = options.body;
	  }
	
	  this.contact = ua.contact.toString();
	
	  options.extraHeaders.push('Contact: '+ this.contact);
	  options.extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);
	
	  this.logger = ua.getLogger('sip.subscription');
	
	  this.dialog = null;
	  this.timers = {N: null, sub_duration: null};
	  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];
	};
	
	SIP.Subscription.prototype = {
	  subscribe: function() {
	    var sub = this;
	
	     //these states point to an existing subscription, no subscribe is necessary
	    if (this.state === 'active') {
	      this.refresh();
	      return this;
	    } else if (this.state === 'notify_wait') {
	      return this;
	    }
	
	    SIP.Timers.clearTimeout(this.timers.sub_duration);
	    SIP.Timers.clearTimeout(this.timers.N);
	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
	
	    this.send();
	
	    this.state = 'notify_wait';
	
	    return this;
	  },
	
	  refresh: function () {
	    if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {
	      return;
	    }
	
	    this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {
	      extraHeaders: this.extraHeaders,
	      body: this.body
	    });
	  },
	
	  receiveResponse: function(response) {
	    var expires, sub = this,
	        cause = SIP.Utils.getReasonPhrase(response.status_code);
	
	    if ((this.state === 'notify_wait' && response.status_code >= 300) ||
	        (this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1)) {
	      this.failed(response, null);
	    } else if (/^2[0-9]{2}$/.test(response.status_code)){
	      expires = response.getHeader('Expires');
	      SIP.Timers.clearTimeout(this.timers.N);
	
	      if (this.createConfirmedDialog(response,'UAC')) {
	        this.id = this.dialog.id.toString();
	        this.ua.subscriptions[this.id] = this;
	        this.emit('accepted', response, cause);
	        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?
	      }
	
	      if (expires && expires <= this.expires) {
	        // Preserve new expires value for subsequent requests
	        this.expires = expires;
	        this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);
	      } else {
	        if (!expires) {
	          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');
	          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);
	        } else {
	          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');
	          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);
	        }
	      }
	    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx
	  },
	
	  unsubscribe: function() {
	    var extraHeaders = [], sub = this;
	
	    this.state = 'terminated';
	
	    extraHeaders.push('Event: ' + this.event);
	    extraHeaders.push('Expires: 0');
	
	    extraHeaders.push('Contact: '+ this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	
	    //makes sure expires isn't set, and other typical resubscribe behavior
	    this.receiveResponse = function(){};
	
	    this.dialog.sendRequest(this, this.method, {
	      extraHeaders: extraHeaders,
	      body: this.body
	    });
	
	    SIP.Timers.clearTimeout(this.timers.sub_duration);
	    SIP.Timers.clearTimeout(this.timers.N);
	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
	  },
	
	  /**
	  * @private
	  */
	  timer_fire: function(){
	    if (this.state === 'terminated') {
	      this.terminateDialog();
	      SIP.Timers.clearTimeout(this.timers.N);
	      SIP.Timers.clearTimeout(this.timers.sub_duration);
	
	      delete this.ua.subscriptions[this.id];
	    } else if (this.state === 'pending' || this.state === 'notify_wait') {
	      this.close();
	    } else {
	      this.refresh();
	    }
	  },
	
	  /**
	  * @private
	  */
	  close: function() {
	    if(this.state !== 'notify_wait' && this.state !== 'terminated') {
	      this.unsubscribe();
	    }
	  },
	
	  /**
	  * @private
	  */
	  createConfirmedDialog: function(message, type) {
	    var dialog;
	
	    this.terminateDialog();
	    dialog = new SIP.Dialog(this, message, type);
	
	    if(!dialog.error) {
	      this.dialog = dialog;
	      return true;
	    }
	    // Dialog not created due to an error
	    else {
	      return false;
	    }
	  },
	
	  /**
	  * @private
	  */
	  terminateDialog: function() {
	    if(this.dialog) {
	      delete this.ua.subscriptions[this.id];
	      this.dialog.terminate();
	      delete this.dialog;
	    }
	  },
	
	  /**
	  * @private
	  */
	  receiveRequest: function(request) {
	    var sub_state, sub = this;
	
	    function setExpiresTimeout() {
	      if (sub_state.expires) {
	        SIP.Timers.clearTimeout(sub.timers.sub_duration);
	        sub_state.expires = Math.min(sub.expires,
	                                     Math.max(sub_state.expires, 0));
	        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub),
	                                                    sub_state.expires * 900);
	      }
	    }
	
	    if (!this.matchEvent(request)) { //checks event and subscription_state headers
	      request.reply(489);
	      return;
	    }
	
	    sub_state = request.parseHeader('Subscription-State');
	
	    request.reply(200, SIP.C.REASON_200);
	
	    SIP.Timers.clearTimeout(this.timers.N);
	
	    this.emit('notify', {request: request});
	
	    // if we've set state to terminated, no further processing should take place
	    // and we are only interested in cleaning up after the appropriate NOTIFY
	    if (this.state === 'terminated') {
	      if (sub_state.state === 'terminated') {
	        this.terminateDialog();
	        SIP.Timers.clearTimeout(this.timers.N);
	        SIP.Timers.clearTimeout(this.timers.sub_duration);
	
	        delete this.ua.subscriptions[this.id];
	      }
	      return;
	    }
	
	    switch (sub_state.state) {
	      case 'active':
	        this.state = 'active';
	        setExpiresTimeout();
	        break;
	      case 'pending':
	        if (this.state === 'notify_wait') {
	          setExpiresTimeout();
	        }
	        this.state = 'pending';
	        break;
	      case 'terminated':
	        SIP.Timers.clearTimeout(this.timers.sub_duration);
	        if (sub_state.reason) {
	          this.logger.log('terminating subscription with reason '+ sub_state.reason);
	          switch (sub_state.reason) {
	            case 'deactivated':
	            case 'timeout':
	              this.subscribe();
	              return;
	            case 'probation':
	            case 'giveup':
	              if(sub_state.params && sub_state.params['retry-after']) {
	                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);
	              } else {
	                this.subscribe();
	              }
	              return;
	            case 'rejected':
	            case 'noresource':
	            case 'invariant':
	              break;
	          }
	        }
	        this.close();
	        break;
	    }
	  },
	
	  failed: function(response, cause) {
	    this.close();
	    this.emit('failed', response, cause);
	    return this;
	  },
	
	  onDialogError: function(response) {
	    this.failed(response, SIP.C.causes.DIALOG_ERROR);
	  },
	
	  /**
	  * @private
	  */
	  matchEvent: function(request) {
	    var event;
	
	    // Check mandatory header Event
	    if (!request.hasHeader('Event')) {
	      this.logger.warn('missing Event header');
	      return false;
	    }
	    // Check mandatory header Subscription-State
	    if (!request.hasHeader('Subscription-State')) {
	      this.logger.warn('missing Subscription-State header');
	      return false;
	    }
	
	    // Check whether the event in NOTIFY matches the event in SUBSCRIBE
	    event = request.parseHeader('event').event;
	
	    if (this.event !== event) {
	      this.logger.warn('event match failed');
	      request.reply(481, 'Event Match Failed');
	      return false;
	    } else {
	      return true;
	    }
	  }
	};
	};


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileoverview WebRTC
	 */
	
	module.exports = function (SIP, environment) {
	var WebRTC;
	
	WebRTC = {};
	
	WebRTC.MediaHandler = __webpack_require__(237)(SIP);
	WebRTC.MediaStreamManager = __webpack_require__(238)(SIP, environment);
	
	var _isSupported;
	
	WebRTC.isSupported = function () {
	  if (_isSupported !== undefined) {
	    return _isSupported;
	  }
	
	  WebRTC.MediaStream = environment.MediaStream;
	  WebRTC.getUserMedia = environment.getUserMedia;
	  WebRTC.RTCPeerConnection = environment.RTCPeerConnection;
	  WebRTC.RTCSessionDescription = environment.RTCSessionDescription;
	
	  if (WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {
	    if (WebRTC.getUserMedia) {
	      WebRTC.getUserMedia = SIP.Utils.promisify(environment, 'getUserMedia');
	    }
	    _isSupported = true;
	  }
	  else {
	    _isSupported = false;
	  }
	  return _isSupported;
	};
	
	return WebRTC;
	};


/***/ },
/* 237 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaHandler
	 */
	
	/* MediaHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]
	 *        The MediaStreamManager to acquire/release streams from/to.
	 *        If not provided, a default MediaStreamManager will be used.
	 */
	module.exports = function (SIP) {
	
	var MediaHandler = function(session, options) {
	  options = options || {};
	
	  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);
	  this.session = session;
	  this.localMedia = null;
	  this.ready = true;
	  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);
	  this.audioMuted = false;
	  this.videoMuted = false;
	
	  // old init() from here on
	  var servers = this.prepareIceServers(options.stunServers, options.turnServers);
	  this.RTCConstraints = options.RTCConstraints || {};
	
	  this.initPeerConnection(servers, this.RTCConstraints);
	
	  function selfEmit(mh, event) {
	    if (mh.mediaStreamManager.on) {
	      mh.mediaStreamManager.on(event, function () {
	        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));
	      });
	    }
	  }
	
	  selfEmit(this, 'userMediaRequest');
	  selfEmit(this, 'userMedia');
	  selfEmit(this, 'userMediaFailed');
	};
	
	MediaHandler.defaultFactory = function defaultFactory (session, options) {
	  return new MediaHandler(session, options);
	};
	MediaHandler.defaultFactory.isSupported = function () {
	  return SIP.WebRTC.isSupported();
	};
	
	MediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {
	// Functions the session can use
	  isReady: {writable: true, value: function isReady () {
	    return this.ready;
	  }},
	
	  close: {writable: true, value: function close () {
	    this.logger.log('closing PeerConnection');
	    this._remoteStreams = [];
	    // have to check signalingState since this.close() gets called multiple times
	    // TODO figure out why that happens
	    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {
	      this.peerConnection.close();
	
	      if(this.localMedia) {
	        this.mediaStreamManager.release(this.localMedia);
	      }
	    }
	  }},
	
	  /**
	   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]
	   *        the MediaStream (or the constraints describing it) to be used for the session
	   */
	  getDescription: {writable: true, value: function getDescription (mediaHint) {
	    var self = this;
	    var acquire = self.mediaStreamManager.acquire;
	    if (acquire.length > 1) {
	      acquire = SIP.Utils.promisify(this.mediaStreamManager, 'acquire', true);
	    }
	    mediaHint = mediaHint || {};
	    if (mediaHint.dataChannel === true) {
	      mediaHint.dataChannel = {};
	    }
	    this.mediaHint = mediaHint;
	
	    /*
	     * 1. acquire streams (skip if MediaStreams passed in)
	     * 2. addStreams
	     * 3. createOffer/createAnswer
	     */
	
	    var streamPromise;
	    if (self.localMedia) {
	      self.logger.log('already have local media');
	      streamPromise = SIP.Utils.Promise.resolve(self.localMedia);
	    }
	    else {
	      self.logger.log('acquiring local media');
	      streamPromise = acquire.call(self.mediaStreamManager, mediaHint)
	        .then(function acquireSucceeded(streams) {
	          self.logger.log('acquired local media streams');
	          self.localMedia = streams;
	          self.session.connecting();
	          return streams;
	        }, function acquireFailed(err) {
	          self.logger.error('unable to acquire streams');
	          self.logger.error(err);
	          self.session.connecting();
	          throw err;
	        })
	        .then(this.addStreams.bind(this))
	      ;
	    }
	
	    return streamPromise
	      .then(function streamAdditionSucceeded() {
	        if (self.hasOffer('remote')) {
	          self.peerConnection.ondatachannel = function (evt) {
	            self.dataChannel = evt.channel;
	            self.emit('dataChannel', self.dataChannel);
	          };
	        } else if (mediaHint.dataChannel &&
	                   self.peerConnection.createDataChannel) {
	          self.dataChannel = self.peerConnection.createDataChannel(
	            'sipjs',
	            mediaHint.dataChannel
	          );
	          self.emit('dataChannel', self.dataChannel);
	        }
	
	        self.render();
	        return self.createOfferOrAnswer(self.RTCConstraints);
	      })
	    ;
	  }},
	
	  /**
	  * Message reception.
	  * @param {String} type
	  * @param {String} sdp
	  */
	  setDescription: {writable: true, value: function setDescription (sdp) {
	    var rawDescription = {
	      type: this.hasOffer('local') ? 'answer' : 'offer',
	      sdp: sdp
	    };
	
	    this.emit('setDescription', rawDescription);
	
	    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);
	    return SIP.Utils.promisify(this.peerConnection, 'setRemoteDescription')(description);
	  }},
	
	  /**
	   * If the Session associated with this MediaHandler were to be referred,
	   * what mediaHint should be provided to the UA's invite method?
	   */
	  getReferMedia: {writable: true, value: function getReferMedia () {
	    function hasTracks (trackGetter, stream) {
	      return stream[trackGetter]().length > 0;
	    }
	
	    function bothHaveTracks (trackGetter) {
	      /* jshint validthis:true */
	      return this.getLocalStreams().some(hasTracks.bind(null, trackGetter)) &&
	             this.getRemoteStreams().some(hasTracks.bind(null, trackGetter));
	    }
	
	    return {
	      constraints: {
	        audio: bothHaveTracks.call(this, 'getAudioTracks'),
	        video: bothHaveTracks.call(this, 'getVideoTracks')
	      }
	    };
	  }},
	
	  updateIceServers: {writeable:true, value: function (options) {
	    var servers = this.prepareIceServers(options.stunServers, options.turnServers);
	    this.RTCConstraints = options.RTCConstraints || this.RTCConstraints;
	
	    this.initPeerConnection(servers, this.RTCConstraints);
	
	    /* once updateIce is implemented correctly, this is better than above
	    //no op if browser does not support this
	    if (!this.peerConnection.updateIce) {
	      return;
	    }
	
	    this.peerConnection.updateIce({'iceServers': servers}, this.RTCConstraints);
	    */
	  }},
	
	// Functions the session can use, but only because it's convenient for the application
	  isMuted: {writable: true, value: function isMuted () {
	    return {
	      audio: this.audioMuted,
	      video: this.videoMuted
	    };
	  }},
	
	  mute: {writable: true, value: function mute (options) {
	    if (this.getLocalStreams().length === 0) {
	      return;
	    }
	
	    options = options || {
	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
	      video: this.getLocalStreams()[0].getVideoTracks().length > 0
	    };
	
	    var audioMuted = false,
	        videoMuted = false;
	
	    if (options.audio && !this.audioMuted) {
	      audioMuted = true;
	      this.audioMuted = true;
	      this.toggleMuteAudio(true);
	    }
	
	    if (options.video && !this.videoMuted) {
	      videoMuted = true;
	      this.videoMuted = true;
	      this.toggleMuteVideo(true);
	    }
	
	    //REVISIT
	    if (audioMuted || videoMuted) {
	      return {
	        audio: audioMuted,
	        video: videoMuted
	      };
	      /*this.session.onmute({
	        audio: audioMuted,
	        video: videoMuted
	      });*/
	    }
	  }},
	
	  unmute: {writable: true, value: function unmute (options) {
	    if (this.getLocalStreams().length === 0) {
	      return;
	    }
	
	    options = options || {
	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
	      video: this.getLocalStreams()[0].getVideoTracks().length > 0
	    };
	
	    var audioUnMuted = false,
	        videoUnMuted = false;
	
	    if (options.audio && this.audioMuted) {
	      audioUnMuted = true;
	      this.audioMuted = false;
	      this.toggleMuteAudio(false);
	    }
	
	    if (options.video && this.videoMuted) {
	      videoUnMuted = true;
	      this.videoMuted = false;
	      this.toggleMuteVideo(false);
	    }
	
	    //REVISIT
	    if (audioUnMuted || videoUnMuted) {
	      return {
	        audio: audioUnMuted,
	        video: videoUnMuted
	      };
	      /*this.session.onunmute({
	        audio: audioUnMuted,
	        video: videoUnMuted
	      });*/
	    }
	  }},
	
	  hold: {writable: true, value: function hold () {
	    this.toggleMuteAudio(true);
	    this.toggleMuteVideo(true);
	  }},
	
	  unhold: {writable: true, value: function unhold () {
	    if (!this.audioMuted) {
	      this.toggleMuteAudio(false);
	    }
	
	    if (!this.videoMuted) {
	      this.toggleMuteVideo(false);
	    }
	  }},
	
	// Functions the application can use, but not the session
	  getLocalStreams: {writable: true, value: function getLocalStreams () {
	    var pc = this.peerConnection;
	    if (pc && pc.signalingState === 'closed') {
	      this.logger.warn('peerConnection is closed, getLocalStreams returning []');
	      return [];
	    }
	    return (pc.getLocalStreams && pc.getLocalStreams()) ||
	      pc.localStreams || [];
	  }},
	
	  getRemoteStreams: {writable: true, value: function getRemoteStreams () {
	    var pc = this.peerConnection;
	    if (pc && pc.signalingState === 'closed') {
	      this.logger.warn('peerConnection is closed, getRemoteStreams returning this._remoteStreams');
	      return this._remoteStreams;
	    }
	    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||
	      pc.remoteStreams || [];
	  }},
	
	  render: {writable: true, value: function render (renderHint) {
	    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);
	    if (!renderHint) {
	      return false;
	    }
	    var streamGetters = {
	      local: 'getLocalStreams',
	      remote: 'getRemoteStreams'
	    };
	    Object.keys(streamGetters).forEach(function (loc) {
	      var streamGetter = streamGetters[loc];
	      var streams = this[streamGetter]();
	      SIP.WebRTC.MediaStreamManager.render(streams, renderHint[loc]);
	    }.bind(this));
	  }},
	
	// Internal functions
	  hasOffer: {writable: true, value: function hasOffer (where) {
	    var offerState = 'have-' + where + '-offer';
	    return this.peerConnection.signalingState === offerState;
	    // TODO consider signalingStates with 'pranswer'?
	  }},
	
	  prepareIceServers: {writable: true, value: function prepareIceServers (stunServers, turnServers) {
	    var servers = [],
	      config = this.session.ua.configuration;
	
	    stunServers = stunServers || config.stunServers;
	    turnServers = turnServers || config.turnServers;
	
	    [].concat(stunServers).forEach(function (server) {
	      servers.push({'urls': server});
	    });
	
	    [].concat(turnServers).forEach(function (server) {
	      servers.push({
	        'urls': server.urls,
	        'username': server.username,
	        'credential': server.password
	      });
	    });
	
	    return servers;
	  }},
	
	  initPeerConnection: {writable: true, value: function initPeerConnection(servers, RTCConstraints) {
	    var self = this,
	      config = this.session.ua.configuration;
	
	    this.onIceCompleted = SIP.Utils.defer();
	    this.onIceCompleted.promise.then(function(pc) {
	      self.emit('iceGatheringComplete', pc);
	      if (self.iceCheckingTimer) {
	        SIP.Timers.clearTimeout(self.iceCheckingTimer);
	        self.iceCheckingTimer = null;
	      }
	    });
	
	    if (this.peerConnection) {
	      this.peerConnection.close();
	    }
	
	    this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers}, RTCConstraints);
	
	    // Firefox (35.0.1) sometimes throws on calls to peerConnection.getRemoteStreams
	    // even if peerConnection.onaddstream was just called. In order to make
	    // MediaHandler.prototype.getRemoteStreams work, keep track of them manually
	    this._remoteStreams = [];
	
	    this.peerConnection.onaddstream = function(e) {
	      self.logger.log('stream added: '+ e.stream.id);
	      self._remoteStreams.push(e.stream);
	      self.render();
	      self.emit('addStream', e);
	    };
	
	    this.peerConnection.onremovestream = function(e) {
	      self.logger.log('stream removed: '+ e.stream.id);
	    };
	
	    this.startIceCheckingTimer = function () {
	      if (!self.iceCheckingTimer) {
	        self.iceCheckingTimer = SIP.Timers.setTimeout(function() {
	          self.logger.log('RTCIceChecking Timeout Triggered after '+config.iceCheckingTimeout+' milliseconds');
	          self.onIceCompleted.resolve(this);
	        }.bind(this.peerConnection), config.iceCheckingTimeout);
	      }
	    };
	
	    this.peerConnection.onicecandidate = function(e) {
	      self.emit('iceCandidate', e);
	      if (e.candidate) {
	        self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));
	        self.startIceCheckingTimer();
	      } else {
	        self.onIceCompleted.resolve(this);
	      }
	    };
	
	    this.peerConnection.onicegatheringstatechange = function () {
	      self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);
	      if (this.iceGatheringState === 'gathering') {
	        self.emit('iceGathering', this);
	      }
	      if (this.iceGatheringState === 'complete') {
	        self.onIceCompleted.resolve(this);
	      }
	    };
	
	    this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case
	      var stateEvent;
	
	      if (this.iceConnectionState === 'checking') {
	        self.startIceCheckingTimer();
	      }
	
	      switch (this.iceConnectionState) {
	      case 'new':
	        stateEvent = 'iceConnection';
	        break;
	      case 'checking':
	        stateEvent = 'iceConnectionChecking';
	        break;
	      case 'connected':
	        stateEvent = 'iceConnectionConnected';
	        break;
	      case 'completed':
	        stateEvent = 'iceConnectionCompleted';
	        break;
	      case 'failed':
	        stateEvent = 'iceConnectionFailed';
	        break;
	      case 'disconnected':
	        stateEvent = 'iceConnectionDisconnected';
	        break;
	      case 'closed':
	        stateEvent = 'iceConnectionClosed';
	        break;
	      default:
	        self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);
	        return;
	      }
	      self.emit(stateEvent, this);
	
	      //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated
	      //normal calls switch from failed to connected in some cases, so checking for failed and terminated
	      /*if (this.iceConnectionState === 'failed') {
	        self.session.terminate({
	        cause: SIP.C.causes.RTP_TIMEOUT,
	        status_code: 200,
	        reason_phrase: SIP.C.causes.RTP_TIMEOUT
	      });
	      } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {
	      self.onIceCompleted(this);
	      }*/
	    };
	
	    this.peerConnection.onstatechange = function() {
	      self.logger.log('PeerConnection state changed to "'+ this.readyState +'"');
	    };
	  }},
	
	  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (constraints) {
	    var self = this;
	    var methodName;
	    var pc = self.peerConnection;
	
	    self.ready = false;
	    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';
	
	    return SIP.Utils.promisify(pc, methodName, true)(constraints)
	      .then(SIP.Utils.promisify(pc, 'setLocalDescription'))
	      .then(function onSetLocalDescriptionSuccess() {
	        var deferred = SIP.Utils.defer();
	        if (pc.iceGatheringState === 'complete' && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed')) {
	          deferred.resolve();
	        } else {
	          self.onIceCompleted.promise.then(deferred.resolve);
	        }
	        return deferred.promise;
	      })
	      .then(function readySuccess () {
	        var sdp = pc.localDescription.sdp;
	
	        sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);
	        sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);
	
	        var sdpWrapper = {
	          type: methodName === 'createOffer' ? 'offer' : 'answer',
	          sdp: sdp
	        };
	
	        self.emit('getDescription', sdpWrapper);
	
	        self.ready = true;
	        return sdpWrapper.sdp;
	      })
	      .catch(function methodFailed (e) {
	        self.logger.error(e);
	        self.ready = true;
	        throw new SIP.Exceptions.GetDescriptionError(e);
	      })
	    ;
	  }},
	
	  addStreams: {writable: true, value: function addStreams (streams) {
	    try {
	      streams = [].concat(streams);
	      streams.forEach(function (stream) {
	        this.peerConnection.addStream(stream);
	      }, this);
	    } catch(e) {
	      this.logger.error('error adding stream');
	      this.logger.error(e);
	      return SIP.Utils.Promise.reject(e);
	    }
	
	    return SIP.Utils.Promise.resolve();
	  }},
	
	  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {
	    this.getLocalStreams().forEach(function (stream) {
	      stream[trackGetter]().forEach(function (track) {
	        track.enabled = !mute;
	      });
	    });
	  }},
	
	  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {
	    this.toggleMuteHelper('getAudioTracks', mute);
	  }},
	
	  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {
	    this.toggleMuteHelper('getVideoTracks', mute);
	  }}
	});
	
	// Return since it will be assigned to a variable.
	return MediaHandler;
	};


/***/ },
/* 238 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaStreamManager
	 */
	
	/* MediaStreamManager
	 * @class Manages the acquisition and release of MediaStreams.
	 * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()
	 */
	module.exports = function (SIP, environment) {
	
	// Default MediaStreamManager provides single-use streams created with getUserMedia
	var MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {
	  if (!SIP.WebRTC.isSupported()) {
	    throw new SIP.Exceptions.NotSupportedError('Media not supported');
	  }
	
	  this.mediaHint = defaultMediaHint || {
	    constraints: {audio: true, video: true}
	  };
	
	  // map of streams to acquisition manner:
	  // true -> passed in as mediaHint.stream
	  // false -> getUserMedia
	  this.acquisitions = {};
	};
	MediaStreamManager.streamId = function (stream) {
	  return stream.getAudioTracks().concat(stream.getVideoTracks())
	    .map(function trackId (track) {
	      return track.id;
	    })
	    .join('');
	};
	
	/**
	 * @param {(Array of) MediaStream} streams - The streams to render
	 *
	 * @param {(Array of) HTMLMediaElement} elements
	 *        - The <audio>/<video> element(s) that should render the streams
	 *
	 * Each stream in streams renders to the corresponding element in elements,
	 * wrapping around elements if needed.
	 */
	MediaStreamManager.render = function render (streams, elements) {
	  if (!elements) {
	    return false;
	  }
	  if (Array.isArray(elements) && !elements.length) {
	    throw new TypeError('elements must not be empty');
	  }
	
	  function attachMediaStream(element, stream) {
	    if (typeof element.src !== 'undefined') {
	      environment.revokeObjectURL(element.src);
	      element.src = environment.createObjectURL(stream);
	    } else if (typeof (element.srcObject || element.mozSrcObject) !== 'undefined') {
	      element.srcObject = element.mozSrcObject = stream;
	    } else {
	      return false;
	    }
	
	    return true;
	  }
	
	  function ensureMediaPlaying (mediaElement) {
	    var interval = 100;
	    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {
	      if (mediaElement.paused) {
	        mediaElement.play();
	      }
	      else {
	        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);
	      }
	    }, interval);
	  }
	
	  function attachAndPlay (elements, stream, index) {
	    if (typeof elements === 'function') {
	      elements = elements();
	    }
	    var element = elements[index % elements.length];
	    (environment.attachMediaStream || attachMediaStream)(element, stream);
	    ensureMediaPlaying(element);
	  }
	
	  // [].concat "casts" `elements` into an array
	  // so forEach works even if `elements` was a single element
	  elements = [].concat(elements);
	  [].concat(streams).forEach(attachAndPlay.bind(null, elements));
	};
	
	MediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {
	  'acquire': {writable: true, value: function acquire (mediaHint) {
	    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;
	
	    var saveSuccess = function (isHintStream, streams) {
	      streams = [].concat(streams);
	      streams.forEach(function (stream) {
	        var streamId = MediaStreamManager.streamId(stream);
	        this.acquisitions[streamId] = !!isHintStream;
	      }, this);
	      return SIP.Utils.Promise.resolve(streams);
	    }.bind(this);
	
	    if (mediaHint.stream) {
	      return saveSuccess(true, mediaHint.stream);
	    } else {
	      // Fallback to audio/video enabled if no mediaHint can be found.
	      var constraints = mediaHint.constraints ||
	        (this.mediaHint && this.mediaHint.constraints) ||
	        {audio: true, video: true};
	
	      var deferred = SIP.Utils.defer();
	
	      /*
	       * Make the call asynchronous, so that ICCs have a chance
	       * to define callbacks to `userMediaRequest`
	       */
	      SIP.Timers.setTimeout(function () {
	        this.emit('userMediaRequest', constraints);
	
	        var emitThenCall = function (eventName, callback) {
	          var callbackArgs = Array.prototype.slice.call(arguments, 2);
	          // Emit with all of the arguments from the real callback.
	          var newArgs = [eventName].concat(callbackArgs);
	
	          this.emit.apply(this, newArgs);
	
	          return callback.apply(null, callbackArgs);
	        }.bind(this);
	
	        if (constraints.audio || constraints.video) {
	          deferred.resolve(
	            SIP.WebRTC.getUserMedia(constraints)
	            .then(
	              emitThenCall.bind(this, 'userMedia', saveSuccess.bind(null, false)),
	              emitThenCall.bind(this, 'userMediaFailed', function(e){throw e;})
	            )
	          );
	        } else {
	          // Local streams were explicitly excluded.
	          deferred.resolve([]);
	        }
	      }.bind(this), 0);
	
	      return deferred.promise;
	    }
	  }},
	
	  'release': {writable: true, value: function release (streams) {
	    streams = [].concat(streams);
	    streams.forEach(function (stream) {
	      var streamId = MediaStreamManager.streamId(stream);
	      if (this.acquisitions[streamId] === false) {
	        stream.getTracks().forEach(function (track) {
	          track.stop();
	        });
	      }
	      delete this.acquisitions[streamId];
	    }, this);
	  }},
	});
	
	// Return since it will be assigned to a variable.
	return MediaStreamManager;
	};


/***/ },
/* 239 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * @augments SIP
	 * @class Class creating a SIP User Agent.
	 * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]
	 *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.
	 *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.
	 *
	 * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	 */
	module.exports = function (SIP, environment) {
	var UA,
	  C = {
	    // UA status codes
	    STATUS_INIT:                0,
	    STATUS_STARTING:            1,
	    STATUS_READY:               2,
	    STATUS_USER_CLOSED:         3,
	    STATUS_NOT_READY:           4,
	
	    // UA error codes
	    CONFIGURATION_ERROR:  1,
	    NETWORK_ERROR:        2,
	
	    ALLOWED_METHODS: [
	      'ACK',
	      'CANCEL',
	      'INVITE',
	      'MESSAGE',
	      'BYE',
	      'OPTIONS',
	      'INFO',
	      'NOTIFY',
	      'REFER'
	    ],
	
	    ACCEPTED_BODY_TYPES: [
	      'application/sdp',
	      'application/dtmf-relay'
	    ],
	
	    MAX_FORWARDS: 70,
	    TAG_LENGTH: 10
	  };
	
	UA = function(configuration) {
	  var self = this;
	
	  // Helper function for forwarding events
	  function selfEmit(type) {
	    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments
	    return self.emit.bind(self, type);
	  }
	
	  // Set Accepted Body Types
	  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();
	
	  this.log = new SIP.LoggerFactory();
	  this.logger = this.getLogger('sip.ua');
	
	  this.cache = {
	    credentials: {}
	  };
	
	  this.configuration = {};
	  this.dialogs = {};
	
	  //User actions outside any session/dialog (MESSAGE)
	  this.applicants = {};
	
	  this.data = {};
	  this.sessions = {};
	  this.subscriptions = {};
	  this.transport = null;
	  this.contact = null;
	  this.status = C.STATUS_INIT;
	  this.error = null;
	  this.transactions = {
	    nist: {},
	    nict: {},
	    ist: {},
	    ict: {}
	  };
	
	  this.transportRecoverAttempts = 0;
	  this.transportRecoveryTimer = null;
	
	  Object.defineProperties(this, {
	    transactionsCount: {
	      get: function() {
	        var type,
	          transactions = ['nist','nict','ist','ict'],
	          count = 0;
	
	        for (type in transactions) {
	          count += Object.keys(this.transactions[transactions[type]]).length;
	        }
	
	        return count;
	      }
	    },
	
	    nictTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['nict']).length;
	      }
	    },
	
	    nistTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['nist']).length;
	      }
	    },
	
	    ictTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['ict']).length;
	      }
	    },
	
	    istTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['ist']).length;
	      }
	    }
	  });
	
	  /**
	   * Load configuration
	   *
	   * @throws {SIP.Exceptions.ConfigurationError}
	   * @throws {TypeError}
	   */
	
	  if(configuration === undefined) {
	    configuration = {};
	  } else if (typeof configuration === 'string' || configuration instanceof String) {
	    configuration = {
	      uri: configuration
	    };
	  }
	
	  // Apply log configuration if present
	  if (configuration.log) {
	    if (configuration.log.hasOwnProperty('builtinEnabled')) {
	      this.log.builtinEnabled = configuration.log.builtinEnabled;
	    }
	
	    if (configuration.log.hasOwnProperty('level')) {
	      this.log.level = configuration.log.level;
	    }
	
	    if (configuration.log.hasOwnProperty('connector')) {
	      this.log.connector = configuration.log.connector;
	    }
	  }
	
	  try {
	    this.loadConfig(configuration);
	  } catch(e) {
	    this.status = C.STATUS_NOT_READY;
	    this.error = C.CONFIGURATION_ERROR;
	    throw e;
	  }
	
	  // Initialize registerContext
	  this.registerContext = new SIP.RegisterContext(this);
	  this.registerContext.on('failed', selfEmit('registrationFailed'));
	  this.registerContext.on('registered', selfEmit('registered'));
	  this.registerContext.on('unregistered', selfEmit('unregistered'));
	
	  if(this.configuration.autostart) {
	    this.start();
	  }
	
	  if (typeof environment.addEventListener === 'function') {
	    // Google Chrome Packaged Apps don't allow 'unload' listeners:
	    // unload is not available in packaged apps
	    if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {
	      environment.addEventListener('unload', this.stop.bind(this));
	    }
	  }
	};
	UA.prototype = Object.create(SIP.EventEmitter.prototype);
	
	//=================
	//  High Level API
	//=================
	
	UA.prototype.register = function(options) {
	  this.configuration.register = true;
	  this.registerContext.register(options);
	
	  return this;
	};
	
	/**
	 * Unregister.
	 *
	 * @param {Boolean} [all] unregister all user bindings.
	 *
	 */
	UA.prototype.unregister = function(options) {
	  this.configuration.register = false;
	
	  var context = this.registerContext;
	  this.afterConnected(context.unregister.bind(context, options));
	
	  return this;
	};
	
	UA.prototype.isRegistered = function() {
	  return this.registerContext.registered;
	};
	
	/**
	 * Connection state.
	 * @param {Boolean}
	 */
	UA.prototype.isConnected = function() {
	  return this.transport ? this.transport.connected : false;
	};
	
	UA.prototype.afterConnected = function afterConnected (callback) {
	  if (this.isConnected()) {
	    callback();
	  } else {
	    this.once('connected', callback);
	  }
	};
	
	/**
	 * Make an outgoing call.
	 *
	 * @param {String} target
	 * @param {Object} views
	 * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	 *
	 * @throws {TypeError}
	 *
	 */
	UA.prototype.invite = function(target, options) {
	  var context = new SIP.InviteClientContext(this, target, options);
	
	  this.afterConnected(context.invite.bind(context));
	  return context;
	};
	
	UA.prototype.subscribe = function(target, event, options) {
	  var sub = new SIP.Subscription(this, target, event, options);
	
	  this.afterConnected(sub.subscribe.bind(sub));
	  return sub;
	};
	
	/**
	 * Send a message.
	 *
	 * @param {String} target
	 * @param {String} body
	 * @param {Object} [options]
	 *
	 * @throws {TypeError}
	 *
	 */
	UA.prototype.message = function(target, body, options) {
	  if (body === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  // There is no Message module, so it is okay that the UA handles defaults here.
	  options = Object.create(options || Object.prototype);
	  options.contentType || (options.contentType = 'text/plain');
	  options.body = body;
	
	  return this.request(SIP.C.MESSAGE, target, options);
	};
	
	UA.prototype.request = function (method, target, options) {
	  var req = new SIP.ClientContext(this, method, target, options);
	
	  this.afterConnected(req.send.bind(req));
	  return req;
	};
	
	/**
	 * Gracefully close.
	 *
	 */
	UA.prototype.stop = function() {
	  var session, subscription, applicant,
	    ua = this;
	
	  function transactionsListener() {
	    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {
	        ua.removeListener('transactionDestroyed', transactionsListener);
	        ua.transport.disconnect();
	    }
	  }
	
	  this.logger.log('user requested closure...');
	
	  if(this.status === C.STATUS_USER_CLOSED) {
	    this.logger.warn('UA already closed');
	    return this;
	  }
	
	  // Clear transportRecoveryTimer
	  SIP.Timers.clearTimeout(this.transportRecoveryTimer);
	
	  // Close registerContext
	  this.logger.log('closing registerContext');
	  this.registerContext.close();
	
	  // Run  _terminate_ on every Session
	  for(session in this.sessions) {
	    this.logger.log('closing session ' + session);
	    this.sessions[session].terminate();
	  }
	
	  //Run _close_ on every Subscription
	  for(subscription in this.subscriptions) {
	    this.logger.log('unsubscribing from subscription ' + subscription);
	    this.subscriptions[subscription].close();
	  }
	
	  // Run  _close_ on every applicant
	  for(applicant in this.applicants) {
	    this.applicants[applicant].close();
	  }
	
	  this.status = C.STATUS_USER_CLOSED;
	
	  /*
	   * If the remaining transactions are all INVITE transactions, there is no need to
	   * wait anymore because every session has already been closed by this method.
	   * - locally originated sessions where terminated (CANCEL or BYE)
	   * - remotely originated sessions where rejected (4XX) or terminated (BYE)
	   * Remaining INVITE transactions belong tho sessions that where answered. This are in
	   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]
	   */
	  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {
	    this.transport.disconnect();
	  } else {
	    this.on('transactionDestroyed', transactionsListener);
	  }
	
	  return this;
	};
	
	/**
	 * Connect to the WS server if status = STATUS_INIT.
	 * Resume UA after being closed.
	 *
	 */
	UA.prototype.start = function() {
	  var server;
	
	  this.logger.log('user requested startup...');
	  if (this.status === C.STATUS_INIT) {
	    server = this.getNextWsServer();
	    this.status = C.STATUS_STARTING;
	    new SIP.Transport(this, server);
	  } else if(this.status === C.STATUS_USER_CLOSED) {
	    this.logger.log('resuming');
	    this.status = C.STATUS_READY;
	    this.transport.connect();
	  } else if (this.status === C.STATUS_STARTING) {
	    this.logger.log('UA is in STARTING status, not opening new connection');
	  } else if (this.status === C.STATUS_READY) {
	    this.logger.log('UA is in READY status, not resuming');
	  } else {
	    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');
	  }
	
	  return this;
	};
	
	/**
	 * Normalize a string into a valid SIP request URI
	 *
	 * @param {String} target
	 *
	 * @returns {SIP.URI|undefined}
	 */
	UA.prototype.normalizeTarget = function(target) {
	  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);
	};
	
	
	//===============================
	//  Private (For internal use)
	//===============================
	
	UA.prototype.saveCredentials = function(credentials) {
	  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};
	  this.cache.credentials[credentials.realm][credentials.uri] = credentials;
	
	  return this;
	};
	
	UA.prototype.getCredentials = function(request) {
	  var realm, credentials;
	
	  realm = request.ruri.host;
	
	  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {
	    credentials = this.cache.credentials[realm][request.ruri];
	    credentials.method = request.method;
	  }
	
	  return credentials;
	};
	
	UA.prototype.getLogger = function(category, label) {
	  return this.log.getLogger(category, label);
	};
	
	
	//==============================
	// Event Handlers
	//==============================
	
	/**
	 * Transport Close event
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportClosed = function(transport) {
	  // Run _onTransportError_ callback on every client transaction using _transport_
	  var type, idx, length,
	    client_transactions = ['nict', 'ict', 'nist', 'ist'];
	
	  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;
	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);
	
	  length = client_transactions.length;
	  for (type = 0; type < length; type++) {
	    for(idx in this.transactions[client_transactions[type]]) {
	      this.transactions[client_transactions[type]][idx].onTransportError();
	    }
	  }
	
	  // Close sessions if GRUU is not being used
	  if (!this.contact.pub_gruu) {
	    this.closeSessionsOnTransportError();
	  }
	
	};
	
	/**
	 * Unrecoverable transport event.
	 * Connection reattempt logic has been done and didn't success.
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportError = function(transport) {
	  var server;
	
	  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);
	
	  // Close sessions.
	  //Mark this transport as 'down'
	  transport.server.status = SIP.Transport.C.STATUS_ERROR;
	
	  this.emit('disconnected', {
	    transport: transport
	  });
	
	  // try the next transport if the UA isn't closed
	  if(this.status === C.STATUS_USER_CLOSED) {
	    return;
	  }
	
	  server = this.getNextWsServer();
	
	  if(server) {
	    new SIP.Transport(this, server);
	  }else {
	    this.closeSessionsOnTransportError();
	    if (!this.error || this.error !== C.NETWORK_ERROR) {
	      this.status = C.STATUS_NOT_READY;
	      this.error = C.NETWORK_ERROR;
	    }
	    // Transport Recovery process
	    this.recoverTransport();
	  }
	};
	
	/**
	 * Transport connection event.
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportConnected = function(transport) {
	  this.transport = transport;
	
	  // Reset transport recovery counter
	  this.transportRecoverAttempts = 0;
	
	  transport.server.status = SIP.Transport.C.STATUS_READY;
	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);
	
	  if(this.status === C.STATUS_USER_CLOSED) {
	    return;
	  }
	
	  this.status = C.STATUS_READY;
	  this.error = null;
	
	  if(this.configuration.register) {
	    this.configuration.authenticationFactory.initialize().then(function () {
	      this.registerContext.onTransportConnected();
	    }.bind(this));
	  }
	
	  this.emit('connected', {
	    transport: transport
	  });
	};
	
	
	/**
	 * Transport connecting event
	 * @private
	 * @param {SIP.Transport} transport.
	 * #param {Integer} attempts.
	 */
	  UA.prototype.onTransportConnecting = function(transport, attempts) {
	    this.emit('connecting', {
	      transport: transport,
	      attempts: attempts
	    });
	  };
	
	
	/**
	 * new Transaction
	 * @private
	 * @param {SIP.Transaction} transaction.
	 */
	UA.prototype.newTransaction = function(transaction) {
	  this.transactions[transaction.type][transaction.id] = transaction;
	  this.emit('newTransaction', {transaction: transaction});
	};
	
	
	/**
	 * destroy Transaction
	 * @private
	 * @param {SIP.Transaction} transaction.
	 */
	UA.prototype.destroyTransaction = function(transaction) {
	  delete this.transactions[transaction.type][transaction.id];
	  this.emit('transactionDestroyed', {
	    transaction: transaction
	  });
	};
	
	
	//=========================
	// receiveRequest
	//=========================
	
	/**
	 * Request reception
	 * @private
	 * @param {SIP.IncomingRequest} request.
	 */
	UA.prototype.receiveRequest = function(request) {
	  var dialog, session, message,
	    method = request.method,
	    transaction,
	    replaces,
	    replacedDialog,
	    self = this;
	
	  function ruriMatches (uri) {
	    return uri && uri.user === request.ruri.user;
	  }
	
	  // Check that request URI points to us
	  if(!(ruriMatches(this.configuration.uri) ||
	       ruriMatches(this.contact.uri) ||
	       ruriMatches(this.contact.pub_gruu) ||
	       ruriMatches(this.contact.temp_gruu))) {
	    this.logger.warn('Request-URI does not point to us');
	    if (request.method !== SIP.C.ACK) {
	      request.reply_sl(404);
	    }
	    return;
	  }
	
	  // Check request URI scheme
	  if(request.ruri.scheme === SIP.C.SIPS) {
	    request.reply_sl(416);
	    return;
	  }
	
	  // Check transaction
	  if(SIP.Transactions.checkTransaction(this, request)) {
	    return;
	  }
	
	  /* RFC3261 12.2.2
	   * Requests that do not change in any way the state of a dialog may be
	   * received within a dialog (for example, an OPTIONS request).
	   * They are processed as if they had been received outside the dialog.
	   */
	  if(method === SIP.C.OPTIONS) {
	    new SIP.Transactions.NonInviteServerTransaction(request, this);
	    request.reply(200, null, [
	      'Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString(),
	      'Accept: '+ C.ACCEPTED_BODY_TYPES
	    ]);
	  } else if (method === SIP.C.MESSAGE) {
	    message = new SIP.ServerContext(this, request);
	    message.body = request.body;
	    message.content_type = request.getHeader('Content-Type') || 'text/plain';
	
	    request.reply(200, null);
	    this.emit('message', message);
	  } else if (method !== SIP.C.INVITE &&
	             method !== SIP.C.ACK) {
	    // Let those methods pass through to normal processing for now.
	    transaction = new SIP.ServerContext(this, request);
	  }
	
	  // Initial Request
	  if(!request.to_tag) {
	    switch(method) {
	      case SIP.C.INVITE:
	        replaces =
	          this.configuration.replaces !== SIP.C.supported.UNSUPPORTED &&
	          request.parseHeader('replaces');
	
	        if (replaces) {
	          replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];
	
	          if (!replacedDialog) {
	            //Replaced header without a matching dialog, reject
	            request.reply_sl(481, null);
	            return;
	          } else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {
	            request.reply_sl(603, null);
	            return;
	          } else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {
	            request.reply_sl(486, null);
	            return;
	          }
	        }
	
	        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;
	        if(!isMediaSupported || isMediaSupported()) {
	          session = new SIP.InviteServerContext(this, request);
	          session.replacee = replacedDialog && replacedDialog.owner;
	          session.on('invite', function() {
	            self.emit('invite', this);
	          });
	        } else {
	          this.logger.warn('INVITE received but WebRTC is not supported');
	          request.reply(488);
	        }
	        break;
	      case SIP.C.BYE:
	        // Out of dialog BYE received
	        request.reply(481);
	        break;
	      case SIP.C.CANCEL:
	        session = this.findSession(request);
	        if(session) {
	          session.receiveRequest(request);
	        } else {
	          this.logger.warn('received CANCEL request for a non existent session');
	        }
	        break;
	      case SIP.C.ACK:
	        /* Absorb it.
	         * ACK request without a corresponding Invite Transaction
	         * and without To tag.
	         */
	        break;
	      default:
	        request.reply(405);
	        break;
	    }
	  }
	  // In-dialog request
	  else {
	    dialog = this.findDialog(request);
	
	    if(dialog) {
	      if (method === SIP.C.INVITE) {
	        new SIP.Transactions.InviteServerTransaction(request, this);
	      }
	      dialog.receiveRequest(request);
	    } else if (method === SIP.C.NOTIFY) {
	      session = this.findSession(request);
	      if(session) {
	        session.receiveRequest(request);
	      } else {
	        this.logger.warn('received NOTIFY request for a non existent session');
	        request.reply(481, 'Subscription does not exist');
	      }
	    }
	    /* RFC3261 12.2.2
	     * Request with to tag, but no matching dialog found.
	     * Exception: ACK for an Invite request for which a dialog has not
	     * been created.
	     */
	    else {
	      if(method !== SIP.C.ACK) {
	        request.reply(481);
	      }
	    }
	  }
	};
	
	//=================
	// Utils
	//=================
	
	/**
	 * Get the session to which the request belongs to, if any.
	 * @private
	 * @param {SIP.IncomingRequest} request.
	 * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}
	 */
	UA.prototype.findSession = function(request) {
	  return this.sessions[request.call_id + request.from_tag] ||
	          this.sessions[request.call_id + request.to_tag] ||
	          null;
	};
	
	/**
	 * Get the dialog to which the request belongs to, if any.
	 * @private
	 * @param {SIP.IncomingRequest}
	 * @returns {SIP.Dialog|null}
	 */
	UA.prototype.findDialog = function(request) {
	  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||
	          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||
	          null;
	};
	
	/**
	 * Retrieve the next server to which connect.
	 * @private
	 * @returns {Object} ws_server
	 */
	UA.prototype.getNextWsServer = function() {
	  // Order servers by weight
	  var idx, length, ws_server,
	    candidates = [];
	
	  length = this.configuration.wsServers.length;
	  for (idx = 0; idx < length; idx++) {
	    ws_server = this.configuration.wsServers[idx];
	
	    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {
	      continue;
	    } else if (candidates.length === 0) {
	      candidates.push(ws_server);
	    } else if (ws_server.weight > candidates[0].weight) {
	      candidates = [ws_server];
	    } else if (ws_server.weight === candidates[0].weight) {
	      candidates.push(ws_server);
	    }
	  }
	
	  idx = Math.floor(Math.random() * candidates.length);
	
	  return candidates[idx];
	};
	
	/**
	 * Close all sessions on transport error.
	 * @private
	 */
	UA.prototype.closeSessionsOnTransportError = function() {
	  var idx;
	
	  // Run _transportError_ for every Session
	  for(idx in this.sessions) {
	    this.sessions[idx].onTransportError();
	  }
	  // Call registerContext _onTransportClosed_
	  this.registerContext.onTransportClosed();
	};
	
	UA.prototype.recoverTransport = function(ua) {
	  var idx, length, k, nextRetry, count, server;
	
	  ua = ua || this;
	  count = ua.transportRecoverAttempts;
	
	  length = ua.configuration.wsServers.length;
	  for (idx = 0; idx < length; idx++) {
	    ua.configuration.wsServers[idx].status = 0;
	  }
	
	  server = ua.getNextWsServer();
	
	  k = Math.floor((Math.random() * Math.pow(2,count)) +1);
	  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;
	
	  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {
	    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');
	    nextRetry = ua.configuration.connectionRecoveryMinInterval;
	    count = 0;
	  }
	
	  this.logger.log('next connection attempt in '+ nextRetry +' seconds');
	
	  this.transportRecoveryTimer = SIP.Timers.setTimeout(
	    function(){
	      ua.transportRecoverAttempts = count + 1;
	      new SIP.Transport(ua, server);
	    }, nextRetry * 1000);
	};
	
	function checkAuthenticationFactory (authenticationFactory) {
	  if (!(authenticationFactory instanceof Function)) {
	    return;
	  }
	  if (!authenticationFactory.initialize) {
	    authenticationFactory.initialize = function initialize () {
	      return SIP.Utils.Promise.resolve();
	    };
	  }
	  return authenticationFactory;
	}
	
	/**
	 * Configuration load.
	 * @private
	 * returns {Boolean}
	 */
	UA.prototype.loadConfig = function(configuration) {
	  // Settings and default values
	  var parameter, value, checked_value, hostportParams, registrarServer,
	    settings = {
	      /* Host address
	      * Value to be set in Via sent_by and host part of Contact FQDN
	      */
	      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',
	
	      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),
	      wsServers: [{
	        scheme: 'WSS',
	        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',
	        status: 0,
	        weight: 0,
	        ws_uri: 'wss://edge.sip.onsip.com'
	      }],
	
	      // Password
	      password: null,
	
	      // Registration parameters
	      registerExpires: 600,
	      register: true,
	      registrarServer: null,
	
	      // Transport related parameters
	      wsServerMaxReconnection: 3,
	      wsServerReconnectionTimeout: 4,
	
	      connectionRecoveryMinInterval: 2,
	      connectionRecoveryMaxInterval: 30,
	
	      keepAliveInterval: 0,
	
	      extraSupported: [],
	
	      usePreloadedRoute: false,
	
	      //string to be inserted into User-Agent request header
	      userAgentString: SIP.C.USER_AGENT,
	
	      // Session parameters
	      iceCheckingTimeout: 5000,
	      noAnswerTimeout: 60,
	      stunServers: ['stun:stun.l.google.com:19302'],
	      turnServers: [],
	
	      // Logging parameters
	      traceSip: false,
	
	      // Hacks
	      hackViaTcp: false,
	      hackIpInContact: false,
	      hackWssInTransport: false,
	      hackAllowUnregisteredOptionTags: false,
	
	      contactTransport: 'ws',
	      forceRport: false,
	
	      //autostarting
	      autostart: true,
	
	      //Reliable Provisional Responses
	      rel100: SIP.C.supported.UNSUPPORTED,
	
	      // Replaces header (RFC 3891)
	      // http://tools.ietf.org/html/rfc3891
	      replaces: SIP.C.supported.UNSUPPORTED,
	
	      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory,
	
	      authenticationFactory: checkAuthenticationFactory(function authenticationFactory (ua) {
	        return new SIP.DigestAuthentication(ua);
	      })
	    };
	
	  // Pre-Configuration
	  function aliasUnderscored (parameter, logger) {
	    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {
	      return m[0] + '_' + m[1].toLowerCase();
	    });
	
	    if (parameter === underscored) {
	      return;
	    }
	
	    var hasParameter = configuration.hasOwnProperty(parameter);
	    if (configuration.hasOwnProperty(underscored)) {
	      logger.warn(underscored + ' is deprecated, please use ' + parameter);
	      if (hasParameter) {
	        logger.warn(parameter + ' overriding ' + underscored);
	      }
	    }
	
	    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];
	  }
	
	  // Check Mandatory parameters
	  for(parameter in UA.configuration_check.mandatory) {
	    aliasUnderscored(parameter, this.logger);
	    if(!configuration.hasOwnProperty(parameter)) {
	      throw new SIP.Exceptions.ConfigurationError(parameter);
	    } else {
	      value = configuration[parameter];
	      checked_value = UA.configuration_check.mandatory[parameter](value);
	      if (checked_value !== undefined) {
	        settings[parameter] = checked_value;
	      } else {
	        throw new SIP.Exceptions.ConfigurationError(parameter, value);
	      }
	    }
	  }
	
	  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);
	
	  var emptyArraysAllowed = ['stunServers', 'turnServers'];
	
	  // Check Optional parameters
	  for(parameter in UA.configuration_check.optional) {
	    aliasUnderscored(parameter, this.logger);
	    if(configuration.hasOwnProperty(parameter)) {
	      value = configuration[parameter];
	
	      // If the parameter value is an empty array, but shouldn't be, apply its default value.
	      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }
	
	      // If the parameter value is null, empty string, or undefined then apply its default value.
	      if(value === null || value === "" || value === undefined) { continue; }
	      // If it's a number with NaN value then also apply its default value.
	      // NOTE: JS does not allow "value === NaN", the following does the work:
	      else if(typeof(value) === 'number' && isNaN(value)) { continue; }
	
	      checked_value = UA.configuration_check.optional[parameter](value);
	      if (checked_value !== undefined) {
	        settings[parameter] = checked_value;
	      } else {
	        throw new SIP.Exceptions.ConfigurationError(parameter, value);
	      }
	    }
	  }
	
	  // Sanity Checks
	
	  // Connection recovery intervals
	  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {
	    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);
	  }
	
	  // Post Configuration Process
	
	  // Allow passing 0 number as displayName.
	  if (settings.displayName === 0) {
	    settings.displayName = '0';
	  }
	
	  // Instance-id for GRUU
	  if (!settings.instanceId) {
	    settings.instanceId = SIP.Utils.newUUID();
	  }
	
	  // sipjsId instance parameter. Static random tag of length 5
	  settings.sipjsId = SIP.Utils.createRandomToken(5);
	
	  // String containing settings.uri without scheme and user.
	  hostportParams = settings.uri.clone();
	  hostportParams.user = null;
	  settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');
	
	  /* Check whether authorizationUser is explicitly defined.
	   * Take 'settings.uri.user' value if not.
	   */
	  if (!settings.authorizationUser) {
	    settings.authorizationUser = settings.uri.user;
	  }
	
	  /* If no 'registrarServer' is set use the 'uri' value without user portion. */
	  if (!settings.registrarServer) {
	    registrarServer = settings.uri.clone();
	    registrarServer.user = null;
	    settings.registrarServer = registrarServer;
	  }
	
	  // User noAnswerTimeout
	  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;
	
	  // Via Host
	  if (settings.hackIpInContact) {
	    if (typeof settings.hackIpInContact === 'boolean') {
	      settings.viaHost = SIP.Utils.getRandomTestNetIP();
	    }
	    else if (typeof settings.hackIpInContact === 'string') {
	      settings.viaHost = settings.hackIpInContact;
	    }
	  }
	
	  // Contact transport parameter
	  if (settings.hackWssInTransport) {
	    settings.contactTransport = 'wss';
	  }
	
	  this.contact = {
	    pub_gruu: null,
	    temp_gruu: null,
	    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: settings.contactTransport}),
	    toString: function(options){
	      options = options || {};
	
	      var
	        anonymous = options.anonymous || null,
	        outbound = options.outbound || null,
	        contact = '<';
	
	      if (anonymous) {
	        contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport='+settings.contactTransport)).toString();
	      } else {
	        contact += (this.pub_gruu || this.uri).toString();
	      }
	
	      if (outbound) {
	        contact += ';ob';
	      }
	
	      contact += '>';
	
	      return contact;
	    }
	  };
	
	  // media overrides mediaConstraints
	  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);
	
	  // Fill the value of the configuration_skeleton
	  for(parameter in settings) {
	    UA.configuration_skeleton[parameter].value = settings[parameter];
	  }
	
	  Object.defineProperties(this.configuration, UA.configuration_skeleton);
	
	  // Clean UA.configuration_skeleton
	  for(parameter in settings) {
	    UA.configuration_skeleton[parameter].value = '';
	  }
	
	  this.logger.log('configuration parameters after validation:');
	  for(parameter in settings) {
	    switch(parameter) {
	      case 'uri':
	      case 'registrarServer':
	      case 'mediaHandlerFactory':
	        this.logger.log('· ' + parameter + ': ' + settings[parameter]);
	        break;
	      case 'password':
	        this.logger.log('· ' + parameter + ': ' + 'NOT SHOWN');
	        break;
	      default:
	        this.logger.log('· ' + parameter + ': ' + JSON.stringify(settings[parameter]));
	    }
	  }
	
	  return;
	};
	
	/**
	 * Configuration Object skeleton.
	 * @private
	 */
	UA.configuration_skeleton = (function() {
	  var idx,  parameter,
	    skeleton = {},
	    parameters = [
	      // Internal parameters
	      "sipjsId",
	      "hostportParams",
	
	      // Optional user configurable parameters
	      "uri",
	      "wsServers",
	      "authorizationUser",
	      "connectionRecoveryMaxInterval",
	      "connectionRecoveryMinInterval",
	      "keepAliveInterval",
	      "extraSupported",
	      "displayName",
	      "hackViaTcp", // false.
	      "hackIpInContact", //false
	      "hackWssInTransport", //false
	      "hackAllowUnregisteredOptionTags", //false
	      "contactTransport", // 'ws'
	      "forceRport", // false
	      "iceCheckingTimeout",
	      "instanceId",
	      "noAnswerTimeout", // 30 seconds.
	      "password",
	      "registerExpires", // 600 seconds.
	      "registrarServer",
	      "reliable",
	      "rel100",
	      "replaces",
	      "userAgentString", //SIP.C.USER_AGENT
	      "autostart",
	      "stunServers",
	      "traceSip",
	      "turnServers",
	      "usePreloadedRoute",
	      "wsServerMaxReconnection",
	      "wsServerReconnectionTimeout",
	      "mediaHandlerFactory",
	      "media",
	      "mediaConstraints",
	      "authenticationFactory",
	
	      // Post-configuration generated parameters
	      "via_core_value",
	      "viaHost"
	    ];
	
	  for(idx in parameters) {
	    parameter = parameters[idx];
	    skeleton[parameter] = {
	      value: '',
	      writable: false,
	      configurable: false
	    };
	  }
	
	  skeleton['register'] = {
	    value: '',
	    writable: true,
	    configurable: false
	  };
	
	  return skeleton;
	}());
	
	/**
	 * Configuration checker.
	 * @private
	 * @return {Boolean}
	 */
	UA.configuration_check = {
	  mandatory: {
	  },
	
	  optional: {
	
	    uri: function(uri) {
	      var parsed;
	
	      if (!(/^sip:/i).test(uri)) {
	        uri = SIP.C.SIP + ':' + uri;
	      }
	      parsed = SIP.URI.parse(uri);
	
	      if(!parsed) {
	        return;
	      } else if(!parsed.user) {
	        return;
	      } else {
	        return parsed;
	      }
	    },
	
	    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid
	    wsServers: function(wsServers) {
	      var idx, length, url;
	
	      /* Allow defining wsServers parameter as:
	       *  String: "host"
	       *  Array of Strings: ["host1", "host2"]
	       *  Array of Objects: [{ws_uri:"host1", weight:1}, {ws_uri:"host2", weight:0}]
	       *  Array of Objects and Strings: [{ws_uri:"host1"}, "host2"]
	       */
	      if (typeof wsServers === 'string') {
	        wsServers = [{ws_uri: wsServers}];
	      } else if (wsServers instanceof Array) {
	        length = wsServers.length;
	        for (idx = 0; idx < length; idx++) {
	          if (typeof wsServers[idx] === 'string'){
	            wsServers[idx] = {ws_uri: wsServers[idx]};
	          }
	        }
	      } else {
	        return;
	      }
	
	      if (wsServers.length === 0) {
	        return false;
	      }
	
	      length = wsServers.length;
	      for (idx = 0; idx < length; idx++) {
	        if (!wsServers[idx].ws_uri) {
	          return;
	        }
	        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {
	          return;
	        }
	
	        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');
	
	        if(url === -1) {
	          return;
	        } else if(['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {
	          return;
	        } else {
	          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';
	
	          if (!wsServers[idx].weight) {
	            wsServers[idx].weight = 0;
	          }
	
	          wsServers[idx].status = 0;
	          wsServers[idx].scheme = url.scheme.toUpperCase();
	        }
	      }
	      return wsServers;
	    },
	
	    authorizationUser: function(authorizationUser) {
	      if(SIP.Grammar.parse('"'+ authorizationUser +'"', 'quoted_string') === -1) {
	        return;
	      } else {
	        return authorizationUser;
	      }
	    },
	
	    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {
	      var value;
	      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {
	        value = Number(connectionRecoveryMaxInterval);
	        if(value > 0) {
	          return value;
	        }
	      }
	    },
	
	    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {
	      var value;
	      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {
	        value = Number(connectionRecoveryMinInterval);
	        if(value > 0) {
	          return value;
	        }
	      }
	    },
	
	    displayName: function(displayName) {
	      if(SIP.Grammar.parse('"' + displayName + '"', 'displayName') === -1) {
	        return;
	      } else {
	        return displayName;
	      }
	    },
	
	    hackViaTcp: function(hackViaTcp) {
	      if (typeof hackViaTcp === 'boolean') {
	        return hackViaTcp;
	      }
	    },
	
	    hackIpInContact: function(hackIpInContact) {
	      if (typeof hackIpInContact === 'boolean') {
	        return hackIpInContact;
	      }
	      else if (typeof hackIpInContact === 'string' && SIP.Grammar.parse(hackIpInContact, 'host') !== -1) {
	        return hackIpInContact;
	      }
	    },
	
	    iceCheckingTimeout: function(iceCheckingTimeout) {
	      if(SIP.Utils.isDecimal(iceCheckingTimeout)) {
	        return Math.max(500, iceCheckingTimeout);
	      }
	    },
	
	    hackWssInTransport: function(hackWssInTransport) {
	      if (typeof hackWssInTransport === 'boolean') {
	        return hackWssInTransport;
	      }
	    },
	
	    hackAllowUnregisteredOptionTags: function(hackAllowUnregisteredOptionTags) {
	      if (typeof hackAllowUnregisteredOptionTags === 'boolean') {
	        return hackAllowUnregisteredOptionTags;
	      }
	    },
	
	    contactTransport: function(contactTransport) {
	      if (typeof contactTransport === 'string') {
	        return contactTransport;
	      }
	    },
	
	    forceRport: function(forceRport) {
	      if (typeof forceRport === 'boolean') {
	        return forceRport;
	      }
	    },
	
	    instanceId: function(instanceId) {
	      if(typeof instanceId !== 'string') {
	        return;
	      }
	
	      if ((/^uuid:/i.test(instanceId))) {
	        instanceId = instanceId.substr(5);
	      }
	
	      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {
	        return;
	      } else {
	        return instanceId;
	      }
	    },
	
	    keepAliveInterval: function(keepAliveInterval) {
	      var value;
	      if (SIP.Utils.isDecimal(keepAliveInterval)) {
	        value = Number(keepAliveInterval);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    extraSupported: function(optionTags) {
	      var idx, length;
	
	      if (!(optionTags instanceof Array)) {
	        return;
	      }
	
	      length = optionTags.length;
	      for (idx = 0; idx < length; idx++) {
	        if (typeof optionTags[idx] !== 'string') {
	          return;
	        }
	      }
	
	      return optionTags;
	    },
	
	    noAnswerTimeout: function(noAnswerTimeout) {
	      var value;
	      if (SIP.Utils.isDecimal(noAnswerTimeout)) {
	        value = Number(noAnswerTimeout);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    password: function(password) {
	      return String(password);
	    },
	
	    rel100: function(rel100) {
	      if(rel100 === SIP.C.supported.REQUIRED) {
	        return SIP.C.supported.REQUIRED;
	      } else if (rel100 === SIP.C.supported.SUPPORTED) {
	        return SIP.C.supported.SUPPORTED;
	      } else  {
	        return SIP.C.supported.UNSUPPORTED;
	      }
	    },
	
	    replaces: function(replaces) {
	      if(replaces === SIP.C.supported.REQUIRED) {
	        return SIP.C.supported.REQUIRED;
	      } else if (replaces === SIP.C.supported.SUPPORTED) {
	        return SIP.C.supported.SUPPORTED;
	      } else  {
	        return SIP.C.supported.UNSUPPORTED;
	      }
	    },
	
	    register: function(register) {
	      if (typeof register === 'boolean') {
	        return register;
	      }
	    },
	
	    registerExpires: function(registerExpires) {
	      var value;
	      if (SIP.Utils.isDecimal(registerExpires)) {
	        value = Number(registerExpires);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    registrarServer: function(registrarServer) {
	      var parsed;
	
	      if(typeof registrarServer !== 'string') {
	        return;
	      }
	
	      if (!/^sip:/i.test(registrarServer)) {
	        registrarServer = SIP.C.SIP + ':' + registrarServer;
	      }
	      parsed = SIP.URI.parse(registrarServer);
	
	      if(!parsed) {
	        return;
	      } else if(parsed.user) {
	        return;
	      } else {
	        return parsed;
	      }
	    },
	
	    stunServers: function(stunServers) {
	      var idx, length, stun_server;
	
	      if (typeof stunServers === 'string') {
	        stunServers = [stunServers];
	      } else if (!(stunServers instanceof Array)) {
	        return;
	      }
	
	      length = stunServers.length;
	      for (idx = 0; idx < length; idx++) {
	        stun_server = stunServers[idx];
	        if (!(/^stuns?:/.test(stun_server))) {
	          stun_server = 'stun:' + stun_server;
	        }
	
	        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {
	          return;
	        } else {
	          stunServers[idx] = stun_server;
	        }
	      }
	      return stunServers;
	    },
	
	    traceSip: function(traceSip) {
	      if (typeof traceSip === 'boolean') {
	        return traceSip;
	      }
	    },
	
	    turnServers: function(turnServers) {
	      var idx, jdx, length, turn_server, num_turn_server_urls, url;
	
	      if (turnServers instanceof Array) {
	        // Do nothing
	      } else {
	        turnServers = [turnServers];
	      }
	
	      length = turnServers.length;
	      for (idx = 0; idx < length; idx++) {
	        turn_server = turnServers[idx];
	        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.
	        if (turn_server.server) {
	          turn_server.urls = [turn_server.server];
	        }
	
	        if (!turn_server.urls || !turn_server.username || !turn_server.password) {
	          return;
	        }
	
	        if (turn_server.urls instanceof Array) {
	          num_turn_server_urls = turn_server.urls.length;
	        } else {
	          turn_server.urls = [turn_server.urls];
	          num_turn_server_urls = 1;
	        }
	
	        for (jdx = 0; jdx < num_turn_server_urls; jdx++) {
	          url = turn_server.urls[jdx];
	
	          if (!(/^turns?:/.test(url))) {
	            url = 'turn:' + url;
	          }
	
	          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {
	            return;
	          }
	        }
	      }
	      return turnServers;
	    },
	
	    userAgentString: function(userAgentString) {
	      if (typeof userAgentString === 'string') {
	        return userAgentString;
	      }
	    },
	
	    usePreloadedRoute: function(usePreloadedRoute) {
	      if (typeof usePreloadedRoute === 'boolean') {
	        return usePreloadedRoute;
	      }
	    },
	
	    wsServerMaxReconnection: function(wsServerMaxReconnection) {
	      var value;
	      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {
	        value = Number(wsServerMaxReconnection);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {
	      var value;
	      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {
	        value = Number(wsServerReconnectionTimeout);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    autostart: function(autostart) {
	      if (typeof autostart === 'boolean') {
	        return autostart;
	      }
	    },
	
	    mediaHandlerFactory: function(mediaHandlerFactory) {
	      if (mediaHandlerFactory instanceof Function) {
	        var promisifiedFactory = function promisifiedFactory () {
	          var mediaHandler = mediaHandlerFactory.apply(this, arguments);
	
	          function patchMethod (methodName) {
	            var method = mediaHandler[methodName];
	            if (method.length > 1) {
	              var callbacksFirst = methodName === 'getDescription';
	              mediaHandler[methodName] = SIP.Utils.promisify(mediaHandler, methodName, callbacksFirst);
	            }
	          }
	
	          patchMethod('getDescription');
	          patchMethod('setDescription');
	
	          return mediaHandler;
	        };
	
	        promisifiedFactory.isSupported = mediaHandlerFactory.isSupported;
	        return promisifiedFactory;
	      }
	    },
	
	    authenticationFactory: checkAuthenticationFactory
	  }
	};
	
	UA.C = C;
	SIP.UA = UA;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 240 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Hacks - This file contains all of the things we
	 * wish we didn't have to do, just for interop.  It is similar to
	 * Utils, which provides actually useful and relevant functions for
	 * a SIP library. Methods in this file are grouped by vendor, so
	 * as to most easily track when particular hacks may not be necessary anymore.
	 */
	
	module.exports = function (SIP) {
	
	//keep to quiet jshint, and remain consistent with other files
	SIP = SIP;
	
	var Hacks = {
	  AllBrowsers: {
	    maskDtls: function (message) {
	      if (message.body) {
	        message.body = message.body.replace(/ UDP\/TLS\/RTP\/SAVP/gmi, " RTP/SAVP");
	      }
	    },
	    unmaskDtls: function (sdp) {
	      /**
	       * Chrome does not handle DTLS correctly (Canaray does, but not production)
	       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)
	       *
	       * UPDATE: May 21, 2014
	       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES
	       *
	       * UPDATE: 2014-09-24
	       * Opera now supports DTLS by default as well.
	       *
	       **/
	      return sdp.replace(/ RTP\/SAVP/gmi, " UDP/TLS/RTP/SAVP");
	    }
	  },
	  Firefox: {
	    /* Condition to detect if hacks are applicable */
	    isFirefox: function () {
	      return typeof mozRTCPeerConnection !== 'undefined';
	    },
	
	    cannotHandleExtraWhitespace: function (message) {
	      if (this.isFirefox() && message.body) {
	        message.body = message.body.replace(/ \r\n/g, "\r\n");
	      }
	    },
	
	    hasMissingCLineInSDP: function (sdp) {
	      /*
	       * This is a Firefox hack to insert valid sdp when getDescription is
	       * called with the constraint offerToReceiveVideo = false.
	       * We search for either a c-line at the top of the sdp above all
	       * m-lines. If that does not exist then we search for a c-line
	       * beneath each m-line. If it is missing a c-line, we insert
	       * a fake c-line with the ip address 0.0.0.0. This is then valid
	       * sdp and no media will be sent for that m-line.
	       *
	       * Valid SDP is:
	       * m=
	       * i=
	       * c=
	       */
	      var insertAt, mlines;
	      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {
	
	        // Find all m= lines
	        mlines = sdp.match(/m=.*\r\n.*/g);
	        for (var i=0; i<mlines.length; i++) {
	
	          // If it has an i= line, check if the next line is the c= line
	          if (mlines[i].toString().search(/i=.*/) >= 0) {
	            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;
	            if (sdp.substr(insertAt,2)!=='c=') {
	              sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
	            }
	
	          // else add the C line if it's missing
	          } else if (mlines[i].toString().search(/c=.*/) < 0) {
	            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;
	            sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
	          }
	        }
	      }
	      return sdp;
	    },
	  },
	
	  Chrome: {
	    needsExplicitlyInactiveSDP: function (sdp) {
	      var sub, index;
	
	      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending
	        index = sdp.indexOf('m=video 0');
	        if (index !== -1) {
	          sub = sdp.substr(index);
	          sub = sub.replace(/\r\nc=IN IP4.*\r\n$/,
	                            '\r\nc=IN IP4 0.0.0.0\r\na=inactive\r\n');
	          return sdp.substr(0, index) + sub;
	        }
	      }
	      return sdp;
	    },
	
	    getsConfusedAboutGUM: function (session) {
	      if (session.mediaHandler) {
	        session.mediaHandler.close();
	      }
	    }
	  }
	};
	return Hacks;
	};

/***/ },
/* 241 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Incoming SIP Message Sanity Check
	 */
	
	/**
	 * SIP message sanity check.
	 * @augments SIP
	 * @function
	 * @param {SIP.IncomingMessage} message
	 * @param {SIP.UA} ua
	 * @param {SIP.Transport} transport
	 * @returns {Boolean}
	 */
	module.exports = function (SIP) {
	var sanityCheck,
	 logger,
	 message, ua, transport,
	 requests = [],
	 responses = [],
	 all = [];
	
	// Reply
	function reply(status_code) {
	  var to,
	    response = SIP.Utils.buildStatusLine(status_code),
	    vias = message.getHeaders('via'),
	    length = vias.length,
	    idx = 0;
	
	  for(idx; idx < length; idx++) {
	    response += "Via: " + vias[idx] + "\r\n";
	  }
	
	  to = message.getHeader('To');
	
	  if(!message.to_tag) {
	    to += ';tag=' + SIP.Utils.newTag();
	  }
	
	  response += "To: " + to + "\r\n";
	  response += "From: " + message.getHeader('From') + "\r\n";
	  response += "Call-ID: " + message.call_id + "\r\n";
	  response += "CSeq: " + message.cseq + " " + message.method + "\r\n";
	  response += "\r\n";
	
	  transport.send(response);
	}
	
	/*
	 * Sanity Check for incoming Messages
	 *
	 * Requests:
	 *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
	 *  - _rfc3261_16_3_4_ Receive a Request already sent by us
	 *   Does not look at via sent-by but at sipjsId, which is inserted as
	 *   a prefix in all initial requests generated by the ua
	 *  - _rfc3261_18_3_request_ Body Content-Length
	 *  - _rfc3261_8_2_2_2_ Merged Requests
	 *
	 * Responses:
	 *  - _rfc3261_8_1_3_3_ Multiple Via headers
	 *  - _rfc3261_18_1_2_ sent-by mismatch
	 *  - _rfc3261_18_3_response_ Body Content-Length
	 *
	 * All:
	 *  - Minimum headers in a SIP message
	 */
	
	// Sanity Check functions for requests
	function rfc3261_8_2_2_1() {
	  if(!message.ruri || message.ruri.scheme !== 'sip') {
	    reply(416);
	    return false;
	  }
	}
	
	function rfc3261_16_3_4() {
	  if(!message.to_tag) {
	    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {
	      reply(482);
	      return false;
	    }
	  }
	}
	
	function rfc3261_18_3_request() {
	  var len = SIP.Utils.str_utf8_length(message.body),
	  contentLength = message.getHeader('content-length');
	
	  if(len < contentLength) {
	    reply(400);
	    return false;
	  }
	}
	
	function rfc3261_8_2_2_2() {
	  var tr, idx,
	    fromTag = message.from_tag,
	    call_id = message.call_id,
	    cseq = message.cseq;
	
	  if(!message.to_tag) {
	    if(message.method === SIP.C.INVITE) {
	      tr = ua.transactions.ist[message.via_branch];
	      if(tr) {
	        return;
	      } else {
	        for(idx in ua.transactions.ist) {
	          tr = ua.transactions.ist[idx];
	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
	            reply(482);
	            return false;
	          }
	        }
	      }
	    } else {
	      tr = ua.transactions.nist[message.via_branch];
	      if(tr) {
	        return;
	      } else {
	        for(idx in ua.transactions.nist) {
	          tr = ua.transactions.nist[idx];
	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
	            reply(482);
	            return false;
	          }
	        }
	      }
	    }
	  }
	}
	
	// Sanity Check functions for responses
	function rfc3261_8_1_3_3() {
	  if(message.getHeaders('via').length > 1) {
	    logger.warn('More than one Via header field present in the response. Dropping the response');
	    return false;
	  }
	}
	
	function rfc3261_18_1_2() {
	  var viaHost = ua.configuration.viaHost;
	  if(message.via.host !== viaHost || message.via.port !== undefined) {
	    logger.warn('Via sent-by in the response does not match UA Via host value. Dropping the response');
	    return false;
	  }
	}
	
	function rfc3261_18_3_response() {
	  var
	    len = SIP.Utils.str_utf8_length(message.body),
	    contentLength = message.getHeader('content-length');
	
	    if(len < contentLength) {
	      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');
	      return false;
	    }
	}
	
	// Sanity Check functions for requests and responses
	function minimumHeaders() {
	  var
	    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],
	    idx = mandatoryHeaders.length;
	
	  while(idx--) {
	    if(!message.hasHeader(mandatoryHeaders[idx])) {
	      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');
	      return false;
	    }
	  }
	}
	
	requests.push(rfc3261_8_2_2_1);
	requests.push(rfc3261_16_3_4);
	requests.push(rfc3261_18_3_request);
	requests.push(rfc3261_8_2_2_2);
	
	responses.push(rfc3261_8_1_3_3);
	responses.push(rfc3261_18_1_2);
	responses.push(rfc3261_18_3_response);
	
	all.push(minimumHeaders);
	
	sanityCheck = function(m, u, t) {
	  var len, pass;
	
	  message = m;
	  ua = u;
	  transport = t;
	
	  logger = ua.getLogger('sip.sanitycheck');
	
	  len = all.length;
	  while(len--) {
	    pass = all[len](message);
	    if(pass === false) {
	      return false;
	    }
	  }
	
	  if(message instanceof SIP.IncomingRequest) {
	    len = requests.length;
	    while(len--) {
	      pass = requests[len](message);
	      if(pass === false) {
	        return false;
	      }
	    }
	  }
	
	  else if(message instanceof SIP.IncomingResponse) {
	    len = responses.length;
	    while(len--) {
	      pass = responses[len](message);
	      if(pass === false) {
	        return false;
	      }
	    }
	  }
	
	  //Everything is OK
	  return true;
	};
	
	SIP.sanityCheck = sanityCheck;
	};


/***/ },
/* 242 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview SIP Digest Authentication
	 */
	
	/**
	 * SIP Digest Authentication.
	 * @augments SIP.
	 * @function Digest Authentication
	 * @param {SIP.UA} ua
	 */
	module.exports = function (Utils) {
	var DigestAuthentication;
	
	DigestAuthentication = function(ua) {
	  this.logger = ua.getLogger('sipjs.digestauthentication');
	  this.username = ua.configuration.authorizationUser;
	  this.password = ua.configuration.password;
	  this.cnonce = null;
	  this.nc = 0;
	  this.ncHex = '00000000';
	  this.response = null;
	};
	
	
	/**
	* Performs Digest authentication given a SIP request and the challenge
	* received in a response to that request.
	* Returns true if credentials were successfully generated, false otherwise.
	*
	* @param {SIP.OutgoingRequest} request
	* @param {Object} challenge
	*/
	DigestAuthentication.prototype.authenticate = function(request, challenge) {
	  // Inspect and validate the challenge.
	
	  this.algorithm = challenge.algorithm;
	  this.realm = challenge.realm;
	  this.nonce = challenge.nonce;
	  this.opaque = challenge.opaque;
	  this.stale = challenge.stale;
	
	  if (this.algorithm) {
	    if (this.algorithm !== 'MD5') {
	      this.logger.warn('challenge with Digest algorithm different than "MD5", authentication aborted');
	      return false;
	    }
	  } else {
	    this.algorithm = 'MD5';
	  }
	
	  if (! this.realm) {
	    this.logger.warn('challenge without Digest realm, authentication aborted');
	    return false;
	  }
	
	  if (! this.nonce) {
	    this.logger.warn('challenge without Digest nonce, authentication aborted');
	    return false;
	  }
	
	  // 'qop' can contain a list of values (Array). Let's choose just one.
	  if (challenge.qop) {
	    if (challenge.qop.indexOf('auth') > -1) {
	      this.qop = 'auth';
	    } else if (challenge.qop.indexOf('auth-int') > -1) {
	      this.qop = 'auth-int';
	    } else {
	      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
	      this.logger.warn('challenge without Digest qop different than "auth" or "auth-int", authentication aborted');
	      return false;
	    }
	  } else {
	    this.qop = null;
	  }
	
	  // Fill other attributes.
	
	  this.method = request.method;
	  this.uri = request.ruri;
	  this.cnonce = Utils.createRandomToken(12);
	  this.nc += 1;
	  this.updateNcHex();
	
	  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
	  if (this.nc === 4294967296) {
	    this.nc = 1;
	    this.ncHex = '00000001';
	  }
	
	  // Calculate the Digest "response" value.
	  this.calculateResponse();
	
	  return true;
	};
	
	
	/**
	* Generate Digest 'response' value.
	* @private
	*/
	DigestAuthentication.prototype.calculateResponse = function() {
	  var ha1, ha2;
	
	  // HA1 = MD5(A1) = MD5(username:realm:password)
	  ha1 = Utils.calculateMD5(this.username + ":" + this.realm + ":" + this.password);
	
	  if (this.qop === 'auth') {
	    // HA2 = MD5(A2) = MD5(method:digestURI)
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
	
	  } else if (this.qop === 'auth-int') {
	    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri + ":" + Utils.calculateMD5(this.body ? this.body : ""));
	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
	
	  } else if (this.qop === null) {
	    // HA2 = MD5(A2) = MD5(method:digestURI)
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
	    // response = MD5(HA1:nonce:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + ha2);
	  }
	};
	
	
	/**
	* Return the Proxy-Authorization or WWW-Authorization header value.
	*/
	DigestAuthentication.prototype.toString = function() {
	  var auth_params = [];
	
	  if (! this.response) {
	    throw new Error('response field does not exist, cannot generate Authorization header');
	  }
	
	  auth_params.push('algorithm=' + this.algorithm);
	  auth_params.push('username="' + this.username + '"');
	  auth_params.push('realm="' + this.realm + '"');
	  auth_params.push('nonce="' + this.nonce + '"');
	  auth_params.push('uri="' + this.uri + '"');
	  auth_params.push('response="' + this.response + '"');
	  if (this.opaque) {
	    auth_params.push('opaque="' + this.opaque + '"');
	  }
	  if (this.qop) {
	    auth_params.push('qop=' + this.qop);
	    auth_params.push('cnonce="' + this.cnonce + '"');
	    auth_params.push('nc=' + this.ncHex);
	  }
	
	  return 'Digest ' + auth_params.join(', ');
	};
	
	
	/**
	* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
	* @private
	*/
	DigestAuthentication.prototype.updateNcHex = function() {
	  var hex = Number(this.nc).toString(16);
	  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;
	};
	
	return DigestAuthentication;
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Grammar = __webpack_require__(244);
	
	module.exports = function (SIP) {
	
	return {
	  parse: function parseCustom (input, startRule) {
	    var options = {startRule: startRule, SIP: SIP};
	    try {
	      Grammar.parse(input, options);
	    } catch (e) {
	      options.data = -1;
	    }
	    return options.data;
	  }
	};
	
	};


/***/ },
/* 244 */
/***/ function(module, exports) {

	module.exports = (function() {
	  /*
	   * Generated by PEG.js 0.8.0.
	   *
	   * http://pegjs.majda.cz/
	   */
	
	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }
	
	  function SyntaxError(message, expected, found, offset, line, column) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.offset   = offset;
	    this.line     = line;
	    this.column   = column;
	
	    this.name     = "SyntaxError";
	  }
	
	  peg$subclass(SyntaxError, Error);
	
	  function parse(input) {
	    var options = arguments.length > 1 ? arguments[1] : {},
	
	        peg$FAILED = {},
	
	        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 185, Supported: 190, Require: 181, Via: 193, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Min_SE: 212, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, Replaces: 178, Session_Expires: 209, stun_URI: 216, To: 191, turn_URI: 223, uuid: 226, WWW_Authenticate: 208, challenge: 157 },
	        peg$startRuleIndex   = 118,
	
	        peg$consts = [
	          "\r\n",
	          { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
	          /^[0-9]/,
	          { type: "class", value: "[0-9]", description: "[0-9]" },
	          /^[a-zA-Z]/,
	          { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
	          /^[0-9a-fA-F]/,
	          { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
	          /^[\0-\xFF]/,
	          { type: "class", value: "[\\0-\\xFF]", description: "[\\0-\\xFF]" },
	          /^["]/,
	          { type: "class", value: "[\"]", description: "[\"]" },
	          " ",
	          { type: "literal", value: " ", description: "\" \"" },
	          "\t",
	          { type: "literal", value: "\t", description: "\"\\t\"" },
	          /^[a-zA-Z0-9]/,
	          { type: "class", value: "[a-zA-Z0-9]", description: "[a-zA-Z0-9]" },
	          ";",
	          { type: "literal", value: ";", description: "\";\"" },
	          "/",
	          { type: "literal", value: "/", description: "\"/\"" },
	          "?",
	          { type: "literal", value: "?", description: "\"?\"" },
	          ":",
	          { type: "literal", value: ":", description: "\":\"" },
	          "@",
	          { type: "literal", value: "@", description: "\"@\"" },
	          "&",
	          { type: "literal", value: "&", description: "\"&\"" },
	          "=",
	          { type: "literal", value: "=", description: "\"=\"" },
	          "+",
	          { type: "literal", value: "+", description: "\"+\"" },
	          "$",
	          { type: "literal", value: "$", description: "\"$\"" },
	          ",",
	          { type: "literal", value: ",", description: "\",\"" },
	          "-",
	          { type: "literal", value: "-", description: "\"-\"" },
	          "_",
	          { type: "literal", value: "_", description: "\"_\"" },
	          ".",
	          { type: "literal", value: ".", description: "\".\"" },
	          "!",
	          { type: "literal", value: "!", description: "\"!\"" },
	          "~",
	          { type: "literal", value: "~", description: "\"~\"" },
	          "*",
	          { type: "literal", value: "*", description: "\"*\"" },
	          "'",
	          { type: "literal", value: "'", description: "\"'\"" },
	          "(",
	          { type: "literal", value: "(", description: "\"(\"" },
	          ")",
	          { type: "literal", value: ")", description: "\")\"" },
	          peg$FAILED,
	          "%",
	          { type: "literal", value: "%", description: "\"%\"" },
	          null,
	          [],
	          function() {return " "; },
	          function() {return ':'; },
	          /^[!-~]/,
	          { type: "class", value: "[!-~]", description: "[!-~]" },
	          /^[\x80-\uFFFF]/,
	          { type: "class", value: "[\\x80-\\uFFFF]", description: "[\\x80-\\uFFFF]" },
	          /^[\x80-\xBF]/,
	          { type: "class", value: "[\\x80-\\xBF]", description: "[\\x80-\\xBF]" },
	          /^[a-f]/,
	          { type: "class", value: "[a-f]", description: "[a-f]" },
	          "`",
	          { type: "literal", value: "`", description: "\"`\"" },
	          "<",
	          { type: "literal", value: "<", description: "\"<\"" },
	          ">",
	          { type: "literal", value: ">", description: "\">\"" },
	          "\\",
	          { type: "literal", value: "\\", description: "\"\\\\\"" },
	          "[",
	          { type: "literal", value: "[", description: "\"[\"" },
	          "]",
	          { type: "literal", value: "]", description: "\"]\"" },
	          "{",
	          { type: "literal", value: "{", description: "\"{\"" },
	          "}",
	          { type: "literal", value: "}", description: "\"}\"" },
	          function() {return "*"; },
	          function() {return "/"; },
	          function() {return "="; },
	          function() {return "("; },
	          function() {return ")"; },
	          function() {return ">"; },
	          function() {return "<"; },
	          function() {return ","; },
	          function() {return ";"; },
	          function() {return ":"; },
	          function() {return "\""; },
	          /^[!-']/,
	          { type: "class", value: "[!-']", description: "[!-']" },
	          /^[*-[]/,
	          { type: "class", value: "[*-[]", description: "[*-[]" },
	          /^[\]-~]/,
	          { type: "class", value: "[\\]-~]", description: "[\\]-~]" },
	          function(contents) {
	                                  return contents; },
	          /^[#-[]/,
	          { type: "class", value: "[#-[]", description: "[#-[]" },
	          /^[\0-\t]/,
	          { type: "class", value: "[\\0-\\t]", description: "[\\0-\\t]" },
	          /^[\x0B-\f]/,
	          { type: "class", value: "[\\x0B-\\f]", description: "[\\x0B-\\f]" },
	          /^[\x0E-]/,
	          { type: "class", value: "[\\x0E-]", description: "[\\x0E-]" },
	          function() {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                },
	          function() {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                  delete options.data.uri_params;
	
	                                  if (options.startRule === 'SIP_URI') { options.data = options.data.uri;}
	                                },
	          "sips",
	          { type: "literal", value: "sips", description: "\"sips\"" },
	          "sip",
	          { type: "literal", value: "sip", description: "\"sip\"" },
	          function(uri_scheme) {
	                              options.data.scheme = uri_scheme; },
	          function() {
	                              options.data.user = decodeURIComponent(text().slice(0, -1));},
	          function() {
	                              options.data.password = text(); },
	          function() {
	                              options.data.host = text();
	                              return options.data.host; },
	          function() {
	                            options.data.host_type = 'domain';
	                            return text(); },
	          /^[a-zA-Z0-9_\-]/,
	          { type: "class", value: "[a-zA-Z0-9_\\-]", description: "[a-zA-Z0-9_\\-]" },
	          /^[a-zA-Z0-9\-]/,
	          { type: "class", value: "[a-zA-Z0-9\\-]", description: "[a-zA-Z0-9\\-]" },
	          function() {
	                              options.data.host_type = 'IPv6';
	                              return text(); },
	          "::",
	          { type: "literal", value: "::", description: "\"::\"" },
	          function() {
	                            options.data.host_type = 'IPv6';
	                            return text(); },
	          function() {
	                              options.data.host_type = 'IPv4';
	                              return text(); },
	          "25",
	          { type: "literal", value: "25", description: "\"25\"" },
	          /^[0-5]/,
	          { type: "class", value: "[0-5]", description: "[0-5]" },
	          "2",
	          { type: "literal", value: "2", description: "\"2\"" },
	          /^[0-4]/,
	          { type: "class", value: "[0-4]", description: "[0-4]" },
	          "1",
	          { type: "literal", value: "1", description: "\"1\"" },
	          /^[1-9]/,
	          { type: "class", value: "[1-9]", description: "[1-9]" },
	          function(port) {
	                              port = parseInt(port.join(''));
	                              options.data.port = port;
	                              return port; },
	          "transport=",
	          { type: "literal", value: "transport=", description: "\"transport=\"" },
	          "udp",
	          { type: "literal", value: "udp", description: "\"udp\"" },
	          "tcp",
	          { type: "literal", value: "tcp", description: "\"tcp\"" },
	          "sctp",
	          { type: "literal", value: "sctp", description: "\"sctp\"" },
	          "tls",
	          { type: "literal", value: "tls", description: "\"tls\"" },
	          function(transport) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['transport'] = transport.toLowerCase(); },
	          "user=",
	          { type: "literal", value: "user=", description: "\"user=\"" },
	          "phone",
	          { type: "literal", value: "phone", description: "\"phone\"" },
	          "ip",
	          { type: "literal", value: "ip", description: "\"ip\"" },
	          function(user) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['user'] = user.toLowerCase(); },
	          "method=",
	          { type: "literal", value: "method=", description: "\"method=\"" },
	          function(method) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['method'] = method; },
	          "ttl=",
	          { type: "literal", value: "ttl=", description: "\"ttl=\"" },
	          function(ttl) {
	                                if(!options.data.params) options.data.params={};
	                                options.data.params['ttl'] = ttl; },
	          "maddr=",
	          { type: "literal", value: "maddr=", description: "\"maddr=\"" },
	          function(maddr) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['maddr'] = maddr; },
	          "lr",
	          { type: "literal", value: "lr", description: "\"lr\"" },
	          function() {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['lr'] = undefined; },
	          function(param, value) {
	                                if(!options.data.uri_params) options.data.uri_params = {};
	                                if (value === null){
	                                  value = undefined;
	                                }
	                                else {
	                                  value = value[1];
	                                }
	                                options.data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},
	          function(hname, hvalue) {
	                                hname = hname.join('').toLowerCase();
	                                hvalue = hvalue.join('');
	                                if(!options.data.uri_headers) options.data.uri_headers = {};
	                                if (!options.data.uri_headers[hname]) {
	                                  options.data.uri_headers[hname] = [hvalue];
	                                } else {
	                                  options.data.uri_headers[hname].push(hvalue);
	                                }},
	          function() {
	                                // lots of tests fail if this isn't guarded...
	                                if (options.startRule === 'Refer_To') {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                  delete options.data.uri_params;
	                                }
	                              },
	          "//",
	          { type: "literal", value: "//", description: "\"//\"" },
	          function() {
	                              options.data.scheme= text(); },
	          { type: "literal", value: "SIP", description: "\"SIP\"" },
	          function() {
	                              options.data.sip_version = text(); },
	          "INVITE",
	          { type: "literal", value: "INVITE", description: "\"INVITE\"" },
	          "ACK",
	          { type: "literal", value: "ACK", description: "\"ACK\"" },
	          "VXACH",
	          { type: "literal", value: "VXACH", description: "\"VXACH\"" },
	          "OPTIONS",
	          { type: "literal", value: "OPTIONS", description: "\"OPTIONS\"" },
	          "BYE",
	          { type: "literal", value: "BYE", description: "\"BYE\"" },
	          "CANCEL",
	          { type: "literal", value: "CANCEL", description: "\"CANCEL\"" },
	          "REGISTER",
	          { type: "literal", value: "REGISTER", description: "\"REGISTER\"" },
	          "SUBSCRIBE",
	          { type: "literal", value: "SUBSCRIBE", description: "\"SUBSCRIBE\"" },
	          "NOTIFY",
	          { type: "literal", value: "NOTIFY", description: "\"NOTIFY\"" },
	          "REFER",
	          { type: "literal", value: "REFER", description: "\"REFER\"" },
	          function() {
	
	                              options.data.method = text();
	                              return options.data.method; },
	          function(status_code) {
	                            options.data.status_code = parseInt(status_code.join('')); },
	          function() {
	                            options.data.reason_phrase = text(); },
	          function() {
	                        options.data = text(); },
	          function() {
	                                  var idx, length;
	                                  length = options.data.multi_header.length;
	                                  for (idx = 0; idx < length; idx++) {
	                                    if (options.data.multi_header[idx].parsed === null) {
	                                      options.data = null;
	                                      break;
	                                    }
	                                  }
	                                  if (options.data !== null) {
	                                    options.data = options.data.multi_header;
	                                  } else {
	                                    options.data = -1;
	                                  }},
	          function() {
	                                  var header;
	                                  if(!options.data.multi_header) options.data.multi_header = [];
	                                  try {
	                                    header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                                    delete options.data.uri;
	                                    delete options.data.displayName;
	                                    delete options.data.params;
	                                  } catch(e) {
	                                    header = null;
	                                  }
	                                  options.data.multi_header.push( { 'position': peg$currPos,
	                                                            'offset': offset(),
	                                                            'parsed': header
	                                                          });},
	          function(displayName) {
	                                  displayName = text().trim();
	                                  if (displayName[0] === '\"') {
	                                    displayName = displayName.substring(1, displayName.length-1);
	                                  }
	                                  options.data.displayName = displayName; },
	          "q",
	          { type: "literal", value: "q", description: "\"q\"" },
	          function(q) {
	                                  if(!options.data.params) options.data.params = {};
	                                  options.data.params['q'] = q; },
	          "expires",
	          { type: "literal", value: "expires", description: "\"expires\"" },
	          function(expires) {
	                                  if(!options.data.params) options.data.params = {};
	                                  options.data.params['expires'] = expires; },
	          function(delta_seconds) {
	                                  return parseInt(delta_seconds.join('')); },
	          "0",
	          { type: "literal", value: "0", description: "\"0\"" },
	          function() {
	                                  return parseFloat(text()); },
	          function(param, value) {
	                                  if(!options.data.params) options.data.params = {};
	                                  if (value === null){
	                                    value = undefined;
	                                  }
	                                  else {
	                                    value = value[1];
	                                  }
	                                  options.data.params[param.toLowerCase()] = value;},
	          "render",
	          { type: "literal", value: "render", description: "\"render\"" },
	          "session",
	          { type: "literal", value: "session", description: "\"session\"" },
	          "icon",
	          { type: "literal", value: "icon", description: "\"icon\"" },
	          "alert",
	          { type: "literal", value: "alert", description: "\"alert\"" },
	          function() {
	                                      if (options.startRule === 'Content_Disposition') {
	                                        options.data.type = text().toLowerCase();
	                                      }
	                                    },
	          "handling",
	          { type: "literal", value: "handling", description: "\"handling\"" },
	          "optional",
	          { type: "literal", value: "optional", description: "\"optional\"" },
	          "required",
	          { type: "literal", value: "required", description: "\"required\"" },
	          function(length) {
	                                  options.data = parseInt(length.join('')); },
	          function() {
	                                  options.data = text(); },
	          "text",
	          { type: "literal", value: "text", description: "\"text\"" },
	          "image",
	          { type: "literal", value: "image", description: "\"image\"" },
	          "audio",
	          { type: "literal", value: "audio", description: "\"audio\"" },
	          "video",
	          { type: "literal", value: "video", description: "\"video\"" },
	          "application",
	          { type: "literal", value: "application", description: "\"application\"" },
	          "message",
	          { type: "literal", value: "message", description: "\"message\"" },
	          "multipart",
	          { type: "literal", value: "multipart", description: "\"multipart\"" },
	          "x-",
	          { type: "literal", value: "x-", description: "\"x-\"" },
	          function(cseq_value) {
	                            options.data.value=parseInt(cseq_value.join('')); },
	          function(expires) {options.data = expires; },
	          function(event_type) {
	                                 options.data.event = event_type.toLowerCase(); },
	          function() {
	                          var tag = options.data.tag;
	                            options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                            if (tag) {options.data.setParam('tag',tag)}
	                          },
	          "tag",
	          { type: "literal", value: "tag", description: "\"tag\"" },
	          function(tag) {options.data.tag = tag; },
	          function(forwards) {
	                            options.data = parseInt(forwards.join('')); },
	          function(min_expires) {options.data = min_expires; },
	          function() {
	                                  options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                                },
	          "digest",
	          { type: "literal", value: "Digest", description: "\"Digest\"" },
	          "realm",
	          { type: "literal", value: "realm", description: "\"realm\"" },
	          function(realm) { options.data.realm = realm; },
	          "domain",
	          { type: "literal", value: "domain", description: "\"domain\"" },
	          "nonce",
	          { type: "literal", value: "nonce", description: "\"nonce\"" },
	          function(nonce) { options.data.nonce=nonce; },
	          "opaque",
	          { type: "literal", value: "opaque", description: "\"opaque\"" },
	          function(opaque) { options.data.opaque=opaque; },
	          "stale",
	          { type: "literal", value: "stale", description: "\"stale\"" },
	          "true",
	          { type: "literal", value: "true", description: "\"true\"" },
	          function() { options.data.stale=true; },
	          "false",
	          { type: "literal", value: "false", description: "\"false\"" },
	          function() { options.data.stale=false; },
	          "algorithm",
	          { type: "literal", value: "algorithm", description: "\"algorithm\"" },
	          "md5",
	          { type: "literal", value: "MD5", description: "\"MD5\"" },
	          "md5-sess",
	          { type: "literal", value: "MD5-sess", description: "\"MD5-sess\"" },
	          function(algorithm) {
	                                options.data.algorithm=algorithm.toUpperCase(); },
	          "qop",
	          { type: "literal", value: "qop", description: "\"qop\"" },
	          "auth-int",
	          { type: "literal", value: "auth-int", description: "\"auth-int\"" },
	          "auth",
	          { type: "literal", value: "auth", description: "\"auth\"" },
	          function(qop_value) {
	                                  options.data.qop || (options.data.qop=[]);
	                                  options.data.qop.push(qop_value.toLowerCase()); },
	          function(rack_value) {
	                            options.data.value=parseInt(rack_value.join('')); },
	          function() {
	                            var idx, length;
	                            length = options.data.multi_header.length;
	                            for (idx = 0; idx < length; idx++) {
	                              if (options.data.multi_header[idx].parsed === null) {
	                                options.data = null;
	                                break;
	                              }
	                            }
	                            if (options.data !== null) {
	                              options.data = options.data.multi_header;
	                            } else {
	                              options.data = -1;
	                            }},
	          function() {
	                            var header;
	                            if(!options.data.multi_header) options.data.multi_header = [];
	                            try {
	                              header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                              delete options.data.uri;
	                              delete options.data.displayName;
	                              delete options.data.params;
	                            } catch(e) {
	                              header = null;
	                            }
	                            options.data.multi_header.push( { 'position': peg$currPos,
	                                                      'offset': offset(),
	                                                      'parsed': header
	                                                    });},
	          function() {
	                        options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                      },
	          function() {
	                                if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
	                                  options.data = -1;
	                                }
	                              },
	          function() {
	                                options.data = {
	                                  call_id: options.data
	                                };
	                              },
	          "from-tag",
	          { type: "literal", value: "from-tag", description: "\"from-tag\"" },
	          function(from_tag) {
	                                options.data.replaces_from_tag = from_tag;
	                              },
	          "to-tag",
	          { type: "literal", value: "to-tag", description: "\"to-tag\"" },
	          function(to_tag) {
	                                options.data.replaces_to_tag = to_tag;
	                              },
	          "early-only",
	          { type: "literal", value: "early-only", description: "\"early-only\"" },
	          function() {
	                                options.data.early_only = true;
	                              },
	          function(r) {return r;},
	          function(first, rest) { return list(first, rest); },
	          function(value) {
	                          if (options.startRule === 'Require') {
	                            options.data = value || [];
	                          }
	                        },
	          function(rseq_value) {
	                            options.data.value=parseInt(rseq_value.join('')); },
	          "active",
	          { type: "literal", value: "active", description: "\"active\"" },
	          "pending",
	          { type: "literal", value: "pending", description: "\"pending\"" },
	          "terminated",
	          { type: "literal", value: "terminated", description: "\"terminated\"" },
	          function() {
	                                  options.data.state = text(); },
	          "reason",
	          { type: "literal", value: "reason", description: "\"reason\"" },
	          function(reason) {
	                                  if (typeof reason !== 'undefined') options.data.reason = reason; },
	          function(expires) {
	                                  if (typeof expires !== 'undefined') options.data.expires = expires; },
	          "retry_after",
	          { type: "literal", value: "retry_after", description: "\"retry_after\"" },
	          function(retry_after) {
	                                  if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after; },
	          "deactivated",
	          { type: "literal", value: "deactivated", description: "\"deactivated\"" },
	          "probation",
	          { type: "literal", value: "probation", description: "\"probation\"" },
	          "rejected",
	          { type: "literal", value: "rejected", description: "\"rejected\"" },
	          "timeout",
	          { type: "literal", value: "timeout", description: "\"timeout\"" },
	          "giveup",
	          { type: "literal", value: "giveup", description: "\"giveup\"" },
	          "noresource",
	          { type: "literal", value: "noresource", description: "\"noresource\"" },
	          "invariant",
	          { type: "literal", value: "invariant", description: "\"invariant\"" },
	          function(value) {
	                          if (options.startRule === 'Supported') {
	                            options.data = value || [];
	                          }
	                        },
	          function() {
	                        var tag = options.data.tag;
	                          options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                          if (tag) {options.data.setParam('tag',tag)}
	                        },
	          "ttl",
	          { type: "literal", value: "ttl", description: "\"ttl\"" },
	          function(via_ttl_value) {
	                                options.data.ttl = via_ttl_value; },
	          "maddr",
	          { type: "literal", value: "maddr", description: "\"maddr\"" },
	          function(via_maddr) {
	                                options.data.maddr = via_maddr; },
	          "received",
	          { type: "literal", value: "received", description: "\"received\"" },
	          function(via_received) {
	                                options.data.received = via_received; },
	          "branch",
	          { type: "literal", value: "branch", description: "\"branch\"" },
	          function(via_branch) {
	                                options.data.branch = via_branch; },
	          "rport",
	          { type: "literal", value: "rport", description: "\"rport\"" },
	          function() {
	                                if(typeof response_port !== 'undefined')
	                                  options.data.rport = response_port.join(''); },
	          function(via_protocol) {
	                                options.data.protocol = via_protocol; },
	          { type: "literal", value: "UDP", description: "\"UDP\"" },
	          { type: "literal", value: "TCP", description: "\"TCP\"" },
	          { type: "literal", value: "TLS", description: "\"TLS\"" },
	          { type: "literal", value: "SCTP", description: "\"SCTP\"" },
	          function(via_transport) {
	                                options.data.transport = via_transport; },
	          function() {
	                                options.data.host = text(); },
	          function(via_sent_by_port) {
	                                options.data.port = parseInt(via_sent_by_port.join('')); },
	          function(ttl) {
	                                return parseInt(ttl.join('')); },
	          function(deltaSeconds) {
	                                if (options.startRule === 'Session_Expires') {
	                                  options.data.deltaSeconds = deltaSeconds;
	                                }
	                              },
	          "refresher",
	          { type: "literal", value: "refresher", description: "\"refresher\"" },
	          "uas",
	          { type: "literal", value: "uas", description: "\"uas\"" },
	          "uac",
	          { type: "literal", value: "uac", description: "\"uac\"" },
	          function(endpoint) {
	                                if (options.startRule === 'Session_Expires') {
	                                  options.data.refresher = endpoint;
	                                }
	                              },
	          function(deltaSeconds) {
	                                if (options.startRule === 'Min_SE') {
	                                  options.data = deltaSeconds;
	                                }
	                              },
	          "stuns",
	          { type: "literal", value: "stuns", description: "\"stuns\"" },
	          "stun",
	          { type: "literal", value: "stun", description: "\"stun\"" },
	          function(scheme) {
	                                options.data.scheme = scheme; },
	          function(host) {
	                                options.data.host = host; },
	          "?transport=",
	          { type: "literal", value: "?transport=", description: "\"?transport=\"" },
	          "turns",
	          { type: "literal", value: "turns", description: "\"turns\"" },
	          "turn",
	          { type: "literal", value: "turn", description: "\"turn\"" },
	          function() {
	                                options.data.transport = transport; },
	          function() {
	                            options.data = text(); }
	        ],
	
	        peg$bytecode = [
	          peg$decode(". \"\"2 3!"),
	          peg$decode("0\"\"\"1!3#"),
	          peg$decode("0$\"\"1!3%"),
	          peg$decode("0&\"\"1!3'"),
	          peg$decode("7'*# \"7("),
	          peg$decode("0(\"\"1!3)"),
	          peg$decode("0*\"\"1!3+"),
	          peg$decode(".,\"\"2,3-"),
	          peg$decode("..\"\"2.3/"),
	          peg$decode("00\"\"1!31"),
	          peg$decode(".2\"\"2233*\x89 \".4\"\"2435*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("7)*# \"7,"),
	          peg$decode(".F\"\"2F3G*} \".H\"\"2H3I*q \".J\"\"2J3K*e \".L\"\"2L3M*Y \".N\"\"2N3O*M \".P\"\"2P3Q*A \".R\"\"2R3S*5 \".T\"\"2T3U*) \".V\"\"2V3W"),
	          peg$decode("!!.Y\"\"2Y3Z+7$7#+-%7#+#%'#%$## X$\"# X\"# X+! (%"),
	          peg$decode("!! \\7$,#&7$\"+-$7 +#%'\"%$\"# X\"# X*# \" [+@$ \\7$+&$,#&7$\"\"\" X+'%4\"6]\" %$\"# X\"# X"),
	          peg$decode("7.*# \" ["),
	          peg$decode("! \\7'*# \"7(,)&7'*# \"7(\"+A$.8\"\"2839+1%7/+'%4#6^# %$## X$\"# X\"# X"),
	          peg$decode("!! \\72+&$,#&72\"\"\" X+o$ \\! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X,@&! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
	          peg$decode("0_\"\"1!3`*# \"73"),
	          peg$decode("0a\"\"1!3b"),
	          peg$decode("0c\"\"1!3d"),
	          peg$decode("7!*) \"0e\"\"1!3f"),
	          peg$decode("! \\7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x9E$,\x9B&7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
	          peg$decode("! \\7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x92$,\x8F&7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
	          peg$decode(".T\"\"2T3U*\xE3 \".V\"\"2V3W*\xD7 \".i\"\"2i3j*\xCB \".k\"\"2k3l*\xBF \".:\"\"2:3;*\xB3 \".D\"\"2D3E*\xA7 \".2\"\"2233*\x9B \".8\"\"2839*\x8F \".m\"\"2m3n*\x83 \"7&*} \".4\"\"2435*q \".o\"\"2o3p*e \".q\"\"2q3r*Y \".6\"\"2637*M \".>\"\"2>3?*A \".s\"\"2s3t*5 \".u\"\"2u3v*) \"7'*# \"7("),
	          peg$decode("! \\7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v+\u0134$,\u0131&7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v\"\"\" X+! (%"),
	          peg$decode("!7/+A$.P\"\"2P3Q+1%7/+'%4#6w# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.4\"\"2435+1%7/+'%4#6x# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.>\"\"2>3?+1%7/+'%4#6y# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.T\"\"2T3U+1%7/+'%4#6z# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.V\"\"2V3W+1%7/+'%4#6{# %$## X$\"# X\"# X"),
	          peg$decode("!.k\"\"2k3l+1$7/+'%4\"6|\" %$\"# X\"# X"),
	          peg$decode("!7/+7$.i\"\"2i3j+'%4\"6}\" %$\"# X\"# X"),
	          peg$decode("!7/+A$.D\"\"2D3E+1%7/+'%4#6~# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.2\"\"2233+1%7/+'%4#6# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.8\"\"2839+1%7/+'%4#6\x80# %$## X$\"# X\"# X"),
	          peg$decode("!7/+1$7&+'%4\"6\x81\" %$\"# X\"# X"),
	          peg$decode("!7&+1$7/+'%4\"6\x81\" %$\"# X\"# X"),
	          peg$decode("!7=+W$ \\7G*) \"7K*# \"7F,/&7G*) \"7K*# \"7F\"+-%7>+#%'#%$## X$\"# X\"# X"),
	          peg$decode("0\x82\"\"1!3\x83*A \"0\x84\"\"1!3\x85*5 \"0\x86\"\"1!3\x87*) \"73*# \"7."),
	          peg$decode("!!7/+U$7&+K% \\7J*# \"7K,)&7J*# \"7K\"+-%7&+#%'$%$$# X$## X$\"# X\"# X+! (%"),
	          peg$decode("!7/+`$7&+V%! \\7J*# \"7K,)&7J*# \"7K\"+! (%+2%7&+(%4$6\x88$!!%$$# X$## X$\"# X\"# X"),
	          peg$decode("7.*G \".L\"\"2L3M*; \"0\x89\"\"1!3\x8A*/ \"0\x86\"\"1!3\x87*# \"73"),
	          peg$decode("!.m\"\"2m3n+K$0\x8B\"\"1!3\x8C*5 \"0\x8D\"\"1!3\x8E*) \"0\x8F\"\"1!3\x90+#%'\"%$\"# X\"# X"),
	          peg$decode("!7N+Q$.8\"\"2839+A%7O*# \" [+1%7S+'%4$6\x91$ %$$# X$## X$\"# X\"# X"),
	          peg$decode("!7N+k$.8\"\"2839+[%7O*# \" [+K%7S+A%7_+7%7l*# \" [+'%4&6\x92& %$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\x93\"\"1$3\x94*) \"/\x95\"\"1#3\x96+' 4!6\x97!! %"),
	          peg$decode("!7P+b$!.8\"\"2839+-$7R+#%'\"%$\"# X\"# X*# \" [+7%.:\"\"2:3;+'%4#6\x98# %$## X$\"# X\"# X"),
	          peg$decode(" \\7+*) \"7-*# \"7Q+2$,/&7+*) \"7-*# \"7Q\"\"\" X"),
	          peg$decode(".<\"\"2<3=*q \".>\"\"2>3?*e \".@\"\"2@3A*Y \".B\"\"2B3C*M \".D\"\"2D3E*A \".2\"\"2233*5 \".6\"\"2637*) \".4\"\"2435"),
	          peg$decode("! \\7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E,e&7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E\"+& 4!6\x99! %"),
	          peg$decode("!7T+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\x9A! %"),
	          peg$decode("! \\!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X,>&!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X\"+G$7W+=%.J\"\"2J3K*# \" [+'%4#6\x9B# %$## X$\"# X\"# X"),
	          peg$decode(" \\0\x9C\"\"1!3\x9D+,$,)&0\x9C\"\"1!3\x9D\"\"\" X"),
	          peg$decode("!0$\"\"1!3%+A$ \\0\x9E\"\"1!3\x9F,)&0\x9E\"\"1!3\x9F\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!.o\"\"2o3p+A$7Y+7%.q\"\"2q3r+'%4#6\xA0# %$## X$\"# X\"# X"),
	          peg$decode("!!7Z+\xBF$.8\"\"2839+\xAF%7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0838 \"!.\xA1\"\"2\xA13\xA2+\xAF$7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0795 \"!.\xA1\"\"2\xA13\xA2+\x95$7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u070C \"!.\xA1\"\"2\xA13\xA2+{$7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u069D \"!.\xA1\"\"2\xA13\xA2+a$7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X*\u0648 \"!.\xA1\"\"2\xA13\xA2+G$7Z+=%.8\"\"2839+-%7[+#%'$%$$# X$## X$\"# X\"# X*\u060D \"!.\xA1\"\"2\xA13\xA2+-$7[+#%'\"%$\"# X\"# X*\u05EC \"!.\xA1\"\"2\xA13\xA2+-$7Z+#%'\"%$\"# X\"# X*\u05CB \"!7Z+\xA5$.\xA1\"\"2\xA13\xA2+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0538 \"!7Z+\xB6$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x8B%.\xA1\"\"2\xA13\xA2+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0494 \"!7Z+\xC7$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x9C%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+q%.\xA1\"\"2\xA13\xA2+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u03DF \"!7Z+\xD8$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xAD%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x82%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+W%.\xA1\"\"2\xA13\xA2+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0319 \"!7Z+\xE9$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0242 \"!7Z+\u0114$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xE9%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0140 \"!7Z+\u0135$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\u010A%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xDF%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xB4%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x89%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+^%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+3%.\xA1\"\"2\xA13\xA2+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X+& 4!6\xA3! %"),
	          peg$decode("!7#+S$7#*# \" [+C%7#*# \" [+3%7#*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!7Z+=$.8\"\"2839+-%7Z+#%'#%$## X$\"# X\"# X*# \"7\\"),
	          peg$decode("!7]+u$.J\"\"2J3K+e%7]+[%.J\"\"2J3K+K%7]+A%.J\"\"2J3K+1%7]+'%4'6\xA4' %$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!.\xA5\"\"2\xA53\xA6+3$0\xA7\"\"1!3\xA8+#%'\"%$\"# X\"# X*\xA0 \"!.\xA9\"\"2\xA93\xAA+=$0\xAB\"\"1!3\xAC+-%7!+#%'#%$## X$\"# X\"# X*o \"!.\xAD\"\"2\xAD3\xAE+7$7!+-%7!+#%'#%$## X$\"# X\"# X*D \"!0\xAF\"\"1!3\xB0+-$7!+#%'\"%$\"# X\"# X*# \"7!"),
	          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\xB1!! %"),
	          peg$decode(" \\!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X\""),
	          peg$decode("7a*A \"7b*; \"7c*5 \"7d*/ \"7e*) \"7f*# \"7g"),
	          peg$decode("!/\xB2\"\"1*3\xB3+b$/\xB4\"\"1#3\xB5*G \"/\xB6\"\"1#3\xB7*; \"/\xB8\"\"1$3\xB9*/ \"/\xBA\"\"1#3\xBB*# \"76+(%4\"6\xBC\"! %$\"# X\"# X"),
	          peg$decode("!/\xBD\"\"1%3\xBE+J$/\xBF\"\"1%3\xC0*/ \"/\xC1\"\"1\"3\xC2*# \"76+(%4\"6\xC3\"! %$\"# X\"# X"),
	          peg$decode("!/\xC4\"\"1'3\xC5+2$7\x8F+(%4\"6\xC6\"! %$\"# X\"# X"),
	          peg$decode("!/\xC7\"\"1$3\xC8+2$7\xEF+(%4\"6\xC9\"! %$\"# X\"# X"),
	          peg$decode("!/\xCA\"\"1&3\xCB+2$7T+(%4\"6\xCC\"! %$\"# X\"# X"),
	          peg$decode("!/\xCD\"\"1\"3\xCE+R$!.>\"\"2>3?+-$76+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xCF\" %$\"# X\"# X"),
	          peg$decode("!7h+T$!.>\"\"2>3?+-$7i+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xD0\"\"! %$\"# X\"# X"),
	          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
	          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
	          peg$decode("7k*) \"7+*# \"7-"),
	          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".8\"\"2839*A \".<\"\"2<3=*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
	          peg$decode("!.6\"\"2637+u$7m+k% \\!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X,>&!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X\"+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7n+C$.>\"\"2>3?+3%7o+)%4#6\xD1#\"\" %$## X$\"# X\"# X"),
	          peg$decode(" \\7p*) \"7+*# \"7-+2$,/&7p*) \"7+*# \"7-\"\"\" X"),
	          peg$decode(" \\7p*) \"7+*# \"7-,/&7p*) \"7+*# \"7-\""),
	          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".6\"\"2637*A \".8\"\"2839*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
	          peg$decode("7\x90*# \"7r"),
	          peg$decode("!7\x8F+K$7'+A%7s+7%7'+-%7\x84+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7M*# \"7t"),
	          peg$decode("!7+G$.8\"\"2839+7%7u*# \"7x+'%4#6\xD2# %$## X$\"# X\"# X"),
	          peg$decode("!7v*# \"7w+N$!.6\"\"2637+-$7\x83+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!.\xD3\"\"2\xD33\xD4+=$7\x80+3%7w*# \" [+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!.4\"\"2435+-$7{+#%'\"%$\"# X\"# X"),
	          peg$decode("!7z+5$ \\7y,#&7y\"+#%'\"%$\"# X\"# X"),
	          peg$decode("7**) \"7+*# \"7-"),
	          peg$decode("7+*\x8F \"7-*\x89 \".2\"\"2233*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("!7|+k$ \\!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X,>&!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7~,#&7~\"+k$ \\!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode(" \\7~,#&7~\""),
	          peg$decode("7+*w \"7-*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("!7\"+\x8D$ \\7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K,M&7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K\"+'%4\"6\xD5\" %$\"# X\"# X"),
	          peg$decode("7\x81*# \"7\x82"),
	          peg$decode("!!7O+3$.:\"\"2:3;+#%'\"%$\"# X\"# X*# \" [+-$7S+#%'\"%$\"# X\"# X*# \" ["),
	          peg$decode(" \\7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A+\x8C$,\x89&7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A\"\"\" X"),
	          peg$decode(" \\7y,#&7y\""),
	          peg$decode("!/\x95\"\"1#3\xD6+y$.4\"\"2435+i% \\7!+&$,#&7!\"\"\" X+P%.J\"\"2J3K+@% \\7!+&$,#&7!\"\"\" X+'%4%6\xD7% %$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode(".\xD8\"\"2\xD83\xD9"),
	          peg$decode(".\xDA\"\"2\xDA3\xDB"),
	          peg$decode(".\xDC\"\"2\xDC3\xDD"),
	          peg$decode(".\xDE\"\"2\xDE3\xDF"),
	          peg$decode(".\xE0\"\"2\xE03\xE1"),
	          peg$decode(".\xE2\"\"2\xE23\xE3"),
	          peg$decode(".\xE4\"\"2\xE43\xE5"),
	          peg$decode(".\xE6\"\"2\xE63\xE7"),
	          peg$decode(".\xE8\"\"2\xE83\xE9"),
	          peg$decode(".\xEA\"\"2\xEA3\xEB"),
	          peg$decode("!7\x85*S \"7\x86*M \"7\x88*G \"7\x89*A \"7\x8A*; \"7\x8B*5 \"7\x8C*/ \"7\x8D*) \"7\x8E*# \"76+& 4!6\xEC! %"),
	          peg$decode("!7\x84+K$7'+A%7\x91+7%7'+-%7\x93+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!7\x92+' 4!6\xED!! %"),
	          peg$decode("!7!+7$7!+-%7!+#%'#%$## X$\"# X\"# X"),
	          peg$decode("! \\7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(,G&7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(\"+& 4!6\xEE! %"),
	          peg$decode("!7\xB5+_$ \\!7A+-$7\xB5+#%'\"%$\"# X\"# X,8&!7A+-$7\xB5+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!79+R$!.:\"\"2:3;+-$79+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xEF\" %$\"# X\"# X"),
	          peg$decode("!7:*j \"!7\x97+_$ \\!7A+-$7\x97+#%'\"%$\"# X\"# X,8&!7A+-$7\x97+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+& 4!6\xF0! %"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\x9A+#%'\"%$\"# X\"# X,8&!7B+-$7\x9A+#%'\"%$\"# X\"# X\"+'%4\"6\xF1\" %$\"# X\"# X"),
	          peg$decode("!7\x99*# \" [+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!!76+_$ \\!7.+-$76+#%'\"%$\"# X\"# X,8&!7.+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X*# \"7H+' 4!6\xF2!! %"),
	          peg$decode("7\x9B*) \"7\x9C*# \"7\x9F"),
	          peg$decode("!/\xF3\"\"1!3\xF4+<$7<+2%7\x9E+(%4#6\xF5#! %$## X$\"# X\"# X"),
	          peg$decode("!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\xF8#! %$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\xF9!! %"),
	          peg$decode("!.\xFA\"\"2\xFA3\xFB+x$!.J\"\"2J3K+S$7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'$%$$# X$## X$\"# X\"# X*# \" [+'%4\"6\xFC\" %$\"# X\"# X"),
	          peg$decode("!76+N$!7<+-$7\xA0+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xFD\"\"! %$\"# X\"# X"),
	          peg$decode("76*) \"7T*# \"7H"),
	          peg$decode("!7\xA2+_$ \\!7B+-$7\xA3+#%'\"%$\"# X\"# X,8&!7B+-$7\xA3+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!/\xFE\"\"1&3\xFF*G \"/\u0100\"\"1'3\u0101*; \"/\u0102\"\"1$3\u0103*/ \"/\u0104\"\"1%3\u0105*# \"76+& 4!6\u0106! %"),
	          peg$decode("7\xA4*# \"7\x9F"),
	          peg$decode("!/\u0107\"\"1(3\u0108+O$7<+E%/\u0109\"\"1(3\u010A*/ \"/\u010B\"\"1(3\u010C*# \"76+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u010D!! %"),
	          peg$decode("!7\xA8+& 4!6\u010E! %"),
	          peg$decode("!7\xA9+s$7;+i%7\xAE+_% \\!7B+-$7\xAF+#%'\"%$\"# X\"# X,8&!7B+-$7\xAF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xAA*# \"7\xAB"),
	          peg$decode("/\u010F\"\"1$3\u0110*S \"/\u0111\"\"1%3\u0112*G \"/\u0113\"\"1%3\u0114*; \"/\u0115\"\"1%3\u0116*/ \"/\u0117\"\"1+3\u0118*# \"7\xAC"),
	          peg$decode("/\u0119\"\"1'3\u011A*/ \"/\u011B\"\"1)3\u011C*# \"7\xAC"),
	          peg$decode("76*# \"7\xAD"),
	          peg$decode("!/\u011D\"\"1\"3\u011E+-$76+#%'\"%$\"# X\"# X"),
	          peg$decode("7\xAC*# \"76"),
	          peg$decode("!76+7$7<+-%7\xB0+#%'#%$## X$\"# X\"# X"),
	          peg$decode("76*# \"7H"),
	          peg$decode("!7\xB2+7$7.+-%7\x8F+#%'#%$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u011F!! %"),
	          peg$decode("!7\x9D+' 4!6\u0120!! %"),
	          peg$decode("!7\xB5+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u0121\"!!%$\"# X\"# X"),
	          peg$decode("!!77+k$ \\!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X,>&!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xB7+#%'\"%$\"# X\"# X,8&!7B+-$7\xB7+#%'\"%$\"# X\"# X\"+'%4\"6\u0122\" %$\"# X\"# X"),
	          peg$decode("7\xB8*# \"7\x9F"),
	          peg$decode("!/\u0123\"\"1#3\u0124+<$7<+2%76+(%4#6\u0125#! %$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u0126!! %"),
	          peg$decode("!7\x9D+' 4!6\u0127!! %"),
	          peg$decode("! \\7\x99,#&7\x99\"+\x81$7@+w%7M+m%7?+c% \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4%6\u0128% %$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xBD"),
	          peg$decode("!/\u0129\"\"1&3\u012A+s$7.+i%7\xC0+_% \\!7A+-$7\xC0+#%'\"%$\"# X\"# X,8&!7A+-$7\xC0+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X*# \"7\xBE"),
	          peg$decode("!76+s$7.+i%7\xBF+_% \\!7A+-$7\xBF+#%'\"%$\"# X\"# X,8&!7A+-$7\xBF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!76+=$7<+3%76*# \"7H+#%'#%$## X$\"# X\"# X"),
	          peg$decode("7\xC1*G \"7\xC3*A \"7\xC5*; \"7\xC7*5 \"7\xC8*/ \"7\xC9*) \"7\xCA*# \"7\xBF"),
	          peg$decode("!/\u012B\"\"1%3\u012C+7$7<+-%7\xC2+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7I+' 4!6\u012D!! %"),
	          peg$decode("!/\u012E\"\"1&3\u012F+\xA5$7<+\x9B%7D+\x91%7\xC4+\x87% \\! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X,G&! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7t*# \"7w"),
	          peg$decode("!/\u0130\"\"1%3\u0131+7$7<+-%7\xC6+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7I+' 4!6\u0132!! %"),
	          peg$decode("!/\u0133\"\"1&3\u0134+<$7<+2%7I+(%4#6\u0135#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0136\"\"1%3\u0137+_$7<+U%!/\u0138\"\"1$3\u0139+& 4!6\u013A! %*4 \"!/\u013B\"\"1%3\u013C+& 4!6\u013D! %+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!/\u013E\"\"1)3\u013F+T$7<+J%/\u0140\"\"1#3\u0141*/ \"/\u0142\"\"1(3\u0143*# \"76+(%4#6\u0144#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0145\"\"1#3\u0146+\x9E$7<+\x94%7D+\x8A%!7\xCB+k$ \\!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X,>&!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+-%7E+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\u0147\"\"1(3\u0148*/ \"/\u0149\"\"1$3\u014A*# \"76+' 4!6\u014B!! %"),
	          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\xCE+K$7.+A%7\xCE+7%7.+-%7\x8F+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u014C!! %"),
	          peg$decode("!7\xD0+c$ \\!7A+-$7\xD0+#%'\"%$\"# X\"# X,8&!7A+-$7\xD0+#%'\"%$\"# X\"# X\"+'%4\"6\u014D\" %$\"# X\"# X"),
	          peg$decode("!7\x98+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014E\" %$\"# X\"# X"),
	          peg$decode("!7L*T \"7\x98*N \"!7@*# \" [+=$7t+3%7?*# \" [+#%'#%$## X$\"# X\"# X+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014F\" %$\"# X\"# X"),
	          peg$decode("!7\xD3+c$ \\!7B+-$7\xD4+#%'\"%$\"# X\"# X,8&!7B+-$7\xD4+#%'\"%$\"# X\"# X\"+'%4\"6\u0150\" %$\"# X\"# X"),
	          peg$decode("!7\x95+& 4!6\u0151! %"),
	          peg$decode("!/\u0152\"\"1(3\u0153+<$7<+2%76+(%4#6\u0154#! %$## X$\"# X\"# X*j \"!/\u0155\"\"1&3\u0156+<$7<+2%76+(%4#6\u0157#! %$## X$\"# X\"# X*: \"!/\u0158\"\"1*3\u0159+& 4!6\u015A! %*# \"7\x9F"),
	          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u015D!! %"),
	          peg$decode("!7\xD7+_$ \\!7A+-$7\xD7+#%'\"%$\"# X\"# X,8&!7A+-$7\xD7+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\x98+_$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u015E!! %"),
	          peg$decode("!7\xDA+_$ \\!7B+-$7\xDB+#%'\"%$\"# X\"# X,8&!7B+-$7\xDB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!/\u015F\"\"1&3\u0160*; \"/\u0161\"\"1'3\u0162*/ \"/\u0163\"\"1*3\u0164*# \"76+& 4!6\u0165! %"),
	          peg$decode("!/\u0166\"\"1&3\u0167+<$7<+2%7\xDC+(%4#6\u0168#! %$## X$\"# X\"# X*\x83 \"!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\u0169#! %$## X$\"# X\"# X*S \"!/\u016A\"\"1+3\u016B+<$7<+2%7\x9D+(%4#6\u016C#! %$## X$\"# X\"# X*# \"7\x9F"),
	          peg$decode("/\u016D\"\"1+3\u016E*k \"/\u016F\"\"1)3\u0170*_ \"/\u0171\"\"1(3\u0172*S \"/\u0173\"\"1'3\u0174*G \"/\u0175\"\"1&3\u0176*; \"/\u0177\"\"1*3\u0178*/ \"/\u0179\"\"1)3\u017A*# \"76"),
	          peg$decode("71*# \" ["),
	          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u017B!! %"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xE0+#%'\"%$\"# X\"# X,8&!7B+-$7\xE0+#%'\"%$\"# X\"# X\"+'%4\"6\u017C\" %$\"# X\"# X"),
	          peg$decode("7\xB8*# \"7\x9F"),
	          peg$decode("!7\xE2+_$ \\!7A+-$7\xE2+#%'\"%$\"# X\"# X,8&!7A+-$7\xE2+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\xE9+s$7.+i%7\xEC+_% \\!7B+-$7\xE3+#%'\"%$\"# X\"# X,8&!7B+-$7\xE3+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xE4*; \"7\xE5*5 \"7\xE6*/ \"7\xE7*) \"7\xE8*# \"7\x9F"),
	          peg$decode("!/\u017D\"\"1#3\u017E+<$7<+2%7\xEF+(%4#6\u017F#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0180\"\"1%3\u0181+<$7<+2%7T+(%4#6\u0182#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0183\"\"1(3\u0184+B$7<+8%7\\*# \"7Y+(%4#6\u0185#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0186\"\"1&3\u0187+<$7<+2%76+(%4#6\u0188#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0189\"\"1%3\u018A+T$!7<+5$ \\7!,#&7!\"+#%'\"%$\"# X\"# X*# \" [+'%4\"6\u018B\" %$\"# X\"# X"),
	          peg$decode("!7\xEA+K$7;+A%76+7%7;+-%7\xEB+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\x95\"\"1#3\xD6*# \"76+' 4!6\u018C!! %"),
	          peg$decode("!/\xB4\"\"1#3\u018D*G \"/\xB6\"\"1#3\u018E*; \"/\xBA\"\"1#3\u018F*/ \"/\xB8\"\"1$3\u0190*# \"76+' 4!6\u0191!! %"),
	          peg$decode("!7\xED+H$!7C+-$7\xEE+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\u0192! %"),
	          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\u0193!! %"),
	          peg$decode("!!7!+C$7!*# \" [+3%7!*# \" [+#%'#%$## X$\"# X\"# X+' 4!6\u0194!! %"),
	          peg$decode("7\xBD"),
	          peg$decode("!7\x9D+d$ \\!7B+-$7\xF2+#%'\"%$\"# X\"# X,8&!7B+-$7\xF2+#%'\"%$\"# X\"# X\"+(%4\"6\u0195\"!!%$\"# X\"# X"),
	          peg$decode("7\xF3*# \"7\x9F"),
	          peg$decode("!.\u0196\"\"2\u01963\u0197+N$7<+D%.\u0198\"\"2\u01983\u0199*) \".\u019A\"\"2\u019A3\u019B+(%4#6\u019C#! %$## X$\"# X\"# X"),
	          peg$decode("!7\x9D+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u019D\"!!%$\"# X\"# X"),
	          peg$decode("!76+7$70+-%7\xF6+#%'#%$## X$\"# X\"# X"),
	          peg$decode(" \\72*) \"74*# \"7.,/&72*) \"74*# \"7.\""),
	          peg$decode(" \\7%,#&7%\""),
	          peg$decode("!7\xF9+=$.8\"\"2839+-%7\xFA+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!/\u019E\"\"1%3\u019F*) \"/\u01A0\"\"1$3\u01A1+' 4!6\u01A2!! %"),
	          peg$decode("!7\xFB+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\\*) \"7X*# \"7\x82+' 4!6\u01A3!! %"),
	          peg$decode("! \\7\xFD*) \"7-*# \"7\xFE,/&7\xFD*) \"7-*# \"7\xFE\"+! (%"),
	          peg$decode("7\"*S \"7!*M \".F\"\"2F3G*A \".J\"\"2J3K*5 \".H\"\"2H3I*) \".N\"\"2N3O"),
	          peg$decode(".L\"\"2L3M*\x95 \".B\"\"2B3C*\x89 \".<\"\"2<3=*} \".R\"\"2R3S*q \".T\"\"2T3U*e \".V\"\"2V3W*Y \".P\"\"2P3Q*M \".@\"\"2@3A*A \".D\"\"2D3E*5 \".2\"\"2233*) \".>\"\"2>3?"),
	          peg$decode("!7\u0100+h$.8\"\"2839+X%7\xFA+N%!.\u01A4\"\"2\u01A43\u01A5+-$7\xEB+#%'\"%$\"# X\"# X*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\u01A6\"\"1%3\u01A7*) \"/\u01A8\"\"1$3\u01A9+' 4!6\u01A2!! %"),
	          peg$decode("!7\xEB+Q$/\xB4\"\"1#3\xB5*7 \"/\xB6\"\"1#3\xB7*+ \" \\7+,#&7+\"+'%4\"6\u01AA\" %$\"# X\"# X"),
	          peg$decode("!7\u0104+\x8F$.F\"\"2F3G+%7\u0103+u%.F\"\"2F3G+e%7\u0103+[%.F\"\"2F3G+K%7\u0103+A%.F\"\"2F3G+1%7\u0105+'%4)6\u01AB) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!7\u0103+-$7\u0103+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\u0103+7$7\u0103+-%7\u0103+#%'#%$## X$\"# X\"# X")
	        ],
	
	        peg$currPos          = 0,
	        peg$reportedPos      = 0,
	        peg$cachedPos        = 0,
	        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,
	
	        peg$result;
	
	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleIndices)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }
	
	      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
	    }
	
	    function text() {
	      return input.substring(peg$reportedPos, peg$currPos);
	    }
	
	    function offset() {
	      return peg$reportedPos;
	    }
	
	    function line() {
	      return peg$computePosDetails(peg$reportedPos).line;
	    }
	
	    function column() {
	      return peg$computePosDetails(peg$reportedPos).column;
	    }
	
	    function expected(description) {
	      throw peg$buildException(
	        null,
	        [{ type: "other", description: description }],
	        peg$reportedPos
	      );
	    }
	
	    function error(message) {
	      throw peg$buildException(message, null, peg$reportedPos);
	    }
	
	    function peg$computePosDetails(pos) {
	      function advance(details, startPos, endPos) {
	        var p, ch;
	
	        for (p = startPos; p < endPos; p++) {
	          ch = input.charAt(p);
	          if (ch === "\n") {
	            if (!details.seenCR) { details.line++; }
	            details.column = 1;
	            details.seenCR = false;
	          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	            details.line++;
	            details.column = 1;
	            details.seenCR = true;
	          } else {
	            details.column++;
	            details.seenCR = false;
	          }
	        }
	      }
	
	      if (peg$cachedPos !== pos) {
	        if (peg$cachedPos > pos) {
	          peg$cachedPos = 0;
	          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
	        }
	        advance(peg$cachedPosDetails, peg$cachedPos, pos);
	        peg$cachedPos = pos;
	      }
	
	      return peg$cachedPosDetails;
	    }
	
	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }
	
	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }
	
	      peg$maxFailExpected.push(expected);
	    }
	
	    function peg$buildException(message, expected, pos) {
	      function cleanupExpected(expected) {
	        var i = 1;
	
	        expected.sort(function(a, b) {
	          if (a.description < b.description) {
	            return -1;
	          } else if (a.description > b.description) {
	            return 1;
	          } else {
	            return 0;
	          }
	        });
	
	        while (i < expected.length) {
	          if (expected[i - 1] === expected[i]) {
	            expected.splice(i, 1);
	          } else {
	            i++;
	          }
	        }
	      }
	
	      function buildMessage(expected, found) {
	        function stringEscape(s) {
	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
	
	          return s
	            .replace(/\\/g,   '\\\\')
	            .replace(/"/g,    '\\"')
	            .replace(/\x08/g, '\\b')
	            .replace(/\t/g,   '\\t')
	            .replace(/\n/g,   '\\n')
	            .replace(/\f/g,   '\\f')
	            .replace(/\r/g,   '\\r')
	            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
	            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
	            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
	            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
	        }
	
	        var expectedDescs = new Array(expected.length),
	            expectedDesc, foundDesc, i;
	
	        for (i = 0; i < expected.length; i++) {
	          expectedDescs[i] = expected[i].description;
	        }
	
	        expectedDesc = expected.length > 1
	          ? expectedDescs.slice(0, -1).join(", ")
	              + " or "
	              + expectedDescs[expected.length - 1]
	          : expectedDescs[0];
	
	        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	
	        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	      }
	
	      var posDetails = peg$computePosDetails(pos),
	          found      = pos < input.length ? input.charAt(pos) : null;
	
	      if (expected !== null) {
	        cleanupExpected(expected);
	      }
	
	      return new SyntaxError(
	        message !== null ? message : buildMessage(expected, found),
	        expected,
	        found,
	        pos,
	        posDetails.line,
	        posDetails.column
	      );
	    }
	
	    function peg$decode(s) {
	      var bc = new Array(s.length), i;
	
	      for (i = 0; i < s.length; i++) {
	        bc[i] = s.charCodeAt(i) - 32;
	      }
	
	      return bc;
	    }
	
	    function peg$parseRule(index) {
	      var bc    = peg$bytecode[index],
	          ip    = 0,
	          ips   = [],
	          end   = bc.length,
	          ends  = [],
	          stack = [],
	          params, i;
	
	      function protect(object) {
	        return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;
	      }
	
	      while (true) {
	        while (ip < end) {
	          switch (bc[ip]) {
	            case 0:
	              stack.push(protect(peg$consts[bc[ip + 1]]));
	              ip += 2;
	              break;
	
	            case 1:
	              stack.push(peg$currPos);
	              ip++;
	              break;
	
	            case 2:
	              stack.pop();
	              ip++;
	              break;
	
	            case 3:
	              peg$currPos = stack.pop();
	              ip++;
	              break;
	
	            case 4:
	              stack.length -= bc[ip + 1];
	              ip += 2;
	              break;
	
	            case 5:
	              stack.splice(-2, 1);
	              ip++;
	              break;
	
	            case 6:
	              stack[stack.length - 2].push(stack.pop());
	              ip++;
	              break;
	
	            case 7:
	              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
	              ip += 2;
	              break;
	
	            case 8:
	              stack.pop();
	              stack.push(input.substring(stack[stack.length - 1], peg$currPos));
	              ip++;
	              break;
	
	            case 9:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1]) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 10:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1] === peg$FAILED) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 11:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1] !== peg$FAILED) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 12:
	              if (stack[stack.length - 1] !== peg$FAILED) {
	                ends.push(end);
	                ips.push(ip);
	
	                end = ip + 2 + bc[ip + 1];
	                ip += 2;
	              } else {
	                ip += 2 + bc[ip + 1];
	              }
	
	              break;
	
	            case 13:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (input.length > peg$currPos) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 14:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 15:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 16:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 17:
	              stack.push(input.substr(peg$currPos, bc[ip + 1]));
	              peg$currPos += bc[ip + 1];
	              ip += 2;
	              break;
	
	            case 18:
	              stack.push(peg$consts[bc[ip + 1]]);
	              peg$currPos += peg$consts[bc[ip + 1]].length;
	              ip += 2;
	              break;
	
	            case 19:
	              stack.push(peg$FAILED);
	              if (peg$silentFails === 0) {
	                peg$fail(peg$consts[bc[ip + 1]]);
	              }
	              ip += 2;
	              break;
	
	            case 20:
	              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];
	              ip += 2;
	              break;
	
	            case 21:
	              peg$reportedPos = peg$currPos;
	              ip++;
	              break;
	
	            case 22:
	              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
	              for (i = 0; i < bc[ip + 3]; i++) {
	                params[i] = stack[stack.length - 1 - params[i]];
	              }
	
	              stack.splice(
	                stack.length - bc[ip + 2],
	                bc[ip + 2],
	                peg$consts[bc[ip + 1]].apply(null, params)
	              );
	
	              ip += 4 + bc[ip + 3];
	              break;
	
	            case 23:
	              stack.push(peg$parseRule(bc[ip + 1]));
	              ip += 2;
	              break;
	
	            case 24:
	              peg$silentFails++;
	              ip++;
	              break;
	
	            case 25:
	              peg$silentFails--;
	              ip++;
	              break;
	
	            default:
	              throw new Error("Invalid opcode: " + bc[ip] + ".");
	          }
	        }
	
	        if (ends.length > 0) {
	          end = ends.pop();
	          ip = ips.pop();
	        } else {
	          break;
	        }
	      }
	
	      return stack[0];
	    }
	
	
	      options.data = {}; // Object to which header attributes will be assigned during parsing
	
	      function list (first, rest) {
	        return [first].concat(rest);
	      }
	
	
	    peg$result = peg$parseRule(peg$startRuleIndex);
	
	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail({ type: "end", description: "end of input" });
	      }
	
	      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
	    }
	  }
	
	  return {
	    SyntaxError: SyntaxError,
	    parse:       parse
	  };
	})();


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var toplevel = global.window || global;
	
	function getPrefixedProperty (object, name) {
	  if (object == null) {
	    return;
	  }
	  var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
	  var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];
	  for (var i in prefixedNames) {
	    var property = object[prefixedNames[i]];
	    if (property) {
	      return property.bind(object);
	    }
	  }
	}
	
	module.exports = {
	  WebSocket: toplevel.WebSocket,
	  Transport: __webpack_require__(246),
	  open: toplevel.open,
	  Promise: toplevel.Promise,
	  timers: toplevel,
	
	  // Console is not defined in ECMAScript, so just in case...
	  console: toplevel.console || {
	    debug: function () {},
	    log: function () {},
	    warn: function () {},
	    error: function () {}
	  },
	
	  MediaStream: getPrefixedProperty(toplevel, 'MediaStream'),
	  getUserMedia: getPrefixedProperty(toplevel.navigator, 'getUserMedia'),
	  RTCPeerConnection: getPrefixedProperty(toplevel, 'RTCPeerConnection'),
	  RTCSessionDescription: getPrefixedProperty(toplevel, 'RTCSessionDescription'),
	
	  addEventListener: getPrefixedProperty(toplevel, 'addEventListener'),
	  HTMLMediaElement: toplevel.HTMLMediaElement,
	
	  attachMediaStream: toplevel.attachMediaStream,
	  createObjectURL: toplevel.URL && toplevel.URL.createObjectURL,
	  revokeObjectURL: toplevel.URL && toplevel.URL.revokeObjectURL
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 246 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Transport
	 */
	
	/**
	 * @augments SIP
	 * @class Transport
	 * @param {SIP.UA} ua
	 * @param {Object} server ws_server Object
	 */
	module.exports = function (SIP, WebSocket) {
	var Transport,
	  C = {
	    // Transport status codes
	    STATUS_READY:        0,
	    STATUS_DISCONNECTED: 1,
	    STATUS_ERROR:        2
	  };
	
	/**
	 * Compute an amount of time in seconds to wait before sending another
	 * keep-alive.
	 * @returns {Number}
	 */
	function computeKeepAliveTimeout(upperBound) {
	  var lowerBound = upperBound * 0.8;
	  return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);
	}
	
	Transport = function(ua, server) {
	
	  this.logger = ua.getLogger('sip.transport');
	  this.ua = ua;
	  this.ws = null;
	  this.server = server;
	  this.reconnection_attempts = 0;
	  this.closed = false;
	  this.connected = false;
	  this.reconnectTimer = null;
	  this.lastTransportError = {};
	
	  this.keepAliveInterval = ua.configuration.keepAliveInterval;
	  this.keepAliveTimeout = null;
	  this.keepAliveTimer = null;
	
	  this.ua.transport = this;
	
	  // Connect
	  this.connect();
	};
	
	Transport.prototype = {
	  /**
	   * Send a message.
	   * @param {SIP.OutgoingRequest|String} msg
	   * @returns {Boolean}
	   */
	  send: function(msg) {
	    var message = msg.toString();
	
	    if(this.ws && this.ws.readyState === WebSocket.OPEN) {
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('sending WebSocket message:\n\n' + message + '\n');
	      }
	      this.ws.send(message);
	      return true;
	    } else {
	      this.logger.warn('unable to send message, WebSocket is not open');
	      return false;
	    }
	  },
	
	  /**
	   * Send a keep-alive (a double-CRLF sequence).
	   * @private
	   * @returns {Boolean}
	   */
	  sendKeepAlive: function() {
	    if(this.keepAliveTimeout) { return; }
	
	    this.keepAliveTimeout = SIP.Timers.setTimeout(function() {
	      this.ua.emit('keepAliveTimeout');
	    }.bind(this), 10000);
	
	    return this.send('\r\n\r\n');
	  },
	
	  /**
	   * Start sending keep-alives.
	   * @private
	   */
	  startSendingKeepAlives: function() {
	    if (this.keepAliveInterval && !this.keepAliveTimer) {
	      this.keepAliveTimer = SIP.Timers.setTimeout(function() {
	        this.sendKeepAlive();
	        this.keepAliveTimer = null;
	        this.startSendingKeepAlives();
	      }.bind(this), computeKeepAliveTimeout(this.keepAliveInterval));
	    }
	  },
	
	  /**
	   * Stop sending keep-alives.
	   * @private
	   */
	  stopSendingKeepAlives: function() {
	    SIP.Timers.clearTimeout(this.keepAliveTimer);
	    SIP.Timers.clearTimeout(this.keepAliveTimeout);
	    this.keepAliveTimer = null;
	    this.keepAliveTimeout = null;
	  },
	
	  /**
	  * Disconnect socket.
	  */
	  disconnect: function() {
	    if(this.ws) {
	      // Clear reconnectTimer
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	
	      this.stopSendingKeepAlives();
	
	      this.closed = true;
	      this.logger.log('closing WebSocket ' + this.server.ws_uri);
	      this.ws.close();
	    }
	
	    if (this.reconnectTimer !== null) {
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	      this.reconnectTimer = null;
	      this.ua.emit('disconnected', {
	        transport: this,
	        code: this.lastTransportError.code,
	        reason: this.lastTransportError.reason
	      });
	    }
	  },
	
	  /**
	  * Connect socket.
	  */
	  connect: function() {
	    var transport = this;
	
	    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
	      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');
	      return false;
	    }
	
	    if(this.ws) {
	      this.ws.close();
	    }
	
	    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);
	    this.ua.onTransportConnecting(this,
	      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);
	
	    try {
	      this.ws = new WebSocket(this.server.ws_uri, 'sip');
	    } catch(e) {
	      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);
	    }
	
	    this.ws.binaryType = 'arraybuffer';
	
	    this.ws.onopen = function() {
	      transport.onOpen();
	    };
	
	    this.ws.onclose = function(e) {
	      transport.onClose(e);
	    };
	
	    this.ws.onmessage = function(e) {
	      transport.onMessage(e);
	    };
	
	    this.ws.onerror = function(e) {
	      transport.onError(e);
	    };
	  },
	
	  // Transport Event Handlers
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onOpen: function() {
	    this.connected = true;
	
	    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');
	    // Clear reconnectTimer since we are not disconnected
	    if (this.reconnectTimer !== null) {
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	      this.reconnectTimer = null;
	    }
	    // Reset reconnection_attempts
	    this.reconnection_attempts = 0;
	    // Disable closed
	    this.closed = false;
	    // Trigger onTransportConnected callback
	    this.ua.onTransportConnected(this);
	    // Start sending keep-alives
	    this.startSendingKeepAlives();
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onClose: function(e) {
	    var connected_before = this.connected;
	
	    this.lastTransportError.code = e.code;
	    this.lastTransportError.reason = e.reason;
	
	    this.stopSendingKeepAlives();
	
	    if (this.reconnection_attempts > 0) {
	      this.logger.log('Reconnection attempt ' + this.reconnection_attempts + ' failed (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
	      this.reconnect();
	    } else {
	      this.connected = false;
	      this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
	
	      if(e.wasClean === false) {
	        this.logger.warn('WebSocket abrupt disconnection');
	      }
	      // Transport was connected
	      if(connected_before === true) {
	        this.ua.onTransportClosed(this);
	        // Check whether the user requested to close.
	        if(!this.closed) {
	          this.reconnect();
	        } else {
	          this.ua.emit('disconnected', {
	            transport: this,
	            code: this.lastTransportError.code,
	            reason: this.lastTransportError.reason
	          });
	
	        }
	      } else {
	        // This is the first connection attempt
	        //Network error
	        this.ua.onTransportError(this);
	      }
	    }
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onMessage: function(e) {
	    var message, transaction,
	      data = e.data;
	
	    // CRLF Keep Alive response from server. Ignore it.
	    if(data === '\r\n') {
	      SIP.Timers.clearTimeout(this.keepAliveTimeout);
	      this.keepAliveTimeout = null;
	
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket message with CRLF Keep Alive response');
	      }
	
	      return;
	    }
	
	    // WebSocket binary message.
	    else if (typeof data !== 'string') {
	      try {
	        data = String.fromCharCode.apply(null, new Uint8Array(data));
	      } catch(evt) {
	        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');
	        return;
	      }
	
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket binary message:\n\n' + data + '\n');
	      }
	    }
	
	    // WebSocket text message.
	    else {
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket text message:\n\n' + data + '\n');
	      }
	    }
	
	    message = SIP.Parser.parseMessage(data, this.ua);
	
	    if (!message) {
	      return;
	    }
	
	    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {
	      return;
	    }
	
	    // Do some sanity check
	    if(SIP.sanityCheck(message, this.ua, this)) {
	      if(message instanceof SIP.IncomingRequest) {
	        message.transport = this;
	        this.ua.receiveRequest(message);
	      } else if(message instanceof SIP.IncomingResponse) {
	        /* Unike stated in 18.1.2, if a response does not match
	        * any transaction, it is discarded here and no passed to the core
	        * in order to be discarded there.
	        */
	        switch(message.method) {
	          case SIP.C.INVITE:
	            transaction = this.ua.transactions.ict[message.via_branch];
	            if(transaction) {
	              transaction.receiveResponse(message);
	            }
	            break;
	          case SIP.C.ACK:
	            // Just in case ;-)
	            break;
	          default:
	            transaction = this.ua.transactions.nict[message.via_branch];
	            if(transaction) {
	              transaction.receiveResponse(message);
	            }
	            break;
	        }
	      }
	    }
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onError: function(e) {
	    this.logger.warn('WebSocket connection error: ' + JSON.stringify(e));
	  },
	
	  /**
	  * Reconnection attempt logic.
	  * @private
	  */
	  reconnect: function() {
	    var transport = this;
	
	    this.reconnection_attempts += 1;
	
	    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {
	      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);
	      this.ua.onTransportError(this);
	    } else if (this.reconnection_attempts === 1) {
	      this.logger.log('Connection to WebSocket ' + this.server.ws_uri + ' severed, attempting first reconnect');
	      transport.connect();
	    } else {
	      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');
	
	      this.reconnectTimer = SIP.Timers.setTimeout(function() {
	        transport.connect();
	        transport.reconnectTimer = null;
	      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);
	    }
	  }
	};
	
	Transport.C = C;
	return Transport;
	};


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBlMjUzYTNjYThlZWE0NDAyMGViNCIsIndlYnBhY2s6Ly8vLi9zcmMvcmMtcGhvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2FkZC1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yaW5nY2VudHJhbC9idWlsZC9yaW5nY2VudHJhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwid2VicGFjazovLy8uL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vL3ZlcnR4IChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpbmdjZW50cmFsL34vd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwid2VicGFjazovLy8uL34vcHVibnViL21vZGVybi9kaXN0L3B1Ym51Yi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpbmdjZW50cmFsLWNsaWVudC9idWlsZC9yaW5nY2VudHJhbC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yYy1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9zeW1ib2wtbWFwLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvZW51bS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlZHV4LWhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2V2ZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qva2V5cy9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc2V0dGluZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0hvc3RPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvYnJhbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvYnJhbmQvYnJhbmQtYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9icmFuZC9icmFuZC1yZWR1Y2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2F1dGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2xvZ2luLXN0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3N1YnNjcmlwdGlvbi9zdWJzY3JpcHRpb24tYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1zdGF0dXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvdXNlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLWFjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1hY3Rpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL3dlYnBob25lLXN0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS9jYWxsLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL2NhbGwtc3RhdHVzLmpzIiwid2VicGFjazovLy8uL34vcmluZ2NlbnRyYWwtd2ViLXBob25lL3NyYy9yaW5nY2VudHJhbC13ZWItcGhvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9TSVAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvcGFja2FnZS5qc29uIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvTG9nZ2VyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvQ29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9FeGNlcHRpb25zLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9UaW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU0lQTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVVJJLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9OYW1lQWRkckhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVHJhbnNhY3Rpb25zLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9EaWFsb2dzLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9EaWFsb2cvUmVxdWVzdFNlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvUmVxdWVzdFNlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvUmVnaXN0ZXJDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9NZWRpYUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL0NsaWVudENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1NlcnZlckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1Nlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1Nlc3Npb24vRFRNRi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9XZWJSVEMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYVN0cmVhbU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1VBLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9IYWNrcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU2FuaXR5Q2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL0RpZ2VzdEF1dGhlbnRpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9HcmFtbWFyLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9HcmFtbWFyL2Rpc3QvR3JhbW1hci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvZW52aXJvbm1lbnRfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVHJhbnNwb3J0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLEtBQU0sVUFBVSx1QkFBaEI7O0FBRUEsVUFBUywyQkFBVCxHQUF1QztBQUNyQyxPQUFNLFdBQVcsbUJBQWpCO0FBQ0EsVUFBTyxDQUNMLFVBQUMsRUFBRDtBQUFBLFlBQVEsU0FBUyxHQUFULENBQWEsRUFBYixDQUFSO0FBQUEsSUFESyxFQUVMLFVBQUMsS0FBRDtBQUFBLFlBQVcsU0FBUyxPQUFULENBQWlCO0FBQUEsY0FBTSxHQUFHLEtBQUgsQ0FBTjtBQUFBLE1BQWpCLENBQVg7QUFBQSxJQUZLLENBQVA7QUFJRDs7S0FFb0IsTzs7O0FBQ25CLDBCQU9HO0FBQUEsU0FORCxvQkFNQyxRQU5ELG9CQU1DO0FBQUEsU0FMRCxRQUtDLFFBTEQsUUFLQztBQUFBLFNBSkQsWUFJQyxRQUpELFdBSUM7QUFBQSw0QkFIRCxNQUdDO0FBQUEsU0FIRCxNQUdDLCtCQUhRLElBR1I7QUFBQSxTQUZELFdBRUMsUUFGRCxXQUVD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FB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QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNILHFCQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsVUFBVTs7Ozs7OztBQ3RIdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDLDZCQUFxRDs7Ozs7OztBQzNIdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsU0FBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7O0FDbkZBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOzs7Ozs7OytDQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMEc7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLHNCQUFzQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7QUFDVCx3QkFBdUIsUUFBUTtBQUMvQjs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUVBQWtFLFFBQVE7O0FBRTFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBa0UsUUFBUTtBQUMxRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFFBQVE7O0FBRTdDOztBQUVBLHNCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBLGVBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBLHdDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUErQiwwQkFBMEIsZUFBZTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsT0FBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVE7QUFDUixPQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQSxPQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLG1FQUFtRTtBQUNwRztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsT0FBTTs7QUFFTjtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsbUVBQW1FO0FBQ3BHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLFNBQVE7QUFDUjtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWOztBQUVBLFNBQVE7QUFDUixPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTJFLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsVUFBVSxlQUFlLGNBQWM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDhGQUE4RjtBQUMvRjs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE2RSxVQUFVLFlBQVksWUFBWTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZLFdBQVcsYUFBYTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLG9GQUFtRixRQUFRO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBc0YsV0FBVztBQUNqRztBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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TUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBMkUsVUFBVSxZQUFZLFlBQVk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWSxVQUFVLFVBQVU7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE2RSxVQUFVLFlBQVksWUFBWSxVQUFVLFVBQVU7QUFDbkk7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsK0VBQStFO0FBQzVGLGNBQWEsOEVBQThFO0FBQzNGLGNBQWEsZ0ZBQWdGO0FBQzdGLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsbUdBQW1HO0FBQ2hILGNBQWEsaUdBQWlHO0FBQzlHLGNBQWE7QUFDYjtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEwRCxrQkFBa0I7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUM1U0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUMxRUE7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRixtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEc7Ozs7OztBQzVIQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0EseURBQXdELEVBQUU7QUFDMUQsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWEsVUFBVTtBQUN2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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM5ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLHVCQUFzQix1QkFBdUIsRUFBRTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLHdCQUF1QixhQUFhLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSx3QkFBdUIsaUJBQWlCLEVBQUU7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDakhBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNILHFCQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOzs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDcFFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLGtCQUFrQjtBQUM1QixXQUFVLG9CQUFvQjtBQUM5QixXQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGtCQUFrQjtBQUM3QixZQUFXLG9CQUFvQjtBQUMvQixZQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsb0JBQW9CO0FBQzlCLFdBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLG9CQUFvQjtBQUM5QixXQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQixFQUFFO0FBQ3BCO0FBQ0E7O0FBRUEsbUJBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3RHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDekZBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsb0NBQW9DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtCQUE4QixvREFBb0Q7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1Asc0NBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsRUFBRTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsUUFBTzs7QUFFUDs7QUFFQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBLFlBQVc7QUFDWDtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLG9EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkM7QUFDM0M7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2x0RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsWUFBWTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0IsRUFBRTtBQUNwQjtBQUNBOztBQUVBLG1CQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xMQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsdUVBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSyxtQkFBbUIsRUFBRTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLDZDQUE2QztBQUNsRCxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQXlCLGlCQUFpQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFH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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYztBQUNkLDRDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFxRSxTQUFTO0FBQzlFO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0EsS0FBSTs7QUFFSixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7Ozs7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxvQ0FBb0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWixhQUFZO0FBQ1osWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZCxlQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVB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QUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsY0FBYztBQUM3QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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Szs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsNEJBQTRCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOWpEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsaUJBQWlCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLG9CQUFvQjtBQUMvQixZQUFXLE9BQU87QUFDbEIsWUFBVyxjQUFjO0FBQ3pCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ25PQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsb0JBQW9CO0FBQzlCLFdBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSx5QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLG1CQUFrQiwyQ0FBMkM7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7OztBQ3IwQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekIsd0JBQXVCO0FBQ3ZCLHlCQUF3QjtBQUN4QjtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSwyQkFBMkI7QUFDeEMsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0EsZ0NBQStCLFFBQVE7O0FBRXZDO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiJyaW5nY2VudHJhbC1qcy1pbnRlZ3JhdGlvbi1jb21tb25zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUmNQaG9uZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJSY1Bob25lXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uXG4gKiovIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCBlMjUzYTNjYThlZWE0NDAyMGViNFxuICoqLyIsImltcG9ydCBhZGRNb2R1bGUgZnJvbSAnLi9saWIvYWRkLW1vZHVsZSc7XG5pbXBvcnQgUmluZ0NlbnRyYWwgZnJvbSAncmluZ2NlbnRyYWwnO1xuaW1wb3J0IFJpbmdDZW50cmFsQ2xpZW50IGZyb20gJ3JpbmdjZW50cmFsLWNsaWVudCc7XG5cbmltcG9ydCBSY01vZHVsZSBmcm9tICcuL2xpYi9yYy1tb2R1bGUnO1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi9tb2R1bGVzL3NldHRpbmdzJztcbmltcG9ydCBCcmFuZCBmcm9tICcuL21vZHVsZXMvYnJhbmQnO1xuaW1wb3J0IEF1dGggZnJvbSAnLi9tb2R1bGVzL2F1dGgnO1xuaW1wb3J0IFN1YnNjcmlwdGlvbiBmcm9tICcuL21vZHVsZXMvc3Vic2NyaXB0aW9uJztcbmltcG9ydCBVc2VyIGZyb20gJy4vbW9kdWxlcy91c2VyJztcbmltcG9ydCBXZWJwaG9uZSBmcm9tICcuL21vZHVsZXMvd2VicGhvbmUnO1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzLCBjcmVhdGVTdG9yZSB9IGZyb20gJ3JlZHV4JztcblxuY29uc3QgUkVEVUNFUiA9IFN5bWJvbCgpO1xuXG5mdW5jdGlvbiBnZXRTdG9yZVJlZ2lzdGVyQW5kUmVzb2x2ZXIoKSB7XG4gIGNvbnN0IGhhbmRsZXJzID0gbmV3IFNldCgpO1xuICByZXR1cm4gW1xuICAgIChmbikgPT4gaGFuZGxlcnMuYWRkKGZuKSxcbiAgICAoc3RvcmUpID0+IGhhbmRsZXJzLmZvckVhY2goZm4gPT4gZm4oc3RvcmUpKSxcbiAgXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmNQaG9uZSBleHRlbmRzIFJjTW9kdWxlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyLFxuICAgIGdldFN0b3JlLFxuICAgIHN0YXRlTWFwcGVyLFxuICAgIHByZWZpeCA9ICdyYycsXG4gICAgc2RrU2V0dGluZ3MsXG4gICAgZGVmYXVsdEJyYW5kLFxuICB9KSB7XG4gICAgbGV0IHJlZ2lzdGVyID0gcmVnaXN0ZXJTdG9yZUhhbmRsZXI7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgaWYgKCFyZWdpc3Rlcikge1xuICAgICAgW3JlZ2lzdGVyLCByZXNvbHZlXSA9IGdldFN0b3JlUmVnaXN0ZXJBbmRSZXNvbHZlcigpO1xuICAgIH1cblxuICAgIHN1cGVyKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyLFxuICAgIH0pO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCdzZGsnLCBuZXcgUmluZ0NlbnRyYWwoe1xuXG4gICAgICBjYWNoZVByZWZpeDogYCR7cHJlZml4fS1gLFxuICAgICAgLi4uc2RrU2V0dGluZ3MsXG4gICAgfSkpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCdwbGF0Zm9ybScsIHRoaXMuc2RrLnBsYXRmb3JtKCkpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCdhcGknLCBuZXcgUmluZ0NlbnRyYWxDbGllbnQodGhpcy5zZGspKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgnYXV0aCcsIG5ldyBBdXRoKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyOiBzdGF0ZSA9PiBzdGF0ZU1hcHBlcihzdGF0ZSkuYXV0aCxcbiAgICAgIHByZWZpeCxcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgIH0pKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgnc2V0dGluZ3MnLCBuZXcgU2V0dGluZ3Moe1xuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IHJlZ2lzdGVyLFxuICAgICAgc3RhdGVNYXBwZXI6IHN0YXRlID0+IHN0YXRlTWFwcGVyKHN0YXRlKS5zZXR0aW5ncyxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ2RlZmF1bHRCcmFuZCcsIG5ldyBCcmFuZCh7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBwcmVmaXg6IGAke3ByZWZpeH0tZGVmYXVsdGAsXG4gICAgICBzdGF0ZU1hcHBlcjogc3RhdGUgPT4gc3RhdGVNYXBwZXIoc3RhdGUpLmRlZmF1bHRCcmFuZCxcbiAgICAgIC4uLmRlZmF1bHRCcmFuZCxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3N1YnNjcmlwdGlvbicsIG5ldyBTdWJzY3JpcHRpb24oe1xuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IHJlZ2lzdGVyLFxuICAgICAgc3RhdGVNYXBwZXI6IHN0YXRlID0+IHN0YXRlTWFwcGVyKHN0YXRlKS5zdWJzY3JpcHRpb24sXG4gICAgICBwcmVmaXgsXG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICBzZGs6IHRoaXMuc2RrLFxuICAgICAgYXV0aDogdGhpcy5hdXRoLFxuICAgIH0pKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgndXNlcicsIG5ldyBVc2VyKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyOiBzdGF0ZSA9PiBzdGF0ZU1hcHBlcihzdGF0ZSkudXNlcixcbiAgICAgIHByZWZpeCxcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuICAgIH0pKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgnd2VicGhvbmUnLCBuZXcgV2VicGhvbmUoe1xuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IHJlZ2lzdGVyLFxuICAgICAgc3RhdGVNYXBwZXI6IChzdGF0ZSkgPT4gc3RhdGVNYXBwZXIoc3RhdGUpLndlYnBob25lLFxuICAgICAgcHJlZml4LFxuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgfSkpO1xuXG4gICAgLy8gY29tYmluZSByZWR1Y2Vyc1xuICAgIHRoaXNbUkVEVUNFUl0gPSBjb21iaW5lUmVkdWNlcnMoe1xuICAgICAgYXV0aDogdGhpcy5hdXRoLnJlZHVjZXIsXG4gICAgICBkZWZhdWx0QnJhbmQ6IHRoaXMuZGVmYXVsdEJyYW5kLnJlZHVjZXIsXG4gICAgICBzdWJzY3JpcHRpb246IHRoaXMuc3Vic2NyaXB0aW9uLnJlZHVjZXIsXG4gICAgICB1c2VyOiB0aGlzLnVzZXIucmVkdWNlcixcbiAgICAgIHdlYnBob25lOiB0aGlzLndlYnBob25lLnJlZHVjZXIsXG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncy5yZWR1Y2VyLFxuICAgIH0pO1xuXG4gICAgaWYgKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUoZ2V0U3RvcmUodGhpcy5yZWR1Y2VyKSk7XG4gICAgICAvLyByZXNvbHZlKGNyZWF0ZVN0b3JlKHRoaXMucmVkdWNlcikpO1xuICAgIH1cbiAgfVxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gdGhpc1tSRURVQ0VSXTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcmMtcGhvbmUuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvYXNzaWduXCIpO1xuXG52YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfYXNzaWduMi5kZWZhdWx0IHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XHJcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgJGFzc2lnbiAgPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcbiAgICAsIGFMZW4gID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mXG4gICAgLCBpc0VudW0gICAgID0gcElFLmY7XG4gIHdoaWxlKGFMZW4gPiBpbmRleCl7XG4gICAgdmFyIFMgICAgICA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcclxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxyXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XHJcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcclxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXHJcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xyXG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxyXG4gICAgLCBpICAgICAgPSAwXHJcbiAgICAsIHJlc3VsdCA9IFtdXHJcbiAgICAsIGtleTtcclxuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xyXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcclxuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcclxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XHJcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXHJcbm1vZHVsZS5leHBvcnRzID0gKFxyXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXHJcbikuc3BsaXQoJywnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxyXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxyXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcclxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xyXG4gIE8gPSB0b09iamVjdChPKTtcclxuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcclxuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcclxuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcclxuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanNcbiAqKiBtb2R1bGUgaWQgPSA0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXNJdGVyYWJsZTIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9pcy1pdGVyYWJsZVwiKTtcblxudmFyIF9pc0l0ZXJhYmxlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSXRlcmFibGUyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShhcnIpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXNJdGVyYWJsZTMuZGVmYXVsdCkoT2JqZWN0KGFycikpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2lzLWl0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBJdGVyYXRvcnMgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG4gICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXHJcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXHJcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxyXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcclxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXHJcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cclxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XHJcblxyXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXHJcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcclxuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xyXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXHJcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxyXG4gICAgLCBndCAgICAgPSAnPidcclxuICAgICwgaWZyYW1lRG9jdW1lbnQ7XHJcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxyXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XHJcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xyXG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XHJcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xyXG4gIGlmcmFtZURvY3VtZW50LndyaXRlKCc8c2NyaXB0PmRvY3VtZW50LkY9T2JqZWN0PC9zY3JpcHQnICsgZ3QpO1xyXG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XHJcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XHJcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xyXG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xyXG4gIHZhciByZXN1bHQ7XHJcbiAgaWYoTyAhPT0gbnVsbCl7XHJcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XHJcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XHJcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcclxuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcclxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xyXG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XHJcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXHJcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXHJcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XHJcbiAgYW5PYmplY3QoTyk7XHJcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcclxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuICAgICwgaSA9IDBcclxuICAgICwgUDtcclxuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XHJcbiAgcmV0dXJuIE87XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanNcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzXG4gKiogbW9kdWxlIGlkID0gNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgfHwgSXRlcmF0b3JzLmhhc093blByb3BlcnR5KGNsYXNzb2YoTykpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXQgICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qc1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xyXG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxyXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1xuICoqIG1vZHVsZSBpZCA9IDc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG4gICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH1cbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIE1FVEEgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKVxuICAsIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBoYXMgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgc2V0RGVzYyAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaWQgICAgICAgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24oaXQpe1xuICBzZXREZXNjKGl0LCBNRVRBLCB7dmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9fSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKXNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiAgICAgIE1FVEEsXG4gIE5FRUQ6ICAgICBmYWxzZSxcbiAgZmFzdEtleTogIGZhc3RLZXksXG4gIGdldFdlYWs6ICBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcclxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXHJcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxyXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcclxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcclxuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xyXG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanNcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgcmVzdWx0ICAgICA9IGdldEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZihnZXRTeW1ib2xzKXtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG4gICAgICAsIGlzRW51bSAgPSBwSUUuZlxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXHJcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxyXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcclxuXHJcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XHJcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1xuICoqIG1vZHVsZSBpZCA9IDg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgcElFICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcclxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXHJcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxyXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxyXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXHJcbiAgLCBnT1BEICAgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XHJcblxyXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcclxuICBPID0gdG9JT2JqZWN0KE8pO1xyXG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcclxuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xyXG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XHJcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxyXG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzXG4gKiogbW9kdWxlIGlkID0gOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3NldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9jcmVhdGVcIik7XG5cbnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKHN1cGVyQ2xhc3MpKSk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCA/ICgwLCBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qc1xuICoqIG1vZHVsZSBpZCA9IDk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCl7XG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXHJcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zZXRcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMTAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuU2V0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnNldC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgaGlkZSAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGFuSW5zdGFuY2UgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGRlZmluZWQgICAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgZm9yT2YgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKVxuICAsIHN0ZXAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBzZXRTcGVjaWVzICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBmYXN0S2V5ICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5XG4gICwgU0laRSAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uKHRoYXQsIGtleSl7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xuICBpZihpbmRleCAhPT0gJ0YnKXJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvcihlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgIGlmKGVudHJ5LmsgPT0ga2V5KXJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpe1xuICAgICAgICBmb3IodmFyIHRoYXQgPSB0aGlzLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihlbnRyeS5wKWVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgICAsIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYoZW50cnkpe1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkublxuICAgICAgICAgICAgLCBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmKHRoYXQuX2YgPT0gZW50cnkpdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYodGhhdC5fbCA9PSBlbnRyeSl0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgQywgJ2ZvckVhY2gnKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKERFU0NSSVBUT1JTKWRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGRlZmluZWQodGhpc1tTSVpFXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxuICAgICAgLCBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZihlbnRyeSl7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZighdGhhdC5fZil0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZihwcmV2KXByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZihpbmRleCAhPT0gJ0YnKXRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uKEMsIE5BTUUsIElTX01BUCl7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgICAgIHRoaXMuX3QgPSBpdGVyYXRlZDsgIC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAsIGtpbmQgID0gdGhhdC5fa1xuICAgICAgICAsIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSl7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnICwgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzXG4gKiogbW9kdWxlIGlkID0gMTA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMsIHNhZmUpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpe1xuICAgIGlmKHNhZmUgJiYgdGFyZ2V0W2tleV0pdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICBlbHNlIGhpZGUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSl7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1pbnN0YW5jZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAsIEJSRUFLICAgICAgID0ge31cbiAgLCBSRVRVUk4gICAgICA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1Ipe1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbigpeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLICA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2goZSl7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZihyZXQgIT09IHVuZGVmaW5lZClhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDExMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSB0eXBlb2YgY29yZVtLRVldID09ICdmdW5jdGlvbicgPyBjb3JlW0tFWV0gOiBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1zcGVjaWVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBtZXRhICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmVBbGwgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGZvck9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBhbkluc3RhbmNlICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgZWFjaCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspe1xuICB2YXIgQmFzZSAgPSBnbG9iYWxbTkFNRV1cbiAgICAsIEMgICAgID0gQmFzZVxuICAgICwgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnXG4gICAgLCBwcm90byA9IEMgJiYgQy5wcm90b3R5cGVcbiAgICAsIE8gICAgID0ge307XG4gIGlmKCFERVNDUklQVE9SUyB8fCB0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKXtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSwgJ19jJyk7XG4gICAgICB0YXJnZXQuX2MgPSBuZXcgQmFzZTtcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0YXJnZXRbQURERVJdLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIGVhY2goJ2FkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzLHRvSlNPTicuc3BsaXQoJywnKSxmdW5jdGlvbihLRVkpe1xuICAgICAgdmFyIElTX0FEREVSID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcbiAgICAgIGlmKEtFWSBpbiBwcm90byAmJiAhKElTX1dFQUsgJiYgS0VZID09ICdjbGVhcicpKWhpZGUoQy5wcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgQywgS0VZKTtcbiAgICAgICAgaWYoIUlTX0FEREVSICYmIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpKXJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2NbS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoJ3NpemUnIGluIHByb3RvKWRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Muc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiwgTyk7XG5cbiAgaWYoIUlTX1dFQUspY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXNjICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUWVBFLCAkY3JlYXRlKXtcbiAgdmFyIElTX01BUCAgICAgICAgPSBUWVBFID09IDFcbiAgICAsIElTX0ZJTFRFUiAgICAgPSBUWVBFID09IDJcbiAgICAsIElTX1NPTUUgICAgICAgPSBUWVBFID09IDNcbiAgICAsIElTX0VWRVJZICAgICAgPSBUWVBFID09IDRcbiAgICAsIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDZcbiAgICAsIE5PX0hPTEVTICAgICAgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWFxuICAgICwgY3JlYXRlICAgICAgICA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpe1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdCgkdGhpcylcbiAgICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICAgLCBmICAgICAgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IDBcbiAgICAgICwgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZFxuICAgICAgLCB2YWwsIHJlcztcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpe1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYoVFlQRSl7XG4gICAgICAgIGlmKElTX01BUClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2goVFlQRSl7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZihJU19FVkVSWSlyZXR1cm4gZmFsc2U7ICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzXG4gKiogbW9kdWxlIGlkID0gMTEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsLCBsZW5ndGgpe1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXHJcbiAgLCBpc0FycmF5ICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcclxuICAsIFNQRUNJRVMgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwpe1xyXG4gIHZhciBDO1xyXG4gIGlmKGlzQXJyYXkob3JpZ2luYWwpKXtcclxuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcclxuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXHJcbiAgICBpZih0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpQyA9IHVuZGVmaW5lZDtcclxuICAgIGlmKGlzT2JqZWN0KEMpKXtcclxuICAgICAgQyA9IENbU1BFQ0lFU107XHJcbiAgICAgIGlmKEMgPT09IG51bGwpQyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBmcm9tICAgID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpe1xuICAgIGlmKGNsYXNzb2YodGhpcykgIT0gTkFNRSl0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzXG4gKiogbW9kdWxlIGlkID0gMTE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyLCBJVEVSQVRPUil7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkTW9kdWxlKG5hbWUsIG1vZHVsZSkge1xuICBpZiAodGhpczo6T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbW9kdWxlICcke25hbWV9JyBhbHJlYWR5IGV4aXN0cy4uLmApO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgfSk7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvYWRkLW1vZHVsZS5qc1xuICoqLyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImVzNi1wcm9taXNlXCIpLCByZXF1aXJlKFwibm9kZS1mZXRjaFwiKSwgcmVxdWlyZShcInB1Ym51YlwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbLCAsIFwicHVibnViXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlNES1wiXSA9IGZhY3RvcnkocmVxdWlyZShcImVzNi1wcm9taXNlXCIpLCByZXF1aXJlKFwibm9kZS1mZXRjaFwiKSwgcmVxdWlyZShcInB1Ym51YlwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiUmluZ0NlbnRyYWxcIl0gPSByb290W1wiUmluZ0NlbnRyYWxcIl0gfHwge30sIHJvb3RbXCJSaW5nQ2VudHJhbFwiXVtcIlNES1wiXSA9IGZhY3Rvcnkocm9vdFt1bmRlZmluZWRdLCByb290W3VuZGVmaW5lZF0sIHJvb3RbdW5kZWZpbmVkXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzVfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV82X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfN19fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2J1aWxkL1wiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9VdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9VdGlscyk7XG5cbnZhciBfQ2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX0NhY2hlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhY2hlKTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgRXh0ZXJuYWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX0V4dGVybmFscyk7XG5cbnZhciBfZXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9DbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9DbGllbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2xpZW50KTtcblxudmFyIF9BcGlSZXNwb25zZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgX0FwaVJlc3BvbnNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FwaVJlc3BvbnNlKTtcblxudmFyIF9DbGllbnRNb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBfQ2xpZW50TW9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DbGllbnRNb2NrKTtcblxudmFyIF9Nb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbnZhciBfTW9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Nb2NrKTtcblxudmFyIF9SZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX1JlZ2lzdHJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZ2lzdHJ5KTtcblxudmFyIF9QbGF0Zm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG52YXIgX1BsYXRmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BsYXRmb3JtKTtcblxudmFyIF9BdXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfQXV0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BdXRoKTtcblxudmFyIF9QdWJudWJGYWN0b3J5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbnZhciBfUHVibnViRmFjdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QdWJudWJGYWN0b3J5KTtcblxudmFyIF9TdWJzY3JpcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxudmFyIF9TdWJzY3JpcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3Vic2NyaXB0aW9uKTtcblxudmFyIF9DYWNoZWRTdWJzY3JpcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxudmFyIF9DYWNoZWRTdWJzY3JpcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FjaGVkU3Vic2NyaXB0aW9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFNESyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2UgUmluZ0NlbnRyYWxcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlcnZlcl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FjaGVQcmVmaXhdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFwcFNlY3JldF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwS2V5XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcHBOYW1lXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcHBWZXJzaW9uXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wdWJudWJGYWN0b3J5XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbGllbnRdXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTREsob3B0aW9ucykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU0RLKTtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAoIUV4dGVybmFscy5mZXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgRmV0Y2ggaXMgbWlzc2luZywgc2V0IFJpbmdDZW50cmFsLlNESy5jb3JlLkV4dGVybmFscy5mZXRjaCB0byB5b3VyIGZhdm9yaXRlIGFsdGVybmF0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUV4dGVybmFscy5Qcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hdGl2ZSBQcm9taXNlIGlzIG1pc3NpbmcsIHNldCBSaW5nQ2VudHJhbC5TREsuY29yZS5FeHRlcm5hbHMuUHJvbWlzZSB0byB5b3VyIGZhdm9yaXRlIGFsdGVybmF0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBfQ2FjaGUyLmRlZmF1bHQoRXh0ZXJuYWxzLmxvY2FsU3RvcmFnZSwgb3B0aW9ucy5jYWNoZVByZWZpeCk7XG5cbiAgICAgICAgdGhpcy5fY2xpZW50ID0gb3B0aW9ucy5jbGllbnQgfHwgbmV3IF9DbGllbnQyLmRlZmF1bHQoKTtcblxuICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IG5ldyBfUGxhdGZvcm0yLmRlZmF1bHQodGhpcy5fY2xpZW50LCB0aGlzLl9jYWNoZSwgb3B0aW9ucy5zZXJ2ZXIsIG9wdGlvbnMuYXBwS2V5LCBvcHRpb25zLmFwcFNlY3JldCwgb3B0aW9ucy5hcHBOYW1lLCBvcHRpb25zLmFwcFZlcnNpb24sIFNESy52ZXJzaW9uKTtcblxuICAgICAgICB0aGlzLl9wdWJudWJGYWN0b3J5ID0gb3B0aW9ucy5wdWJudWJGYWN0b3J5IHx8IEV4dGVybmFscy5QVUJOVUI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7UGxhdGZvcm19XG4gICAgICovXG5cblxuICAgIFNESy5wcm90b3R5cGUucGxhdGZvcm0gPSBmdW5jdGlvbiBwbGF0Zm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259XG4gICAgICovXG5cblxuICAgIFNESy5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gY3JlYXRlU3Vic2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IF9TdWJzY3JpcHRpb24yLmRlZmF1bHQodGhpcy5fcHVibnViRmFjdG9yeSwgdGhpcy5fcGxhdGZvcm0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtDYWNoZWRTdWJzY3JpcHRpb259XG4gICAgICovXG5cblxuICAgIFNESy5wcm90b3R5cGUuY3JlYXRlQ2FjaGVkU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gY3JlYXRlQ2FjaGVkU3Vic2NyaXB0aW9uKGNhY2hlS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NhY2hlZFN1YnNjcmlwdGlvbjIuZGVmYXVsdCh0aGlzLl9wdWJudWJGYWN0b3J5LCB0aGlzLl9wbGF0Zm9ybSwgdGhpcy5fY2FjaGUsIGNhY2hlS2V5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Q2FjaGV9XG4gICAgICovXG5cblxuICAgIFNESy5wcm90b3R5cGUuY2FjaGUgPSBmdW5jdGlvbiBjYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH07XG5cbiAgICBTREsuaGFuZGxlTG9naW5SZWRpcmVjdCA9IGZ1bmN0aW9uIGhhbmRsZUxvZ2luUmVkaXJlY3Qob3JpZ2luKSB7XG4gICAgICAgIHdpbmRvdy5vcGVuZXIucG9zdE1lc3NhZ2UoeyBSQ0F1dGhvcml6YXRpb25Db2RlOiB3aW5kb3cubG9jYXRpb24uc2VhcmNoIH0sIG9yaWdpbiB8fCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNESztcbn0oKTtcblxuU0RLLnZlcnNpb24gPSAgdHJ1ZSA/IChcIjMuMC4wLXJjMVwiKSA6ICd4LngueCc7XG5TREsuc2VydmVyID0ge1xuICAgIHNhbmRib3g6ICdodHRwczovL3BsYXRmb3JtLmRldnRlc3QucmluZ2NlbnRyYWwuY29tJyxcbiAgICBwcm9kdWN0aW9uOiAnaHR0cHM6Ly9wbGF0Zm9ybS5yaW5nY2VudHJhbC5jb20nXG59O1xuU0RLLmNvcmUgPSB7XG4gICAgQ2FjaGU6IF9DYWNoZTIuZGVmYXVsdCxcbiAgICBFdmVudEVtaXR0ZXI6IF9ldmVudHMyLmRlZmF1bHQsXG4gICAgVXRpbHM6IFV0aWxzLFxuICAgIEV4dGVybmFsczogRXh0ZXJuYWxzXG59O1xuU0RLLmh0dHAgPSB7XG4gICAgQ2xpZW50OiBfQ2xpZW50Mi5kZWZhdWx0LFxuICAgIEFwaVJlc3BvbnNlOiBfQXBpUmVzcG9uc2UyLmRlZmF1bHRcbn07XG5TREsucGxhdGZvcm0gPSB7XG4gICAgQXV0aDogX0F1dGgyLmRlZmF1bHQsXG4gICAgUGxhdGZvcm06IF9QbGF0Zm9ybTIuZGVmYXVsdFxufTtcblNESy5zdWJzY3JpcHRpb24gPSB7XG4gICAgU3Vic2NyaXB0aW9uOiBfU3Vic2NyaXB0aW9uMi5kZWZhdWx0XG59O1xuU0RLLm1vY2tzID0ge1xuICAgIENsaWVudDogX0NsaWVudE1vY2syLmRlZmF1bHQsXG4gICAgUmVnaXN0cnk6IF9SZWdpc3RyeTIuZGVmYXVsdCxcbiAgICBNb2NrOiBfTW9jazIuZGVmYXVsdFxufTtcblNESy5wdWJudWIgPSB7XG4gICAgUHVibnViTW9ja0ZhY3Rvcnk6IF9QdWJudWJGYWN0b3J5Mi5kZWZhdWx0XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU0RLO1xuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9XG4gICAgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKChvdXRlckZuIHx8IEdlbmVyYXRvcikucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLiBTb21lIG1heSBjb25zaWRlciB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZCB0b29cbiAgLy8gY3V0ZXN5LCBidXQgdGhleSBhcmUgY3VybXVkZ2VvbnMuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gbmV3IEF3YWl0QXJndW1lbnQoYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBBd2FpdEFyZ3VtZW50KGFyZykge1xuICAgIHRoaXMuYXJnID0gYXJnO1xuICB9XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICAvLyBUaGlzIGludm9rZSBmdW5jdGlvbiBpcyB3cml0dGVuIGluIGEgc3R5bGUgdGhhdCBhc3N1bWVzIHNvbWVcbiAgICAvLyBjYWxsaW5nIGZ1bmN0aW9uIChvciBQcm9taXNlKSB3aWxsIGhhbmRsZSBleGNlcHRpb25zLlxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IGdlbmVyYXRvclttZXRob2RdKGFyZyk7XG4gICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50XG4gICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLmFyZykudGhlbihpbnZva2VOZXh0LCBpbnZva2VUaHJvdylcbiAgICAgICAgOiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIGludm9rZU5leHQgPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwibmV4dFwiKTtcbiAgICB2YXIgaW52b2tlVGhyb3cgPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwidGhyb3dcIik7XG4gICAgdmFyIGludm9rZVJldHVybiA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJyZXR1cm5cIik7XG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHxcbiAgICAgICAgICAgICAgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiICYmIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvcixcbiAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGNvbnRleHQuX3NlbnQgPSBhcmc7XG5cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkWWllbGQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGFyZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5xdWVyeVN0cmluZ2lmeSA9IHF1ZXJ5U3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZVF1ZXJ5U3RyaW5nID0gcGFyc2VRdWVyeVN0cmluZztcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc09iamVjdE9iamVjdCA9IGlzT2JqZWN0T2JqZWN0O1xuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbmV4cG9ydHMuaXNOb2RlSlMgPSBpc05vZGVKUztcbmV4cG9ydHMuaXNCcm93c2VyID0gaXNCcm93c2VyO1xuZXhwb3J0cy5kZWxheSA9IGRlbGF5O1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbi8qKlxuICogVE9ETyBSZXBsYWNlIHdpdGggc29tZXRoaW5nIGJldHRlclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvYmxvYi9tYXN0ZXIvbGliL3F1ZXJ5c3RyaW5nLmpzXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1ldGVyc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcXVlcnlTdHJpbmdpZnkocGFyYW1ldGVycykge1xuXG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICAgIE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblxuICAgICAgICB2YXIgdiA9IHBhcmFtZXRlcnNba107XG5cbiAgICAgICAgaWYgKGlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHYuZm9yRWFjaChmdW5jdGlvbiAodnYpIHtcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2dikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2KSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhcnJheS5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogVE9ETyBSZXBsYWNlIHdpdGggc29tZXRoaW5nIGJldHRlclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvYmxvYi9tYXN0ZXIvbGliL3F1ZXJ5c3RyaW5nLmpzXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlTdHJpbmdcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmcocXVlcnlTdHJpbmcpIHtcblxuICAgIHZhciBhcmdzUGFyc2VkID0ge307XG5cbiAgICBxdWVyeVN0cmluZy5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuXG4gICAgICAgIGFyZyA9IGRlY29kZVVSSUNvbXBvbmVudChhcmcpO1xuXG4gICAgICAgIGlmIChhcmcuaW5kZXhPZignPScpID09IC0xKSB7XG5cbiAgICAgICAgICAgIGFyZ3NQYXJzZWRbYXJnLnRyaW0oKV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgcGFpciA9IGFyZy5zcGxpdCgnPScpLFxuICAgICAgICAgICAgICAgIGtleSA9IHBhaXJbMF0udHJpbSgpLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFpclsxXS50cmltKCk7XG5cbiAgICAgICAgICAgIGlmIChrZXkgaW4gYXJnc1BhcnNlZCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gYXJnc1BhcnNlZCAmJiAhaXNBcnJheShhcmdzUGFyc2VkW2tleV0pKSBhcmdzUGFyc2VkW2tleV0gPSBbYXJnc1BhcnNlZFtrZXldXTtcbiAgICAgICAgICAgICAgICBhcmdzUGFyc2VkW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3NQYXJzZWRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJnc1BhcnNlZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8qKlxuICogQHBhcmFtIG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkob2JqKSA6IHR5cGVvZiBvYmogPT09IFwiYXJyYXlcIjtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3Qobykge1xuICAgIHJldHVybiBvICE9IG51bGwgJiYgKHR5cGVvZiBvID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvKSkgPT09ICdvYmplY3QnICYmICFpc0FycmF5KG8pO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdE9iamVjdChvKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KG8pID09PSB0cnVlICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICAgIHZhciBjdG9yLCBwcm90O1xuXG4gICAgaWYgKGlzT2JqZWN0T2JqZWN0KG8pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gSWYgaGFzIG1vZGlmaWVkIGNvbnN0cnVjdG9yXG4gICAgY3RvciA9IG8uY29uc3RydWN0b3I7XG4gICAgaWYgKHR5cGVvZiBjdG9yICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBJZiBoYXMgbW9kaWZpZWQgcHJvdG90eXBlXG4gICAgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICAgIGlmIChpc09iamVjdE9iamVjdChwcm90KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIElmIGNvbnN0cnVjdG9yIGRvZXMgbm90IGhhdmUgYW4gT2JqZWN0LXNwZWNpZmljIG1ldGhvZFxuICAgIGlmIChwcm90Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBNb3N0IGxpa2VseSBhIHBsYWluIE9iamVjdFxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc05vZGVKUygpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnO1xufVxuXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufVxuXG5mdW5jdGlvbiBkZWxheSh0aW1lb3V0KSB7XG4gICAgcmV0dXJuIG5ldyBfRXh0ZXJuYWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH0pO1xufVxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9jYWxTdG9yYWdlID0gZXhwb3J0cy5QVUJOVUIgPSBleHBvcnRzLkhlYWRlcnMgPSBleHBvcnRzLlJlc3BvbnNlID0gZXhwb3J0cy5SZXF1ZXN0ID0gZXhwb3J0cy5mZXRjaCA9IGV4cG9ydHMuUHJvbWlzZSA9IHVuZGVmaW5lZDtcblxudmFyIF9lczZQcm9taXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9lczZQcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VzNlByb21pc2UpO1xuXG52YXIgX25vZGVGZXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfbm9kZUZldGNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25vZGVGZXRjaCk7XG5cbnZhciBfcHVibnViID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF9wdWJudWIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHVibnViKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHJvb3QgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyB8fCB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzO1wiKSgpO1xuXG52YXIgUHJvbWlzZSA9IF9lczZQcm9taXNlMi5kZWZhdWx0ICYmIF9lczZQcm9taXNlMi5kZWZhdWx0LlByb21pc2UgfHwgcm9vdC5Qcm9taXNlO1xuXG52YXIgZmV0Y2ggPSBfbm9kZUZldGNoMi5kZWZhdWx0ICYmIHR5cGVvZiBfbm9kZUZldGNoMi5kZWZhdWx0ID09ICdmdW5jdGlvbicgPyBfbm9kZUZldGNoMi5kZWZhdWx0IDogcm9vdC5mZXRjaDtcbnZhciBSZXF1ZXN0ID0gZmV0Y2guUmVxdWVzdCB8fCByb290LlJlcXVlc3Q7XG52YXIgUmVzcG9uc2UgPSBmZXRjaC5SZXNwb25zZSB8fCByb290LlJlc3BvbnNlO1xudmFyIEhlYWRlcnMgPSBmZXRjaC5IZWFkZXJzIHx8IHJvb3QuSGVhZGVycztcblxudmFyIFBVQk5VQiA9IF9wdWJudWIyLmRlZmF1bHQgfHwgcm9vdC5QVUJOVUI7XG5cbnZhciBsb2NhbFN0b3JhZ2UgPSB0eXBlb2Ygcm9vdC5sb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnID8gcm9vdC5sb2NhbFN0b3JhZ2UgOiB7fTtcblxuZXhwb3J0cy5Qcm9taXNlID0gUHJvbWlzZTtcbmV4cG9ydHMuZmV0Y2ggPSBmZXRjaDtcbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7XG5leHBvcnRzLkhlYWRlcnMgPSBIZWFkZXJzO1xuZXhwb3J0cy5QVUJOVUIgPSBQVUJOVUI7XG5leHBvcnRzLmxvY2FsU3RvcmFnZSA9IGxvY2FsU3RvcmFnZTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNV9fO1xuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV82X187XG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXztcblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYWNoZShzdG9yYWdlLCBwcmVmaXgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhY2hlKTtcblxuICAgICAgICB0aGlzLnNldFByZWZpeChwcmVmaXgpO1xuICAgICAgICB0aGlzLl9zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB9XG5cbiAgICBDYWNoZS5wcm90b3R5cGUuc2V0UHJlZml4ID0gZnVuY3Rpb24gc2V0UHJlZml4KHByZWZpeCkge1xuICAgICAgICB0aGlzLl9wcmVmaXggPSBwcmVmaXggfHwgQ2FjaGUuZGVmYXVsdFByZWZpeDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENhY2hlLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24gc2V0SXRlbShrZXksIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fc3RvcmFnZVt0aGlzLl9wcmVmaXhLZXkoa2V5KV0gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENhY2hlLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gcmVtb3ZlSXRlbShrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N0b3JhZ2VbdGhpcy5fcHJlZml4S2V5KGtleSldO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgQ2FjaGUucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbiBnZXRJdGVtKGtleSkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX3N0b3JhZ2VbdGhpcy5fcHJlZml4S2V5KGtleSldO1xuICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShpdGVtKTtcbiAgICB9O1xuXG4gICAgQ2FjaGUucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24gY2xlYW4oKSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX3N0b3JhZ2UpIHtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdG9yYWdlLmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YodGhpcy5fcHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yYWdlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgQ2FjaGUucHJvdG90eXBlLl9wcmVmaXhLZXkgPSBmdW5jdGlvbiBfcHJlZml4S2V5KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJlZml4ICsga2V5O1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FjaGU7XG59KCk7XG5cbkNhY2hlLmRlZmF1bHRQcmVmaXggPSAncmMtJztcbmV4cG9ydHMuZGVmYXVsdCA9IENhY2hlO1xuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG4vKioqLyB9LFxuLyogMTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZmluZEhlYWRlck5hbWUgPSBmaW5kSGVhZGVyTmFtZTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX1V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9ldmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX0FwaVJlc3BvbnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBfQXBpUmVzcG9uc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXBpUmVzcG9uc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENsaWVudCA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKENsaWVudCwgX0V2ZW50RW1pdHRlcik7XG5cbiAgICBmdW5jdGlvbiBDbGllbnQoKSB7XG4gICAgICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaWVudCk7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudEVtaXR0ZXIuY2FsbC5hcHBseShfRXZlbnRFbWl0dGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuZXZlbnRzID0ge1xuICAgICAgICAgICAgYmVmb3JlUmVxdWVzdDogJ2JlZm9yZVJlcXVlc3QnLFxuICAgICAgICAgICAgcmVxdWVzdFN1Y2Nlc3M6ICdyZXF1ZXN0U3VjY2VzcycsXG4gICAgICAgICAgICByZXF1ZXN0RXJyb3I6ICdyZXF1ZXN0RXJyb3InXG4gICAgICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG4gICAgQ2xpZW50LnByb3RvdHlwZS5zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHZhciBhcGlSZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZXNwb25zZSA9IG5ldyBfQXBpUmVzcG9uc2UyLmRlZmF1bHQocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBTdG9wIHJlcXVlc3QgaWYgbGlzdGVuZXJzIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5iZWZvcmVSZXF1ZXN0LCBhcGlSZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFJlc3BvbnNlKHJlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVzcG9uc2UuX3Jlc3BvbnNlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBpUmVzcG9uc2UuX2luaXQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcGlSZXNwb25zZS5vaygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBoYXMgdW5zdWNjZXNzZnVsIHN0YXR1cycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLnJlcXVlc3RTdWNjZXNzLCBhcGlSZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFwaVJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDEpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9jb250ZXh0LnQwLmFwaVJlc3BvbnNlKSBfY29udGV4dC50MCA9IHRoaXMubWFrZUVycm9yKF9jb250ZXh0LnQwLCBhcGlSZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMucmVxdWVzdEVycm9yLCBfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dC50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcywgW1sxLCAxNF1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KF94KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbmRSZXF1ZXN0O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2U+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIENsaWVudC5wcm90b3R5cGUuX2xvYWRSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9FeHRlcm5hbHMuZmV0Y2guY2FsbChudWxsLCByZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gX2xvYWRSZXNwb25zZShfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9sb2FkUmVzcG9uc2U7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogV3JhcHMgdGhlIEpTIEVycm9yIG9iamVjdCB3aXRoIHRyYW5zYWN0aW9uIGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIHtFcnJvcnxJQXBpRXJyb3J9IGVcbiAgICAgKiBAcGFyYW0ge0FwaVJlc3BvbnNlfSBhcGlSZXNwb25zZVxuICAgICAqIEByZXR1cm4ge0lBcGlFcnJvcn1cbiAgICAgKi9cblxuXG4gICAgQ2xpZW50LnByb3RvdHlwZS5tYWtlRXJyb3IgPSBmdW5jdGlvbiBtYWtlRXJyb3IoZSwgYXBpUmVzcG9uc2UpIHtcblxuICAgICAgICAvLyBXcmFwIG9ubHkgaWYgcmVndWxhciBlcnJvclxuICAgICAgICBpZiAoIWUuaGFzT3duUHJvcGVydHkoJ2FwaVJlc3BvbnNlJykgJiYgIWUuaGFzT3duUHJvcGVydHkoJ29yaWdpbmFsTWVzc2FnZScpKSB7XG5cbiAgICAgICAgICAgIGUuYXBpUmVzcG9uc2UgPSBhcGlSZXNwb25zZTtcbiAgICAgICAgICAgIGUub3JpZ2luYWxNZXNzYWdlID0gZS5tZXNzYWdlO1xuICAgICAgICAgICAgZS5tZXNzYWdlID0gYXBpUmVzcG9uc2UgJiYgYXBpUmVzcG9uc2UuZXJyb3IodHJ1ZSkgfHwgZS5vcmlnaW5hbE1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5pdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbaW5pdC51cmxdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtpbml0LmJvZHldXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtpbml0Lm1ldGhvZF1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2luaXQucXVlcnldXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtpbml0LmhlYWRlcnNdXG4gICAgICogQHJldHVybiB7UmVxdWVzdH1cbiAgICAgKi9cblxuXG4gICAgQ2xpZW50LnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChpbml0KSB7XG5cbiAgICAgICAgaW5pdCA9IGluaXQgfHwge307XG4gICAgICAgIGluaXQuaGVhZGVycyA9IGluaXQuaGVhZGVycyB8fCB7fTtcblxuICAgICAgICAvLyBTYW5pdHkgY2hlY2tzXG4gICAgICAgIGlmICghaW5pdC51cmwpIHRocm93IG5ldyBFcnJvcignVXJsIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgIGlmICghaW5pdC5tZXRob2QpIGluaXQubWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGlmIChpbml0Lm1ldGhvZCAmJiBDbGllbnQuX2FsbG93ZWRNZXRob2RzLmluZGV4T2YoaW5pdC5tZXRob2QudG9VcHBlckNhc2UoKSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBoYXMgd3JvbmcgdmFsdWU6ICcgKyBpbml0Lm1ldGhvZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0c1xuICAgICAgICBpbml0LmNyZWRlbnRpYWxzID0gaW5pdC5jcmVkZW50aWFscyB8fCAnaW5jbHVkZSc7XG4gICAgICAgIGluaXQubW9kZSA9IGluaXQubW9kZSB8fCAnY29ycyc7XG5cbiAgICAgICAgLy8gQXBwZW5kIFF1ZXJ5IFN0cmluZ1xuICAgICAgICBpZiAoaW5pdC5xdWVyeSkge1xuICAgICAgICAgICAgaW5pdC51cmwgPSBpbml0LnVybCArIChpbml0LnVybC5pbmRleE9mKCc/JykgPiAtMSA/ICcmJyA6ICc/JykgKyAoMCwgX1V0aWxzLnF1ZXJ5U3RyaW5naWZ5KShpbml0LnF1ZXJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmluZEhlYWRlck5hbWUoJ0FjY2VwdCcsIGluaXQuaGVhZGVycykpIHtcbiAgICAgICAgICAgIGluaXQuaGVhZGVyc1snQWNjZXB0J10gPSBfQXBpUmVzcG9uc2UyLmRlZmF1bHQuX2pzb25Db250ZW50VHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlcmlhbGl6ZSBib2R5XG4gICAgICAgIGlmICgoMCwgX1V0aWxzLmlzUGxhaW5PYmplY3QpKGluaXQuYm9keSkgfHwgIWluaXQuYm9keSkge1xuXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGVIZWFkZXJOYW1lID0gZmluZEhlYWRlck5hbWUoX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9jb250ZW50VHlwZSwgaW5pdC5oZWFkZXJzKTtcblxuICAgICAgICAgICAgaWYgKCFjb250ZW50VHlwZUhlYWRlck5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZUhlYWRlck5hbWUgPSBfQXBpUmVzcG9uc2UyLmRlZmF1bHQuX2NvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgIGluaXQuaGVhZGVyc1tjb250ZW50VHlwZUhlYWRlck5hbWVdID0gX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9qc29uQ29udGVudFR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IGluaXQuaGVhZGVyc1tjb250ZW50VHlwZUhlYWRlck5hbWVdO1xuXG4gICAgICAgICAgICAvLyBBc3NpZ24gYSBuZXcgZW5jb2RlZCBib2R5XG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZihfQXBpUmVzcG9uc2UyLmRlZmF1bHQuX2pzb25Db250ZW50VHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGluaXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KGluaXQuYm9keSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll91cmxlbmNvZGVkQ29udGVudFR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpbml0LmJvZHkgPSAoMCwgX1V0aWxzLnF1ZXJ5U3RyaW5naWZ5KShpbml0LmJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgcmVxdWVzdCB3aXRoIGVuY29kZWQgYm9keVxuICAgICAgICB2YXIgcmVxID0gbmV3IF9FeHRlcm5hbHMuUmVxdWVzdChpbml0LnVybCwgaW5pdCk7XG5cbiAgICAgICAgLy8gS2VlcCB0aGUgb3JpZ2luYWwgYm9keSBhY2Nlc3NpYmxlIGRpcmVjdGx5IChmb3IgbW9ja3MpXG4gICAgICAgIHJlcS5vcmlnaW5hbEJvZHkgPSBpbml0LmJvZHk7XG5cbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENsaWVudDtcbn0oX2V2ZW50czIuZGVmYXVsdCk7XG5cbkNsaWVudC5fYWxsb3dlZE1ldGhvZHMgPSBbJ0dFVCcsICdQT1NUJywgJ1BVVCcsICdERUxFVEUnLCAnUEFUQ0gnLCAnT1BUSU9OUycsICdIRUFEJ107XG5leHBvcnRzLmRlZmF1bHQgPSBDbGllbnQ7XG5mdW5jdGlvbiBmaW5kSGVhZGVyTmFtZShuYW1lLCBoZWFkZXJzKSB7XG4gICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGtleSkge1xuICAgICAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgICAgICBpZiAobmFtZSA9PSBrZXkudG9Mb3dlckNhc2UoKSkgcmV0dXJuIGtleTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCBudWxsKTtcbn1cblxuLyoqXG4gKiBAbmFtZSBJQXBpRXJyb3JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGFja1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG9yaWdpbmFsTWVzc2FnZVxuICogQHByb3BlcnR5IHtBcGlSZXNwb25zZX0gYXBpUmVzcG9uc2VcbiAqL1xuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgX0V4dGVybmFscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyByZXR1cm4gX0V4dGVybmFscy5Qcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEFwaVJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VUZXh0XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBBcGlSZXNwb25zZShyZXF1ZXN0LCByZXNwb25zZSwgcmVzcG9uc2VUZXh0KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcGlSZXNwb25zZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtSZXF1ZXN0fSAqL1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdDtcblxuICAgICAgICAvKiogQHR5cGUge1Jlc3BvbnNlfSAqL1xuICAgICAgICB0aGlzLl9yZXNwb25zZSA9IHJlc3BvbnNlO1xuXG4gICAgICAgIHRoaXMuX3RleHQgPSByZXNwb25zZVRleHQ7XG4gICAgICAgIHRoaXMuX2pzb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9tdWx0aXBhcnQgPSBbXTtcbiAgICB9XG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9pc011bHRpcGFydCgpIHx8IHRoaXMuX2lzSnNvbigpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2UoKS50ZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0ID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfaW5pdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtSZXNwb25zZX1cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLnJlc3BvbnNlID0gZnVuY3Rpb24gcmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7UmVxdWVzdH1cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLm9rID0gZnVuY3Rpb24gb2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZSAmJiB0aGlzLl9yZXNwb25zZS5vaztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNKc29uKCkgJiYgIXRoaXMuX2lzTXVsdGlwYXJ0KCkpIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaXMgbm90IHRleHQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiBqc29uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzSnNvbigpKSB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGlzIG5vdCBKU09OJyk7XG4gICAgICAgIGlmICghdGhpcy5fanNvbikge1xuICAgICAgICAgICAgdGhpcy5fanNvbiA9IHRoaXMuX3RleHQgPyBKU09OLnBhcnNlKHRoaXMuX3RleHQpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fanNvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIFtza2lwT0tDaGVja11cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKHNraXBPS0NoZWNrKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub2soKSAmJiAhc2tpcE9LQ2hlY2spIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciBtZXNzYWdlID0gKHRoaXMuX3Jlc3BvbnNlICYmIHRoaXMuX3Jlc3BvbnNlLnN0YXR1cyA/IHRoaXMuX3Jlc3BvbnNlLnN0YXR1cyArICcgJyA6ICcnKSArICh0aGlzLl9yZXNwb25zZSAmJiB0aGlzLl9yZXNwb25zZS5zdGF0dXNUZXh0ID8gdGhpcy5fcmVzcG9uc2Uuc3RhdHVzVGV4dCA6ICcnKTtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5qc29uKCkubWVzc2FnZSkgbWVzc2FnZSA9IHRoaXMuanNvbigpLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAodGhpcy5qc29uKCkuZXJyb3JfZGVzY3JpcHRpb24pIG1lc3NhZ2UgPSB0aGlzLmpzb24oKS5lcnJvcl9kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmpzb24oKS5kZXNjcmlwdGlvbikgbWVzc2FnZSA9IHRoaXMuanNvbigpLmRlc2NyaXB0aW9uO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtBcGlSZXNwb25zZVtdfVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUubXVsdGlwYXJ0ID0gZnVuY3Rpb24gbXVsdGlwYXJ0KCkge1xuXG4gICAgICAgIGlmICghdGhpcy5faXNNdWx0aXBhcnQoKSkgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBpcyBub3QgbXVsdGlwYXJ0Jyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tdWx0aXBhcnQubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgMS4gU3BsaXQgbXVsdGlwYXJ0IHJlc3BvbnNlXG5cbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0KCk7XG5cbiAgICAgICAgICAgIGlmICghdGV4dCkgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBib2R5Jyk7XG5cbiAgICAgICAgICAgIHZhciBib3VuZGFyeSA9IHRoaXMuX2dldENvbnRlbnRUeXBlKCkubWF0Y2goL2JvdW5kYXJ5PShbXjtdKykvaSlbMV07XG5cbiAgICAgICAgICAgIGlmICghYm91bmRhcnkpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYm91bmRhcnknKTtcblxuICAgICAgICAgICAgdmFyIHBhcnRzID0gdGV4dC50b1N0cmluZygpLnNwbGl0KEFwaVJlc3BvbnNlLl9ib3VuZGFyeVNlcGFyYXRvciArIGJvdW5kYXJ5KTtcblxuICAgICAgICAgICAgaWYgKHBhcnRzWzBdLnRyaW0oKSA9PT0gJycpIHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0udHJpbSgpID09IEFwaVJlc3BvbnNlLl9ib3VuZGFyeVNlcGFyYXRvcikgcGFydHMucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCAxKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHBhcnRzIGluIGJvZHknKTtcblxuICAgICAgICAgICAgLy8gU3RlcCAyLiBQYXJzZSBzdGF0dXMgaW5mb1xuXG4gICAgICAgICAgICB2YXIgc3RhdHVzSW5mbyA9IEFwaVJlc3BvbnNlLmNyZWF0ZShwYXJ0cy5zaGlmdCgpLCB0aGlzLl9yZXNwb25zZS5zdGF0dXMsIHRoaXMuX3Jlc3BvbnNlLnN0YXR1c1RleHQpLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gU3RlcCAzLiBQYXJzZSBhbGwgb3RoZXIgcGFydHNcblxuICAgICAgICAgICAgdGhpcy5fbXVsdGlwYXJ0ID0gcGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0LCBpKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gc3RhdHVzSW5mby5yZXNwb25zZVtpXS5zdGF0dXM7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gQXBpUmVzcG9uc2UuY3JlYXRlKHBhcnQsIHN0YXR1cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9tdWx0aXBhcnQ7XG4gICAgfTtcblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5faXNDb250ZW50VHlwZSA9IGZ1bmN0aW9uIF9pc0NvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZW50VHlwZSgpLmluZGV4T2YoY29udGVudFR5cGUpID4gLTE7XG4gICAgfTtcblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5fZ2V0Q29udGVudFR5cGUgPSBmdW5jdGlvbiBfZ2V0Q29udGVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZS5oZWFkZXJzLmdldChBcGlSZXNwb25zZS5fY29udGVudFR5cGUpIHx8ICcnO1xuICAgIH07XG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuX2lzTXVsdGlwYXJ0ID0gZnVuY3Rpb24gX2lzTXVsdGlwYXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDb250ZW50VHlwZShBcGlSZXNwb25zZS5fbXVsdGlwYXJ0Q29udGVudFR5cGUpO1xuICAgIH07XG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuX2lzVXJsRW5jb2RlZCA9IGZ1bmN0aW9uIF9pc1VybEVuY29kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NvbnRlbnRUeXBlKEFwaVJlc3BvbnNlLl91cmxlbmNvZGVkQ29udGVudFR5cGUpO1xuICAgIH07XG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuX2lzSnNvbiA9IGZ1bmN0aW9uIF9pc0pzb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NvbnRlbnRUeXBlKEFwaVJlc3BvbnNlLl9qc29uQ29udGVudFR5cGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgaXMgdXNlZCB0byBjcmVhdGUgQXBpUmVzcG9uc2Ugb2JqZWN0IGZyb20gc3RyaW5nIHBhcnRzIG9mIG11bHRpcGFydC9taXhlZCByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXR1c11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0YXR1c1RleHRdXG4gICAgICogQHJldHVybiB7QXBpUmVzcG9uc2V9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSh0ZXh0LCBzdGF0dXMsIHN0YXR1c1RleHQpIHtcblxuICAgICAgICB0ZXh0ID0gdGV4dCB8fCAnJztcbiAgICAgICAgc3RhdHVzID0gc3RhdHVzIHx8IDIwMDtcbiAgICAgICAgc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgJ09LJztcblxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHIvZywgJycpO1xuXG4gICAgICAgIHZhciBoZWFkZXJzID0gbmV3IF9FeHRlcm5hbHMuSGVhZGVycygpLFxuICAgICAgICAgICAgaGVhZGVyc0FuZEJvZHkgPSB0ZXh0LnNwbGl0KEFwaVJlc3BvbnNlLl9ib2R5U2VwYXJhdG9yKSxcbiAgICAgICAgICAgIGhlYWRlcnNUZXh0ID0gaGVhZGVyc0FuZEJvZHkubGVuZ3RoID4gMSA/IGhlYWRlcnNBbmRCb2R5LnNoaWZ0KCkgOiAnJztcblxuICAgICAgICB0ZXh0ID0gaGVhZGVyc0FuZEJvZHkubGVuZ3RoID4gMCA/IGhlYWRlcnNBbmRCb2R5LmpvaW4oQXBpUmVzcG9uc2UuX2JvZHlTZXBhcmF0b3IpIDogbnVsbDtcblxuICAgICAgICAoaGVhZGVyc1RleHQgfHwgJycpLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcblxuICAgICAgICAgICAgdmFyIHNwbGl0ID0gaGVhZGVyLnRyaW0oKS5zcGxpdChBcGlSZXNwb25zZS5faGVhZGVyU2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgICBrZXkgPSBzcGxpdC5zaGlmdCgpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNwbGl0LmpvaW4oQXBpUmVzcG9uc2UuX2hlYWRlclNlcGFyYXRvcikudHJpbSgpO1xuXG4gICAgICAgICAgICBpZiAoa2V5KSBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBBcGlSZXNwb25zZShudWxsLCBuZXcgX0V4dGVybmFscy5SZXNwb25zZSh0ZXh0ID8gdGV4dCA6IHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogc3RhdHVzVGV4dFxuICAgICAgICB9KSwgdGV4dCk7XG4gICAgfTtcblxuICAgIHJldHVybiBBcGlSZXNwb25zZTtcbn0oKTtcblxuQXBpUmVzcG9uc2UuX2NvbnRlbnRUeXBlID0gJ0NvbnRlbnQtVHlwZSc7XG5BcGlSZXNwb25zZS5fanNvbkNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuQXBpUmVzcG9uc2UuX211bHRpcGFydENvbnRlbnRUeXBlID0gJ211bHRpcGFydC9taXhlZCc7XG5BcGlSZXNwb25zZS5fdXJsZW5jb2RlZENvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG5BcGlSZXNwb25zZS5faGVhZGVyU2VwYXJhdG9yID0gJzonO1xuQXBpUmVzcG9uc2UuX2JvZHlTZXBhcmF0b3IgPSAnXFxuXFxuJztcbkFwaVJlc3BvbnNlLl9ib3VuZGFyeVNlcGFyYXRvciA9ICctLSc7XG5leHBvcnRzLmRlZmF1bHQgPSBBcGlSZXNwb25zZTtcblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1JlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBfUmVnaXN0cnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVnaXN0cnkpO1xuXG52YXIgX0NsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX0NsaWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DbGllbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENsaWVudCA9IGZ1bmN0aW9uIChfSHR0cENsaWVudCkge1xuICAgIF9pbmhlcml0cyhDbGllbnQsIF9IdHRwQ2xpZW50KTtcblxuICAgIGZ1bmN0aW9uIENsaWVudCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaWVudCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0h0dHBDbGllbnQuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMuX3JlZ2lzdHJ5ID0gbmV3IF9SZWdpc3RyeTIuZGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgQ2xpZW50LnByb3RvdHlwZS5yZWdpc3RyeSA9IGZ1bmN0aW9uIHJlZ2lzdHJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0cnk7XG4gICAgfTtcblxuICAgIENsaWVudC5wcm90b3R5cGUuX2xvYWRSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHZhciBtb2NrO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vY2sgPSB0aGlzLl9yZWdpc3RyeS5maW5kKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2NrLmdldFJlc3BvbnNlKHJlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gX2xvYWRSZXNwb25zZShfeCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfbG9hZFJlc3BvbnNlO1xuICAgIH0oKTtcblxuICAgIHJldHVybiBDbGllbnQ7XG59KF9DbGllbnQyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDbGllbnQ7XG5cbi8qKiovIH0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9Nb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbnZhciBfTW9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Nb2NrKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFJlZ2lzdHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZ2lzdHJ5KCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVnaXN0cnkpO1xuXG4gICAgICAgIHRoaXMuX21vY2tzID0gW107XG4gICAgfVxuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChtb2NrKSB7XG4gICAgICAgIHRoaXMuX21vY2tzLnB1c2gobW9jayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbW9ja3MgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gZmluZChyZXF1ZXN0KSB7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnUmVnaXN0cnkgaXMgbG9va2luZyBmb3InLCByZXF1ZXN0KTtcblxuICAgICAgICB2YXIgbW9jayA9IHRoaXMuX21vY2tzLnNoaWZ0KCk7XG5cbiAgICAgICAgaWYgKCFtb2NrKSB0aHJvdyBuZXcgRXJyb3IoJ05vIG1vY2sgaW4gcmVnaXN0cnkgZm9yIHJlcXVlc3QgJyArIHJlcXVlc3QubWV0aG9kICsgJyAnICsgcmVxdWVzdC51cmwpO1xuXG4gICAgICAgIGlmICghbW9jay50ZXN0KHJlcXVlc3QpKSB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIHJlcXVlc3QgJyArIHJlcXVlc3QubWV0aG9kICsgJyAnICsgcmVxdWVzdC51cmwgKyAnIGZvciBleHBlY3RlZCBtb2NrICcgKyBtb2NrLm1ldGhvZCgpICsgJyAnICsgbW9jay5wYXRoKCkpO1xuXG4gICAgICAgIHJldHVybiBtb2NrO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuYXBpQ2FsbCA9IGZ1bmN0aW9uIGFwaUNhbGwobWV0aG9kLCBwYXRoLCByZXNwb25zZSwgc3RhdHVzLCBzdGF0dXNUZXh0LCBkZWxheSkge1xuXG4gICAgICAgIHRoaXMuYWRkKG5ldyBfTW9jazIuZGVmYXVsdChtZXRob2QsIHBhdGgsIHJlc3BvbnNlLCBzdGF0dXMsIHN0YXR1c1RleHQsIGRlbGF5KSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5hdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uIGF1dGhlbnRpY2F0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuYXBpQ2FsbCgnUE9TVCcsICcvcmVzdGFwaS9vYXV0aC90b2tlbicsIHtcbiAgICAgICAgICAgICdhY2Nlc3NfdG9rZW4nOiAnQUNDRVNTX1RPS0VOJyxcbiAgICAgICAgICAgICd0b2tlbl90eXBlJzogJ2JlYXJlcicsXG4gICAgICAgICAgICAnZXhwaXJlc19pbic6IDM2MDAsXG4gICAgICAgICAgICAncmVmcmVzaF90b2tlbic6ICdSRUZSRVNIX1RPS0VOJyxcbiAgICAgICAgICAgICdyZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW4nOiA2MDQ4MCxcbiAgICAgICAgICAgICdzY29wZSc6ICdTTVMgUkNNIEZvbyBCb28nLFxuICAgICAgICAgICAgJ2V4cGlyZVRpbWUnOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIDM2MDAwMDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5sb2dvdXQgPSBmdW5jdGlvbiBsb2dvdXQoKSB7XG5cbiAgICAgICAgdGhpcy5hcGlDYWxsKCdQT1NUJywgJy9yZXN0YXBpL29hdXRoL3Jldm9rZScsIHt9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLnByZXNlbmNlTG9hZCA9IGZ1bmN0aW9uIHByZXNlbmNlTG9hZChpZCkge1xuXG4gICAgICAgIHRoaXMuYXBpQ2FsbCgnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC9+L2V4dGVuc2lvbi8nICsgaWQgKyAnL3ByZXNlbmNlJywge1xuICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwczovL3BsYXRmb3JtLnJpbmdjZW50cmFsLmNvbS9yZXN0YXBpL3YxLjAvYWNjb3VudC8xMjMvZXh0ZW5zaW9uL1wiICsgaWQgKyBcIi9wcmVzZW5jZVwiLFxuICAgICAgICAgICAgXCJleHRlbnNpb25cIjoge1xuICAgICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cHM6Ly9wbGF0Zm9ybS5yaW5nY2VudHJhbC5jb20vcmVzdGFwaS92MS4wL2FjY291bnQvMTIzL2V4dGVuc2lvbi9cIiArIGlkLFxuICAgICAgICAgICAgICAgIFwiaWRcIjogaWQsXG4gICAgICAgICAgICAgICAgXCJleHRlbnNpb25OdW1iZXJcIjogXCIxMDFcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWN0aXZlQ2FsbHNcIjogW10sXG4gICAgICAgICAgICBcInByZXNlbmNlU3RhdHVzXCI6IFwiQXZhaWxhYmxlXCIsXG4gICAgICAgICAgICBcInRlbGVwaG9ueVN0YXR1c1wiOiBcIlJpbmdpbmdcIixcbiAgICAgICAgICAgIFwidXNlclN0YXR1c1wiOiBcIkF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgXCJkbmRTdGF0dXNcIjogXCJUYWtlQWxsQ2FsbHNcIixcbiAgICAgICAgICAgIFwiZXh0ZW5zaW9uSWRcIjogaWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5zdWJzY3JpYmVHZW5lcmljID0gZnVuY3Rpb24gc3Vic2NyaWJlR2VuZXJpYyhleHBpcmVzSW4pIHtcblxuICAgICAgICBleHBpcmVzSW4gPSBleHBpcmVzSW4gfHwgMTUgKiA2MCAqIDYwO1xuXG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAnZXZlbnRGaWx0ZXJzJzogWycvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vfi9wcmVzZW5jZSddLFxuICAgICAgICAgICAgJ2V4cGlyYXRpb25UaW1lJzogbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgKyBleHBpcmVzSW4gKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgJ2V4cGlyZXNJbic6IGV4cGlyZXNJbixcbiAgICAgICAgICAgICdkZWxpdmVyeU1vZGUnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYW5zcG9ydFR5cGUnOiAnUHViTnViJyxcbiAgICAgICAgICAgICAgICAnZW5jcnlwdGlvbic6IGZhbHNlLFxuICAgICAgICAgICAgICAgICdhZGRyZXNzJzogJzEyM19mb28nLFxuICAgICAgICAgICAgICAgICdzdWJzY3JpYmVyS2V5JzogJ3N1Yi1jLWZvbycsXG4gICAgICAgICAgICAgICAgJ3NlY3JldEtleSc6ICdzZWMtYy1iYXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2lkJzogJ2Zvby1iYXItYmF6JyxcbiAgICAgICAgICAgICdjcmVhdGlvblRpbWUnOiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAnc3RhdHVzJzogJ0FjdGl2ZScsXG4gICAgICAgICAgICAndXJpJzogJ2h0dHBzOi8vcGxhdGZvcm0ucmluZ2NlbnRyYWwuY29tL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24vZm9vLWJhci1iYXonXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuc3Vic2NyaWJlT25QcmVzZW5jZSA9IGZ1bmN0aW9uIHN1YnNjcmliZU9uUHJlc2VuY2UoaWQsIGRldGFpbGVkKSB7XG5cbiAgICAgICAgaWQgPSBpZCB8fCAnMSc7XG5cbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHRoaXMuYXBpQ2FsbCgnUE9TVCcsICcvcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbicsIHtcbiAgICAgICAgICAgICdldmVudEZpbHRlcnMnOiBbJy9yZXN0YXBpL3YxLjAvYWNjb3VudC9+L2V4dGVuc2lvbi8nICsgaWQgKyAnL3ByZXNlbmNlJyArIChkZXRhaWxlZCA/ICc/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlJyA6ICcnKV0sXG4gICAgICAgICAgICAnZXhwaXJhdGlvblRpbWUnOiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIDE1ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAnZGVsaXZlcnlNb2RlJzoge1xuICAgICAgICAgICAgICAgICd0cmFuc3BvcnRUeXBlJzogJ1B1Yk51YicsXG4gICAgICAgICAgICAgICAgJ2VuY3J5cHRpb24nOiB0cnVlLFxuICAgICAgICAgICAgICAgICdhZGRyZXNzJzogJzEyM19mb28nLFxuICAgICAgICAgICAgICAgICdzdWJzY3JpYmVyS2V5JzogJ3N1Yi1jLWZvbycsXG4gICAgICAgICAgICAgICAgJ3NlY3JldEtleSc6ICdzZWMtYy1iYXInLFxuICAgICAgICAgICAgICAgICdlbmNyeXB0aW9uQWxnb3JpdGhtJzogJ0FFUycsXG4gICAgICAgICAgICAgICAgJ2VuY3J5cHRpb25LZXknOiAnVlF3YjZFVk5jUVBCaEUvSmdGWjJ6dz09J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdjcmVhdGlvblRpbWUnOiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAnaWQnOiAnZm9vLWJhci1iYXonLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdBY3RpdmUnLFxuICAgICAgICAgICAgJ3VyaSc6ICdodHRwczovL3BsYXRmb3JtLnJpbmdjZW50cmFsLmNvbS9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uL2Zvby1iYXItYmF6J1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLnRva2VuUmVmcmVzaCA9IGZ1bmN0aW9uIHRva2VuUmVmcmVzaChmYWlsdXJlKSB7XG5cbiAgICAgICAgaWYgKCFmYWlsdXJlKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYXBpQ2FsbCgnUE9TVCcsICcvcmVzdGFwaS9vYXV0aC90b2tlbicsIHtcbiAgICAgICAgICAgICAgICAnYWNjZXNzX3Rva2VuJzogJ0FDQ0VTU19UT0tFTl9GUk9NX1JFRlJFU0gnLFxuICAgICAgICAgICAgICAgICd0b2tlbl90eXBlJzogJ2JlYXJlcicsXG4gICAgICAgICAgICAgICAgJ2V4cGlyZXNfaW4nOiAzNjAwLFxuICAgICAgICAgICAgICAgICdyZWZyZXNoX3Rva2VuJzogJ1JFRlJFU0hfVE9LRU5fRlJPTV9SRUZSRVNIJyxcbiAgICAgICAgICAgICAgICAncmVmcmVzaF90b2tlbl9leHBpcmVzX2luJzogNjA0ODAsXG4gICAgICAgICAgICAgICAgJ3Njb3BlJzogJ1NNUyBSQ00gRm9vIEJvbydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvb2F1dGgvdG9rZW4nLCB7XG4gICAgICAgICAgICAgICAgJ21lc3NhZ2UnOiAnV3JvbmcgdG9rZW4nLFxuICAgICAgICAgICAgICAgICdlcnJvcl9kZXNjcmlwdGlvbic6ICdXcm9uZyB0b2tlbicsXG4gICAgICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJzogJ1dyb25nIHRva2VuJ1xuICAgICAgICAgICAgfSwgNDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVnaXN0cnk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlZ2lzdHJ5O1xuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9BcGlSZXNwb25zZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgX0FwaVJlc3BvbnNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FwaVJlc3BvbnNlKTtcblxudmFyIF9VdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IF9FeHRlcm5hbHMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIF9FeHRlcm5hbHMuUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBNb2NrID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vY2sobWV0aG9kLCBwYXRoLCBqc29uLCBzdGF0dXMsIHN0YXR1c1RleHQsIGRlbGF5KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2NrKTtcblxuICAgICAgICB0aGlzLl9tZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuX2pzb24gPSBqc29uIHx8IHt9O1xuICAgICAgICB0aGlzLl9kZWxheSA9IGRlbGF5IHx8IDEwO1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSBzdGF0dXMgfHwgMjAwO1xuICAgICAgICB0aGlzLl9zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCAnT0snO1xuICAgIH1cblxuICAgIE1vY2sucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiBwYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGF0aDtcbiAgICB9O1xuXG4gICAgTW9jay5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24gbWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0aG9kO1xuICAgIH07XG5cbiAgICBNb2NrLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdChyZXF1ZXN0KSB7XG5cbiAgICAgICAgcmV0dXJuIHJlcXVlc3QudXJsLmluZGV4T2YodGhpcy5fcGF0aCkgPiAtMSAmJiByZXF1ZXN0Lm1ldGhvZC50b1VwcGVyQ2FzZSgpID09IHRoaXMuX21ldGhvZDtcbiAgICB9O1xuXG4gICAgTW9jay5wcm90b3R5cGUuZ2V0UmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfVXRpbHMuZGVsYXkpKHRoaXMuX2RlbGF5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIHRoaXMuY3JlYXRlUmVzcG9uc2UodGhpcy5fanNvbikpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFJlc3BvbnNlKF94KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFJlc3BvbnNlO1xuICAgIH0oKTtcblxuICAgIE1vY2sucHJvdG90eXBlLmNyZWF0ZVJlc3BvbnNlID0gZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2UoanNvbiwgaW5pdCkge1xuXG4gICAgICAgIGluaXQgPSBpbml0IHx8IHt9O1xuXG4gICAgICAgIGluaXQuc3RhdHVzID0gaW5pdC5zdGF0dXMgfHwgdGhpcy5fc3RhdHVzO1xuICAgICAgICBpbml0LnN0YXR1c1RleHQgPSBpbml0LnN0YXR1c1RleHQgfHwgdGhpcy5fc3RhdHVzVGV4dDtcblxuICAgICAgICB2YXIgc3RyID0gSlNPTi5zdHJpbmdpZnkoanNvbiksXG4gICAgICAgICAgICByZXMgPSBuZXcgX0V4dGVybmFscy5SZXNwb25zZShzdHIsIGluaXQpO1xuXG4gICAgICAgIHJlcy5oZWFkZXJzLnNldChfQXBpUmVzcG9uc2UyLmRlZmF1bHQuX2NvbnRlbnRUeXBlLCBfQXBpUmVzcG9uc2UyLmRlZmF1bHQuX2pzb25Db250ZW50VHlwZSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1vY2s7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1vY2s7XG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfZXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9BdXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfQXV0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BdXRoKTtcblxudmFyIF9VdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IF9FeHRlcm5hbHMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIF9FeHRlcm5hbHMuUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFBsYXRmb3JtID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoUGxhdGZvcm0sIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgZnVuY3Rpb24gUGxhdGZvcm0oY2xpZW50LCBjYWNoZSwgc2VydmVyLCBhcHBLZXksIGFwcFNlY3JldCwgYXBwTmFtZSwgYXBwVmVyc2lvbiwgc2RrVmVyc2lvbikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxhdGZvcm0pO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMuZXZlbnRzID0ge1xuICAgICAgICAgICAgYmVmb3JlTG9naW46ICdiZWZvcmVMb2dpbicsXG4gICAgICAgICAgICBsb2dpblN1Y2Nlc3M6ICdsb2dpblN1Y2Nlc3MnLFxuICAgICAgICAgICAgbG9naW5FcnJvcjogJ2xvZ2luRXJyb3InLFxuICAgICAgICAgICAgYmVmb3JlUmVmcmVzaDogJ2JlZm9yZVJlZnJlc2gnLFxuICAgICAgICAgICAgcmVmcmVzaFN1Y2Nlc3M6ICdyZWZyZXNoU3VjY2VzcycsXG4gICAgICAgICAgICByZWZyZXNoRXJyb3I6ICdyZWZyZXNoRXJyb3InLFxuICAgICAgICAgICAgYmVmb3JlTG9nb3V0OiAnYmVmb3JlTG9nb3V0JyxcbiAgICAgICAgICAgIGxvZ291dFN1Y2Nlc3M6ICdsb2dvdXRTdWNjZXNzJyxcbiAgICAgICAgICAgIGxvZ291dEVycm9yOiAnbG9nb3V0RXJyb3InXG4gICAgICAgIH07XG5cblxuICAgICAgICBfdGhpcy5fc2VydmVyID0gc2VydmVyO1xuICAgICAgICBfdGhpcy5fYXBwS2V5ID0gYXBwS2V5O1xuICAgICAgICBfdGhpcy5fYXBwU2VjcmV0ID0gYXBwU2VjcmV0O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Q2FjaGV9ICovXG4gICAgICAgIF90aGlzLl9jYWNoZSA9IGNhY2hlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Q2xpZW50fSAqL1xuICAgICAgICBfdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7UHJvbWlzZTxBcGlSZXNwb25zZT59ICovXG4gICAgICAgIF90aGlzLl9yZWZyZXNoUHJvbWlzZSA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMuX2F1dGggPSBuZXcgX0F1dGgyLmRlZmF1bHQoX3RoaXMuX2NhY2hlLCBQbGF0Zm9ybS5fY2FjaGVJZCk7XG5cbiAgICAgICAgX3RoaXMuX3VzZXJBZ2VudCA9IChhcHBOYW1lID8gYXBwTmFtZSArIChhcHBWZXJzaW9uID8gJy8nICsgYXBwVmVyc2lvbiA6ICcnKSArICcgJyA6ICcnKSArICdSQ0pTU0RLLycgKyBzZGtWZXJzaW9uO1xuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtBdXRofVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uIGF1dGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtDbGllbnR9XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5jbGllbnQgPSBmdW5jdGlvbiBjbGllbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWRkU2VydmVyXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hZGRNZXRob2RdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hZGRUb2tlbl1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5jcmVhdGVVcmwgPSBmdW5jdGlvbiBjcmVhdGVVcmwocGF0aCwgb3B0aW9ucykge1xuXG4gICAgICAgIHBhdGggPSBwYXRoIHx8ICcnO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgYnVpbHRVcmwgPSAnJyxcbiAgICAgICAgICAgIGhhc0h0dHAgPSBwYXRoLmluZGV4T2YoJ2h0dHA6Ly8nKSAhPSAtMSB8fCBwYXRoLmluZGV4T2YoJ2h0dHBzOi8vJykgIT0gLTE7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWRkU2VydmVyICYmICFoYXNIdHRwKSBidWlsdFVybCArPSB0aGlzLl9zZXJ2ZXI7XG5cbiAgICAgICAgaWYgKHBhdGguaW5kZXhPZihQbGF0Zm9ybS5fdXJsUHJlZml4KSA9PSAtMSAmJiAhaGFzSHR0cCkgYnVpbHRVcmwgKz0gUGxhdGZvcm0uX3VybFByZWZpeCArICcvJyArIFBsYXRmb3JtLl9hcGlWZXJzaW9uO1xuXG4gICAgICAgIGJ1aWx0VXJsICs9IHBhdGg7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWRkTWV0aG9kIHx8IG9wdGlvbnMuYWRkVG9rZW4pIGJ1aWx0VXJsICs9IHBhdGguaW5kZXhPZignPycpID4gLTEgPyAnJicgOiAnPyc7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWRkTWV0aG9kKSBidWlsdFVybCArPSAnX21ldGhvZD0nICsgb3B0aW9ucy5hZGRNZXRob2Q7XG4gICAgICAgIGlmIChvcHRpb25zLmFkZFRva2VuKSBidWlsdFVybCArPSAob3B0aW9ucy5hZGRNZXRob2QgPyAnJicgOiAnJykgKyAnYWNjZXNzX3Rva2VuPScgKyB0aGlzLl9hdXRoLmFjY2Vzc1Rva2VuKCk7XG5cbiAgICAgICAgcmV0dXJuIGJ1aWx0VXJsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZWRpcmVjdFVyaVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN0YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYnJhbmRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmRpc3BsYXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5wcm9tcHRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUubG9naW5VcmwgPSBmdW5jdGlvbiBsb2dpblVybChvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVXJsKFBsYXRmb3JtLl9hdXRob3JpemVFbmRwb2ludCArICc/JyArICgwLCBfVXRpbHMucXVlcnlTdHJpbmdpZnkpKHtcbiAgICAgICAgICAgICdyZXNwb25zZV90eXBlJzogJ2NvZGUnLFxuICAgICAgICAgICAgJ3JlZGlyZWN0X3VyaSc6IG9wdGlvbnMucmVkaXJlY3RVcmkgfHwgJycsXG4gICAgICAgICAgICAnY2xpZW50X2lkJzogdGhpcy5fYXBwS2V5LFxuICAgICAgICAgICAgJ3N0YXRlJzogb3B0aW9ucy5zdGF0ZSB8fCAnJyxcbiAgICAgICAgICAgICdicmFuZF9pZCc6IG9wdGlvbnMuYnJhbmRJZCB8fCAnJyxcbiAgICAgICAgICAgICdkaXNwbGF5Jzogb3B0aW9ucy5kaXNwbGF5IHx8ICcnLFxuICAgICAgICAgICAgJ3Byb21wdCc6IG9wdGlvbnMucHJvbXB0IHx8ICcnXG4gICAgICAgIH0pLCB7IGFkZFNlcnZlcjogdHJ1ZSB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLnBhcnNlTG9naW5SZWRpcmVjdFVybCA9IGZ1bmN0aW9uIHBhcnNlTG9naW5SZWRpcmVjdFVybCh1cmwpIHtcblxuICAgICAgICB2YXIgcXMgPSAoMCwgX1V0aWxzLnBhcnNlUXVlcnlTdHJpbmcpKHVybC5zcGxpdCgnPycpLnJldmVyc2UoKVswXSksXG4gICAgICAgICAgICBlcnJvciA9IHFzLmVycm9yX2Rlc2NyaXB0aW9uIHx8IHFzLmVycm9yO1xuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgZS5lcnJvciA9IHFzLmVycm9yO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGhhbmRsZSAzLWxlZ2dlZCBPQXV0aFxuICAgICAqXG4gICAgICogQXR0ZW50aW9uISBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBtZXRob2QgYW5kIGl0J3Mgc2lnbmF0dXJlIGFuZCBiZWhhdmlvciBtYXkgY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5sb2dpbl0gYWRkaXRpb25hbCBvcHRpb25zIGZvciBsb2dpbigpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9yaWdpbl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvcGVydHldIG5hbWUgb2Ygd2luZG93LnBvc3RNZXNzYWdlJ3MgZXZlbnQgZGF0YSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50YXJnZXRdIHRhcmdldCBmb3Igd2luZG93Lm9wZW4oKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVybFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5sb2dpbldpbmRvdyA9IGZ1bmN0aW9uIGxvZ2luV2luZG93KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBfRXh0ZXJuYWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgICAgICBpZiAoISgwLCBfVXRpbHMuaXNCcm93c2VyKSgpKSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIG9ubHkgaW4gYnJvd3NlcicpO1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudXJsKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgbWFuZGF0b3J5IFVSTCBwYXJhbWV0ZXInKTtcblxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsIHx8IDQwMDtcbiAgICAgICAgICAgIG9wdGlvbnMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDQwMDtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgNjAwO1xuICAgICAgICAgICAgb3B0aW9ucy5vcmlnaW4gPSBvcHRpb25zLm9yaWdpbiB8fCB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgICAgICAgICAgb3B0aW9ucy5wcm9wZXJ0eSA9IG9wdGlvbnMucHJvcGVydHkgfHwgJ1JDQXV0aG9yaXphdGlvbkNvZGUnO1xuICAgICAgICAgICAgb3B0aW9ucy50YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCAnX2JsYW5rJztcblxuICAgICAgICAgICAgdmFyIGR1YWxTY3JlZW5MZWZ0ID0gd2luZG93LnNjcmVlbkxlZnQgIT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlbkxlZnQgOiBzY3JlZW4ubGVmdDtcbiAgICAgICAgICAgIHZhciBkdWFsU2NyZWVuVG9wID0gd2luZG93LnNjcmVlblRvcCAhPSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuVG9wIDogc2NyZWVuLnRvcDtcblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPyB3aW5kb3cuaW5uZXJXaWR0aCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA6IHNjcmVlbi53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA6IHNjcmVlbi5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBsZWZ0ID0gd2lkdGggLyAyIC0gb3B0aW9ucy53aWR0aCAvIDIgKyBkdWFsU2NyZWVuTGVmdDtcbiAgICAgICAgICAgIHZhciB0b3AgPSBoZWlnaHQgLyAyIC0gb3B0aW9ucy5oZWlnaHQgLyAyICsgZHVhbFNjcmVlblRvcDtcbiAgICAgICAgICAgIHZhciB3aW4gPSB3aW5kb3cub3BlbihvcHRpb25zLnVybCwgJ19ibGFuaycsIG9wdGlvbnMudGFyZ2V0ID09ICdfYmxhbmsnID8gJ3Njcm9sbGJhcnM9eWVzLCBzdGF0dXM9eWVzLCB3aWR0aD0nICsgb3B0aW9ucy53aWR0aCArICcsIGhlaWdodD0nICsgb3B0aW9ucy5oZWlnaHQgKyAnLCBsZWZ0PScgKyBsZWZ0ICsgJywgdG9wPScgKyB0b3AgOiAnJyk7XG5cbiAgICAgICAgICAgIGlmICh3aW5kb3cuZm9jdXMpIHdpbi5mb2N1cygpO1xuXG4gICAgICAgICAgICB2YXIgZXZlbnRNZXRob2QgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdhdHRhY2hFdmVudCc7XG4gICAgICAgICAgICB2YXIgZXZlbnRSZW1vdmVNZXRob2QgPSBldmVudE1ldGhvZCA9PSAnYWRkRXZlbnRMaXN0ZW5lcicgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnZGV0YWNoRXZlbnQnO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VFdmVudCA9IGV2ZW50TWV0aG9kID09ICdhZGRFdmVudExpc3RlbmVyJyA/ICdtZXNzYWdlJyA6ICdvbm1lc3NhZ2UnO1xuXG4gICAgICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIoZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luICE9IG9wdGlvbnMub3JpZ2luKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCFlLmRhdGEgfHwgIWUuZGF0YVtvcHRpb25zLnByb3BlcnR5XSkgcmV0dXJuOyAvLyBrZWVwIHdhaXRpbmdcblxuICAgICAgICAgICAgICAgIHdpbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHdpbmRvd1tldmVudFJlbW92ZU1ldGhvZF0obWVzc2FnZUV2ZW50LCBldmVudExpc3RlbmVyKTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ2luT3B0aW9ucyA9IF90aGlzMi5wYXJzZUxvZ2luUmVkaXJlY3RVcmwoZS5kYXRhW29wdGlvbnMucHJvcGVydHldKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvZ2luT3B0aW9ucy5jb2RlKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGF1dGhvcml6YXRpb24gY29kZScpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobG9naW5PcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB3aW5kb3dbZXZlbnRNZXRob2RdKG1lc3NhZ2VFdmVudCwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmxvZ2dlZEluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTG9nZ2VkSW4oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcywgW1swLCA2XV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbG9nZ2VkSW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvZ2dlZEluO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVzZXJuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5leHRlbnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jb2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucmVkaXJlY3RVcmlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5lbmRwb2ludElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucmVtZW1iZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hY2Nlc3NUb2tlblR0bFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlZnJlc2hUb2tlblR0bFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmxvZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYm9keSwgYXBpUmVzcG9uc2UsIGpzb247XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMuYmVmb3JlTG9naW4pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IHt9O1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuY29kZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuZ3JhbnRfdHlwZSA9ICdwYXNzd29yZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkudXNlcm5hbWUgPSBvcHRpb25zLnVzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LnBhc3N3b3JkID0gb3B0aW9ucy5wYXNzd29yZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5leHRlbnNpb24gPSBvcHRpb25zLmV4dGVuc2lvbiB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY29kZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuZ3JhbnRfdHlwZSA9ICdhdXRob3JpemF0aW9uX2NvZGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LmNvZGUgPSBvcHRpb25zLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkucmVkaXJlY3RfdXJpID0gb3B0aW9ucy5yZWRpcmVjdFVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ib2R5LmNsaWVudF9pZCA9IHRoaXMuZ2V0Q3JlZGVudGlhbHMoKS5rZXk7IC8vIG5vdCBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lbmRwb2ludElkKSBib2R5LmVuZHBvaW50X2lkID0gb3B0aW9ucy5lbmRwb2ludElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFjY2Vzc1Rva2VuVHRsKSBib2R5LmFjY2Vzc1Rva2VuVHRsID0gb3B0aW9ucy5hY2Nlc3NUb2tlblR0bDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZWZyZXNoVG9rZW5UdGwpIGJvZHkucmVmcmVzaFRva2VuVHRsID0gb3B0aW9ucy5yZWZyZXNoVG9rZW5UdGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2tlblJlcXVlc3QoUGxhdGZvcm0uX3Rva2VuRW5kcG9pbnQsIGJvZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IGFwaVJlc3BvbnNlLmpzb24oKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aC5zZXREYXRhKGpzb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmxvZ2luU3VjY2VzcywgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNsZWFuKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMubG9naW5FcnJvciwgX2NvbnRleHQyLnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0Mi50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzAsIDE3XV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbG9naW4oX3gpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvZ2luO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuX3JlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMyA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICAgICAgdmFyIHJlcywganNvbjtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAwO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMuYmVmb3JlUmVmcmVzaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfVXRpbHMuZGVsYXkpKFBsYXRmb3JtLl9yZWZyZXNoRGVsYXlNcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXV0aC5yZWZyZXNoVG9rZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmcmVzaCB0b2tlbiBpcyBtaXNzaW5nJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXV0aC5yZWZyZXNoVG9rZW5WYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZyZXNoIHRva2VuIGhhcyBleHBpcmVkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2tlblJlcXVlc3QoUGxhdGZvcm0uX3Rva2VuRW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJncmFudF90eXBlXCI6IFwicmVmcmVzaF90b2tlblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJlZnJlc2hfdG9rZW5cIjogdGhpcy5fYXV0aC5yZWZyZXNoVG9rZW4oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhY2Nlc3NfdG9rZW5fdHRsXCI6IHRoaXMuX2F1dGguZGF0YSgpLmV4cGlyZXNfaW4gKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJlZnJlc2hfdG9rZW5fdHRsXCI6IHRoaXMuX2F1dGguZGF0YSgpLnJlZnJlc2hfdG9rZW5fZXhwaXJlc19pbiArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gcmVzLmpzb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jbGllbnQubWFrZUVycm9yKG5ldyBFcnJvcignTWFsZm9ybWVkIE9BdXRoIHJlc3BvbnNlJyksIHJlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRoLnNldERhdGEoanNvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMucmVmcmVzaFN1Y2Nlc3MsIHJlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCByZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IHRoaXMuX2NsaWVudC5tYWtlRXJyb3IoX2NvbnRleHQzLnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChQbGF0Zm9ybS5fY2xlYXJDYWNoZU9uUmVmcmVzaEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNsZWFuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLnJlZnJlc2hFcnJvciwgX2NvbnRleHQzLnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0My50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzLCBbWzAsIDE5XV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gX3JlZnJlc2goKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfcmVmcmVzaDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjQgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVmcmVzaFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9yZWZyZXNoUHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDI7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hQcm9taXNlID0gdGhpcy5fcmVmcmVzaCgpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczMuX3JlZnJlc2hQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX3JlZnJlc2hQcm9taXNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQudDAgPSBfY29udGV4dDRbXCJjYXRjaFwiXSgyKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0NC50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzLCBbWzIsIDddXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVmcmVzaDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5sb2dvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmNSA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkge1xuICAgICAgICAgICAgdmFyIHJlcztcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAwO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMuYmVmb3JlTG9nb3V0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5SZXF1ZXN0KFBsYXRmb3JtLl9yZXZva2VFbmRwb2ludCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogdGhpcy5fYXV0aC5hY2Nlc3NUb2tlbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDUuc2VudDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2xlYW4oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5sb2dvdXRTdWNjZXNzLCByZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMubG9nb3V0RXJyb3IsIF9jb250ZXh0NS50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDUudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcywgW1swLCAxMF1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvZ291dDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVxdWVzdD59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5pbmZsYXRlUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY2ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYocmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNraXBBdXRoQ2hlY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCByZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVMb2dnZWRJbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdYLVVzZXItQWdlbnQnLCB0aGlzLl91c2VyQWdlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoJ0NsaWVudC1JZCcsIHRoaXMuX2FwcEtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIHRoaXMuX2F1dGhIZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXF1ZXN0LnVybCA9IHRoaXMuY3JlYXRlVXJsKHJlcXVlc3QudXJsLCB7YWRkU2VydmVyOiB0cnVlfSk7IC8vRklYTUUgU3BlYyBwcmV2ZW50cyB0aGlzLi4uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCByZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlcXVlc3QoX3gyLCBfeDMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZmxhdGVSZXF1ZXN0O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY3ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcocmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluZmxhdGVSZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ3LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1tcImNhdGNoXCJdKDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoIV9jb250ZXh0Ny50MC5hcGlSZXNwb25zZSB8fCAhX2NvbnRleHQ3LnQwLmFwaVJlc3BvbnNlLnJlc3BvbnNlKCkgfHwgX2NvbnRleHQ3LnQwLmFwaVJlc3BvbnNlLnJlc3BvbnNlKCkuc3RhdHVzICE9IDQwMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ3LnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aC5jYW5jZWxBY2Nlc3NUb2tlbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDcuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlNywgdGhpcywgW1swLCA5XV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2VuZFJlcXVlc3QoX3g0LCBfeDUpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmNy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbmRSZXF1ZXN0O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYWwgcHVycG9zZSBmdW5jdGlvbiB0byBzZW5kIGFueXRoaW5nIHRvIHNlcnZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVybFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5ib2R5XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tZXRob2RdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnF1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEF1dGhDaGVja11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmOCA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0ZJWE1FIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRpbm4vbm9kZS1mZXRjaC9pc3N1ZXMvNDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IHRoaXMuY3JlYXRlVXJsKG9wdGlvbnMudXJsLCB7IGFkZFNlcnZlcjogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh0aGlzLl9jbGllbnQuY3JlYXRlUmVxdWVzdChvcHRpb25zKSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDguc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWU4LCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNlbmQoX3g2KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZW5kO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3F1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmOSA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KHVybCwgcXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDkuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWU5LCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldChfeDgsIF94OSwgX3gxMCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWY5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcXVlcnldXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEF1dGhDaGVja11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMTAgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAodXJsLCBib2R5LCBxdWVyeSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxMCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnUE9TVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0MTAuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMTAsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gcG9zdChfeDExLCBfeDEyLCBfeDEzLCBfeDE0KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjEwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtib2R5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcXVlcnldXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEF1dGhDaGVja11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYxMSA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMSh1cmwsIGJvZHksIHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDExLnByZXYgPSBfY29udGV4dDExLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1ldGhvZCA9ICdQVVQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDExLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTExLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHB1dChfeDE1LCBfeDE2LCBfeDE3LCBfeDE4KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjExLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHV0O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3F1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMTIgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTIodXJsLCBxdWVyeSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMi5wcmV2ID0gX2NvbnRleHQxMi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0MTIuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMTIsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gX2RlbGV0ZShfeDE5LCBfeDIwLCBfeDIxKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjEyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2RlbGV0ZTtcbiAgICB9KCk7XG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuX3Rva2VuUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYxMyA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMyhwYXRoLCBib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEzJChfY29udGV4dDEzKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEzLnByZXYgPSBfY29udGV4dDEzLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBBdXRoQ2hlY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCYXNpYyAnICsgdGhpcy5fYXBpS2V5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0MTMuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMTMsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gX3Rva2VuUmVxdWVzdChfeDIyLCBfeDIzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjEzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3Rva2VuUmVxdWVzdDtcbiAgICB9KCk7XG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuZW5zdXJlTG9nZ2VkSW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMTQgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE0JChfY29udGV4dDE0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE0LnByZXYgPSBfY29udGV4dDE0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzQWNjZXNzVG9rZW5WYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0MTQuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMTQsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZW5zdXJlTG9nZ2VkSW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjE0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW5zdXJlTG9nZ2VkSW47XG4gICAgfSgpO1xuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLl9pc0FjY2Vzc1Rva2VuVmFsaWQgPSBmdW5jdGlvbiBfaXNBY2Nlc3NUb2tlblZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0aC5hY2Nlc3NUb2tlblZhbGlkKCk7XG4gICAgfTtcblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5fYXBpS2V5ID0gZnVuY3Rpb24gX2FwaUtleSgpIHtcbiAgICAgICAgdmFyIGFwaUtleSA9IHRoaXMuX2FwcEtleSArICc6JyArIHRoaXMuX2FwcFNlY3JldDtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBidG9hID09ICdmdW5jdGlvbicgPyBidG9hKGFwaUtleSkgOiBuZXcgQnVmZmVyKGFwaUtleSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH07XG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuX2F1dGhIZWFkZXIgPSBmdW5jdGlvbiBfYXV0aEhlYWRlcigpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy5fYXV0aC5hY2Nlc3NUb2tlbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0aC50b2tlblR5cGUoKSArICh0b2tlbiA/ICcgJyArIHRva2VuIDogJycpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGxhdGZvcm07XG59KF9ldmVudHMyLmRlZmF1bHQpO1xuXG5QbGF0Zm9ybS5fdXJsUHJlZml4ID0gJy9yZXN0YXBpJztcblBsYXRmb3JtLl9hcGlWZXJzaW9uID0gJ3YxLjAnO1xuUGxhdGZvcm0uX3Rva2VuRW5kcG9pbnQgPSAnL3Jlc3RhcGkvb2F1dGgvdG9rZW4nO1xuUGxhdGZvcm0uX3Jldm9rZUVuZHBvaW50ID0gJy9yZXN0YXBpL29hdXRoL3Jldm9rZSc7XG5QbGF0Zm9ybS5fYXV0aG9yaXplRW5kcG9pbnQgPSAnL3Jlc3RhcGkvb2F1dGgvYXV0aG9yaXplJztcblBsYXRmb3JtLl9yZWZyZXNoRGVsYXlNcyA9IDEwMDtcblBsYXRmb3JtLl9jYWNoZUlkID0gJ3BsYXRmb3JtJztcblBsYXRmb3JtLl9jbGVhckNhY2hlT25SZWZyZXNoRXJyb3IgPSBmYWxzZTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBsYXRmb3JtO1xuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBdXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1dGgoY2FjaGUsIGNhY2hlSWQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF1dGgpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Q2FjaGV9ICovXG4gICAgICAgIHRoaXMuX2NhY2hlID0gY2FjaGU7XG4gICAgICAgIHRoaXMuX2NhY2hlSWQgPSBjYWNoZUlkO1xuICAgIH0gLy8gMSBtaW51dGVcblxuXG4gICAgQXV0aC5wcm90b3R5cGUuYWNjZXNzVG9rZW4gPSBmdW5jdGlvbiBhY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpLmFjY2Vzc190b2tlbjtcbiAgICB9O1xuXG4gICAgQXV0aC5wcm90b3R5cGUucmVmcmVzaFRva2VuID0gZnVuY3Rpb24gcmVmcmVzaFRva2VuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCkucmVmcmVzaF90b2tlbjtcbiAgICB9O1xuXG4gICAgQXV0aC5wcm90b3R5cGUudG9rZW5UeXBlID0gZnVuY3Rpb24gdG9rZW5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCkudG9rZW5fdHlwZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7e3Rva2VuX3R5cGU6IHN0cmluZywgYWNjZXNzX3Rva2VuOiBzdHJpbmcsIGV4cGlyZXNfaW46IG51bWJlciwgcmVmcmVzaF90b2tlbjogc3RyaW5nLCByZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW46IG51bWJlcn19XG4gICAgICovXG5cblxuICAgIEF1dGgucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiBkYXRhKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5nZXRJdGVtKHRoaXMuX2NhY2hlSWQpIHx8IHtcbiAgICAgICAgICAgIHRva2VuX3R5cGU6ICcnLFxuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiAnJyxcbiAgICAgICAgICAgIGV4cGlyZXNfaW46IDAsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiAnJyxcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW5fZXhwaXJlc19pbjogMFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3RGF0YVxuICAgICAqIEByZXR1cm4ge0F1dGh9XG4gICAgICovXG5cblxuICAgIEF1dGgucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiBzZXREYXRhKG5ld0RhdGEpIHtcblxuICAgICAgICBuZXdEYXRhID0gbmV3RGF0YSB8fCB7fTtcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSgpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG5ld0RhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZGF0YVtrZXldID0gbmV3RGF0YVtrZXldO1xuICAgICAgICB9KTtcblxuICAgICAgICBkYXRhLmV4cGlyZV90aW1lID0gRGF0ZS5ub3coKSArIGRhdGEuZXhwaXJlc19pbiAqIDEwMDA7XG4gICAgICAgIGRhdGEucmVmcmVzaF90b2tlbl9leHBpcmVfdGltZSA9IERhdGUubm93KCkgKyBkYXRhLnJlZnJlc2hfdG9rZW5fZXhwaXJlc19pbiAqIDEwMDA7XG5cbiAgICAgICAgdGhpcy5fY2FjaGUuc2V0SXRlbSh0aGlzLl9jYWNoZUlkLCBkYXRhKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlcmUgaXMgYSB2YWxpZCAobm90IGV4cGlyZWQpIGFjY2VzcyB0b2tlblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cblxuICAgIEF1dGgucHJvdG90eXBlLmFjY2Vzc1Rva2VuVmFsaWQgPSBmdW5jdGlvbiBhY2Nlc3NUb2tlblZhbGlkKCkge1xuXG4gICAgICAgIHZhciBhdXRoRGF0YSA9IHRoaXMuZGF0YSgpO1xuICAgICAgICByZXR1cm4gYXV0aERhdGEudG9rZW5fdHlwZSA9PT0gQXV0aC5mb3JjZWRUb2tlblR5cGUgfHwgYXV0aERhdGEuZXhwaXJlX3RpbWUgLSBBdXRoLnJlZnJlc2hIYW5kaWNhcE1zID4gRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlcmUgaXMgYSB2YWxpZCAobm90IGV4cGlyZWQpIGFjY2VzcyB0b2tlblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cblxuICAgIEF1dGgucHJvdG90eXBlLnJlZnJlc2hUb2tlblZhbGlkID0gZnVuY3Rpb24gcmVmcmVzaFRva2VuVmFsaWQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpLnJlZnJlc2hfdG9rZW5fZXhwaXJlX3RpbWUgPiBEYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtBdXRofVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5jYW5jZWxBY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uIGNhbmNlbEFjY2Vzc1Rva2VuKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldERhdGEoe1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiAnJyxcbiAgICAgICAgICAgIGV4cGlyZXNfaW46IDBcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgYSBzcGVjaWFsIGF1dGhlbnRpY2F0aW9uIG1vZGUgdXNlZCBpbiBTZXJ2aWNlIFdlYlxuICAgICAqIEByZXR1cm4ge0F1dGh9XG4gICAgICovXG5cblxuICAgIEF1dGgucHJvdG90eXBlLmZvcmNlQXV0aGVudGljYXRpb24gPSBmdW5jdGlvbiBmb3JjZUF1dGhlbnRpY2F0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgICB0b2tlbl90eXBlOiBBdXRoLmZvcmNlZFRva2VuVHlwZSxcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogJycsXG4gICAgICAgICAgICBleHBpcmVzX2luOiAwLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogJycsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW46IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBBdXRoO1xufSgpO1xuXG4vL2V4cG9ydCBpbnRlcmZhY2UgSUF1dGhEYXRhIHtcbi8vICAgIHJlbWVtYmVyPzpib29sZWFuO1xuLy8gICAgdG9rZW5fdHlwZT86c3RyaW5nO1xuLy8gICAgYWNjZXNzX3Rva2VuPzpzdHJpbmc7XG4vLyAgICBleHBpcmVzX2luPzpudW1iZXI7IC8vIGFjdHVhbGx5IGl0J3Mgc3RyaW5nXG4vLyAgICBleHBpcmVfdGltZT86bnVtYmVyO1xuLy8gICAgcmVmcmVzaF90b2tlbj86c3RyaW5nO1xuLy8gICAgcmVmcmVzaF90b2tlbl9leHBpcmVzX2luPzpudW1iZXI7IC8vIGFjdHVhbGx5IGl0J3Mgc3RyaW5nXG4vLyAgICByZWZyZXNoX3Rva2VuX2V4cGlyZV90aW1lPzpudW1iZXI7XG4vLyAgICBzY29wZT86c3RyaW5nO1xuLy99XG5cblxuQXV0aC5yZWZyZXNoSGFuZGljYXBNcyA9IDYwICogMTAwMDtcbkF1dGguZm9yY2VkVG9rZW5UeXBlID0gJ2ZvcmNlZCc7XG5leHBvcnRzLmRlZmF1bHQgPSBBdXRoO1xuXG4vKioqLyB9LFxuLyogMTcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUHVibnViTW9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG52YXIgX1B1Ym51Yk1vY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHVibnViTW9jayk7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFB1Ym51Yk1vY2tGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFB1Ym51Yk1vY2tGYWN0b3J5KCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHVibnViTW9ja0ZhY3RvcnkpO1xuXG4gICAgICAgIHRoaXMuY3J5cHRvX29iaiA9IF9FeHRlcm5hbHMuUFVCTlVCLmNyeXB0b19vYmo7XG4gICAgfVxuXG4gICAgUHVibnViTW9ja0ZhY3RvcnkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfUHVibnViTW9jazIuZGVmYXVsdChvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFB1Ym51Yk1vY2tGYWN0b3J5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQdWJudWJNb2NrRmFjdG9yeTtcblxuLyoqKi8gfSxcbi8qIDE4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBQdWJudWJNb2NrID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoUHVibnViTW9jaywgX0V2ZW50RW1pdHRlcik7XG5cbiAgICBmdW5jdGlvbiBQdWJudWJNb2NrKG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFB1Ym51Yk1vY2spO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIF90aGlzLmNyeXB0b19vYmogPSBfRXh0ZXJuYWxzLlBVQk5VQi5jcnlwdG9fb2JqO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgUHVibnViTW9jay5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH07XG5cbiAgICBQdWJudWJNb2NrLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIHJlYWR5KCkge307XG5cbiAgICBQdWJudWJNb2NrLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiBzdWJzY3JpYmUob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9uKCdtZXNzYWdlLScgKyBvcHRpb25zLmNoYW5uZWwsIG9wdGlvbnMubWVzc2FnZSk7XG4gICAgfTtcblxuICAgIFB1Ym51Yk1vY2sucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUob3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnbWVzc2FnZS0nICsgb3B0aW9ucy5jaGFubmVsKTtcbiAgICB9O1xuXG4gICAgUHVibnViTW9jay5wcm90b3R5cGUucmVjZWl2ZU1lc3NhZ2UgPSBmdW5jdGlvbiByZWNlaXZlTWVzc2FnZShtc2csIGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlLScgKyBjaGFubmVsLCBtc2csICdlbnYnLCBjaGFubmVsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFB1Ym51Yk1vY2s7XG59KF9ldmVudHMyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQdWJudWJNb2NrO1xuXG4vKioqLyB9LFxuLyogMTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAgIF9pbmhlcml0cyhTdWJzY3JpcHRpb24sIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHB1Ym51YkZhY3RvcnksIHBsYXRmb3JtKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzY3JpcHRpb24pO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMuZXZlbnRzID0ge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uOiAnbm90aWZpY2F0aW9uJyxcbiAgICAgICAgICAgIHJlbW92ZVN1Y2Nlc3M6ICdyZW1vdmVTdWNjZXNzJyxcbiAgICAgICAgICAgIHJlbW92ZUVycm9yOiAncmVtb3ZlRXJyb3InLFxuICAgICAgICAgICAgcmVuZXdTdWNjZXNzOiAncmVuZXdTdWNjZXNzJyxcbiAgICAgICAgICAgIHJlbmV3RXJyb3I6ICdyZW5ld0Vycm9yJyxcbiAgICAgICAgICAgIHN1YnNjcmliZVN1Y2Nlc3M6ICdzdWJzY3JpYmVTdWNjZXNzJyxcbiAgICAgICAgICAgIHN1YnNjcmliZUVycm9yOiAnc3Vic2NyaWJlRXJyb3InXG4gICAgICAgIH07XG5cblxuICAgICAgICBfdGhpcy5fcHVibnViRmFjdG9yeSA9IHB1Ym51YkZhY3Rvcnk7XG4gICAgICAgIF90aGlzLl9wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICBfdGhpcy5fcHVibnViID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3B1Ym51Ykxhc3RDaGFubmVsID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9uID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmVkID0gZnVuY3Rpb24gc3Vic2NyaWJlZCgpIHtcblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpcHRpb24oKTtcblxuICAgICAgICByZXR1cm4gISEoc3Vic2NyaXB0aW9uLmlkICYmIHN1YnNjcmlwdGlvbi5kZWxpdmVyeU1vZGUgJiYgc3Vic2NyaXB0aW9uLmRlbGl2ZXJ5TW9kZS5zdWJzY3JpYmVyS2V5ICYmIHN1YnNjcmlwdGlvbi5kZWxpdmVyeU1vZGUuYWRkcmVzcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWxpdmUgPSBmdW5jdGlvbiBhbGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlZCgpICYmIERhdGUubm93KCkgPCB0aGlzLmV4cGlyYXRpb25UaW1lKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZXhwaXJlZCA9IGZ1bmN0aW9uIGV4cGlyZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpYmVkKCkpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gIXRoaXMuc3Vic2NyaWJlZCgpIHx8IERhdGUubm93KCkgPiB0aGlzLnN1YnNjcmlwdGlvbigpLmV4cGlyYXRpb25UaW1lO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmV4cGlyYXRpb25UaW1lID0gZnVuY3Rpb24gZXhwaXJhdGlvblRpbWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnN1YnNjcmlwdGlvbigpLmV4cGlyYXRpb25UaW1lIHx8IDApLmdldFRpbWUoKSAtIFN1YnNjcmlwdGlvbi5fcmVuZXdIYW5kaWNhcE1zO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnNldFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIHtcblxuICAgICAgICBzdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb24gfHwge307XG5cbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVBdFB1Ym51YigpO1xuICAgICAgICB0aGlzLl9zZXRUaW1lb3V0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gc3Vic2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaXB0aW9uIHx8IHt9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9yIHVwZGF0ZXMgc3Vic2NyaXB0aW9uIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBvbmVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWxpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZXcoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnaXN0ZXI7XG4gICAgfSgpO1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5ldmVudEZpbHRlcnMgPSBmdW5jdGlvbiBldmVudEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbigpLmV2ZW50RmlsdGVycyB8fCBbXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnRzXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZEV2ZW50RmlsdGVycyA9IGZ1bmN0aW9uIGFkZEV2ZW50RmlsdGVycyhldmVudHMpIHtcbiAgICAgICAgdGhpcy5zZXRFdmVudEZpbHRlcnModGhpcy5ldmVudEZpbHRlcnMoKS5jb25jYXQoZXZlbnRzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBldmVudHNcbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259XG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc2V0RXZlbnRGaWx0ZXJzID0gZnVuY3Rpb24gc2V0RXZlbnRGaWx0ZXJzKGV2ZW50cykge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpcHRpb24oKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmV2ZW50RmlsdGVycyA9IGV2ZW50cztcbiAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSwganNvbjtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50RmlsdGVycygpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRzIGFyZSB1bmRlZmluZWQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxhdGZvcm0ucG9zdCgnL3N1YnNjcmlwdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRGaWx0ZXJzOiB0aGlzLl9nZXRGdWxsRXZlbnRGaWx0ZXJzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJ5TW9kZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0VHlwZTogJ1B1Yk51YidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gcmVzcG9uc2UuanNvbigpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN1YnNjcmlwdGlvbihqc29uKS5lbWl0KHRoaXMuZXZlbnRzLnN1YnNjcmliZVN1Y2Nlc3MsIHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCdyZXR1cm4nLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbJ2NhdGNoJ10oMCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IHRoaXMuX3BsYXRmb3JtLmNsaWVudCgpLm1ha2VFcnJvcihfY29udGV4dDIudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpLmVtaXQodGhpcy5ldmVudHMuc3Vic2NyaWJlRXJyb3IsIF9jb250ZXh0Mi50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDIudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMsIFtbMCwgMTJdXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBzdWJzY3JpYmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJzY3JpYmU7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlbmV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSwganNvbjtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAwO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3Vic2NyaXB0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEZpbHRlcnMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50cyBhcmUgdW5kZWZpbmVkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtLnB1dCgnL3N1YnNjcmlwdGlvbi8nICsgdGhpcy5zdWJzY3JpcHRpb24oKS5pZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEZpbHRlcnM6IHRoaXMuX2dldEZ1bGxFdmVudEZpbHRlcnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gcmVzcG9uc2UuanNvbigpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN1YnNjcmlwdGlvbihqc29uKS5lbWl0KHRoaXMuZXZlbnRzLnJlbmV3U3VjY2VzcywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoJ3JldHVybicsIHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1snY2F0Y2gnXSgwKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gdGhpcy5fcGxhdGZvcm0uY2xpZW50KCkubWFrZUVycm9yKF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCkuZW1pdCh0aGlzLmV2ZW50cy5yZW5ld0Vycm9yLCBfY29udGV4dDMudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQzLnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzLCBbWzAsIDE0XV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVuZXcoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5ldztcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjQgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaWJlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWJzY3JpcHRpb24nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxhdGZvcm0uZGVsZXRlKCcvc3Vic2NyaXB0aW9uLycgKyB0aGlzLnN1YnNjcmlwdGlvbigpLmlkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQ0LnNlbnQ7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKS5lbWl0KHRoaXMuZXZlbnRzLnJlbW92ZVN1Y2Nlc3MsIHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQudDAgPSBfY29udGV4dDRbJ2NhdGNoJ10oMCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IHRoaXMuX3BsYXRmb3JtLmNsaWVudCgpLm1ha2VFcnJvcihfY29udGV4dDQudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLnJlbW92ZUVycm9yLCBfY29udGV4dDQudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ0LnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzLCBbWzAsIDEwXV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVtb3ZlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZXN1YnNjcmliZSA9IGZ1bmN0aW9uIHJlc3Vic2NyaWJlKCkge1xuICAgICAgICB2YXIgZmlsdGVycyA9IHRoaXMuZXZlbnRGaWx0ZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2V0KCkuc2V0RXZlbnRGaWx0ZXJzKGZpbHRlcnMpLnN1YnNjcmliZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc3Vic2NyaXB0aW9uIGFuZCBkaXNjb25uZWN0IGZyb20gUFVCTlVCXG4gICAgICogVGhpcyBtZXRob2QgcmVzZXRzIHN1YnNjcmlwdGlvbiBhdCBjbGllbnQgc2lkZSBidXQgYmFja2VuZCBpcyBub3Qgbm90aWZpZWRcbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaWJlZCgpICYmIHRoaXMuX3B1Ym51YikgdGhpcy5fcHVibnViLnVuc3Vic2NyaWJlKHsgY2hhbm5lbDogdGhpcy5zdWJzY3JpcHRpb24oKS5kZWxpdmVyeU1vZGUuYWRkcmVzcyB9KTtcbiAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKG51bGwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fc2V0U3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gX3NldFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9nZXRGdWxsRXZlbnRGaWx0ZXJzID0gZnVuY3Rpb24gX2dldEZ1bGxFdmVudEZpbHRlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50RmlsdGVycygpLm1hcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX3BsYXRmb3JtLmNyZWF0ZVVybChldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9zZXRUaW1lb3V0ID0gZnVuY3Rpb24gX3NldFRpbWVvdXQoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuXG4gICAgICAgIGlmICghdGhpcy5hbGl2ZSgpKSB0aHJvdyBuZXcgRXJyb3IoJ1N1YnNjcmlwdGlvbiBpcyBub3QgYWxpdmUnKTtcblxuICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMzLmFsaXZlKCkpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKF90aGlzMy5leHBpcmVkKCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzMy5yZW5ldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBTdWJzY3JpcHRpb24uX3BvbGxJbnRlcnZhbCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX2NsZWFyVGltZW91dCA9IGZ1bmN0aW9uIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fdGltZW91dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9kZWNyeXB0ID0gZnVuY3Rpb24gX2RlY3J5cHQobWVzc2FnZSkge1xuXG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpYmVkKCkpIHRocm93IG5ldyBFcnJvcignTm8gc3Vic2NyaXB0aW9uJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKCkuZGVsaXZlcnlNb2RlLmVuY3J5cHRpb25LZXkpIHtcblxuICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMuX3B1Ym51YkZhY3RvcnkuY3J5cHRvX29iai5kZWNyeXB0KG1lc3NhZ2UsIHRoaXMuc3Vic2NyaXB0aW9uKCkuZGVsaXZlcnlNb2RlLmVuY3J5cHRpb25LZXksIHtcbiAgICAgICAgICAgICAgICBlbmNyeXB0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBrZXlFbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICAgICAgICAgICAga2V5TGVuZ3RoOiAxMjgsXG4gICAgICAgICAgICAgICAgbW9kZTogJ2VjYidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX25vdGlmeSA9IGZ1bmN0aW9uIF9ub3RpZnkobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMubm90aWZpY2F0aW9uLCB0aGlzLl9kZWNyeXB0KG1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3N1YnNjcmliZUF0UHVibnViID0gZnVuY3Rpb24gX3N1YnNjcmliZUF0UHVibnViKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5hbGl2ZSgpKSB0aHJvdyBuZXcgRXJyb3IoJ1N1YnNjcmlwdGlvbiBpcyBub3QgYWxpdmUnKTtcblxuICAgICAgICB2YXIgZGVsaXZlcnlNb2RlID0gdGhpcy5zdWJzY3JpcHRpb24oKS5kZWxpdmVyeU1vZGU7XG5cbiAgICAgICAgaWYgKHRoaXMuX3B1Ym51Yikge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fcHVibnViTGFzdENoYW5uZWwgPT0gZGVsaXZlcnlNb2RlLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIHVwZGF0ZSwga2VlcCBsaXN0ZW5pbmcgdG8gc2FtZSBjaGFubmVsXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3B1Ym51Ykxhc3RDaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBzdWJzY3JpYmUgdG8gbmV3IGNoYW5uZWxcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJudWIudW5zdWJzY3JpYmUoeyBjaGFubmVsOiB0aGlzLl9wdWJudWJMYXN0Q2hhbm5lbCB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmUtaW5pdCBmb3IgbmV3IGRhdGFcbiAgICAgICAgICAgIHRoaXMuX3B1Ym51YiA9IHRoaXMuX3B1Ym51Yi5pbml0KHtcbiAgICAgICAgICAgICAgICBzc2w6IHRydWUsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlX2tleTogZGVsaXZlcnlNb2RlLnN1YnNjcmliZXJLZXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBJbml0IGZyb20gc2NyYXRjaFxuICAgICAgICAgICAgdGhpcy5fcHVibnViID0gdGhpcy5fcHVibnViRmFjdG9yeS5pbml0KHtcbiAgICAgICAgICAgICAgICBzc2w6IHRydWUsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlX2tleTogZGVsaXZlcnlNb2RlLnN1YnNjcmliZXJLZXlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9wdWJudWIucmVhZHkoKTsgLy9UT0RPIFRoaXMgbWF5IGJlIG5vdCBuZWVkZWQgYW55bW9yZVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHVibnViTGFzdENoYW5uZWwgPSBkZWxpdmVyeU1vZGUuYWRkcmVzcztcblxuICAgICAgICB0aGlzLl9wdWJudWIuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIGNoYW5uZWw6IGRlbGl2ZXJ5TW9kZS5hZGRyZXNzLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5fbm90aWZ5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBjb25uZWN0OiBmdW5jdGlvbiBjb25uZWN0KCkge31cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBTdWJzY3JpcHRpb247XG59KF9ldmVudHMyLmRlZmF1bHQpO1xuXG4vL2V4cG9ydCBpbnRlcmZhY2UgSVN1YnNjcmlwdGlvbiB7XG4vLyAgICBpZD86c3RyaW5nO1xuLy8gICAgdXJpPzogc3RyaW5nO1xuLy8gICAgZXZlbnRGaWx0ZXJzPzpzdHJpbmdbXTtcbi8vICAgIGV4cGlyYXRpb25UaW1lPzpzdHJpbmc7IC8vIDIwMTQtMDMtMTJUMTk6NTQ6MzUuNjEzWlxuLy8gICAgZXhwaXJlc0luPzpudW1iZXI7XG4vLyAgICBkZWxpdmVyeU1vZGU/OiB7XG4vLyAgICAgICAgdHJhbnNwb3J0VHlwZT86c3RyaW5nO1xuLy8gICAgICAgIGVuY3J5cHRpb24/OmJvb2xlYW47XG4vLyAgICAgICAgYWRkcmVzcz86c3RyaW5nO1xuLy8gICAgICAgIHN1YnNjcmliZXJLZXk/OnN0cmluZztcbi8vICAgICAgICBlbmNyeXB0aW9uS2V5PzpzdHJpbmc7XG4vLyAgICAgICAgc2VjcmV0S2V5PzpzdHJpbmc7XG4vLyAgICB9O1xuLy8gICAgY3JlYXRpb25UaW1lPzpzdHJpbmc7IC8vIDIwMTQtMDMtMTJUMTk6NTQ6MzUuNjEzWlxuLy8gICAgc3RhdHVzPzpzdHJpbmc7IC8vIEFjdGl2ZVxuLy99XG5cblxuU3Vic2NyaXB0aW9uLl9yZW5ld0hhbmRpY2FwTXMgPSAyICogNjAgKiAxMDAwO1xuU3Vic2NyaXB0aW9uLl9wb2xsSW50ZXJ2YWwgPSAxMCAqIDEwMDA7XG5leHBvcnRzLmRlZmF1bHQgPSBTdWJzY3JpcHRpb247XG5cbi8qKiovIH0sXG4vKiAyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1N1YnNjcmlwdGlvbjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxudmFyIF9TdWJzY3JpcHRpb24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3Vic2NyaXB0aW9uMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENhY2hlZFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChfU3Vic2NyaXB0aW9uKSB7XG4gICAgX2luaGVyaXRzKENhY2hlZFN1YnNjcmlwdGlvbiwgX1N1YnNjcmlwdGlvbik7XG5cbiAgICBmdW5jdGlvbiBDYWNoZWRTdWJzY3JpcHRpb24ocHVibnViRmFjdG9yeSwgcGxhdGZvcm0sIGNhY2hlLCBjYWNoZUtleSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FjaGVkU3Vic2NyaXB0aW9uKTtcblxuICAgICAgICAvKiogQHR5cGUge0NhY2hlfSAqL1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9TdWJzY3JpcHRpb24uY2FsbCh0aGlzLCBwdWJudWJGYWN0b3J5LCBwbGF0Zm9ybSkpO1xuXG4gICAgICAgIF90aGlzLl9jYWNoZSA9IGNhY2hlO1xuICAgICAgICBfdGhpcy5fY2FjaGVLZXkgPSBjYWNoZUtleTtcblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgQ2FjaGVkU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5zdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBzdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5nZXRJdGVtKHRoaXMuX2NhY2hlS2V5KSB8fCB7fTtcbiAgICB9O1xuXG4gICAgQ2FjaGVkU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fc2V0U3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gX3NldFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLnNldEl0ZW0odGhpcy5fY2FjaGVLZXksIHN1YnNjcmlwdGlvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBwcmUtZGVmaW5lZCBldmVudEZpbHRlcnMgaW4gY2FjaGUgYW5kIGlmIG5vdCAtLSB1c2VzIHByb3ZpZGVkIGFzIGRlZmF1bHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnRzXG4gICAgICogQHJldHVybiB7Q2FjaGVkU3Vic2NyaXB0aW9ufVxuICAgICAqL1xuXG5cbiAgICBDYWNoZWRTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKGV2ZW50cykge1xuXG4gICAgICAgIGlmICghdGhpcy5ldmVudEZpbHRlcnMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXZlbnRGaWx0ZXJzKGV2ZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhY2hlZFN1YnNjcmlwdGlvbjtcbn0oX1N1YnNjcmlwdGlvbjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhY2hlZFN1YnNjcmlwdGlvbjtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmluZ2NlbnRyYWwuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmluZ2NlbnRyYWwvYnVpbGQvcmluZ2NlbnRyYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbn0gKCkpXG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBjYWNoZWRTZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBTYWZhcmkgNS03IGxhY2tzIHN1cHBvcnQgZm9yIGNoYW5naW5nIHRoZSBgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgcHJvcGVydHlcbiAqICAgICBvbiBvYmplY3RzLlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgZnVuY3Rpb24gQmFyICgpIHt9XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICBhcnIuY29uc3RydWN0b3IgPSBCYXJcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICBhcnIuY29uc3RydWN0b3IgPT09IEJhciAmJiAvLyBjb25zdHJ1Y3RvciBjYW4gYmUgc2V0XG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIC8vIEF2b2lkIGdvaW5nIHRocm91Z2ggYW4gQXJndW1lbnRzQWRhcHRvclRyYW1wb2xpbmUgaW4gdGhlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBhcmd1bWVudHNbMV0pXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnKVxuICB9XG5cbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXMubGVuZ3RoID0gMFxuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcywgYXJnKVxuICB9XG5cbiAgLy8gU2xpZ2h0bHkgbGVzcyBjb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhpcywgYXJnLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6ICd1dGY4JylcbiAgfVxuXG4gIC8vIFVudXN1YWwuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoaXMsIGFyZylcbn1cblxuZnVuY3Rpb24gZnJvbU51bWJlciAodGhhdCwgbGVuZ3RoKSB7XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGggPCAwID8gMCA6IGNoZWNrZWQobGVuZ3RoKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgZW5jb2RpbmcgPSAndXRmOCdcblxuICAvLyBBc3N1bXB0aW9uOiBieXRlTGVuZ3RoKCkgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyA8IGtNYXhMZW5ndGguXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIGZyb21CdWZmZXIodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHJldHVybiBmcm9tQXJyYXkodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKG9iamVjdC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIG9iamVjdClcbiAgICB9XG4gIH1cblxuICBpZiAob2JqZWN0Lmxlbmd0aCkgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqZWN0KVxuXG4gIHJldHVybiBmcm9tSnNvbk9iamVjdCh0aGF0LCBvYmplY3QpXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKHRoYXQsIGJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChidWZmZXIubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgYnVmZmVyLmNvcHkodGhhdCwgMCwgMCwgbGVuZ3RoKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEdXBsaWNhdGUgb2YgZnJvbUFycmF5KCkgdG8ga2VlcCBmcm9tQXJyYXkoKSBtb25vbW9ycGhpYy5cbmZ1bmN0aW9uIGZyb21UeXBlZEFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICAvLyBUcnVuY2F0aW5nIHRoZSBlbGVtZW50cyBpcyBwcm9iYWJseSBub3Qgd2hhdCBwZW9wbGUgZXhwZWN0IGZyb20gdHlwZWRcbiAgLy8gYXJyYXlzIHdpdGggQllURVNfUEVSX0VMRU1FTlQgPiAxIGJ1dCBpdCdzIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3JcbiAgLy8gb2YgdGhlIG9sZCBCdWZmZXIgY29uc3RydWN0b3IuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5KSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGFycmF5LmJ5dGVMZW5ndGhcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21UeXBlZEFycmF5KHRoYXQsIG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRGVzZXJpYWxpemUgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWzEsMiwzLC4uLl0gfSBpbnRvIGEgQnVmZmVyIG9iamVjdC5cbi8vIFJldHVybnMgYSB6ZXJvLWxlbmd0aCBidWZmZXIgZm9yIGlucHV0cyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gdGhlIHNwZWMuXG5mdW5jdGlvbiBmcm9tSnNvbk9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIHZhciBhcnJheVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIGlmIChvYmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmplY3QuZGF0YSkpIHtcbiAgICBhcnJheSA9IG9iamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB9XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG59IGVsc2Uge1xuICAvLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuICBCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuICBCdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZSAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGF0Ll9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBmcm9tUG9vbCA9IGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplID4+PiAxXG4gIGlmIChmcm9tUG9vbCkgdGhhdC5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2xvd0J1ZmZlcikpIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcbiAgZGVsZXRlIGJ1Zi5wYXJlbnRcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgdmFyIGkgPSAwXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSBicmVha1xuXG4gICAgKytpXG4gIH1cblxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgc3RyaW5nID0gJycgKyBzdHJpbmdcblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aCB8IDBcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuaW5kZXhPZiA9IEJQLmluZGV4T2ZcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9idWZmZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFzZTY0LWpzL2xpYi9iNjQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaWVlZTc1NC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pc2FycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vamFrZWFyY2hpYmFsZC9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICAzLjIuMVxuICovXG5cbihmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzTWF5YmVUaGVuYWJsZSh4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkgPSBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID0gMDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJHZlcnR4TmV4dDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuO1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbl0gPSBjYWxsYmFjaztcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuICsgMV0gPSBhcmc7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuICs9IDI7XG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9PT0gMikge1xuICAgICAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbihsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldEFzYXAoYXNhcEZuKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcCA9IGFzYXBGbjtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJXaW5kb3cgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDogdW5kZWZpbmVkO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93IHx8IHt9O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuICAgIC8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuICAgIC8vIG5vZGVcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTmV4dFRpY2soKSB7XG4gICAgICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHZlcnR4XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVZlcnR4VGltZXIoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgbGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IChpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHdlYiB3b3JrZXJcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2g7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gsIDEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbjsgaSs9Mikge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaV07XG4gICAgICAgIHZhciBhcmcgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaSsxXTtcblxuICAgICAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2krMV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhdHRlbXB0VmVydHgoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgICAgIHZhciB2ZXJ0eCA9IHIoJ3ZlcnR4Jyk7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVZlcnR4VGltZXIoKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2g7XG4gICAgLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbiAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGlzTm9kZSkge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTmV4dFRpY2soKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpO1xuICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGlzV29ya2VyKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXR0ZW1wdFZlcnR4KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHRoZW4kJHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcblxuICAgICAgaWYgKGNoaWxkW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbWFrZVByb21pc2UoY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW3N0YXRlIC0gMV07XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSR0aGVuJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHRoZW4kJHRoZW47XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZShvYmplY3QpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRyZXNvbHZlO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQUk9NSVNFX0lEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDE2KTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3AoKSB7fVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcgICA9IHZvaWQgMDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEID0gMTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQgID0gMjtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUiA9IG5ldyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc2VsZkZ1bGZpbGxtZW50KCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZ2V0VGhlbihwcm9taXNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5VGhlbih0aGVuLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuKSB7XG4gICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAoZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvciA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdGhlbmFibGUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9LCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICAgICAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4pIHtcbiAgICAgIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgdGhlbiA9PT0gbGliJGVzNiRwcm9taXNlJHRoZW4kJGRlZmF1bHQgJiZcbiAgICAgICAgICBjb25zdHJ1Y3Rvci5yZXNvbHZlID09PSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0KSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoZW4gPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzZWxmRnVsZmlsbG1lbnQoKSk7XG4gICAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZ2V0VGhlbih2YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgICAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuXG4gICAgICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3N0YXRlID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEO1xuXG4gICAgICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gsIHByb21pc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cbiAgICAgIHByb21pc2UuX3N0YXRlID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQ7XG4gICAgICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgICAgIHZhciBsZW5ndGggPSBzdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgICAgIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURURdICA9IG9uUmVqZWN0aW9uO1xuXG4gICAgICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaCwgcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICAgICAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICAgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgdmFyIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKSB7XG4gICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SID0gbmV3IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgIHZhciBoYXNDYWxsYmFjayA9IGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICAgICAgdmFsdWUsIGVycm9yLCBzdWNjZWVkZWQsIGZhaWxlZDtcblxuICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgIHZhbHVlID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IpIHtcbiAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSl7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaWQgPSAwO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5leHRJZCgpIHtcbiAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpZCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgICAgIHByb21pc2VbbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUFJPTUlTRV9JRF0gPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpZCsrO1xuICAgICAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkYWxsKGVudHJpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJGRlZmF1bHQodGhpcywgZW50cmllcykucHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkYWxsO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJHJhY2UoZW50cmllcykge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAgIGlmICghbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRyYWNlO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkcmVqZWN0KHJlYXNvbikge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJHJlamVjdDtcblxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZTtcbiAgICAvKipcbiAgICAgIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgICAgIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gICAgICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgICAgIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gICAgICBUZXJtaW5vbG9neVxuICAgICAgLS0tLS0tLS0tLS1cblxuICAgICAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgICAgIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgICAgIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgICAgIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAgICAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAgICAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICAgICAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgICAgIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgICAgIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gICAgICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgICAgIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgICAgIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICAgICAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICAgICAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICAgICAgQmFzaWMgVXNhZ2U6XG4gICAgICAtLS0tLS0tLS0tLS1cblxuICAgICAgYGBganNcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gb24gZmFpbHVyZVxuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFkdmFuY2VkIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgICAgIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICAgICAgYGBganNcbiAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gICAgICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICAgICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAY2xhc3MgUHJvbWlzZVxuICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZXJcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEBjb25zdHJ1Y3RvclxuICAgICovXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICAgIHRoaXNbbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUFJPTUlTRV9JRF0gPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRuZXh0SWQoKTtcbiAgICAgIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNSZXNvbHZlcigpO1xuICAgICAgICB0aGlzIGluc3RhbmNlb2YgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UgPyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcikgOiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNOZXcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5hbGwgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmFjZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmVzb2x2ZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmVqZWN0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9zZXRTY2hlZHVsZXIgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0U2NoZWR1bGVyO1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9zZXRBc2FwID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldEFzYXA7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuX2FzYXAgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcDtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZSxcblxuICAgIC8qKlxuICAgICAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gICAgICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICAgICAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIENoYWluaW5nXG4gICAgICAtLS0tLS0tLVxuXG4gICAgICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICAgICAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICAgICAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgICAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgICAgIH0pO1xuXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgICB9KTtcbiAgICAgIGBgYFxuICAgICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQXNzaW1pbGF0aW9uXG4gICAgICAtLS0tLS0tLS0tLS1cblxuICAgICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICAgIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gICAgICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFNpbXBsZSBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfVxuICAgICAgYGBgXG5cbiAgICAgIEVycmJhY2sgRXhhbXBsZVxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAvLyBmYWlsdXJlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBQcm9taXNlIEV4YW1wbGU7XG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgICAgIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgdmFyIGF1dGhvciwgYm9va3M7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfVxuICAgICAgYGBgXG5cbiAgICAgIEVycmJhY2sgRXhhbXBsZVxuXG4gICAgICBgYGBqc1xuXG4gICAgICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG5cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcblxuICAgICAgfVxuXG4gICAgICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAvLyBmYWlsdXJlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBQcm9taXNlIEV4YW1wbGU7XG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIGZpbmRBdXRob3IoKS5cbiAgICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgICAgIC8vIGZvdW5kIGJvb2tzXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCB0aGVuXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgdGhlbjogbGliJGVzNiRwcm9taXNlJHRoZW4kJGRlZmF1bHQsXG5cbiAgICAvKipcbiAgICAgIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBzeW5jaHJvbm91c1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEF1dGhvcigpO1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH1cblxuICAgICAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICAgICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIGNhdGNoXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvcjtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcblxuICAgICAgaWYgKCF0aGlzLnByb21pc2VbbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUFJPTUlTRV9JRF0pIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgdGhpcy5faW5wdXQgICAgID0gaW5wdXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgICAgICAgIHRoaXMuX2VudW1lcmF0ZSgpO1xuICAgICAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHRoaXMucHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW5ndGggID0gdGhpcy5sZW5ndGg7XG4gICAgICB2YXIgaW5wdXQgICA9IHRoaXMuX2lucHV0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgdGhpcy5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcgJiYgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24oZW50cnksIGkpIHtcbiAgICAgIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgICAgIHZhciByZXNvbHZlID0gYy5yZXNvbHZlO1xuXG4gICAgICBpZiAocmVzb2x2ZSA9PT0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCkge1xuICAgICAgICB2YXIgdGhlbiA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4oZW50cnkpO1xuXG4gICAgICAgIGlmICh0aGVuID09PSBsaWIkZXM2JHByb21pc2UkdGhlbiQkZGVmYXVsdCAmJlxuICAgICAgICAgICAgZW50cnkuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcbiAgICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCkge1xuICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgdGhlbik7XG4gICAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbihyZXNvbHZlKSB7IHJlc29sdmUoZW50cnkpOyB9KSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlKGVudHJ5KSwgaSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24oc3RhdGUsIGksIHZhbHVlKSB7XG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuICAgICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uKHByb21pc2UsIGkpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRwb2x5ZmlsbCgpIHtcbiAgICAgIHZhciBsb2NhbDtcblxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbG9jYWwgPSBnbG9iYWw7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxvY2FsID0gc2VsZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICAgICAgaWYgKFAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKSA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb2NhbC5Qcm9taXNlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQ7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJHBvbHlmaWxsO1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2UgPSB7XG4gICAgICAnUHJvbWlzZSc6IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0LFxuICAgICAgJ3BvbHlmaWxsJzogbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0XG4gICAgfTtcblxuICAgIC8qIGdsb2JhbCBkZWZpbmU6dHJ1ZSBtb2R1bGU6dHJ1ZSB3aW5kb3c6IHRydWUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlOyB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZVsnZXhwb3J0cyddKSB7XG4gICAgICBtb2R1bGVbJ2V4cG9ydHMnXSA9IGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXNbJ0VTNlByb21pc2UnXSA9IGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0KCk7XG59KS5jYWxsKHRoaXMpO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIHZlcnR4IChpZ25vcmVkKVxuICoqIG1vZHVsZSBpZCA9IDEyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0XCIpOyB9O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL2FtZC1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbihzZWxmKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoc2VsZi5mZXRjaCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5cXF5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICB9LCB0aGlzKVxuXG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgdmFyIGxpc3QgPSB0aGlzLm1hcFtuYW1lXVxuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IFtdXG4gICAgICB0aGlzLm1hcFtuYW1lXSA9IGxpc3RcbiAgICB9XG4gICAgbGlzdC5wdXNoKHZhbHVlKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICAgIHJldHVybiB2YWx1ZXMgPyB2YWx1ZXNbMF0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldIHx8IFtdXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gW25vcm1hbGl6ZVZhbHVlKHZhbHVlKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMubWFwKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMubWFwW25hbWVdLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcylcbiAgICAgIH0sIHRoaXMpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgICAgfVxuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgIHJldHVybiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgICByZXR1cm4gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIGJsb2I6ICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmICdCbG9iJyBpbiBzZWxmICYmIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIC8vIE9ubHkgc3VwcG9ydCBBcnJheUJ1ZmZlcnMgZm9yIFBPU1QgbWV0aG9kLlxuICAgICAgICAvLyBSZWNlaXZpbmcgQXJyYXlCdWZmZXJzIGhhcHBlbnMgdmlhIEJsb2JzLCBpbnN0ZWFkLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIHJldHVybiByZWplY3RlZCA/IHJlamVjdGVkIDogUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuICAgIGlmIChSZXF1ZXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGlucHV0KSkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IGlucHV0XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnb21pdCdcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSlcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhlYWRlcnMoeGhyKSB7XG4gICAgdmFyIGhlYWQgPSBuZXcgSGVhZGVycygpXG4gICAgdmFyIHBhaXJzID0gKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJykudHJpbSgpLnNwbGl0KCdcXG4nKVxuICAgIHBhaXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICB2YXIgc3BsaXQgPSBoZWFkZXIudHJpbSgpLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBzcGxpdC5zaGlmdCgpLnRyaW0oKVxuICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignOicpLnRyaW0oKVxuICAgICAgaGVhZC5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICB9KVxuICAgIHJldHVybiBoZWFkXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXNcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gb3B0aW9ucy5zdGF0dXNUZXh0XG4gICAgdGhpcy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycyA/IG9wdGlvbnMuaGVhZGVycyA6IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH1cblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH1cblxuICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzXG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3RcbiAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlXG5cbiAgc2VsZi5mZXRjaCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3RcbiAgICAgIGlmIChSZXF1ZXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGlucHV0KSAmJiAhaW5pdCkge1xuICAgICAgICByZXF1ZXN0ID0gaW5wdXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcbiAgICAgIH1cblxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgIGZ1bmN0aW9uIHJlc3BvbnNlVVJMKCkge1xuICAgICAgICBpZiAoJ3Jlc3BvbnNlVVJMJyBpbiB4aHIpIHtcbiAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVVJMXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdm9pZCBzZWN1cml0eSB3YXJuaW5ncyBvbiBnZXRSZXNwb25zZUhlYWRlciB3aGVuIG5vdCBhbGxvd2VkIGJ5IENPUlNcbiAgICAgICAgaWYgKC9eWC1SZXF1ZXN0LVVSTDovbS50ZXN0KHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgICAgICByZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLVJlcXVlc3QtVVJMJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSAoeGhyLnN0YXR1cyA9PT0gMTIyMykgPyAyMDQgOiB4aHIuc3RhdHVzXG4gICAgICAgIGlmIChzdGF0dXMgPCAxMDAgfHwgc3RhdHVzID4gNTk5KSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzKHhociksXG4gICAgICAgICAgdXJsOiByZXNwb25zZVVSTCgpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKVxuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICAgIH0pXG4gIH1cbiAgc2VsZi5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JpbmdjZW50cmFsL34vd2hhdHdnLWZldGNoL2ZldGNoLmpzXG4gKiogbW9kdWxlIGlkID0gMTMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiEgMy4xNS4yIC8gbW9kZXJuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJQVUJOVUJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUFVCTlVCXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIGdsb2JhbHMgJ01vZGVybicgKi9cblx0LyogZXNsaW50IGN1cmx5OiAwLCBjYW1lbGNhc2U6IDAsIGRvdC1ub3RhdGlvbjogMCAqL1xuXG5cdHZhciBwYWNrYWdlSlNPTiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdHZhciBwdWJOdWJDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIGNyeXB0b19vYmogPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgQ3J5cHRvSlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgV1MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5cdC8qKlxuXHQgKiBVVElMIExPQ0FMU1xuXHQgKi9cblx0dmFyIFBOU0RLID0gJ1B1Yk51Yi1KUy0nICsgJ01vZGVybicgKyAnLycgKyBwYWNrYWdlSlNPTi52ZXJzaW9uO1xuXG5cdC8qKlxuXHQgKiBMT0NBTCBTVE9SQUdFXG5cdCAqL1xuXHR2YXIgZGIgPSAoZnVuY3Rpb24gKCkge1xuXHQgIHZhciBscyA9IHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnICYmIGxvY2FsU3RvcmFnZTtcblx0ICByZXR1cm4ge1xuXHQgICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKGxzKSByZXR1cm4gbHMuZ2V0SXRlbShrZXkpO1xuXHQgICAgICAgIGlmIChkb2N1bWVudC5jb29raWUuaW5kZXhPZihrZXkpID09PSAtMSkgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgcmV0dXJuICgoZG9jdW1lbnQuY29va2llIHx8ICcnKS5tYXRjaChcblx0ICAgICAgICAgICAgUmVnRXhwKGtleSArICc9KFteO10rKScpXG5cdCAgICAgICAgICApIHx8IFtdKVsxXSB8fCBudWxsO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGlmIChscykgcmV0dXJuIGxzLnNldEl0ZW0oa2V5LCB2YWx1ZSkgJiYgMDtcblx0ICAgICAgICBkb2N1bWVudC5jb29raWUgPSBrZXkgKyAnPScgKyB2YWx1ZSArXG5cdCAgICAgICAgICAnOyBleHBpcmVzPVRodSwgMSBBdWcgMjAzMCAyMDowMDowMCBVVEM7IHBhdGg9Lyc7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHR9KSgpO1xuXG5cblx0LyoqXG5cdCAqIENPUlMgWEhSIFJlcXVlc3Rcblx0ICogPT09PT09PT09PT09PT09PVxuXHQgKiAgeGRyKHtcblx0ICogICAgIHVybCAgICAgOiBbJ2h0dHA6Ly93d3cuYmxhaC5jb20vdXJsJ10sXG5cdCAqICAgICBzdWNjZXNzIDogZnVuY3Rpb24ocmVzcG9uc2UpIHt9LFxuXHQgKiAgICAgZmFpbCAgICA6IGZ1bmN0aW9uKCkge31cblx0ICogIH0pO1xuXHQgKi9cblx0ZnVuY3Rpb24geGRyKHNldHVwKSB7XG5cdCAgdmFyIHhocjtcblx0ICB2YXIgdGltZXI7XG5cdCAgdmFyIGNvbXBsZXRlID0gMDtcblx0ICB2YXIgbG9hZGVkID0gMDtcblx0ICB2YXIgYXN5bmMgPSB0cnVlOyAvKiBkbyBub3QgYWxsb3cgc3luYyBvcGVyYXRpb25zIGluIG1vZGVybiBidWlsZHMgKi9cblx0ICB2YXIgeGhydG1lID0gc2V0dXAudGltZW91dCB8fCBwdWJOdWJDb3JlLkRFRl9USU1FT1VUO1xuXHQgIHZhciBkYXRhID0gc2V0dXAuZGF0YSB8fCB7fTtcblx0ICB2YXIgZmFpbCA9IHNldHVwLmZhaWwgfHwgZnVuY3Rpb24gKCkge307XG5cdCAgdmFyIHN1Y2Nlc3MgPSBzZXR1cC5zdWNjZXNzIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5cdCAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoZmFpbGVkLCByZXNwb25zZSkge1xuXHQgICAgaWYgKGNvbXBsZXRlKSByZXR1cm47XG5cdCAgICBjb21wbGV0ZSA9IDE7XG5cblx0ICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cblx0ICAgIGlmICh4aHIpIHtcblx0ICAgICAgeGhyLm9uZXJyb3IgPSB4aHIub25sb2FkID0gbnVsbDtcblx0ICAgICAgaWYgKHhoci5hYm9ydCkgeGhyLmFib3J0KCk7XG5cdCAgICAgIHhociA9IG51bGw7XG5cdCAgICB9XG5cblx0ICAgIGlmIChmYWlsZWQpIGZhaWwocmVzcG9uc2UpO1xuXHQgIH07XG5cblx0ICB2YXIgZmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAobG9hZGVkKSByZXR1cm47XG5cdCAgICB2YXIgcmVzcG9uc2U7XG5cdCAgICBsb2FkZWQgPSAxO1xuXG5cdCAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG5cdCAgICB0cnkge1xuXHQgICAgICByZXNwb25zZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdCAgICB9IGNhdGNoIChyKSB7XG5cdCAgICAgIHJldHVybiBkb25lKDEpO1xuXHQgICAgfVxuXG5cdCAgICBzdWNjZXNzKHJlc3BvbnNlKTtcblx0ICB9O1xuXG5cdCAgdGltZXIgPSBwdWJOdWJDb3JlLnRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgZG9uZSgxKTtcblx0ICB9LCB4aHJ0bWUpO1xuXG5cdCAgLy8gU2VuZFxuXHQgIHRyeSB7XG5cdCAgICB4aHIgPSB0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmXG5cdCAgICAgIG5ldyBYRG9tYWluUmVxdWVzdCgpIHx8XG5cdCAgICAgIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG5cdCAgICB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBkb25lKDEsIHhoci5yZXNwb25zZVRleHQgfHwgeyBlcnJvcjogJ05ldHdvcmsgQ29ubmVjdGlvbiBFcnJvcicgfSk7XG5cdCAgICB9O1xuXHQgICAgeGhyLm9ubG9hZCA9IHhoci5vbmxvYWRlbmQgPSBmaW5pc2hlZDtcblxuXHQgICAgZGF0YS5wbnNkayA9IFBOU0RLO1xuXHQgICAgdmFyIHVybCA9IHB1Yk51YkNvcmUuYnVpbGRfdXJsKHNldHVwLnVybCwgZGF0YSk7XG5cdCAgICB4aHIub3BlbignR0VUJywgdXJsLCBhc3luYyk7XG5cdCAgICBpZiAoYXN5bmMpIHhoci50aW1lb3V0ID0geGhydG1lO1xuXHQgICAgeGhyLnNlbmQoKTtcblx0ICB9IGNhdGNoIChlZWUpIHtcblx0ICAgIGRvbmUoMSwgeyBlcnJvcjogJ1hIUiBGYWlsZWQnLCBzdGFja3RyYWNlOiBlZWUgfSk7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuICdkb25lJ1xuXHQgIHJldHVybiBkb25lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJJTkRcblx0ICogPT09PVxuXHQgKiBiaW5kKCAna2V5ZG93bicsIHNlYXJjaCgnYScpWzBdLCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdCAqICAgICAuLi5cblx0ICogfSApO1xuXHQgKi9cblx0ZnVuY3Rpb24gYmluZCh0eXBlLCBlbCwgZnVuKSB7XG5cdCAgcHViTnViQ29yZS5lYWNoKHR5cGUuc3BsaXQoJywnKSwgZnVuY3Rpb24gKGV0eXBlKSB7XG5cdCAgICB2YXIgcmFwZnVuID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgaWYgKCFlKSBlID0gd2luZG93LmV2ZW50O1xuXHQgICAgICBpZiAoIWZ1bihlKSkge1xuXHQgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcblx0ICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cdCAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSBlbC5hZGRFdmVudExpc3RlbmVyKGV0eXBlLCByYXBmdW4sIGZhbHNlKTtcblx0ICAgIGVsc2UgaWYgKGVsLmF0dGFjaEV2ZW50KSBlbC5hdHRhY2hFdmVudCgnb24nICsgZXR5cGUsIHJhcGZ1bik7XG5cdCAgICBlbHNlIGVsWydvbicgKyBldHlwZV0gPSByYXBmdW47XG5cdCAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogRVJST1Jcblx0ICogPT09XG5cdCAqIGVycm9yKCdtZXNzYWdlJyk7XG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG5cdCAgY29uc29sZS5lcnJvcihtZXNzYWdlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdH1cblxuXHQvKipcblx0ICogRVZFTlRTXG5cdCAqID09PT09PVxuXHQgKiBQVUJOVUIuZXZlbnRzLmJpbmQoICd5b3Utc3RlcHBlZC1vbi1mbG93ZXInLCBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdCAqICAgICAvLyBEbyBTdHVmZiB3aXRoIG1lc3NhZ2Vcblx0ICogfSApO1xuXHQgKlxuXHQgKiBQVUJOVUIuZXZlbnRzLmZpcmUoICd5b3Utc3RlcHBlZC1vbi1mbG93ZXInLCBcIm1lc3NhZ2UtZGF0YVwiICk7XG5cdCAqIFBVQk5VQi5ldmVudHMuZmlyZSggJ3lvdS1zdGVwcGVkLW9uLWZsb3dlcicsIHttZXNzYWdlOlwiZGF0YVwifSApO1xuXHQgKiBQVUJOVUIuZXZlbnRzLmZpcmUoICd5b3Utc3RlcHBlZC1vbi1mbG93ZXInLCBbMSwyLDNdICk7XG5cdCAqXG5cdCAqL1xuXHR2YXIgZXZlbnRzID0ge1xuXHQgIGxpc3Q6IHt9LFxuXHQgIHVuYmluZDogZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgIGV2ZW50cy5saXN0W25hbWVdID0gW107XG5cdCAgfSxcblx0ICBiaW5kOiBmdW5jdGlvbiAobmFtZSwgZnVuKSB7XG5cdCAgICAoZXZlbnRzLmxpc3RbbmFtZV0gPSBldmVudHMubGlzdFtuYW1lXSB8fCBbXSkucHVzaChmdW4pO1xuXHQgIH0sXG5cdCAgZmlyZTogZnVuY3Rpb24gKG5hbWUsIGRhdGEpIHtcblx0ICAgIHB1Yk51YkNvcmUuZWFjaChcblx0ICAgICAgZXZlbnRzLmxpc3RbbmFtZV0gfHwgW10sXG5cdCAgICAgIGZ1bmN0aW9uIChmdW4pIHtcblx0ICAgICAgICBmdW4oZGF0YSk7XG5cdCAgICAgIH1cblx0ICAgICk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBVFRSXG5cdCAqID09PT1cblx0ICogdmFyIGF0dHJpYnV0ZSA9IGF0dHIoIG5vZGUsICdhdHRyaWJ1dGUnICk7XG5cdCAqL1xuXHRmdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0ICBpZiAodmFsdWUpIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuXHQgIGVsc2UgcmV0dXJuIG5vZGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiAkXG5cdCAqID1cblx0ICogdmFyIGRpdiA9ICQoJ2RpdmlkJyk7XG5cdCAqL1xuXHRmdW5jdGlvbiAkKGlkKSB7XG5cdCAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFNFQVJDSFxuXHQgKiA9PT09PT1cblx0ICogdmFyIGVsZW1lbnRzID0gc2VhcmNoKCdhIGRpdiBzcGFuJyk7XG5cdCAqL1xuXHRmdW5jdGlvbiBzZWFyY2goZWxlbWVudHMsIHN0YXJ0KSB7XG5cdCAgdmFyIGxpc3QgPSBbXTtcblx0ICBwdWJOdWJDb3JlLmVhY2goZWxlbWVudHMuc3BsaXQoL1xccysvKSwgZnVuY3Rpb24gKGVsKSB7XG5cdCAgICBwdWJOdWJDb3JlLmVhY2goKHN0YXJ0IHx8IGRvY3VtZW50KS5nZXRFbGVtZW50c0J5VGFnTmFtZShlbCksIGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgIGxpc3QucHVzaChub2RlKTtcblx0ICAgIH0pO1xuXHQgIH0pO1xuXHQgIHJldHVybiBsaXN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENTU1xuXHQgKiA9PT1cblx0ICogdmFyIG9iaiA9IGNyZWF0ZSgnZGl2Jyk7XG5cdCAqL1xuXHRmdW5jdGlvbiBjc3MoZWxlbWVudCwgc3R5bGVzKSB7XG5cdCAgZm9yICh2YXIgc3R5bGUgaW4gc3R5bGVzKSBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSlcblx0ICAgIHRyeSB7XG5cdCAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVdID0gc3R5bGVzW3N0eWxlXSArIChcblx0ICAgICAgICAgICd8d2lkdGh8aGVpZ2h0fHRvcHxsZWZ0fCcuaW5kZXhPZihzdHlsZSkgPiAwICYmXG5cdCAgICAgICAgICB0eXBlb2Ygc3R5bGVzW3N0eWxlXSA9PT0gJ251bWJlcidcblx0ICAgICAgICAgICAgPyAncHgnIDogJydcblx0ICAgICAgICApO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdH1cblxuXHQvKipcblx0ICogQ1JFQVRFXG5cdCAqID09PT09PVxuXHQgKiB2YXIgb2JqID0gY3JlYXRlKCdkaXYnKTtcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG5cdCAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudCk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGdldF9obWFjX1NIQTI1NihkYXRhLCBrZXkpIHtcblx0ICB2YXIgaGFzaCA9IENyeXB0b0pTWydIbWFjU0hBMjU2J10oZGF0YSwga2V5KTtcblx0ICByZXR1cm4gaGFzaC50b1N0cmluZyhDcnlwdG9KU1snZW5jJ11bJ0Jhc2U2NCddKTtcblx0fVxuXG5cdC8qID0tPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0tPSAqL1xuXHQvKiA9LT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09LT0gKi9cblx0LyogPS09PT09PT09PT09PT09PT09PT09PT09PT09ICAgICBQVUJOVUIgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PS09ICovXG5cdC8qID0tPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0tPSAqL1xuXHQvKiA9LT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09LT0gKi9cblxuXHRmdW5jdGlvbiBDUkVBVEVfUFVCTlVCKHNldHVwKSB7XG5cdCAgc2V0dXAuZGIgPSBkYjtcblx0ICBzZXR1cC54ZHIgPSB4ZHI7XG5cdCAgc2V0dXAuZXJyb3IgPSBzZXR1cC5lcnJvciB8fCBlcnJvcjtcblx0ICBzZXR1cC5obWFjX1NIQTI1NiA9IGdldF9obWFjX1NIQTI1Njtcblx0ICBzZXR1cC5jcnlwdG9fb2JqID0gY3J5cHRvX29iaigpO1xuXHQgIHNldHVwLldTID0gV1M7XG5cdCAgc2V0dXAucGFyYW1zID0geyBwbnNkazogUE5TREsgfTtcblxuXHQgIHZhciBTRUxGID0gZnVuY3Rpb24gKHNldHVwKSB7XG5cdCAgICByZXR1cm4gQ1JFQVRFX1BVQk5VQihzZXR1cCk7XG5cdCAgfTtcblxuXHQgIHZhciBQTiA9IHB1Yk51YkNvcmUuUE5fQVBJKHNldHVwKTtcblx0ICBmb3IgKHZhciBwcm9wIGluIFBOKSB7XG5cdCAgICBpZiAoUE4uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0ICAgICAgU0VMRltwcm9wXSA9IFBOW3Byb3BdO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIFNFTEYuaW5pdCA9IFNFTEY7XG5cdCAgU0VMRi4kID0gJDtcblx0ICBTRUxGLmF0dHIgPSBhdHRyO1xuXHQgIFNFTEYuc2VhcmNoID0gc2VhcmNoO1xuXHQgIFNFTEYuYmluZCA9IGJpbmQ7XG5cdCAgU0VMRi5jc3MgPSBjc3M7XG5cdCAgU0VMRi5jcmVhdGUgPSBjcmVhdGU7XG5cdCAgU0VMRi5jcnlwdG9fb2JqID0gY3J5cHRvX29iaigpO1xuXHQgIFNFTEYuV1MgPSBXUztcblx0ICBTRUxGLlBObWVzc2FnZSA9IHB1Yk51YkNvcmUuUE5tZXNzYWdlO1xuXHQgIFNFTEYuc3VwcGxhbnQgPSBwdWJOdWJDb3JlLnN1cHBsYW50O1xuXG5cdCAgaWYgKHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgYmluZCgnYmVmb3JldW5sb2FkJywgd2luZG93LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIFNFTEZbJ2VhY2gtY2hhbm5lbCddKGZ1bmN0aW9uIChjaCkge1xuXHQgICAgICAgIFNFTEZbJ0xFQVZFJ10oY2gubmFtZSwgMSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIFNFTEYucmVhZHkoKTtcblxuXHQgIC8vIFJldHVybiB3aXRob3V0IFRlc3Rpbmdcblx0ICBpZiAoc2V0dXAubm90ZXN0KSByZXR1cm4gU0VMRjtcblxuXHQgIGlmICh0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIGJpbmQoJ29mZmxpbmUnLCB3aW5kb3csIFNFTEZbJ29mZmxpbmUnXSk7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZihkb2N1bWVudCkgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICBiaW5kKCdvZmZsaW5lJywgZG9jdW1lbnQsIFNFTEZbJ29mZmxpbmUnXSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIFNFTEY7XG5cdH1cblxuXHRDUkVBVEVfUFVCTlVCLmluaXQgPSBDUkVBVEVfUFVCTlVCO1xuXHRDUkVBVEVfUFVCTlVCLnNlY3VyZSA9IENSRUFURV9QVUJOVUI7XG5cdENSRUFURV9QVUJOVUIuY3J5cHRvX29iaiA9IGNyeXB0b19vYmooKTtcblx0Q1JFQVRFX1BVQk5VQi5XUyA9IFdTO1xuXHRDUkVBVEVfUFVCTlVCLmRiID0gZGI7XG5cdENSRUFURV9QVUJOVUIuUE5tZXNzYWdlID0gcHViTnViQ29yZS5QTm1lc3NhZ2U7XG5cdENSRUFURV9QVUJOVUIudXVpZCA9IHB1Yk51YkNvcmUudXVpZDtcblxuXHRDUkVBVEVfUFVCTlVCLmNzcyA9IGNzcztcblx0Q1JFQVRFX1BVQk5VQi4kID0gJDtcblx0Q1JFQVRFX1BVQk5VQi5jcmVhdGUgPSAkO1xuXHRDUkVBVEVfUFVCTlVCLmJpbmQgPSBiaW5kO1xuXHRDUkVBVEVfUFVCTlVCLnNlYXJjaCA9IHNlYXJjaDtcblx0Q1JFQVRFX1BVQk5VQi5hdHRyID0gYXR0cjtcblx0Q1JFQVRFX1BVQk5VQi5ldmVudHMgPSBldmVudHM7XG5cblx0Q1JFQVRFX1BVQk5VQi5tYXAgPSBwdWJOdWJDb3JlLm1hcDtcblx0Q1JFQVRFX1BVQk5VQi5lYWNoID0gcHViTnViQ29yZS5lYWNoO1xuXHRDUkVBVEVfUFVCTlVCLmdyZXAgPSBwdWJOdWJDb3JlLmdyZXA7XG5cdENSRUFURV9QVUJOVUIuc3VwcGxhbnQgPSBwdWJOdWJDb3JlLnN1cHBsYW50O1xuXHRDUkVBVEVfUFVCTlVCLm5vdyA9IHB1Yk51YkNvcmUubm93O1xuXHRDUkVBVEVfUFVCTlVCLnVuaXF1ZSA9IHB1Yk51YkNvcmUudW5pcXVlO1xuXHRDUkVBVEVfUFVCTlVCLnVwZGF0ZXIgPSBwdWJOdWJDb3JlLnVwZGF0ZXI7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBDUkVBVEVfUFVCTlVCO1xuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0XHRcIm5hbWVcIjogXCJwdWJudWJcIixcblx0XHRcInByZWZlckdsb2JhbFwiOiBmYWxzZSxcblx0XHRcInZlcnNpb25cIjogXCIzLjE1LjJcIixcblx0XHRcImF1dGhvclwiOiBcIlB1Yk51YiA8c3VwcG9ydEBwdWJudWIuY29tPlwiLFxuXHRcdFwiZGVzY3JpcHRpb25cIjogXCJQdWJsaXNoICYgU3Vic2NyaWJlIFJlYWwtdGltZSBNZXNzYWdpbmcgd2l0aCBQdWJOdWJcIixcblx0XHRcImNvbnRyaWJ1dG9yc1wiOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwibmFtZVwiOiBcIlN0ZXBoZW4gQmx1bVwiLFxuXHRcdFx0XHRcImVtYWlsXCI6IFwic3RlcGhlbkBwdWJudWIuY29tXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwiYmluXCI6IHt9LFxuXHRcdFwic2NyaXB0c1wiOiB7XG5cdFx0XHRcInRlc3RcIjogXCJncnVudCB0ZXN0IC0tZm9yY2VcIlxuXHRcdH0sXG5cdFx0XCJtYWluXCI6IFwiLi9ub2RlLmpzL3B1Ym51Yi5qc1wiLFxuXHRcdFwiYnJvd3NlclwiOiBcIi4vbW9kZXJuL2Rpc3QvcHVibnViLmpzXCIsXG5cdFx0XCJyZXBvc2l0b3J5XCI6IHtcblx0XHRcdFwidHlwZVwiOiBcImdpdFwiLFxuXHRcdFx0XCJ1cmxcIjogXCJnaXQ6Ly9naXRodWIuY29tL3B1Ym51Yi9qYXZhc2NyaXB0LmdpdFwiXG5cdFx0fSxcblx0XHRcImtleXdvcmRzXCI6IFtcblx0XHRcdFwiY2xvdWRcIixcblx0XHRcdFwicHVibGlzaFwiLFxuXHRcdFx0XCJzdWJzY3JpYmVcIixcblx0XHRcdFwid2Vic29ja2V0c1wiLFxuXHRcdFx0XCJjb21ldFwiLFxuXHRcdFx0XCJib3NoXCIsXG5cdFx0XHRcInhtcHBcIixcblx0XHRcdFwicmVhbC10aW1lXCIsXG5cdFx0XHRcIm1lc3NhZ2luZ1wiXG5cdFx0XSxcblx0XHRcImRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XHRcImFnZW50a2VlcGFsaXZlXCI6IFwifjAuMlwiLFxuXHRcdFx0XCJsb2Rhc2hcIjogXCJeNC4xLjBcIlxuXHRcdH0sXG5cdFx0XCJub0FuYWx5emVcIjogZmFsc2UsXG5cdFx0XCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuXHRcdFx0XCJjaGFpXCI6IFwiXjMuNS4wXCIsXG5cdFx0XHRcImVzbGludFwiOiBcIjIuNC4wXCIsXG5cdFx0XHRcImVzbGludC1jb25maWctYWlyYm5iXCI6IFwiXjYuMC4yXCIsXG5cdFx0XHRcImVzbGludC1wbHVnaW4tZmxvd3R5cGVcIjogXCJeMi4xLjBcIixcblx0XHRcdFwiZXNsaW50LXBsdWdpbi1tb2NoYVwiOiBcIl4yLjAuMFwiLFxuXHRcdFx0XCJlc2xpbnQtcGx1Z2luLXJlYWN0XCI6IFwiXjQuMS4wXCIsXG5cdFx0XHRcImZsb3ctYmluXCI6IFwiXjAuMjIuMFwiLFxuXHRcdFx0XCJncnVudFwiOiBcIl4wLjQuNVwiLFxuXHRcdFx0XCJncnVudC1jb250cmliLWNsZWFuXCI6IFwiXjEuMC4wXCIsXG5cdFx0XHRcImdydW50LWNvbnRyaWItY29weVwiOiBcIl4wLjguMlwiLFxuXHRcdFx0XCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIl4wLjExLjFcIixcblx0XHRcdFwiZ3J1bnQtZW52XCI6IFwiXjAuNC40XCIsXG5cdFx0XHRcImdydW50LWVzbGludFwiOiBcIl4xOC4wLjBcIixcblx0XHRcdFwiZ3J1bnQtZmxvd1wiOiBcIl4xLjAuM1wiLFxuXHRcdFx0XCJncnVudC1rYXJtYVwiOiBcIl4wLjEyLjFcIixcblx0XHRcdFwiZ3J1bnQtbW9jaGEtaXN0YW5idWxcIjogXCJeMy4wLjFcIixcblx0XHRcdFwiZ3J1bnQtdGV4dC1yZXBsYWNlXCI6IFwiXjAuNC4wXCIsXG5cdFx0XHRcImdydW50LXdlYnBhY2tcIjogXCJeMS4wLjExXCIsXG5cdFx0XHRcImltcG9ydHMtbG9hZGVyXCI6IFwiXjAuNi41XCIsXG5cdFx0XHRcImlzcGFydGFcIjogXCJeNC4wLjBcIixcblx0XHRcdFwianNvbi1sb2FkZXJcIjogXCJeMC41LjRcIixcblx0XHRcdFwia2FybWFcIjogXCJeMC4xMy4yMVwiLFxuXHRcdFx0XCJrYXJtYS1jaGFpXCI6IFwiXjAuMS4wXCIsXG5cdFx0XHRcImthcm1hLW1vY2hhXCI6IFwiXjAuMi4xXCIsXG5cdFx0XHRcImthcm1hLXBoYW50b21qcy1sYXVuY2hlclwiOiBcIl4xLjAuMFwiLFxuXHRcdFx0XCJrYXJtYS1zcGVjLXJlcG9ydGVyXCI6IFwiMC4wLjI0XCIsXG5cdFx0XHRcImxvYWQtZ3J1bnQtdGFza3NcIjogXCJeMy40LjBcIixcblx0XHRcdFwibW9jaGFcIjogXCJeMi40LjVcIixcblx0XHRcdFwibm9ja1wiOiBcIl4xLjEuMFwiLFxuXHRcdFx0XCJub2RlLXV1aWRcIjogXCJeMS40LjdcIixcblx0XHRcdFwibm9kZXVuaXRcIjogXCJeMC45LjBcIixcblx0XHRcdFwicGhhbnRvbWpzLXByZWJ1aWx0XCI6IFwiXjIuMS40XCIsXG5cdFx0XHRcInByb3h5cXVpcmVcIjogXCJeMS43LjRcIixcblx0XHRcdFwic2lub25cIjogXCJeMS4xNy4yXCIsXG5cdFx0XHRcInVnbGlmeS1qc1wiOiBcIl4yLjYuMVwiLFxuXHRcdFx0XCJ1bmRlcnNjb3JlXCI6IFwiXjEuNy4wXCIsXG5cdFx0XHRcIndlYnBhY2tcIjogXCJeMS4xMi4xM1wiLFxuXHRcdFx0XCJ3ZWJwYWNrLWRldi1zZXJ2ZXJcIjogXCJeMS4xNC4xXCJcblx0XHR9LFxuXHRcdFwiYnVuZGxlRGVwZW5kZW5jaWVzXCI6IFtdLFxuXHRcdFwibGljZW5zZVwiOiBcIk1JVFwiLFxuXHRcdFwiZW5naW5lXCI6IHtcblx0XHRcdFwibm9kZVwiOiBcIj49MC44XCJcblx0XHR9LFxuXHRcdFwiZmlsZXNcIjogW1xuXHRcdFx0XCJjb3JlXCIsXG5cdFx0XHRcIm5vZGUuanNcIixcblx0XHRcdFwibW9kZXJuXCIsXG5cdFx0XHRcIkNIQU5HRUxPR1wiLFxuXHRcdFx0XCJGVVRVUkUubWRcIixcblx0XHRcdFwiTElDRU5TRVwiLFxuXHRcdFx0XCJSRUFETUUubWRcIlxuXHRcdF1cblx0fTtcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIGVzbGludCBjYW1lbGNhc2U6IDAsIG5vLXVzZS1iZWZvcmUtZGVmaW5lOiAwLCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IDAgICovXG5cdC8qIGVzbGludCBlcWVxZXE6IDAsIG9uZS12YXI6IDAgKi9cblx0LyogZXNsaW50IG5vLXJlZGVjbGFyZTogMCAqL1xuXHQvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG5cdC8qIGVzbGludCBibG9jay1zY29wZWQtdmFyOiAwIHNwYWNlLXJldHVybi10aHJvdy1jYXNlOiAwLCBuby11bnVzZWQtdmFyczogMCAqL1xuXG5cdHZhciBwYWNrYWdlSlNPTiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdHZhciBkZWZhdWx0Q29uZmlndXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblx0dmFyIE5PVyA9IDE7XG5cdHZhciBSRUFEWSA9IGZhbHNlO1xuXHR2YXIgUkVBRFlfQlVGRkVSID0gW107XG5cdHZhciBQUkVTRU5DRV9TVUZGSVggPSAnLXBucHJlcyc7XG5cdHZhciBERUZfV0lORE9XSU5HID0gMTA7IC8vIE1JTExJU0VDT05EUy5cblx0dmFyIERFRl9USU1FT1VUID0gMTUwMDA7IC8vIE1JTExJU0VDT05EUy5cblx0dmFyIERFRl9TVUJfVElNRU9VVCA9IDMxMDsgLy8gU0VDT05EUy5cblx0dmFyIERFRl9LRUVQQUxJVkUgPSA2MDsgLy8gU0VDT05EUyAoRk9SIFRJTUVTWU5DKS5cblx0dmFyIFNFQ09ORCA9IDEwMDA7IC8vIEEgVEhPVVNBTkQgTUlMTElTRUNPTkRTLlxuXHR2YXIgUFJFU0VOQ0VfSEJfVEhSRVNIT0xEID0gNTtcblx0dmFyIFBSRVNFTkNFX0hCX0RFRkFVTFQgPSAzMDtcblx0dmFyIFNES19WRVIgPSBwYWNrYWdlSlNPTi52ZXJzaW9uO1xuXG5cdC8qKlxuXHQgKiBVVElMSVRJRVNcblx0ICovXG5cdGZ1bmN0aW9uIHVuaXF1ZSgpIHtcblx0ICByZXR1cm4gJ3gnICsgKytOT1cgKyAnJyArICgrbmV3IERhdGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE5FWFRPUklHSU5cblx0ICogPT09PT09PT09PVxuXHQgKiB2YXIgbmV4dF9vcmlnaW4gPSBuZXh0b3JpZ2luKCk7XG5cdCAqL1xuXHR2YXIgbmV4dG9yaWdpbiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIG1heCA9IDIwO1xuXHQgIHZhciBvcmkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xuXHQgIHJldHVybiBmdW5jdGlvbiAob3JpZ2luLCBmYWlsb3Zlcikge1xuXHQgICAgcmV0dXJuIG9yaWdpbi5pbmRleE9mKCdwdWJzdWIuJykgPiAwXG5cdCAgICAgICYmIG9yaWdpbi5yZXBsYWNlKFxuXHQgICAgICAgICdwdWJzdWInLCAncHMnICsgKFxuXHQgICAgICAgICAgZmFpbG92ZXIgPyB1dGlscy5nZW5lcmF0ZVVVSUQoKS5zcGxpdCgnLScpWzBdIDpcblx0ICAgICAgICAgICAgKCsrb3JpIDwgbWF4ID8gb3JpIDogb3JpID0gMSlcblx0ICAgICAgICApKSB8fCBvcmlnaW47XG5cdCAgfTtcblx0fSkoKTtcblxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBTdWJzY3JpcHRpb24gQ2hhbm5lbCBMaXN0XG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogZ2VuZXJhdGVfY2hhbm5lbF9saXN0KGNoYW5uZWxzX29iamVjdCk7XG5cdCAqL1xuXHRmdW5jdGlvbiBnZW5lcmF0ZV9jaGFubmVsX2xpc3QoY2hhbm5lbHMsIG5vcHJlc2VuY2UpIHtcblx0ICB2YXIgbGlzdCA9IFtdO1xuXHQgIHV0aWxzLmVhY2goY2hhbm5lbHMsIGZ1bmN0aW9uIChjaGFubmVsLCBzdGF0dXMpIHtcblx0ICAgIGlmIChub3ByZXNlbmNlKSB7XG5cdCAgICAgIGlmIChjaGFubmVsLnNlYXJjaCgnLXBucHJlcycpIDwgMCkge1xuXHQgICAgICAgIGlmIChzdGF0dXMuc3Vic2NyaWJlZCkgbGlzdC5wdXNoKGNoYW5uZWwpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoc3RhdHVzLnN1YnNjcmliZWQpIGxpc3QucHVzaChjaGFubmVsKTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICByZXR1cm4gbGlzdC5zb3J0KCk7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGUgU3Vic2NyaXB0aW9uIENoYW5uZWwgR3JvdXBzIExpc3Rcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBnZW5lcmF0ZV9jaGFubmVsX2dyb3VwX2xpc3QoY2hhbm5lbHNfZ3JvdXBzIG9iamVjdCk7XG5cdCAqL1xuXHRmdW5jdGlvbiBnZW5lcmF0ZV9jaGFubmVsX2dyb3VwX2xpc3QoY2hhbm5lbF9ncm91cHMsIG5vcHJlc2VuY2UpIHtcblx0ICB2YXIgbGlzdCA9IFtdO1xuXHQgIHV0aWxzLmVhY2goY2hhbm5lbF9ncm91cHMsIGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwLCBzdGF0dXMpIHtcblx0ICAgIGlmIChub3ByZXNlbmNlKSB7XG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwLnNlYXJjaCgnLXBucHJlcycpIDwgMCkge1xuXHQgICAgICAgIGlmIChzdGF0dXMuc3Vic2NyaWJlZCkgbGlzdC5wdXNoKGNoYW5uZWxfZ3JvdXApO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoc3RhdHVzLnN1YnNjcmliZWQpIGxpc3QucHVzaChjaGFubmVsX2dyb3VwKTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICByZXR1cm4gbGlzdC5zb3J0KCk7XG5cdH1cblxuXHQvLyBQVUJOVUIgUkVBRFkgVE8gQ09OTkVDVFxuXHRmdW5jdGlvbiByZWFkeSgpIHtcblx0ICBpZiAoUkVBRFkpIHJldHVybjtcblx0ICBSRUFEWSA9IDE7XG5cdCAgdXRpbHMuZWFjaChSRUFEWV9CVUZGRVIsIGZ1bmN0aW9uIChjb25uZWN0KSB7XG5cdCAgICBjb25uZWN0KCk7XG5cdCAgfSk7XG5cdH1cblxuXHRmdW5jdGlvbiBQTm1lc3NhZ2UoYXJncykge1xuXHQgIHZhciBtc2cgPSBhcmdzIHx8IHsgYXBuczoge30gfTtcblxuXHQgIG1zZ1snZ2V0UHVibnViTWVzc2FnZSddID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIG0gPSB7fTtcblxuXHQgICAgaWYgKE9iamVjdC5rZXlzKG1zZ1snYXBucyddKS5sZW5ndGgpIHtcblx0ICAgICAgbVsncG5fYXBucyddID0ge1xuXHQgICAgICAgIGFwczoge1xuXHQgICAgICAgICAgYWxlcnQ6IG1zZ1snYXBucyddWydhbGVydCddLFxuXHQgICAgICAgICAgYmFkZ2U6IG1zZ1snYXBucyddWydiYWRnZSddXG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgICBmb3IgKHZhciBrIGluIG1zZ1snYXBucyddKSB7XG5cdCAgICAgICAgbVsncG5fYXBucyddW2tdID0gbXNnWydhcG5zJ11ba107XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGV4Y2x1ZGUxID0gWydiYWRnZScsICdhbGVydCddO1xuXHQgICAgICBmb3IgKHZhciBrIGluIGV4Y2x1ZGUxKSB7XG5cdCAgICAgICAgZGVsZXRlIG1bJ3BuX2FwbnMnXVtleGNsdWRlMVtrXV07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKG1zZ1snZ2NtJ10pIHtcblx0ICAgICAgbVsncG5fZ2NtJ10gPSB7XG5cdCAgICAgICAgZGF0YTogbXNnWydnY20nXVxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBrIGluIG1zZykge1xuXHQgICAgICBtW2tdID0gbXNnW2tdO1xuXHQgICAgfVxuXHQgICAgdmFyIGV4Y2x1ZGUgPSBbJ2FwbnMnLCAnZ2NtJywgJ3B1Ymxpc2gnLCAnY2hhbm5lbCcsICdjYWxsYmFjaycsICdlcnJvciddO1xuXHQgICAgZm9yICh2YXIgayBpbiBleGNsdWRlKSB7XG5cdCAgICAgIGRlbGV0ZSBtW2V4Y2x1ZGVba11dO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbTtcblx0ICB9O1xuXHQgIG1zZ1sncHVibGlzaCddID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIG0gPSBtc2cuZ2V0UHVibnViTWVzc2FnZSgpO1xuXG5cdCAgICBpZiAobXNnWydwdWJudWInXSAmJiBtc2dbJ2NoYW5uZWwnXSkge1xuXHQgICAgICBtc2dbJ3B1Ym51YiddLnB1Ymxpc2goe1xuXHQgICAgICAgIG1lc3NhZ2U6IG0sXG5cdCAgICAgICAgY2hhbm5lbDogbXNnWydjaGFubmVsJ10sXG5cdCAgICAgICAgY2FsbGJhY2s6IG1zZ1snY2FsbGJhY2snXSxcblx0ICAgICAgICBlcnJvcjogbXNnWydlcnJvciddXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgcmV0dXJuIG1zZztcblx0fVxuXG5cdGZ1bmN0aW9uIFBOX0FQSShzZXR1cCkge1xuXHQgIHZhciBTVUJfV0lORE9XSU5HID0gK3NldHVwWyd3aW5kb3dpbmcnXSB8fCBERUZfV0lORE9XSU5HO1xuXHQgIHZhciBTVUJfVElNRU9VVCA9ICgrc2V0dXBbJ3RpbWVvdXQnXSB8fCBERUZfU1VCX1RJTUVPVVQpICogU0VDT05EO1xuXHQgIHZhciBLRUVQQUxJVkUgPSAoK3NldHVwWydrZWVwYWxpdmUnXSB8fCBERUZfS0VFUEFMSVZFKSAqIFNFQ09ORDtcblx0ICB2YXIgVElNRV9DSEVDSyA9IHNldHVwWyd0aW1lY2hlY2snXSB8fCAwO1xuXHQgIHZhciBOT0xFQVZFID0gc2V0dXBbJ25vbGVhdmUnXSB8fCAwO1xuXHQgIHZhciBQVUJMSVNIX0tFWSA9IHNldHVwWydwdWJsaXNoX2tleSddO1xuXHQgIHZhciBTVUJTQ1JJQkVfS0VZID0gc2V0dXBbJ3N1YnNjcmliZV9rZXknXTtcblx0ICB2YXIgQVVUSF9LRVkgPSBzZXR1cFsnYXV0aF9rZXknXSB8fCAnJztcblx0ICB2YXIgU0VDUkVUX0tFWSA9IHNldHVwWydzZWNyZXRfa2V5J10gfHwgJyc7XG5cdCAgdmFyIGhtYWNfU0hBMjU2ID0gc2V0dXBbJ2htYWNfU0hBMjU2J107XG5cdCAgdmFyIFNTTCA9IHNldHVwWydzc2wnXSA/ICdzJyA6ICcnO1xuXHQgIHZhciBPUklHSU4gPSAnaHR0cCcgKyBTU0wgKyAnOi8vJyArIChzZXR1cFsnb3JpZ2luJ10gfHwgJ3B1YnN1Yi5wdWJudWIuY29tJyk7XG5cdCAgdmFyIFNURF9PUklHSU4gPSBuZXh0b3JpZ2luKE9SSUdJTik7XG5cdCAgdmFyIFNVQl9PUklHSU4gPSBuZXh0b3JpZ2luKE9SSUdJTik7XG5cdCAgdmFyIENPTk5FQ1QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgfTtcblx0ICB2YXIgUFVCX1FVRVVFID0gW107XG5cdCAgdmFyIENMT0FLID0gdHJ1ZTtcblx0ICB2YXIgVElNRV9EUklGVCA9IDA7XG5cdCAgdmFyIFNVQl9DQUxMQkFDSyA9IDA7XG5cdCAgdmFyIFNVQl9DSEFOTkVMID0gMDtcblx0ICB2YXIgU1VCX1JFQ0VJVkVSID0gMDtcblx0ICB2YXIgU1VCX1JFU1RPUkUgPSBzZXR1cFsncmVzdG9yZSddIHx8IDA7XG5cdCAgdmFyIFNVQl9CVUZGX1dBSVQgPSAwO1xuXHQgIHZhciBUSU1FVE9LRU4gPSAwO1xuXHQgIHZhciBSRVNVTUVEID0gZmFsc2U7XG5cdCAgdmFyIENIQU5ORUxTID0ge307XG5cdCAgdmFyIENIQU5ORUxfR1JPVVBTID0ge307XG5cdCAgdmFyIFNVQl9FUlJPUiA9IGZ1bmN0aW9uICgpIHtcblx0ICB9O1xuXHQgIHZhciBTVEFURSA9IHt9O1xuXHQgIHZhciBQUkVTRU5DRV9IQl9USU1FT1VUID0gbnVsbDtcblx0ICB2YXIgUFJFU0VOQ0VfSEIgPSB2YWxpZGF0ZV9wcmVzZW5jZV9oZWFydGJlYXQoXG5cdCAgICBzZXR1cFsnaGVhcnRiZWF0J10gfHwgc2V0dXBbJ3BuZXhwaXJlcyddIHx8IDAsIHNldHVwWydlcnJvciddXG5cdCAgKTtcblx0ICB2YXIgUFJFU0VOQ0VfSEJfSU5URVJWQUwgPSBzZXR1cFsnaGVhcnRiZWF0X2ludGVydmFsJ10gfHwgKFBSRVNFTkNFX0hCIC8gMikgLSAxO1xuXHQgIHZhciBQUkVTRU5DRV9IQl9SVU5OSU5HID0gZmFsc2U7XG5cdCAgdmFyIE5PX1dBSVRfRk9SX1BFTkRJTkcgPSBzZXR1cFsnbm9fd2FpdF9mb3JfcGVuZGluZyddO1xuXHQgIHZhciBDT01QQVRJQkxFXzM1ID0gc2V0dXBbJ2NvbXBhdGlibGVfMy41J10gfHwgZmFsc2U7XG5cdCAgdmFyIHhkciA9IHNldHVwWyd4ZHInXTtcblx0ICB2YXIgcGFyYW1zID0gc2V0dXBbJ3BhcmFtcyddIHx8IHt9O1xuXHQgIHZhciBlcnJvciA9IHNldHVwWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgIHZhciBfaXNfb25saW5lID0gc2V0dXBbJ19pc19vbmxpbmUnXSB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiAxO307XG5cdCAgdmFyIGpzb25wX2NiID0gc2V0dXBbJ2pzb25wX2NiJ10gfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcblx0ICB2YXIgZGIgPSBzZXR1cFsnZGInXSB8fCB7IGdldDogZnVuY3Rpb24gKCkge30sIHNldDogZnVuY3Rpb24gKCkge30gfTtcblx0ICB2YXIgQ0lQSEVSX0tFWSA9IHNldHVwWydjaXBoZXJfa2V5J107XG5cdCAgdmFyIFVVSUQgPSBzZXR1cFsndXVpZCddIHx8ICghc2V0dXBbJ3VuaXF1ZV91dWlkJ10gJiYgZGIgJiYgZGJbJ2dldCddKFNVQlNDUklCRV9LRVkgKyAndXVpZCcpIHx8ICcnKTtcblx0ICB2YXIgVVNFX0lOU1RBTkNFSUQgPSBzZXR1cFsnaW5zdGFuY2VfaWQnXSB8fCBmYWxzZTtcblx0ICB2YXIgSU5TVEFOQ0VJRCA9ICcnO1xuXHQgIHZhciBzaHV0ZG93biA9IHNldHVwWydzaHV0ZG93biddO1xuXHQgIHZhciB1c2Vfc2VuZF9iZWFjb24gPSAodHlwZW9mIHNldHVwWyd1c2Vfc2VuZF9iZWFjb24nXSAhPSAndW5kZWZpbmVkJykgPyBzZXR1cFsndXNlX3NlbmRfYmVhY29uJ10gOiB0cnVlO1xuXHQgIHZhciBzZW5kQmVhY29uID0gKHVzZV9zZW5kX2JlYWNvbikgPyBzZXR1cFsnc2VuZEJlYWNvbiddIDogbnVsbDtcblx0ICB2YXIgX3BvbGxfdGltZXI7XG5cdCAgdmFyIF9wb2xsX3RpbWVyMjtcblxuXHQgIGlmIChQUkVTRU5DRV9IQiA9PT0gMikgUFJFU0VOQ0VfSEJfSU5URVJWQUwgPSAxO1xuXG5cdCAgdmFyIGNyeXB0b19vYmogPSBzZXR1cFsnY3J5cHRvX29iaiddIHx8IHtcblx0ICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChhLCBrZXkpIHtcblx0ICAgICAgcmV0dXJuIGE7XG5cdCAgICB9LFxuXHQgICAgZGVjcnlwdDogZnVuY3Rpb24gKGIsIGtleSkge1xuXHQgICAgICByZXR1cm4gYjtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gX2dldF91cmxfcGFyYW1zKGRhdGEpIHtcblx0ICAgIGlmICghZGF0YSkgZGF0YSA9IHt9O1xuXHQgICAgdXRpbHMuZWFjaChwYXJhbXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdCAgICAgIGlmICghKGtleSBpbiBkYXRhKSkgZGF0YVtrZXldID0gdmFsdWU7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9vYmplY3RfdG9fa2V5X2xpc3Qobykge1xuXHQgICAgdmFyIGwgPSBbXTtcblx0ICAgIHV0aWxzLmVhY2gobywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0ICAgICAgbC5wdXNoKGtleSk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBsO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9vYmplY3RfdG9fa2V5X2xpc3Rfc29ydGVkKG8pIHtcblx0ICAgIHJldHVybiBfb2JqZWN0X3RvX2tleV9saXN0KG8pLnNvcnQoKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfZ2V0X3BhbV9zaWduX2lucHV0X2Zyb21fcGFyYW1zKHBhcmFtcykge1xuXHQgICAgdmFyIHNpID0gJyc7XG5cdCAgICB2YXIgbCA9IF9vYmplY3RfdG9fa2V5X2xpc3Rfc29ydGVkKHBhcmFtcyk7XG5cblx0ICAgIGZvciAodmFyIGkgaW4gbCkge1xuXHQgICAgICB2YXIgayA9IGxbaV07XG5cdCAgICAgIHNpICs9IGsgKyAnPScgKyB1dGlscy5wYW1FbmNvZGUocGFyYW1zW2tdKTtcblx0ICAgICAgaWYgKGkgIT0gbC5sZW5ndGggLSAxKSBzaSArPSAnJic7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc2k7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdmFsaWRhdGVfcHJlc2VuY2VfaGVhcnRiZWF0KGhlYXJ0YmVhdCwgY3VyX2hlYXJ0YmVhdCwgZXJyb3IpIHtcblx0ICAgIHZhciBlcnIgPSBmYWxzZTtcblxuXHQgICAgaWYgKHR5cGVvZiBoZWFydGJlYXQgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgIHJldHVybiBjdXJfaGVhcnRiZWF0O1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGhlYXJ0YmVhdCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgaWYgKGhlYXJ0YmVhdCA+IFBSRVNFTkNFX0hCX1RIUkVTSE9MRCB8fCBoZWFydGJlYXQgPT0gMCkge1xuXHQgICAgICAgIGVyciA9IGZhbHNlO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVyciA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIGhlYXJ0YmVhdCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdCAgICAgIGlmICghaGVhcnRiZWF0KSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIFBSRVNFTkNFX0hCX0RFRkFVTFQ7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVyciA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChlcnIpIHtcblx0ICAgICAgZXJyb3IgJiYgZXJyb3IoJ1ByZXNlbmNlIEhlYXJ0YmVhdCB2YWx1ZSBpbnZhbGlkLiBWYWxpZCByYW5nZSAoIHggPiAnICsgUFJFU0VOQ0VfSEJfVEhSRVNIT0xEICsgJyBvciB4ID0gMCkuIEN1cnJlbnQgVmFsdWUgOiAnICsgKGN1cl9oZWFydGJlYXQgfHwgUFJFU0VOQ0VfSEJfVEhSRVNIT0xEKSk7XG5cdCAgICAgIHJldHVybiBjdXJfaGVhcnRiZWF0IHx8IFBSRVNFTkNFX0hCX1RIUkVTSE9MRDtcblx0ICAgIH0gZWxzZSByZXR1cm4gaGVhcnRiZWF0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGVuY3J5cHQoaW5wdXQsIGtleSkge1xuXHQgICAgcmV0dXJuIGNyeXB0b19vYmpbJ2VuY3J5cHQnXShpbnB1dCwga2V5IHx8IENJUEhFUl9LRVkpIHx8IGlucHV0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGRlY3J5cHQoaW5wdXQsIGtleSkge1xuXHQgICAgcmV0dXJuIGNyeXB0b19vYmpbJ2RlY3J5cHQnXShpbnB1dCwga2V5IHx8IENJUEhFUl9LRVkpIHx8XG5cdCAgICAgIGNyeXB0b19vYmpbJ2RlY3J5cHQnXShpbnB1dCwgQ0lQSEVSX0tFWSkgfHxcblx0ICAgICAgaW5wdXQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZXJyb3JfY29tbW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG5cdCAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh7IGVycm9yOiBtZXNzYWdlIHx8ICdlcnJvciBvY2N1cnJlZCcgfSk7XG5cdCAgICBlcnJvciAmJiBlcnJvcihtZXNzYWdlKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfcHJlc2VuY2VfaGVhcnRiZWF0KCkge1xuXHQgICAgY2xlYXJUaW1lb3V0KFBSRVNFTkNFX0hCX1RJTUVPVVQpO1xuXG5cdCAgICBpZiAoIVBSRVNFTkNFX0hCX0lOVEVSVkFMIHx8IFBSRVNFTkNFX0hCX0lOVEVSVkFMID49IDUwMCB8fFxuXHQgICAgICBQUkVTRU5DRV9IQl9JTlRFUlZBTCA8IDEgfHxcblx0ICAgICAgKCFnZW5lcmF0ZV9jaGFubmVsX2xpc3QoQ0hBTk5FTFMsIHRydWUpLmxlbmd0aCAmJiAhZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KENIQU5ORUxfR1JPVVBTLCB0cnVlKS5sZW5ndGgpKSB7XG5cdCAgICAgIFBSRVNFTkNFX0hCX1JVTk5JTkcgPSBmYWxzZTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBQUkVTRU5DRV9IQl9SVU5OSU5HID0gdHJ1ZTtcblx0ICAgIFNFTEZbJ3ByZXNlbmNlX2hlYXJ0YmVhdCddKHtcblx0ICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChyKSB7XG5cdCAgICAgICAgUFJFU0VOQ0VfSEJfVElNRU9VVCA9IHV0aWxzLnRpbWVvdXQoX3ByZXNlbmNlX2hlYXJ0YmVhdCwgKFBSRVNFTkNFX0hCX0lOVEVSVkFMKSAqIFNFQ09ORCk7XG5cdCAgICAgIH0sXG5cdCAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIGVycm9yICYmIGVycm9yKCdQcmVzZW5jZSBIZWFydGJlYXQgdW5hYmxlIHRvIHJlYWNoIFB1Ym51YiBzZXJ2ZXJzLicgKyBKU09OLnN0cmluZ2lmeShlKSk7XG5cdCAgICAgICAgUFJFU0VOQ0VfSEJfVElNRU9VVCA9IHV0aWxzLnRpbWVvdXQoX3ByZXNlbmNlX2hlYXJ0YmVhdCwgKFBSRVNFTkNFX0hCX0lOVEVSVkFMKSAqIFNFQ09ORCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHN0YXJ0X3ByZXNlbmNlX2hlYXJ0YmVhdCgpIHtcblx0ICAgICFQUkVTRU5DRV9IQl9SVU5OSU5HICYmIF9wcmVzZW5jZV9oZWFydGJlYXQoKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBwdWJsaXNoKG5leHQpIHtcblx0ICAgIGlmIChOT19XQUlUX0ZPUl9QRU5ESU5HKSB7XG5cdCAgICAgIGlmICghUFVCX1FVRVVFLmxlbmd0aCkgcmV0dXJuO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKG5leHQpIFBVQl9RVUVVRS5zZW5kaW5nID0gMDtcblx0ICAgICAgaWYgKFBVQl9RVUVVRS5zZW5kaW5nIHx8ICFQVUJfUVVFVUUubGVuZ3RoKSByZXR1cm47XG5cdCAgICAgIFBVQl9RVUVVRS5zZW5kaW5nID0gMTtcblx0ICAgIH1cblxuXHQgICAgeGRyKFBVQl9RVUVVRS5zaGlmdCgpKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBlYWNoX2NoYW5uZWxfZ3JvdXAoY2FsbGJhY2spIHtcblx0ICAgIHZhciBjb3VudCA9IDA7XG5cblx0ICAgIHV0aWxzLmVhY2goZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KENIQU5ORUxfR1JPVVBTKSwgZnVuY3Rpb24gKGNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgdmFyIGNoYW5nID0gQ0hBTk5FTF9HUk9VUFNbY2hhbm5lbF9ncm91cF07XG5cblx0ICAgICAgaWYgKCFjaGFuZykgcmV0dXJuO1xuXG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICAgIChjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIH0pKGNoYW5nKTtcblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gY291bnQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZWFjaF9jaGFubmVsKGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgY291bnQgPSAwO1xuXG5cdCAgICB1dGlscy5lYWNoKGdlbmVyYXRlX2NoYW5uZWxfbGlzdChDSEFOTkVMUyksIGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgIHZhciBjaGFuID0gQ0hBTk5FTFNbY2hhbm5lbF07XG5cblx0ICAgICAgaWYgKCFjaGFuKSByZXR1cm47XG5cblx0ICAgICAgY291bnQrKztcblx0ICAgICAgKGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgfSkoY2hhbik7XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIGNvdW50O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpIHtcblx0ICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT0gJ29iamVjdCcpIHtcblx0ICAgICAgaWYgKHJlc3BvbnNlWydlcnJvciddKSB7XG5cdCAgICAgICAgdmFyIGNhbGxiYWNrX2RhdGEgPSB7fTtcblxuXHQgICAgICAgIGlmIChyZXNwb25zZVsnbWVzc2FnZSddKSB7XG5cdCAgICAgICAgICBjYWxsYmFja19kYXRhWydtZXNzYWdlJ10gPSByZXNwb25zZVsnbWVzc2FnZSddO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChyZXNwb25zZVsncGF5bG9hZCddKSB7XG5cdCAgICAgICAgICBjYWxsYmFja19kYXRhWydwYXlsb2FkJ10gPSByZXNwb25zZVsncGF5bG9hZCddO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGVyciAmJiBlcnIoY2FsbGJhY2tfZGF0YSk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChyZXNwb25zZVsncGF5bG9hZCddKSB7XG5cdCAgICAgICAgaWYgKHJlc3BvbnNlWyduZXh0X3BhZ2UnXSkge1xuXHQgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcG9uc2VbJ3BheWxvYWQnXSwgcmVzcG9uc2VbJ25leHRfcGFnZSddKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcG9uc2VbJ3BheWxvYWQnXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcG9uc2UpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycikge1xuXHQgICAgaWYgKHR5cGVvZiByZXNwb25zZSA9PSAnb2JqZWN0JyAmJiByZXNwb25zZVsnZXJyb3InXSkge1xuXHQgICAgICB2YXIgY2FsbGJhY2tfZGF0YSA9IHt9O1xuXG5cdCAgICAgIGlmIChyZXNwb25zZVsnbWVzc2FnZSddKSB7XG5cdCAgICAgICAgY2FsbGJhY2tfZGF0YVsnbWVzc2FnZSddID0gcmVzcG9uc2VbJ21lc3NhZ2UnXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChyZXNwb25zZVsncGF5bG9hZCddKSB7XG5cdCAgICAgICAgY2FsbGJhY2tfZGF0YVsncGF5bG9hZCddID0gcmVzcG9uc2VbJ3BheWxvYWQnXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGVyciAmJiBlcnIoY2FsbGJhY2tfZGF0YSk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVyciAmJiBlcnIocmVzcG9uc2UpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIENSKGFyZ3MsIGNhbGxiYWNrLCB1cmwxLCBkYXRhKSB7XG5cdCAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGNhbGxiYWNrO1xuXHQgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZXJyb3I7XG5cdCAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICBkYXRhID0gZGF0YSB8fCB7fTtcblxuXHQgICAgaWYgKCFkYXRhWydhdXRoJ10pIHtcblx0ICAgICAgZGF0YVsnYXV0aCddID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHVybCA9IFtcblx0ICAgICAgU1REX09SSUdJTiwgJ3YxJywgJ2NoYW5uZWwtcmVnaXN0cmF0aW9uJyxcblx0ICAgICAgJ3N1Yi1rZXknLCBTVUJTQ1JJQkVfS0VZXG5cdCAgICBdO1xuXG5cdCAgICB1cmwucHVzaC5hcHBseSh1cmwsIHVybDEpO1xuXG5cdCAgICBpZiAoanNvbnApIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblxuXHQgICAgeGRyKHtcblx0ICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICB9LFxuXHQgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICB9LFxuXHQgICAgICB1cmw6IHVybFxuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgLy8gQW5ub3VuY2UgTGVhdmUgRXZlbnRcblx0ICB2YXIgU0VMRiA9IHtcblx0ICAgIExFQVZFOiBmdW5jdGlvbiAoY2hhbm5lbCwgYmxvY2tpbmcsIGF1dGhfa2V5LCBjYWxsYmFjaywgZXJyb3IpIHtcblx0ICAgICAgdmFyIGRhdGEgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IGF1dGhfa2V5IHx8IEFVVEhfS0VZIH07XG5cdCAgICAgIHZhciBvcmlnaW4gPSBuZXh0b3JpZ2luKE9SSUdJTik7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgZXJyID0gZXJyb3IgfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciB1cmw7XG5cdCAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cblx0ICAgICAgLy8gUHJldmVudCBMZWF2aW5nIGEgUHJlc2VuY2UgQ2hhbm5lbFxuXHQgICAgICBpZiAoY2hhbm5lbC5pbmRleE9mKFBSRVNFTkNFX1NVRkZJWCkgPiAwKSByZXR1cm4gdHJ1ZTtcblxuXG5cdCAgICAgIGlmIChDT01QQVRJQkxFXzM1KSB7XG5cdCAgICAgICAgaWYgKCFTU0wpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICBpZiAoanNvbnAgPT0gJzAnKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoTk9MRUFWRSkgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblxuXHQgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIGRhdGFbJ2luc3RhbmNlaWQnXSA9IElOU1RBTkNFSUQ7XG5cblx0ICAgICAgdXJsID0gW1xuXHQgICAgICAgIG9yaWdpbiwgJ3YyJywgJ3ByZXNlbmNlJywgJ3N1Yl9rZXknLFxuXHQgICAgICAgIFNVQlNDUklCRV9LRVksICdjaGFubmVsJywgdXRpbHMuZW5jb2RlKGNoYW5uZWwpLCAnbGVhdmUnXG5cdCAgICAgIF07XG5cblx0ICAgICAgcGFyYW1zID0gX2dldF91cmxfcGFyYW1zKGRhdGEpO1xuXG5cblx0ICAgICAgaWYgKHNlbmRCZWFjb24pIHtcblx0ICAgICAgICB2YXIgdXJsX3N0cmluZyA9IHV0aWxzLmJ1aWxkVVJMKHVybCwgcGFyYW1zKTtcblx0ICAgICAgICBpZiAoc2VuZEJlYWNvbih1cmxfc3RyaW5nKSkge1xuXHQgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soeyBzdGF0dXM6IDIwMCwgYWN0aW9uOiAnbGVhdmUnLCBtZXNzYWdlOiAnT0snLCBzZXJ2aWNlOiAnUHJlc2VuY2UnIH0pO1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGJsb2NraW5nOiBibG9ja2luZyB8fCBTU0wsXG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IHBhcmFtcyxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSxcblxuXHQgICAgTEVBVkVfR1JPVVA6IGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwLCBibG9ja2luZywgYXV0aF9rZXksIGNhbGxiYWNrLCBlcnJvcikge1xuXHQgICAgICB2YXIgZGF0YSA9IHsgdXVpZDogVVVJRCwgYXV0aDogYXV0aF9rZXkgfHwgQVVUSF9LRVkgfTtcblx0ICAgICAgdmFyIG9yaWdpbiA9IG5leHRvcmlnaW4oT1JJR0lOKTtcblx0ICAgICAgdmFyIHVybDtcblx0ICAgICAgdmFyIHBhcmFtcztcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBlcnIgPSBlcnJvciB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblxuXHQgICAgICAvLyBQcmV2ZW50IExlYXZpbmcgYSBQcmVzZW5jZSBDaGFubmVsIEdyb3VwXG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwLmluZGV4T2YoUFJFU0VOQ0VfU1VGRklYKSA+IDApIHJldHVybiB0cnVlO1xuXG5cdCAgICAgIGlmIChDT01QQVRJQkxFXzM1KSB7XG5cdCAgICAgICAgaWYgKCFTU0wpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICBpZiAoanNvbnAgPT0gJzAnKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoTk9MRUFWRSkgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblxuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cCAmJiBjaGFubmVsX2dyb3VwLmxlbmd0aCA+IDApIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXA7XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHVybCA9IFtcblx0ICAgICAgICBvcmlnaW4sICd2MicsICdwcmVzZW5jZScsICdzdWJfa2V5Jyxcblx0ICAgICAgICBTVUJTQ1JJQkVfS0VZLCAnY2hhbm5lbCcsIHV0aWxzLmVuY29kZSgnLCcpLCAnbGVhdmUnXG5cdCAgICAgIF07XG5cblx0ICAgICAgcGFyYW1zID0gX2dldF91cmxfcGFyYW1zKGRhdGEpO1xuXG5cdCAgICAgIGlmIChzZW5kQmVhY29uKSB7XG5cdCAgICAgICAgdmFyIHVybF9zdHJpbmcgPSB1dGlscy5idWlsZFVSTCh1cmwsIHBhcmFtcyk7XG5cdCAgICAgICAgaWYgKHNlbmRCZWFjb24odXJsX3N0cmluZykpIHtcblx0ICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHsgc3RhdHVzOiAyMDAsIGFjdGlvbjogJ2xlYXZlJywgbWVzc2FnZTogJ09LJywgc2VydmljZTogJ1ByZXNlbmNlJyB9KTtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgYmxvY2tpbmc6IGJsb2NraW5nIHx8IFNTTCxcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogcGFyYW1zLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cmw6IHVybFxuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRfcmVzdW1lZDogZnVuY3Rpb24gKHJlc3VtZWQpIHtcblx0ICAgICAgUkVTVU1FRCA9IHJlc3VtZWQ7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRfY2lwaGVyX2tleTogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gQ0lQSEVSX0tFWTtcblx0ICAgIH0sXG5cblx0ICAgIHNldF9jaXBoZXJfa2V5OiBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgIENJUEhFUl9LRVkgPSBrZXk7XG5cdCAgICB9LFxuXG5cdCAgICByYXdfZW5jcnlwdDogZnVuY3Rpb24gKGlucHV0LCBrZXkpIHtcblx0ICAgICAgcmV0dXJuIGVuY3J5cHQoaW5wdXQsIGtleSk7XG5cdCAgICB9LFxuXG5cdCAgICByYXdfZGVjcnlwdDogZnVuY3Rpb24gKGlucHV0LCBrZXkpIHtcblx0ICAgICAgcmV0dXJuIGRlY3J5cHQoaW5wdXQsIGtleSk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRfaGVhcnRiZWF0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBQUkVTRU5DRV9IQjtcblx0ICAgIH0sXG5cblx0ICAgIHNldF9oZWFydGJlYXQ6IGZ1bmN0aW9uIChoZWFydGJlYXQsIGhlYXJ0YmVhdF9pbnRlcnZhbCkge1xuXHQgICAgICBQUkVTRU5DRV9IQiA9IHZhbGlkYXRlX3ByZXNlbmNlX2hlYXJ0YmVhdChoZWFydGJlYXQsIFBSRVNFTkNFX0hCLCBlcnJvcik7XG5cdCAgICAgIFBSRVNFTkNFX0hCX0lOVEVSVkFMID0gaGVhcnRiZWF0X2ludGVydmFsIHx8IChQUkVTRU5DRV9IQiAvIDIpIC0gMTtcblx0ICAgICAgaWYgKFBSRVNFTkNFX0hCID09IDIpIHtcblx0ICAgICAgICBQUkVTRU5DRV9IQl9JTlRFUlZBTCA9IDE7XG5cdCAgICAgIH1cblx0ICAgICAgQ09OTkVDVCgpO1xuXHQgICAgICBfcHJlc2VuY2VfaGVhcnRiZWF0KCk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRfaGVhcnRiZWF0X2ludGVydmFsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBQUkVTRU5DRV9IQl9JTlRFUlZBTDtcblx0ICAgIH0sXG5cblx0ICAgIHNldF9oZWFydGJlYXRfaW50ZXJ2YWw6IGZ1bmN0aW9uIChoZWFydGJlYXRfaW50ZXJ2YWwpIHtcblx0ICAgICAgUFJFU0VOQ0VfSEJfSU5URVJWQUwgPSBoZWFydGJlYXRfaW50ZXJ2YWw7XG5cdCAgICAgIF9wcmVzZW5jZV9oZWFydGJlYXQoKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldF92ZXJzaW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBTREtfVkVSO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0R2NtTWVzc2FnZU9iamVjdDogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRhdGE6IG9ialxuXHQgICAgICB9O1xuXHQgICAgfSxcblxuXHQgICAgZ2V0QXBuc01lc3NhZ2VPYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgdmFyIHggPSB7XG5cdCAgICAgICAgYXBzOiB7IGJhZGdlOiAxLCBhbGVydDogJycgfVxuXHQgICAgICB9O1xuXHQgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuXHQgICAgICAgIGtbeF0gPSBvYmpba107XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHg7XG5cdCAgICB9LFxuXG5cdCAgICBfYWRkX3BhcmFtOiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0ICAgICAgcGFyYW1zW2tleV0gPSB2YWw7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIG5zX2NoID0gYXJnc1snY2hhbm5lbF9ncm91cCddO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBhcmdzWydjYWxsYmFjayddO1xuXHQgICAgICB2YXIgY2hhbm5lbHMgPSBhcmdzWydjaGFubmVscyddIHx8IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNsb2FrID0gYXJnc1snY2xvYWsnXTtcblx0ICAgICAgdmFyIG5hbWVzcGFjZTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXA7XG5cdCAgICAgIHZhciB1cmwgPSBbXTtcblx0ICAgICAgdmFyIGRhdGEgPSB7fTtcblx0ICAgICAgdmFyIG1vZGUgPSBhcmdzWydtb2RlJ10gfHwgJ2FkZCc7XG5cblxuXHQgICAgICBpZiAobnNfY2gpIHtcblx0ICAgICAgICB2YXIgbnNfY2hfYSA9IG5zX2NoLnNwbGl0KCc6Jyk7XG5cblx0ICAgICAgICBpZiAobnNfY2hfYS5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICBuYW1lc3BhY2UgPSAobnNfY2hfYVswXSA9PT0gJyonKSA/IG51bGwgOiBuc19jaF9hWzBdO1xuXG5cdCAgICAgICAgICBjaGFubmVsX2dyb3VwID0gbnNfY2hfYVsxXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY2hhbm5lbF9ncm91cCA9IG5zX2NoX2FbMF07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgbmFtZXNwYWNlICYmIHVybC5wdXNoKCduYW1lc3BhY2UnKSAmJiB1cmwucHVzaCh1dGlscy5lbmNvZGUobmFtZXNwYWNlKSk7XG5cblx0ICAgICAgdXJsLnB1c2goJ2NoYW5uZWwtZ3JvdXAnKTtcblxuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cCAmJiBjaGFubmVsX2dyb3VwICE9PSAnKicpIHtcblx0ICAgICAgICB1cmwucHVzaChjaGFubmVsX2dyb3VwKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjaGFubmVscykge1xuXHQgICAgICAgIGlmICh1dGlscy5pc0FycmF5KGNoYW5uZWxzKSkge1xuXHQgICAgICAgICAgY2hhbm5lbHMgPSBjaGFubmVscy5qb2luKCcsJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGRhdGFbbW9kZV0gPSBjaGFubmVscztcblx0ICAgICAgICBkYXRhWydjbG9hayddID0gKENMT0FLKSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKG1vZGUgPT09ICdyZW1vdmUnKSB1cmwucHVzaCgncmVtb3ZlJyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodHlwZW9mIGNsb2FrICE9ICd1bmRlZmluZWQnKSBkYXRhWydjbG9hayddID0gKGNsb2FrKSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cblx0ICAgICAgQ1IoYXJncywgY2FsbGJhY2ssIHVybCwgZGF0YSk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX2xpc3RfZ3JvdXBzOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIG5hbWVzcGFjZTtcblxuXHQgICAgICBuYW1lc3BhY2UgPSBhcmdzWyduYW1lc3BhY2UnXSB8fCBhcmdzWyducyddIHx8IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSB8fCBudWxsO1xuXHQgICAgICBpZiAobmFtZXNwYWNlKSB7XG5cdCAgICAgICAgYXJnc1snY2hhbm5lbF9ncm91cCddID0gbmFtZXNwYWNlICsgJzoqJztcblx0ICAgICAgfVxuXG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX2xpc3RfY2hhbm5lbHM6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBpZiAoIWFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwgR3JvdXAnKTtcblx0ICAgICAgU0VMRlsnY2hhbm5lbF9ncm91cCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfcmVtb3ZlX2NoYW5uZWw6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBpZiAoIWFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwgR3JvdXAnKTtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsJ10gJiYgIWFyZ3NbJ2NoYW5uZWxzJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsJyk7XG5cblx0ICAgICAgYXJnc1snbW9kZSddID0gJ3JlbW92ZSc7XG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX3JlbW92ZV9ncm91cDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIGlmICghYXJnc1snY2hhbm5lbF9ncm91cCddKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCBHcm91cCcpO1xuXHQgICAgICBpZiAoYXJnc1snY2hhbm5lbCddKSByZXR1cm4gZXJyb3IoJ1VzZSBjaGFubmVsX2dyb3VwX3JlbW92ZV9jaGFubmVsIGlmIHlvdSB3YW50IHRvIHJlbW92ZSBhIGNoYW5uZWwgZnJvbSBhIGdyb3VwLicpO1xuXG5cdCAgICAgIGFyZ3NbJ21vZGUnXSA9ICdyZW1vdmUnO1xuXHQgICAgICBTRUxGWydjaGFubmVsX2dyb3VwJ10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9hZGRfY2hhbm5lbDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIGlmICghYXJnc1snY2hhbm5lbF9ncm91cCddKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCBHcm91cCcpO1xuXHQgICAgICBpZiAoIWFyZ3NbJ2NoYW5uZWwnXSAmJiAhYXJnc1snY2hhbm5lbHMnXSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblx0ICAgICAgU0VMRlsnY2hhbm5lbF9ncm91cCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfY2xvYWs6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBpZiAodHlwZW9mIGFyZ3NbJ2Nsb2FrJ10gPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICBjYWxsYmFjayhDTE9BSyk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIENMT0FLID0gYXJnc1snY2xvYWsnXTtcblx0ICAgICAgU0VMRlsnY2hhbm5lbF9ncm91cCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfbGlzdF9uYW1lc3BhY2VzOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIHVybCA9IFsnbmFtZXNwYWNlJ107XG5cdCAgICAgIENSKGFyZ3MsIGNhbGxiYWNrLCB1cmwpO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9yZW1vdmVfbmFtZXNwYWNlOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIHVybCA9IFsnbmFtZXNwYWNlJywgYXJnc1snbmFtZXNwYWNlJ10sICdyZW1vdmUnXTtcblx0ICAgICAgQ1IoYXJncywgY2FsbGJhY2ssIHVybCk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5oaXN0b3J5KHtcblx0ICAgICBjaGFubmVsICA6ICdteV9jaGF0X2NoYW5uZWwnLFxuXHQgICAgIGxpbWl0ICAgIDogMTAwLFxuXHQgICAgIGNhbGxiYWNrIDogZnVuY3Rpb24oaGlzdG9yeSkgeyB9XG5cdCAgICAgfSk7XG5cdCAgICAgKi9cblx0ICAgIGhpc3Rvcnk6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGNhbGxiYWNrO1xuXHQgICAgICB2YXIgY291bnQgPSBhcmdzWydjb3VudCddIHx8IGFyZ3NbJ2xpbWl0J10gfHwgMTAwO1xuXHQgICAgICB2YXIgcmV2ZXJzZSA9IGFyZ3NbJ3JldmVyc2UnXSB8fCAnZmFsc2UnO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIGNpcGhlcl9rZXkgPSBhcmdzWydjaXBoZXJfa2V5J107XG5cdCAgICAgIHZhciBjaGFubmVsID0gYXJnc1snY2hhbm5lbCddO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIHN0YXJ0ID0gYXJnc1snc3RhcnQnXTtcblx0ICAgICAgdmFyIGVuZCA9IGFyZ3NbJ2VuZCddO1xuXHQgICAgICB2YXIgaW5jbHVkZV90b2tlbiA9IGFyZ3NbJ2luY2x1ZGVfdG9rZW4nXTtcblx0ICAgICAgdmFyIHN0cmluZ19tc2dfdG9rZW4gPSBhcmdzWydzdHJpbmdfbWVzc2FnZV90b2tlbiddIHx8IGZhbHNlO1xuXHQgICAgICB2YXIgcGFyYW1zID0ge307XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cblx0ICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBDaGFubmVsXG5cdCAgICAgIGlmICghY2hhbm5lbCAmJiAhY2hhbm5lbF9ncm91cCkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblx0ICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENhbGxiYWNrJyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICBwYXJhbXNbJ3N0cmluZ3Rva2VuJ10gPSAndHJ1ZSc7XG5cdCAgICAgIHBhcmFtc1snY291bnQnXSA9IGNvdW50O1xuXHQgICAgICBwYXJhbXNbJ3JldmVyc2UnXSA9IHJldmVyc2U7XG5cdCAgICAgIHBhcmFtc1snYXV0aCddID0gYXV0aF9rZXk7XG5cblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgICBwYXJhbXNbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXA7XG5cdCAgICAgICAgaWYgKCFjaGFubmVsKSB7XG5cdCAgICAgICAgICBjaGFubmVsID0gJywnO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAoanNvbnApIHBhcmFtc1snY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICBpZiAoc3RhcnQpIHBhcmFtc1snc3RhcnQnXSA9IHN0YXJ0O1xuXHQgICAgICBpZiAoZW5kKSBwYXJhbXNbJ2VuZCddID0gZW5kO1xuXHQgICAgICBpZiAoaW5jbHVkZV90b2tlbikgcGFyYW1zWydpbmNsdWRlX3Rva2VuJ10gPSAndHJ1ZSc7XG5cdCAgICAgIGlmIChzdHJpbmdfbXNnX3Rva2VuKSBwYXJhbXNbJ3N0cmluZ19tZXNzYWdlX3Rva2VuJ10gPSAndHJ1ZSc7XG5cblx0ICAgICAgLy8gU2VuZCBNZXNzYWdlXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhwYXJhbXMpLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZSA9PSAnb2JqZWN0JyAmJiByZXNwb25zZVsnZXJyb3InXSkge1xuXHQgICAgICAgICAgICBlcnIoeyBtZXNzYWdlOiByZXNwb25zZVsnbWVzc2FnZSddLCBwYXlsb2FkOiByZXNwb25zZVsncGF5bG9hZCddIH0pO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICB2YXIgbWVzc2FnZXMgPSByZXNwb25zZVswXTtcblx0ICAgICAgICAgIHZhciBkZWNyeXB0ZWRfbWVzc2FnZXMgPSBbXTtcblx0ICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbWVzc2FnZXMubGVuZ3RoOyBhKyspIHtcblx0ICAgICAgICAgICAgaWYgKGluY2x1ZGVfdG9rZW4pIHtcblx0ICAgICAgICAgICAgICB2YXIgbmV3X21lc3NhZ2UgPSBkZWNyeXB0KG1lc3NhZ2VzW2FdWydtZXNzYWdlJ10sIGNpcGhlcl9rZXkpO1xuXHQgICAgICAgICAgICAgIHZhciB0aW1ldG9rZW4gPSBtZXNzYWdlc1thXVsndGltZXRva2VuJ107XG5cdCAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGRlY3J5cHRlZF9tZXNzYWdlc1sncHVzaCddKHsgbWVzc2FnZTogSlNPTlsncGFyc2UnXShuZXdfbWVzc2FnZSksIHRpbWV0b2tlbjogdGltZXRva2VuIH0pO1xuXHQgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIGRlY3J5cHRlZF9tZXNzYWdlc1sncHVzaCddKCh7IG1lc3NhZ2U6IG5ld19tZXNzYWdlLCB0aW1ldG9rZW46IHRpbWV0b2tlbiB9KSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIHZhciBuZXdfbWVzc2FnZSA9IGRlY3J5cHQobWVzc2FnZXNbYV0sIGNpcGhlcl9rZXkpO1xuXHQgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBkZWNyeXB0ZWRfbWVzc2FnZXNbJ3B1c2gnXShKU09OWydwYXJzZSddKG5ld19tZXNzYWdlKSk7XG5cdCAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgZGVjcnlwdGVkX21lc3NhZ2VzWydwdXNoJ10oKG5ld19tZXNzYWdlKSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBjYWxsYmFjayhbZGVjcnlwdGVkX21lc3NhZ2VzLCByZXNwb25zZVsxXSwgcmVzcG9uc2VbMl1dKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogW1xuXHQgICAgICAgICAgU1REX09SSUdJTiwgJ3YyJywgJ2hpc3RvcnknLCAnc3ViLWtleScsXG5cdCAgICAgICAgICBTVUJTQ1JJQkVfS0VZLCAnY2hhbm5lbCcsIHV0aWxzLmVuY29kZShjaGFubmVsKVxuXHQgICAgICAgIF1cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5yZXBsYXkoe1xuXHQgICAgIHNvdXJjZSAgICAgIDogJ215X2NoYW5uZWwnLFxuXHQgICAgIGRlc3RpbmF0aW9uIDogJ25ld19jaGFubmVsJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICByZXBsYXk6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBhcmdzWydjYWxsYmFjayddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIgc291cmNlID0gYXJnc1snc291cmNlJ107XG5cdCAgICAgIHZhciBkZXN0aW5hdGlvbiA9IGFyZ3NbJ2Rlc3RpbmF0aW9uJ107XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBzdG9wID0gYXJnc1snc3RvcCddO1xuXHQgICAgICB2YXIgc3RhcnQgPSBhcmdzWydzdGFydCddO1xuXHQgICAgICB2YXIgZW5kID0gYXJnc1snZW5kJ107XG5cdCAgICAgIHZhciByZXZlcnNlID0gYXJnc1sncmV2ZXJzZSddO1xuXHQgICAgICB2YXIgbGltaXQgPSBhcmdzWydsaW1pdCddO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgZGF0YSA9IHt9O1xuXHQgICAgICB2YXIgdXJsO1xuXG5cdCAgICAgIC8vIENoZWNrIFVzZXIgSW5wdXRcblx0ICAgICAgaWYgKCFzb3VyY2UpIHJldHVybiBlcnJvcignTWlzc2luZyBTb3VyY2UgQ2hhbm5lbCcpO1xuXHQgICAgICBpZiAoIWRlc3RpbmF0aW9uKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgRGVzdGluYXRpb24gQ2hhbm5lbCcpO1xuXHQgICAgICBpZiAoIVBVQkxJU0hfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgUHVibGlzaCBLZXknKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXG5cdCAgICAgIC8vIFNldHVwIFVSTCBQYXJhbXNcblx0ICAgICAgaWYgKGpzb25wICE9ICcwJykgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICBpZiAoc3RvcCkgZGF0YVsnc3RvcCddID0gJ2FsbCc7XG5cdCAgICAgIGlmIChyZXZlcnNlKSBkYXRhWydyZXZlcnNlJ10gPSAndHJ1ZSc7XG5cdCAgICAgIGlmIChzdGFydCkgZGF0YVsnc3RhcnQnXSA9IHN0YXJ0O1xuXHQgICAgICBpZiAoZW5kKSBkYXRhWydlbmQnXSA9IGVuZDtcblx0ICAgICAgaWYgKGxpbWl0KSBkYXRhWydjb3VudCddID0gbGltaXQ7XG5cblx0ICAgICAgZGF0YVsnYXV0aCddID0gYXV0aF9rZXk7XG5cblx0ICAgICAgLy8gQ29tcG9zZSBVUkwgUGFydHNcblx0ICAgICAgdXJsID0gW1xuXHQgICAgICAgIFNURF9PUklHSU4sICd2MScsICdyZXBsYXknLFxuXHQgICAgICAgIFBVQkxJU0hfS0VZLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgIHNvdXJjZSwgZGVzdGluYXRpb25cblx0ICAgICAgXTtcblxuXHQgICAgICAvLyBTdGFydCAob3IgU3RvcCkgUmVwbGF5IVxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgY2FsbGJhY2soWzAsICdEaXNjb25uZWN0ZWQnXSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cmw6IHVybCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSlcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5hdXRoKCdBSkZMS0FKU0RLTEEnKTtcblx0ICAgICAqL1xuXHQgICAgYXV0aDogZnVuY3Rpb24gKGF1dGgpIHtcblx0ICAgICAgQVVUSF9LRVkgPSBhdXRoO1xuXHQgICAgICBDT05ORUNUKCk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi50aW1lKGZ1bmN0aW9uKHRpbWUpeyB9KTtcblx0ICAgICAqL1xuXHQgICAgdGltZTogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cblx0ICAgICAgdmFyIGRhdGEgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IEFVVEhfS0VZIH07XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICB1cmw6IFtTVERfT1JJR0lOLCAndGltZScsIGpzb25wXSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlWzBdKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5wdWJsaXNoKHtcblx0ICAgICBjaGFubmVsIDogJ215X2NoYXRfY2hhbm5lbCcsXG5cdCAgICAgbWVzc2FnZSA6ICdoZWxsbyEnXG5cdCAgICAgfSk7XG5cdCAgICAgKi9cblx0ICAgIHB1Ymxpc2g6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgbXNnID0gYXJnc1snbWVzc2FnZSddO1xuXHQgICAgICBpZiAoIW1zZykgcmV0dXJuIGVycm9yKCdNaXNzaW5nIE1lc3NhZ2UnKTtcblxuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBhcmdzWydjYWxsYmFjayddIHx8IG1zZ1snY2FsbGJhY2snXSB8fCBhcmdzWydzdWNjZXNzJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBjaGFubmVsID0gYXJnc1snY2hhbm5lbCddIHx8IG1zZ1snY2hhbm5lbCddO1xuXHQgICAgICB2YXIgbWV0YSA9IGFyZ3NbJ21ldGEnXSB8fCBhcmdzWydtZXRhZGF0YSddO1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIgY2lwaGVyX2tleSA9IGFyZ3NbJ2NpcGhlcl9rZXknXTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgbXNnWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgcG9zdCA9IGFyZ3NbJ3Bvc3QnXSB8fCBmYWxzZTtcblx0ICAgICAgdmFyIHN0b3JlID0gKCdzdG9yZV9pbl9oaXN0b3J5JyBpbiBhcmdzKSA/IGFyZ3NbJ3N0b3JlX2luX2hpc3RvcnknXSA6IHRydWU7XG5cdCAgICAgIHZhciByZXBsaWNhdGUgPSAoJ3JlcGxpY2F0ZScgaW4gYXJncykgPyBhcmdzWydyZXBsaWNhdGUnXSA6IHRydWU7XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciBhZGRfbXNnID0gJ3B1c2gnO1xuXHQgICAgICB2YXIgcGFyYW1zO1xuXHQgICAgICB2YXIgdXJsO1xuXG5cdCAgICAgIGlmIChhcmdzWydwcmVwZW5kJ10pIGFkZF9tc2cgPSAndW5zaGlmdCc7XG5cblx0ICAgICAgaWYgKCFjaGFubmVsKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCcpO1xuXHQgICAgICBpZiAoIVBVQkxJU0hfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgUHVibGlzaCBLZXknKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXG5cdCAgICAgIGlmIChtc2dbJ2dldFB1Ym51Yk1lc3NhZ2UnXSkge1xuXHQgICAgICAgIG1zZyA9IG1zZ1snZ2V0UHVibnViTWVzc2FnZSddKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBJZiB0cnlpbmcgdG8gc2VuZCBPYmplY3Rcblx0ICAgICAgbXNnID0gSlNPTlsnc3RyaW5naWZ5J10oZW5jcnlwdChtc2csIGNpcGhlcl9rZXkpKTtcblxuXHQgICAgICAvLyBDcmVhdGUgVVJMXG5cdCAgICAgIHVybCA9IFtcblx0ICAgICAgICBTVERfT1JJR0lOLCAncHVibGlzaCcsXG5cdCAgICAgICAgUFVCTElTSF9LRVksIFNVQlNDUklCRV9LRVksXG5cdCAgICAgICAgMCwgdXRpbHMuZW5jb2RlKGNoYW5uZWwpLFxuXHQgICAgICAgIGpzb25wLCB1dGlscy5lbmNvZGUobXNnKVxuXHQgICAgICBdO1xuXG5cdCAgICAgIHBhcmFtcyA9IHsgdXVpZDogVVVJRCwgYXV0aDogYXV0aF9rZXkgfTtcblxuXHQgICAgICBpZiAobWV0YSAmJiB0eXBlb2YgbWV0YSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICBwYXJhbXNbJ21ldGEnXSA9IEpTT04uc3RyaW5naWZ5KG1ldGEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFzdG9yZSkgcGFyYW1zWydzdG9yZSddID0gJzAnO1xuXHQgICAgICBpZiAoIXJlcGxpY2F0ZSkgcGFyYW1zWydub3JlcCddID0gJ3RydWUnO1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgcGFyYW1zWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIC8vIFF1ZXVlIE1lc3NhZ2UgU2VuZFxuXHQgICAgICBQVUJfUVVFVUVbYWRkX21zZ10oe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICB1cmw6IHVybCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMocGFyYW1zKSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgICBwdWJsaXNoKDEpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICAgIHB1Ymxpc2goMSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBtb2RlOiAocG9zdCkgPyAnUE9TVCcgOiAnR0VUJ1xuXHQgICAgICB9KTtcblxuXHQgICAgICAvLyBTZW5kIE1lc3NhZ2Vcblx0ICAgICAgcHVibGlzaCgpO1xuXHQgICAgfSxcblxuXHQgICAgZmlyZTogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIGFyZ3Muc3RvcmVfaW5faGlzdG9yeSA9IGZhbHNlO1xuXHQgICAgICBhcmdzLnJlcGxpY2F0ZSA9IGZhbHNlO1xuXHQgICAgICBTRUxGWydwdWJsaXNoJ10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIudW5zdWJzY3JpYmUoeyBjaGFubmVsIDogJ215X2NoYXQnIH0pO1xuXHQgICAgICovXG5cdCAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjaGFubmVsQXJnID0gYXJnc1snY2hhbm5lbCddO1xuXHQgICAgICB2YXIgY2hhbm5lbEdyb3VwQXJnID0gYXJnc1snY2hhbm5lbF9ncm91cCddO1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBhcmdzWydjYWxsYmFjayddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuXHQgICAgICBpZiAoIWNoYW5uZWxBcmcgJiYgIWNoYW5uZWxHcm91cEFyZykgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwgb3IgQ2hhbm5lbCBHcm91cCcpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgaWYgKGNoYW5uZWxBcmcpIHtcblx0ICAgICAgICB2YXIgY2hhbm5lbHMgPSB1dGlscy5pc0FycmF5KGNoYW5uZWxBcmcpID8gY2hhbm5lbEFyZyA6ICgnJyArIGNoYW5uZWxBcmcpLnNwbGl0KCcsJyk7XG5cdCAgICAgICAgdmFyIGV4aXN0aW5nQ2hhbm5lbHMgPSBbXTtcblx0ICAgICAgICB2YXIgcHJlc2VuY2VDaGFubmVscyA9IFtdO1xuXG5cdCAgICAgICAgdXRpbHMuZWFjaChjaGFubmVscywgZnVuY3Rpb24gKGNoYW5uZWwpIHtcblx0ICAgICAgICAgIGlmIChDSEFOTkVMU1tjaGFubmVsXSkgZXhpc3RpbmdDaGFubmVscy5wdXNoKGNoYW5uZWwpO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLy8gaWYgd2UgZG8gbm90IGhhdmUgYW55IGNoYW5uZWxzIHRvIHVuc3Vic2NyaWJlIGZyb20sIHRyaWdnZXIgYSBjYWxsYmFjay5cblx0ICAgICAgICBpZiAoZXhpc3RpbmdDaGFubmVscy5sZW5ndGggPT0gMCkge1xuXHQgICAgICAgICAgY2FsbGJhY2soeyBhY3Rpb246ICdsZWF2ZScgfSk7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gUHJlcGFyZSBwcmVzZW5jZSBjaGFubmVsc1xuXHQgICAgICAgIHV0aWxzLmVhY2goZXhpc3RpbmdDaGFubmVscywgZnVuY3Rpb24gKGNoYW5uZWwpIHtcblx0ICAgICAgICAgIHByZXNlbmNlQ2hhbm5lbHMucHVzaChjaGFubmVsICsgUFJFU0VOQ0VfU1VGRklYKTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHV0aWxzLmVhY2goZXhpc3RpbmdDaGFubmVscy5jb25jYXQocHJlc2VuY2VDaGFubmVscyksIGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgICBpZiAoY2hhbm5lbCBpbiBDSEFOTkVMUykgZGVsZXRlIENIQU5ORUxTW2NoYW5uZWxdO1xuXHQgICAgICAgICAgaWYgKGNoYW5uZWwgaW4gU1RBVEUpIGRlbGV0ZSBTVEFURVtjaGFubmVsXTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGlmIChDSEFOTkVMUy5sZW5ndGggPT09IDAgJiYgQ0hBTk5FTF9HUk9VUFMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICBUSU1FVE9LRU4gPSAwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBDQl9DQUxMRUQgPSB0cnVlO1xuXHQgICAgICAgIGlmIChSRUFEWSkge1xuXHQgICAgICAgICAgQ0JfQ0FMTEVEID0gU0VMRlsnTEVBVkUnXShleGlzdGluZ0NoYW5uZWxzLmpvaW4oJywnKSwgMCwgYXV0aF9rZXksIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIUNCX0NBTExFRCkgY2FsbGJhY2soeyBhY3Rpb246ICdsZWF2ZScgfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY2hhbm5lbEdyb3VwQXJnKSB7XG5cdCAgICAgICAgdmFyIGNoYW5uZWxHcm91cHMgPSB1dGlscy5pc0FycmF5KGNoYW5uZWxHcm91cEFyZykgPyBjaGFubmVsR3JvdXBBcmcgOiAoJycgKyBjaGFubmVsR3JvdXBBcmcpLnNwbGl0KCcsJyk7XG5cdCAgICAgICAgdmFyIGV4aXN0aW5nQ2hhbm5lbEdyb3VwcyA9IFtdO1xuXHQgICAgICAgIHZhciBwcmVzZW5jZUNoYW5uZWxHcm91cHMgPSBbXTtcblxuXHQgICAgICAgIHV0aWxzLmVhY2goY2hhbm5lbEdyb3VwcywgZnVuY3Rpb24gKGNoYW5uZWxHcm91cCkge1xuXHQgICAgICAgICAgaWYgKENIQU5ORUxfR1JPVVBTW2NoYW5uZWxHcm91cF0pIGV4aXN0aW5nQ2hhbm5lbEdyb3Vwcy5wdXNoKGNoYW5uZWxHcm91cCk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICAvLyBpZiB3ZSBkbyBub3QgaGF2ZSBhbnkgY2hhbm5lbCBncm91cHMgdG8gdW5zdWJzY3JpYmUgZnJvbSwgdHJpZ2dlciBhIGNhbGxiYWNrLlxuXHQgICAgICAgIGlmIChleGlzdGluZ0NoYW5uZWxHcm91cHMubGVuZ3RoID09IDApIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKHsgYWN0aW9uOiAnbGVhdmUnIH0pO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFByZXBhcmUgcHJlc2VuY2UgY2hhbm5lbHNcblx0ICAgICAgICB1dGlscy5lYWNoKGV4aXN0aW5nQ2hhbm5lbEdyb3VwcywgZnVuY3Rpb24gKGNoYW5uZWxHcm91cCkge1xuXHQgICAgICAgICAgcHJlc2VuY2VDaGFubmVsR3JvdXBzLnB1c2goY2hhbm5lbEdyb3VwICsgUFJFU0VOQ0VfU1VGRklYKTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHV0aWxzLmVhY2goZXhpc3RpbmdDaGFubmVsR3JvdXBzLmNvbmNhdChwcmVzZW5jZUNoYW5uZWxHcm91cHMpLCBmdW5jdGlvbiAoY2hhbm5lbEdyb3VwKSB7XG5cdCAgICAgICAgICBpZiAoY2hhbm5lbEdyb3VwIGluIENIQU5ORUxfR1JPVVBTKSBkZWxldGUgQ0hBTk5FTF9HUk9VUFNbY2hhbm5lbEdyb3VwXTtcblx0ICAgICAgICAgIGlmIChjaGFubmVsR3JvdXAgaW4gU1RBVEUpIGRlbGV0ZSBTVEFURVtjaGFubmVsR3JvdXBdO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgaWYgKENIQU5ORUxTLmxlbmd0aCA9PT0gMCAmJiBDSEFOTkVMX0dST1VQUy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgIFRJTUVUT0tFTiA9IDA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIENCX0NBTExFRCA9IHRydWU7XG5cdCAgICAgICAgaWYgKFJFQURZKSB7XG5cdCAgICAgICAgICBDQl9DQUxMRUQgPSBTRUxGWydMRUFWRV9HUk9VUCddKGV4aXN0aW5nQ2hhbm5lbEdyb3Vwcy5qb2luKCcsJyksIDAsIGF1dGhfa2V5LCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFDQl9DQUxMRUQpIGNhbGxiYWNrKHsgYWN0aW9uOiAnbGVhdmUnIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gUmVzZXQgQ29ubmVjdGlvbiBpZiBDb3VudCBMZXNzXG5cdCAgICAgIENPTk5FQ1QoKTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLnN1YnNjcmliZSh7XG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdCdcblx0ICAgICBjYWxsYmFjayA6IGZ1bmN0aW9uKG1lc3NhZ2UpIHsgfVxuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGFyZ3NbJ2NhbGxiYWNrJ107XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGFyZ3NbJ21lc3NhZ2UnXTtcblx0ICAgICAgdmFyIGNvbm5lY3QgPSBhcmdzWydjb25uZWN0J10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciByZWNvbm5lY3QgPSBhcmdzWydyZWNvbm5lY3QnXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGRpc2Nvbm5lY3QgPSBhcmdzWydkaXNjb25uZWN0J10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBTVUJfRVJST1IgPSBhcmdzWydlcnJvciddIHx8IFNVQl9FUlJPUiB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGlkbGVjYiA9IGFyZ3NbJ2lkbGUnXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIHByZXNlbmNlID0gYXJnc1sncHJlc2VuY2UnXSB8fCAwO1xuXHQgICAgICB2YXIgbm9oZXJlc3luYyA9IGFyZ3NbJ25vaGVyZXN5bmMnXSB8fCAwO1xuXHQgICAgICB2YXIgYmFja2ZpbGwgPSBhcmdzWydiYWNrZmlsbCddIHx8IDA7XG5cdCAgICAgIHZhciB0aW1ldG9rZW4gPSBhcmdzWyd0aW1ldG9rZW4nXSB8fCAwO1xuXHQgICAgICB2YXIgc3ViX3RpbWVvdXQgPSBhcmdzWyd0aW1lb3V0J10gfHwgU1VCX1RJTUVPVVQ7XG5cdCAgICAgIHZhciB3aW5kb3dpbmcgPSBhcmdzWyd3aW5kb3dpbmcnXSB8fCBTVUJfV0lORE9XSU5HO1xuXHQgICAgICB2YXIgc3RhdGUgPSBhcmdzWydzdGF0ZSddO1xuXHQgICAgICB2YXIgaGVhcnRiZWF0ID0gYXJnc1snaGVhcnRiZWF0J10gfHwgYXJnc1sncG5leHBpcmVzJ107XG5cdCAgICAgIHZhciBoZWFydGJlYXRfaW50ZXJ2YWwgPSBhcmdzWydoZWFydGJlYXRfaW50ZXJ2YWwnXTtcblx0ICAgICAgdmFyIHJlc3RvcmUgPSBhcmdzWydyZXN0b3JlJ10gfHwgU1VCX1JFU1RPUkU7XG5cblx0ICAgICAgQVVUSF9LRVkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXG5cdCAgICAgIC8vIFJlc3RvcmUgRW5hYmxlZD9cblx0ICAgICAgU1VCX1JFU1RPUkUgPSByZXN0b3JlO1xuXG5cdCAgICAgIC8vIEFsd2F5cyBSZXNldCB0aGUgVFRcblx0ICAgICAgVElNRVRPS0VOID0gdGltZXRva2VuO1xuXG5cdCAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgQ2hhbm5lbFxuXHQgICAgICBpZiAoIWNoYW5uZWwgJiYgIWNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgICByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCcpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENhbGxiYWNrJyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICBpZiAoaGVhcnRiZWF0IHx8IGhlYXJ0YmVhdCA9PT0gMCB8fCBoZWFydGJlYXRfaW50ZXJ2YWwgfHwgaGVhcnRiZWF0X2ludGVydmFsID09PSAwKSB7XG5cdCAgICAgICAgU0VMRlsnc2V0X2hlYXJ0YmVhdCddKGhlYXJ0YmVhdCwgaGVhcnRiZWF0X2ludGVydmFsKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIFNldHVwIENoYW5uZWwocylcblx0ICAgICAgaWYgKGNoYW5uZWwpIHtcblx0ICAgICAgICB1dGlscy5lYWNoKChjaGFubmVsLmpvaW4gPyBjaGFubmVsLmpvaW4oJywnKSA6ICcnICsgY2hhbm5lbCkuc3BsaXQoJywnKSxcblx0ICAgICAgICAgIGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IENIQU5ORUxTW2NoYW5uZWxdIHx8IHt9O1xuXG5cdCAgICAgICAgICAgIC8vIFN0b3JlIENoYW5uZWwgU3RhdGVcblx0ICAgICAgICAgICAgQ0hBTk5FTFNbU1VCX0NIQU5ORUwgPSBjaGFubmVsXSA9IHtcblx0ICAgICAgICAgICAgICBuYW1lOiBjaGFubmVsLFxuXHQgICAgICAgICAgICAgIGNvbm5lY3RlZDogc2V0dGluZ3MuY29ubmVjdGVkLFxuXHQgICAgICAgICAgICAgIGRpc2Nvbm5lY3RlZDogc2V0dGluZ3MuZGlzY29ubmVjdGVkLFxuXHQgICAgICAgICAgICAgIHN1YnNjcmliZWQ6IDEsXG5cdCAgICAgICAgICAgICAgY2FsbGJhY2s6IFNVQl9DQUxMQkFDSyA9IGNhbGxiYWNrLFxuXHQgICAgICAgICAgICAgIGNpcGhlcl9rZXk6IGFyZ3NbJ2NpcGhlcl9rZXknXSxcblx0ICAgICAgICAgICAgICBjb25uZWN0OiBjb25uZWN0LFxuXHQgICAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IGRpc2Nvbm5lY3QsXG5cdCAgICAgICAgICAgICAgcmVjb25uZWN0OiByZWNvbm5lY3Rcblx0ICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICBpZiAoc3RhdGUpIHtcblx0ICAgICAgICAgICAgICBpZiAoY2hhbm5lbCBpbiBzdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgU1RBVEVbY2hhbm5lbF0gPSBzdGF0ZVtjaGFubmVsXTtcblx0ICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgU1RBVEVbY2hhbm5lbF0gPSBzdGF0ZTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQcmVzZW5jZSBFbmFibGVkP1xuXHQgICAgICAgICAgICBpZiAoIXByZXNlbmNlKSByZXR1cm47XG5cblx0ICAgICAgICAgICAgLy8gU3Vic2NyaWJlIFByZXNlbmNlIENoYW5uZWxcblx0ICAgICAgICAgICAgU0VMRlsnc3Vic2NyaWJlJ10oe1xuXHQgICAgICAgICAgICAgIGNoYW5uZWw6IGNoYW5uZWwgKyBQUkVTRU5DRV9TVUZGSVgsXG5cdCAgICAgICAgICAgICAgY2FsbGJhY2s6IHByZXNlbmNlLFxuXHQgICAgICAgICAgICAgIHJlc3RvcmU6IHJlc3RvcmVcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgLy8gUHJlc2VuY2UgU3Vic2NyaWJlZD9cblx0ICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN1YnNjcmliZWQpIHJldHVybjtcblxuXHQgICAgICAgICAgICAvLyBTZWUgV2hvJ3MgSGVyZSBOb3c/XG5cdCAgICAgICAgICAgIGlmIChub2hlcmVzeW5jKSByZXR1cm47XG5cdCAgICAgICAgICAgIFNFTEZbJ2hlcmVfbm93J10oe1xuXHQgICAgICAgICAgICAgIGNoYW5uZWw6IGNoYW5uZWwsXG5cdCAgICAgICAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKHsgdXVpZDogVVVJRCwgYXV0aDogQVVUSF9LRVkgfSksXG5cdCAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChoZXJlKSB7XG5cdCAgICAgICAgICAgICAgICB1dGlscy5lYWNoKCd1dWlkcycgaW4gaGVyZSA/IGhlcmVbJ3V1aWRzJ10gOiBbXSwgZnVuY3Rpb24gKHVpZCkge1xuXHQgICAgICAgICAgICAgICAgICBwcmVzZW5jZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnam9pbicsXG5cdCAgICAgICAgICAgICAgICAgICAgdXVpZDogdWlkLFxuXHQgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogTWF0aC5mbG9vcih1dGlscy5ybm93KCkgLyAxMDAwKSxcblx0ICAgICAgICAgICAgICAgICAgICBvY2N1cGFuY3k6IGhlcmVbJ29jY3VwYW5jeSddIHx8IDFcblx0ICAgICAgICAgICAgICAgICAgfSwgaGVyZSwgY2hhbm5lbCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBTZXR1cCBDaGFubmVsIEdyb3Vwc1xuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cCkge1xuXHQgICAgICAgIHV0aWxzLmVhY2goKGNoYW5uZWxfZ3JvdXAuam9pbiA/IGNoYW5uZWxfZ3JvdXAuam9pbignLCcpIDogJycgKyBjaGFubmVsX2dyb3VwKS5zcGxpdCgnLCcpLFxuXHQgICAgICAgICAgZnVuY3Rpb24gKGNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gQ0hBTk5FTF9HUk9VUFNbY2hhbm5lbF9ncm91cF0gfHwge307XG5cblx0ICAgICAgICAgICAgQ0hBTk5FTF9HUk9VUFNbY2hhbm5lbF9ncm91cF0gPSB7XG5cdCAgICAgICAgICAgICAgbmFtZTogY2hhbm5lbF9ncm91cCxcblx0ICAgICAgICAgICAgICBjb25uZWN0ZWQ6IHNldHRpbmdzLmNvbm5lY3RlZCxcblx0ICAgICAgICAgICAgICBkaXNjb25uZWN0ZWQ6IHNldHRpbmdzLmRpc2Nvbm5lY3RlZCxcblx0ICAgICAgICAgICAgICBzdWJzY3JpYmVkOiAxLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBTVUJfQ0FMTEJBQ0sgPSBjYWxsYmFjayxcblx0ICAgICAgICAgICAgICBjaXBoZXJfa2V5OiBhcmdzWydjaXBoZXJfa2V5J10sXG5cdCAgICAgICAgICAgICAgY29ubmVjdDogY29ubmVjdCxcblx0ICAgICAgICAgICAgICBkaXNjb25uZWN0OiBkaXNjb25uZWN0LFxuXHQgICAgICAgICAgICAgIHJlY29ubmVjdDogcmVjb25uZWN0XG5cdCAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgLy8gUHJlc2VuY2UgRW5hYmxlZD9cblx0ICAgICAgICAgICAgaWYgKCFwcmVzZW5jZSkgcmV0dXJuO1xuXG5cdCAgICAgICAgICAgIC8vIFN1YnNjcmliZSBQcmVzZW5jZSBDaGFubmVsXG5cdCAgICAgICAgICAgIFNFTEZbJ3N1YnNjcmliZSddKHtcblx0ICAgICAgICAgICAgICBjaGFubmVsX2dyb3VwOiBjaGFubmVsX2dyb3VwICsgUFJFU0VOQ0VfU1VGRklYLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBwcmVzZW5jZSxcblx0ICAgICAgICAgICAgICByZXN0b3JlOiByZXN0b3JlLFxuXHQgICAgICAgICAgICAgIGF1dGhfa2V5OiBBVVRIX0tFWVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAvLyBQcmVzZW5jZSBTdWJzY3JpYmVkP1xuXHQgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc3Vic2NyaWJlZCkgcmV0dXJuO1xuXG5cdCAgICAgICAgICAgIC8vIFNlZSBXaG8ncyBIZXJlIE5vdz9cblx0ICAgICAgICAgICAgaWYgKG5vaGVyZXN5bmMpIHJldHVybjtcblx0ICAgICAgICAgICAgU0VMRlsnaGVyZV9ub3cnXSh7XG5cdCAgICAgICAgICAgICAgY2hhbm5lbF9ncm91cDogY2hhbm5lbF9ncm91cCxcblx0ICAgICAgICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoeyB1dWlkOiBVVUlELCBhdXRoOiBBVVRIX0tFWSB9KSxcblx0ICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGhlcmUpIHtcblx0ICAgICAgICAgICAgICAgIHV0aWxzLmVhY2goJ3V1aWRzJyBpbiBoZXJlID8gaGVyZVsndXVpZHMnXSA6IFtdLCBmdW5jdGlvbiAodWlkKSB7XG5cdCAgICAgICAgICAgICAgICAgIHByZXNlbmNlKHtcblx0ICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdqb2luJyxcblx0ICAgICAgICAgICAgICAgICAgICB1dWlkOiB1aWQsXG5cdCAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBNYXRoLmZsb29yKHV0aWxzLnJub3coKSAvIDEwMDApLFxuXHQgICAgICAgICAgICAgICAgICAgIG9jY3VwYW5jeTogaGVyZVsnb2NjdXBhbmN5J10gfHwgMVxuXHQgICAgICAgICAgICAgICAgICB9LCBoZXJlLCBjaGFubmVsX2dyb3VwKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgfVxuXG5cblx0ICAgICAgLy8gVGVzdCBOZXR3b3JrIENvbm5lY3Rpb25cblx0ICAgICAgZnVuY3Rpb24gX3Rlc3RfY29ubmVjdGlvbihzdWNjZXNzKSB7XG5cdCAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcblx0ICAgICAgICAgIC8vIEJlZ2luIE5leHQgU29ja2V0IENvbm5lY3Rpb25cblx0ICAgICAgICAgIHV0aWxzLnRpbWVvdXQoQ09OTkVDVCwgd2luZG93aW5nKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gTmV3IE9yaWdpbiBvbiBGYWlsZWQgQ29ubmVjdGlvblxuXHQgICAgICAgICAgU1REX09SSUdJTiA9IG5leHRvcmlnaW4oT1JJR0lOLCAxKTtcblx0ICAgICAgICAgIFNVQl9PUklHSU4gPSBuZXh0b3JpZ2luKE9SSUdJTiwgMSk7XG5cblx0ICAgICAgICAgIC8vIFJlLXRlc3QgQ29ubmVjdGlvblxuXHQgICAgICAgICAgdXRpbHMudGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIFNFTEZbJ3RpbWUnXShfdGVzdF9jb25uZWN0aW9uKTtcblx0ICAgICAgICAgIH0sIFNFQ09ORCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gRGlzY29ubmVjdCAmIFJlY29ubmVjdFxuXHQgICAgICAgIGVhY2hfY2hhbm5lbChmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgLy8gUmVjb25uZWN0XG5cdCAgICAgICAgICBpZiAoc3VjY2VzcyAmJiBjaGFubmVsLmRpc2Nvbm5lY3RlZCkge1xuXHQgICAgICAgICAgICBjaGFubmVsLmRpc2Nvbm5lY3RlZCA9IDA7XG5cdCAgICAgICAgICAgIHJldHVybiBjaGFubmVsLnJlY29ubmVjdChjaGFubmVsLm5hbWUpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAvLyBEaXNjb25uZWN0XG5cdCAgICAgICAgICBpZiAoIXN1Y2Nlc3MgJiYgIWNoYW5uZWwuZGlzY29ubmVjdGVkKSB7XG5cdCAgICAgICAgICAgIGNoYW5uZWwuZGlzY29ubmVjdGVkID0gMTtcblx0ICAgICAgICAgICAgY2hhbm5lbC5kaXNjb25uZWN0KGNoYW5uZWwubmFtZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICAvLyBEaXNjb25uZWN0ICYgUmVjb25uZWN0IGZvciBjaGFubmVsIGdyb3Vwc1xuXHQgICAgICAgIGVhY2hfY2hhbm5lbF9ncm91cChmdW5jdGlvbiAoY2hhbm5lbF9ncm91cCkge1xuXHQgICAgICAgICAgLy8gUmVjb25uZWN0XG5cdCAgICAgICAgICBpZiAoc3VjY2VzcyAmJiBjaGFubmVsX2dyb3VwLmRpc2Nvbm5lY3RlZCkge1xuXHQgICAgICAgICAgICBjaGFubmVsX2dyb3VwLmRpc2Nvbm5lY3RlZCA9IDA7XG5cdCAgICAgICAgICAgIHJldHVybiBjaGFubmVsX2dyb3VwLnJlY29ubmVjdChjaGFubmVsX2dyb3VwLm5hbWUpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAvLyBEaXNjb25uZWN0XG5cdCAgICAgICAgICBpZiAoIXN1Y2Nlc3MgJiYgIWNoYW5uZWxfZ3JvdXAuZGlzY29ubmVjdGVkKSB7XG5cdCAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXAuZGlzY29ubmVjdGVkID0gMTtcblx0ICAgICAgICAgICAgY2hhbm5lbF9ncm91cC5kaXNjb25uZWN0KGNoYW5uZWxfZ3JvdXAubmFtZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBFdmVudGVkIFN1YnNjcmliZVxuXHQgICAgICBmdW5jdGlvbiBfY29ubmVjdCgpIHtcblx0ICAgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICAgIHZhciBjaGFubmVscyA9IGdlbmVyYXRlX2NoYW5uZWxfbGlzdChDSEFOTkVMUykuam9pbignLCcpO1xuXHQgICAgICAgIHZhciBjaGFubmVsX2dyb3VwcyA9IGdlbmVyYXRlX2NoYW5uZWxfZ3JvdXBfbGlzdChDSEFOTkVMX0dST1VQUykuam9pbignLCcpO1xuXG5cdCAgICAgICAgLy8gU3RvcCBDb25uZWN0aW9uXG5cdCAgICAgICAgaWYgKCFjaGFubmVscyAmJiAhY2hhbm5lbF9ncm91cHMpIHJldHVybjtcblxuXHQgICAgICAgIGlmICghY2hhbm5lbHMpIGNoYW5uZWxzID0gJywnO1xuXG5cdCAgICAgICAgLy8gQ29ubmVjdCB0byBQdWJOdWIgU3Vic2NyaWJlIFNlcnZlcnNcblx0ICAgICAgICBfcmVzZXRfb2ZmbGluZSgpO1xuXG5cdCAgICAgICAgdmFyIGRhdGEgPSBfZ2V0X3VybF9wYXJhbXMoeyB1dWlkOiBVVUlELCBhdXRoOiBBVVRIX0tFWSB9KTtcblxuXHQgICAgICAgIGlmIChjaGFubmVsX2dyb3Vwcykge1xuXHQgICAgICAgICAgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cHM7XG5cdCAgICAgICAgfVxuXG5cblx0ICAgICAgICB2YXIgc3QgPSBKU09OLnN0cmluZ2lmeShTVEFURSk7XG5cdCAgICAgICAgaWYgKHN0Lmxlbmd0aCA+IDIpIGRhdGFbJ3N0YXRlJ10gPSBKU09OLnN0cmluZ2lmeShTVEFURSk7XG5cblx0ICAgICAgICBpZiAoUFJFU0VOQ0VfSEIpIGRhdGFbJ2hlYXJ0YmVhdCddID0gUFJFU0VOQ0VfSEI7XG5cblx0ICAgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIGRhdGFbJ2luc3RhbmNlaWQnXSA9IElOU1RBTkNFSUQ7XG5cblx0ICAgICAgICBzdGFydF9wcmVzZW5jZV9oZWFydGJlYXQoKTtcblx0ICAgICAgICBTVUJfUkVDRUlWRVIgPSB4ZHIoe1xuXHQgICAgICAgICAgdGltZW91dDogc3ViX3RpbWVvdXQsXG5cdCAgICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlWydlcnJvciddICYmIHJlc3BvbnNlWydzZXJ2aWNlJ10pIHtcblx0ICAgICAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBTVUJfRVJST1IpO1xuXHQgICAgICAgICAgICAgIF90ZXN0X2Nvbm5lY3Rpb24oZmFsc2UpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIFNFTEZbJ3RpbWUnXShmdW5jdGlvbiAoc3VjY2Vzcykge1xuXHQgICAgICAgICAgICAgICAgIXN1Y2Nlc3MgJiYgKF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIFNVQl9FUlJPUikpO1xuXHQgICAgICAgICAgICAgICAgX3Rlc3RfY29ubmVjdGlvbihzdWNjZXNzKTtcblx0ICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICAgIHVybDogW1xuXHQgICAgICAgICAgICBTVUJfT1JJR0lOLCAnc3Vic2NyaWJlJyxcblx0ICAgICAgICAgICAgU1VCU0NSSUJFX0tFWSwgdXRpbHMuZW5jb2RlKGNoYW5uZWxzKSxcblx0ICAgICAgICAgICAganNvbnAsIFRJTUVUT0tFTlxuXHQgICAgICAgICAgXSxcblx0ICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuXHQgICAgICAgICAgICAvLyBDaGVjayBmb3IgRXJyb3JzXG5cdCAgICAgICAgICAgIGlmICghbWVzc2FnZXMgfHwgKHR5cGVvZiBtZXNzYWdlcyA9PSAnb2JqZWN0JyAmJiAnZXJyb3InIGluIG1lc3NhZ2VzICYmIG1lc3NhZ2VzWydlcnJvciddKSkge1xuXHQgICAgICAgICAgICAgIFNVQl9FUlJPUihtZXNzYWdlcyk7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnRpbWVvdXQoQ09OTkVDVCwgU0VDT05EKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFVzZXIgSWRsZSBDYWxsYmFja1xuXHQgICAgICAgICAgICBpZGxlY2IobWVzc2FnZXNbMV0pO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc3RvcmUgUHJldmlvdXMgQ29ubmVjdGlvbiBQb2ludCBpZiBOZWVkZWRcblx0ICAgICAgICAgICAgVElNRVRPS0VOID0gIVRJTUVUT0tFTiAmJiBTVUJfUkVTVE9SRSAmJiBkYlsnZ2V0J10oU1VCU0NSSUJFX0tFWSkgfHwgbWVzc2FnZXNbMV07XG5cblx0ICAgICAgICAgICAgLypcblx0ICAgICAgICAgICAgIC8vIENvbm5lY3Rcblx0ICAgICAgICAgICAgIGVhY2hfY2hhbm5lbF9yZWdpc3RyeShmdW5jdGlvbihyZWdpc3RyeSl7XG5cdCAgICAgICAgICAgICBpZiAocmVnaXN0cnkuY29ubmVjdGVkKSByZXR1cm47XG5cdCAgICAgICAgICAgICByZWdpc3RyeS5jb25uZWN0ZWQgPSAxO1xuXHQgICAgICAgICAgICAgcmVnaXN0cnkuY29ubmVjdChjaGFubmVsLm5hbWUpO1xuXHQgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXG5cdCAgICAgICAgICAgIC8vIENvbm5lY3Rcblx0ICAgICAgICAgICAgZWFjaF9jaGFubmVsKGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgICAgICAgaWYgKGNoYW5uZWwuY29ubmVjdGVkKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgY2hhbm5lbC5jb25uZWN0ZWQgPSAxO1xuXHQgICAgICAgICAgICAgIGNoYW5uZWwuY29ubmVjdChjaGFubmVsLm5hbWUpO1xuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAvLyBDb25uZWN0IGZvciBjaGFubmVsIGdyb3Vwc1xuXHQgICAgICAgICAgICBlYWNoX2NoYW5uZWxfZ3JvdXAoZnVuY3Rpb24gKGNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgICAgICAgICBpZiAoY2hhbm5lbF9ncm91cC5jb25uZWN0ZWQpIHJldHVybjtcblx0ICAgICAgICAgICAgICBjaGFubmVsX2dyb3VwLmNvbm5lY3RlZCA9IDE7XG5cdCAgICAgICAgICAgICAgY2hhbm5lbF9ncm91cC5jb25uZWN0KGNoYW5uZWxfZ3JvdXAubmFtZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIGlmIChSRVNVTUVEICYmICFTVUJfUkVTVE9SRSkge1xuXHQgICAgICAgICAgICAgIFRJTUVUT0tFTiA9IDA7XG5cdCAgICAgICAgICAgICAgUkVTVU1FRCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgIC8vIFVwZGF0ZSBTYXZlZCBUaW1ldG9rZW5cblx0ICAgICAgICAgICAgICBkYlsnc2V0J10oU1VCU0NSSUJFX0tFWSwgMCk7XG5cdCAgICAgICAgICAgICAgdXRpbHMudGltZW91dChfY29ubmVjdCwgd2luZG93aW5nKTtcblx0ICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnZva2UgTWVtb3J5IENhdGNodXAgYW5kIFJlY2VpdmUgVXAgdG8gMTAwXG5cdCAgICAgICAgICAgIC8vIFByZXZpb3VzIE1lc3NhZ2VzIGZyb20gdGhlIFF1ZXVlLlxuXHQgICAgICAgICAgICBpZiAoYmFja2ZpbGwpIHtcblx0ICAgICAgICAgICAgICBUSU1FVE9LRU4gPSAxMDAwMDtcblx0ICAgICAgICAgICAgICBiYWNrZmlsbCA9IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBVcGRhdGUgU2F2ZWQgVGltZXRva2VuXG5cdCAgICAgICAgICAgIGRiWydzZXQnXShTVUJTQ1JJQkVfS0VZLCBtZXNzYWdlc1sxXSk7XG5cblx0ICAgICAgICAgICAgLy8gUm91dGUgQ2hhbm5lbCA8LS0tPiBDYWxsYmFjayBmb3IgTWVzc2FnZVxuXHQgICAgICAgICAgICB2YXIgbmV4dF9jYWxsYmFjayA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgdmFyIGNoYW5uZWxzID0gJyc7XG5cdCAgICAgICAgICAgICAgdmFyIGNoYW5uZWxzMiA9ICcnO1xuXG5cdCAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA+IDMpIHtcblx0ICAgICAgICAgICAgICAgIGNoYW5uZWxzID0gbWVzc2FnZXNbM107XG5cdCAgICAgICAgICAgICAgICBjaGFubmVsczIgPSBtZXNzYWdlc1syXTtcblx0ICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2VzLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICAgICAgICAgIGNoYW5uZWxzID0gbWVzc2FnZXNbMl07XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGNoYW5uZWxzID0gdXRpbHMubWFwKFxuXHQgICAgICAgICAgICAgICAgICBnZW5lcmF0ZV9jaGFubmVsX2xpc3QoQ0hBTk5FTFMpLCBmdW5jdGlvbiAoY2hhbikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5tYXAoXG5cdCAgICAgICAgICAgICAgICAgICAgICBBcnJheShtZXNzYWdlc1swXS5sZW5ndGgpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsJykuc3BsaXQoJywnKSxcblx0ICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW47XG5cdCAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgICAgfSkuam9pbignLCcpO1xuXHQgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgIHZhciBsaXN0ID0gY2hhbm5lbHMuc3BsaXQoJywnKTtcblx0ICAgICAgICAgICAgICB2YXIgbGlzdDIgPSAoY2hhbm5lbHMyKSA/IGNoYW5uZWxzMi5zcGxpdCgnLCcpIDogW107XG5cblx0ICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSBsaXN0LnNoaWZ0KCkgfHwgU1VCX0NIQU5ORUw7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbDIgPSBsaXN0Mi5zaGlmdCgpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgY2hvYmogPSB7fTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwyKSB7XG5cdCAgICAgICAgICAgICAgICAgIGlmIChjaGFubmVsICYmIGNoYW5uZWwuaW5kZXhPZignLXBucHJlcycpID49IDBcblx0ICAgICAgICAgICAgICAgICAgICAmJiBjaGFubmVsMi5pbmRleE9mKCctcG5wcmVzJykgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDIgKz0gJy1wbnByZXMnO1xuXHQgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgIGNob2JqID0gQ0hBTk5FTF9HUk9VUFNbY2hhbm5lbDJdIHx8IENIQU5ORUxTW2NoYW5uZWwyXSB8fCB7IGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fSB9O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgY2hvYmogPSBDSEFOTkVMU1tjaGFubmVsXTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIHIgPSBbXG5cdCAgICAgICAgICAgICAgICAgIGNob2JqXG5cdCAgICAgICAgICAgICAgICAgICAgLmNhbGxiYWNrIHx8IFNVQl9DQUxMQkFDSyxcblx0ICAgICAgICAgICAgICAgICAgY2hhbm5lbC5zcGxpdChQUkVTRU5DRV9TVUZGSVgpWzBdXG5cdCAgICAgICAgICAgICAgICBdO1xuXHQgICAgICAgICAgICAgICAgY2hhbm5lbDIgJiYgci5wdXNoKGNoYW5uZWwyLnNwbGl0KFBSRVNFTkNFX1NVRkZJWClbMF0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG5cdCAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkoKTtcblxuXHQgICAgICAgICAgICB2YXIgbGF0ZW5jeSA9IGRldGVjdF9sYXRlbmN5KCttZXNzYWdlc1sxXSk7XG5cdCAgICAgICAgICAgIHV0aWxzLmVhY2gobWVzc2FnZXNbMF0sIGZ1bmN0aW9uIChtc2cpIHtcblx0ICAgICAgICAgICAgICB2YXIgbmV4dCA9IG5leHRfY2FsbGJhY2soKTtcblx0ICAgICAgICAgICAgICB2YXIgZGVjcnlwdGVkX21zZyA9IGRlY3J5cHQobXNnLFxuXHQgICAgICAgICAgICAgICAgKENIQU5ORUxTW25leHRbMV1dKSA/IENIQU5ORUxTW25leHRbMV1dWydjaXBoZXJfa2V5J10gOiBudWxsKTtcblx0ICAgICAgICAgICAgICBuZXh0WzBdICYmIG5leHRbMF0oZGVjcnlwdGVkX21zZywgbWVzc2FnZXMsIG5leHRbMl0gfHwgbmV4dFsxXSwgbGF0ZW5jeSwgbmV4dFsxXSk7XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIHV0aWxzLnRpbWVvdXQoX2Nvbm5lY3QsIHdpbmRvd2luZyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBDT05ORUNUID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIF9yZXNldF9vZmZsaW5lKCk7XG5cdCAgICAgICAgdXRpbHMudGltZW91dChfY29ubmVjdCwgd2luZG93aW5nKTtcblx0ICAgICAgfTtcblxuXHQgICAgICAvLyBSZWR1Y2UgU3RhdHVzIEZsaWNrZXJcblx0ICAgICAgaWYgKCFSRUFEWSkgcmV0dXJuIFJFQURZX0JVRkZFUi5wdXNoKENPTk5FQ1QpO1xuXG5cdCAgICAgIC8vIENvbm5lY3QgTm93XG5cdCAgICAgIENPTk5FQ1QoKTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLmhlcmVfbm93KHsgY2hhbm5lbCA6ICdteV9jaGF0JywgY2FsbGJhY2sgOiBmdW4gfSk7XG5cdCAgICAgKi9cblx0ICAgIGhlcmVfbm93OiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBjYWxsYmFjaztcblx0ICAgICAgdmFyIGRlYnVnID0gYXJnc1snZGVidWcnXTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBjaGFubmVsID0gYXJnc1snY2hhbm5lbCddO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIHV1aWRzID0gKCd1dWlkcycgaW4gYXJncykgPyBhcmdzWyd1dWlkcyddIDogdHJ1ZTtcblx0ICAgICAgdmFyIHN0YXRlID0gYXJnc1snc3RhdGUnXTtcblx0ICAgICAgdmFyIGRhdGEgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IGF1dGhfa2V5IH07XG5cblx0ICAgICAgaWYgKCF1dWlkcykgZGF0YVsnZGlzYWJsZV91dWlkcyddID0gMTtcblx0ICAgICAgaWYgKHN0YXRlKSBkYXRhWydzdGF0ZSddID0gMTtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENhbGxiYWNrJyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICB2YXIgdXJsID0gW1xuXHQgICAgICAgIFNURF9PUklHSU4sICd2MicsICdwcmVzZW5jZScsXG5cdCAgICAgICAgJ3N1Yl9rZXknLCBTVUJTQ1JJQkVfS0VZXG5cdCAgICAgIF07XG5cblx0ICAgICAgY2hhbm5lbCAmJiB1cmwucHVzaCgnY2hhbm5lbCcpICYmIHVybC5wdXNoKHV0aWxzLmVuY29kZShjaGFubmVsKSk7XG5cblx0ICAgICAgaWYgKGpzb25wICE9ICcwJykge1xuXHQgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cDtcblx0ICAgICAgICAhY2hhbm5lbCAmJiB1cmwucHVzaCgnY2hhbm5lbCcpICYmIHVybC5wdXNoKCcsJyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIGRhdGFbJ2luc3RhbmNlaWQnXSA9IElOU1RBTkNFSUQ7XG5cblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBkZWJ1ZzogZGVidWcsXG5cdCAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5jdXJyZW50X2NoYW5uZWxzX2J5X3V1aWQoeyBjaGFubmVsIDogJ215X2NoYXQnLCBjYWxsYmFjayA6IGZ1biB9KTtcblx0ICAgICAqL1xuXHQgICAgd2hlcmVfbm93OiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBjYWxsYmFjaztcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciB1dWlkID0gYXJnc1sndXVpZCddIHx8IFVVSUQ7XG5cdCAgICAgIHZhciBkYXRhID0geyBhdXRoOiBhdXRoX2tleSB9O1xuXG5cdCAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgQ2hhbm5lbFxuXHQgICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2FsbGJhY2snKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIHtcblx0ICAgICAgICBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIGRhdGFbJ2luc3RhbmNlaWQnXSA9IElOU1RBTkNFSUQ7XG5cblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MicsICdwcmVzZW5jZScsXG5cdCAgICAgICAgICAnc3ViX2tleScsIFNVQlNDUklCRV9LRVksXG5cdCAgICAgICAgICAndXVpZCcsIHV0aWxzLmVuY29kZSh1dWlkKVxuXHQgICAgICAgIF1cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICBzdGF0ZTogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2sgfHwgZnVuY3Rpb24gKHIpIHt9O1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIHN0YXRlID0gYXJnc1snc3RhdGUnXTtcblx0ICAgICAgdmFyIHV1aWQgPSBhcmdzWyd1dWlkJ10gfHwgVVVJRDtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwID0gYXJnc1snY2hhbm5lbF9ncm91cCddO1xuXHQgICAgICB2YXIgdXJsO1xuXHQgICAgICB2YXIgZGF0YSA9IF9nZXRfdXJsX3BhcmFtcyh7IGF1dGg6IGF1dGhfa2V5IH0pO1xuXG5cdCAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgQ2hhbm5lbFxuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cdCAgICAgIGlmICghdXVpZCkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFVVSUQnKTtcblx0ICAgICAgaWYgKCFjaGFubmVsICYmICFjaGFubmVsX2dyb3VwKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCcpO1xuXG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIHtcblx0ICAgICAgICBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodHlwZW9mIGNoYW5uZWwgIT0gJ3VuZGVmaW5lZCdcblx0ICAgICAgICAmJiBDSEFOTkVMU1tjaGFubmVsXSAmJiBDSEFOTkVMU1tjaGFubmVsXS5zdWJzY3JpYmVkKSB7XG5cdCAgICAgICAgaWYgKHN0YXRlKSBTVEFURVtjaGFubmVsXSA9IHN0YXRlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBjaGFubmVsX2dyb3VwICE9ICd1bmRlZmluZWQnXG5cdCAgICAgICAgJiYgQ0hBTk5FTF9HUk9VUFNbY2hhbm5lbF9ncm91cF1cblx0ICAgICAgICAmJiBDSEFOTkVMX0dST1VQU1tjaGFubmVsX2dyb3VwXS5zdWJzY3JpYmVkXG5cdCAgICAgICkge1xuXHQgICAgICAgIGlmIChzdGF0ZSkgU1RBVEVbY2hhbm5lbF9ncm91cF0gPSBzdGF0ZTtcblx0ICAgICAgICBkYXRhWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3VwO1xuXG5cdCAgICAgICAgaWYgKCFjaGFubmVsKSB7XG5cdCAgICAgICAgICBjaGFubmVsID0gJywnO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGRhdGFbJ3N0YXRlJ10gPSBKU09OLnN0cmluZ2lmeShzdGF0ZSk7XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIGlmIChzdGF0ZSkge1xuXHQgICAgICAgIHVybCA9IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MicsICdwcmVzZW5jZScsXG5cdCAgICAgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVksXG5cdCAgICAgICAgICAnY2hhbm5lbCcsIGNoYW5uZWwsXG5cdCAgICAgICAgICAndXVpZCcsIHV1aWQsICdkYXRhJ1xuXHQgICAgICAgIF07XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdXJsID0gW1xuXHQgICAgICAgICAgU1REX09SSUdJTiwgJ3YyJywgJ3ByZXNlbmNlJyxcblx0ICAgICAgICAgICdzdWIta2V5JywgU1VCU0NSSUJFX0tFWSxcblx0ICAgICAgICAgICdjaGFubmVsJywgY2hhbm5lbCxcblx0ICAgICAgICAgICd1dWlkJywgdXRpbHMuZW5jb2RlKHV1aWQpXG5cdCAgICAgICAgXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiB1cmxcblxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLmdyYW50KHtcblx0ICAgICBjaGFubmVsICA6ICdteV9jaGF0Jyxcblx0ICAgICBjYWxsYmFjayA6IGZ1bixcblx0ICAgICBlcnJvciAgICA6IGZ1bixcblx0ICAgICB0dGwgICAgICA6IDI0ICogNjAsIC8vIE1pbnV0ZXNcblx0ICAgICByZWFkICAgICA6IHRydWUsXG5cdCAgICAgd3JpdGUgICAgOiB0cnVlLFxuXHQgICAgIGF1dGhfa2V5IDogJzN5OHVpYWpka2x5dG93c2onXG5cdCAgICAgfSk7XG5cdCAgICAgKi9cblx0ICAgIGdyYW50OiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBjYWxsYmFjaztcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBjaGFubmVsID0gYXJnc1snY2hhbm5lbCddIHx8IGFyZ3NbJ2NoYW5uZWxzJ107XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwID0gYXJnc1snY2hhbm5lbF9ncm91cCddO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgdHRsID0gYXJnc1sndHRsJ107XG5cdCAgICAgIHZhciByID0gKGFyZ3NbJ3JlYWQnXSkgPyAnMScgOiAnMCc7XG5cdCAgICAgIHZhciB3ID0gKGFyZ3NbJ3dyaXRlJ10pID8gJzEnIDogJzAnO1xuXHQgICAgICB2YXIgbSA9IChhcmdzWydtYW5hZ2UnXSkgPyAnMScgOiAnMCc7XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgYXJnc1snYXV0aF9rZXlzJ107XG5cblx0ICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENhbGxiYWNrJyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblx0ICAgICAgaWYgKCFQVUJMSVNIX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFB1Ymxpc2ggS2V5Jyk7XG5cdCAgICAgIGlmICghU0VDUkVUX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFNlY3JldCBLZXknKTtcblxuXHQgICAgICB2YXIgdGltZXN0YW1wID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuXHQgICAgICB2YXIgc2lnbl9pbnB1dCA9IFNVQlNDUklCRV9LRVkgKyAnXFxuJyArIFBVQkxJU0hfS0VZICsgJ1xcbicgKyAnZ3JhbnQnICsgJ1xcbic7XG5cblx0ICAgICAgdmFyIGRhdGEgPSB7IHc6IHcsIHI6IHIsIHRpbWVzdGFtcDogdGltZXN0YW1wIH07XG5cblx0ICAgICAgaWYgKGFyZ3NbJ21hbmFnZSddKSB7XG5cdCAgICAgICAgZGF0YVsnbSddID0gbTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodXRpbHMuaXNBcnJheShjaGFubmVsKSkge1xuXHQgICAgICAgIGNoYW5uZWwgPSBjaGFubmVsWydqb2luJ10oJywnKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodXRpbHMuaXNBcnJheShhdXRoX2tleSkpIHtcblx0ICAgICAgICBhdXRoX2tleSA9IGF1dGhfa2V5Wydqb2luJ10oJywnKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodHlwZW9mIGNoYW5uZWwgIT0gJ3VuZGVmaW5lZCcgJiYgY2hhbm5lbCAhPSBudWxsICYmIGNoYW5uZWwubGVuZ3RoID4gMCkgZGF0YVsnY2hhbm5lbCddID0gY2hhbm5lbDtcblx0ICAgICAgaWYgKHR5cGVvZiBjaGFubmVsX2dyb3VwICE9ICd1bmRlZmluZWQnICYmIGNoYW5uZWxfZ3JvdXAgIT0gbnVsbCAmJiBjaGFubmVsX2dyb3VwLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICBkYXRhWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3VwO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIHtcblx0ICAgICAgICBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHR0bCB8fCB0dGwgPT09IDApIGRhdGFbJ3R0bCddID0gdHRsO1xuXG5cdCAgICAgIGlmIChhdXRoX2tleSkgZGF0YVsnYXV0aCddID0gYXV0aF9rZXk7XG5cblx0ICAgICAgZGF0YSA9IF9nZXRfdXJsX3BhcmFtcyhkYXRhKTtcblxuXHQgICAgICBpZiAoIWF1dGhfa2V5KSBkZWxldGUgZGF0YVsnYXV0aCddO1xuXG5cdCAgICAgIHNpZ25faW5wdXQgKz0gX2dldF9wYW1fc2lnbl9pbnB1dF9mcm9tX3BhcmFtcyhkYXRhKTtcblxuXHQgICAgICB2YXIgc2lnbmF0dXJlID0gaG1hY19TSEEyNTYoc2lnbl9pbnB1dCwgU0VDUkVUX0tFWSk7XG5cblx0ICAgICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlLnJlcGxhY2UoL1xcKy9nLCAnLScpO1xuXHQgICAgICBzaWduYXR1cmUgPSBzaWduYXR1cmUucmVwbGFjZSgvXFwvL2csICdfJyk7XG5cblx0ICAgICAgZGF0YVsnc2lnbmF0dXJlJ10gPSBzaWduYXR1cmU7XG5cblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogZGF0YSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjEnLCAnYXV0aCcsICdncmFudCcsXG5cdCAgICAgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVlcblx0ICAgICAgICBdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIubW9iaWxlX2d3X3Byb3Zpc2lvbiAoe1xuXHQgICAgIGRldmljZV9pZDogJ0E2NTVGQkE5OTMxQUInLFxuXHQgICAgIG9wICAgICAgIDogJ2FkZCcgfCAncmVtb3ZlJyxcblx0ICAgICBnd190eXBlICA6ICdhcG5zJyB8ICdnY20nLFxuXHQgICAgIGNoYW5uZWwgIDogJ215X2NoYXQnLFxuXHQgICAgIGNhbGxiYWNrIDogZnVuLFxuXHQgICAgIGVycm9yICAgIDogZnVuLFxuXHQgICAgIH0pO1xuXHQgICAgICovXG5cblx0ICAgIG1vYmlsZV9nd19wcm92aXNpb246IGZ1bmN0aW9uIChhcmdzKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIG9wID0gYXJnc1snb3AnXTtcblx0ICAgICAgdmFyIGd3X3R5cGUgPSBhcmdzWydnd190eXBlJ107XG5cdCAgICAgIHZhciBkZXZpY2VfaWQgPSBhcmdzWydkZXZpY2VfaWQnXTtcblx0ICAgICAgdmFyIHBhcmFtcztcblx0ICAgICAgdmFyIHVybDtcblxuXHQgICAgICBpZiAoIWRldmljZV9pZCkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIERldmljZSBJRCAoZGV2aWNlX2lkKScpO1xuXHQgICAgICBpZiAoIWd3X3R5cGUpIHJldHVybiBlcnJvcignTWlzc2luZyBHVyBUeXBlIChnd190eXBlOiBnY20gb3IgYXBucyknKTtcblx0ICAgICAgaWYgKCFvcCkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIEdXIE9wZXJhdGlvbiAob3A6IGFkZCBvciByZW1vdmUpJyk7XG5cdCAgICAgIGlmICghY2hhbm5lbCkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIGd3IGRlc3RpbmF0aW9uIENoYW5uZWwgKGNoYW5uZWwpJyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICAvLyBDcmVhdGUgVVJMXG5cdCAgICAgIHVybCA9IFtcblx0ICAgICAgICBTVERfT1JJR0lOLCAndjEvcHVzaC9zdWIta2V5Jyxcblx0ICAgICAgICBTVUJTQ1JJQkVfS0VZLCAnZGV2aWNlcycsIGRldmljZV9pZFxuXHQgICAgICBdO1xuXG5cdCAgICAgIHBhcmFtcyA9IHsgdXVpZDogVVVJRCwgYXV0aDogYXV0aF9rZXksIHR5cGU6IGd3X3R5cGUgfTtcblxuXHQgICAgICBpZiAob3AgPT0gJ2FkZCcpIHtcblx0ICAgICAgICBwYXJhbXNbJ2FkZCddID0gY2hhbm5lbDtcblx0ICAgICAgfSBlbHNlIGlmIChvcCA9PSAncmVtb3ZlJykge1xuXHQgICAgICAgIHBhcmFtc1sncmVtb3ZlJ10gPSBjaGFubmVsO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBwYXJhbXNbJ2luc3RhbmNlaWQnXSA9IElOU1RBTkNFSUQ7XG5cblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogcGFyYW1zLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cmw6IHVybFxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLmF1ZGl0KHtcblx0ICAgICBjaGFubmVsICA6ICdteV9jaGF0Jyxcblx0ICAgICBjYWxsYmFjayA6IGZ1bixcblx0ICAgICBlcnJvciAgICA6IGZ1bixcblx0ICAgICByZWFkICAgICA6IHRydWUsXG5cdCAgICAgd3JpdGUgICAgOiB0cnVlLFxuXHQgICAgIGF1dGhfa2V5IDogJzN5OHVpYWpka2x5dG93c2onXG5cdCAgICAgfSk7XG5cdCAgICAgKi9cblx0ICAgIGF1ZGl0OiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBjYWxsYmFjaztcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBjaGFubmVsID0gYXJnc1snY2hhbm5lbCddO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENhbGxiYWNrJyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblx0ICAgICAgaWYgKCFQVUJMSVNIX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFB1Ymxpc2ggS2V5Jyk7XG5cdCAgICAgIGlmICghU0VDUkVUX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFNlY3JldCBLZXknKTtcblxuXHQgICAgICB2YXIgdGltZXN0YW1wID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuXHQgICAgICB2YXIgc2lnbl9pbnB1dCA9IFNVQlNDUklCRV9LRVkgKyAnXFxuJyArIFBVQkxJU0hfS0VZICsgJ1xcbicgKyAnYXVkaXQnICsgJ1xcbic7XG5cblx0ICAgICAgdmFyIGRhdGEgPSB7IHRpbWVzdGFtcDogdGltZXN0YW1wIH07XG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIHtcblx0ICAgICAgICBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9ICd1bmRlZmluZWQnICYmIGNoYW5uZWwgIT0gbnVsbCAmJiBjaGFubmVsLmxlbmd0aCA+IDApIGRhdGFbJ2NoYW5uZWwnXSA9IGNoYW5uZWw7XG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbF9ncm91cCAhPSAndW5kZWZpbmVkJyAmJiBjaGFubmVsX2dyb3VwICE9IG51bGwgJiYgY2hhbm5lbF9ncm91cC5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoYXV0aF9rZXkpIGRhdGFbJ2F1dGgnXSA9IGF1dGhfa2V5O1xuXG5cdCAgICAgIGRhdGEgPSBfZ2V0X3VybF9wYXJhbXMoZGF0YSk7XG5cblx0ICAgICAgaWYgKCFhdXRoX2tleSkgZGVsZXRlIGRhdGFbJ2F1dGgnXTtcblxuXHQgICAgICBzaWduX2lucHV0ICs9IF9nZXRfcGFtX3NpZ25faW5wdXRfZnJvbV9wYXJhbXMoZGF0YSk7XG5cblx0ICAgICAgdmFyIHNpZ25hdHVyZSA9IGhtYWNfU0hBMjU2KHNpZ25faW5wdXQsIFNFQ1JFVF9LRVkpO1xuXG5cdCAgICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS5yZXBsYWNlKC9cXCsvZywgJy0nKTtcblx0ICAgICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xuXG5cdCAgICAgIGRhdGFbJ3NpZ25hdHVyZSddID0gc2lnbmF0dXJlO1xuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBkYXRhLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MScsICdhdXRoJywgJ2F1ZGl0Jyxcblx0ICAgICAgICAgICdzdWIta2V5JywgU1VCU0NSSUJFX0tFWVxuXHQgICAgICAgIF1cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5yZXZva2Uoe1xuXHQgICAgIGNoYW5uZWwgIDogJ215X2NoYXQnLFxuXHQgICAgIGNhbGxiYWNrIDogZnVuLFxuXHQgICAgIGVycm9yICAgIDogZnVuLFxuXHQgICAgIGF1dGhfa2V5IDogJzN5OHVpYWpka2x5dG93c2onXG5cdCAgICAgfSk7XG5cdCAgICAgKi9cblx0ICAgIHJldm9rZTogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIGFyZ3NbJ3JlYWQnXSA9IGZhbHNlO1xuXHQgICAgICBhcmdzWyd3cml0ZSddID0gZmFsc2U7XG5cdCAgICAgIFNFTEZbJ2dyYW50J10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgc2V0X3V1aWQ6IGZ1bmN0aW9uICh1dWlkKSB7XG5cdCAgICAgIFVVSUQgPSB1dWlkO1xuXHQgICAgICBDT05ORUNUKCk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRfdXVpZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gVVVJRDtcblx0ICAgIH0sXG5cblx0ICAgIGlzQXJyYXk6IGZ1bmN0aW9uIChhcmcpIHtcblx0ICAgICAgcmV0dXJuIHV0aWxzLmlzQXJyYXkoYXJnKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldF9zdWJzY3JpYmVkX2NoYW5uZWxzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBnZW5lcmF0ZV9jaGFubmVsX2xpc3QoQ0hBTk5FTFMsIHRydWUpO1xuXHQgICAgfSxcblxuXHQgICAgcHJlc2VuY2VfaGVhcnRiZWF0OiBmdW5jdGlvbiAoYXJncykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIGRhdGEgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IEFVVEhfS0VZIH07XG5cblx0ICAgICAgdmFyIHN0ID0gSlNPTlsnc3RyaW5naWZ5J10oU1RBVEUpO1xuXHQgICAgICBpZiAoc3QubGVuZ3RoID4gMikgZGF0YVsnc3RhdGUnXSA9IEpTT05bJ3N0cmluZ2lmeSddKFNUQVRFKTtcblxuXHQgICAgICBpZiAoUFJFU0VOQ0VfSEIgPiAwICYmIFBSRVNFTkNFX0hCIDwgMzIwKSBkYXRhWydoZWFydGJlYXQnXSA9IFBSRVNFTkNFX0hCO1xuXG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIHtcblx0ICAgICAgICBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgY2hhbm5lbHMgPSB1dGlscy5lbmNvZGUoZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTLCB0cnVlKVsnam9pbiddKCcsJykpO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cHMgPSBnZW5lcmF0ZV9jaGFubmVsX2dyb3VwX2xpc3QoQ0hBTk5FTF9HUk9VUFMsIHRydWUpWydqb2luJ10oJywnKTtcblxuXHQgICAgICBpZiAoIWNoYW5uZWxzKSBjaGFubmVscyA9ICcsJztcblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXBzKSBkYXRhWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3VwcztcblxuXHQgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIGRhdGFbJ2luc3RhbmNlaWQnXSA9IElOU1RBTkNFSUQ7XG5cblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpLFxuXHQgICAgICAgIHVybDogW1xuXHQgICAgICAgICAgU1REX09SSUdJTiwgJ3YyJywgJ3ByZXNlbmNlJyxcblx0ICAgICAgICAgICdzdWIta2V5JywgU1VCU0NSSUJFX0tFWSxcblx0ICAgICAgICAgICdjaGFubmVsJywgY2hhbm5lbHMsXG5cdCAgICAgICAgICAnaGVhcnRiZWF0J1xuXHQgICAgICAgIF0sXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgc3RvcF90aW1lcnM6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgY2xlYXJUaW1lb3V0KF9wb2xsX3RpbWVyKTtcblx0ICAgICAgY2xlYXJUaW1lb3V0KF9wb2xsX3RpbWVyMik7XG5cdCAgICAgIGNsZWFyVGltZW91dChQUkVTRU5DRV9IQl9USU1FT1VUKTtcblx0ICAgIH0sXG5cblx0ICAgIHNodXRkb3duOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIFNFTEZbJ3N0b3BfdGltZXJzJ10oKTtcblx0ICAgICAgc2h1dGRvd24gJiYgc2h1dGRvd24oKTtcblx0ICAgIH0sXG5cblx0ICAgIC8vIEV4cG9zZSBQVUJOVUIgRnVuY3Rpb25zXG5cdCAgICB4ZHI6IHhkcixcblx0ICAgIHJlYWR5OiByZWFkeSxcblx0ICAgIGRiOiBkYixcblx0ICAgIHV1aWQ6IHV0aWxzLmdlbmVyYXRlVVVJRCxcblx0ICAgIG1hcDogdXRpbHMubWFwLFxuXHQgICAgZWFjaDogdXRpbHMuZWFjaCxcblx0ICAgICdlYWNoLWNoYW5uZWwnOiBlYWNoX2NoYW5uZWwsXG5cdCAgICBncmVwOiB1dGlscy5ncmVwLFxuXHQgICAgb2ZmbGluZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICBfcmVzZXRfb2ZmbGluZSgxLCB7IG1lc3NhZ2U6ICdPZmZsaW5lLiBQbGVhc2UgY2hlY2sgeW91ciBuZXR3b3JrIHNldHRpbmdzLicgfSk7XG5cdCAgICB9LFxuXHQgICAgc3VwcGxhbnQ6IHV0aWxzLnN1cHBsYW50LFxuXHQgICAgbm93OiB1dGlscy5ybm93LFxuXHQgICAgdW5pcXVlOiB1bmlxdWUsXG5cdCAgICB1cGRhdGVyOiB1dGlscy51cGRhdGVyXG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIF9wb2xsX29ubGluZSgpIHtcblx0ICAgIF9pc19vbmxpbmUoKSB8fCBfcmVzZXRfb2ZmbGluZSgxLCB7IGVycm9yOiAnT2ZmbGluZS4gUGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yayBzZXR0aW5ncy4nIH0pO1xuXHQgICAgX3BvbGxfdGltZXIgJiYgY2xlYXJUaW1lb3V0KF9wb2xsX3RpbWVyKTtcblx0ICAgIF9wb2xsX3RpbWVyID0gdXRpbHMudGltZW91dChfcG9sbF9vbmxpbmUsIFNFQ09ORCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX3BvbGxfb25saW5lMigpIHtcblx0ICAgIGlmICghVElNRV9DSEVDSykgcmV0dXJuO1xuXHQgICAgU0VMRlsndGltZSddKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG5cdCAgICAgIGRldGVjdF90aW1lX2RldGxhKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgfSwgc3VjY2Vzcyk7XG5cdCAgICAgIHN1Y2Nlc3MgfHwgX3Jlc2V0X29mZmxpbmUoMSwge1xuXHQgICAgICAgIGVycm9yOiAnSGVhcnRiZWF0IGZhaWxlZCB0byBjb25uZWN0IHRvIFB1Ym51YiBTZXJ2ZXJzLicgK1xuXHQgICAgICAgICdQbGVhc2UgY2hlY2sgeW91ciBuZXR3b3JrIHNldHRpbmdzLidcblx0ICAgICAgfSk7XG5cdCAgICAgIF9wb2xsX3RpbWVyMiAmJiBjbGVhclRpbWVvdXQoX3BvbGxfdGltZXIyKTtcblx0ICAgICAgX3BvbGxfdGltZXIyID0gdXRpbHMudGltZW91dChfcG9sbF9vbmxpbmUyLCBLRUVQQUxJVkUpO1xuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX3Jlc2V0X29mZmxpbmUoZXJyLCBtc2cpIHtcblx0ICAgIFNVQl9SRUNFSVZFUiAmJiBTVUJfUkVDRUlWRVIoZXJyLCBtc2cpO1xuXHQgICAgU1VCX1JFQ0VJVkVSID0gbnVsbDtcblxuXHQgICAgY2xlYXJUaW1lb3V0KF9wb2xsX3RpbWVyKTtcblx0ICAgIGNsZWFyVGltZW91dChfcG9sbF90aW1lcjIpO1xuXHQgIH1cblxuXHQgIGlmICghVVVJRCkgVVVJRCA9IFNFTEZbJ3V1aWQnXSgpO1xuXHQgIGlmICghSU5TVEFOQ0VJRCkgSU5TVEFOQ0VJRCA9IFNFTEZbJ3V1aWQnXSgpO1xuXHQgIGRiWydzZXQnXShTVUJTQ1JJQkVfS0VZICsgJ3V1aWQnLCBVVUlEKTtcblxuXHQgIF9wb2xsX3RpbWVyID0gdXRpbHMudGltZW91dChfcG9sbF9vbmxpbmUsIFNFQ09ORCk7XG5cdCAgX3BvbGxfdGltZXIyID0gdXRpbHMudGltZW91dChfcG9sbF9vbmxpbmUyLCBLRUVQQUxJVkUpO1xuXHQgIFBSRVNFTkNFX0hCX1RJTUVPVVQgPSB1dGlscy50aW1lb3V0KFxuXHQgICAgc3RhcnRfcHJlc2VuY2VfaGVhcnRiZWF0LFxuXHQgICAgKFBSRVNFTkNFX0hCX0lOVEVSVkFMIC0gMykgKiBTRUNPTkRcblx0ICApO1xuXG5cdCAgLy8gRGV0ZWN0IEFnZSBvZiBNZXNzYWdlXG5cdCAgZnVuY3Rpb24gZGV0ZWN0X2xhdGVuY3kodHQpIHtcblx0ICAgIHZhciBhZGp1c3RlZF90aW1lID0gdXRpbHMucm5vdygpIC0gVElNRV9EUklGVDtcblx0ICAgIHJldHVybiBhZGp1c3RlZF90aW1lIC0gdHQgLyAxMDAwMDtcblx0ICB9XG5cblx0ICBkZXRlY3RfdGltZV9kZXRsYSgpO1xuXHQgIGZ1bmN0aW9uIGRldGVjdF90aW1lX2RldGxhKGNiLCB0aW1lKSB7XG5cdCAgICB2YXIgc3RpbWUgPSB1dGlscy5ybm93KCk7XG5cblx0ICAgIHRpbWUgJiYgY2FsY3VsYXRlKHRpbWUpIHx8IFNFTEZbJ3RpbWUnXShjYWxjdWxhdGUpO1xuXG5cdCAgICBmdW5jdGlvbiBjYWxjdWxhdGUodGltZSkge1xuXHQgICAgICBpZiAoIXRpbWUpIHJldHVybjtcblx0ICAgICAgdmFyIHB0aW1lID0gdGltZSAvIDEwMDAwO1xuXHQgICAgICB2YXIgbGF0ZW5jeSA9ICh1dGlscy5ybm93KCkgLSBzdGltZSkgLyAyO1xuXHQgICAgICBUSU1FX0RSSUZUID0gdXRpbHMucm5vdygpIC0gKHB0aW1lICsgbGF0ZW5jeSk7XG5cdCAgICAgIGNiICYmIGNiKFRJTUVfRFJJRlQpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBTRUxGO1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdCAgUE5fQVBJOiBQTl9BUEksXG5cdCAgdW5pcXVlOiB1bmlxdWUsXG5cdCAgUE5tZXNzYWdlOiBQTm1lc3NhZ2UsXG5cdCAgREVGX1RJTUVPVVQ6IERFRl9USU1FT1VULFxuXHQgIHRpbWVvdXQ6IHV0aWxzLnRpbWVvdXQsXG5cdCAgYnVpbGRfdXJsOiB1dGlscy5idWlsZFVSTCxcblx0ICBlYWNoOiB1dGlscy5lYWNoLFxuXHQgIHV1aWQ6IHV0aWxzLmdlbmVyYXRlVVVJRCxcblx0ICBVUkxCSVQ6IGRlZmF1bHRDb25maWd1cmF0aW9uLlVSTEJJVCxcblx0ICBncmVwOiB1dGlscy5ncmVwLFxuXHQgIHN1cHBsYW50OiB1dGlscy5zdXBwbGFudCxcblx0ICBub3c6IHV0aWxzLnJub3csXG5cdCAgdXBkYXRlcjogdXRpbHMudXBkYXRlcixcblx0ICBtYXA6IHV0aWxzLm1hcFxuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0XHRcIlBBUkFNU0JJVFwiOiBcIiZcIixcblx0XHRcIlVSTEJJVFwiOiBcIi9cIlxuXHR9O1xuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogMCwgYmxvY2stc2NvcGVkLXZhcjogMCwgbm8tcmVkZWNsYXJlOiAwLCBndWFyZC1mb3ItaW46IDAgKi9cblxuXHR2YXIgZGVmYXVsdENvbmZpZ3VyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgUkVQTCA9IC97KFtcXHdcXC1dKyl9L2c7XG5cblx0ZnVuY3Rpb24gcm5vdygpIHtcblx0ICByZXR1cm4gK25ldyBEYXRlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcblx0ICByZXR1cm4gISFhcmcgJiYgdHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgJiYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheShhcmcpIHx8IHR5cGVvZihhcmcubGVuZ3RoKSA9PT0gJ251bWJlcicpO1xuXHQgIC8vIHJldHVybiAhIWFyZyAmJiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KGFyZykgfHwgdHlwZW9mKGFyZy5sZW5ndGgpID09PSBcIm51bWJlclwiKVxuXHR9XG5cblx0LyoqXG5cdCAqIEVBQ0hcblx0ICogPT09PVxuXHQgKiBlYWNoKCBbMSwyLDNdLCBmdW5jdGlvbihpdGVtKSB7IH0gKVxuXHQgKi9cblx0ZnVuY3Rpb24gZWFjaChvLCBmKSB7XG5cdCAgaWYgKCFvIHx8ICFmKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgaWYgKGlzQXJyYXkobykpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gby5sZW5ndGg7IGkgPCBsOykge1xuXHQgICAgICBmLmNhbGwob1tpXSwgb1tpXSwgaSsrKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgZm9yICh2YXIgaSBpbiBvKSB7XG5cdCAgICAgIG8uaGFzT3duUHJvcGVydHkgJiZcblx0ICAgICAgby5oYXNPd25Qcm9wZXJ0eShpKSAmJlxuXHQgICAgICBmLmNhbGwob1tpXSwgaSwgb1tpXSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEVOQ09ERVxuXHQgKiA9PT09PT1cblx0ICogdmFyIGVuY29kZWRfZGF0YSA9IGVuY29kZSgncGF0aCcpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKHBhdGgpIHsgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChwYXRoKTsgfVxuXG5cdC8qKlxuXHQgKiBCdWlsZCBVcmxcblx0ICogPT09PT09PVxuXHQgKlxuXHQgKi9cblx0ZnVuY3Rpb24gYnVpbGRVUkwodXJsQ29tcG9uZW50cywgdXJsUGFyYW1zKSB7XG5cdCAgdmFyIHVybCA9IHVybENvbXBvbmVudHMuam9pbihkZWZhdWx0Q29uZmlndXJhdGlvbi5VUkxCSVQpO1xuXHQgIHZhciBwYXJhbXMgPSBbXTtcblxuXHQgIGlmICghdXJsUGFyYW1zKSByZXR1cm4gdXJsO1xuXG5cdCAgZWFjaCh1cmxQYXJhbXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdCAgICB2YXIgdmFsdWVTdHIgPSAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgPyBKU09OWydzdHJpbmdpZnknXSh2YWx1ZSkgOiB2YWx1ZTtcblx0ICAgICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmXG5cdCAgICAgIHZhbHVlICE9PSBudWxsICYmIGVuY29kZSh2YWx1ZVN0cikubGVuZ3RoID4gMFxuXHQgICAgKSAmJiBwYXJhbXMucHVzaChrZXkgKyAnPScgKyBlbmNvZGUodmFsdWVTdHIpKTtcblx0ICB9KTtcblxuXHQgIHVybCArPSAnPycgKyBwYXJhbXMuam9pbihkZWZhdWx0Q29uZmlndXJhdGlvbi5QQVJBTVNCSVQpO1xuXHQgIHJldHVybiB1cmw7XG5cdH1cblxuXHQvKipcblx0ICogVVBEQVRFUlxuXHQgKiA9PT09PT09XG5cdCAqIHZhciB0aW1lc3RhbXAgPSB1bmlxdWUoKTtcblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZXIoZnVuLCByYXRlKSB7XG5cdCAgdmFyIHRpbWVvdXQ7XG5cdCAgdmFyIGxhc3QgPSAwO1xuXHQgIHZhciBydW5uaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAobGFzdCArIHJhdGUgPiBybm93KCkpIHtcblx0ICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHQgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChydW5uaXQsIHJhdGUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbGFzdCA9IHJub3coKTtcblx0ICAgICAgZnVuKCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHJldHVybiBydW5uaXQ7XG5cdH1cblxuXHQvKipcblx0ICogR1JFUFxuXHQgKiA9PT09XG5cdCAqIHZhciBsaXN0ID0gZ3JlcCggWzEsMiwzXSwgZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbSAlIDIgfSApXG5cdCAqL1xuXHRmdW5jdGlvbiBncmVwKGxpc3QsIGZ1bikge1xuXHQgIHZhciBmaW4gPSBbXTtcblx0ICBlYWNoKGxpc3QgfHwgW10sIGZ1bmN0aW9uIChsKSB7XG5cdCAgICBmdW4obCkgJiYgZmluLnB1c2gobCk7XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGZpbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBTVVBQTEFOVFxuXHQgKiA9PT09PT09PVxuXHQgKiB2YXIgdGV4dCA9IHN1cHBsYW50KCAnSGVsbG8ge25hbWV9IScsIHsgbmFtZSA6ICdKb2huJyB9IClcblx0ICovXG5cdGZ1bmN0aW9uIHN1cHBsYW50KHN0ciwgdmFsdWVzKSB7XG5cdCAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFUEwsIGZ1bmN0aW9uIChfLCBtYXRjaCkge1xuXHQgICAgcmV0dXJuIHZhbHVlc1ttYXRjaF0gfHwgXztcblx0ICB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiB0aW1lb3V0XG5cdCAqID09PT09PT1cblx0ICogdGltZW91dCggZnVuY3Rpb24oKXt9LCAxMDAgKTtcblx0ICovXG5cdGZ1bmN0aW9uIHRpbWVvdXQoZnVuLCB3YWl0KSB7XG5cdCAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgd2FpdCk7XG5cdH1cblxuXHQvKipcblx0ICogdXVpZFxuXHQgKiA9PT09XG5cdCAqIHZhciBteV91dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cdCAqL1xuXHRmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoY2FsbGJhY2spIHtcblx0ICB2YXIgdSA9ICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZyxcblx0ICAgIGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMDtcblx0ICAgICAgdmFyIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuXHQgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG5cdCAgICB9KTtcblx0ICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHUpO1xuXHQgIHJldHVybiB1O1xuXHR9XG5cblx0LyoqXG5cdCAqIE1BUFxuXHQgKiA9PT1cblx0ICogdmFyIGxpc3QgPSBtYXAoIFsxLDIsM10sIGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gKyAxIH0gKVxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGxpc3QsIGZ1bikge1xuXHQgIHZhciBmaW4gPSBbXTtcblx0ICBlYWNoKGxpc3QgfHwgW10sIGZ1bmN0aW9uIChrLCB2KSB7XG5cdCAgICBmaW4ucHVzaChmdW4oaywgdikpO1xuXHQgIH0pO1xuXHQgIHJldHVybiBmaW47XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHBhbUVuY29kZShzdHIpIHtcblx0ICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCkqfl0vZywgZnVuY3Rpb24gKGMpIHtcblx0ICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdCAgfSk7XG5cdH1cblxuXG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIGJ1aWxkVVJMOiBidWlsZFVSTCxcblx0ICBlbmNvZGU6IGVuY29kZSxcblx0ICBlYWNoOiBlYWNoLFxuXHQgIHVwZGF0ZXI6IHVwZGF0ZXIsXG5cdCAgcm5vdzogcm5vdyxcblx0ICBpc0FycmF5OiBpc0FycmF5LFxuXHQgIG1hcDogbWFwLFxuXHQgIHBhbUVuY29kZTogcGFtRW5jb2RlLFxuXHQgIGdlbmVyYXRlVVVJRDogZ2VuZXJhdGVVVUlELFxuXHQgIHRpbWVvdXQ6IHRpbWVvdXQsXG5cdCAgc3VwcGxhbnQ6IHN1cHBsYW50LFxuXHQgIGdyZXA6IGdyZXBcblx0fTtcblxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogZXNsaW50IGNhbWVsY2FzZTogMCBlcWVxZXE6IDAgKi9cblxuXHR2YXIgQ3J5cHRvSlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG5cdGZ1bmN0aW9uIGNyeXB0b19vYmooKSB7XG5cdCAgZnVuY3Rpb24gU0hBMjU2KHMpIHtcblx0ICAgIHJldHVybiBDcnlwdG9KU1snU0hBMjU2J10ocylbJ3RvU3RyaW5nJ10oQ3J5cHRvSlNbJ2VuYyddWydIZXgnXSk7XG5cdCAgfVxuXG5cdCAgdmFyIGl2ID0gJzAxMjM0NTY3ODkwMTIzNDUnO1xuXG5cdCAgdmFyIGFsbG93ZWRLZXlFbmNvZGluZ3MgPSBbJ2hleCcsICd1dGY4JywgJ2Jhc2U2NCcsICdiaW5hcnknXTtcblx0ICB2YXIgYWxsb3dlZEtleUxlbmd0aHMgPSBbMTI4LCAyNTZdO1xuXHQgIHZhciBhbGxvd2VkTW9kZXMgPSBbJ2VjYicsICdjYmMnXTtcblxuXHQgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblx0ICAgIGVuY3J5cHRLZXk6IHRydWUsXG5cdCAgICBrZXlFbmNvZGluZzogJ3V0ZjgnLFxuXHQgICAga2V5TGVuZ3RoOiAyNTYsXG5cdCAgICBtb2RlOiAnY2JjJ1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBwYXJzZV9vcHRpb25zKG9wdGlvbnMpIHtcblx0ICAgIC8vIERlZmF1bHRzXG5cdCAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICAgIGlmICghb3B0aW9uc1snaGFzT3duUHJvcGVydHknXSgnZW5jcnlwdEtleScpKSBvcHRpb25zWydlbmNyeXB0S2V5J10gPSBkZWZhdWx0T3B0aW9uc1snZW5jcnlwdEtleSddO1xuXHQgICAgaWYgKCFvcHRpb25zWydoYXNPd25Qcm9wZXJ0eSddKCdrZXlFbmNvZGluZycpKSBvcHRpb25zWydrZXlFbmNvZGluZyddID0gZGVmYXVsdE9wdGlvbnNbJ2tleUVuY29kaW5nJ107XG5cdCAgICBpZiAoIW9wdGlvbnNbJ2hhc093blByb3BlcnR5J10oJ2tleUxlbmd0aCcpKSBvcHRpb25zWydrZXlMZW5ndGgnXSA9IGRlZmF1bHRPcHRpb25zWydrZXlMZW5ndGgnXTtcblx0ICAgIGlmICghb3B0aW9uc1snaGFzT3duUHJvcGVydHknXSgnbW9kZScpKSBvcHRpb25zWydtb2RlJ10gPSBkZWZhdWx0T3B0aW9uc1snbW9kZSddO1xuXG5cdCAgICAvLyBWYWxpZGF0aW9uXG5cdCAgICBpZiAoYWxsb3dlZEtleUVuY29kaW5nc1snaW5kZXhPZiddKG9wdGlvbnNbJ2tleUVuY29kaW5nJ11bJ3RvTG93ZXJDYXNlJ10oKSkgPT0gLTEpIG9wdGlvbnNbJ2tleUVuY29kaW5nJ10gPSBkZWZhdWx0T3B0aW9uc1sna2V5RW5jb2RpbmcnXTtcblx0ICAgIGlmIChhbGxvd2VkS2V5TGVuZ3Roc1snaW5kZXhPZiddKHBhcnNlSW50KG9wdGlvbnNbJ2tleUxlbmd0aCddLCAxMCkpID09IC0xKSBvcHRpb25zWydrZXlMZW5ndGgnXSA9IGRlZmF1bHRPcHRpb25zWydrZXlMZW5ndGgnXTtcblx0ICAgIGlmIChhbGxvd2VkTW9kZXNbJ2luZGV4T2YnXShvcHRpb25zWydtb2RlJ11bJ3RvTG93ZXJDYXNlJ10oKSkgPT0gLTEpIG9wdGlvbnNbJ21vZGUnXSA9IGRlZmF1bHRPcHRpb25zWydtb2RlJ107XG5cblx0ICAgIHJldHVybiBvcHRpb25zO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGRlY29kZV9rZXkoa2V5LCBvcHRpb25zKSB7XG5cdCAgICBpZiAob3B0aW9uc1sna2V5RW5jb2RpbmcnXSA9PT0gJ2Jhc2U2NCcpIHtcblx0ICAgICAgcmV0dXJuIENyeXB0b0pTWydlbmMnXVsnQmFzZTY0J11bJ3BhcnNlJ10oa2V5KTtcblx0ICAgIH0gZWxzZSBpZiAob3B0aW9uc1sna2V5RW5jb2RpbmcnXSA9PT0gJ2hleCcpIHtcblx0ICAgICAgcmV0dXJuIENyeXB0b0pTWydlbmMnXVsnSGV4J11bJ3BhcnNlJ10oa2V5KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBrZXk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZ2V0X3BhZGRlZF9rZXkoa2V5LCBvcHRpb25zKSB7XG5cdCAgICBrZXkgPSBkZWNvZGVfa2V5KGtleSwgb3B0aW9ucyk7XG5cdCAgICBpZiAob3B0aW9uc1snZW5jcnlwdEtleSddKSB7XG5cdCAgICAgIHJldHVybiBDcnlwdG9KU1snZW5jJ11bJ1V0ZjgnXVsncGFyc2UnXShTSEEyNTYoa2V5KVsnc2xpY2UnXSgwLCAzMikpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGtleTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBnZXRfbW9kZShvcHRpb25zKSB7XG5cdCAgICBpZiAob3B0aW9uc1snbW9kZSddID09PSAnZWNiJykge1xuXHQgICAgICByZXR1cm4gQ3J5cHRvSlNbJ21vZGUnXVsnRUNCJ107XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gQ3J5cHRvSlNbJ21vZGUnXVsnQ0JDJ107XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZ2V0X2l2KG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiAob3B0aW9uc1snbW9kZSddID09PSAnY2JjJykgPyBDcnlwdG9KU1snZW5jJ11bJ1V0ZjgnXVsncGFyc2UnXShpdikgOiBudWxsO1xuXHQgIH1cblxuXHQgIHJldHVybiB7XG5cdCAgICBlbmNyeXB0OiBmdW5jdGlvbiAoZGF0YSwga2V5LCBvcHRpb25zKSB7XG5cdCAgICAgIGlmICgha2V5KSByZXR1cm4gZGF0YTtcblx0ICAgICAgb3B0aW9ucyA9IHBhcnNlX29wdGlvbnMob3B0aW9ucyk7XG5cdCAgICAgIHZhciBpdiA9IGdldF9pdihvcHRpb25zKTtcblx0ICAgICAgdmFyIG1vZGUgPSBnZXRfbW9kZShvcHRpb25zKTtcblx0ICAgICAgdmFyIGNpcGhlcl9rZXkgPSBnZXRfcGFkZGVkX2tleShrZXksIG9wdGlvbnMpO1xuXHQgICAgICB2YXIgaGV4X21lc3NhZ2UgPSBKU09OWydzdHJpbmdpZnknXShkYXRhKTtcblx0ICAgICAgdmFyIGVuY3J5cHRlZEhleEFycmF5ID0gQ3J5cHRvSlNbJ0FFUyddWydlbmNyeXB0J10oaGV4X21lc3NhZ2UsIGNpcGhlcl9rZXksIHsgaXY6IGl2LCBtb2RlOiBtb2RlIH0pWydjaXBoZXJ0ZXh0J107XG5cdCAgICAgIHZhciBiYXNlXzY0X2VuY3J5cHRlZCA9IGVuY3J5cHRlZEhleEFycmF5Wyd0b1N0cmluZyddKENyeXB0b0pTWydlbmMnXVsnQmFzZTY0J10pO1xuXHQgICAgICByZXR1cm4gYmFzZV82NF9lbmNyeXB0ZWQgfHwgZGF0YTtcblx0ICAgIH0sXG5cblx0ICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChkYXRhLCBrZXksIG9wdGlvbnMpIHtcblx0ICAgICAgaWYgKCFrZXkpIHJldHVybiBkYXRhO1xuXHQgICAgICBvcHRpb25zID0gcGFyc2Vfb3B0aW9ucyhvcHRpb25zKTtcblx0ICAgICAgdmFyIGl2ID0gZ2V0X2l2KG9wdGlvbnMpO1xuXHQgICAgICB2YXIgbW9kZSA9IGdldF9tb2RlKG9wdGlvbnMpO1xuXHQgICAgICB2YXIgY2lwaGVyX2tleSA9IGdldF9wYWRkZWRfa2V5KGtleSwgb3B0aW9ucyk7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgdmFyIGJpbmFyeV9lbmMgPSBDcnlwdG9KU1snZW5jJ11bJ0Jhc2U2NCddWydwYXJzZSddKGRhdGEpO1xuXHQgICAgICAgIHZhciBqc29uX3BsYWluID0gQ3J5cHRvSlNbJ0FFUyddWydkZWNyeXB0J10oeyBjaXBoZXJ0ZXh0OiBiaW5hcnlfZW5jIH0sIGNpcGhlcl9rZXksIHsgaXY6IGl2LCBtb2RlOiBtb2RlIH0pWyd0b1N0cmluZyddKENyeXB0b0pTWydlbmMnXVsnVXRmOCddKTtcblx0ICAgICAgICB2YXIgcGxhaW50ZXh0ID0gSlNPTlsncGFyc2UnXShqc29uX3BsYWluKTtcblx0ICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGNyeXB0b19vYmo7XG5cblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qXG5cdCBDcnlwdG9KUyB2My4xLjJcblx0IGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuXHQgKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdCBjb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG5cdCAqL1xuXHR2YXIgQ3J5cHRvSlM9Q3J5cHRvSlN8fGZ1bmN0aW9uKGgscyl7dmFyIGY9e30sZz1mLmxpYj17fSxxPWZ1bmN0aW9uKCl7fSxtPWcuQmFzZT17ZXh0ZW5kOmZ1bmN0aW9uKGEpe3EucHJvdG90eXBlPXRoaXM7dmFyIGM9bmV3IHE7YSYmYy5taXhJbihhKTtjLmhhc093blByb3BlcnR5KFwiaW5pdFwiKXx8KGMuaW5pdD1mdW5jdGlvbigpe2MuJHN1cGVyLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSk7Yy5pbml0LnByb3RvdHlwZT1jO2MuJHN1cGVyPXRoaXM7cmV0dXJuIGN9LGNyZWF0ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZXh0ZW5kKCk7YS5pbml0LmFwcGx5KGEsYXJndW1lbnRzKTtyZXR1cm4gYX0saW5pdDpmdW5jdGlvbigpe30sbWl4SW46ZnVuY3Rpb24oYSl7Zm9yKHZhciBjIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShjKSYmKHRoaXNbY109YVtjXSk7YS5oYXNPd25Qcm9wZXJ0eShcInRvU3RyaW5nXCIpJiYodGhpcy50b1N0cmluZz1hLnRvU3RyaW5nKX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyl9fSxcblx0ICAgIHI9Zy5Xb3JkQXJyYXk9bS5leHRlbmQoe2luaXQ6ZnVuY3Rpb24oYSxjKXthPXRoaXMud29yZHM9YXx8W107dGhpcy5zaWdCeXRlcz1jIT1zP2M6NCphLmxlbmd0aH0sdG9TdHJpbmc6ZnVuY3Rpb24oYSl7cmV0dXJuKGF8fGspLnN0cmluZ2lmeSh0aGlzKX0sY29uY2F0OmZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMud29yZHMsZD1hLndvcmRzLGI9dGhpcy5zaWdCeXRlczthPWEuc2lnQnl0ZXM7dGhpcy5jbGFtcCgpO2lmKGIlNClmb3IodmFyIGU9MDtlPGE7ZSsrKWNbYitlPj4+Ml18PShkW2U+Pj4yXT4+PjI0LTgqKGUlNCkmMjU1KTw8MjQtOCooKGIrZSklNCk7ZWxzZSBpZig2NTUzNTxkLmxlbmd0aClmb3IoZT0wO2U8YTtlKz00KWNbYitlPj4+Ml09ZFtlPj4+Ml07ZWxzZSBjLnB1c2guYXBwbHkoYyxkKTt0aGlzLnNpZ0J5dGVzKz1hO3JldHVybiB0aGlzfSxjbGFtcDpmdW5jdGlvbigpe3ZhciBhPXRoaXMud29yZHMsYz10aGlzLnNpZ0J5dGVzO2FbYz4+PjJdJj00Mjk0OTY3Mjk1PDxcblx0ICAgICAgMzItOCooYyU0KTthLmxlbmd0aD1oLmNlaWwoYy80KX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgYT1tLmNsb25lLmNhbGwodGhpcyk7YS53b3Jkcz10aGlzLndvcmRzLnNsaWNlKDApO3JldHVybiBhfSxyYW5kb206ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPVtdLGQ9MDtkPGE7ZCs9NCljLnB1c2goNDI5NDk2NzI5NipoLnJhbmRvbSgpfDApO3JldHVybiBuZXcgci5pbml0KGMsYSl9fSksbD1mLmVuYz17fSxrPWwuSGV4PXtzdHJpbmdpZnk6ZnVuY3Rpb24oYSl7dmFyIGM9YS53b3JkczthPWEuc2lnQnl0ZXM7Zm9yKHZhciBkPVtdLGI9MDtiPGE7YisrKXt2YXIgZT1jW2I+Pj4yXT4+PjI0LTgqKGIlNCkmMjU1O2QucHVzaCgoZT4+PjQpLnRvU3RyaW5nKDE2KSk7ZC5wdXNoKChlJjE1KS50b1N0cmluZygxNikpfXJldHVybiBkLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1hLmxlbmd0aCxkPVtdLGI9MDtiPGM7Yis9MilkW2I+Pj4zXXw9cGFyc2VJbnQoYS5zdWJzdHIoYixcblx0ICAgICAgICAyKSwxNik8PDI0LTQqKGIlOCk7cmV0dXJuIG5ldyByLmluaXQoZCxjLzIpfX0sbj1sLkxhdGluMT17c3RyaW5naWZ5OmZ1bmN0aW9uKGEpe3ZhciBjPWEud29yZHM7YT1hLnNpZ0J5dGVzO2Zvcih2YXIgZD1bXSxiPTA7YjxhO2IrKylkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjW2I+Pj4yXT4+PjI0LTgqKGIlNCkmMjU1KSk7cmV0dXJuIGQuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPWEubGVuZ3RoLGQ9W10sYj0wO2I8YztiKyspZFtiPj4+Ml18PShhLmNoYXJDb2RlQXQoYikmMjU1KTw8MjQtOCooYiU0KTtyZXR1cm4gbmV3IHIuaW5pdChkLGMpfX0saj1sLlV0Zjg9e3N0cmluZ2lmeTpmdW5jdGlvbihhKXt0cnl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUobi5zdHJpbmdpZnkoYSkpKX1jYXRjaChjKXt0aHJvdyBFcnJvcihcIk1hbGZvcm1lZCBVVEYtOCBkYXRhXCIpO319LHBhcnNlOmZ1bmN0aW9uKGEpe3JldHVybiBuLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChhKSkpfX0sXG5cdCAgICB1PWcuQnVmZmVyZWRCbG9ja0FsZ29yaXRobT1tLmV4dGVuZCh7cmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9kYXRhPW5ldyByLmluaXQ7dGhpcy5fbkRhdGFCeXRlcz0wfSxfYXBwZW5kOmZ1bmN0aW9uKGEpe1wic3RyaW5nXCI9PXR5cGVvZiBhJiYoYT1qLnBhcnNlKGEpKTt0aGlzLl9kYXRhLmNvbmNhdChhKTt0aGlzLl9uRGF0YUJ5dGVzKz1hLnNpZ0J5dGVzfSxfcHJvY2VzczpmdW5jdGlvbihhKXt2YXIgYz10aGlzLl9kYXRhLGQ9Yy53b3JkcyxiPWMuc2lnQnl0ZXMsZT10aGlzLmJsb2NrU2l6ZSxmPWIvKDQqZSksZj1hP2guY2VpbChmKTpoLm1heCgoZnwwKS10aGlzLl9taW5CdWZmZXJTaXplLDApO2E9ZiplO2I9aC5taW4oNCphLGIpO2lmKGEpe2Zvcih2YXIgZz0wO2c8YTtnKz1lKXRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGQsZyk7Zz1kLnNwbGljZSgwLGEpO2Muc2lnQnl0ZXMtPWJ9cmV0dXJuIG5ldyByLmluaXQoZyxiKX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgYT1tLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgIGEuX2RhdGE9dGhpcy5fZGF0YS5jbG9uZSgpO3JldHVybiBhfSxfbWluQnVmZmVyU2l6ZTowfSk7Zy5IYXNoZXI9dS5leHRlbmQoe2NmZzptLmV4dGVuZCgpLGluaXQ6ZnVuY3Rpb24oYSl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKGEpO3RoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXt1LnJlc2V0LmNhbGwodGhpcyk7dGhpcy5fZG9SZXNldCgpfSx1cGRhdGU6ZnVuY3Rpb24oYSl7dGhpcy5fYXBwZW5kKGEpO3RoaXMuX3Byb2Nlc3MoKTtyZXR1cm4gdGhpc30sZmluYWxpemU6ZnVuY3Rpb24oYSl7YSYmdGhpcy5fYXBwZW5kKGEpO3JldHVybiB0aGlzLl9kb0ZpbmFsaXplKCl9LGJsb2NrU2l6ZToxNixfY3JlYXRlSGVscGVyOmZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihjLGQpe3JldHVybihuZXcgYS5pbml0KGQpKS5maW5hbGl6ZShjKX19LF9jcmVhdGVIbWFjSGVscGVyOmZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihjLGQpe3JldHVybihuZXcgdC5ITUFDLmluaXQoYSxcblx0ICAgIGQpKS5maW5hbGl6ZShjKX19fSk7dmFyIHQ9Zi5hbGdvPXt9O3JldHVybiBmfShNYXRoKTtcblxuXHQvLyBTSEEyNTZcblx0KGZ1bmN0aW9uKGgpe2Zvcih2YXIgcz1DcnlwdG9KUyxmPXMubGliLGc9Zi5Xb3JkQXJyYXkscT1mLkhhc2hlcixmPXMuYWxnbyxtPVtdLHI9W10sbD1mdW5jdGlvbihhKXtyZXR1cm4gNDI5NDk2NzI5NiooYS0oYXwwKSl8MH0saz0yLG49MDs2ND5uOyl7dmFyIGo7YTp7aj1rO2Zvcih2YXIgdT1oLnNxcnQoaiksdD0yO3Q8PXU7dCsrKWlmKCEoaiV0KSl7aj0hMTticmVhayBhfWo9ITB9aiYmKDg+biYmKG1bbl09bChoLnBvdyhrLDAuNSkpKSxyW25dPWwoaC5wb3coaywxLzMpKSxuKyspO2srK312YXIgYT1bXSxmPWYuU0hBMjU2PXEuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IGcuaW5pdChtLnNsaWNlKDApKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGMsZCl7Zm9yKHZhciBiPXRoaXMuX2hhc2gud29yZHMsZT1iWzBdLGY9YlsxXSxnPWJbMl0saj1iWzNdLGg9Yls0XSxtPWJbNV0sbj1iWzZdLHE9Yls3XSxwPTA7NjQ+cDtwKyspe2lmKDE2PnApYVtwXT1cblx0ICBjW2QrcF18MDtlbHNle3ZhciBrPWFbcC0xNV0sbD1hW3AtMl07YVtwXT0oKGs8PDI1fGs+Pj43KV4oazw8MTR8az4+PjE4KV5rPj4+MykrYVtwLTddKygobDw8MTV8bD4+PjE3KV4obDw8MTN8bD4+PjE5KV5sPj4+MTApK2FbcC0xNl19az1xKygoaDw8MjZ8aD4+PjYpXihoPDwyMXxoPj4+MTEpXihoPDw3fGg+Pj4yNSkpKyhoJm1efmgmbikrcltwXSthW3BdO2w9KChlPDwzMHxlPj4+MileKGU8PDE5fGU+Pj4xMyleKGU8PDEwfGU+Pj4yMikpKyhlJmZeZSZnXmYmZyk7cT1uO249bTttPWg7aD1qK2t8MDtqPWc7Zz1mO2Y9ZTtlPWsrbHwwfWJbMF09YlswXStlfDA7YlsxXT1iWzFdK2Z8MDtiWzJdPWJbMl0rZ3wwO2JbM109YlszXStqfDA7Yls0XT1iWzRdK2h8MDtiWzVdPWJbNV0rbXwwO2JbNl09Yls2XStufDA7Yls3XT1iWzddK3F8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9kYXRhLGQ9YS53b3JkcyxiPTgqdGhpcy5fbkRhdGFCeXRlcyxlPTgqYS5zaWdCeXRlcztcblx0ICBkW2U+Pj41XXw9MTI4PDwyNC1lJTMyO2RbKGUrNjQ+Pj45PDw0KSsxNF09aC5mbG9vcihiLzQyOTQ5NjcyOTYpO2RbKGUrNjQ+Pj45PDw0KSsxNV09YjthLnNpZ0J5dGVzPTQqZC5sZW5ndGg7dGhpcy5fcHJvY2VzcygpO3JldHVybiB0aGlzLl9oYXNofSxjbG9uZTpmdW5jdGlvbigpe3ZhciBhPXEuY2xvbmUuY2FsbCh0aGlzKTthLl9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKTtyZXR1cm4gYX19KTtzLlNIQTI1Nj1xLl9jcmVhdGVIZWxwZXIoZik7cy5IbWFjU0hBMjU2PXEuX2NyZWF0ZUhtYWNIZWxwZXIoZil9KShNYXRoKTtcblxuXHQvLyBITUFDIFNIQTI1NlxuXHQoZnVuY3Rpb24oKXt2YXIgaD1DcnlwdG9KUyxzPWguZW5jLlV0Zjg7aC5hbGdvLkhNQUM9aC5saWIuQmFzZS5leHRlbmQoe2luaXQ6ZnVuY3Rpb24oZixnKXtmPXRoaXMuX2hhc2hlcj1uZXcgZi5pbml0O1wic3RyaW5nXCI9PXR5cGVvZiBnJiYoZz1zLnBhcnNlKGcpKTt2YXIgaD1mLmJsb2NrU2l6ZSxtPTQqaDtnLnNpZ0J5dGVzPm0mJihnPWYuZmluYWxpemUoZykpO2cuY2xhbXAoKTtmb3IodmFyIHI9dGhpcy5fb0tleT1nLmNsb25lKCksbD10aGlzLl9pS2V5PWcuY2xvbmUoKSxrPXIud29yZHMsbj1sLndvcmRzLGo9MDtqPGg7aisrKWtbal1ePTE1NDk1NTY4MjgsbltqXV49OTA5NTIyNDg2O3Iuc2lnQnl0ZXM9bC5zaWdCeXRlcz1tO3RoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXt2YXIgZj10aGlzLl9oYXNoZXI7Zi5yZXNldCgpO2YudXBkYXRlKHRoaXMuX2lLZXkpfSx1cGRhdGU6ZnVuY3Rpb24oZil7dGhpcy5faGFzaGVyLnVwZGF0ZShmKTtyZXR1cm4gdGhpc30sZmluYWxpemU6ZnVuY3Rpb24oZil7dmFyIGc9XG5cdCAgdGhpcy5faGFzaGVyO2Y9Zy5maW5hbGl6ZShmKTtnLnJlc2V0KCk7cmV0dXJuIGcuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChmKSl9fSl9KSgpO1xuXG5cdC8vIEJhc2U2NFxuXHQoZnVuY3Rpb24oKXt2YXIgdT1DcnlwdG9KUyxwPXUubGliLldvcmRBcnJheTt1LmVuYy5CYXNlNjQ9e3N0cmluZ2lmeTpmdW5jdGlvbihkKXt2YXIgbD1kLndvcmRzLHA9ZC5zaWdCeXRlcyx0PXRoaXMuX21hcDtkLmNsYW1wKCk7ZD1bXTtmb3IodmFyIHI9MDtyPHA7cis9Mylmb3IodmFyIHc9KGxbcj4+PjJdPj4+MjQtOCoociU0KSYyNTUpPDwxNnwobFtyKzE+Pj4yXT4+PjI0LTgqKChyKzEpJTQpJjI1NSk8PDh8bFtyKzI+Pj4yXT4+PjI0LTgqKChyKzIpJTQpJjI1NSx2PTA7ND52JiZyKzAuNzUqdjxwO3YrKylkLnB1c2godC5jaGFyQXQodz4+PjYqKDMtdikmNjMpKTtpZihsPXQuY2hhckF0KDY0KSlmb3IoO2QubGVuZ3RoJTQ7KWQucHVzaChsKTtyZXR1cm4gZC5qb2luKFwiXCIpfSxwYXJzZTpmdW5jdGlvbihkKXt2YXIgbD1kLmxlbmd0aCxzPXRoaXMuX21hcCx0PXMuY2hhckF0KDY0KTt0JiYodD1kLmluZGV4T2YodCksLTEhPXQmJihsPXQpKTtmb3IodmFyIHQ9W10scj0wLHc9MDt3PFxuXHRsO3crKylpZih3JTQpe3ZhciB2PXMuaW5kZXhPZihkLmNoYXJBdCh3LTEpKTw8MioodyU0KSxiPXMuaW5kZXhPZihkLmNoYXJBdCh3KSk+Pj42LTIqKHclNCk7dFtyPj4+Ml18PSh2fGIpPDwyNC04KihyJTQpO3IrK31yZXR1cm4gcC5jcmVhdGUodCxyKX0sX21hcDpcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCJ9fSkoKTtcblxuXHQvLyBCbG9ja0NpcGhlclxuXHQoZnVuY3Rpb24odSl7ZnVuY3Rpb24gcChiLG4sYSxjLGUsaixrKXtiPWIrKG4mYXx+biZjKStlK2s7cmV0dXJuKGI8PGp8Yj4+PjMyLWopK259ZnVuY3Rpb24gZChiLG4sYSxjLGUsaixrKXtiPWIrKG4mY3xhJn5jKStlK2s7cmV0dXJuKGI8PGp8Yj4+PjMyLWopK259ZnVuY3Rpb24gbChiLG4sYSxjLGUsaixrKXtiPWIrKG5eYV5jKStlK2s7cmV0dXJuKGI8PGp8Yj4+PjMyLWopK259ZnVuY3Rpb24gcyhiLG4sYSxjLGUsaixrKXtiPWIrKGFeKG58fmMpKStlK2s7cmV0dXJuKGI8PGp8Yj4+PjMyLWopK259Zm9yKHZhciB0PUNyeXB0b0pTLHI9dC5saWIsdz1yLldvcmRBcnJheSx2PXIuSGFzaGVyLHI9dC5hbGdvLGI9W10seD0wOzY0Png7eCsrKWJbeF09NDI5NDk2NzI5Nip1LmFicyh1LnNpbih4KzEpKXwwO3I9ci5NRDU9di5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgdy5pbml0KFsxNzMyNTg0MTkzLDQwMjMyMzM0MTcsMjU2MjM4MzEwMiwyNzE3MzM4NzhdKX0sXG5cdCAgX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHEsbil7Zm9yKHZhciBhPTA7MTY+YTthKyspe3ZhciBjPW4rYSxlPXFbY107cVtjXT0oZTw8OHxlPj4+MjQpJjE2NzExOTM1fChlPDwyNHxlPj4+OCkmNDI3ODI1NTM2MH12YXIgYT10aGlzLl9oYXNoLndvcmRzLGM9cVtuKzBdLGU9cVtuKzFdLGo9cVtuKzJdLGs9cVtuKzNdLHo9cVtuKzRdLHI9cVtuKzVdLHQ9cVtuKzZdLHc9cVtuKzddLHY9cVtuKzhdLEE9cVtuKzldLEI9cVtuKzEwXSxDPXFbbisxMV0sdT1xW24rMTJdLEQ9cVtuKzEzXSxFPXFbbisxNF0seD1xW24rMTVdLGY9YVswXSxtPWFbMV0sZz1hWzJdLGg9YVszXSxmPXAoZixtLGcsaCxjLDcsYlswXSksaD1wKGgsZixtLGcsZSwxMixiWzFdKSxnPXAoZyxoLGYsbSxqLDE3LGJbMl0pLG09cChtLGcsaCxmLGssMjIsYlszXSksZj1wKGYsbSxnLGgseiw3LGJbNF0pLGg9cChoLGYsbSxnLHIsMTIsYls1XSksZz1wKGcsaCxmLG0sdCwxNyxiWzZdKSxtPXAobSxnLGgsZix3LDIyLGJbN10pLFxuXHQgICAgZj1wKGYsbSxnLGgsdiw3LGJbOF0pLGg9cChoLGYsbSxnLEEsMTIsYls5XSksZz1wKGcsaCxmLG0sQiwxNyxiWzEwXSksbT1wKG0sZyxoLGYsQywyMixiWzExXSksZj1wKGYsbSxnLGgsdSw3LGJbMTJdKSxoPXAoaCxmLG0sZyxELDEyLGJbMTNdKSxnPXAoZyxoLGYsbSxFLDE3LGJbMTRdKSxtPXAobSxnLGgsZix4LDIyLGJbMTVdKSxmPWQoZixtLGcsaCxlLDUsYlsxNl0pLGg9ZChoLGYsbSxnLHQsOSxiWzE3XSksZz1kKGcsaCxmLG0sQywxNCxiWzE4XSksbT1kKG0sZyxoLGYsYywyMCxiWzE5XSksZj1kKGYsbSxnLGgsciw1LGJbMjBdKSxoPWQoaCxmLG0sZyxCLDksYlsyMV0pLGc9ZChnLGgsZixtLHgsMTQsYlsyMl0pLG09ZChtLGcsaCxmLHosMjAsYlsyM10pLGY9ZChmLG0sZyxoLEEsNSxiWzI0XSksaD1kKGgsZixtLGcsRSw5LGJbMjVdKSxnPWQoZyxoLGYsbSxrLDE0LGJbMjZdKSxtPWQobSxnLGgsZix2LDIwLGJbMjddKSxmPWQoZixtLGcsaCxELDUsYlsyOF0pLGg9ZChoLGYsXG5cdCAgICAgIG0sZyxqLDksYlsyOV0pLGc9ZChnLGgsZixtLHcsMTQsYlszMF0pLG09ZChtLGcsaCxmLHUsMjAsYlszMV0pLGY9bChmLG0sZyxoLHIsNCxiWzMyXSksaD1sKGgsZixtLGcsdiwxMSxiWzMzXSksZz1sKGcsaCxmLG0sQywxNixiWzM0XSksbT1sKG0sZyxoLGYsRSwyMyxiWzM1XSksZj1sKGYsbSxnLGgsZSw0LGJbMzZdKSxoPWwoaCxmLG0sZyx6LDExLGJbMzddKSxnPWwoZyxoLGYsbSx3LDE2LGJbMzhdKSxtPWwobSxnLGgsZixCLDIzLGJbMzldKSxmPWwoZixtLGcsaCxELDQsYls0MF0pLGg9bChoLGYsbSxnLGMsMTEsYls0MV0pLGc9bChnLGgsZixtLGssMTYsYls0Ml0pLG09bChtLGcsaCxmLHQsMjMsYls0M10pLGY9bChmLG0sZyxoLEEsNCxiWzQ0XSksaD1sKGgsZixtLGcsdSwxMSxiWzQ1XSksZz1sKGcsaCxmLG0seCwxNixiWzQ2XSksbT1sKG0sZyxoLGYsaiwyMyxiWzQ3XSksZj1zKGYsbSxnLGgsYyw2LGJbNDhdKSxoPXMoaCxmLG0sZyx3LDEwLGJbNDldKSxnPXMoZyxoLGYsbSxcblx0ICAgICAgRSwxNSxiWzUwXSksbT1zKG0sZyxoLGYsciwyMSxiWzUxXSksZj1zKGYsbSxnLGgsdSw2LGJbNTJdKSxoPXMoaCxmLG0sZyxrLDEwLGJbNTNdKSxnPXMoZyxoLGYsbSxCLDE1LGJbNTRdKSxtPXMobSxnLGgsZixlLDIxLGJbNTVdKSxmPXMoZixtLGcsaCx2LDYsYls1Nl0pLGg9cyhoLGYsbSxnLHgsMTAsYls1N10pLGc9cyhnLGgsZixtLHQsMTUsYls1OF0pLG09cyhtLGcsaCxmLEQsMjEsYls1OV0pLGY9cyhmLG0sZyxoLHosNixiWzYwXSksaD1zKGgsZixtLGcsQywxMCxiWzYxXSksZz1zKGcsaCxmLG0saiwxNSxiWzYyXSksbT1zKG0sZyxoLGYsQSwyMSxiWzYzXSk7YVswXT1hWzBdK2Z8MDthWzFdPWFbMV0rbXwwO2FbMl09YVsyXStnfDA7YVszXT1hWzNdK2h8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLl9kYXRhLG49Yi53b3JkcyxhPTgqdGhpcy5fbkRhdGFCeXRlcyxjPTgqYi5zaWdCeXRlcztuW2M+Pj41XXw9MTI4PDwyNC1jJTMyO3ZhciBlPXUuZmxvb3IoYS9cblx0ICAgIDQyOTQ5NjcyOTYpO25bKGMrNjQ+Pj45PDw0KSsxNV09KGU8PDh8ZT4+PjI0KSYxNjcxMTkzNXwoZTw8MjR8ZT4+PjgpJjQyNzgyNTUzNjA7blsoYys2ND4+Pjk8PDQpKzE0XT0oYTw8OHxhPj4+MjQpJjE2NzExOTM1fChhPDwyNHxhPj4+OCkmNDI3ODI1NTM2MDtiLnNpZ0J5dGVzPTQqKG4ubGVuZ3RoKzEpO3RoaXMuX3Byb2Nlc3MoKTtiPXRoaXMuX2hhc2g7bj1iLndvcmRzO2ZvcihhPTA7ND5hO2ErKyljPW5bYV0sblthXT0oYzw8OHxjPj4+MjQpJjE2NzExOTM1fChjPDwyNHxjPj4+OCkmNDI3ODI1NTM2MDtyZXR1cm4gYn0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgYj12LmNsb25lLmNhbGwodGhpcyk7Yi5faGFzaD10aGlzLl9oYXNoLmNsb25lKCk7cmV0dXJuIGJ9fSk7dC5NRDU9di5fY3JlYXRlSGVscGVyKHIpO3QuSG1hY01ENT12Ll9jcmVhdGVIbWFjSGVscGVyKHIpfSkoTWF0aCk7XG5cdChmdW5jdGlvbigpe3ZhciB1PUNyeXB0b0pTLHA9dS5saWIsZD1wLkJhc2UsbD1wLldvcmRBcnJheSxwPXUuYWxnbyxzPXAuRXZwS0RGPWQuZXh0ZW5kKHtjZmc6ZC5leHRlbmQoe2tleVNpemU6NCxoYXNoZXI6cC5NRDUsaXRlcmF0aW9uczoxfSksaW5pdDpmdW5jdGlvbihkKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQoZCl9LGNvbXB1dGU6ZnVuY3Rpb24oZCxyKXtmb3IodmFyIHA9dGhpcy5jZmcscz1wLmhhc2hlci5jcmVhdGUoKSxiPWwuY3JlYXRlKCksdT1iLndvcmRzLHE9cC5rZXlTaXplLHA9cC5pdGVyYXRpb25zO3UubGVuZ3RoPHE7KXtuJiZzLnVwZGF0ZShuKTt2YXIgbj1zLnVwZGF0ZShkKS5maW5hbGl6ZShyKTtzLnJlc2V0KCk7Zm9yKHZhciBhPTE7YTxwO2ErKyluPXMuZmluYWxpemUobikscy5yZXNldCgpO2IuY29uY2F0KG4pfWIuc2lnQnl0ZXM9NCpxO3JldHVybiBifX0pO3UuRXZwS0RGPWZ1bmN0aW9uKGQsbCxwKXtyZXR1cm4gcy5jcmVhdGUocCkuY29tcHV0ZShkLFxuXHQgIGwpfX0pKCk7XG5cblx0Ly8gQ2lwaGVyXG5cdENyeXB0b0pTLmxpYi5DaXBoZXJ8fGZ1bmN0aW9uKHUpe3ZhciBwPUNyeXB0b0pTLGQ9cC5saWIsbD1kLkJhc2Uscz1kLldvcmRBcnJheSx0PWQuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSxyPXAuZW5jLkJhc2U2NCx3PXAuYWxnby5FdnBLREYsdj1kLkNpcGhlcj10LmV4dGVuZCh7Y2ZnOmwuZXh0ZW5kKCksY3JlYXRlRW5jcnlwdG9yOmZ1bmN0aW9uKGUsYSl7cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLGUsYSl9LGNyZWF0ZURlY3J5cHRvcjpmdW5jdGlvbihlLGEpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSxlLGEpfSxpbml0OmZ1bmN0aW9uKGUsYSxiKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQoYik7dGhpcy5feGZvcm1Nb2RlPWU7dGhpcy5fa2V5PWE7dGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe3QucmVzZXQuY2FsbCh0aGlzKTt0aGlzLl9kb1Jlc2V0KCl9LHByb2Nlc3M6ZnVuY3Rpb24oZSl7dGhpcy5fYXBwZW5kKGUpO3JldHVybiB0aGlzLl9wcm9jZXNzKCl9LFxuXHQgIGZpbmFsaXplOmZ1bmN0aW9uKGUpe2UmJnRoaXMuX2FwcGVuZChlKTtyZXR1cm4gdGhpcy5fZG9GaW5hbGl6ZSgpfSxrZXlTaXplOjQsaXZTaXplOjQsX0VOQ19YRk9STV9NT0RFOjEsX0RFQ19YRk9STV9NT0RFOjIsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbihlKXtyZXR1cm57ZW5jcnlwdDpmdW5jdGlvbihiLGssZCl7cmV0dXJuKFwic3RyaW5nXCI9PXR5cGVvZiBrP2M6YSkuZW5jcnlwdChlLGIsayxkKX0sZGVjcnlwdDpmdW5jdGlvbihiLGssZCl7cmV0dXJuKFwic3RyaW5nXCI9PXR5cGVvZiBrP2M6YSkuZGVjcnlwdChlLGIsayxkKX19fX0pO2QuU3RyZWFtQ2lwaGVyPXYuZXh0ZW5kKHtfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm9jZXNzKCEwKX0sYmxvY2tTaXplOjF9KTt2YXIgYj1wLm1vZGU9e30seD1mdW5jdGlvbihlLGEsYil7dmFyIGM9dGhpcy5faXY7Yz90aGlzLl9pdj11OmM9dGhpcy5fcHJldkJsb2NrO2Zvcih2YXIgZD0wO2Q8YjtkKyspZVthK2RdXj1cblx0ICBjW2RdfSxxPShkLkJsb2NrQ2lwaGVyTW9kZT1sLmV4dGVuZCh7Y3JlYXRlRW5jcnlwdG9yOmZ1bmN0aW9uKGUsYSl7cmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShlLGEpfSxjcmVhdGVEZWNyeXB0b3I6ZnVuY3Rpb24oZSxhKXtyZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGUsYSl9LGluaXQ6ZnVuY3Rpb24oZSxhKXt0aGlzLl9jaXBoZXI9ZTt0aGlzLl9pdj1hfX0pKS5leHRlbmQoKTtxLkVuY3J5cHRvcj1xLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsYSl7dmFyIGI9dGhpcy5fY2lwaGVyLGM9Yi5ibG9ja1NpemU7eC5jYWxsKHRoaXMsZSxhLGMpO2IuZW5jcnlwdEJsb2NrKGUsYSk7dGhpcy5fcHJldkJsb2NrPWUuc2xpY2UoYSxhK2MpfX0pO3EuRGVjcnlwdG9yPXEuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24oZSxhKXt2YXIgYj10aGlzLl9jaXBoZXIsYz1iLmJsb2NrU2l6ZSxkPWUuc2xpY2UoYSxhK2MpO2IuZGVjcnlwdEJsb2NrKGUsYSk7eC5jYWxsKHRoaXMsXG5cdCAgZSxhLGMpO3RoaXMuX3ByZXZCbG9jaz1kfX0pO2I9Yi5DQkM9cTtxPShwLnBhZD17fSkuUGtjczc9e3BhZDpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz00KmIsYz1jLWEuc2lnQnl0ZXMlYyxkPWM8PDI0fGM8PDE2fGM8PDh8YyxsPVtdLG49MDtuPGM7bis9NClsLnB1c2goZCk7Yz1zLmNyZWF0ZShsLGMpO2EuY29uY2F0KGMpfSx1bnBhZDpmdW5jdGlvbihhKXthLnNpZ0J5dGVzLT1hLndvcmRzW2Euc2lnQnl0ZXMtMT4+PjJdJjI1NX19O2QuQmxvY2tDaXBoZXI9di5leHRlbmQoe2NmZzp2LmNmZy5leHRlbmQoe21vZGU6YixwYWRkaW5nOnF9KSxyZXNldDpmdW5jdGlvbigpe3YucmVzZXQuY2FsbCh0aGlzKTt2YXIgYT10aGlzLmNmZyxiPWEuaXYsYT1hLm1vZGU7aWYodGhpcy5feGZvcm1Nb2RlPT10aGlzLl9FTkNfWEZPUk1fTU9ERSl2YXIgYz1hLmNyZWF0ZUVuY3J5cHRvcjtlbHNlIGM9YS5jcmVhdGVEZWNyeXB0b3IsdGhpcy5fbWluQnVmZmVyU2l6ZT0xO3RoaXMuX21vZGU9Yy5jYWxsKGEsXG5cdCAgdGhpcyxiJiZiLndvcmRzKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGEsYil7dGhpcy5fbW9kZS5wcm9jZXNzQmxvY2soYSxiKX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNmZy5wYWRkaW5nO2lmKHRoaXMuX3hmb3JtTW9kZT09dGhpcy5fRU5DX1hGT1JNX01PREUpe2EucGFkKHRoaXMuX2RhdGEsdGhpcy5ibG9ja1NpemUpO3ZhciBiPXRoaXMuX3Byb2Nlc3MoITApfWVsc2UgYj10aGlzLl9wcm9jZXNzKCEwKSxhLnVucGFkKGIpO3JldHVybiBifSxibG9ja1NpemU6NH0pO3ZhciBuPWQuQ2lwaGVyUGFyYW1zPWwuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGEpe3RoaXMubWl4SW4oYSl9LHRvU3RyaW5nOmZ1bmN0aW9uKGEpe3JldHVybihhfHx0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpfX0pLGI9KHAuZm9ybWF0PXt9KS5PcGVuU1NMPXtzdHJpbmdpZnk6ZnVuY3Rpb24oYSl7dmFyIGI9YS5jaXBoZXJ0ZXh0O2E9YS5zYWx0O3JldHVybihhP3MuY3JlYXRlKFsxMzk4ODkzNjg0LFxuXHQgIDE3MDEwNzY4MzFdKS5jb25jYXQoYSkuY29uY2F0KGIpOmIpLnRvU3RyaW5nKHIpfSxwYXJzZTpmdW5jdGlvbihhKXthPXIucGFyc2UoYSk7dmFyIGI9YS53b3JkcztpZigxMzk4ODkzNjg0PT1iWzBdJiYxNzAxMDc2ODMxPT1iWzFdKXt2YXIgYz1zLmNyZWF0ZShiLnNsaWNlKDIsNCkpO2Iuc3BsaWNlKDAsNCk7YS5zaWdCeXRlcy09MTZ9cmV0dXJuIG4uY3JlYXRlKHtjaXBoZXJ0ZXh0OmEsc2FsdDpjfSl9fSxhPWQuU2VyaWFsaXphYmxlQ2lwaGVyPWwuZXh0ZW5kKHtjZmc6bC5leHRlbmQoe2Zvcm1hdDpifSksZW5jcnlwdDpmdW5jdGlvbihhLGIsYyxkKXtkPXRoaXMuY2ZnLmV4dGVuZChkKTt2YXIgbD1hLmNyZWF0ZUVuY3J5cHRvcihjLGQpO2I9bC5maW5hbGl6ZShiKTtsPWwuY2ZnO3JldHVybiBuLmNyZWF0ZSh7Y2lwaGVydGV4dDpiLGtleTpjLGl2OmwuaXYsYWxnb3JpdGhtOmEsbW9kZTpsLm1vZGUscGFkZGluZzpsLnBhZGRpbmcsYmxvY2tTaXplOmEuYmxvY2tTaXplLGZvcm1hdHRlcjpkLmZvcm1hdH0pfSxcblx0ICBkZWNyeXB0OmZ1bmN0aW9uKGEsYixjLGQpe2Q9dGhpcy5jZmcuZXh0ZW5kKGQpO2I9dGhpcy5fcGFyc2UoYixkLmZvcm1hdCk7cmV0dXJuIGEuY3JlYXRlRGVjcnlwdG9yKGMsZCkuZmluYWxpemUoYi5jaXBoZXJ0ZXh0KX0sX3BhcnNlOmZ1bmN0aW9uKGEsYil7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGE/Yi5wYXJzZShhLHRoaXMpOmF9fSkscD0ocC5rZGY9e30pLk9wZW5TU0w9e2V4ZWN1dGU6ZnVuY3Rpb24oYSxiLGMsZCl7ZHx8KGQ9cy5yYW5kb20oOCkpO2E9dy5jcmVhdGUoe2tleVNpemU6YitjfSkuY29tcHV0ZShhLGQpO2M9cy5jcmVhdGUoYS53b3Jkcy5zbGljZShiKSw0KmMpO2Euc2lnQnl0ZXM9NCpiO3JldHVybiBuLmNyZWF0ZSh7a2V5OmEsaXY6YyxzYWx0OmR9KX19LGM9ZC5QYXNzd29yZEJhc2VkQ2lwaGVyPWEuZXh0ZW5kKHtjZmc6YS5jZmcuZXh0ZW5kKHtrZGY6cH0pLGVuY3J5cHQ6ZnVuY3Rpb24oYixjLGQsbCl7bD10aGlzLmNmZy5leHRlbmQobCk7ZD1sLmtkZi5leGVjdXRlKGQsXG5cdCAgYi5rZXlTaXplLGIuaXZTaXplKTtsLml2PWQuaXY7Yj1hLmVuY3J5cHQuY2FsbCh0aGlzLGIsYyxkLmtleSxsKTtiLm1peEluKGQpO3JldHVybiBifSxkZWNyeXB0OmZ1bmN0aW9uKGIsYyxkLGwpe2w9dGhpcy5jZmcuZXh0ZW5kKGwpO2M9dGhpcy5fcGFyc2UoYyxsLmZvcm1hdCk7ZD1sLmtkZi5leGVjdXRlKGQsYi5rZXlTaXplLGIuaXZTaXplLGMuc2FsdCk7bC5pdj1kLml2O3JldHVybiBhLmRlY3J5cHQuY2FsbCh0aGlzLGIsYyxkLmtleSxsKX19KX0oKTtcblxuXHQvLyBBRVNcblx0KGZ1bmN0aW9uKCl7Zm9yKHZhciB1PUNyeXB0b0pTLHA9dS5saWIuQmxvY2tDaXBoZXIsZD11LmFsZ28sbD1bXSxzPVtdLHQ9W10scj1bXSx3PVtdLHY9W10sYj1bXSx4PVtdLHE9W10sbj1bXSxhPVtdLGM9MDsyNTY+YztjKyspYVtjXT0xMjg+Yz9jPDwxOmM8PDFeMjgzO2Zvcih2YXIgZT0wLGo9MCxjPTA7MjU2PmM7YysrKXt2YXIgaz1qXmo8PDFeajw8Ml5qPDwzXmo8PDQsaz1rPj4+OF5rJjI1NV45OTtsW2VdPWs7c1trXT1lO3ZhciB6PWFbZV0sRj1hW3pdLEc9YVtGXSx5PTI1NyphW2tdXjE2ODQzMDA4Kms7dFtlXT15PDwyNHx5Pj4+ODtyW2VdPXk8PDE2fHk+Pj4xNjt3W2VdPXk8PDh8eT4+PjI0O3ZbZV09eTt5PTE2ODQzMDA5KkdeNjU1MzcqRl4yNTcqel4xNjg0MzAwOCplO2Jba109eTw8MjR8eT4+Pjg7eFtrXT15PDwxNnx5Pj4+MTY7cVtrXT15PDw4fHk+Pj4yNDtuW2tdPXk7ZT8oZT16XmFbYVthW0deel1dXSxqXj1hW2Fbal1dKTplPWo9MX12YXIgSD1bMCwxLDIsNCw4LFxuXHQgIDE2LDMyLDY0LDEyOCwyNyw1NF0sZD1kLkFFUz1wLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5fa2V5LGM9YS53b3JkcyxkPWEuc2lnQnl0ZXMvNCxhPTQqKCh0aGlzLl9uUm91bmRzPWQrNikrMSksZT10aGlzLl9rZXlTY2hlZHVsZT1bXSxqPTA7ajxhO2orKylpZihqPGQpZVtqXT1jW2pdO2Vsc2V7dmFyIGs9ZVtqLTFdO2olZD82PGQmJjQ9PWolZCYmKGs9bFtrPj4+MjRdPDwyNHxsW2s+Pj4xNiYyNTVdPDwxNnxsW2s+Pj44JjI1NV08PDh8bFtrJjI1NV0pOihrPWs8PDh8az4+PjI0LGs9bFtrPj4+MjRdPDwyNHxsW2s+Pj4xNiYyNTVdPDwxNnxsW2s+Pj44JjI1NV08PDh8bFtrJjI1NV0sa149SFtqL2R8MF08PDI0KTtlW2pdPWVbai1kXV5rfWM9dGhpcy5faW52S2V5U2NoZWR1bGU9W107Zm9yKGQ9MDtkPGE7ZCsrKWo9YS1kLGs9ZCU0P2Vbal06ZVtqLTRdLGNbZF09ND5kfHw0Pj1qP2s6YltsW2s+Pj4yNF1dXnhbbFtrPj4+MTYmMjU1XV1ecVtsW2s+Pj5cblx0OCYyNTVdXV5uW2xbayYyNTVdXX0sZW5jcnlwdEJsb2NrOmZ1bmN0aW9uKGEsYil7dGhpcy5fZG9DcnlwdEJsb2NrKGEsYix0aGlzLl9rZXlTY2hlZHVsZSx0LHIsdyx2LGwpfSxkZWNyeXB0QmxvY2s6ZnVuY3Rpb24oYSxjKXt2YXIgZD1hW2MrMV07YVtjKzFdPWFbYyszXTthW2MrM109ZDt0aGlzLl9kb0NyeXB0QmxvY2soYSxjLHRoaXMuX2ludktleVNjaGVkdWxlLGIseCxxLG4scyk7ZD1hW2MrMV07YVtjKzFdPWFbYyszXTthW2MrM109ZH0sX2RvQ3J5cHRCbG9jazpmdW5jdGlvbihhLGIsYyxkLGUsaixsLGYpe2Zvcih2YXIgbT10aGlzLl9uUm91bmRzLGc9YVtiXV5jWzBdLGg9YVtiKzFdXmNbMV0saz1hW2IrMl1eY1syXSxuPWFbYiszXV5jWzNdLHA9NCxyPTE7cjxtO3IrKyl2YXIgcT1kW2c+Pj4yNF1eZVtoPj4+MTYmMjU1XV5qW2s+Pj44JjI1NV1ebFtuJjI1NV1eY1twKytdLHM9ZFtoPj4+MjRdXmVbaz4+PjE2JjI1NV1ealtuPj4+OCYyNTVdXmxbZyYyNTVdXmNbcCsrXSx0PVxuXHQgIGRbaz4+PjI0XV5lW24+Pj4xNiYyNTVdXmpbZz4+PjgmMjU1XV5sW2gmMjU1XV5jW3ArK10sbj1kW24+Pj4yNF1eZVtnPj4+MTYmMjU1XV5qW2g+Pj44JjI1NV1ebFtrJjI1NV1eY1twKytdLGc9cSxoPXMsaz10O3E9KGZbZz4+PjI0XTw8MjR8ZltoPj4+MTYmMjU1XTw8MTZ8ZltrPj4+OCYyNTVdPDw4fGZbbiYyNTVdKV5jW3ArK107cz0oZltoPj4+MjRdPDwyNHxmW2s+Pj4xNiYyNTVdPDwxNnxmW24+Pj44JjI1NV08PDh8ZltnJjI1NV0pXmNbcCsrXTt0PShmW2s+Pj4yNF08PDI0fGZbbj4+PjE2JjI1NV08PDE2fGZbZz4+PjgmMjU1XTw8OHxmW2gmMjU1XSleY1twKytdO249KGZbbj4+PjI0XTw8MjR8ZltnPj4+MTYmMjU1XTw8MTZ8ZltoPj4+OCYyNTVdPDw4fGZbayYyNTVdKV5jW3ArK107YVtiXT1xO2FbYisxXT1zO2FbYisyXT10O2FbYiszXT1ufSxrZXlTaXplOjh9KTt1LkFFUz1wLl9jcmVhdGVIZWxwZXIoZCl9KSgpO1xuXG5cdC8vIE1vZGUgRUNCXG5cdENyeXB0b0pTLm1vZGUuRUNCID0gKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgRUNCID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgIEVDQi5FbmNyeXB0b3IgPSBFQ0IuZXh0ZW5kKHtcblx0ICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgIH1cblx0ICB9KTtcblxuXHQgIEVDQi5EZWNyeXB0b3IgPSBFQ0IuZXh0ZW5kKHtcblx0ICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgdGhpcy5fY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgIH1cblx0ICB9KTtcblxuXHQgIHJldHVybiBFQ0I7XG5cdH0oKSk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBDcnlwdG9KUztcblxuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vIFdFQlNPQ0tFVCBJTlRFUkZBQ0Vcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdHZhciBXUyA9IGZ1bmN0aW9uKCB1cmwsIHByb3RvY29scyApIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV1MpKSByZXR1cm4gbmV3IFdTKCB1cmwsIHByb3RvY29scyApO1xuXG5cdCAgdmFyIHNlbGYgICAgID0gdGhpc1xuXHQgICAgLCAgIHVybCAgICAgID0gc2VsZi51cmwgICAgICA9IHVybCB8fCAnJ1xuXHQgICAgLCAgIHByb3RvY29sID0gc2VsZi5wcm90b2NvbCA9IHByb3RvY29scyB8fCAnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCdcblx0ICAgICwgICBiaXRzICAgICA9IHVybC5zcGxpdCgnLycpXG5cdCAgICAsICAgc2V0dXAgICAgPSB7XG5cdCAgICAnc3NsJyAgICAgICAgICAgOiBiaXRzWzBdID09PSAnd3NzOidcblx0ICAgICwnb3JpZ2luJyAgICAgICAgOiBiaXRzWzJdXG5cdCAgICAsJ3B1Ymxpc2hfa2V5JyAgIDogYml0c1szXVxuXHQgICAgLCdzdWJzY3JpYmVfa2V5JyA6IGJpdHNbNF1cblx0ICAgICwnY2hhbm5lbCcgICAgICAgOiBiaXRzWzVdXG5cdCAgfTtcblxuXHQgIC8vIFJFQURZIFNUQVRFU1xuXHQgIHNlbGZbJ0NPTk5FQ1RJTkcnXSA9IDA7IC8vIFRoZSBjb25uZWN0aW9uIGlzIG5vdCB5ZXQgb3Blbi5cblx0ICBzZWxmWydPUEVOJ10gICAgICAgPSAxOyAvLyBUaGUgY29ubmVjdGlvbiBpcyBvcGVuIGFuZCByZWFkeSB0byBjb21tdW5pY2F0ZS5cblx0ICBzZWxmWydDTE9TSU5HJ10gICAgPSAyOyAvLyBUaGUgY29ubmVjdGlvbiBpcyBpbiB0aGUgcHJvY2VzcyBvZiBjbG9zaW5nLlxuXHQgIHNlbGZbJ0NMT1NFRCddICAgICA9IDM7IC8vIFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCBvciBjb3VsZG4ndCBiZSBvcGVuZWQuXG5cblx0ICAvLyBDTE9TRSBTVEFURVNcblx0ICBzZWxmWydDTE9TRV9OT1JNQUwnXSAgICAgICAgID0gMTAwMDsgLy8gTm9ybWFsIEludGVuZGVkIENsb3NlOyBjb21wbGV0ZWQuXG5cdCAgc2VsZlsnQ0xPU0VfR09JTkdfQVdBWSddICAgICA9IDEwMDE7IC8vIENsb3NlZCBVbmV4cGVjdHRlZGx5LlxuXHQgIHNlbGZbJ0NMT1NFX1BST1RPQ09MX0VSUk9SJ10gPSAxMDAyOyAvLyBTZXJ2ZXI6IE5vdCBTdXBwb3J0ZWQuXG5cdCAgc2VsZlsnQ0xPU0VfVU5TVVBQT1JURUQnXSAgICA9IDEwMDM7IC8vIFNlcnZlcjogVW5zdXBwb3J0ZWQgUHJvdG9jb2wuXG5cdCAgc2VsZlsnQ0xPU0VfVE9PX0xBUkdFJ10gICAgICA9IDEwMDQ7IC8vIFNlcnZlcjogVG9vIE11Y2ggRGF0YS5cblx0ICBzZWxmWydDTE9TRV9OT19TVEFUVVMnXSAgICAgID0gMTAwNTsgLy8gU2VydmVyOiBObyByZWFzb24uXG5cdCAgc2VsZlsnQ0xPU0VfQUJOT1JNQUwnXSAgICAgICA9IDEwMDY7IC8vIEFibm9ybWFsIERpc2Nvbm5lY3QuXG5cblx0ICAvLyBFdmVudHMgRGVmYXVsdFxuXHQgIHNlbGZbJ29uY2xvc2UnXSAgID0gc2VsZlsnb25lcnJvciddID1cblx0ICAgIHNlbGZbJ29ubWVzc2FnZSddID0gc2VsZlsnb25vcGVuJ10gID1cblx0ICAgICAgc2VsZlsnb25zZW5kJ10gICAgPSAgZnVuY3Rpb24oKXt9O1xuXG5cdCAgLy8gQXR0cmlidXRlc1xuXHQgIHNlbGZbJ2JpbmFyeVR5cGUnXSAgICAgPSAnJztcblx0ICBzZWxmWydleHRlbnNpb25zJ10gICAgID0gJyc7XG5cdCAgc2VsZlsnYnVmZmVyZWRBbW91bnQnXSA9IDA7XG5cdCAgc2VsZlsndHJhc25taXR0aW5nJ10gICA9IGZhbHNlO1xuXHQgIHNlbGZbJ2J1ZmZlciddICAgICAgICAgPSBbXTtcblx0ICBzZWxmWydyZWFkeVN0YXRlJ10gICAgID0gc2VsZlsnQ09OTkVDVElORyddO1xuXG5cdCAgLy8gQ2xvc2UgaWYgbm8gc2V0dXAuXG5cdCAgaWYgKCF1cmwpIHtcblx0ICAgIHNlbGZbJ3JlYWR5U3RhdGUnXSA9IHNlbGZbJ0NMT1NFRCddO1xuXHQgICAgc2VsZlsnb25jbG9zZSddKHtcblx0ICAgICAgJ2NvZGUnICAgICA6IHNlbGZbJ0NMT1NFX0FCTk9STUFMJ10sXG5cdCAgICAgICdyZWFzb24nICAgOiAnTWlzc2luZyBVUkwnLFxuXHQgICAgICAnd2FzQ2xlYW4nIDogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gc2VsZjtcblx0ICB9XG5cblx0ICAvLyBQdWJOdWIgV2ViU29ja2V0IEVtdWxhdGlvblxuXHQgIHNlbGYucHVibnViICAgICAgID0gUFVCTlVCWydpbml0J10oc2V0dXApO1xuXHQgIHNlbGYucHVibnViLnNldHVwID0gc2V0dXA7XG5cdCAgc2VsZi5zZXR1cCAgICAgICAgPSBzZXR1cDtcblxuXHQgIHNlbGYucHVibnViWydzdWJzY3JpYmUnXSh7XG5cdCAgICAncmVzdG9yZScgICAgOiBmYWxzZSxcblx0ICAgICdjaGFubmVsJyAgICA6IHNldHVwWydjaGFubmVsJ10sXG5cdCAgICAnZGlzY29ubmVjdCcgOiBzZWxmWydvbmVycm9yJ10sXG5cdCAgICAncmVjb25uZWN0JyAgOiBzZWxmWydvbm9wZW4nXSxcblx0ICAgICdlcnJvcicgICAgICA6IGZ1bmN0aW9uKCkge1xuXHQgICAgICBzZWxmWydvbmNsb3NlJ10oe1xuXHQgICAgICAgICdjb2RlJyAgICAgOiBzZWxmWydDTE9TRV9BQk5PUk1BTCddLFxuXHQgICAgICAgICdyZWFzb24nICAgOiAnTWlzc2luZyBVUkwnLFxuXHQgICAgICAgICd3YXNDbGVhbicgOiBmYWxzZVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICAnY2FsbGJhY2snICAgOiBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdCAgICAgIHNlbGZbJ29ubWVzc2FnZSddKHsgJ2RhdGEnIDogbWVzc2FnZSB9KTtcblx0ICAgIH0sXG5cdCAgICAnY29ubmVjdCcgICAgOiBmdW5jdGlvbigpIHtcblx0ICAgICAgc2VsZlsncmVhZHlTdGF0ZSddID0gc2VsZlsnT1BFTiddO1xuXHQgICAgICBzZWxmWydvbm9wZW4nXSgpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHR9O1xuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBXRUJTT0NLRVQgU0VORFxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0V1MucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHNlbGYucHVibnViWydwdWJsaXNoJ10oe1xuXHQgICAgJ2NoYW5uZWwnICA6IHNlbGYucHVibnViLnNldHVwWydjaGFubmVsJ10sXG5cdCAgICAnbWVzc2FnZScgIDogZGF0YSxcblx0ICAgICdjYWxsYmFjaycgOiBmdW5jdGlvbihyZXNwb25zZSkge1xuXHQgICAgICBzZWxmWydvbnNlbmQnXSh7ICdkYXRhJyA6IHJlc3BvbnNlIH0pO1xuXHQgICAgfVxuXHQgIH0pO1xuXHR9O1xuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBXRUJTT0NLRVQgQ0xPU0Vcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFdTLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBzZWxmLnB1Ym51YlsndW5zdWJzY3JpYmUnXSh7ICdjaGFubmVsJyA6IHNlbGYucHVibnViLnNldHVwWydjaGFubmVsJ10gfSk7XG5cdCAgc2VsZlsncmVhZHlTdGF0ZSddID0gc2VsZlsnQ0xPU0VEJ107XG5cdCAgc2VsZlsnb25jbG9zZSddKHt9KTtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9wdWJudWIvbW9kZXJuL2Rpc3QvcHVibnViLmpzXG4gKiogbW9kdWxlIGlkID0gMTMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJDbGllbnRcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUmluZ0NlbnRyYWxcIl0gPSByb290W1wiUmluZ0NlbnRyYWxcIl0gfHwge30sIHJvb3RbXCJSaW5nQ2VudHJhbFwiXVtcIkNsaWVudFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIGFjY291bnRDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIGNhbGxMb2dDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcbnZhciBkaWN0aW9uYXJ5Q2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG52YXIgZXh0ZW5zaW9uQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG52YXIgbWVzc2FnZXNDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KTtcbnZhciBub3RpZmljYXRpb25zQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XG52YXIgcHJlc2VuY2VDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KTtcbnZhciByaW5nb3V0Q2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Myk7XG52YXIgZm9yd2FyZGluZ051bWJlcnNDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KTtcbnZhciBibG9ja2VkTnVtYmVyc0NsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOTkpO1xudmFyIENsaWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xpZW50KHNkaykge1xuICAgICAgICB0aGlzLl9zZGsgPSBzZGs7XG4gICAgICAgIHRoaXMuX2FjY291bnQgPSBuZXcgYWNjb3VudENsaWVudC5BY2NvdW50KHNkayk7XG4gICAgICAgIHRoaXMuX2NhbGxMb2cgPSBuZXcgY2FsbExvZ0NsaWVudC5DYWxsTG9nKHNkayk7XG4gICAgICAgIHRoaXMuX2RpY3Rpb25hcnkgPSBuZXcgZGljdGlvbmFyeUNsaWVudC5EaWN0aW9uYXJ5KHNkayk7XG4gICAgICAgIHRoaXMuX2V4dGVuc2lvbiA9IG5ldyBleHRlbnNpb25DbGllbnQuRXh0ZW5zaW9uKHNkayk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzID0gbmV3IG1lc3NhZ2VzQ2xpZW50Lk1lc3NhZ2VzKHNkayk7XG4gICAgICAgIHRoaXMuX25vdGlmaWNhdGlvbnMgPSBuZXcgbm90aWZpY2F0aW9uc0NsaWVudC5Ob3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJKHNkayk7XG4gICAgICAgIHRoaXMuX3ByZXNlbmNlID0gbmV3IHByZXNlbmNlQ2xpZW50LlByZXNlbmNlKHNkayk7XG4gICAgICAgIHRoaXMuX3JpbmdvdXQgPSBuZXcgcmluZ291dENsaWVudC5SaW5nT3V0KHNkayk7XG4gICAgICAgIHRoaXMuX2ZvcndhcmRpbmdOdW1iZXJzID0gbmV3IGZvcndhcmRpbmdOdW1iZXJzQ2xpZW50LkZvcndhcmRpbmdOdW1iZXJzKHNkayk7XG4gICAgICAgIHRoaXMuX2Jsb2NrZWROdW1iZXJzID0gbmV3IGJsb2NrZWROdW1iZXJzQ2xpZW50LkJsb2NrZWROdW1iZXJzKHNkayk7XG4gICAgfVxuICAgIENsaWVudC5wcm90b3R5cGUuYWNjb3VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FjY291bnQ7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5jYWxsTG9nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2FsbExvZzsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmRpY3Rpb25hcnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaWN0aW9uYXJ5OyB9O1xuICAgIENsaWVudC5wcm90b3R5cGUuZXh0ZW5zaW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZXh0ZW5zaW9uOyB9O1xuICAgIENsaWVudC5wcm90b3R5cGUubWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tZXNzYWdlczsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLm5vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ub3RpZmljYXRpb25zOyB9O1xuICAgIENsaWVudC5wcm90b3R5cGUucHJlc2VuY2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcmVzZW5jZTsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLnJpbmdvdXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yaW5nb3V0OyB9O1xuICAgIENsaWVudC5wcm90b3R5cGUuZm9yd2FyZGluZ051bWJlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9mb3J3YXJkaW5nTnVtYmVyczsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmJsb2NrZWROdW1iZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYmxvY2tlZE51bWJlcnM7IH07XG4gICAgQ2xpZW50LnZlcnNpb24gPSAnMC4xLjAnO1xuICAgIHJldHVybiBDbGllbnQ7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBDbGllbnQ7XG5cblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGFjY291bnRpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBhY2NvdW50YnVzaW5lc3NhZGRyZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG52YXIgZGlhbGluZ3BsYW5pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG52YXIgcGhvbmVudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgYWNjb3VudHBob25lbnVtYmVycyA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xudmFyIGFjY291bnRzZXJ2aWNlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xudmFyIEFjY291bnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnQoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgQWNjb3VudFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEwIChSZWxlYXNlIDYuMik8L3A+XG4gICAgICogPHA+Q3JlYXRlcyB0aGUgYWNjb3VudCBpbiBJbml0aWFsIHN0YXRlLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+QWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5NYW5hZ2luZyBhY2NvdW50czogY3JlYXRpbmcgbmV3IGFjY291bnRzLCB2aWV3aW5nIGFuZCB1cGRhdGluZyBhY2NvdW50IGluZm9ybWF0aW9uLCBkZWxldGluZyBleGlzdGluZyBhY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyLCBhc3NpZ25lZCBwaG9uZSBudW1iZXJzLCBkZXZpY2VzIGFuZCBvdGhlciBleHRlbnNpb24gc2V0dGluZ3MpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUuY3JlYXRlQWNjb3VudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50Jywgb3B0aW9ucywgZXhwb3J0cy5jcmVhdGVBY2NvdW50T3B0aW9ucyksIGFjY291bnRpbmZvLkFjY291bnRJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBBY2NvdW50IEluZm9cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4wPC9wPlxuICAgICAqIDxwPlJldHVybnMgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgYSBwYXJ0aWN1bGFyIFJpbmdDZW50cmFsIGN1c3RvbWVyIGFjY291bnQuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUubG9hZEFjY291bnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQWNjb3VudE9wdGlvbnMpLCBhY2NvdW50aW5mby5BY2NvdW50SW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWNjb3VudCBCdXNpbmVzcyBBZGRyZXNzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUubG9hZEFjY291bnRCdXNpbmVzc0FkZHJlc3MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2J1c2luZXNzLWFkZHJlc3MnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRBY2NvdW50QnVzaW5lc3NBZGRyZXNzT3B0aW9ucyksIGFjY291bnRpbmZvLkFjY291bnRJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBBY2NvdW50IEJ1c2luZXNzIEFkZHJlc3NcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS51cGRhdGVBY2NvdW50QnVzaW5lc3NBZGRyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUFVUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9idXNpbmVzcy1hZGRyZXNzJywgb3B0aW9ucywgZXhwb3J0cy51cGRhdGVBY2NvdW50QnVzaW5lc3NBZGRyZXNzT3B0aW9ucyksIGFjY291bnRidXNpbmVzc2FkZHJlc3MuQWNjb3VudEJ1c2luZXNzQWRkcmVzcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWNjb3VudCBEaWFsaW5nIFBsYW5cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGxpc3Qgb2YgY291bnRyaWVzIHdoaWNoIGNhbiBiZSBzZWxlY3RlZCBmb3IgYSBkaWFsaW5nIHBsYW4gKHRvIGNhbGwgc2hvcnQgbnVtYmVycyBhbmQgc3BlY2lhbCBzZXJ2aWNlcykuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUubGlzdERpYWxpbmdQbGFucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZGlhbGluZy1wbGFuJywgb3B0aW9ucywgZXhwb3J0cy5saXN0RGlhbGluZ1BsYW5zT3B0aW9ucyksIGRpYWxpbmdwbGFuaW5mby5EaWFsaW5nUGxhbkluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvdmlzaW9uIFBob25lIE51bWJlcnNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMSAoUmVsZWFzZSA2LjMpPC9wPlxuICAgICAqIDxwPlByb3Zpc2lvbnMgYSBwaG9uZSBudW1iZXIuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0QWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUucHJvdmlzaW9uUGhvbmVOdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9waG9uZS1udW1iZXInLCBvcHRpb25zLCBleHBvcnRzLnByb3Zpc2lvblBob25lTnVtYmVyT3B0aW9ucyksIHBob25lbnVtYmVyaW5mby5QaG9uZU51bWJlckluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgUGhvbmUgTnVtYmVyc1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBwaG9uZSBudW1iZXJzIGFzc2lnbmVkIHRvIHRoZSBSaW5nQ2VudHJhbCBjdXN0b21lciBhY2NvdW50LiBCb3RoIGNvbXBhbnktbGV2ZWwgYW5kIGV4dGVuc2lvbi1sZXZlbCBudW1iZXJzIGFyZSByZXR1cm5lZC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS5saXN0QWNjb3VudFBob25lTnVtYmVycyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vcGhvbmUtbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5saXN0QWNjb3VudFBob25lTnVtYmVyc09wdGlvbnMpLCBhY2NvdW50cGhvbmVudW1iZXJzLkFjY291bnRQaG9uZU51bWJlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFBob25lIE51bWJlcihzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxvYWRBY2NvdW50UGhvbmVOdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L3Bob25lLW51bWJlci97cGhvbmVOdW1iZXJJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRBY2NvdW50UGhvbmVOdW1iZXJPcHRpb25zKSwgcGhvbmVudW1iZXJpbmZvLlBob25lTnVtYmVySW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWNjb3VudCBTZXJ2aWNlIEluZm9cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4wPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGluZm9ybWF0aW9uIGFib3V0IHNlcnZpY2UgcGxhbiwgYXZhaWxhYmxlIGZlYXR1cmVzIGFuZCBsaW1pdGF0aW9ucyBmb3IgYSBwYXJ0aWN1bGFyIFJpbmdDZW50cmFsIGN1c3RvbWVyIGFjY291bnQuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUubG9hZFNlcnZpY2VJbmZvID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9zZXJ2aWNlLWluZm8nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRTZXJ2aWNlSW5mb09wdGlvbnMpLCBhY2NvdW50c2VydmljZWluZm8uQWNjb3VudFNlcnZpY2VJbmZvKTtcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50O1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLkFjY291bnQgPSBBY2NvdW50O1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGNyZWF0ZUFjY291bnQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuY3JlYXRlQWNjb3VudE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiY3JlYXRlYWNjb3VudHJlcXVlc3QuQ3JlYXRlQWNjb3VudFJlcXVlc3RcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEFjY291bnQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEFjY291bnRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEFjY291bnRCdXNpbmVzc0FkZHJlc3Mgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEFjY291bnRCdXNpbmVzc0FkZHJlc3NPcHRpb25zID0gW107XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgdXBkYXRlQWNjb3VudEJ1c2luZXNzQWRkcmVzcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy51cGRhdGVBY2NvdW50QnVzaW5lc3NBZGRyZXNzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJtb2RpZnlhY2NvdW50YnVzaW5lc3NhZGRyZXNzcmVxdWVzdC5Nb2RpZnlBY2NvdW50QnVzaW5lc3NBZGRyZXNzUmVxdWVzdFwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0RGlhbGluZ1BsYW5zIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3REaWFsaW5nUGxhbnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgcHJvdmlzaW9uUGhvbmVOdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMucHJvdmlzaW9uUGhvbmVOdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwicHJvdmlzaW9ucGhvbmVudW1iZXJzLlByb3Zpc2lvblBob25lTnVtYmVyc1wiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0QWNjb3VudFBob25lTnVtYmVycyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0QWNjb3VudFBob25lTnVtYmVyc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInVzYWdlVHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJNYWluQ29tcGFueU51bWJlclwiLFxuICAgICAgICAgICAgXCJBZGRpdGlvbmFsQ29tcGFueU51bWJlclwiLFxuICAgICAgICAgICAgXCJDb21wYW55TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkRpcmVjdE51bWJlclwiLFxuICAgICAgICAgICAgXCJDb21wYW55RmF4TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkZvcndhcmRlZE51bWJlclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkQWNjb3VudFBob25lTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRBY2NvdW50UGhvbmVOdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwaG9uZU51bWJlcklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRTZXJ2aWNlSW5mbyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkU2VydmljZUluZm9PcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4oZnVuY3Rpb24gKElMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZSkge1xuICAgIElMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJNYWluQ29tcGFueU51bWJlclwiXSA9ICdNYWluQ29tcGFueU51bWJlciddID0gXCJNYWluQ29tcGFueU51bWJlclwiO1xuICAgIElMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJBZGRpdGlvbmFsQ29tcGFueU51bWJlclwiXSA9ICdBZGRpdGlvbmFsQ29tcGFueU51bWJlciddID0gXCJBZGRpdGlvbmFsQ29tcGFueU51bWJlclwiO1xuICAgIElMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJDb21wYW55TnVtYmVyXCJdID0gJ0NvbXBhbnlOdW1iZXInXSA9IFwiQ29tcGFueU51bWJlclwiO1xuICAgIElMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJEaXJlY3ROdW1iZXJcIl0gPSAnRGlyZWN0TnVtYmVyJ10gPSBcIkRpcmVjdE51bWJlclwiO1xuICAgIElMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJDb21wYW55RmF4TnVtYmVyXCJdID0gJ0NvbXBhbnlGYXhOdW1iZXInXSA9IFwiQ29tcGFueUZheE51bWJlclwiO1xuICAgIElMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJGb3J3YXJkZWROdW1iZXJcIl0gPSAnRm9yd2FyZGVkTnVtYmVyJ10gPSBcIkZvcndhcmRlZE51bWJlclwiO1xufSkoZXhwb3J0cy5JTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGUgfHwgKGV4cG9ydHMuSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlID0ge30pKTtcbnZhciBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGUgPSBleHBvcnRzLklMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZTtcblxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBDbGllbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsaWVudChzZGspIHtcbiAgICAgICAgdGhpcy5fc2RrID0gc2RrO1xuICAgIH1cbiAgICBDbGllbnQucHJvdG90eXBlLnBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgb3B0aW9ucywgb3BlcmF0aW9uUGFyYW1ldGVycykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcXVlcnk6IHt9LFxuICAgICAgICAgICAgYm9keTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIGlmIChwYXJhbS5yZXF1aXJlZCAmJiAhcGFyYW0uZGVmYXVsdCAmJiAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwYXJhbS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgcGFyYW1ldGVyIFwiJyArIHBhcmFtLm5hbWUgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0uZGVmYXVsdCAmJiAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwYXJhbS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbcGFyYW0ubmFtZV0gPSBwYXJhbS5kZWZhdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLmluID09ICdwYXRoJykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QudXJsID0gcmVxdWVzdC51cmwucmVwbGFjZSgneycgKyBwYXJhbS5uYW1lICsgJ30nLCBvcHRpb25zW3BhcmFtLm5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS5pbiA9PSAncXVlcnknICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkocGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnF1ZXJ5W3BhcmFtLm5hbWVdID0gb3B0aW9uc1twYXJhbS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS5pbiA9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJvZHkgPSBvcHRpb25zW3BhcmFtLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoYXBpT3B0aW9ucywgQ2xhc3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nkay5wbGF0Zm9ybSgpXG4gICAgICAgICAgICAuc2VuZChhcGlPcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgLy9UT0RPIFN1cHBvcnQgbXVsdGlwYXJ0XG4gICAgICAgICAgICAvL1RPRE8gVGhpbmsgaG93IHRvIHBhc3MgaGVhZGVycyZzdHVmZiB0byBvdXRzaWRlXG4gICAgICAgICAgICBpZiAoQ2xhc3MgJiYgIXJlcy5faXNNdWx0aXBhcnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENsYXNzKF90aGlzLl9zZGssIHJlcy5qc29uKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50O1xufSgpKTtcbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuXG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGV4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIHNlcnZpY2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG52YXIgYWNjb3VudHN0YXR1c2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcbnZhciBBY2NvdW50SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudEluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbWFpbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnb3BlcmF0b3InLCBDbGFzczogZXh0ZW5zaW9uaW5mby5FeHRlbnNpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYXJ0bmVySWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3NlcnZpY2VJbmZvJywgQ2xhc3M6IHNlcnZpY2VpbmZvLlNlcnZpY2VJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXR1cFdpemFyZFN0YXRlJywgQ2xhc3M6IEFjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdHVzJywgQ2xhc3M6IEFjY291bnRJbmZvU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXNJbmZvJywgQ2xhc3M6IGFjY291bnRzdGF0dXNpbmZvLkFjY291bnRTdGF0dXNJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudEluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRJbmZvID0gQWNjb3VudEluZm87XG4oZnVuY3Rpb24gKEFjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZSkge1xuICAgIEFjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZVtBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbXCJOb3RTdGFydGVkXCJdID0gJ05vdFN0YXJ0ZWQnXSA9IFwiTm90U3RhcnRlZFwiO1xuICAgIEFjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZVtBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbXCJJbmNvbXBsZXRlXCJdID0gJ0luY29tcGxldGUnXSA9IFwiSW5jb21wbGV0ZVwiO1xuICAgIEFjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZVtBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbXCJDb21wbGV0ZWRcIl0gPSAnQ29tcGxldGVkJ10gPSBcIkNvbXBsZXRlZFwiO1xufSkoZXhwb3J0cy5BY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGUgfHwgKGV4cG9ydHMuQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlID0ge30pKTtcbnZhciBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGUgPSBleHBvcnRzLkFjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZTtcbihmdW5jdGlvbiAoQWNjb3VudEluZm9TdGF0dXMpIHtcbiAgICBBY2NvdW50SW5mb1N0YXR1c1tBY2NvdW50SW5mb1N0YXR1c1tcIkNvbmZpcm1lZFwiXSA9ICdDb25maXJtZWQnXSA9IFwiQ29uZmlybWVkXCI7XG4gICAgQWNjb3VudEluZm9TdGF0dXNbQWNjb3VudEluZm9TdGF0dXNbXCJEaXNhYmxlZFwiXSA9ICdEaXNhYmxlZCddID0gXCJEaXNhYmxlZFwiO1xufSkoZXhwb3J0cy5BY2NvdW50SW5mb1N0YXR1cyB8fCAoZXhwb3J0cy5BY2NvdW50SW5mb1N0YXR1cyA9IHt9KSk7XG52YXIgQWNjb3VudEluZm9TdGF0dXMgPSBleHBvcnRzLkFjY291bnRJbmZvU3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIE1vZGVsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RlbChzZGssIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc2RrID0gc2RrO1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eU1hcHBpbmdzKCkuZm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICAgICAgdmFyIENsYXNzID0gbWFwcGluZy5DbGFzcywgcHJvcCA9IG1hcHBpbmcucHJvcGVydHk7XG4gICAgICAgICAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGluZy5pc1JlcXVpcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1JlcXVpcmVkIHByb3BlcnR5IFwiJyArIHByb3AgKyAnXCIgbm90IGRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc1Byb3BlcnR5ID0gZnVuY3Rpb24gKGRhdGFQYXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFDbGFzcyB8fCB0eXBlb2YgQ2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFQYXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDbGFzcyhfdGhpcy5fc2RrLCBkYXRhUGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChtYXBwaW5nLmlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBfdGhpc1twcm9wXSA9IGRhdGFbcHJvcF0ubWFwKHByb2Nlc3NQcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpc1twcm9wXSA9IHByb2Nlc3NQcm9wZXJ0eShkYXRhW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE1vZGVsLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01vZGVsJztcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJ2lkJ107XG4gICAgfTtcbiAgICByZXR1cm4gTW9kZWw7XG59KCkpO1xuZXhwb3J0cy5Nb2RlbCA9IE1vZGVsO1xuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNvbnRhY3RpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBkZXBhcnRtZW50aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG52YXIgZXh0ZW5zaW9ucGVybWlzc2lvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBwcm9maWxlaW1hZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG52YXIgcmVmZXJlbmNlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xudmFyIHJlZ2lvbmFsc2V0dGluZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbnZhciBleHRlbnNpb25zZXJ2aWNlZmVhdHVyZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbnZhciBleHRlbnNpb25zdGF0dXNpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgRXh0ZW5zaW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbnRhY3QnLCBDbGFzczogY29udGFjdGluZm8uQ29udGFjdEluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RlcGFydG1lbnRzJywgQ2xhc3M6IGRlcGFydG1lbnRpbmZvLkRlcGFydG1lbnRJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhcnRuZXJJZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGVybWlzc2lvbnMnLCBDbGFzczogZXh0ZW5zaW9ucGVybWlzc2lvbnMuRXh0ZW5zaW9uUGVybWlzc2lvbnMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Byb2ZpbGVJbWFnZScsIENsYXNzOiBwcm9maWxlaW1hZ2VpbmZvLlByb2ZpbGVJbWFnZUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVmZXJlbmNlcycsIENsYXNzOiByZWZlcmVuY2VpbmZvLlJlZmVyZW5jZUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVnaW9uYWxTZXR0aW5ncycsIENsYXNzOiByZWdpb25hbHNldHRpbmdzLlJlZ2lvbmFsU2V0dGluZ3MsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3NlcnZpY2VGZWF0dXJlcycsIENsYXNzOiBleHRlbnNpb25zZXJ2aWNlZmVhdHVyZWluZm8uRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3NldHVwV2l6YXJkU3RhdGUnLCBDbGFzczogRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXR1cycsIENsYXNzOiBFeHRlbnNpb25JbmZvU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXR1c0luZm8nLCBDbGFzczogZXh0ZW5zaW9uc3RhdHVzaW5mby5FeHRlbnNpb25TdGF0dXNJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IEV4dGVuc2lvbkluZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uSW5mbyA9IEV4dGVuc2lvbkluZm87XG4oZnVuY3Rpb24gKEV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlKSB7XG4gICAgRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGVbRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGVbXCJOb3RTdGFydGVkXCJdID0gJ05vdFN0YXJ0ZWQnXSA9IFwiTm90U3RhcnRlZFwiO1xuICAgIEV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlW0V4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlW1wiSW5jb21wbGV0ZVwiXSA9ICdJbmNvbXBsZXRlJ10gPSBcIkluY29tcGxldGVcIjtcbiAgICBFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZVtFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZVtcIkNvbXBsZXRlZFwiXSA9ICdDb21wbGV0ZWQnXSA9IFwiQ29tcGxldGVkXCI7XG59KShleHBvcnRzLkV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlIHx8IChleHBvcnRzLkV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlID0ge30pKTtcbnZhciBFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZSA9IGV4cG9ydHMuRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGU7XG4oZnVuY3Rpb24gKEV4dGVuc2lvbkluZm9TdGF0dXMpIHtcbiAgICBFeHRlbnNpb25JbmZvU3RhdHVzW0V4dGVuc2lvbkluZm9TdGF0dXNbXCJFbmFibGVkXCJdID0gJ0VuYWJsZWQnXSA9IFwiRW5hYmxlZFwiO1xuICAgIEV4dGVuc2lvbkluZm9TdGF0dXNbRXh0ZW5zaW9uSW5mb1N0YXR1c1tcIkRpc2FibGVkXCJdID0gJ0Rpc2FibGVkJ10gPSBcIkRpc2FibGVkXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1N0YXR1c1tFeHRlbnNpb25JbmZvU3RhdHVzW1wiTm90QWN0aXZhdGVkXCJdID0gJ05vdEFjdGl2YXRlZCddID0gXCJOb3RBY3RpdmF0ZWRcIjtcbiAgICBFeHRlbnNpb25JbmZvU3RhdHVzW0V4dGVuc2lvbkluZm9TdGF0dXNbXCJVbmFzc2lnbmVkXCJdID0gJ1VuYXNzaWduZWQnXSA9IFwiVW5hc3NpZ25lZFwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25JbmZvU3RhdHVzIHx8IChleHBvcnRzLkV4dGVuc2lvbkluZm9TdGF0dXMgPSB7fSkpO1xudmFyIEV4dGVuc2lvbkluZm9TdGF0dXMgPSBleHBvcnRzLkV4dGVuc2lvbkluZm9TdGF0dXM7XG4oZnVuY3Rpb24gKEV4dGVuc2lvbkluZm9UeXBlKSB7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJVc2VyXCJdID0gJ1VzZXInXSA9IFwiVXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiRmF4VXNlclwiXSA9ICdGYXhVc2VyJ10gPSBcIkZheFVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIlZpcnR1YWxVc2VyXCJdID0gJ1ZpcnR1YWxVc2VyJ10gPSBcIlZpcnR1YWxVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJEaWdpdGFsVXNlclwiXSA9ICdEaWdpdGFsVXNlciddID0gXCJEaWdpdGFsVXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiRGVwYXJ0bWVudFwiXSA9ICdEZXBhcnRtZW50J10gPSBcIkRlcGFydG1lbnRcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkFubm91bmNlbWVudFwiXSA9ICdBbm5vdW5jZW1lbnQnXSA9IFwiQW5ub3VuY2VtZW50XCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJWb2ljZW1haWxcIl0gPSAnVm9pY2VtYWlsJ10gPSBcIlZvaWNlbWFpbFwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiU2hhcmVkTGluZXNHcm91cFwiXSA9ICdTaGFyZWRMaW5lc0dyb3VwJ10gPSBcIlNoYXJlZExpbmVzR3JvdXBcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIlBhZ2luZ09ubHlHcm91cFwiXSA9ICdQYWdpbmdPbmx5R3JvdXAnXSA9IFwiUGFnaW5nT25seUdyb3VwXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJJdnJNZW51XCJdID0gJ0l2ck1lbnUnXSA9IFwiSXZyTWVudVwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiQXBwbGljYXRpb25FeHRlbnNpb25cIl0gPSAnQXBwbGljYXRpb25FeHRlbnNpb24nXSA9IFwiQXBwbGljYXRpb25FeHRlbnNpb25cIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIlBhcmtMb2NhdGlvblwiXSA9ICdQYXJrTG9jYXRpb24nXSA9IFwiUGFya0xvY2F0aW9uXCI7XG59KShleHBvcnRzLkV4dGVuc2lvbkluZm9UeXBlIHx8IChleHBvcnRzLkV4dGVuc2lvbkluZm9UeXBlID0ge30pKTtcbnZhciBFeHRlbnNpb25JbmZvVHlwZSA9IGV4cG9ydHMuRXh0ZW5zaW9uSW5mb1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY29udGFjdGFkZHJlc3NpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBDb250YWN0SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnRhY3RJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRhY3RJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ29udGFjdEluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmlyc3ROYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsYXN0TmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29tcGFueScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW1haWwnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2J1c2luZXNzUGhvbmUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2J1c2luZXNzQWRkcmVzcycsIENsYXNzOiBjb250YWN0YWRkcmVzc2luZm8uQ29udGFjdEFkZHJlc3NJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ29udGFjdEluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDb250YWN0SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udGFjdEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNvbnRhY3RJbmZvID0gQ29udGFjdEluZm87XG5cblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQ29udGFjdEFkZHJlc3NJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udGFjdEFkZHJlc3NJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRhY3RBZGRyZXNzSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbnRhY3RBZGRyZXNzSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb3VudHJ5JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0ZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2l0eScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RyZWV0JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd6aXAnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDb250YWN0QWRkcmVzc0luZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDb250YWN0QWRkcmVzc0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRhY3RBZGRyZXNzSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQ29udGFjdEFkZHJlc3NJbmZvID0gQ29udGFjdEFkZHJlc3NJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIERlcGFydG1lbnRJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVwYXJ0bWVudEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVwYXJ0bWVudEluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEZXBhcnRtZW50SW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEZXBhcnRtZW50SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RlcGFydG1lbnRJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBEZXBhcnRtZW50SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGVwYXJ0bWVudEluZm8gPSBEZXBhcnRtZW50SW5mbztcblxuXG4vKioqLyB9LFxuLyogMTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgcGVybWlzc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciBFeHRlbnNpb25QZXJtaXNzaW9ucyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvblBlcm1pc3Npb25zLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvblBlcm1pc3Npb25zKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uUGVybWlzc2lvbnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYWRtaW4nLCBDbGFzczogcGVybWlzc2lvbmluZm8uUGVybWlzc2lvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ludGVybmF0aW9uYWxDYWxsaW5nJywgQ2xhc3M6IHBlcm1pc3Npb25pbmZvLlBlcm1pc3Npb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uUGVybWlzc2lvbnMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25QZXJtaXNzaW9ucyc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uUGVybWlzc2lvbnM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvblBlcm1pc3Npb25zID0gRXh0ZW5zaW9uUGVybWlzc2lvbnM7XG5cblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFBlcm1pc3Npb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGVybWlzc2lvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGVybWlzc2lvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQZXJtaXNzaW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlbmFibGVkJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFBlcm1pc3Npb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUGVybWlzc2lvbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFBlcm1pc3Npb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5QZXJtaXNzaW9uSW5mbyA9IFBlcm1pc3Npb25JbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQcm9maWxlSW1hZ2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvZmlsZUltYWdlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcm9maWxlSW1hZ2VJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUHJvZmlsZUltYWdlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXRhZycsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFzdE1vZGlmaWVkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb250ZW50VHlwZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2NhbGVzJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nW10gKi8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFByb2ZpbGVJbWFnZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdQcm9maWxlSW1hZ2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQcm9maWxlSW1hZ2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Qcm9maWxlSW1hZ2VJbmZvID0gUHJvZmlsZUltYWdlSW5mbztcblxuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUmVmZXJlbmNlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZmVyZW5jZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJlZmVyZW5jZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVmJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IFJlZmVyZW5jZUluZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUmVmZXJlbmNlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1JlZmVyZW5jZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZmVyZW5jZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlJlZmVyZW5jZUluZm8gPSBSZWZlcmVuY2VJbmZvO1xuKGZ1bmN0aW9uIChSZWZlcmVuY2VJbmZvVHlwZSkge1xuICAgIFJlZmVyZW5jZUluZm9UeXBlW1JlZmVyZW5jZUluZm9UeXBlW1wiUGFydG5lcklkXCJdID0gJ1BhcnRuZXJJZCddID0gXCJQYXJ0bmVySWRcIjtcbiAgICBSZWZlcmVuY2VJbmZvVHlwZVtSZWZlcmVuY2VJbmZvVHlwZVtcIkN1c3RvbWVyRGlyZWN0b3J5SWRcIl0gPSAnQ3VzdG9tZXJEaXJlY3RvcnlJZCddID0gXCJDdXN0b21lckRpcmVjdG9yeUlkXCI7XG59KShleHBvcnRzLlJlZmVyZW5jZUluZm9UeXBlIHx8IChleHBvcnRzLlJlZmVyZW5jZUluZm9UeXBlID0ge30pKTtcbnZhciBSZWZlcmVuY2VJbmZvVHlwZSA9IGV4cG9ydHMuUmVmZXJlbmNlSW5mb1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNvdW50cnlpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG52YXIgdGltZXpvbmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG52YXIgbGFuZ3VhZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG52YXIgZ3JlZXRpbmdsYW5ndWFnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbnZhciBmb3JtYXR0aW5nbG9jYWxlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xudmFyIFJlZ2lvbmFsU2V0dGluZ3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWdpb25hbFNldHRpbmdzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZ2lvbmFsU2V0dGluZ3MoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZWdpb25hbFNldHRpbmdzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2hvbWVDb3VudHJ5JywgQ2xhc3M6IGNvdW50cnlpbmZvLkNvdW50cnlJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0aW1lem9uZScsIENsYXNzOiB0aW1lem9uZWluZm8uVGltZXpvbmVJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsYW5ndWFnZScsIENsYXNzOiBsYW5ndWFnZWluZm8uTGFuZ3VhZ2VJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdncmVldGluZ0xhbmd1YWdlJywgQ2xhc3M6IGdyZWV0aW5nbGFuZ3VhZ2VpbmZvLkdyZWV0aW5nTGFuZ3VhZ2VJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmb3JtYXR0aW5nTG9jYWxlJywgQ2xhc3M6IGZvcm1hdHRpbmdsb2NhbGVpbmZvLkZvcm1hdHRpbmdMb2NhbGVJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUmVnaW9uYWxTZXR0aW5ncy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1JlZ2lvbmFsU2V0dGluZ3MnO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZ2lvbmFsU2V0dGluZ3M7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlJlZ2lvbmFsU2V0dGluZ3MgPSBSZWdpb25hbFNldHRpbmdzO1xuXG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBDb3VudHJ5SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvdW50cnlJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvdW50cnlJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ291bnRyeUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ291bnRyeUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIENvdW50cnlJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Db3VudHJ5SW5mbyA9IENvdW50cnlJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAxNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBUaW1lem9uZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lem9uZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZXpvbmVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGltZXpvbmVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Rlc2NyaXB0aW9uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgVGltZXpvbmVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnVGltZXpvbmVJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBUaW1lem9uZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlRpbWV6b25lSW5mbyA9IFRpbWV6b25lSW5mbztcblxuXG4vKioqLyB9LFxuLyogMTcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgTGFuZ3VhZ2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGFuZ3VhZ2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExhbmd1YWdlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExhbmd1YWdlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdncmVldGluZycsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Zvcm1hdHRpbmdMb2NhbGUnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsb2NhbGVDb2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1aScsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBMYW5ndWFnZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdMYW5ndWFnZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIExhbmd1YWdlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTGFuZ3VhZ2VJbmZvID0gTGFuZ3VhZ2VJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBHcmVldGluZ0xhbmd1YWdlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyZWV0aW5nTGFuZ3VhZ2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyZWV0aW5nTGFuZ3VhZ2VJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgR3JlZXRpbmdMYW5ndWFnZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xvY2FsZUNvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBHcmVldGluZ0xhbmd1YWdlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0dyZWV0aW5nTGFuZ3VhZ2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBHcmVldGluZ0xhbmd1YWdlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuR3JlZXRpbmdMYW5ndWFnZUluZm8gPSBHcmVldGluZ0xhbmd1YWdlSW5mbztcblxuXG4vKioqLyB9LFxuLyogMTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRm9ybWF0dGluZ0xvY2FsZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb3JtYXR0aW5nTG9jYWxlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGb3JtYXR0aW5nTG9jYWxlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEZvcm1hdHRpbmdMb2NhbGVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsb2NhbGVDb2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRm9ybWF0dGluZ0xvY2FsZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdGb3JtYXR0aW5nTG9jYWxlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRm9ybWF0dGluZ0xvY2FsZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkZvcm1hdHRpbmdMb2NhbGVJbmZvID0gRm9ybWF0dGluZ0xvY2FsZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDIwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5hYmxlZCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZlYXR1cmVOYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWFzb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvID0gRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBFeHRlbnNpb25TdGF0dXNJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uU3RhdHVzSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25TdGF0dXNJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uU3RhdHVzSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb21tZW50JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWFzb24nLCBDbGFzczogRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvblN0YXR1c0luZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25TdGF0dXNJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25TdGF0dXNJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25TdGF0dXNJbmZvID0gRXh0ZW5zaW9uU3RhdHVzSW5mbztcbihmdW5jdGlvbiAoRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbikge1xuICAgIEV4dGVuc2lvblN0YXR1c0luZm9SZWFzb25bRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbltcIlZvbHVudGFyaWx5XCJdID0gJ1ZvbHVudGFyaWx5J10gPSBcIlZvbHVudGFyaWx5XCI7XG4gICAgRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbltFeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uW1wiSW52b2x1bnRhcmlseVwiXSA9ICdJbnZvbHVudGFyaWx5J10gPSBcIkludm9sdW50YXJpbHlcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbiB8fCAoZXhwb3J0cy5FeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uID0ge30pKTtcbnZhciBFeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uID0gZXhwb3J0cy5FeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uO1xuXG5cbi8qKiovIH0sXG4vKiAyMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBiaWxsaW5ncGxhbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbnZhciBicmFuZGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcbnZhciBzZXJ2aWNlcGxhbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbnZhciB0YXJnZXRzZXJ2aWNlcGxhbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbnZhciBTZXJ2aWNlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcnZpY2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcnZpY2VJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VydmljZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdiaWxsaW5nUGxhbicsIENsYXNzOiBiaWxsaW5ncGxhbmluZm8uQmlsbGluZ1BsYW5JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdicmFuZCcsIENsYXNzOiBicmFuZGluZm8uQnJhbmRJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXJ2aWNlUGxhbicsIENsYXNzOiBzZXJ2aWNlcGxhbmluZm8uU2VydmljZVBsYW5JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0YXJnZXRTZXJ2aWNlUGxhbicsIENsYXNzOiB0YXJnZXRzZXJ2aWNlcGxhbmluZm8uVGFyZ2V0U2VydmljZVBsYW5JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU2VydmljZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTZXJ2aWNlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gU2VydmljZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlNlcnZpY2VJbmZvID0gU2VydmljZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDIzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEJpbGxpbmdQbGFuSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJpbGxpbmdQbGFuSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaWxsaW5nUGxhbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCaWxsaW5nUGxhbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2R1cmF0aW9uVW5pdCcsIENsYXNzOiBCaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2R1cmF0aW9uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IEJpbGxpbmdQbGFuSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBCaWxsaW5nUGxhbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdCaWxsaW5nUGxhbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbGxpbmdQbGFuSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvID0gQmlsbGluZ1BsYW5JbmZvO1xuKGZ1bmN0aW9uIChCaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXQpIHtcbiAgICBCaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXRbQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0W1wiTW9udGhcIl0gPSAnTW9udGgnXSA9IFwiTW9udGhcIjtcbiAgICBCaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXRbQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0W1wiRGF5XCJdID0gJ0RheSddID0gXCJEYXlcIjtcbn0pKGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0IHx8IChleHBvcnRzLkJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdCA9IHt9KSk7XG52YXIgQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0ID0gZXhwb3J0cy5CaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXQ7XG4oZnVuY3Rpb24gKEJpbGxpbmdQbGFuSW5mb1R5cGUpIHtcbiAgICBCaWxsaW5nUGxhbkluZm9UeXBlW0JpbGxpbmdQbGFuSW5mb1R5cGVbXCJJbml0aWFsXCJdID0gJ0luaXRpYWwnXSA9IFwiSW5pdGlhbFwiO1xuICAgIEJpbGxpbmdQbGFuSW5mb1R5cGVbQmlsbGluZ1BsYW5JbmZvVHlwZVtcIlJlZ3VsYXJcIl0gPSAnUmVndWxhciddID0gXCJSZWd1bGFyXCI7XG4gICAgQmlsbGluZ1BsYW5JbmZvVHlwZVtCaWxsaW5nUGxhbkluZm9UeXBlW1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbiAgICBCaWxsaW5nUGxhbkluZm9UeXBlW0JpbGxpbmdQbGFuSW5mb1R5cGVbXCJUcmlhbFwiXSA9ICdUcmlhbCddID0gXCJUcmlhbFwiO1xuICAgIEJpbGxpbmdQbGFuSW5mb1R5cGVbQmlsbGluZ1BsYW5JbmZvVHlwZVtcIlRyaWFsTm9DQ1wiXSA9ICdUcmlhbE5vQ0MnXSA9IFwiVHJpYWxOb0NDXCI7XG4gICAgQmlsbGluZ1BsYW5JbmZvVHlwZVtCaWxsaW5nUGxhbkluZm9UeXBlW1wiRnJlZVwiXSA9ICdGcmVlJ10gPSBcIkZyZWVcIjtcbn0pKGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvVHlwZSB8fCAoZXhwb3J0cy5CaWxsaW5nUGxhbkluZm9UeXBlID0ge30pKTtcbnZhciBCaWxsaW5nUGxhbkluZm9UeXBlID0gZXhwb3J0cy5CaWxsaW5nUGxhbkluZm9UeXBlO1xuXG5cbi8qKiovIH0sXG4vKiAyNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjb3VudHJ5aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xudmFyIEJyYW5kSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyYW5kSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCcmFuZEluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCcmFuZEluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2hvbWVDb3VudHJ5JywgQ2xhc3M6IGNvdW50cnlpbmZvLkNvdW50cnlJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQnJhbmRJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQnJhbmRJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBCcmFuZEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkJyYW5kSW5mbyA9IEJyYW5kSW5mbztcblxuXG4vKioqLyB9LFxuLyogMjUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgU2VydmljZVBsYW5JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VydmljZVBsYW5JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcnZpY2VQbGFuSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNlcnZpY2VQbGFuSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZWRpdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFNlcnZpY2VQbGFuSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1NlcnZpY2VQbGFuSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gU2VydmljZVBsYW5JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5TZXJ2aWNlUGxhbkluZm8gPSBTZXJ2aWNlUGxhbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDI2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFRhcmdldFNlcnZpY2VQbGFuSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhcmdldFNlcnZpY2VQbGFuSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYXJnZXRTZXJ2aWNlUGxhbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUYXJnZXRTZXJ2aWNlUGxhbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBUYXJnZXRTZXJ2aWNlUGxhbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdUYXJnZXRTZXJ2aWNlUGxhbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFRhcmdldFNlcnZpY2VQbGFuSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuVGFyZ2V0U2VydmljZVBsYW5JbmZvID0gVGFyZ2V0U2VydmljZVBsYW5JbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBBY2NvdW50U3RhdHVzSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRTdGF0dXNJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRTdGF0dXNJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudFN0YXR1c0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29tbWVudCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVhc29uJywgQ2xhc3M6IEFjY291bnRTdGF0dXNJbmZvUmVhc29uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudFN0YXR1c0luZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50U3RhdHVzSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudFN0YXR1c0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRTdGF0dXNJbmZvID0gQWNjb3VudFN0YXR1c0luZm87XG4oZnVuY3Rpb24gKEFjY291bnRTdGF0dXNJbmZvUmVhc29uKSB7XG4gICAgQWNjb3VudFN0YXR1c0luZm9SZWFzb25bQWNjb3VudFN0YXR1c0luZm9SZWFzb25bXCJWb2x1bnRhcmlseVwiXSA9ICdWb2x1bnRhcmlseSddID0gXCJWb2x1bnRhcmlseVwiO1xuICAgIEFjY291bnRTdGF0dXNJbmZvUmVhc29uW0FjY291bnRTdGF0dXNJbmZvUmVhc29uW1wiSW52b2x1bnRhcmlseVwiXSA9ICdJbnZvbHVudGFyaWx5J10gPSBcIkludm9sdW50YXJpbHlcIjtcbn0pKGV4cG9ydHMuQWNjb3VudFN0YXR1c0luZm9SZWFzb24gfHwgKGV4cG9ydHMuQWNjb3VudFN0YXR1c0luZm9SZWFzb24gPSB7fSkpO1xudmFyIEFjY291bnRTdGF0dXNJbmZvUmVhc29uID0gZXhwb3J0cy5BY2NvdW50U3RhdHVzSW5mb1JlYXNvbjtcblxuXG4vKioqLyB9LFxuLyogMjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgYnVzaW5lc3NhZGRyZXNzaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xudmFyIEFjY291bnRCdXNpbmVzc0FkZHJlc3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50QnVzaW5lc3NBZGRyZXNzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRCdXNpbmVzc0FkZHJlc3MoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50QnVzaW5lc3NBZGRyZXNzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29tcGFueScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW1haWwnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2J1c2luZXNzQWRkcmVzcycsIENsYXNzOiBidXNpbmVzc2FkZHJlc3NpbmZvLkJ1c2luZXNzQWRkcmVzc0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRCdXNpbmVzc0FkZHJlc3MucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50QnVzaW5lc3NBZGRyZXNzJztcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50QnVzaW5lc3NBZGRyZXNzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50QnVzaW5lc3NBZGRyZXNzID0gQWNjb3VudEJ1c2luZXNzQWRkcmVzcztcblxuXG4vKioqLyB9LFxuLyogMjkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQnVzaW5lc3NBZGRyZXNzSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1c2luZXNzQWRkcmVzc0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVzaW5lc3NBZGRyZXNzSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJ1c2luZXNzQWRkcmVzc0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY291bnRyeScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NpdHknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0cmVldCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnemlwJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQnVzaW5lc3NBZGRyZXNzSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0J1c2luZXNzQWRkcmVzc0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1c2luZXNzQWRkcmVzc0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkJ1c2luZXNzQWRkcmVzc0luZm8gPSBCdXNpbmVzc0FkZHJlc3NJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAzMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBkaWFsaW5ncGxhbmNvdW50cnlpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgRGlhbGluZ1BsYW5JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGlhbGluZ1BsYW5JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpYWxpbmdQbGFuSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpYWxpbmdQbGFuSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGRpYWxpbmdwbGFuY291bnRyeWluZm8uRGlhbGluZ1BsYW5Db3VudHJ5SW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGlhbGluZ1BsYW5JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGlhbGluZ1BsYW5JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBEaWFsaW5nUGxhbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpYWxpbmdQbGFuSW5mbyA9IERpYWxpbmdQbGFuSW5mbztcblxuXG4vKioqLyB9LFxuLyogMzEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRGlhbGluZ1BsYW5Db3VudHJ5SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpYWxpbmdQbGFuQ291bnRyeUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGlhbGluZ1BsYW5Db3VudHJ5SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpYWxpbmdQbGFuQ291bnRyeUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbGluZ0NvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lzb0NvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWFsaW5nUGxhbkNvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGlhbGluZ1BsYW5Db3VudHJ5SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGlhbGluZ1BsYW5Db3VudHJ5SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGlhbGluZ1BsYW5Db3VudHJ5SW5mbyA9IERpYWxpbmdQbGFuQ291bnRyeUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDMyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFBhZ2luZ0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYWdpbmdJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhZ2luZ0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQYWdpbmdJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2UnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BlclBhZ2UnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2VTdGFydCcsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnZUVuZCcsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndG90YWxQYWdlcycsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndG90YWxFbGVtZW50cycsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFBhZ2luZ0luZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdQYWdpbmdJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQYWdpbmdJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5QYWdpbmdJbmZvID0gUGFnaW5nSW5mbztcblxuXG4vKioqLyB9LFxuLyogMzMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgTmF2aWdhdGlvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOYXZpZ2F0aW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE5hdmlnYXRpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZpcnN0UGFnZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmV4dFBhZ2UnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ByZXZpb3VzUGFnZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFzdFBhZ2UnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBOYXZpZ2F0aW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ05hdmlnYXRpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBOYXZpZ2F0aW9uSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTmF2aWdhdGlvbkluZm8gPSBOYXZpZ2F0aW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogMzQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbnZhciBwaG9uZW51bWJlcnNleHRlbnNpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG52YXIgUGhvbmVOdW1iZXJJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGhvbmVOdW1iZXJJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBob25lTnVtYmVySW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBob25lTnVtYmVySW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY291bnRyeScsIENsYXNzOiBjb3VudHJ5aW5mby5Db3VudHJ5SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uJywgQ2xhc3M6IHBob25lbnVtYmVyc2V4dGVuc2lvbmluZm8uUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmVhdHVyZXMnLCBDbGFzczogbnVsbCAvKiBzdHJpbmdbXSAqLywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsb2NhdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGF5bWVudFR5cGUnLCBDbGFzczogUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Bob25lTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXMnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogUGhvbmVOdW1iZXJJbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXNhZ2VUeXBlJywgQ2xhc3M6IFBob25lTnVtYmVySW5mb1VzYWdlVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFBob25lTnVtYmVySW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1Bob25lTnVtYmVySW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUGhvbmVOdW1iZXJJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5QaG9uZU51bWJlckluZm8gPSBQaG9uZU51bWJlckluZm87XG4oZnVuY3Rpb24gKFBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlKSB7XG4gICAgUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGVbUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGVbXCJFeHRlcm5hbFwiXSA9ICdFeHRlcm5hbCddID0gXCJFeHRlcm5hbFwiO1xuICAgIFBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlW1Bob25lTnVtYmVySW5mb1BheW1lbnRUeXBlW1wiVG9sbEZyZWVcIl0gPSAnVG9sbEZyZWUnXSA9IFwiVG9sbEZyZWVcIjtcbiAgICBQaG9uZU51bWJlckluZm9QYXltZW50VHlwZVtQaG9uZU51bWJlckluZm9QYXltZW50VHlwZVtcIkxvY2FsXCJdID0gJ0xvY2FsJ10gPSBcIkxvY2FsXCI7XG59KShleHBvcnRzLlBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlIHx8IChleHBvcnRzLlBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlID0ge30pKTtcbnZhciBQaG9uZU51bWJlckluZm9QYXltZW50VHlwZSA9IGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGU7XG4oZnVuY3Rpb24gKFBob25lTnVtYmVySW5mb1R5cGUpIHtcbiAgICBQaG9uZU51bWJlckluZm9UeXBlW1Bob25lTnVtYmVySW5mb1R5cGVbXCJWb2ljZUZheFwiXSA9ICdWb2ljZUZheCddID0gXCJWb2ljZUZheFwiO1xuICAgIFBob25lTnVtYmVySW5mb1R5cGVbUGhvbmVOdW1iZXJJbmZvVHlwZVtcIkZheE9ubHlcIl0gPSAnRmF4T25seSddID0gXCJGYXhPbmx5XCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVHlwZVtQaG9uZU51bWJlckluZm9UeXBlW1wiVm9pY2VPbmx5XCJdID0gJ1ZvaWNlT25seSddID0gXCJWb2ljZU9ubHlcIjtcbn0pKGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVHlwZSB8fCAoZXhwb3J0cy5QaG9uZU51bWJlckluZm9UeXBlID0ge30pKTtcbnZhciBQaG9uZU51bWJlckluZm9UeXBlID0gZXhwb3J0cy5QaG9uZU51bWJlckluZm9UeXBlO1xuKGZ1bmN0aW9uIChQaG9uZU51bWJlckluZm9Vc2FnZVR5cGUpIHtcbiAgICBQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1wiTWFpbkNvbXBhbnlOdW1iZXJcIl0gPSAnTWFpbkNvbXBhbnlOdW1iZXInXSA9IFwiTWFpbkNvbXBhbnlOdW1iZXJcIjtcbiAgICBQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1wiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIl0gPSAnQWRkaXRpb25hbENvbXBhbnlOdW1iZXInXSA9IFwiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIjtcbiAgICBQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1wiQ29tcGFueU51bWJlclwiXSA9ICdDb21wYW55TnVtYmVyJ10gPSBcIkNvbXBhbnlOdW1iZXJcIjtcbiAgICBQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1wiRGlyZWN0TnVtYmVyXCJdID0gJ0RpcmVjdE51bWJlciddID0gXCJEaXJlY3ROdW1iZXJcIjtcbiAgICBQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1wiQ29tcGFueUZheE51bWJlclwiXSA9ICdDb21wYW55RmF4TnVtYmVyJ10gPSBcIkNvbXBhbnlGYXhOdW1iZXJcIjtcbiAgICBQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1wiRm9yd2FyZGVkTnVtYmVyXCJdID0gJ0ZvcndhcmRlZE51bWJlciddID0gXCJGb3J3YXJkZWROdW1iZXJcIjtcbn0pKGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlIHx8IChleHBvcnRzLlBob25lTnVtYmVySW5mb1VzYWdlVHlwZSA9IHt9KSk7XG52YXIgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlID0gZXhwb3J0cy5QaG9uZU51bWJlckluZm9Vc2FnZVR5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDM1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFBob25lTnVtYmVyc0V4dGVuc2lvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBob25lTnVtYmVyc0V4dGVuc2lvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFydG5lcklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1Bob25lTnVtYmVyc0V4dGVuc2lvbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFBob25lTnVtYmVyc0V4dGVuc2lvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlBob25lTnVtYmVyc0V4dGVuc2lvbkluZm8gPSBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAzNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBwaG9uZW51bWJlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBBY2NvdW50UGhvbmVOdW1iZXJzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudFBob25lTnVtYmVycywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50UGhvbmVOdW1iZXJzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudFBob25lTnVtYmVycy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IHBob25lbnVtYmVyaW5mby5QaG9uZU51bWJlckluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRQaG9uZU51bWJlcnMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50UGhvbmVOdW1iZXJzJztcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50UGhvbmVOdW1iZXJzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50UGhvbmVOdW1iZXJzID0gQWNjb3VudFBob25lTnVtYmVycztcblxuXG4vKioqLyB9LFxuLyogMzcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgc2VydmljZWZlYXR1cmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG52YXIgYWNjb3VudGxpbWl0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xudmFyIEFjY291bnRTZXJ2aWNlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRTZXJ2aWNlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50U2VydmljZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50U2VydmljZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXJ2aWNlUGxhbk5hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3NlcnZpY2VGZWF0dXJlcycsIENsYXNzOiBzZXJ2aWNlZmVhdHVyZWluZm8uU2VydmljZUZlYXR1cmVJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xpbWl0cycsIENsYXNzOiBhY2NvdW50bGltaXRzLkFjY291bnRMaW1pdHMsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRTZXJ2aWNlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRTZXJ2aWNlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudFNlcnZpY2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50U2VydmljZUluZm8gPSBBY2NvdW50U2VydmljZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDM4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFNlcnZpY2VGZWF0dXJlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcnZpY2VGZWF0dXJlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlRmVhdHVyZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZXJ2aWNlRmVhdHVyZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmVhdHVyZU5hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VuYWJsZWQnLCBDbGFzczogU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFNlcnZpY2VGZWF0dXJlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1NlcnZpY2VGZWF0dXJlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gU2VydmljZUZlYXR1cmVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5TZXJ2aWNlRmVhdHVyZUluZm8gPSBTZXJ2aWNlRmVhdHVyZUluZm87XG4oZnVuY3Rpb24gKFNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQpIHtcbiAgICBTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkW1NlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWRbXCJUcnVlXCJdID0gJ1RydWUnXSA9IFwiVHJ1ZVwiO1xuICAgIFNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWRbU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZFtcIkZhbHNlXCJdID0gJ0ZhbHNlJ10gPSBcIkZhbHNlXCI7XG59KShleHBvcnRzLlNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQgfHwgKGV4cG9ydHMuU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZCA9IHt9KSk7XG52YXIgU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZCA9IGV4cG9ydHMuU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZDtcblxuXG4vKioqLyB9LFxuLyogMzkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQWNjb3VudExpbWl0cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRMaW1pdHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudExpbWl0cygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRMaW1pdHMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZnJlZVNvZnRQaG9uZUxpbmVzUGVyRXh0ZW5zaW9uJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdtZWV0aW5nU2l6ZScsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbWF4TW9uaXRvcmVkRXh0ZW5zaW9uc1BlclVzZXInLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50TGltaXRzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudExpbWl0cyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudExpbWl0cztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudExpbWl0cyA9IEFjY291bnRMaW1pdHM7XG5cblxuLyoqKi8gfSxcbi8qIDQwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBhY2NvdW50YWN0aXZlY2FsbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcbnZhciBhY2NvdW50Y2FsbGxvZyA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xudmFyIGFjY291bnRjYWxsbG9ncmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG52YXIgZXh0ZW5zaW9uYWN0aXZlY2FsbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcbnZhciBleHRlbnNpb25jYWxsbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG52YXIgZXh0ZW5zaW9uY2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpO1xudmFyIGNhbGxsb2dzeW5jID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG52YXIgY2FsbHJlY29yZGluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xudmFyIENhbGxMb2cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxsTG9nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGxMb2coKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgQWNjb3VudCBBY3RpdmUgQ2FsbHNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMyAoUmVsZWFzZSA2LjUpPC9wPlxuICAgICAqIDxwPlJldHVybnMgcmVjb3JkcyBvZiBhbGwgY2FsbHMgdGhhdCBhcmUgaW4gcHJvZ3Jlc3MsIG9yZGVyZWQgYnkgc3RhcnQgdGltZSBpbiBkZXNjZW5kaW5nIG9yZGVyLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5saXN0QWNjb3VudEFjdGl2ZUNhbGxzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9hY3RpdmUtY2FsbHMnLCBvcHRpb25zLCBleHBvcnRzLmxpc3RBY2NvdW50QWN0aXZlQ2FsbHNPcHRpb25zKSwgYWNjb3VudGFjdGl2ZWNhbGxzLkFjY291bnRBY3RpdmVDYWxscyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQ2FsbCBMb2cgUmVjb3JkcyBieSBGaWx0ZXJcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4zIChSZWxlYXNlIDUuMTEpPC9wPlxuICAgICAqIDxwPlJldHVybnMgY2FsbCBsb2cgcmVjb3JkcyBmaWx0ZXJlZCBieSB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxvYWRBY2NvdW50Q2FsbExvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vY2FsbC1sb2cnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRBY2NvdW50Q2FsbExvZ09wdGlvbnMpLCBhY2NvdW50Y2FsbGxvZy5BY2NvdW50Q2FsbExvZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgQ2FsbCBMb2cgUmVjb3JkcyBieSBGaWx0ZXJcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUuZGVsZXRlQWNjb3VudENhbGxMb2cgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdERUxFVEUnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2NhbGwtbG9nJywgb3B0aW9ucywgZXhwb3J0cy5kZWxldGVBY2NvdW50Q2FsbExvZ09wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBBY2NvdW50IENhbGwgTG9nIFJlY29yZChzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjMgKFJlbGVhc2UgNS4xMSk8L3A+XG4gICAgICogPHA+UmV0dXJucyBpbmRpdmlkdWFsIGNhbGwgbG9nIHJlY29yZChzKSBieSBJRChzKS4gQmF0Y2ggcmVxdWVzdCBpcyBzdXBwb3J0ZWQsIHNlZSBCYXRjaCBSZXF1ZXN0cyBmb3IgZGV0YWlscy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubG9hZEFjY291bnRDYWxsTG9nUmVjb3JkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9jYWxsLWxvZy97Y2FsbFJlY29yZElkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEFjY291bnRDYWxsTG9nUmVjb3JkT3B0aW9ucyksIGFjY291bnRjYWxsbG9ncmVjb3JkLkFjY291bnRDYWxsTG9nUmVjb3JkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBBY3RpdmUgQ2FsbHNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMyAoUmVsZWFzZSA2LjUpPC9wPlxuICAgICAqIDxwPlJldHVybnMgcmVjb3JkcyBvZiBhbGwgZXh0ZW5zaW9uIGNhbGxzIHRoYXQgYXJlIGluIHByb2dyZXNzLCBvcmRlcmVkIGJ5IHN0YXJ0IHRpbWUgaW4gZGVzY2VuZGluZyBvcmRlci48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9hY3RpdmUtY2FsbHMnLCBvcHRpb25zLCBleHBvcnRzLmxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc09wdGlvbnMpLCBleHRlbnNpb25hY3RpdmVjYWxscy5FeHRlbnNpb25BY3RpdmVDYWxscyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQ2FsbCBMb2cgUmVjb3JkcyBieSBGaWx0ZXJcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4zIChSZWxlYXNlIDUuMTEpPC9wPlxuICAgICAqIDxwPlJldHVybnMgY2FsbCBsb2cgcmVjb3JkcyBmaWx0ZXJlZCBieSB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxvYWRFeHRlbnNpb25DYWxsTG9nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9jYWxsLWxvZycsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEV4dGVuc2lvbkNhbGxMb2dPcHRpb25zKSwgZXh0ZW5zaW9uY2FsbGxvZy5FeHRlbnNpb25DYWxsTG9nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBDYWxsIExvZyBSZWNvcmRzIGJ5IEZpbHRlclxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5kZWxldGVFeHRlbnNpb25DYWxsTG9nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9jYWxsLWxvZycsIG9wdGlvbnMsIGV4cG9ydHMuZGVsZXRlRXh0ZW5zaW9uQ2FsbExvZ09wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gQ2FsbCBMb2cgUmVjb3JkKHMpIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMyAoUmVsZWFzZSA1LjExKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGNhbGwgbG9nIHJlY29yZChzKSBieSB0aGVpciBJRChzKS4gQmF0Y2ggcmVxdWVzdCBpcyBzdXBwb3J0ZWQsIHNlZSBCYXRjaCBSZXF1ZXN0cyBmb3IgZGV0YWlscy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubG9hZEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2NhbGwtbG9nL3tjYWxsUmVjb3JkSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZE9wdGlvbnMpLCBleHRlbnNpb25jYWxsbG9ncmVjb3JkLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbCBMb2cgU3luY2hyb25pemF0aW9uXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLnN5bmNFeHRlbnNpb25DYWxsTG9nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9jYWxsLWxvZy1zeW5jJywgb3B0aW9ucywgZXhwb3J0cy5zeW5jRXh0ZW5zaW9uQ2FsbExvZ09wdGlvbnMpLCBjYWxsbG9nc3luYy5DYWxsTG9nU3luYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQ2FsbCBSZWNvcmRpbmdcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xODwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGNhbGwgcmVjb3JkaW5nIG1ldGFkYXRhLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxSZWNvcmRpbmc8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5Eb3dubG9hZGluZyBjYWxsIHJlY29yZGluZyBjb250ZW50PC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxvYWRDYWxsUmVjb3JkaW5nTWV0YWRhdGEgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L3JlY29yZGluZy97cmVjb3JkaW5nSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQ2FsbFJlY29yZGluZ01ldGFkYXRhT3B0aW9ucyksIGNhbGxyZWNvcmRpbmcuQ2FsbFJlY29yZGluZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQ2FsbCBSZWNvcmRpbmcgRGF0YVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxSZWNvcmRpbmc8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5Eb3dubG9hZGluZyBjYWxsIHJlY29yZGluZyBjb250ZW50PC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkQ2FsbFJlY29yZGluZ0NvbnRlbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L3JlY29yZGluZy97cmVjb3JkaW5nSWR9L2NvbnRlbnQnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRDYWxsUmVjb3JkaW5nQ29udGVudE9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBDYWxsTG9nO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLkNhbGxMb2cgPSBDYWxsTG9nO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RBY2NvdW50QWN0aXZlQ2FsbHMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEFjY291bnRBY3RpdmVDYWxsc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvblwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkluYm91bmRcIixcbiAgICAgICAgICAgIFwiT3V0Ym91bmRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIlZvaWNlXCIsXG4gICAgICAgICAgICBcIkZheFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkQWNjb3VudENhbGxMb2cgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEFjY291bnRDYWxsTG9nT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uTnVtYmVyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwaG9uZU51bWJlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEFjY291bnRDYWxsTG9nVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIlZvaWNlXCIsXG4gICAgICAgICAgICBcIkZheFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInZpZXdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXdcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJTaW1wbGVcIixcbiAgICAgICAgICAgIFwiRGV0YWlsZWRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ3aXRoUmVjb3JkaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZUZyb21cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGRlbGV0ZUFjY291bnRDYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmRlbGV0ZUFjY291bnRDYWxsTG9nT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZVRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEFjY291bnRDYWxsTG9nUmVjb3JkIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRBY2NvdW50Q2FsbExvZ1JlY29yZE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNhbGxSZWNvcmRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiSW5ib3VuZFwiLFxuICAgICAgICAgICAgXCJPdXRib3VuZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJWb2ljZVwiLFxuICAgICAgICAgICAgXCJGYXhcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEV4dGVuc2lvbkNhbGxMb2cgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEV4dGVuc2lvbkNhbGxMb2dPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uTnVtYmVyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwaG9uZU51bWJlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvblwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkluYm91bmRcIixcbiAgICAgICAgICAgIFwiT3V0Ym91bmRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJWb2ljZVwiLFxuICAgICAgICAgICAgXCJGYXhcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ2aWV3XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXdcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJTaW1wbGVcIixcbiAgICAgICAgICAgIFwiRGV0YWlsZWRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ3aXRoUmVjb3JkaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZVRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlRnJvbVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGRlbGV0ZUV4dGVuc2lvbkNhbGxMb2cgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZGVsZXRlRXh0ZW5zaW9uQ2FsbExvZ09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlVG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjYWxsUmVjb3JkSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc3luY0V4dGVuc2lvbkNhbGxMb2cgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuc3luY0V4dGVuc2lvbkNhbGxMb2dPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3luY1R5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJGU3luY1wiLFxuICAgICAgICAgICAgXCJJU3luY1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN5bmNUb2tlblwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZUZyb21cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInJlY29yZENvdW50XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdGF0dXNHcm91cFwiLFxuICAgICAgICBcInR5cGVcIjogXCJJU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cFwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIk1pc3NlZFwiLFxuICAgICAgICAgICAgXCJBbGxcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZENhbGxSZWNvcmRpbmdNZXRhZGF0YSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQ2FsbFJlY29yZGluZ01ldGFkYXRhT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicmVjb3JkaW5nSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZENhbGxSZWNvcmRpbmdDb250ZW50IG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRDYWxsUmVjb3JkaW5nQ29udGVudE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInJlY29yZGluZ0lkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuKGZ1bmN0aW9uIChJTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbikge1xuICAgIElMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uW0lMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBJTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbltJTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uIHx8IChleHBvcnRzLklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uID0ge30pKTtcbnZhciBJTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbiA9IGV4cG9ydHMuSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb247XG4oZnVuY3Rpb24gKElMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZSkge1xuICAgIElMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZVtJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIElMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZVtJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGUgfHwgKGV4cG9ydHMuSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlID0ge30pKTtcbnZhciBJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGUgPSBleHBvcnRzLklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZTtcbihmdW5jdGlvbiAoSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbikge1xuICAgIElMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb25bSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbltJTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uID0ge30pKTtcbnZhciBJTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uID0gZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJTG9hZEFjY291bnRDYWxsTG9nVHlwZSkge1xuICAgIElMb2FkQWNjb3VudENhbGxMb2dUeXBlW0lMb2FkQWNjb3VudENhbGxMb2dUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nVHlwZVtJTG9hZEFjY291bnRDYWxsTG9nVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dUeXBlIHx8IChleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dUeXBlID0ge30pKTtcbnZhciBJTG9hZEFjY291bnRDYWxsTG9nVHlwZSA9IGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGU7XG4oZnVuY3Rpb24gKElMb2FkQWNjb3VudENhbGxMb2dWaWV3KSB7XG4gICAgSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXdbSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXdbXCJTaW1wbGVcIl0gPSAnU2ltcGxlJ10gPSBcIlNpbXBsZVwiO1xuICAgIElMb2FkQWNjb3VudENhbGxMb2dWaWV3W0lMb2FkQWNjb3VudENhbGxMb2dWaWV3W1wiRGV0YWlsZWRcIl0gPSAnRGV0YWlsZWQnXSA9IFwiRGV0YWlsZWRcIjtcbn0pKGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXcgfHwgKGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXcgPSB7fSkpO1xudmFyIElMb2FkQWNjb3VudENhbGxMb2dWaWV3ID0gZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nVmlldztcbihmdW5jdGlvbiAoSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbikge1xuICAgIElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb25bSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbltJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uID0ge30pKTtcbnZhciBJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uID0gZXhwb3J0cy5JTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZSkge1xuICAgIElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlW0lMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZVtJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlIHx8IChleHBvcnRzLklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlID0ge30pKTtcbnZhciBJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZSA9IGV4cG9ydHMuSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGU7XG4oZnVuY3Rpb24gKElMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvbikge1xuICAgIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvbltJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvbltJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb24gfHwgKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uID0ge30pKTtcbnZhciBJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb24gPSBleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZSkge1xuICAgIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGVbSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZVtJTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZSB8fCAoZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlID0ge30pKTtcbnZhciBJTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlID0gZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlO1xuKGZ1bmN0aW9uIChJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3KSB7XG4gICAgSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlld1tJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3W1wiU2ltcGxlXCJdID0gJ1NpbXBsZSddID0gXCJTaW1wbGVcIjtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3W0lMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXdbXCJEZXRhaWxlZFwiXSA9ICdEZXRhaWxlZCddID0gXCJEZXRhaWxlZFwiO1xufSkoZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3IHx8IChleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXcgPSB7fSkpO1xudmFyIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXcgPSBleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXc7XG4oZnVuY3Rpb24gKElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlKSB7XG4gICAgSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGVbSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGVbXCJGU3luY1wiXSA9ICdGU3luYyddID0gXCJGU3luY1wiO1xuICAgIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlW0lTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlW1wiSVN5bmNcIl0gPSAnSVN5bmMnXSA9IFwiSVN5bmNcIjtcbn0pKGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGUgfHwgKGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGUgPSB7fSkpO1xudmFyIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlID0gZXhwb3J0cy5JU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZTtcbihmdW5jdGlvbiAoSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXApIHtcbiAgICBJU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cFtJU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cFtcIk1pc3NlZFwiXSA9ICdNaXNzZWQnXSA9IFwiTWlzc2VkXCI7XG4gICAgSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXBbSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXBbXCJBbGxcIl0gPSAnQWxsJ10gPSBcIkFsbFwiO1xufSkoZXhwb3J0cy5JU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cCB8fCAoZXhwb3J0cy5JU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cCA9IHt9KSk7XG52YXIgSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXAgPSBleHBvcnRzLklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwO1xuXG5cbi8qKiovIH0sXG4vKiA0MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9ncmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgQWNjb3VudEFjdGl2ZUNhbGxzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudEFjdGl2ZUNhbGxzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRBY3RpdmVDYWxscygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRBY3RpdmVDYWxscy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGNhbGxsb2dyZWNvcmQuQ2FsbExvZ1JlY29yZCwgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudEFjdGl2ZUNhbGxzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudEFjdGl2ZUNhbGxzJztcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50QWN0aXZlQ2FsbHM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRBY3RpdmVDYWxscyA9IEFjY291bnRBY3RpdmVDYWxscztcblxuXG4vKioqLyB9LFxuLyogNDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ2NhbGxlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbnZhciByZWNvcmRpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG52YXIgY2FsbGxvZ3JlY29yZGxlZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcbnZhciBDYWxsTG9nUmVjb3JkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsbExvZ1JlY29yZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsTG9nUmVjb3JkKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2FsbExvZ1JlY29yZC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXNzaW9uSWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Zyb20nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IENhbGxMb2dSZWNvcmRUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkaXJlY3Rpb24nLCBDbGFzczogQ2FsbExvZ1JlY29yZERpcmVjdGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYWN0aW9uJywgQ2xhc3M6IENhbGxMb2dSZWNvcmRBY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Jlc3VsdCcsIENsYXNzOiBDYWxsTG9nUmVjb3JkUmVzdWx0LCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGFydFRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2R1cmF0aW9uJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRpbmcnLCBDbGFzczogcmVjb3JkaW5naW5mby5SZWNvcmRpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsYXN0TW9kaWZpZWRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0cmFuc3BvcnQnLCBDbGFzczogQ2FsbExvZ1JlY29yZFRyYW5zcG9ydCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGVncycsIENsYXNzOiBjYWxsbG9ncmVjb3JkbGVnaW5mby5DYWxsTG9nUmVjb3JkTGVnSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDYWxsTG9nUmVjb3JkLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ2FsbExvZ1JlY29yZCc7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbExvZ1JlY29yZDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQ2FsbExvZ1JlY29yZCA9IENhbGxMb2dSZWNvcmQ7XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRUeXBlKSB7XG4gICAgQ2FsbExvZ1JlY29yZFR5cGVbQ2FsbExvZ1JlY29yZFR5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIENhbGxMb2dSZWNvcmRUeXBlW0NhbGxMb2dSZWNvcmRUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZFR5cGUgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZFR5cGUgPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRUeXBlID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkVHlwZTtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZERpcmVjdGlvbikge1xuICAgIENhbGxMb2dSZWNvcmREaXJlY3Rpb25bQ2FsbExvZ1JlY29yZERpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgQ2FsbExvZ1JlY29yZERpcmVjdGlvbltDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZERpcmVjdGlvbiB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkRGlyZWN0aW9uID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkRGlyZWN0aW9uID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkQWN0aW9uKSB7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJQaG9uZUNhbGxcIl0gPSAnUGhvbmUgQ2FsbCddID0gXCJQaG9uZUNhbGxcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJQaG9uZUxvZ2luXCJdID0gJ1Bob25lIExvZ2luJ10gPSBcIlBob25lTG9naW5cIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJJbmNvbWluZ0ZheFwiXSA9ICdJbmNvbWluZyBGYXgnXSA9IFwiSW5jb21pbmdGYXhcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJBY2NlcHRDYWxsXCJdID0gJ0FjY2VwdCBDYWxsJ10gPSBcIkFjY2VwdENhbGxcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJGaW5kTWVcIl0gPSAnRmluZE1lJ10gPSBcIkZpbmRNZVwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkZvbGxvd01lXCJdID0gJ0ZvbGxvd01lJ10gPSBcIkZvbGxvd01lXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiT3V0Z29pbmdGYXhcIl0gPSAnT3V0Z29pbmcgRmF4J10gPSBcIk91dGdvaW5nRmF4XCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiQ2FsbFJldHVyblwiXSA9ICdDYWxsIFJldHVybiddID0gXCJDYWxsUmV0dXJuXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiQ2FsbGluZ0NhcmRcIl0gPSAnQ2FsbGluZyBDYXJkJ10gPSBcIkNhbGxpbmdDYXJkXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ0RpcmVjdGx5XCJdID0gJ1JpbmcgRGlyZWN0bHknXSA9IFwiUmluZ0RpcmVjdGx5XCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ091dFdlYlwiXSA9ICdSaW5nT3V0IFdlYiddID0gXCJSaW5nT3V0V2ViXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiVm9JUENhbGxcIl0gPSAnVm9JUCBDYWxsJ10gPSBcIlZvSVBDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ091dFBDXCJdID0gJ1JpbmdPdXQgUEMnXSA9IFwiUmluZ091dFBDXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ01lXCJdID0gJ1JpbmdNZSddID0gXCJSaW5nTWVcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJUcmFuc2ZlclwiXSA9ICdUcmFuc2ZlciddID0gXCJUcmFuc2ZlclwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvblsnNDExSW5mbyddID0gJzQxMSBJbmZvJ10gPSAnNDExSW5mbyc7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiRW1lcmdlbmN5XCJdID0gJ0VtZXJnZW5jeSddID0gXCJFbWVyZ2VuY3lcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bJ0U5MTFVcGRhdGUnXSA9ICdFOTExIFVwZGF0ZSddID0gJ0U5MTFVcGRhdGUnO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlN1cHBvcnRcIl0gPSAnU3VwcG9ydCddID0gXCJTdXBwb3J0XCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ091dE1vYmlsZVwiXSA9ICdSaW5nT3V0IE1vYmlsZSddID0gXCJSaW5nT3V0TW9iaWxlXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRBY3Rpb24gfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZEFjdGlvbiA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZEFjdGlvbiA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZEFjdGlvbjtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZFJlc3VsdCkge1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVzdWx0SW5Qcm9ncmVzc1wiXSA9ICdSZXN1bHRJblByb2dyZXNzJ10gPSBcIlJlc3VsdEluUHJvZ3Jlc3NcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJNaXNzZWRcIl0gPSAnTWlzc2VkJ10gPSBcIk1pc3NlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxhY2NlcHRlZFwiXSA9ICdDYWxsIGFjY2VwdGVkJ10gPSBcIkNhbGxhY2NlcHRlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlZvaWNlbWFpbFwiXSA9ICdWb2ljZW1haWwnXSA9IFwiVm9pY2VtYWlsXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVqZWN0ZWRcIl0gPSAnUmVqZWN0ZWQnXSA9IFwiUmVqZWN0ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXBseVwiXSA9ICdSZXBseSddID0gXCJSZXBseVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlY2VpdmVkXCJdID0gJ1JlY2VpdmVkJ10gPSBcIlJlY2VpdmVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVjZWl2ZUVycm9yXCJdID0gJ1JlY2VpdmUgRXJyb3InXSA9IFwiUmVjZWl2ZUVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4b25EZW1hbmRcIl0gPSAnRmF4IG9uIERlbWFuZCddID0gXCJGYXhvbkRlbWFuZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlBhcnRpYWxSZWNlaXZlXCJdID0gJ1BhcnRpYWwgUmVjZWl2ZSddID0gXCJQYXJ0aWFsUmVjZWl2ZVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkJsb2NrZWRcIl0gPSAnQmxvY2tlZCddID0gXCJCbG9ja2VkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbGNvbm5lY3RlZFwiXSA9ICdDYWxsIGNvbm5lY3RlZCddID0gXCJDYWxsY29ubmVjdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiTm9BbnN3ZXJcIl0gPSAnTm8gQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSW50ZXJuYXRpb25hbERpc2FibGVkXCJdID0gJ0ludGVybmF0aW9uYWwgRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJTZW5kRXJyb3JcIl0gPSAnU2VuZCBFcnJvciddID0gXCJTZW5kRXJyb3JcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJTZW50XCJdID0gJ1NlbnQnXSA9IFwiU2VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIk5vZmF4bWFjaGluZVwiXSA9ICdObyBmYXggbWFjaGluZSddID0gXCJOb2ZheG1hY2hpbmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN1bHRFbXB0eVwiXSA9ICdSZXN1bHRFbXB0eSddID0gXCJSZXN1bHRFbXB0eVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkFjY291bnRcIl0gPSAnQWNjb3VudCddID0gXCJBY2NvdW50XCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsRmFpbGVkXCJdID0gJ0NhbGwgRmFpbGVkJ10gPSBcIkNhbGxGYWlsZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsRmFpbHVyZVwiXSA9ICdDYWxsIEZhaWx1cmUnXSA9IFwiQ2FsbEZhaWx1cmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hbEVycm9yXCJdID0gJ0ludGVybmFsIEVycm9yJ10gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJJUFBob25lb2ZmbGluZVwiXSA9ICdJUCBQaG9uZSBvZmZsaW5lJ10gPSBcIklQUGhvbmVvZmZsaW5lXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVzdHJpY3RlZE51bWJlclwiXSA9ICdSZXN0cmljdGVkIE51bWJlciddID0gXCJSZXN0cmljdGVkTnVtYmVyXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiV3JvbmdOdW1iZXJcIl0gPSAnV3JvbmcgTnVtYmVyJ10gPSBcIldyb25nTnVtYmVyXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU3RvcHBlZFwiXSA9ICdTdG9wcGVkJ10gPSBcIlN0b3BwZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJIYW5ndXBcIl0gPSAnSGFuZyB1cCddID0gXCJIYW5ndXBcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJQb29yTGluZVF1YWxpdHlcIl0gPSAnUG9vciBMaW5lIFF1YWxpdHknXSA9IFwiUG9vckxpbmVRdWFsaXR5XCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUGFydGlhbGx5U2VudFwiXSA9ICdQYXJ0aWFsbHkgU2VudCddID0gXCJQYXJ0aWFsbHlTZW50XCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSW50ZXJuYXRpb25hbFJlc3RyaWN0aW9uXCJdID0gJ0ludGVybmF0aW9uYWwgUmVzdHJpY3Rpb24nXSA9IFwiSW50ZXJuYXRpb25hbFJlc3RyaWN0aW9uXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQWJhbmRvbmVkXCJdID0gJ0FiYW5kb25lZCddID0gXCJBYmFuZG9uZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJEZWNsaW5lZFwiXSA9ICdEZWNsaW5lZCddID0gXCJEZWNsaW5lZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheFJlY2VpcHRFcnJvclwiXSA9ICdGYXggUmVjZWlwdCBFcnJvciddID0gXCJGYXhSZWNlaXB0RXJyb3JcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhTZW5kRXJyb3JcIl0gPSAnRmF4IFNlbmQgRXJyb3InXSA9IFwiRmF4U2VuZEVycm9yXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRSZXN1bHQgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZFJlc3VsdCA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZFJlc3VsdCA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZFJlc3VsdDtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZFRyYW5zcG9ydCkge1xuICAgIENhbGxMb2dSZWNvcmRUcmFuc3BvcnRbQ2FsbExvZ1JlY29yZFRyYW5zcG9ydFtcIlBTVE5cIl0gPSAnUFNUTiddID0gXCJQU1ROXCI7XG4gICAgQ2FsbExvZ1JlY29yZFRyYW5zcG9ydFtDYWxsTG9nUmVjb3JkVHJhbnNwb3J0W1wiVm9JUFwiXSA9ICdWb0lQJ10gPSBcIlZvSVBcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZFRyYW5zcG9ydCB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkVHJhbnNwb3J0ID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkVHJhbnNwb3J0ID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkVHJhbnNwb3J0O1xuXG5cbi8qKiovIH0sXG4vKiA0MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBDYWxsTG9nQ2FsbGVySW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGxMb2dDYWxsZXJJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGxMb2dDYWxsZXJJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2FsbExvZ0NhbGxlckluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGhvbmVOdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYXRpb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDYWxsTG9nQ2FsbGVySW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NhbGxMb2dDYWxsZXJJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBDYWxsTG9nQ2FsbGVySW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQ2FsbExvZ0NhbGxlckluZm8gPSBDYWxsTG9nQ2FsbGVySW5mbztcblxuXG4vKioqLyB9LFxuLyogNDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUmVjb3JkaW5nSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlY29yZGluZ0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVjb3JkaW5nSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJlY29yZGluZ0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBSZWNvcmRpbmdJbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFVyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFJlY29yZGluZ0luZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdSZWNvcmRpbmdJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBSZWNvcmRpbmdJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5SZWNvcmRpbmdJbmZvID0gUmVjb3JkaW5nSW5mbztcbihmdW5jdGlvbiAoUmVjb3JkaW5nSW5mb1R5cGUpIHtcbiAgICBSZWNvcmRpbmdJbmZvVHlwZVtSZWNvcmRpbmdJbmZvVHlwZVtcIkF1dG9tYXRpY1wiXSA9ICdBdXRvbWF0aWMnXSA9IFwiQXV0b21hdGljXCI7XG4gICAgUmVjb3JkaW5nSW5mb1R5cGVbUmVjb3JkaW5nSW5mb1R5cGVbXCJPbkRlbWFuZFwiXSA9ICdPbkRlbWFuZCddID0gXCJPbkRlbWFuZFwiO1xufSkoZXhwb3J0cy5SZWNvcmRpbmdJbmZvVHlwZSB8fCAoZXhwb3J0cy5SZWNvcmRpbmdJbmZvVHlwZSA9IHt9KSk7XG52YXIgUmVjb3JkaW5nSW5mb1R5cGUgPSBleHBvcnRzLlJlY29yZGluZ0luZm9UeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA0NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBleHRlbnNpb25pbmZvY2FsbGxvZyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xudmFyIGNhbGxsb2djYWxsZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG52YXIgcmVjb3JkaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xudmFyIENhbGxMb2dSZWNvcmRMZWdJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsbExvZ1JlY29yZExlZ0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsbExvZ1JlY29yZExlZ0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhY3Rpb24nLCBDbGFzczogQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RpcmVjdGlvbicsIENsYXNzOiBDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZHVyYXRpb24nLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbicsIENsYXNzOiBleHRlbnNpb25pbmZvY2FsbGxvZy5FeHRlbnNpb25JbmZvQ2FsbExvZywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGVnVHlwZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhcnRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IENhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVzdWx0JywgQ2xhc3M6IENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0LCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmcm9tJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0bycsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHJhbnNwb3J0JywgQ2xhc3M6IENhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0LCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRpbmcnLCBDbGFzczogcmVjb3JkaW5naW5mby5SZWNvcmRpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDYWxsTG9nUmVjb3JkTGVnSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbExvZ1JlY29yZExlZ0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvID0gQ2FsbExvZ1JlY29yZExlZ0luZm87XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uKSB7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiUGhvbmVDYWxsXCJdID0gJ1Bob25lIENhbGwnXSA9IFwiUGhvbmVDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJQaG9uZUxvZ2luXCJdID0gJ1Bob25lIExvZ2luJ10gPSBcIlBob25lTG9naW5cIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkluY29taW5nRmF4XCJdID0gJ0luY29taW5nIEZheCddID0gXCJJbmNvbWluZ0ZheFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiQWNjZXB0Q2FsbFwiXSA9ICdBY2NlcHQgQ2FsbCddID0gXCJBY2NlcHRDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJGaW5kTWVcIl0gPSAnRmluZE1lJ10gPSBcIkZpbmRNZVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiRm9sbG93TWVcIl0gPSAnRm9sbG93TWUnXSA9IFwiRm9sbG93TWVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIk91dGdvaW5nRmF4XCJdID0gJ091dGdvaW5nIEZheCddID0gXCJPdXRnb2luZ0ZheFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiQ2FsbFJldHVyblwiXSA9ICdDYWxsIFJldHVybiddID0gXCJDYWxsUmV0dXJuXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJDYWxsaW5nQ2FyZFwiXSA9ICdDYWxsaW5nIENhcmQnXSA9IFwiQ2FsbGluZ0NhcmRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlJpbmdEaXJlY3RseVwiXSA9ICdSaW5nIERpcmVjdGx5J10gPSBcIlJpbmdEaXJlY3RseVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiUmluZ091dFdlYlwiXSA9ICdSaW5nT3V0IFdlYiddID0gXCJSaW5nT3V0V2ViXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJWb0lQQ2FsbFwiXSA9ICdWb0lQIENhbGwnXSA9IFwiVm9JUENhbGxcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlJpbmdPdXRQQ1wiXSA9ICdSaW5nT3V0IFBDJ10gPSBcIlJpbmdPdXRQQ1wiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiUmluZ01lXCJdID0gJ1JpbmdNZSddID0gXCJSaW5nTWVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlRyYW5zZmVyXCJdID0gJ1RyYW5zZmVyJ10gPSBcIlRyYW5zZmVyXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bJzQxMUluZm8nXSA9ICc0MTEgSW5mbyddID0gJzQxMUluZm8nO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiRW1lcmdlbmN5XCJdID0gJ0VtZXJnZW5jeSddID0gXCJFbWVyZ2VuY3lcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvblsnRTkxMVVwZGF0ZSddID0gJ0U5MTEgVXBkYXRlJ10gPSAnRTkxMVVwZGF0ZSc7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJTdXBwb3J0XCJdID0gJ1N1cHBvcnQnXSA9IFwiU3VwcG9ydFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiUmluZ091dE1vYmlsZVwiXSA9ICdSaW5nT3V0IE1vYmlsZSddID0gXCJSaW5nT3V0TW9iaWxlXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbiA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb247XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uKSB7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb24gfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb24gPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlKSB7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlW0NhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlW0NhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZSB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGUgPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZSA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdCkge1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlc3VsdEluUHJvZ3Jlc3NcIl0gPSAnUmVzdWx0SW5Qcm9ncmVzcyddID0gXCJSZXN1bHRJblByb2dyZXNzXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJNaXNzZWRcIl0gPSAnTWlzc2VkJ10gPSBcIk1pc3NlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQ2FsbGFjY2VwdGVkXCJdID0gJ0NhbGwgYWNjZXB0ZWQnXSA9IFwiQ2FsbGFjY2VwdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJWb2ljZW1haWxcIl0gPSAnVm9pY2VtYWlsJ10gPSBcIlZvaWNlbWFpbFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUmVqZWN0ZWRcIl0gPSAnUmVqZWN0ZWQnXSA9IFwiUmVqZWN0ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlcGx5XCJdID0gJ1JlcGx5J10gPSBcIlJlcGx5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJSZWNlaXZlZFwiXSA9ICdSZWNlaXZlZCddID0gXCJSZWNlaXZlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUmVjZWl2ZUVycm9yXCJdID0gJ1JlY2VpdmUgRXJyb3InXSA9IFwiUmVjZWl2ZUVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJGYXhvbkRlbWFuZFwiXSA9ICdGYXggb24gRGVtYW5kJ10gPSBcIkZheG9uRGVtYW5kXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJQYXJ0aWFsUmVjZWl2ZVwiXSA9ICdQYXJ0aWFsIFJlY2VpdmUnXSA9IFwiUGFydGlhbFJlY2VpdmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkJsb2NrZWRcIl0gPSAnQmxvY2tlZCddID0gXCJCbG9ja2VkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJDYWxsY29ubmVjdGVkXCJdID0gJ0NhbGwgY29ubmVjdGVkJ10gPSBcIkNhbGxjb25uZWN0ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIk5vQW5zd2VyXCJdID0gJ05vIEFuc3dlciddID0gXCJOb0Fuc3dlclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiSW50ZXJuYXRpb25hbERpc2FibGVkXCJdID0gJ0ludGVybmF0aW9uYWwgRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJCdXN5XCJdID0gJ0J1c3knXSA9IFwiQnVzeVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiU2VuZEVycm9yXCJdID0gJ1NlbmQgRXJyb3InXSA9IFwiU2VuZEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJTZW50XCJdID0gJ1NlbnQnXSA9IFwiU2VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiTm9mYXhtYWNoaW5lXCJdID0gJ05vIGZheCBtYWNoaW5lJ10gPSBcIk5vZmF4bWFjaGluZVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUmVzdWx0RW1wdHlcIl0gPSAnUmVzdWx0RW1wdHknXSA9IFwiUmVzdWx0RW1wdHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkFjY291bnRcIl0gPSAnQWNjb3VudCddID0gXCJBY2NvdW50XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJTdXNwZW5kZWRcIl0gPSAnU3VzcGVuZGVkJ10gPSBcIlN1c3BlbmRlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQ2FsbEZhaWxlZFwiXSA9ICdDYWxsIEZhaWxlZCddID0gXCJDYWxsRmFpbGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJDYWxsRmFpbHVyZVwiXSA9ICdDYWxsIEZhaWx1cmUnXSA9IFwiQ2FsbEZhaWx1cmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkludGVybmFsRXJyb3JcIl0gPSAnSW50ZXJuYWwgRXJyb3InXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiSVBQaG9uZW9mZmxpbmVcIl0gPSAnSVAgUGhvbmUgb2ZmbGluZSddID0gXCJJUFBob25lb2ZmbGluZVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUmVzdHJpY3RlZE51bWJlclwiXSA9ICdSZXN0cmljdGVkIE51bWJlciddID0gXCJSZXN0cmljdGVkTnVtYmVyXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJXcm9uZ051bWJlclwiXSA9ICdXcm9uZyBOdW1iZXInXSA9IFwiV3JvbmdOdW1iZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlN0b3BwZWRcIl0gPSAnU3RvcHBlZCddID0gXCJTdG9wcGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJIYW5ndXBcIl0gPSAnSGFuZyB1cCddID0gXCJIYW5ndXBcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlBvb3JMaW5lUXVhbGl0eVwiXSA9ICdQb29yIExpbmUgUXVhbGl0eSddID0gXCJQb29yTGluZVF1YWxpdHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlBhcnRpYWxseVNlbnRcIl0gPSAnUGFydGlhbGx5IFNlbnQnXSA9IFwiUGFydGlhbGx5U2VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiSW50ZXJuYXRpb25hbFJlc3RyaWN0aW9uXCJdID0gJ0ludGVybmF0aW9uYWwgUmVzdHJpY3Rpb24nXSA9IFwiSW50ZXJuYXRpb25hbFJlc3RyaWN0aW9uXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJBYmFuZG9uZWRcIl0gPSAnQWJhbmRvbmVkJ10gPSBcIkFiYW5kb25lZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiRGVjbGluZWRcIl0gPSAnRGVjbGluZWQnXSA9IFwiRGVjbGluZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkZheFJlY2VpcHRFcnJvclwiXSA9ICdGYXggUmVjZWlwdCBFcnJvciddID0gXCJGYXhSZWNlaXB0RXJyb3JcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkZheFNlbmRFcnJvclwiXSA9ICdGYXggU2VuZCBFcnJvciddID0gXCJGYXhTZW5kRXJyb3JcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHQgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHQgPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0ID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdDtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnQpIHtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydFtDYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydFtcIlBTVE5cIl0gPSAnUFNUTiddID0gXCJQU1ROXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnRbQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnRbXCJWb0lQXCJdID0gJ1ZvSVAnXSA9IFwiVm9JUFwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydCB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydCA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnQgPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0O1xuXG5cbi8qKiovIH0sXG4vKiA0NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBFeHRlbnNpb25JbmZvQ2FsbExvZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkluZm9DYWxsTG9nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkluZm9DYWxsTG9nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uSW5mb0NhbGxMb2cucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkluZm9DYWxsTG9nLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uSW5mb0NhbGxMb2cnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkluZm9DYWxsTG9nO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25JbmZvQ2FsbExvZyA9IEV4dGVuc2lvbkluZm9DYWxsTG9nO1xuXG5cbi8qKiovIH0sXG4vKiA0NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9ncmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgQWNjb3VudENhbGxMb2cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50Q2FsbExvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50Q2FsbExvZygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRDYWxsTG9nLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogY2FsbGxvZ3JlY29yZC5DYWxsTG9nUmVjb3JkLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50Q2FsbExvZy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRDYWxsTG9nJztcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50Q2FsbExvZztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudENhbGxMb2cgPSBBY2NvdW50Q2FsbExvZztcblxuXG4vKioqLyB9LFxuLyogNDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ2NhbGxlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbnZhciByZWNvcmRpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG52YXIgQWNjb3VudENhbGxMb2dSZWNvcmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50Q2FsbExvZ1JlY29yZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50Q2FsbExvZ1JlY29yZCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Nlc3Npb25JZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZnJvbScsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndG8nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkaXJlY3Rpb24nLCBDbGFzczogQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FjdGlvbicsIENsYXNzOiBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVzdWx0JywgQ2xhc3M6IEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0LCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGFydFRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2R1cmF0aW9uJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRpbmcnLCBDbGFzczogcmVjb3JkaW5naW5mby5SZWNvcmRpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50Q2FsbExvZ1JlY29yZCc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudENhbGxMb2dSZWNvcmQ7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkID0gQWNjb3VudENhbGxMb2dSZWNvcmQ7XG4oZnVuY3Rpb24gKEFjY291bnRDYWxsTG9nUmVjb3JkVHlwZSkge1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkVHlwZVtBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkVHlwZVtBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZFR5cGUgfHwgKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlID0ge30pKTtcbnZhciBBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGUgPSBleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkVHlwZTtcbihmdW5jdGlvbiAoQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb24pIHtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbiB8fCAoZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbiA9IHt9KSk7XG52YXIgQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSBleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbikge1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lQ2FsbFwiXSA9ICdQaG9uZSBDYWxsJ10gPSBcIlBob25lQ2FsbFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUGhvbmVMb2dpblwiXSA9ICdQaG9uZSBMb2dpbiddID0gXCJQaG9uZUxvZ2luXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJJbmNvbWluZ0ZheFwiXSA9ICdJbmNvbWluZyBGYXgnXSA9IFwiSW5jb21pbmdGYXhcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIkFjY2VwdENhbGxcIl0gPSAnQWNjZXB0IENhbGwnXSA9IFwiQWNjZXB0Q2FsbFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiRmluZE1lXCJdID0gJ0ZpbmRNZSddID0gXCJGaW5kTWVcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIkZvbGxvd01lXCJdID0gJ0ZvbGxvd01lJ10gPSBcIkZvbGxvd01lXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJPdXRnb2luZ0ZheFwiXSA9ICdPdXRnb2luZyBGYXgnXSA9IFwiT3V0Z29pbmdGYXhcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxSZXR1cm5cIl0gPSAnQ2FsbCBSZXR1cm4nXSA9IFwiQ2FsbFJldHVyblwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiQ2FsbGluZ0NhcmRcIl0gPSAnQ2FsbGluZyBDYXJkJ10gPSBcIkNhbGxpbmdDYXJkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nRGlyZWN0bHlcIl0gPSAnUmluZyBEaXJlY3RseSddID0gXCJSaW5nRGlyZWN0bHlcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRXZWJcIl0gPSAnUmluZ091dCBXZWInXSA9IFwiUmluZ091dFdlYlwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiVm9JUENhbGxcIl0gPSAnVm9JUCBDYWxsJ10gPSBcIlZvSVBDYWxsXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0UENcIl0gPSAnUmluZ091dCBQQyddID0gXCJSaW5nT3V0UENcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdNZVwiXSA9ICdSaW5nTWUnXSA9IFwiUmluZ01lXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJUcmFuc2ZlclwiXSA9ICdUcmFuc2ZlciddID0gXCJUcmFuc2ZlclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uWyc0MTFJbmZvJ10gPSAnNDExIEluZm8nXSA9ICc0MTFJbmZvJztcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIkVtZXJnZW5jeVwiXSA9ICdFbWVyZ2VuY3knXSA9IFwiRW1lcmdlbmN5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bJ0U5MTFVcGRhdGUnXSA9ICdFOTExIFVwZGF0ZSddID0gJ0U5MTFVcGRhdGUnO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiU3VwcG9ydFwiXSA9ICdTdXBwb3J0J10gPSBcIlN1cHBvcnRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRNb2JpbGVcIl0gPSAnUmluZ091dCBNb2JpbGUnXSA9IFwiUmluZ091dE1vYmlsZVwiO1xufSkoZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbiB8fCAoZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbiA9IHt9KSk7XG52YXIgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24gPSBleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uO1xuKGZ1bmN0aW9uIChBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdCkge1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEluUHJvZ3Jlc3NcIl0gPSAnUmVzdWx0SW5Qcm9ncmVzcyddID0gXCJSZXN1bHRJblByb2dyZXNzXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJNaXNzZWRcIl0gPSAnTWlzc2VkJ10gPSBcIk1pc3NlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbGFjY2VwdGVkXCJdID0gJ0NhbGwgYWNjZXB0ZWQnXSA9IFwiQ2FsbGFjY2VwdGVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJWb2ljZW1haWxcIl0gPSAnVm9pY2VtYWlsJ10gPSBcIlZvaWNlbWFpbFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVqZWN0ZWRcIl0gPSAnUmVqZWN0ZWQnXSA9IFwiUmVqZWN0ZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlcGx5XCJdID0gJ1JlcGx5J10gPSBcIlJlcGx5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWNlaXZlZFwiXSA9ICdSZWNlaXZlZCddID0gXCJSZWNlaXZlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVjZWl2ZUVycm9yXCJdID0gJ1JlY2VpdmUgRXJyb3InXSA9IFwiUmVjZWl2ZUVycm9yXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhvbkRlbWFuZFwiXSA9ICdGYXggb24gRGVtYW5kJ10gPSBcIkZheG9uRGVtYW5kXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsUmVjZWl2ZVwiXSA9ICdQYXJ0aWFsIFJlY2VpdmUnXSA9IFwiUGFydGlhbFJlY2VpdmVcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkJsb2NrZWRcIl0gPSAnQmxvY2tlZCddID0gXCJCbG9ja2VkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsY29ubmVjdGVkXCJdID0gJ0NhbGwgY29ubmVjdGVkJ10gPSBcIkNhbGxjb25uZWN0ZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIk5vQW5zd2VyXCJdID0gJ05vIEFuc3dlciddID0gXCJOb0Fuc3dlclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSW50ZXJuYXRpb25hbERpc2FibGVkXCJdID0gJ0ludGVybmF0aW9uYWwgRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJCdXN5XCJdID0gJ0J1c3knXSA9IFwiQnVzeVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VuZEVycm9yXCJdID0gJ1NlbmQgRXJyb3InXSA9IFwiU2VuZEVycm9yXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJTZW50XCJdID0gJ1NlbnQnXSA9IFwiU2VudFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiTm9mYXhtYWNoaW5lXCJdID0gJ05vIGZheCBtYWNoaW5lJ10gPSBcIk5vZmF4bWFjaGluZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVzdWx0RW1wdHlcIl0gPSAnUmVzdWx0RW1wdHknXSA9IFwiUmVzdWx0RW1wdHlcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkFjY291bnRcIl0gPSAnQWNjb3VudCddID0gXCJBY2NvdW50XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdXNwZW5kZWRcIl0gPSAnU3VzcGVuZGVkJ10gPSBcIlN1c3BlbmRlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWxlZFwiXSA9ICdDYWxsIEZhaWxlZCddID0gXCJDYWxsRmFpbGVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsRmFpbHVyZVwiXSA9ICdDYWxsIEZhaWx1cmUnXSA9IFwiQ2FsbEZhaWx1cmVcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmFsRXJyb3JcIl0gPSAnSW50ZXJuYWwgRXJyb3InXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSVBQaG9uZW9mZmxpbmVcIl0gPSAnSVAgUGhvbmUgb2ZmbGluZSddID0gXCJJUFBob25lb2ZmbGluZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVzdHJpY3RlZE51bWJlclwiXSA9ICdSZXN0cmljdGVkIE51bWJlciddID0gXCJSZXN0cmljdGVkTnVtYmVyXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJXcm9uZ051bWJlclwiXSA9ICdXcm9uZyBOdW1iZXInXSA9IFwiV3JvbmdOdW1iZXJcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlN0b3BwZWRcIl0gPSAnU3RvcHBlZCddID0gXCJTdG9wcGVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJIYW5ndXBcIl0gPSAnSGFuZyB1cCddID0gXCJIYW5ndXBcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlBvb3JMaW5lUXVhbGl0eVwiXSA9ICdQb29yIExpbmUgUXVhbGl0eSddID0gXCJQb29yTGluZVF1YWxpdHlcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlBhcnRpYWxseVNlbnRcIl0gPSAnUGFydGlhbGx5IFNlbnQnXSA9IFwiUGFydGlhbGx5U2VudFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSW50ZXJuYXRpb25hbFJlc3RyaWN0aW9uXCJdID0gJ0ludGVybmF0aW9uYWwgUmVzdHJpY3Rpb24nXSA9IFwiSW50ZXJuYXRpb25hbFJlc3RyaWN0aW9uXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJBYmFuZG9uZWRcIl0gPSAnQWJhbmRvbmVkJ10gPSBcIkFiYW5kb25lZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRGVjbGluZWRcIl0gPSAnRGVjbGluZWQnXSA9IFwiRGVjbGluZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheFJlY2VpcHRFcnJvclwiXSA9ICdGYXggUmVjZWlwdCBFcnJvciddID0gXCJGYXhSZWNlaXB0RXJyb3JcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheFNlbmRFcnJvclwiXSA9ICdGYXggU2VuZCBFcnJvciddID0gXCJGYXhTZW5kRXJyb3JcIjtcbn0pKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHQgfHwgKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHQgPSB7fSkpO1xudmFyIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0ID0gZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdDtcblxuXG4vKioqLyB9LFxuLyogNDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEV4dGVuc2lvbkFjdGl2ZUNhbGxzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uQWN0aXZlQ2FsbHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uQWN0aXZlQ2FsbHMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25BY3RpdmVDYWxscy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGNhbGxsb2dyZWNvcmQuQ2FsbExvZ1JlY29yZCwgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uQWN0aXZlQ2FsbHMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25BY3RpdmVDYWxscyc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uQWN0aXZlQ2FsbHM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkFjdGl2ZUNhbGxzID0gRXh0ZW5zaW9uQWN0aXZlQ2FsbHM7XG5cblxuLyoqKi8gfSxcbi8qIDUwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2dyZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBFeHRlbnNpb25DYWxsTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uQ2FsbExvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25DYWxsTG9nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uQ2FsbExvZy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGNhbGxsb2dyZWNvcmQuQ2FsbExvZ1JlY29yZCwgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uQ2FsbExvZy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkNhbGxMb2cnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkNhbGxMb2c7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkNhbGxMb2cgPSBFeHRlbnNpb25DYWxsTG9nO1xuXG5cbi8qKiovIH0sXG4vKiA1MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9nY2FsbGVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xudmFyIHJlY29yZGluZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbnZhciBFeHRlbnNpb25DYWxsTG9nUmVjb3JkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXNzaW9uSWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Zyb20nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkaXJlY3Rpb24nLCBDbGFzczogRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYWN0aW9uJywgQ2xhc3M6IEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Jlc3VsdCcsIENsYXNzOiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0LCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGFydFRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2R1cmF0aW9uJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRpbmcnLCBDbGFzczogcmVjb3JkaW5naW5mby5SZWNvcmRpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkNhbGxMb2dSZWNvcmQnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQ7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmQgPSBFeHRlbnNpb25DYWxsTG9nUmVjb3JkO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZSkge1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZVtFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlIHx8IChleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlID0ge30pKTtcbnZhciBFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZSA9IGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGU7XG4oZnVuY3Rpb24gKEV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb24pIHtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb24gfHwgKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbiA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbiA9IGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbjtcbihmdW5jdGlvbiAoRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbikge1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiUGhvbmVDYWxsXCJdID0gJ1Bob25lIENhbGwnXSA9IFwiUGhvbmVDYWxsXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiUGhvbmVMb2dpblwiXSA9ICdQaG9uZSBMb2dpbiddID0gXCJQaG9uZUxvZ2luXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiSW5jb21pbmdGYXhcIl0gPSAnSW5jb21pbmcgRmF4J10gPSBcIkluY29taW5nRmF4XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiQWNjZXB0Q2FsbFwiXSA9ICdBY2NlcHQgQ2FsbCddID0gXCJBY2NlcHRDYWxsXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiRmluZE1lXCJdID0gJ0ZpbmRNZSddID0gXCJGaW5kTWVcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJGb2xsb3dNZVwiXSA9ICdGb2xsb3dNZSddID0gXCJGb2xsb3dNZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIk91dGdvaW5nRmF4XCJdID0gJ091dGdvaW5nIEZheCddID0gXCJPdXRnb2luZ0ZheFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxSZXR1cm5cIl0gPSAnQ2FsbCBSZXR1cm4nXSA9IFwiQ2FsbFJldHVyblwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxpbmdDYXJkXCJdID0gJ0NhbGxpbmcgQ2FyZCddID0gXCJDYWxsaW5nQ2FyZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdEaXJlY3RseVwiXSA9ICdSaW5nIERpcmVjdGx5J10gPSBcIlJpbmdEaXJlY3RseVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRXZWJcIl0gPSAnUmluZ091dCBXZWInXSA9IFwiUmluZ091dFdlYlwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlZvSVBDYWxsXCJdID0gJ1ZvSVAgQ2FsbCddID0gXCJWb0lQQ2FsbFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRQQ1wiXSA9ICdSaW5nT3V0IFBDJ10gPSBcIlJpbmdPdXRQQ1wiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdNZVwiXSA9ICdSaW5nTWUnXSA9IFwiUmluZ01lXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiVHJhbnNmZXJcIl0gPSAnVHJhbnNmZXInXSA9IFwiVHJhbnNmZXJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bJzQxMUluZm8nXSA9ICc0MTEgSW5mbyddID0gJzQxMUluZm8nO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkVtZXJnZW5jeVwiXSA9ICdFbWVyZ2VuY3knXSA9IFwiRW1lcmdlbmN5XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uWydFOTExVXBkYXRlJ10gPSAnRTkxMSBVcGRhdGUnXSA9ICdFOTExVXBkYXRlJztcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJTdXBwb3J0XCJdID0gJ1N1cHBvcnQnXSA9IFwiU3VwcG9ydFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRNb2JpbGVcIl0gPSAnUmluZ091dCBNb2JpbGUnXSA9IFwiUmluZ091dE1vYmlsZVwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uIHx8IChleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb24gPSB7fSkpO1xudmFyIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb24gPSBleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb247XG4oZnVuY3Rpb24gKEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHQpIHtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEluUHJvZ3Jlc3NcIl0gPSAnUmVzdWx0SW5Qcm9ncmVzcyddID0gXCJSZXN1bHRJblByb2dyZXNzXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiTWlzc2VkXCJdID0gJ01pc3NlZCddID0gXCJNaXNzZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsYWNjZXB0ZWRcIl0gPSAnQ2FsbCBhY2NlcHRlZCddID0gXCJDYWxsYWNjZXB0ZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJWb2ljZW1haWxcIl0gPSAnVm9pY2VtYWlsJ10gPSBcIlZvaWNlbWFpbFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVwbHlcIl0gPSAnUmVwbHknXSA9IFwiUmVwbHlcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWNlaXZlZFwiXSA9ICdSZWNlaXZlZCddID0gXCJSZWNlaXZlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlY2VpdmVFcnJvclwiXSA9ICdSZWNlaXZlIEVycm9yJ10gPSBcIlJlY2VpdmVFcnJvclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheG9uRGVtYW5kXCJdID0gJ0ZheCBvbiBEZW1hbmQnXSA9IFwiRmF4b25EZW1hbmRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsUmVjZWl2ZVwiXSA9ICdQYXJ0aWFsIFJlY2VpdmUnXSA9IFwiUGFydGlhbFJlY2VpdmVcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJCbG9ja2VkXCJdID0gJ0Jsb2NrZWQnXSA9IFwiQmxvY2tlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxjb25uZWN0ZWRcIl0gPSAnQ2FsbCBjb25uZWN0ZWQnXSA9IFwiQ2FsbGNvbm5lY3RlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIk5vQW5zd2VyXCJdID0gJ05vIEFuc3dlciddID0gXCJOb0Fuc3dlclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsIERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VuZEVycm9yXCJdID0gJ1NlbmQgRXJyb3InXSA9IFwiU2VuZEVycm9yXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb2ZheG1hY2hpbmVcIl0gPSAnTm8gZmF4IG1hY2hpbmUnXSA9IFwiTm9mYXhtYWNoaW5lXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVzdWx0RW1wdHlcIl0gPSAnUmVzdWx0RW1wdHknXSA9IFwiUmVzdWx0RW1wdHlcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJBY2NvdW50XCJdID0gJ0FjY291bnQnXSA9IFwiQWNjb3VudFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlN1c3BlbmRlZFwiXSA9ICdTdXNwZW5kZWQnXSA9IFwiU3VzcGVuZGVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWxlZFwiXSA9ICdDYWxsIEZhaWxlZCddID0gXCJDYWxsRmFpbGVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWx1cmVcIl0gPSAnQ2FsbCBGYWlsdXJlJ10gPSBcIkNhbGxGYWlsdXJlXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiSW50ZXJuYWxFcnJvclwiXSA9ICdJbnRlcm5hbCBFcnJvciddID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiSVBQaG9uZW9mZmxpbmVcIl0gPSAnSVAgUGhvbmUgb2ZmbGluZSddID0gXCJJUFBob25lb2ZmbGluZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3RyaWN0ZWROdW1iZXJcIl0gPSAnUmVzdHJpY3RlZCBOdW1iZXInXSA9IFwiUmVzdHJpY3RlZE51bWJlclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIldyb25nTnVtYmVyXCJdID0gJ1dyb25nIE51bWJlciddID0gXCJXcm9uZ051bWJlclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlN0b3BwZWRcIl0gPSAnU3RvcHBlZCddID0gXCJTdG9wcGVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiSGFuZ3VwXCJdID0gJ0hhbmcgdXAnXSA9IFwiSGFuZ3VwXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUG9vckxpbmVRdWFsaXR5XCJdID0gJ1Bvb3IgTGluZSBRdWFsaXR5J10gPSBcIlBvb3JMaW5lUXVhbGl0eVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlBhcnRpYWxseVNlbnRcIl0gPSAnUGFydGlhbGx5IFNlbnQnXSA9IFwiUGFydGlhbGx5U2VudFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiXSA9ICdJbnRlcm5hdGlvbmFsIFJlc3RyaWN0aW9uJ10gPSBcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkFiYW5kb25lZFwiXSA9ICdBYmFuZG9uZWQnXSA9IFwiQWJhbmRvbmVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiRGVjbGluZWRcIl0gPSAnRGVjbGluZWQnXSA9IFwiRGVjbGluZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhSZWNlaXB0RXJyb3JcIl0gPSAnRmF4IFJlY2VpcHQgRXJyb3InXSA9IFwiRmF4UmVjZWlwdEVycm9yXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4U2VuZEVycm9yXCJdID0gJ0ZheCBTZW5kIEVycm9yJ10gPSBcIkZheFNlbmRFcnJvclwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0IHx8IChleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHQgPSB7fSkpO1xudmFyIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHQgPSBleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHQ7XG5cblxuLyoqKi8gfSxcbi8qIDUyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2dyZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbnZhciBzeW5jaW5mb2NhbGxsb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcbnZhciBDYWxsTG9nU3luYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGxMb2dTeW5jLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGxMb2dTeW5jKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2FsbExvZ1N5bmMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBjYWxsbG9ncmVjb3JkLkNhbGxMb2dSZWNvcmQsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jSW5mbycsIENsYXNzOiBzeW5jaW5mb2NhbGxsb2cuU3luY0luZm9DYWxsTG9nLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2FsbExvZ1N5bmMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDYWxsTG9nU3luYyc7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbExvZ1N5bmM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNhbGxMb2dTeW5jID0gQ2FsbExvZ1N5bmM7XG5cblxuLyoqKi8gfSxcbi8qIDUzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFN5bmNJbmZvQ2FsbExvZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN5bmNJbmZvQ2FsbExvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTeW5jSW5mb0NhbGxMb2coKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTeW5jSW5mb0NhbGxMb2cucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY1R5cGUnLCBDbGFzczogU3luY0luZm9DYWxsTG9nU3luY1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUb2tlbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY1RpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBTeW5jSW5mb0NhbGxMb2cucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTeW5jSW5mb0NhbGxMb2cnO1xuICAgIH07XG4gICAgcmV0dXJuIFN5bmNJbmZvQ2FsbExvZztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuU3luY0luZm9DYWxsTG9nID0gU3luY0luZm9DYWxsTG9nO1xuKGZ1bmN0aW9uIChTeW5jSW5mb0NhbGxMb2dTeW5jVHlwZSkge1xuICAgIFN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlW1N5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlW1wiRlN5bmNcIl0gPSAnRlN5bmMnXSA9IFwiRlN5bmNcIjtcbiAgICBTeW5jSW5mb0NhbGxMb2dTeW5jVHlwZVtTeW5jSW5mb0NhbGxMb2dTeW5jVHlwZVtcIklTeW5jXCJdID0gJ0lTeW5jJ10gPSBcIklTeW5jXCI7XG59KShleHBvcnRzLlN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlIHx8IChleHBvcnRzLlN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlID0ge30pKTtcbnZhciBTeW5jSW5mb0NhbGxMb2dTeW5jVHlwZSA9IGV4cG9ydHMuU3luY0luZm9DYWxsTG9nU3luY1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDU0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIENhbGxSZWNvcmRpbmcgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxsUmVjb3JkaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGxSZWNvcmRpbmcoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDYWxsUmVjb3JkaW5nLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb250ZW50VXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb250ZW50VHlwZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZHVyYXRpb24nLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDYWxsUmVjb3JkaW5nLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ2FsbFJlY29yZGluZyc7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbFJlY29yZGluZztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQ2FsbFJlY29yZGluZyA9IENhbGxSZWNvcmRpbmc7XG5cblxuLyoqKi8gfSxcbi8qIDU1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBjb3VudHJ5bGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xudmFyIGRpY3Rpb25hcnljb3VudHJ5aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xudmFyIGxhbmd1YWdlbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xudmFyIGxhbmd1YWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIGRpY3Rpb25hcnlsb2NhdGlvbmxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcbnZhciBkaWN0aW9uYXJ5c2VjcmV0cXVlc3Rpb25saXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XG52YXIgc2VjcmV0cXVlc3Rpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XG52YXIgZGljdGlvbmFyeXNoaXBwaW5nb3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xudmFyIGRpY3Rpb25hcnlzdGF0ZWxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcbnZhciBkaWN0aW9uYXJ5c3RhdGVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG52YXIgZGljdGlvbmFyeXRpbWV6b25lbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xudmFyIGRpY3Rpb25hcnl0aW1lem9uZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcbnZhciBEaWN0aW9uYXJ5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGljdGlvbmFyeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IENvdW50cnkgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEwIChSZWxlYXNlIDYuMik8L3A+XG4gICAgICogPHA+UmV0dXJucyBhbGwgdGhlIGNvdW50cmllcyBhdmFpbGFibGUgZm9yIGNhbGxpbmcuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxpc3RDb3VudHJpZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L2NvdW50cnknLCBvcHRpb25zLCBleHBvcnRzLmxpc3RDb3VudHJpZXNPcHRpb25zKSwgY291bnRyeWxpc3QuQ291bnRyeUxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENvdW50cnlcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGluZm9ybWF0aW9uIG9uIHRoZSByZXF1aXJlZCBjb3VudHJ5LjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5sb2FkQ291bnRyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvY291bnRyeS97Y291bnRyeUlkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZENvdW50cnlPcHRpb25zKSwgZGljdGlvbmFyeWNvdW50cnlpbmZvLkRpY3Rpb25hcnlDb3VudHJ5SW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgTGFuZ3VhZ2UgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjE0IChSZWxlYXNlIDYuNik8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgc3VwcG9ydGVkIGxhbmd1YWdlcy48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubGlzdExhbmd1YWdlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvbGFuZ3VhZ2UnLCBvcHRpb25zLCBleHBvcnRzLmxpc3RMYW5ndWFnZXNPcHRpb25zKSwgbGFuZ3VhZ2VsaXN0Lkxhbmd1YWdlTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgTGFuZ3VhZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xNCAoUmVsZWFzZSA2LjYpPC9wPlxuICAgICAqIDxwPlJldHVybnMgbGFuZ3VhZ2UgYnkgaXRzIHJlc3BlY3RpdmUgSUQuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxvYWRMYW5ndWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvbGFuZ3VhZ2Uve2xhbmd1YWdlSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkTGFuZ3VhZ2VPcHRpb25zKSwgbGFuZ3VhZ2VpbmZvLkxhbmd1YWdlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgTG9jYXRpb24gTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEwIChSZWxlYXNlIDYuMik8L3A+XG4gICAgICogPHA+UmV0dXJucyBhbGwgdGhlIGF2YWlsYWJsZSBsb2NhdGlvbnMgZm9yIHRoZSBjZXJ0YWluIHN0YXRlLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5saXN0TG9jYXRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9sb2NhdGlvbicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdExvY2F0aW9uc09wdGlvbnMpLCBkaWN0aW9uYXJ5bG9jYXRpb25saXN0LkRpY3Rpb25hcnlMb2NhdGlvbkxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFNlY3JldCBRdWVzdGlvbiBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjAgKFJlbGVhc2UgNy40KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBsaXN0IG9mIHNlY3JldCBxdWVzdGlvbnMgZm9yIGEgc3BlY2lmaWMgbGFuZ3VhZ2UuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxpc3RTZWNyZXRRdWVzdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L3NlY3JldC1xdWVzdGlvbicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdFNlY3JldFF1ZXN0aW9uc09wdGlvbnMpLCBkaWN0aW9uYXJ5c2VjcmV0cXVlc3Rpb25saXN0LkRpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFNlY3JldCBRdWVzdGlvblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjIwIChSZWxlYXNlIDcuNCk8L3A+XG4gICAgICogPHA+UmV0dXJucyBhIHBhcnRpY3VsYXIgc2VjcmV0IHF1ZXN0aW9uIGluIHNwZWNpZmljIGxhbmd1YWdlIGJ5IHF1ZXN0aW9uIElELjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5sb2FkU2VjcmV0UXVlc3Rpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L3NlY3JldC1xdWVzdGlvbi9xdWVzdGlvbklkJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkU2VjcmV0UXVlc3Rpb25PcHRpb25zKSwgc2VjcmV0cXVlc3Rpb25pbmZvLlNlY3JldFF1ZXN0aW9uSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU2hpcHBpbmcgT3B0aW9uc1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjE2IChSZWxlYXNlIDcuMSk8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBkZXZpY2Ugc2hpcHBpbmcgb3B0aW9ucyB3aXRoIHRoZWlyIHByaWNlcywgYWNjb3JkaW5nIHRvIGJyYW5kLCB0aWVyLCBudW1iZXIgb2Ygb3JkZXJlZCBkZXZpY2VzLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5saXN0U2hpcHBpbmdPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9zaGlwcGluZy1vcHRpb25zJywgb3B0aW9ucywgZXhwb3J0cy5saXN0U2hpcHBpbmdPcHRpb25zT3B0aW9ucyksIGRpY3Rpb25hcnlzaGlwcGluZ29wdGlvbnMuRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU3RhdGUgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEwIChSZWxlYXNlIDYuMik8L3A+XG4gICAgICogPHA+UmV0dXJucyBhbGwgdGhlIHN0YXRlcyBmb3IgYSBjZXJ0YWluIGNvdW50cnkuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxvYWRsaXN0U3RhdGVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9zdGF0ZScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZGxpc3RTdGF0ZXNPcHRpb25zKSwgZGljdGlvbmFyeXN0YXRlbGlzdC5EaWN0aW9uYXJ5U3RhdGVMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBTdGF0ZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEwIChSZWxlYXNlIDYuMik8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgaW5mb3JtYXRpb24gb24gdGhlIHJlcXVpcmVkIHN0YXRlLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5sb2FkU3RhdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L3N0YXRlL3tzdGF0ZUlkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZFN0YXRlT3B0aW9ucyksIGRpY3Rpb25hcnlzdGF0ZWluZm8uRGljdGlvbmFyeVN0YXRlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgVGltZXpvbmUgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEwIChSZWxlYXNlIDYuMik8L3A+XG4gICAgICogPHA+UmV0dXJucyBhbGwgYXZhaWxhYmxlIHRpbWV6b25lcy48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubGlzdFRpbWV6b25lcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvdGltZXpvbmUnLCBvcHRpb25zLCBleHBvcnRzLmxpc3RUaW1lem9uZXNPcHRpb25zKSwgZGljdGlvbmFyeXRpbWV6b25lbGlzdC5EaWN0aW9uYXJ5VGltZXpvbmVMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBUaW1lem9uZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEwIChSZWxlYXNlIDYuMik8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgaW5mb3JtYXRpb24gb24gYSBjZXJ0YWluIHRpbWV6b25lLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5sb2FkVGltZXpvbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L3RpbWV6b25lL3t0aW1lem9uZUlkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZFRpbWV6b25lT3B0aW9ucyksIGRpY3Rpb25hcnl0aW1lem9uZWluZm8uRGljdGlvbmFyeVRpbWV6b25lSW5mbyk7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeTtcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5ID0gRGljdGlvbmFyeTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0Q291bnRyaWVzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RDb3VudHJpZXNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibG9naW5BbGxvd2VkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibnVtYmVyU2VsbGluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkQ291bnRyeSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQ291bnRyeU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjb3VudHJ5SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdExhbmd1YWdlcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0TGFuZ3VhZ2VzT3B0aW9ucyA9IFtdO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRMYW5ndWFnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkTGFuZ3VhZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibGFuZ3VhZ2VJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0TG9jYXRpb25zIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RMb2NhdGlvbnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwib3JkZXJCeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdExvY2F0aW9uc09yZGVyQnlcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJOcGFcIixcbiAgICAgICAgICAgIFwiQ2l0eVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0YXRlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIndpdGhOeHhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdFNlY3JldFF1ZXN0aW9ucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0U2VjcmV0UXVlc3Rpb25zT3B0aW9ucyA9IFtdO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRTZWNyZXRRdWVzdGlvbiBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkU2VjcmV0UXVlc3Rpb25PcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicXVlc3Rpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0U2hpcHBpbmdPcHRpb25zIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RTaGlwcGluZ09wdGlvbnNPcHRpb25zID0gW107XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZGxpc3RTdGF0ZXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZGxpc3RTdGF0ZXNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY291bnRyeUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ3aXRoUGhvbmVOdW1iZXJzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRTdGF0ZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkU3RhdGVPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3RhdGVJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0VGltZXpvbmVzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RUaW1lem9uZXNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRUaW1lem9uZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkVGltZXpvbmVPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidGltZXpvbmVJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbihmdW5jdGlvbiAoSUxpc3RMb2NhdGlvbnNPcmRlckJ5KSB7XG4gICAgSUxpc3RMb2NhdGlvbnNPcmRlckJ5W0lMaXN0TG9jYXRpb25zT3JkZXJCeVtcIk5wYVwiXSA9ICdOcGEnXSA9IFwiTnBhXCI7XG4gICAgSUxpc3RMb2NhdGlvbnNPcmRlckJ5W0lMaXN0TG9jYXRpb25zT3JkZXJCeVtcIkNpdHlcIl0gPSAnQ2l0eSddID0gXCJDaXR5XCI7XG59KShleHBvcnRzLklMaXN0TG9jYXRpb25zT3JkZXJCeSB8fCAoZXhwb3J0cy5JTGlzdExvY2F0aW9uc09yZGVyQnkgPSB7fSkpO1xudmFyIElMaXN0TG9jYXRpb25zT3JkZXJCeSA9IGV4cG9ydHMuSUxpc3RMb2NhdGlvbnNPcmRlckJ5O1xuXG5cbi8qKiovIH0sXG4vKiA1NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBkaWN0aW9uYXJ5Y291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBDb3VudHJ5TGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvdW50cnlMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvdW50cnlMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ291bnRyeUxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBkaWN0aW9uYXJ5Y291bnRyeWluZm8uRGljdGlvbmFyeUNvdW50cnlJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDb3VudHJ5TGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NvdW50cnlMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBDb3VudHJ5TGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQ291bnRyeUxpc3QgPSBDb3VudHJ5TGlzdDtcblxuXG4vKioqLyB9LFxuLyogNTcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRGljdGlvbmFyeUNvdW50cnlJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGljdGlvbmFyeUNvdW50cnlJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlDb3VudHJ5SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlDb3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsaW5nQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW1lcmdlbmN5Q2FsbGluZycsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lzb0NvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ251bWJlclNlbGxpbmcnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsb2dpbkFsbG93ZWQnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeUNvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeUNvdW50cnlJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5Q291bnRyeUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlDb3VudHJ5SW5mbyA9IERpY3Rpb25hcnlDb3VudHJ5SW5mbztcblxuXG4vKioqLyB9LFxuLyogNTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbGFuZ3VhZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgTGFuZ3VhZ2VMaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGFuZ3VhZ2VMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExhbmd1YWdlTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExhbmd1YWdlTGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBsYW5ndWFnZWluZm8uTGFuZ3VhZ2VJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBMYW5ndWFnZUxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdMYW5ndWFnZUxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIExhbmd1YWdlTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTGFuZ3VhZ2VMaXN0ID0gTGFuZ3VhZ2VMaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA1OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBsb2NhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBEaWN0aW9uYXJ5TG9jYXRpb25MaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGljdGlvbmFyeUxvY2F0aW9uTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5TG9jYXRpb25MaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGljdGlvbmFyeUxvY2F0aW9uTGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGxvY2F0aW9uaW5mby5Mb2NhdGlvbkluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5TG9jYXRpb25MaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeUxvY2F0aW9uTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeUxvY2F0aW9uTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeUxvY2F0aW9uTGlzdCA9IERpY3Rpb25hcnlMb2NhdGlvbkxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDYwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIExvY2F0aW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2F0aW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMb2NhdGlvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMb2NhdGlvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhcmVhQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2l0eScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbnBhJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdueHgnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXRlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTG9jYXRpb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTG9jYXRpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBMb2NhdGlvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkxvY2F0aW9uSW5mbyA9IExvY2F0aW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogNjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgc2VjcmV0cXVlc3Rpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IHNlY3JldHF1ZXN0aW9uaW5mby5TZWNyZXRRdWVzdGlvbkluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0ID0gRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdDtcblxuXG4vKioqLyB9LFxuLyogNjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgU2VjcmV0UXVlc3Rpb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VjcmV0UXVlc3Rpb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlY3JldFF1ZXN0aW9uSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNlY3JldFF1ZXN0aW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncXVlc3Rpb25UeXBlJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsYW5ndWFnZUlkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdxdWVzdGlvblRleHQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Nob3dJblNpZ25VcCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBTZWNyZXRRdWVzdGlvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTZWNyZXRRdWVzdGlvbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFNlY3JldFF1ZXN0aW9uSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuU2VjcmV0UXVlc3Rpb25JbmZvID0gU2VjcmV0UXVlc3Rpb25JbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA2MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBzaGlwcGluZ21ldGhvZGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcbnZhciBEaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdxdWFudGl0eScsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncHJpY2UnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21ldGhvZCcsIENsYXNzOiBzaGlwcGluZ21ldGhvZGluZm8uU2hpcHBpbmdNZXRob2RJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucyA9IERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnM7XG5cblxuLyoqKi8gfSxcbi8qIDY0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFNoaXBwaW5nTWV0aG9kSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNoaXBwaW5nTWV0aG9kSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaGlwcGluZ01ldGhvZEluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTaGlwcGluZ01ldGhvZEluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBTaGlwcGluZ01ldGhvZEluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTaGlwcGluZ01ldGhvZEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFNoaXBwaW5nTWV0aG9kSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuU2hpcHBpbmdNZXRob2RJbmZvID0gU2hpcHBpbmdNZXRob2RJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA2NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBkaWN0aW9uYXJ5c3RhdGVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRGljdGlvbmFyeVN0YXRlTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlTdGF0ZUxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeVN0YXRlTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlTdGF0ZUxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBkaWN0aW9uYXJ5c3RhdGVpbmZvLkRpY3Rpb25hcnlTdGF0ZUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlTdGF0ZUxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWN0aW9uYXJ5U3RhdGVMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5U3RhdGVMaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5U3RhdGVMaXN0ID0gRGljdGlvbmFyeVN0YXRlTGlzdDtcblxuXG4vKioqLyB9LFxuLyogNjYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgc3RhdGVjb3VudHJ5aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xudmFyIERpY3Rpb25hcnlTdGF0ZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5U3RhdGVJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlTdGF0ZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5U3RhdGVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvdW50cnknLCBDbGFzczogc3RhdGVjb3VudHJ5aW5mby5TdGF0ZUNvdW50cnlJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpc29Db2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeVN0YXRlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlTdGF0ZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlTdGF0ZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlTdGF0ZUluZm8gPSBEaWN0aW9uYXJ5U3RhdGVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA2NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTdGF0ZUNvdW50cnlJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RhdGVDb3VudHJ5SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGF0ZUNvdW50cnlJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3RhdGVDb3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU3RhdGVDb3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1N0YXRlQ291bnRyeUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlQ291bnRyeUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlN0YXRlQ291bnRyeUluZm8gPSBTdGF0ZUNvdW50cnlJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA2OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBkaWN0aW9uYXJ5dGltZXpvbmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRGljdGlvbmFyeVRpbWV6b25lTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlUaW1lem9uZUxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeVRpbWV6b25lTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlUaW1lem9uZUxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBkaWN0aW9uYXJ5dGltZXpvbmVpbmZvLkRpY3Rpb25hcnlUaW1lem9uZUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlUaW1lem9uZUxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWN0aW9uYXJ5VGltZXpvbmVMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5VGltZXpvbmVMaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5VGltZXpvbmVMaXN0ID0gRGljdGlvbmFyeVRpbWV6b25lTGlzdDtcblxuXG4vKioqLyB9LFxuLyogNjkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRGljdGlvbmFyeVRpbWV6b25lSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlUaW1lem9uZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeVRpbWV6b25lSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlUaW1lem9uZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGVzY3JpcHRpb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5VGltZXpvbmVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVRpbWV6b25lSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVRpbWV6b25lSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVRpbWV6b25lSW5mbyA9IERpY3Rpb25hcnlUaW1lem9uZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDcwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBleHRlbnNpb25saXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG52YXIgZXh0ZW5zaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgZXh0ZW5zaW9ucGhvbmVudW1iZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG52YXIgZXh0ZW5zaW9uZ3JhbnRsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG52YXIgZGVwYXJ0bWVudG1lbWJlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcbnZhciBFeHRlbnNpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMDwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBsaXN0IG9mIGV4dGVuc2lvbnMgY3JlYXRlZCBmb3IgYSBwYXJ0aWN1bGFyIGFjY291bnQuIEFsbCB0eXBlcyBvZiBleHRlbnNpb25zIGFyZSBpbmNsdWRlZCBpbiB0aGlzIGxpc3QuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUubGlzdEV4dGVuc2lvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEV4dGVuc2lvbnNPcHRpb25zKSwgZXh0ZW5zaW9ubGlzdC5FeHRlbnNpb25MaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gSW5mb1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjA8L3A+XG4gICAgICogPHA+UmV0dXJucyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBhIHBhcnRpY3VsYXIgZXh0ZW5zaW9uIG9mIGFuIGFjY291bnQuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5sb2FkRXh0ZW5zaW9uSW5mbyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRFeHRlbnNpb25JbmZvT3B0aW9ucyksIGV4dGVuc2lvbmluZm8uRXh0ZW5zaW9uSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIFBob25lIE51bWJlciBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBsaXN0IG9mIHBob25lIG51bWJlcnMgdGhhdCBhcmUgdXNlZCBieSBhIHBhcnRpY3VsYXIgZXh0ZW5zaW9uLCBhbmQgY2FuIGJlIGZpbHRlcmVkIGJ5IHRoZSBwaG9uZSBudW1iZXIgdHlwZS4gVGhlIHJldHVybmVkIGxpc3QgY29udGFpbnMgYWxsIG51bWJlcnMgd2hpY2ggYXJlIGRpcmVjdGx5IG1hcHBlZCB0byBhIGdpdmVuIGV4dGVuc2lvbiBwbHVzIHRoZSBmZWF0dXJlcyBhbmQgYWxzbyBjb21wYW55LWxldmVsIG51bWJlcnNcbiAgICAgKiAgICAgd2hpY2ggbWF5IGJlIHVzZWQgd2hlbiBwZXJmb3JtaW5nIGRpZmZlcmVudCBvcGVyYXRpb25zIG9uIGJlaGFsZiBvZiB0aGlzIGV4dGVuc2lvbi48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3Bob25lLW51bWJlcicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEV4dGVuc2lvblBob25lTnVtYmVyc09wdGlvbnMpLCBleHRlbnNpb25waG9uZW51bWJlcnMuRXh0ZW5zaW9uUGhvbmVOdW1iZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gR3JhbnQgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgZXh0ZW5zaW9uIGdyYW50cy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxpc3RFeHRlbnNpb25HcmFudHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2dyYW50Jywgb3B0aW9ucywgZXhwb3J0cy5saXN0RXh0ZW5zaW9uR3JhbnRzT3B0aW9ucyksIGV4dGVuc2lvbmdyYW50bGlzdC5FeHRlbnNpb25HcmFudExpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBQcm9maWxlIEltYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgZXh0ZW5zaW9uIHByb2ZpbGUgaW1hZ2UuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUubG9hZEV4dGVuc2lvblByb2ZpbGVJbWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJvZmlsZS1pbWFnZScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEV4dGVuc2lvblByb2ZpbGVJbWFnZU9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBFeHRlbnNpb24gUHJvZmlsZSBJbWFnZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGV4dGVuc2lvbiBwcm9maWxlIGltYWdlLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyBteSBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhpZ2g8L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5jcmVhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9wcm9maWxlLWltYWdlJywgb3B0aW9ucywgZXhwb3J0cy5jcmVhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2VPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgRXh0ZW5zaW9uIFByb2ZpbGUgSW1hZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5VcGRhdGVzIHRoZSBleHRlbnNpb24gcHJvZmlsZSBpbWFnZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgbXkgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IaWdoPC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUudXBkYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUFVUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9wcm9maWxlLWltYWdlJywgb3B0aW9ucywgZXhwb3J0cy51cGRhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2VPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIFByb2ZpbGUgSW1hZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBzY2FsZWQgcHJvZmlsZSBpbWFnZSBvZiBhbiBleHRlbnNpb24uPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUubG9hZEV4dGVuc2lvblNjYWxlZFByb2ZpbGVJbWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJvZmlsZS1pbWFnZS97c2NhbGVTaXplfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEV4dGVuc2lvblNjYWxlZFByb2ZpbGVJbWFnZU9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBEZXBhcnRtZW50IE1lbWJlciBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5saXN0RGVwYXJ0bWVudE1lbWJlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2RlcGFydG1lbnQve2RlcGFydG1lbnRJZH0vbWVtYmVycycsIG9wdGlvbnMsIGV4cG9ydHMubGlzdERlcGFydG1lbnRNZW1iZXJzT3B0aW9ucyksIGRlcGFydG1lbnRtZW1iZXJzLkRlcGFydG1lbnRNZW1iZXJzKTtcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb247XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uID0gRXh0ZW5zaW9uO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RFeHRlbnNpb25zIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RFeHRlbnNpb25zT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3RhdHVzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0RXh0ZW5zaW9uc1N0YXR1c1wiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkVuYWJsZWRcIixcbiAgICAgICAgICAgIFwiRGlzYWJsZWRcIixcbiAgICAgICAgICAgIFwiTm90QWN0aXZhdGVkXCIsXG4gICAgICAgICAgICBcIlVuYXNzaWduZWRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0RXh0ZW5zaW9uc1R5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJVc2VyXCIsXG4gICAgICAgICAgICBcIkZheFVzZXJcIixcbiAgICAgICAgICAgIFwiVmlydHVhbFVzZXJcIixcbiAgICAgICAgICAgIFwiRGlnaXRhbFVzZXJcIixcbiAgICAgICAgICAgIFwiRGVwYXJ0bWVudFwiLFxuICAgICAgICAgICAgXCJBbm5vdW5jZW1lbnRcIixcbiAgICAgICAgICAgIFwiVm9pY2VtYWlsXCIsXG4gICAgICAgICAgICBcIlNoYXJlZExpbmVzR3JvdXBcIixcbiAgICAgICAgICAgIFwiUGFnaW5nT25seUdyb3VwXCIsXG4gICAgICAgICAgICBcIkl2ck1lbnVcIixcbiAgICAgICAgICAgIFwiQXBwbGljYXRpb25FeHRlbnNpb25cIixcbiAgICAgICAgICAgIFwiUGFya0xvY2F0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRFeHRlbnNpb25JbmZvIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRFeHRlbnNpb25JbmZvT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidXNhZ2VUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiTWFpbkNvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiQ29tcGFueU51bWJlclwiLFxuICAgICAgICAgICAgXCJEaXJlY3ROdW1iZXJcIixcbiAgICAgICAgICAgIFwiQ29tcGFueUZheE51bWJlclwiLFxuICAgICAgICAgICAgXCJGb3J3YXJkZWROdW1iZXJcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEV4dGVuc2lvbkdyYW50cyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RXh0ZW5zaW9uR3JhbnRzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkRXh0ZW5zaW9uUHJvZmlsZUltYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRFeHRlbnNpb25Qcm9maWxlSW1hZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGNyZWF0ZUV4dGVuc2lvblByb2ZpbGVJbWFnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5jcmVhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHVwZGF0ZUV4dGVuc2lvblByb2ZpbGVJbWFnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy51cGRhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRFeHRlbnNpb25TY2FsZWRQcm9maWxlSW1hZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEV4dGVuc2lvblNjYWxlZFByb2ZpbGVJbWFnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzY2FsZVNpemVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdERlcGFydG1lbnRNZW1iZXJzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3REZXBhcnRtZW50TWVtYmVyc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRlcGFydG1lbnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbihmdW5jdGlvbiAoSUxpc3RFeHRlbnNpb25zU3RhdHVzKSB7XG4gICAgSUxpc3RFeHRlbnNpb25zU3RhdHVzW0lMaXN0RXh0ZW5zaW9uc1N0YXR1c1tcIkVuYWJsZWRcIl0gPSAnRW5hYmxlZCddID0gXCJFbmFibGVkXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zU3RhdHVzW0lMaXN0RXh0ZW5zaW9uc1N0YXR1c1tcIkRpc2FibGVkXCJdID0gJ0Rpc2FibGVkJ10gPSBcIkRpc2FibGVkXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zU3RhdHVzW0lMaXN0RXh0ZW5zaW9uc1N0YXR1c1tcIk5vdEFjdGl2YXRlZFwiXSA9ICdOb3RBY3RpdmF0ZWQnXSA9IFwiTm90QWN0aXZhdGVkXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zU3RhdHVzW0lMaXN0RXh0ZW5zaW9uc1N0YXR1c1tcIlVuYXNzaWduZWRcIl0gPSAnVW5hc3NpZ25lZCddID0gXCJVbmFzc2lnbmVkXCI7XG59KShleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1N0YXR1cyB8fCAoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbnNTdGF0dXMgPSB7fSkpO1xudmFyIElMaXN0RXh0ZW5zaW9uc1N0YXR1cyA9IGV4cG9ydHMuSUxpc3RFeHRlbnNpb25zU3RhdHVzO1xuKGZ1bmN0aW9uIChJTGlzdEV4dGVuc2lvbnNUeXBlKSB7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiVXNlclwiXSA9ICdVc2VyJ10gPSBcIlVzZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJGYXhVc2VyXCJdID0gJ0ZheFVzZXInXSA9IFwiRmF4VXNlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIlZpcnR1YWxVc2VyXCJdID0gJ1ZpcnR1YWxVc2VyJ10gPSBcIlZpcnR1YWxVc2VyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiRGlnaXRhbFVzZXJcIl0gPSAnRGlnaXRhbFVzZXInXSA9IFwiRGlnaXRhbFVzZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJEZXBhcnRtZW50XCJdID0gJ0RlcGFydG1lbnQnXSA9IFwiRGVwYXJ0bWVudFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIkFubm91bmNlbWVudFwiXSA9ICdBbm5vdW5jZW1lbnQnXSA9IFwiQW5ub3VuY2VtZW50XCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJTaGFyZWRMaW5lc0dyb3VwXCJdID0gJ1NoYXJlZExpbmVzR3JvdXAnXSA9IFwiU2hhcmVkTGluZXNHcm91cFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIlBhZ2luZ09ubHlHcm91cFwiXSA9ICdQYWdpbmdPbmx5R3JvdXAnXSA9IFwiUGFnaW5nT25seUdyb3VwXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiSXZyTWVudVwiXSA9ICdJdnJNZW51J10gPSBcIkl2ck1lbnVcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiXSA9ICdBcHBsaWNhdGlvbkV4dGVuc2lvbiddID0gXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIlBhcmtMb2NhdGlvblwiXSA9ICdQYXJrTG9jYXRpb24nXSA9IFwiUGFya0xvY2F0aW9uXCI7XG59KShleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1R5cGUgfHwgKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25zVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RFeHRlbnNpb25zVHlwZSA9IGV4cG9ydHMuSUxpc3RFeHRlbnNpb25zVHlwZTtcbihmdW5jdGlvbiAoSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGUpIHtcbiAgICBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtcIk1haW5Db21wYW55TnVtYmVyXCJdID0gJ01haW5Db21wYW55TnVtYmVyJ10gPSBcIk1haW5Db21wYW55TnVtYmVyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJBZGRpdGlvbmFsQ29tcGFueU51bWJlclwiXSA9ICdBZGRpdGlvbmFsQ29tcGFueU51bWJlciddID0gXCJBZGRpdGlvbmFsQ29tcGFueU51bWJlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQ29tcGFueU51bWJlclwiXSA9ICdDb21wYW55TnVtYmVyJ10gPSBcIkNvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkRpcmVjdE51bWJlclwiXSA9ICdEaXJlY3ROdW1iZXInXSA9IFwiRGlyZWN0TnVtYmVyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJDb21wYW55RmF4TnVtYmVyXCJdID0gJ0NvbXBhbnlGYXhOdW1iZXInXSA9IFwiQ29tcGFueUZheE51bWJlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiRm9yd2FyZGVkTnVtYmVyXCJdID0gJ0ZvcndhcmRlZE51bWJlciddID0gXCJGb3J3YXJkZWROdW1iZXJcIjtcbn0pKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGUgfHwgKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGUgPSB7fSkpO1xudmFyIElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlID0gZXhwb3J0cy5JTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZTtcblxuXG4vKioqLyB9LFxuLyogNzEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZXh0ZW5zaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRXh0ZW5zaW9uTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBleHRlbnNpb25pbmZvLkV4dGVuc2lvbkluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25MaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25MaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25MaXN0ID0gRXh0ZW5zaW9uTGlzdDtcblxuXG4vKioqLyB9LFxuLyogNzIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgcGhvbmVudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRXh0ZW5zaW9uUGhvbmVOdW1iZXJzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uUGhvbmVOdW1iZXJzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvblBob25lTnVtYmVycygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvblBob25lTnVtYmVycy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IHBob25lbnVtYmVyaW5mby5QaG9uZU51bWJlckluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvblBob25lTnVtYmVycy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvblBob25lTnVtYmVycyc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uUGhvbmVOdW1iZXJzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25QaG9uZU51bWJlcnMgPSBFeHRlbnNpb25QaG9uZU51bWJlcnM7XG5cblxuLyoqKi8gfSxcbi8qIDczICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGdyYW50aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEV4dGVuc2lvbkdyYW50TGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkdyYW50TGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25HcmFudExpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25HcmFudExpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBncmFudGluZm8uR3JhbnRJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25HcmFudExpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25HcmFudExpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkdyYW50TGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uR3JhbnRMaXN0ID0gRXh0ZW5zaW9uR3JhbnRMaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA3NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBleHRlbnNpb25pbmZvZ3JhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG52YXIgR3JhbnRJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JhbnRJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyYW50SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdyYW50SW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbicsIENsYXNzOiBleHRlbnNpb25pbmZvZ3JhbnRzLkV4dGVuc2lvbkluZm9HcmFudHMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NhbGxQaWNrdXAnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsTW9uaXRvcmluZycsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBHcmFudEluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdHcmFudEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEdyYW50SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuR3JhbnRJbmZvID0gR3JhbnRJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA3NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBFeHRlbnNpb25JbmZvR3JhbnRzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uSW5mb0dyYW50cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25JbmZvR3JhbnRzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50cy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uSW5mb0dyYW50cyc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uSW5mb0dyYW50cztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uSW5mb0dyYW50cyA9IEV4dGVuc2lvbkluZm9HcmFudHM7XG4oZnVuY3Rpb24gKEV4dGVuc2lvbkluZm9HcmFudHNUeXBlKSB7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJVc2VyXCJdID0gJ1VzZXInXSA9IFwiVXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiRmF4VXNlclwiXSA9ICdGYXggVXNlciddID0gXCJGYXhVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJWaXJ0dWFsVXNlclwiXSA9ICdWaXJ0dWFsVXNlciddID0gXCJWaXJ0dWFsVXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiRGlnaXRhbFVzZXJcIl0gPSAnRGlnaXRhbFVzZXInXSA9IFwiRGlnaXRhbFVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkRlcGFydG1lbnRcIl0gPSAnRGVwYXJ0bWVudCddID0gXCJEZXBhcnRtZW50XCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJBbm5vdW5jZW1lbnRcIl0gPSAnQW5ub3VuY2VtZW50J10gPSBcIkFubm91bmNlbWVudFwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIlNoYXJlZExpbmVzR3JvdXBcIl0gPSAnU2hhcmVkTGluZXNHcm91cCddID0gXCJTaGFyZWRMaW5lc0dyb3VwXCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJQYWdpbmdPbmx5XCJdID0gJ1BhZ2luZ09ubHknXSA9IFwiUGFnaW5nT25seVwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiSXZyTWVudVwiXSA9ICdJdnJNZW51J10gPSBcIkl2ck1lbnVcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCJdID0gJ0FwcGxpY2F0aW9uRXh0ZW5zaW9uJ10gPSBcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJQYXJrTG9jYXRpb25cIl0gPSAnUGFyayBMb2NhdGlvbiddID0gXCJQYXJrTG9jYXRpb25cIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGUgfHwgKGV4cG9ydHMuRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGUgPSB7fSkpO1xudmFyIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlID0gZXhwb3J0cy5FeHRlbnNpb25JbmZvR3JhbnRzVHlwZTtcblxuXG4vKioqLyB9LFxuLyogNzYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZXh0ZW5zaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRGVwYXJ0bWVudE1lbWJlcnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZXBhcnRtZW50TWVtYmVycywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZXBhcnRtZW50TWVtYmVycygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERlcGFydG1lbnRNZW1iZXJzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZXh0ZW5zaW9uaW5mby5FeHRlbnNpb25JbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEZXBhcnRtZW50TWVtYmVycy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RlcGFydG1lbnRNZW1iZXJzJztcbiAgICB9O1xuICAgIHJldHVybiBEZXBhcnRtZW50TWVtYmVycztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGVwYXJ0bWVudE1lbWJlcnMgPSBEZXBhcnRtZW50TWVtYmVycztcblxuXG4vKioqLyB9LFxuLyogNzcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIG1lc3NhZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XG52YXIgbWVzc2FnZWxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcbnZhciBtZXNzYWdlc3luYyA9IF9fd2VicGFja19yZXF1aXJlX18oODIpO1xudmFyIE1lc3NhZ2VzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVzc2FnZXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZXMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgUGFnZXIgTWVzc2FnZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+Q3JlYXRlcyBhbmQgc2VuZHMgYSBwYWdlciBtZXNzYWdlLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+SW50ZXJuYWxNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlNlbmRpbmcgYW5kIHJlY2VpdmluZyBpbnRyYS1jb21wYW55IHRleHQgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIE1lc3NhZ2VzLnByb3RvdHlwZS5zZW5kSW50ZXJuYWxNZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vY29tcGFueS1wYWdlcicsIG9wdGlvbnMsIGV4cG9ydHMuc2VuZEludGVybmFsTWVzc2FnZU9wdGlvbnMpLCBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgRmF4IE1lc3NhZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPkNyZWF0ZXMgYW5kIHNlbmRzL3Jlc2VuZHMgbmV3IGZheCBtZXNzYWdlLiBSZXNlbmQgY2FuIGJlIGRvbmUgaWYgc2VuZGluZyBmYWlsZWQuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5GYXhlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlNlbmRpbmcgYW5kIHJlY2VpdmluZyBmYXhlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUuc2VuZEZheE1lc3NhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9mYXgnLCBvcHRpb25zLCBleHBvcnRzLnNlbmRGYXhNZXNzYWdlT3B0aW9ucyksIG1lc3NhZ2VpbmZvLk1lc3NhZ2VJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBTTVMgTWVzc2FnZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+Q3JlYXRlcyBhbmQgc2VuZHMgbmV3IFNNUyBtZXNzYWdlLiBTZW5kaW5nIFNNUyBtZXNzYWdlcyBzaW11bHRhbmVvdXNseSB0byBkaWZmZXJlbnQgcmVjaXBpZW50cyBpcyBsaW1pdGVkIHVwIHRvIDUwIHJlcXVlc3RzIHBlciBtaW51dGU7IHJlbGV2YW50IGZvciBhbGwgY2xpZW50IGFwcGxpY2F0aW9ucy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlNNUzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlNlbmRpbmcgYW5kIHJlY2VpdmluZyBTTVMgKHRleHQpIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUuc2VuZFNNUyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3NtcycsIG9wdGlvbnMsIGV4cG9ydHMuc2VuZFNNU09wdGlvbnMpLCBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgTWVzc2FnZSBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBsaXN0IG9mIG1lc3NhZ2VzIGZyb20gYW4gZXh0ZW5zaW9uIG1haWxib3guPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIE1lc3NhZ2VzLnByb3RvdHlwZS5saXN0TWVzc2FnZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L21lc3NhZ2Utc3RvcmUnLCBvcHRpb25zLCBleHBvcnRzLmxpc3RNZXNzYWdlc09wdGlvbnMpLCBtZXNzYWdlbGlzdC5NZXNzYWdlTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgTWVzc2FnZShzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyBpbmRpdmlkdWFsIG1lc3NhZ2UgcmVjb3JkKHMpIGJ5IHRoZSBnaXZlbiBtZXNzYWdlIElEKHMpLiBUaGUgbGVuZ3RoIG9mIGluYm91bmQgbWVzc2FnZXMgaXMgdW5saW1pdGVkLiBCYXRjaCByZXF1ZXN0IGlzIHN1cHBvcnRlZCwgc2VlIEJhdGNoIFJlcXVlc3RzIGZvciBkZXRhaWxzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUubG9hZE1lc3NhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L21lc3NhZ2Utc3RvcmUve21lc3NhZ2VJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRNZXNzYWdlT3B0aW9ucyksIG1lc3NhZ2VpbmZvLk1lc3NhZ2VJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBNZXNzYWdlKHMpIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5VcGRhdGVzIG1lc3NhZ2UocykgYnkgSUQocykuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLCBzZWUgQmF0Y2ggUmVxdWVzdHMgZm9yIGRldGFpbHMuIEN1cnJlbnRseSwgb25seSB0aGUgbWVzc2FnZSByZWFkIHN0YXR1cyB1cGRhdGluZyBpcyBzdXBwb3J0ZWQuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0TWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUudXBkYXRlTWVzc2FnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BVVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vbWVzc2FnZS1zdG9yZS97bWVzc2FnZUlkfScsIG9wdGlvbnMsIGV4cG9ydHMudXBkYXRlTWVzc2FnZU9wdGlvbnMpLCBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgTWVzc2FnZShzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPkRlbGV0ZXMgbWVzc2FnZShzKSBieSB0aGUgZ2l2ZW4gbWVzc2FnZSBJRChzKS4gVGhlIGZpcnN0IGNhbGwgb2YgdGhpcyBtZXRob2QgdHJhbnNmZXJzIHRoZSBtZXNzYWdlIHRvIHRoZSAnRGVsZXRlJyBzdGF0dXMuIFRoZSBzZWNvbmQgY2FsbCB0cmFuc2ZlcnMgdGhlIGRlbGV0ZWQgbWVzc2FnZSB0byB0aGUgJ1B1cmdlZCcgc3RhdHVzLiBJZiBpdCBpcyByZXF1aXJlZCB0byBtYWtlIHRoZSBtZXNzYWdlICdQdXJnZWQnIGltbWVkaWF0ZWx5XG4gICAgICogICAgIChmcm9tIHRoZSBmaXJzdCBjYWxsKSwgdGhlbiBzZXQgdGhlIHF1ZXJ5IHBhcmFtZXRlciBwdXJnZSB0byAnVHJ1ZScuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLmRlbGV0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdERUxFVEUnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L21lc3NhZ2Utc3RvcmUve21lc3NhZ2VJZH0nLCBvcHRpb25zLCBleHBvcnRzLmRlbGV0ZU1lc3NhZ2VPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgTWVzc2FnZSBBdHRhY2htZW50XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNCAoUmVsZWFzZSA1LjEzKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHBhcnRpY3VsYXIgbWVzc2FnZSBhdHRhY2htZW50IGRhdGEgYXMgYSBtZWRpYSBzdHJlYW0uPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUubG9hZE1lc3NhZ2VBdHRhY2htZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN0b3JlL3ttZXNzYWdlSWR9L2NvbnRlbnQve2F0dGFjaG1lbnRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRNZXNzYWdlQXR0YWNobWVudE9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBNZXNzYWdlIFN5bmNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC40IChSZWxlYXNlIDUuMTMpPC9wPlxuICAgICAqIDxwPlByb3ZpZGVzIGZhY2lsaXRpZXMgdG8gc3luY2hyb25pemUgbWFpbGJveCBjb250ZW50IHN0b3JlZCBleHRlcm5hbGx5IHdpdGggc2VydmVyIHN0YXRlLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUuc3luY01lc3NhZ2VzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN5bmMnLCBvcHRpb25zLCBleHBvcnRzLnN5bmNNZXNzYWdlc09wdGlvbnMpLCBtZXNzYWdlc3luYy5NZXNzYWdlU3luYyk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZXM7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuTWVzc2FnZXMgPSBNZXNzYWdlcztcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBzZW5kSW50ZXJuYWxNZXNzYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnNlbmRJbnRlcm5hbE1lc3NhZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcImNyZWF0ZXBhZ2VybWVzc2FnZXJlcXVlc3QuQ3JlYXRlUGFnZXJNZXNzYWdlUmVxdWVzdFwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBzZW5kRmF4TWVzc2FnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5zZW5kRmF4TWVzc2FnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJub3Rlc1wiOiBcIlwiLFxuICAgICAgICBcInBhcmFtVHlwZVwiOiBcInBhdGhcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogXCJ+XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJhbGxvd011bHRpcGxlXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcIm5vdGVzXCI6IFwiXCIsXG4gICAgICAgIFwicGFyYW1UeXBlXCI6IFwicGF0aFwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiBcIn5cIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImFsbG93TXVsdGlwbGVcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiLFxuICAgICAgICBcImluXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIm11bHRpcGFydC9taXhlZDsgYm91bmRhcnk9Qm91bmRhcnlfMV8xNDQxMzkwMV8xMzYxODcxMDgwODg4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIkNvbnRlbnQtTGVuZ3RoXCIsXG4gICAgICAgIFwiaW5cIjogXCJoZWFkZXJcIixcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJjb25zdW1lc1wiOiBbXG4gICAgICAgICAgICBcIm11bHRpcGFydC9taXhlZDsgYm91bmRhcnk9Qm91bmRhcnlfMV8xNDQxMzkwMV8xMzYxODcxMDgwODg4XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiLS1Cb3VuZGFyeV8xXzE0NDEzOTAxXzEzNjE4NzEwODA4ODhcXG5Db250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cXG5cXG57XFxuICBcXFwidG9cXFwiOlt7XFxcInBob25lTnVtYmVyXFxcIjpcXFwiMTgwMDU2MzAwMDNcXFwifV0sXFxuICBcXFwiZmF4UmVzb2x1dGlvblxcXCI6XFxcIkhpZ2hcXFwiLFxcbiAgXFxcInNlbmRUaW1lXFxcIjpcXFwiMjAxMy0wMi0yNlQwOTozMToyMC44ODJaXFxcIlxcbn1cXG5cXG4tLUJvdW5kYXJ5XzFfMTQ0MTM5MDFfMTM2MTg3MTA4MDg4OFxcbkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpblxcblxcbkhlbGxvLCBXb3JsZCFcXG5cXG4tLUJvdW5kYXJ5XzFfMTQ0MTM5MDFfMTM2MTg3MTA4MDg4OC0tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBzZW5kU01TIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnNlbmRTTVNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcImNyZWF0ZXNtc21lc3NhZ2UuQ3JlYXRlU01TTWVzc2FnZVwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0TWVzc2FnZXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdE1lc3NhZ2VzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImF2YWlsYWJpbGl0eVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5XCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiQWxpdmVcIixcbiAgICAgICAgICAgIFwiRGVsZXRlZFwiLFxuICAgICAgICAgICAgXCJQdXJnZWRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjb252ZXJzYXRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZUZyb21cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0TWVzc2FnZXNEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlzdGluY3RDb252ZXJzYXRpb25zXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibWVzc2FnZVR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiRmF4XCIsXG4gICAgICAgICAgICBcIlNNU1wiLFxuICAgICAgICAgICAgXCJWb2ljZU1haWxcIixcbiAgICAgICAgICAgIFwiUGFnZXJcIixcbiAgICAgICAgICAgIFwiVGV4dFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInJlYWRTdGF0dXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXNcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJSZWFkXCIsXG4gICAgICAgICAgICBcIlVucmVhZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBob25lTnVtYmVyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZE1lc3NhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZE1lc3NhZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibWVzc2FnZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHVwZGF0ZU1lc3NhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlTWVzc2FnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJtZXNzYWdlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidXBkYXRlbWVzc2FnZXJlcXVlc3QuVXBkYXRlTWVzc2FnZVJlcXVlc3RcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgZGVsZXRlTWVzc2FnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5kZWxldGVNZXNzYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm1lc3NhZ2VJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInB1cmdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY29udmVyc2F0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkTWVzc2FnZUF0dGFjaG1lbnQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZE1lc3NhZ2VBdHRhY2htZW50T3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImF0dGFjaG1lbnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm1lc3NhZ2VJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBzeW5jTWVzc2FnZXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuc3luY01lc3NhZ2VzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNvbnZlcnNhdGlvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlRnJvbVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZVRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSVN5bmNNZXNzYWdlc0RpcmVjdGlvblwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkluYm91bmRcIixcbiAgICAgICAgICAgIFwiT3V0Ym91bmRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXN0aW5jdENvbnZlcnNhdGlvbnNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJtZXNzYWdlVHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJGYXhcIixcbiAgICAgICAgICAgIFwiU01TXCIsXG4gICAgICAgICAgICBcIlZvaWNlTWFpbFwiLFxuICAgICAgICAgICAgXCJQYWdlclwiLFxuICAgICAgICAgICAgXCJUZXh0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicmVjb3JkQ291bnRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN5bmNUb2tlblwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3luY1R5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSVN5bmNNZXNzYWdlc1N5bmNUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiRlN5bmNcIixcbiAgICAgICAgICAgIFwiSVN5bmNcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4oZnVuY3Rpb24gKElMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHkpIHtcbiAgICBJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5W0lMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHlbXCJBbGl2ZVwiXSA9ICdBbGl2ZSddID0gXCJBbGl2ZVwiO1xuICAgIElMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHlbSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVtcIkRlbGV0ZWRcIl0gPSAnRGVsZXRlZCddID0gXCJEZWxldGVkXCI7XG4gICAgSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVtJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5W1wiUHVyZ2VkXCJdID0gJ1B1cmdlZCddID0gXCJQdXJnZWRcIjtcbn0pKGV4cG9ydHMuSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eSB8fCAoZXhwb3J0cy5JTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5ID0ge30pKTtcbnZhciBJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5ID0gZXhwb3J0cy5JTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5O1xuKGZ1bmN0aW9uIChJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uKSB7XG4gICAgSUxpc3RNZXNzYWdlc0RpcmVjdGlvbltJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uW0lMaXN0TWVzc2FnZXNEaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5JTGlzdE1lc3NhZ2VzRGlyZWN0aW9uIHx8IChleHBvcnRzLklMaXN0TWVzc2FnZXNEaXJlY3Rpb24gPSB7fSkpO1xudmFyIElMaXN0TWVzc2FnZXNEaXJlY3Rpb24gPSBleHBvcnRzLklMaXN0TWVzc2FnZXNEaXJlY3Rpb247XG4oZnVuY3Rpb24gKElMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZSkge1xuICAgIElMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVtJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xuICAgIElMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVtJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbXCJTTVNcIl0gPSAnU01TJ10gPSBcIlNNU1wiO1xuICAgIElMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVtJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbXCJWb2ljZU1haWxcIl0gPSAnVm9pY2VNYWlsJ10gPSBcIlZvaWNlTWFpbFwiO1xuICAgIElMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVtJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbXCJQYWdlclwiXSA9ICdQYWdlciddID0gXCJQYWdlclwiO1xuICAgIElMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVtJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbXCJUZXh0XCJdID0gJ1RleHQnXSA9IFwiVGV4dFwiO1xufSkoZXhwb3J0cy5JTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMuSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlID0ge30pKTtcbnZhciBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGUgPSBleHBvcnRzLklMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXMpIHtcbiAgICBJTGlzdE1lc3NhZ2VzUmVhZFN0YXR1c1tJTGlzdE1lc3NhZ2VzUmVhZFN0YXR1c1tcIlJlYWRcIl0gPSAnUmVhZCddID0gXCJSZWFkXCI7XG4gICAgSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXNbSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXNbXCJVbnJlYWRcIl0gPSAnVW5yZWFkJ10gPSBcIlVucmVhZFwiO1xufSkoZXhwb3J0cy5JTGlzdE1lc3NhZ2VzUmVhZFN0YXR1cyB8fCAoZXhwb3J0cy5JTGlzdE1lc3NhZ2VzUmVhZFN0YXR1cyA9IHt9KSk7XG52YXIgSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXMgPSBleHBvcnRzLklMaXN0TWVzc2FnZXNSZWFkU3RhdHVzO1xuKGZ1bmN0aW9uIChJU3luY01lc3NhZ2VzRGlyZWN0aW9uKSB7XG4gICAgSVN5bmNNZXNzYWdlc0RpcmVjdGlvbltJU3luY01lc3NhZ2VzRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBJU3luY01lc3NhZ2VzRGlyZWN0aW9uW0lTeW5jTWVzc2FnZXNEaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5JU3luY01lc3NhZ2VzRGlyZWN0aW9uIHx8IChleHBvcnRzLklTeW5jTWVzc2FnZXNEaXJlY3Rpb24gPSB7fSkpO1xudmFyIElTeW5jTWVzc2FnZXNEaXJlY3Rpb24gPSBleHBvcnRzLklTeW5jTWVzc2FnZXNEaXJlY3Rpb247XG4oZnVuY3Rpb24gKElTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZSkge1xuICAgIElTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZVtJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xuICAgIElTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZVtJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbXCJTTVNcIl0gPSAnU01TJ10gPSBcIlNNU1wiO1xuICAgIElTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZVtJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbXCJWb2ljZU1haWxcIl0gPSAnVm9pY2VNYWlsJ10gPSBcIlZvaWNlTWFpbFwiO1xuICAgIElTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZVtJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbXCJQYWdlclwiXSA9ICdQYWdlciddID0gXCJQYWdlclwiO1xuICAgIElTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZVtJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbXCJUZXh0XCJdID0gJ1RleHQnXSA9IFwiVGV4dFwiO1xufSkoZXhwb3J0cy5JU3luY01lc3NhZ2VzTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMuSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlID0ge30pKTtcbnZhciBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGUgPSBleHBvcnRzLklTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoSVN5bmNNZXNzYWdlc1N5bmNUeXBlKSB7XG4gICAgSVN5bmNNZXNzYWdlc1N5bmNUeXBlW0lTeW5jTWVzc2FnZXNTeW5jVHlwZVtcIkZTeW5jXCJdID0gJ0ZTeW5jJ10gPSBcIkZTeW5jXCI7XG4gICAgSVN5bmNNZXNzYWdlc1N5bmNUeXBlW0lTeW5jTWVzc2FnZXNTeW5jVHlwZVtcIklTeW5jXCJdID0gJ0lTeW5jJ10gPSBcIklTeW5jXCI7XG59KShleHBvcnRzLklTeW5jTWVzc2FnZXNTeW5jVHlwZSB8fCAoZXhwb3J0cy5JU3luY01lc3NhZ2VzU3luY1R5cGUgPSB7fSkpO1xudmFyIElTeW5jTWVzc2FnZXNTeW5jVHlwZSA9IGV4cG9ydHMuSVN5bmNNZXNzYWdlc1N5bmNUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA3OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBtZXNzYWdlYXR0YWNobWVudGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KTtcbnZhciBtZXNzYWdlc3RvcmVjYWxsZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MCk7XG52YXIgTWVzc2FnZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1lc3NhZ2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2F0dGFjaG1lbnRzJywgQ2xhc3M6IG1lc3NhZ2VhdHRhY2htZW50aW5mby5NZXNzYWdlQXR0YWNobWVudEluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYXZhaWxhYmlsaXR5JywgQ2xhc3M6IE1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5LCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb252ZXJzYXRpb25JZCcsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY3JlYXRpb25UaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkZWxpdmVyeUVycm9yQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGlyZWN0aW9uJywgQ2xhc3M6IE1lc3NhZ2VJbmZvRGlyZWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmYXhQYWdlQ291bnQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZheFJlc29sdXRpb24nLCBDbGFzczogTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmcm9tJywgQ2xhc3M6IG1lc3NhZ2VzdG9yZWNhbGxlcmluZm8uTWVzc2FnZVN0b3JlQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFzdE1vZGlmaWVkVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbWVzc2FnZVN0YXR1cycsIENsYXNzOiBNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BnVG9EZXBhcnRtZW50JywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncHJpb3JpdHknLCBDbGFzczogTWVzc2FnZUluZm9Qcmlvcml0eSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVhZFN0YXR1cycsIENsYXNzOiBNZXNzYWdlSW5mb1JlYWRTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Ntc0RlbGl2ZXJ5VGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc21zU2VuZGluZ0F0dGVtcHRzQ291bnQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N1YmplY3QnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvJywgQ2xhc3M6IG1lc3NhZ2VzdG9yZWNhbGxlcmluZm8uTWVzc2FnZVN0b3JlQ2FsbGVySW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IE1lc3NhZ2VJbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndm1UcmFuc2NyaXB0aW9uU3RhdHVzJywgQ2xhc3M6IE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNZXNzYWdlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VJbmZvID0gTWVzc2FnZUluZm87XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5KSB7XG4gICAgTWVzc2FnZUluZm9BdmFpbGFiaWxpdHlbTWVzc2FnZUluZm9BdmFpbGFiaWxpdHlbXCJBbGl2ZVwiXSA9ICdBbGl2ZSddID0gXCJBbGl2ZVwiO1xuICAgIE1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5W01lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5W1wiRGVsZXRlZFwiXSA9ICdEZWxldGVkJ10gPSBcIkRlbGV0ZWRcIjtcbiAgICBNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eVtNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eVtcIlB1cmdlZFwiXSA9ICdQdXJnZWQnXSA9IFwiUHVyZ2VkXCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5IHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5ID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSA9IGV4cG9ydHMuTWVzc2FnZUluZm9BdmFpbGFiaWxpdHk7XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvRGlyZWN0aW9uKSB7XG4gICAgTWVzc2FnZUluZm9EaXJlY3Rpb25bTWVzc2FnZUluZm9EaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIE1lc3NhZ2VJbmZvRGlyZWN0aW9uW01lc3NhZ2VJbmZvRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZUluZm9EaXJlY3Rpb24gfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9EaXJlY3Rpb24gPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvRGlyZWN0aW9uID0gZXhwb3J0cy5NZXNzYWdlSW5mb0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uKSB7XG4gICAgTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uW01lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbltcIkhpZ2hcIl0gPSAnSGlnaCddID0gXCJIaWdoXCI7XG4gICAgTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uW01lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbltcIkxvd1wiXSA9ICdMb3cnXSA9IFwiTG93XCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbiB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb0ZheFJlc29sdXRpb24gPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbiA9IGV4cG9ydHMuTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXMpIHtcbiAgICBNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW1wiUXVldWVkXCJdID0gJ1F1ZXVlZCddID0gXCJRdWV1ZWRcIjtcbiAgICBNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW1wiRGVsaXZlcmVkXCJdID0gJ0RlbGl2ZXJlZCddID0gXCJEZWxpdmVyZWRcIjtcbiAgICBNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW1wiRGVsaXZlcnlGYWlsZWRcIl0gPSAnRGVsaXZlcnlGYWlsZWQnXSA9IFwiRGVsaXZlcnlGYWlsZWRcIjtcbiAgICBNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW1wiU2VuZGluZ0ZhaWxlZFwiXSA9ICdTZW5kaW5nRmFpbGVkJ10gPSBcIlNlbmRpbmdGYWlsZWRcIjtcbiAgICBNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzIHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1cyA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzID0gZXhwb3J0cy5NZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXM7XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvUHJpb3JpdHkpIHtcbiAgICBNZXNzYWdlSW5mb1ByaW9yaXR5W01lc3NhZ2VJbmZvUHJpb3JpdHlbXCJOb3JtYWxcIl0gPSAnTm9ybWFsJ10gPSBcIk5vcm1hbFwiO1xuICAgIE1lc3NhZ2VJbmZvUHJpb3JpdHlbTWVzc2FnZUluZm9Qcmlvcml0eVtcIkhpZ2hcIl0gPSAnSGlnaCddID0gXCJIaWdoXCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvUHJpb3JpdHkgfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9Qcmlvcml0eSA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9Qcmlvcml0eSA9IGV4cG9ydHMuTWVzc2FnZUluZm9Qcmlvcml0eTtcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9SZWFkU3RhdHVzKSB7XG4gICAgTWVzc2FnZUluZm9SZWFkU3RhdHVzW01lc3NhZ2VJbmZvUmVhZFN0YXR1c1tcIlJlYWRcIl0gPSAnUmVhZCddID0gXCJSZWFkXCI7XG4gICAgTWVzc2FnZUluZm9SZWFkU3RhdHVzW01lc3NhZ2VJbmZvUmVhZFN0YXR1c1tcIlVucmVhZFwiXSA9ICdVbnJlYWQnXSA9IFwiVW5yZWFkXCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvUmVhZFN0YXR1cyB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb1JlYWRTdGF0dXMgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvUmVhZFN0YXR1cyA9IGV4cG9ydHMuTWVzc2FnZUluZm9SZWFkU3RhdHVzO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb1R5cGUpIHtcbiAgICBNZXNzYWdlSW5mb1R5cGVbTWVzc2FnZUluZm9UeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbiAgICBNZXNzYWdlSW5mb1R5cGVbTWVzc2FnZUluZm9UeXBlW1wiU01TXCJdID0gJ1NNUyddID0gXCJTTVNcIjtcbiAgICBNZXNzYWdlSW5mb1R5cGVbTWVzc2FnZUluZm9UeXBlW1wiVm9pY2VNYWlsXCJdID0gJ1ZvaWNlTWFpbCddID0gXCJWb2ljZU1haWxcIjtcbiAgICBNZXNzYWdlSW5mb1R5cGVbTWVzc2FnZUluZm9UeXBlW1wiUGFnZXJcIl0gPSAnUGFnZXInXSA9IFwiUGFnZXJcIjtcbiAgICBNZXNzYWdlSW5mb1R5cGVbTWVzc2FnZUluZm9UeXBlW1wiVGV4dFwiXSA9ICdUZXh0J10gPSBcIlRleHRcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZUluZm9UeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvVHlwZSA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9UeXBlID0gZXhwb3J0cy5NZXNzYWdlSW5mb1R5cGU7XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzKSB7XG4gICAgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbXCJOb3RBdmFpbGFibGVcIl0gPSAnTm90QXZhaWxhYmxlJ10gPSBcIk5vdEF2YWlsYWJsZVwiO1xuICAgIE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW01lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW1wiSW5Qcm9ncmVzc1wiXSA9ICdJblByb2dyZXNzJ10gPSBcIkluUHJvZ3Jlc3NcIjtcbiAgICBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tcIlRpbWVkT3V0XCJdID0gJ1RpbWVkT3V0J10gPSBcIlRpbWVkT3V0XCI7XG4gICAgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbXCJDb21wbGV0ZWRcIl0gPSAnQ29tcGxldGVkJ10gPSBcIkNvbXBsZXRlZFwiO1xuICAgIE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW01lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW1wiQ29tcGxldGVkUGFydGlhbGx5XCJdID0gJ0NvbXBsZXRlZFBhcnRpYWxseSddID0gXCJDb21wbGV0ZWRQYXJ0aWFsbHlcIjtcbiAgICBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tcIkZhaWxlZFwiXSA9ICdGYWlsZWQnXSA9IFwiRmFpbGVkXCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzIHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cyA9IGV4cG9ydHMuTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXM7XG5cblxuLyoqKi8gfSxcbi8qIDc5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE1lc3NhZ2VBdHRhY2htZW50SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VBdHRhY2htZW50SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlQXR0YWNobWVudEluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb250ZW50VHlwZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndm1EdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE1lc3NhZ2VBdHRhY2htZW50SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VBdHRhY2htZW50SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZUF0dGFjaG1lbnRJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5NZXNzYWdlQXR0YWNobWVudEluZm8gPSBNZXNzYWdlQXR0YWNobWVudEluZm87XG4oZnVuY3Rpb24gKE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGUpIHtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW01lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbXCJBdWRpb1JlY29yZGluZ1wiXSA9ICdBdWRpb1JlY29yZGluZyddID0gXCJBdWRpb1JlY29yZGluZ1wiO1xuICAgIE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtcIkF1ZGlvVHJhbnNjcmlwdGlvblwiXSA9ICdBdWRpb1RyYW5zY3JpcHRpb24nXSA9IFwiQXVkaW9UcmFuc2NyaXB0aW9uXCI7XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW1wiVGV4dFwiXSA9ICdUZXh0J10gPSBcIlRleHRcIjtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW01lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbXCJTb3VyY2VEb2N1bWVudFwiXSA9ICdTb3VyY2VEb2N1bWVudCddID0gXCJTb3VyY2VEb2N1bWVudFwiO1xuICAgIE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtcIlJlbmRlcmVkRG9jdW1lbnRcIl0gPSAnUmVuZGVyZWREb2N1bWVudCddID0gXCJSZW5kZXJlZERvY3VtZW50XCI7XG59KShleHBvcnRzLk1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGUgfHwgKGV4cG9ydHMuTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZSA9IHt9KSk7XG52YXIgTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZSA9IGV4cG9ydHMuTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogODAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgTWVzc2FnZVN0b3JlQ2FsbGVySW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VTdG9yZUNhbGxlckluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVN0b3JlQ2FsbGVySW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xvY2F0aW9uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdtZXNzYWdlU3RhdHVzJywgQ2xhc3M6IE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmYXhFcnJvckNvZGUnLCBDbGFzczogTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGhvbmVOdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTWVzc2FnZVN0b3JlQ2FsbGVySW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZVN0b3JlQ2FsbGVySW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTWVzc2FnZVN0b3JlQ2FsbGVySW5mbyA9IE1lc3NhZ2VTdG9yZUNhbGxlckluZm87XG4oZnVuY3Rpb24gKE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzKSB7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbXCJRdWV1ZWRcIl0gPSAnUXVldWVkJ10gPSBcIlF1ZXVlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tcIkRlbGl2ZXJlZFwiXSA9ICdEZWxpdmVyZWQnXSA9IFwiRGVsaXZlcmVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbXCJEZWxpdmVyeUZhaWxlZFwiXSA9ICdEZWxpdmVyeUZhaWxlZCddID0gXCJEZWxpdmVyeUZhaWxlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW1wiU2VuZGluZ0ZhaWxlZFwiXSA9ICdTZW5kaW5nRmFpbGVkJ10gPSBcIlNlbmRpbmdGYWlsZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tcIlJlY2VpdmVkXCJdID0gJ1JlY2VpdmVkJ10gPSBcIlJlY2VpdmVkXCI7XG59KShleHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzIHx8IChleHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzID0ge30pKTtcbnZhciBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cyA9IGV4cG9ydHMuTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXM7XG4oZnVuY3Rpb24gKE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGUpIHtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJVbmRlZmluZWRcIl0gPSAnVW5kZWZpbmVkJ10gPSBcIlVuZGVmaW5lZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIk5vRmF4U2VuZFBlcm1pc3Npb25cIl0gPSAnTm9GYXhTZW5kUGVybWlzc2lvbiddID0gXCJOb0ZheFNlbmRQZXJtaXNzaW9uXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiTm9JbnRlcm5hdGlvbmFsUGVybWlzc2lvblwiXSA9ICdOb0ludGVybmF0aW9uYWxQZXJtaXNzaW9uJ10gPSBcIk5vSW50ZXJuYXRpb25hbFBlcm1pc3Npb25cIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJOb0ZheE1hY2hpbmVcIl0gPSAnTm9GYXhNYWNoaW5lJ10gPSBcIk5vRmF4TWFjaGluZVwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIk91dGdvaW5nQ2FsbEVycm9yXCJdID0gJ091dGdvaW5nQ2FsbEVycm9yJ10gPSBcIk91dGdvaW5nQ2FsbEVycm9yXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiUmVuZGVyaW5nRmFpbGVkXCJdID0gJ1JlbmRlcmluZ0ZhaWxlZCddID0gXCJSZW5kZXJpbmdGYWlsZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJUb29NYW55UGFnZXNcIl0gPSAnVG9vTWFueVBhZ2VzJ10gPSBcIlRvb01hbnlQYWdlc1wiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlJldHVyblRvREJRdWV1ZVwiXSA9ICdSZXR1cm5Ub0RCUXVldWUnXSA9IFwiUmV0dXJuVG9EQlF1ZXVlXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiTm9DYWxsVGltZVwiXSA9ICdOb0NhbGxUaW1lJ10gPSBcIk5vQ2FsbFRpbWVcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJXcm9uZ051bWJlclwiXSA9ICdXcm9uZ051bWJlciddID0gXCJXcm9uZ051bWJlclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlByb2hpYml0ZWROdW1iZXJcIl0gPSAnUHJvaGliaXRlZE51bWJlciddID0gXCJQcm9oaWJpdGVkTnVtYmVyXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiSW50ZXJuYWxFcnJvclwiXSA9ICdJbnRlcm5hbEVycm9yJ10gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJGYXhTZW5kaW5nUHJvaGliaXRlZFwiXSA9ICdGYXhTZW5kaW5nUHJvaGliaXRlZCddID0gXCJGYXhTZW5kaW5nUHJvaGliaXRlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlRoZVBob25lSXNCbGFja2xpc3RlZFwiXSA9ICdUaGVQaG9uZUlzQmxhY2tsaXN0ZWQnXSA9IFwiVGhlUGhvbmVJc0JsYWNrbGlzdGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiVXNlck5vdEZvdW5kXCJdID0gJ1VzZXJOb3RGb3VuZCddID0gXCJVc2VyTm90Rm91bmRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJDb252ZXJ0RXJyb3JcIl0gPSAnQ29udmVydEVycm9yJ10gPSBcIkNvbnZlcnRFcnJvclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIkRCR2VuZXJhbEVycm9yXCJdID0gJ0RCR2VuZXJhbEVycm9yJ10gPSBcIkRCR2VuZXJhbEVycm9yXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiU2t5cGVCaWxsaW5nRmFpbGVkXCJdID0gJ1NreXBlQmlsbGluZ0ZhaWxlZCddID0gXCJTa3lwZUJpbGxpbmdGYWlsZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJBY2NvdW50U3VzcGVuZGVkXCJdID0gJ0FjY291bnRTdXNwZW5kZWQnXSA9IFwiQWNjb3VudFN1c3BlbmRlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlByb2hpYml0ZWREZXN0aW5hdGlvblwiXSA9ICdQcm9oaWJpdGVkRGVzdGluYXRpb24nXSA9IFwiUHJvaGliaXRlZERlc3RpbmF0aW9uXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiSW50ZXJuYXRpb25hbERpc2FibGVkXCJdID0gJ0ludGVybmF0aW9uYWxEaXNhYmxlZCddID0gXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZSB8fCAoZXhwb3J0cy5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlID0ge30pKTtcbnZhciBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlID0gZXhwb3J0cy5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlO1xuXG5cbi8qKiovIH0sXG4vKiA4MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBtZXNzYWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIE1lc3NhZ2VMaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVzc2FnZUxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZUxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlTGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IG1lc3NhZ2VpbmZvLk1lc3NhZ2VJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNZXNzYWdlTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTWVzc2FnZUxpc3QgPSBNZXNzYWdlTGlzdDtcblxuXG4vKioqLyB9LFxuLyogODIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbWVzc2FnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KTtcbnZhciBtZXNzYWdlc3N5bmNpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Myk7XG52YXIgTWVzc2FnZVN5bmMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlU3luYywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlU3luYygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1lc3NhZ2VTeW5jLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogbWVzc2FnZWluZm8uTWVzc2FnZUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jSW5mbycsIENsYXNzOiBtZXNzYWdlc3N5bmNpbmZvLk1lc3NhZ2VzU3luY0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE1lc3NhZ2VTeW5jLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTWVzc2FnZVN5bmMnO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VTeW5jO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5NZXNzYWdlU3luYyA9IE1lc3NhZ2VTeW5jO1xuXG5cbi8qKiovIH0sXG4vKiA4MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBNZXNzYWdlc1N5bmNJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVzc2FnZXNTeW5jSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlc1N5bmNJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVzc2FnZXNTeW5jSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jVHlwZScsIENsYXNzOiBNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUb2tlbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY1RpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNZXNzYWdlc1N5bmNJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTWVzc2FnZXNTeW5jSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZXNTeW5jSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTWVzc2FnZXNTeW5jSW5mbyA9IE1lc3NhZ2VzU3luY0luZm87XG4oZnVuY3Rpb24gKE1lc3NhZ2VzU3luY0luZm9TeW5jVHlwZSkge1xuICAgIE1lc3NhZ2VzU3luY0luZm9TeW5jVHlwZVtNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGVbXCJGU3luY1wiXSA9ICdGU3luYyddID0gXCJGU3luY1wiO1xuICAgIE1lc3NhZ2VzU3luY0luZm9TeW5jVHlwZVtNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGVbXCJJU3luY1wiXSA9ICdJU3luYyddID0gXCJJU3luY1wiO1xufSkoZXhwb3J0cy5NZXNzYWdlc1N5bmNJbmZvU3luY1R5cGUgfHwgKGV4cG9ydHMuTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlID0ge30pKTtcbnZhciBNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGUgPSBleHBvcnRzLk1lc3NhZ2VzU3luY0luZm9TeW5jVHlwZTtcblxuXG4vKioqLyB9LFxuLyogODQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGdldHN1YnNjcmlwdGlvbmluZm9yZXNwb25zZSA9IF9fd2VicGFja19yZXF1aXJlX18oODUpO1xudmFyIE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgU3Vic2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNiAoUmVsZWFzZSA1LjE1KTwvcD5cbiAgICAgKiA8cD5DcmVhdGVzIGEgbmV3IHN1YnNjcmlwdGlvbi4gVG8gY2FsbCB0aGlzIG1ldGhvZCB3aXRoIEFQTlMgdHJhbnNwb3J0IHR5cGUgeW91IGhhdmUgdG8gc3BlY2lmeSBlbmRwb2ludF9pZCBhdHRyaWJ1dGUgaW4gZ2V0IHRva2VuIHJlcXVlc3QgYXQgYXV0aG9yaXphdGlvbi48L3A+XG4gICAgICogPGg0PlVzYWdlIFBsYW4gR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uJywgb3B0aW9ucywgZXhwb3J0cy5jcmVhdGVPcHRpb25zKSwgZ2V0c3Vic2NyaXB0aW9uaW5mb3Jlc3BvbnNlLkdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU3Vic2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNiAoUmVsZWFzZSA1LjE1KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSByZXF1ZXN0ZWQgc3Vic2NyaXB0aW9uLjwvcD5cbiAgICAgKiA8aDQ+VXNhZ2UgUGxhbiBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbi97c3Vic2NyaXB0aW9uSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkT3B0aW9ucyksIGdldHN1YnNjcmlwdGlvbmluZm9yZXNwb25zZS5HZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVuZXcgU3Vic2NyaXB0aW9uIC8gTW9kaWZ5IEV2ZW50IEZpbHRlcnNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC42IChSZWxlYXNlIDUuMTUpPC9wPlxuICAgICAqIDxwPldpdGggZW1wdHkgcmVxdWVzdCBib2R5IC0gcmVuZXdzIHRoZSBleGlzdGVudCBzdWJzY3JpcHRpb24uIElmIGV2ZW50IGZpbHRlcnMgc3BlY2lmaWVkIC0gbW9kaWZpZXMgdGhlIGV2ZW50IGZpbHRlcnMgZm9yIHRoZSBleGlzdGluZyBzdWJzY3JpcHRpb24uIFRoZSBjbGllbnQgYXBwbGljYXRpb24gY2FuIGV4dGVuZCBvciBuYXJyb3cgdGhlIGV2ZW50cyBmb3Igd2hpY2ggaXQgcmVjZWl2ZXMgbm90aWZpY2F0aW9ucyBpbiB0aGUgZnJhbWVcbiAgICAgKiAgICAgb2Ygb25lIHN1YnNjcmlwdGlvbi48L3A+XG4gICAgICogPGg0PlVzYWdlIFBsYW4gR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24ve3N1YnNjcmlwdGlvbklkfScsIG9wdGlvbnMsIGV4cG9ydHMudXBkYXRlT3B0aW9ucyksIGdldHN1YnNjcmlwdGlvbmluZm9yZXNwb25zZS5HZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIFN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPkNhbmNlbHMgdGhlIGV4aXN0ZW50IHN1YnNjcmlwdGlvbi48L3A+XG4gICAgICogPGg0PlVzYWdlIFBsYW4gR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdERUxFVEUnLCAnL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24ve3N1YnNjcmlwdGlvbklkfScsIG9wdGlvbnMsIGV4cG9ydHMucmVtb3ZlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEk7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSSA9IE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEk7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgY3JlYXRlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmNyZWF0ZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcImNyZWF0ZXN1YnNjcmlwdGlvbnJlcXVlc3QuQ3JlYXRlU3Vic2NyaXB0aW9uUmVxdWVzdFwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdWJzY3JpcHRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN1YnNjcmlwdGlvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcInR5cGVcIjogXCJtb2RpZnlzdWJzY3JpcHRpb25yZXF1ZXN0Lk1vZGlmeVN1YnNjcmlwdGlvblJlcXVlc3RcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciByZW1vdmUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMucmVtb3ZlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN1YnNjcmlwdGlvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuXG5cbi8qKiovIH0sXG4vKiA4NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBub3RpZmljYXRpb25kZWxpdmVyeW1vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2KTtcbnZhciBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V2ZW50RmlsdGVycycsIENsYXNzOiBudWxsIC8qIHN0cmluZ1tdICovLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4cGlyYXRpb25UaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHBpcmVzSW4nLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXR1cycsIENsYXNzOiBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NyZWF0aW9uVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGVsaXZlcnlNb2RlJywgQ2xhc3M6IG5vdGlmaWNhdGlvbmRlbGl2ZXJ5bW9kZS5Ob3RpZmljYXRpb25EZWxpdmVyeU1vZGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZS5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0dldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZSc7XG4gICAgfTtcbiAgICByZXR1cm4gR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5HZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UgPSBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2U7XG4oZnVuY3Rpb24gKEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1cykge1xuICAgIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1c1tHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXNbXCJBY3RpdmVcIl0gPSAnQWN0aXZlJ10gPSBcIkFjdGl2ZVwiO1xuICAgIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1c1tHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXNbXCJTdXNwZW5kZWRcIl0gPSAnU3VzcGVuZGVkJ10gPSBcIlN1c3BlbmRlZFwiO1xufSkoZXhwb3J0cy5HZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXMgfHwgKGV4cG9ydHMuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzID0ge30pKTtcbnZhciBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXMgPSBleHBvcnRzLkdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1cztcblxuXG4vKioqLyB9LFxuLyogODYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0cmFuc3BvcnRUeXBlJywgQ2xhc3M6IE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5jcnlwdGlvbicsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYWRkcmVzcycsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdWJzY3JpYmVyS2V5JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlbmNyeXB0aW9uQWxnb3JpdGhtJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlbmNyeXB0aW9uS2V5JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWdpc3RyYXRpb25JZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2VydGlmaWNhdGVOYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlJztcbiAgICB9O1xuICAgIHJldHVybiBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGU7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSA9IE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZTtcbihmdW5jdGlvbiAoTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZSkge1xuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtcIlB1Yk51YlwiXSA9ICdQdWJOdWInXSA9IFwiUHViTnViXCI7XG4gICAgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlW1wiQVBOU1wiXSA9ICdBUE5TJ10gPSBcIkFQTlNcIjtcbiAgICBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlW05vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbJ1B1Yk51Yi9BUE5TL1ZvSVAnXSA9ICdQdWJOdWIvQVBOUy9Wb0lQJ10gPSAnUHViTnViL0FQTlMvVm9JUCc7XG4gICAgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlW1wiV2ViSG9va1wiXSA9ICdXZWJIb29rJ10gPSBcIldlYkhvb2tcIjtcbn0pKGV4cG9ydHMuTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZSB8fCAoZXhwb3J0cy5Ob3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlID0ge30pKTtcbnZhciBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlID0gZXhwb3J0cy5Ob3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA4NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgcHJlc2VuY2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XG52YXIgbW9uaXRvcmVkZXh0ZW5zaW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oOTApO1xudmFyIFByZXNlbmNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJlc2VuY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJlc2VuY2UoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uKHMpIFByZXNlbmNlIFN0YXR1cyBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyBwcmVzZW5jZSBzdGF0dXMgb2YgYW4gZXh0ZW5zaW9uIG9yIHNldmVyYWwgZXh0ZW5zaW9ucyBieSB0aGVpciBJRChzKS4gQmF0Y2ggcmVxdWVzdCBpcyBzdXBwb3J0ZWQsIHNlZSBCYXRjaCBSZXF1ZXN0cyBmb3IgZGV0YWlscy5UaGUgcHJlc2VuY2VTdGF0dXMgaXMgcmV0dXJuZWQgYXMgT2ZmbGluZSAodGhlIHBhcmFtZXRlcnMgdGVsZXBob255U3RhdHVzLCBtZXNzYWdlLCB1c2VyU3RhdHVzIGFuZCBkbmRTdGF0dXMgYXJlIG5vdFxuICAgICAqICAgICByZXR1cm5lZCBhdCBhbGwpIGZvciB0aGUgZm9sbG93aW5nIGV4dGVuc2lvbiB0eXBlczogRGVwYXJ0bWVudC9Bbm5vdW5jZW1lbnQgT25seS9UYWtlIE1lc3NhZ2VzIE9ubHkgKFZvaWNlbWFpbCkvRmF4IFVzZXIvUGFnaW5nIE9ubHkgR3JvdXAvU2hhcmVkIExpbmVzIEdyb3VwL0lWUiBNZW51L0FwcGxpY2F0aW9uIEV4dGVuc2lvbi9QYXJrIExvY2F0aW9uLklmIHRoZSB1c2VyIHJlcXVlc3RzIGhpcy9oZXIgb3duIHByZXNlbmNlIHN0YXR1cyxcbiAgICAgKiAgICAgdGhlIHJlc3BvbnNlIGNvbnRhaW5zIGFjdHVhbCBwcmVzZW5jZSBzdGF0dXMgZXZlbiBpZiB0aGUgc3RhdHVzIHB1YmxpY2F0aW9uIGlzIHR1cm5lZCBvZmYuQmF0Y2ggcmVxdWVzdCBpcyBzdXBwb3J0ZWQuIEZvciBiYXRjaCByZXF1ZXN0cyB0aGUgbnVtYmVyIG9mIGV4dGVuc2lvbnMgaW4gb25lIHJlcXVlc3QgaXMgbGltaXRlZCB0byAzMC4gSWYgbW9yZSBleHRlbnNpb25zIGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdCwgdGhlXG4gICAgICogICAgIGVycm9yIGNvZGUgNDAwIEJhZCBSZXF1ZXN0IGlzIHJldHVybmVkIHdpdGggdGhlIGxvZ2ljYWwgZXJyb3IgY29kZSBJbnZhbGlkTXVsdGlwYXJ0UmVxdWVzdCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgbWVzc2FnZSAnRXh0ZW5zaW9uIFByZXNlbmNlIEluZm8gbXVsdGlwYXJ0IHJlcXVlc3QgaXMgbGltaXRlZCB0byAzMCBleHRlbnNpb25zJy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRQcmVzZW5jZTwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPkdldHRpbmcgdXNlciBwcmVzZW5jZSBpbmZvcm1hdGlvbjwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgUHJlc2VuY2UucHJvdG90eXBlLmdldFByZXNlbmNlU3RhdHVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9wcmVzZW5jZScsIG9wdGlvbnMsIGV4cG9ydHMuZ2V0UHJlc2VuY2VTdGF0dXNPcHRpb25zKSwgcHJlc2VuY2VpbmZvLlByZXNlbmNlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgTW9uaXRvcmVkIEV4dGVuc2lvbnNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMyAoUmVsZWFzZSA2LjUpPC9wPlxuICAgICAqIDxwPlJldHVybnMgbGlzdCBvZiBsaW5lcyAtIGV4dGVuc2lvbnMgd2hpY2ggcHJlc2VuY2Ugc3RhdHVzIGNhbiBiZSBpbmRpY2F0ZWQgYW5kIG1vbml0b3JlZCBvbiBCTEYtZW5hYmxlZCAoQnVzeSBMYW1wIEZpZWxkKSBkZXZpY2VzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZFByZXNlbmNlPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+R2V0dGluZyB1c2VyIHByZXNlbmNlIGluZm9ybWF0aW9uPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBQcmVzZW5jZS5wcm90b3R5cGUubGlzdE1vbml0b3JlZEV4dGVuc2lvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3ByZXNlbmNlL2xpbmUnLCBvcHRpb25zLCBleHBvcnRzLmxpc3RNb25pdG9yZWRFeHRlbnNpb25zT3B0aW9ucyksIG1vbml0b3JlZGV4dGVuc2lvbnMuTW9uaXRvcmVkRXh0ZW5zaW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJlc2VuY2U7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuUHJlc2VuY2UgPSBQcmVzZW5jZTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBnZXRQcmVzZW5jZVN0YXR1cyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5nZXRQcmVzZW5jZVN0YXR1c09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdE1vbml0b3JlZEV4dGVuc2lvbnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdE1vbml0b3JlZEV4dGVuc2lvbnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuXG5cbi8qKiovIH0sXG4vKiA4OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBwcmVzZW5jZWV4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KTtcbnZhciBQcmVzZW5jZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmVzZW5jZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJlc2VuY2VJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUHJlc2VuY2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYWxsb3dTZWVNeVByZXNlbmNlJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZG5kU3RhdHVzJywgQ2xhc3M6IFByZXNlbmNlSW5mb0RuZFN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uJywgQ2xhc3M6IHByZXNlbmNlZXh0ZW5zaW9uaW5mby5QcmVzZW5jZUV4dGVuc2lvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21lc3NhZ2UnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BpY2tVcENhbGxzT25Ib2xkJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncHJlc2VuY2VTdGF0dXMnLCBDbGFzczogUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JpbmdPbk1vbml0b3JlZENhbGwnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0ZWxlcGhvbnlTdGF0dXMnLCBDbGFzczogUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1c2VyU3RhdHVzJywgQ2xhc3M6IFByZXNlbmNlSW5mb1VzZXJTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQcmVzZW5jZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdQcmVzZW5jZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFByZXNlbmNlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUHJlc2VuY2VJbmZvID0gUHJlc2VuY2VJbmZvO1xuKGZ1bmN0aW9uIChQcmVzZW5jZUluZm9EbmRTdGF0dXMpIHtcbiAgICBQcmVzZW5jZUluZm9EbmRTdGF0dXNbUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1wiVGFrZUFsbENhbGxzXCJdID0gJ1Rha2VBbGxDYWxscyddID0gXCJUYWtlQWxsQ2FsbHNcIjtcbiAgICBQcmVzZW5jZUluZm9EbmRTdGF0dXNbUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1wiRG9Ob3RBY2NlcHRBbnlDYWxsc1wiXSA9ICdEb05vdEFjY2VwdEFueUNhbGxzJ10gPSBcIkRvTm90QWNjZXB0QW55Q2FsbHNcIjtcbiAgICBQcmVzZW5jZUluZm9EbmRTdGF0dXNbUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1wiRG9Ob3RBY2NlcHREZXBhcnRtZW50Q2FsbHNcIl0gPSAnRG9Ob3RBY2NlcHREZXBhcnRtZW50Q2FsbHMnXSA9IFwiRG9Ob3RBY2NlcHREZXBhcnRtZW50Q2FsbHNcIjtcbiAgICBQcmVzZW5jZUluZm9EbmRTdGF0dXNbUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1wiVGFrZURlcGFydG1lbnRDYWxsc09ubHlcIl0gPSAnVGFrZURlcGFydG1lbnRDYWxsc09ubHknXSA9IFwiVGFrZURlcGFydG1lbnRDYWxsc09ubHlcIjtcbn0pKGV4cG9ydHMuUHJlc2VuY2VJbmZvRG5kU3RhdHVzIHx8IChleHBvcnRzLlByZXNlbmNlSW5mb0RuZFN0YXR1cyA9IHt9KSk7XG52YXIgUHJlc2VuY2VJbmZvRG5kU3RhdHVzID0gZXhwb3J0cy5QcmVzZW5jZUluZm9EbmRTdGF0dXM7XG4oZnVuY3Rpb24gKFByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzKSB7XG4gICAgUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXNbUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXNbXCJPZmZsaW5lXCJdID0gJ09mZmxpbmUnXSA9IFwiT2ZmbGluZVwiO1xuICAgIFByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzW1ByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzW1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1c1tQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1c1tcIkF2YWlsYWJsZVwiXSA9ICdBdmFpbGFibGUnXSA9IFwiQXZhaWxhYmxlXCI7XG59KShleHBvcnRzLlByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzIHx8IChleHBvcnRzLlByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzID0ge30pKTtcbnZhciBQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cyA9IGV4cG9ydHMuUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXM7XG4oZnVuY3Rpb24gKFByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1cykge1xuICAgIFByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1c1tQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbXCJOb0NhbGxcIl0gPSAnTm9DYWxsJ10gPSBcIk5vQ2FsbFwiO1xuICAgIFByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1c1tQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbXCJDYWxsQ29ubmVjdGVkXCJdID0gJ0NhbGxDb25uZWN0ZWQnXSA9IFwiQ2FsbENvbm5lY3RlZFwiO1xuICAgIFByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1c1tQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbXCJSaW5naW5nXCJdID0gJ1JpbmdpbmcnXSA9IFwiUmluZ2luZ1wiO1xuICAgIFByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1c1tQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbXCJPbkhvbGRcIl0gPSAnT25Ib2xkJ10gPSBcIk9uSG9sZFwiO1xuICAgIFByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1c1tQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbXCJQYXJrZWRDYWxsXCJdID0gJ1BhcmtlZENhbGwnXSA9IFwiUGFya2VkQ2FsbFwiO1xufSkoZXhwb3J0cy5QcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXMgfHwgKGV4cG9ydHMuUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzID0ge30pKTtcbnZhciBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXMgPSBleHBvcnRzLlByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1cztcbihmdW5jdGlvbiAoUHJlc2VuY2VJbmZvVXNlclN0YXR1cykge1xuICAgIFByZXNlbmNlSW5mb1VzZXJTdGF0dXNbUHJlc2VuY2VJbmZvVXNlclN0YXR1c1tcIk9mZmxpbmVcIl0gPSAnT2ZmbGluZSddID0gXCJPZmZsaW5lXCI7XG4gICAgUHJlc2VuY2VJbmZvVXNlclN0YXR1c1tQcmVzZW5jZUluZm9Vc2VyU3RhdHVzW1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBQcmVzZW5jZUluZm9Vc2VyU3RhdHVzW1ByZXNlbmNlSW5mb1VzZXJTdGF0dXNbXCJBdmFpbGFibGVcIl0gPSAnQXZhaWxhYmxlJ10gPSBcIkF2YWlsYWJsZVwiO1xufSkoZXhwb3J0cy5QcmVzZW5jZUluZm9Vc2VyU3RhdHVzIHx8IChleHBvcnRzLlByZXNlbmNlSW5mb1VzZXJTdGF0dXMgPSB7fSkpO1xudmFyIFByZXNlbmNlSW5mb1VzZXJTdGF0dXMgPSBleHBvcnRzLlByZXNlbmNlSW5mb1VzZXJTdGF0dXM7XG5cblxuLyoqKi8gfSxcbi8qIDg5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFByZXNlbmNlRXh0ZW5zaW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByZXNlbmNlRXh0ZW5zaW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmVzZW5jZUV4dGVuc2lvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQcmVzZW5jZUV4dGVuc2lvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUHJlc2VuY2VFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUHJlc2VuY2VFeHRlbnNpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQcmVzZW5jZUV4dGVuc2lvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlByZXNlbmNlRXh0ZW5zaW9uSW5mbyA9IFByZXNlbmNlRXh0ZW5zaW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogOTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbGluZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBNb25pdG9yZWRFeHRlbnNpb25zID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW9uaXRvcmVkRXh0ZW5zaW9ucywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb25pdG9yZWRFeHRlbnNpb25zKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTW9uaXRvcmVkRXh0ZW5zaW9ucy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogbGluZWluZm8uTGluZUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE1vbml0b3JlZEV4dGVuc2lvbnMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNb25pdG9yZWRFeHRlbnNpb25zJztcbiAgICB9O1xuICAgIHJldHVybiBNb25pdG9yZWRFeHRlbnNpb25zO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Nb25pdG9yZWRFeHRlbnNpb25zID0gTW9uaXRvcmVkRXh0ZW5zaW9ucztcblxuXG4vKioqLyB9LFxuLyogOTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbW9uaXRvcmVkbGluZXNleHRlbnNpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mik7XG52YXIgTGluZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5lSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5lSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExpbmVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbicsIENsYXNzOiBtb25pdG9yZWRsaW5lc2V4dGVuc2lvbmluZm8uTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTGluZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdMaW5lSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkxpbmVJbmZvID0gTGluZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDkyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvID0gTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvO1xuKGZ1bmN0aW9uIChNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlKSB7XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW1wiVXNlclwiXSA9ICdVc2VyJ10gPSBcIlVzZXJcIjtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbXCJGYXhVc2VyXCJdID0gJ0ZheFVzZXInXSA9IFwiRmF4VXNlclwiO1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIlZpcnR1YWxVc2VyXCJdID0gJ1ZpcnR1YWxVc2VyJ10gPSBcIlZpcnR1YWxVc2VyXCI7XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW1wiRGlnaXRhbFVzZXJcIl0gPSAnRGlnaXRhbFVzZXInXSA9IFwiRGlnaXRhbFVzZXJcIjtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbXCJEZXBhcnRtZW50XCJdID0gJ0RlcGFydG1lbnQnXSA9IFwiRGVwYXJ0bWVudFwiO1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCJdID0gJ0FwcGxpY2F0aW9uRXh0ZW5zaW9uJ10gPSBcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCI7XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW1wiUGFya0xvY2F0aW9uXCJdID0gJ1BhcmtMb2NhdGlvbiddID0gXCJQYXJrTG9jYXRpb25cIjtcbn0pKGV4cG9ydHMuTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZSB8fCAoZXhwb3J0cy5Nb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlID0ge30pKTtcbnZhciBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlID0gZXhwb3J0cy5Nb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA5MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgcmluZ291dHN0YXR1cyA9IF9fd2VicGFja19yZXF1aXJlX18oOTQpO1xudmFyIFJpbmdPdXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSaW5nT3V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJpbmdPdXQoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlIFJpbmdPdXQgQ2FsbFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjcgKFJlbGVhc2UgNS4xNik8L3A+XG4gICAgICogPHA+TWFrZXMgYSAyLWxlZyBSaW5nT3V0IGNhbGwuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SaW5nT3V0PC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+UGVyZm9ybWluZyB0d28tbGVnZ2VkIHJpbmctb3V0IHBob25lIGNhbGxzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBSaW5nT3V0LnByb3RvdHlwZS5tYWtlUmluZ091dENhbGwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9yaW5nb3V0Jywgb3B0aW9ucywgZXhwb3J0cy5tYWtlUmluZ091dENhbGxPcHRpb25zKSwgcmluZ291dHN0YXR1cy5SaW5nT3V0U3RhdHVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBTdGF0dXMgb2YgUmluZ091dCBDYWxsXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNyAoUmVsZWFzZSA1LjE2KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBzdGF0dXMgb2YgYSAyLWxlZyBSaW5nT3V0IGNhbGwuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SaW5nT3V0PC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+UGVyZm9ybWluZyB0d28tbGVnZ2VkIHJpbmctb3V0IHBob25lIGNhbGxzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBSaW5nT3V0LnByb3RvdHlwZS5nZXRSaW5nT3V0Q2FsbFN0YXR1cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcmluZ291dC97cmluZ291dElkfScsIG9wdGlvbnMsIGV4cG9ydHMuZ2V0UmluZ091dENhbGxTdGF0dXNPcHRpb25zKSwgcmluZ291dHN0YXR1cy5SaW5nT3V0U3RhdHVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbmNlbCBSaW5nT3V0IENhbGxcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5DYW5jZWxzIHRoZSAyLWxlZyBSaW5nT3V0IGNhbGwuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SaW5nT3V0PC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+UGVyZm9ybWluZyB0d28tbGVnZ2VkIHJpbmctb3V0IHBob25lIGNhbGxzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBSaW5nT3V0LnByb3RvdHlwZS5jYW5jZWxSaW5nT3V0Q2FsbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0RFTEVURScsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcmluZ291dC97cmluZ291dElkfScsIG9wdGlvbnMsIGV4cG9ydHMuY2FuY2VsUmluZ091dENhbGxPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmluZ091dDtcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5SaW5nT3V0ID0gUmluZ091dDtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBtYWtlUmluZ091dENhbGwgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubWFrZVJpbmdPdXRDYWxsT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJtYWtlcmluZ291dHJlcXVlc3QuTWFrZVJpbmdPdXRSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGdldFJpbmdPdXRDYWxsU3RhdHVzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmdldFJpbmdPdXRDYWxsU3RhdHVzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInJpbmdvdXRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBjYW5jZWxSaW5nT3V0Q2FsbCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5jYW5jZWxSaW5nT3V0Q2FsbE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyaW5nb3V0SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG5cblxuLyoqKi8gfSxcbi8qIDk0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHJpbmdvdXRzdGF0dXNpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG52YXIgUmluZ091dFN0YXR1cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJpbmdPdXRTdGF0dXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmluZ091dFN0YXR1cygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJpbmdPdXRTdGF0dXMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXR1cycsIENsYXNzOiByaW5nb3V0c3RhdHVzaW5mby5SaW5nT3V0U3RhdHVzSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFJpbmdPdXRTdGF0dXMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdSaW5nT3V0U3RhdHVzJztcbiAgICB9O1xuICAgIHJldHVybiBSaW5nT3V0U3RhdHVzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5SaW5nT3V0U3RhdHVzID0gUmluZ091dFN0YXR1cztcblxuXG4vKioqLyB9LFxuLyogOTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUmluZ091dFN0YXR1c0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSaW5nT3V0U3RhdHVzSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSaW5nT3V0U3RhdHVzSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJpbmdPdXRTdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NhbGxTdGF0dXMnLCBDbGFzczogUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsZXJTdGF0dXMnLCBDbGFzczogUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NhbGxlZVN0YXR1cycsIENsYXNzOiBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUmluZ091dFN0YXR1c0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFJpbmdPdXRTdGF0dXNJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mbyA9IFJpbmdPdXRTdGF0dXNJbmZvO1xuKGZ1bmN0aW9uIChSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXMpIHtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiSW52YWxpZFwiXSA9ICdJbnZhbGlkJ10gPSBcIkludmFsaWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiU3VjY2Vzc1wiXSA9ICdTdWNjZXNzJ10gPSBcIlN1Y2Nlc3NcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiSW5Qcm9ncmVzc1wiXSA9ICdJblByb2dyZXNzJ10gPSBcIkluUHJvZ3Jlc3NcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiTm9BbnN3ZXJcIl0gPSAnTm9BbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiUmVqZWN0ZWRcIl0gPSAnUmVqZWN0ZWQnXSA9IFwiUmVqZWN0ZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiR2VuZXJpY0Vycm9yXCJdID0gJ0dlbmVyaWNFcnJvciddID0gXCJHZW5lcmljRXJyb3JcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiRmluaXNoZWRcIl0gPSAnRmluaXNoZWQnXSA9IFwiRmluaXNoZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiSW50ZXJuYXRpb25hbERpc2FibGVkXCJdID0gJ0ludGVybmF0aW9uYWxEaXNhYmxlZCddID0gXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiRGVzdGluYXRpb25CbG9ja2VkXCJdID0gJ0Rlc3RpbmF0aW9uQmxvY2tlZCddID0gXCJEZXN0aW5hdGlvbkJsb2NrZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiTm90RW5vdWdoRnVuZHNcIl0gPSAnTm90RW5vdWdoRnVuZHMnXSA9IFwiTm90RW5vdWdoRnVuZHNcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1wiTm9TdWNoVXNlclwiXSA9ICdOb1N1Y2hVc2VyJ10gPSBcIk5vU3VjaFVzZXJcIjtcbn0pKGV4cG9ydHMuUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzIHx8IChleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cyA9IHt9KSk7XG52YXIgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzID0gZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXM7XG4oZnVuY3Rpb24gKFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzKSB7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJJbnZhbGlkXCJdID0gJ0ludmFsaWQnXSA9IFwiSW52YWxpZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiU3VjY2Vzc1wiXSA9ICdTdWNjZXNzJ10gPSBcIlN1Y2Nlc3NcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIkluUHJvZ3Jlc3NcIl0gPSAnSW5Qcm9ncmVzcyddID0gXCJJblByb2dyZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJCdXN5XCJdID0gJ0J1c3knXSA9IFwiQnVzeVwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiTm9BbnN3ZXJcIl0gPSAnTm9BbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJHZW5lcmljRXJyb3JcIl0gPSAnR2VuZXJpY0Vycm9yJ10gPSBcIkdlbmVyaWNFcnJvclwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiRmluaXNoZWRcIl0gPSAnRmluaXNoZWQnXSA9IFwiRmluaXNoZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJEZXN0aW5hdGlvbkJsb2NrZWRcIl0gPSAnRGVzdGluYXRpb25CbG9ja2VkJ10gPSBcIkRlc3RpbmF0aW9uQmxvY2tlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiTm90RW5vdWdoRnVuZHNcIl0gPSAnTm90RW5vdWdoRnVuZHMnXSA9IFwiTm90RW5vdWdoRnVuZHNcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIk5vU3VjaFVzZXJcIl0gPSAnTm9TdWNoVXNlciddID0gXCJOb1N1Y2hVc2VyXCI7XG59KShleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzIHx8IChleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzID0ge30pKTtcbnZhciBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cyA9IGV4cG9ydHMuUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXM7XG4oZnVuY3Rpb24gKFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzKSB7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJJbnZhbGlkXCJdID0gJ0ludmFsaWQnXSA9IFwiSW52YWxpZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiU3VjY2Vzc1wiXSA9ICdTdWNjZXNzJ10gPSBcIlN1Y2Nlc3NcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIkluUHJvZ3Jlc3NcIl0gPSAnSW5Qcm9ncmVzcyddID0gXCJJblByb2dyZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJCdXN5XCJdID0gJ0J1c3knXSA9IFwiQnVzeVwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiTm9BbnN3ZXJcIl0gPSAnTm9BbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJHZW5lcmljRXJyb3JcIl0gPSAnR2VuZXJpY0Vycm9yJ10gPSBcIkdlbmVyaWNFcnJvclwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiRmluaXNoZWRcIl0gPSAnRmluaXNoZWQnXSA9IFwiRmluaXNoZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJEZXN0aW5hdGlvbkJsb2NrZWRcIl0gPSAnRGVzdGluYXRpb25CbG9ja2VkJ10gPSBcIkRlc3RpbmF0aW9uQmxvY2tlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiTm90RW5vdWdoRnVuZHNcIl0gPSAnTm90RW5vdWdoRnVuZHMnXSA9IFwiTm90RW5vdWdoRnVuZHNcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIk5vU3VjaFVzZXJcIl0gPSAnTm9TdWNoVXNlciddID0gXCJOb1N1Y2hVc2VyXCI7XG59KShleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzIHx8IChleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzID0ge30pKTtcbnZhciBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cyA9IGV4cG9ydHMuUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXM7XG5cblxuLyoqKi8gfSxcbi8qIDk2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBleHRlbnNpb25mb3J3YXJkaW5nbnVtYmVybGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTcpO1xudmFyIGZvcndhcmRpbmdudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XG52YXIgRm9yd2FyZGluZ051bWJlcnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb3J3YXJkaW5nTnVtYmVycywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGb3J3YXJkaW5nTnVtYmVycygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gRm9yd2FyZGluZyBOdW1iZXIgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjcgKFJlbGVhc2UgNS4xNik8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBleHRlbnNpb24gcGhvbmUgbnVtYmVycyB1c2VkIGZvciBjYWxsIGZvcndhcmRpbmcgYW5kIGNhbGwgZmxpcC4gVGhlIHJldHVybmVkIGxpc3QgY29udGFpbnMgYWxsIHRoZSBleHRlbnNpb24gcGhvbmUgbnVtYmVycyB0aGF0IGFyZSB1c2VkIGZvciBjYWxsIGZvcndhcmRpbmcgYW5kIGNhbGwgZmxpcC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBGb3J3YXJkaW5nTnVtYmVycy5wcm90b3R5cGUubGlzdEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9mb3J3YXJkaW5nLW51bWJlcicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJzT3B0aW9ucyksIGV4dGVuc2lvbmZvcndhcmRpbmdudW1iZXJsaXN0LkV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBGb3J3YXJkaW5nIE51bWJlclxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEyIChSZWxlYXNlIDYuNCk8L3A+XG4gICAgICogPHA+QWRkcyBhIG5ldyBmb3J3YXJkaW5nIG51bWJlciB0byB0aGUgZm9yd2FyZGluZyBudW1iZXIgbGlzdC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlciwgYXNzaWduZWQgcGhvbmUgbnVtYmVycywgZGV2aWNlcyBhbmQgb3RoZXIgZXh0ZW5zaW9uIHNldHRpbmdzKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEZvcndhcmRpbmdOdW1iZXJzLnByb3RvdHlwZS5jcmVhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vZm9yd2FyZGluZy1udW1iZXInLCBvcHRpb25zLCBleHBvcnRzLmNyZWF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJPcHRpb25zKSwgZm9yd2FyZGluZ251bWJlcmluZm8uRm9yd2FyZGluZ051bWJlckluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIEZvcndhcmRpbmcgTnVtYmVyIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjQgKFJlbGVhc2UgOC4wKTwvcD5cbiAgICAgKiA8cD5VcGRhdGVzIGFuIGV4aXN0ZW50IGZvcndhcmRpbmcgbnVtYmVyIGZyb20gdGhlIGZvcndhcmRpbmcgbnVtYmVyIGxpc3QuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIsIGFzc2lnbmVkIHBob25lIG51bWJlcnMsIGRldmljZXMgYW5kIG90aGVyIGV4dGVuc2lvbiBzZXR0aW5ncyk8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBGb3J3YXJkaW5nTnVtYmVycy5wcm90b3R5cGUudXBkYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BVVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vZm9yd2FyZGluZy1udW1iZXIve2ZvcndhcmRpbmdOdW1iZXJJZH0nLCBvcHRpb25zLCBleHBvcnRzLnVwZGF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJPcHRpb25zKSwgZm9yd2FyZGluZ251bWJlcmluZm8uRm9yd2FyZGluZ051bWJlckluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIEZvcndhcmRpbmcgTnVtYmVyIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjQgKFJlbGVhc2UgOC4wKTwvcD5cbiAgICAgKiA8cD5EZWxldGVzIGEgZm9yd2FyZGluZyBudW1iZXIgZnJvbSB0aGUgZm9yd2FyZGluZyBudW1iZXIgbGlzdCBieSBpdHMgSUQuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIsIGFzc2lnbmVkIHBob25lIG51bWJlcnMsIGRldmljZXMgYW5kIG90aGVyIGV4dGVuc2lvbiBzZXR0aW5ncyk8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBGb3J3YXJkaW5nTnVtYmVycy5wcm90b3R5cGUuZGVsZXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0RFTEVURScsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vZm9yd2FyZGluZy1udW1iZXIve2ZvcndhcmRpbmdOdW1iZXJJZH0nLCBvcHRpb25zLCBleHBvcnRzLmRlbGV0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRm9yd2FyZGluZ051bWJlcnM7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuRm9yd2FyZGluZ051bWJlcnMgPSBGb3J3YXJkaW5nTnVtYmVycztcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0RXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlcnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBjcmVhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmNyZWF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcImNyZWF0ZWZvcndhcmRpbmdudW1iZXJyZXF1ZXN0LkNyZWF0ZUZvcndhcmRpbmdOdW1iZXJSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHVwZGF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJmb3J3YXJkaW5nTnVtYmVySWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidXBkYXRlZm9yd2FyZGluZ251bWJlcnJlcXVlc3QuVXBkYXRlRm9yd2FyZGluZ051bWJlclJlcXVlc3RcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgZGVsZXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5kZWxldGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImZvcndhcmRpbmdOdW1iZXJJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcblxuXG4vKioqLyB9LFxuLyogOTcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZm9yd2FyZGluZ251bWJlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBmb3J3YXJkaW5nbnVtYmVyaW5mby5Gb3J3YXJkaW5nTnVtYmVySW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0ID0gRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDk4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEZvcndhcmRpbmdOdW1iZXJJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9yd2FyZGluZ051bWJlckluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9yd2FyZGluZ051bWJlckluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBGb3J3YXJkaW5nTnVtYmVySW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaG9uZU51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFiZWwnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZlYXR1cmVzJywgQ2xhc3M6IEZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZsaXBOdW1iZXInLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBGb3J3YXJkaW5nTnVtYmVySW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0ZvcndhcmRpbmdOdW1iZXJJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBGb3J3YXJkaW5nTnVtYmVySW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRm9yd2FyZGluZ051bWJlckluZm8gPSBGb3J3YXJkaW5nTnVtYmVySW5mbztcbihmdW5jdGlvbiAoRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcykge1xuICAgIEZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXNbRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlc1tcIkNhbGxGbGlwXCJdID0gJ0NhbGxGbGlwJ10gPSBcIkNhbGxGbGlwXCI7XG4gICAgRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlc1tGb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzW1wiQ2FsbEZvcndhcmRpbmdcIl0gPSAnQ2FsbEZvcndhcmRpbmcnXSA9IFwiQ2FsbEZvcndhcmRpbmdcIjtcbn0pKGV4cG9ydHMuRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcyB8fCAoZXhwb3J0cy5Gb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzID0ge30pKTtcbnZhciBGb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzID0gZXhwb3J0cy5Gb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzO1xuXG5cbi8qKiovIH0sXG4vKiA5OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgYmxvY2tlZG51bWJlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCk7XG52YXIgYmxvY2tlZG51bWJlcnNsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpO1xudmFyIEJsb2NrZWROdW1iZXJzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tlZE51bWJlcnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tlZE51bWJlcnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgQmxvY2tlZCBOdW1iZXJcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgbXkgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgQmxvY2tlZE51bWJlcnMucHJvdG90eXBlLmJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vYmxvY2tlZC1udW1iZXInLCBvcHRpb25zLCBleHBvcnRzLmJsb2NrTnVtYmVyT3B0aW9ucyksIGJsb2NrZWRudW1iZXJpbmZvLkJsb2NrZWROdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBCbG9ja2VkIE51bWJlciBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBsaXN0IG9mIHBob25lIG51bWJlcnMgd2hpY2ggYXJlIHNwZWNpZmllZCBieSB0aGUgdXNlciB0byBibG9jayBpbmJvdW5kIGNhbGxzIGFuZCBTTVMgbWVzc2FnZXMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgQmxvY2tlZE51bWJlcnMucHJvdG90eXBlLmxpc3RCbG9ja2VkTnVtYmVycyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vYmxvY2tlZC1udW1iZXInLCBvcHRpb25zLCBleHBvcnRzLmxpc3RCbG9ja2VkTnVtYmVyc09wdGlvbnMpLCBibG9ja2VkbnVtYmVyc2xpc3QuQmxvY2tlZE51bWJlcnNMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBCbG9ja2VkIE51bWJlcihzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEJsb2NrZWROdW1iZXJzLnByb3RvdHlwZS5sb2FkQmxvY2tlZE51bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vYmxvY2tlZC1udW1iZXIve2Jsb2NrZWROdW1iZXJJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRCbG9ja2VkTnVtYmVyT3B0aW9ucyksIGJsb2NrZWRudW1iZXJpbmZvLkJsb2NrZWROdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBCbG9ja2VkIE51bWJlcihzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyBteSBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBCbG9ja2VkTnVtYmVycy5wcm90b3R5cGUudXBkYXRlQmxvY2tlZE51bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BVVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vYmxvY2tlZC1udW1iZXIve2Jsb2NrZWROdW1iZXJJZH0nLCBvcHRpb25zLCBleHBvcnRzLnVwZGF0ZUJsb2NrZWROdW1iZXJPcHRpb25zKSwgYmxvY2tlZG51bWJlcmluZm8uQmxvY2tlZE51bWJlckluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIEJsb2NrZWQgTnVtYmVyKHMpIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIG15IGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEJsb2NrZWROdW1iZXJzLnByb3RvdHlwZS51bmJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9ibG9ja2VkLW51bWJlci97YmxvY2tlZE51bWJlcklkfScsIG9wdGlvbnMsIGV4cG9ydHMudW5ibG9ja051bWJlck9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja2VkTnVtYmVycztcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5CbG9ja2VkTnVtYmVycyA9IEJsb2NrZWROdW1iZXJzO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGJsb2NrTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmJsb2NrTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0QmxvY2tlZE51bWJlcnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEJsb2NrZWROdW1iZXJzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkQmxvY2tlZE51bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQmxvY2tlZE51bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJibG9ja2VkTnVtYmVySWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgdXBkYXRlQmxvY2tlZE51bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy51cGRhdGVCbG9ja2VkTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJsb2NrZWROdW1iZXJJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1bmJsb2NrTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVuYmxvY2tOdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYmxvY2tlZE51bWJlcklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuXG5cbi8qKiovIH0sXG4vKiAxMDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQmxvY2tlZE51bWJlckluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja2VkTnVtYmVySW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja2VkTnVtYmVySW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJsb2NrZWROdW1iZXJJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Bob25lTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQmxvY2tlZE51bWJlckluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdCbG9ja2VkTnVtYmVySW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tlZE51bWJlckluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkJsb2NrZWROdW1iZXJJbmZvID0gQmxvY2tlZE51bWJlckluZm87XG5cblxuLyoqKi8gfSxcbi8qIDEwMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBibG9ja2VkbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTAwKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBCbG9ja2VkTnVtYmVyc0xpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja2VkTnVtYmVyc0xpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tlZE51bWJlcnNMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQmxvY2tlZE51bWJlcnNMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogYmxvY2tlZG51bWJlcmluZm8uQmxvY2tlZE51bWJlckluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJsb2NrZWROdW1iZXJzTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0Jsb2NrZWROdW1iZXJzTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tlZE51bWJlcnNMaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5CbG9ja2VkTnVtYmVyc0xpc3QgPSBCbG9ja2VkTnVtYmVyc0xpc3Q7XG5cblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmluZ2NlbnRyYWwtY2xpZW50LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JpbmdjZW50cmFsLWNsaWVudC9idWlsZC9yaW5nY2VudHJhbC1jbGllbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBTeW1ib2xNYXAgZnJvbSAnLi9zeW1ib2wtbWFwJztcbmltcG9ydCB7IHByZWZpeEFjdGlvbnMgfSBmcm9tICcuL3JlZHV4LWhlbHBlcic7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50LWVtaXR0ZXInO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdzdG9yZScsXG4gICdtYXBwZXInLFxuICAncHJlZml4JyxcbiAgJ2FjdGlvbnMnLFxuICAnZW1pdHRlcicsXG5dKTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGRlc2NyaXB0aW9uIERlZmF1bHQgcmVkdWNlciBpZiBtb2R1bGUgZG9lcyBub3QgaGFzIGl0cyBvd24gcmVkdWNlci5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFJlZHVjZXIoc3RhdGUpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB7fTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGRlc2NyaXB0aW9uIERlZmF1bHQgcGFyZW50IHN0YXRlIHRvIG1vZHVsZSBzdGF0ZSBtYXBwZXIuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRNYXBwZXIoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEBjbGFzc1xuICogQGRlZmF1bHRcbiAqIEBkZXNjcmlwdGlvbiBCYXNlIG1vZHVsZSBjbGFzcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmNNb2R1bGUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXIsXG4gICAgc3RhdGVNYXBwZXIgPSBkZWZhdWx0TWFwcGVyLFxuICAgIHByZWZpeCxcbiAgICBhY3Rpb25zLFxuICB9KSB7XG4gICAgLy8gRXh0ZW5kaW5nIEV2ZW50RW1pdHRlciBicmVha3Mgc29tZSBtZWNoYW5pYywgc28gd2Ugd2lyZSBlbWl0dGVyIHVwIGxpa2UgdGhpcyBpbnN0ZWFkLlxuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzW3N5bWJvbHMubWFwcGVyXSA9IHN0YXRlTWFwcGVyO1xuICAgIHRoaXNbc3ltYm9scy5wcmVmaXhdID0gcHJlZml4O1xuICAgIHRoaXNbc3ltYm9scy5hY3Rpb25zXSA9IGFjdGlvbnMgJiYgcHJlZml4QWN0aW9ucyhhY3Rpb25zLCBwcmVmaXgpO1xuICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyKChzdG9yZSkgPT4ge1xuICAgICAgdGhpc1tzeW1ib2xzLnN0b3JlXSA9IHN0b3JlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVW5yZWdpc3RlciBmdW5jdGlvbi5cbiAgICovXG4gIG9uKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGhpc1tzeW1ib2xzLmVtaXR0ZXJdLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpc1tzeW1ib2xzLmVtaXR0ZXJdLm9mZihldmVudCwgaGFuZGxlcik7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uKX0gaGFuZGxlclxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVW5yZWdpc3RlciBmdW5jdGlvbi5cbiAgICovXG4gIG9uY2UoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0ub25jZShldmVudCwgaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5vZmYoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHsuLi5hcmdzfSBhcmdzXG4gICAqL1xuICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgdGhpc1tzeW1ib2xzLmVtaXR0ZXJdLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5vZmYoZXZlbnQsIGhhbmRsZXIpO1xuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzW3N5bWJvbHMubWFwcGVyXSh0aGlzW3N5bWJvbHMuc3RvcmVdLmdldFN0YXRlKCkpO1xuICB9XG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiBkZWZhdWx0UmVkdWNlcjtcbiAgfVxuICBnZXQgc3RvcmUoKSB7XG4gICAgcmV0dXJuIHRoaXNbc3ltYm9scy5zdG9yZV07XG4gIH1cbiAgZ2V0IHByZWZpeCgpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLnByZWZpeF07XG4gIH1cbiAgZ2V0IGFjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXNbc3ltYm9scy5hY3Rpb25zXTtcbiAgfVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvcmMtbW9kdWxlLmpzXG4gKiovIiwiaW1wb3J0IEVudW0gZnJvbSAnLi9lbnVtJztcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBkZXNjcmlwdGlvbiBIZWxwZXIgY2xhc3MgZm9yIGNyZWF0aW5nIGEgc3ltYm9sIG1hcHBpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ltYm9sTWFwIGV4dGVuZHMgRW51bSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKi9cbiAgY29uc3RydWN0b3Ioa2V5cykge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7fTtcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGRlZmluaXRpb25ba2V5XSA9IFN5bWJvbCgpO1xuICAgIH0pO1xuICAgIHN1cGVyKGRlZmluaXRpb24pO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvc3ltYm9sLW1hcC5qc1xuICoqLyIsImNvbnN0IGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5jb25zdCBERUZJTklUSU9OID0gU3ltYm9sKCk7XG5jb25zdCBWQUxVRVMgPSBTeW1ib2woKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW51bSB7XG4gIGNvbnN0cnVjdG9yKGRlZmluaXRpb24pIHtcbiAgICB0aGlzW0RFRklOSVRJT05dID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmaW5pdGlvbik7XG4gICAgdGhpc1tWQUxVRVNdID0gbmV3IFNldCgpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmaW5pdGlvbikge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZGVmaW5pdGlvbiwga2V5KSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbREVGSU5JVElPTl1ba2V5XTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzW1ZBTFVFU10uYWRkKHRoaXNbREVGSU5JVElPTl1ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBoYXNWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzW1ZBTFVFU10uaGFzKHZhbHVlKTtcbiAgfVxufVxuXG4vKlxuICogLy93aXRoIFByb3h5IHN1cHBvcnRcbiAqY29uc3QgZW51bUhhbmRsZXIgPSB7XG4gKiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gKiAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gKiAgfSxcbiAqICBzZXQoKSB7XG4gKiAgICByZXR1cm47XG4gKiAgfVxuICp9O1xuICpFbnVtID0gY2xhc3MgRW51bSBleHRlbmRzIFByb3h5IHtcbiAqICBjb25zdHJ1Y3RvcihkZWZpbml0aW9uKSB7XG4gKiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBkZWZpbml0aW9uKSwgZW51bUhhbmRsZXIpO1xuICogIH1cbiAqfVxuICovXG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2xpYi9lbnVtLmpzXG4gKiovIiwiaW1wb3J0IEVudW0gZnJvbSAnLi9lbnVtJztcblxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBkZXNjcmlwdGlvbiBoZWxwZXIgY2xhc3MgZm9yIGNyZWF0aW5nIHJlZHV4IGFjdGlvbiBkZWZpbml0aW9uIG1hcHNcbiAqL1xuZXhwb3J0IGNsYXNzIEFjdGlvbk1hcCBleHRlbmRzIEVudW0ge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGFjdGlvbnMgLSBsaXN0IG9mIGFjdGlvbiBzdHJpbmdzXG4gICAqIEBleHRlbmRzIEVudW1cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFjdGlvbnMgPSBbXSwgcHJlZml4ID0gJycpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0ge307XG4gICAgYWN0aW9ucy5mb3JFYWNoKGFjdGlvbiA9PiB7XG4gICAgICBkZWZpbml0aW9uW2FjdGlvbl0gPSBwcmVmaXggIT09ICcnID8gYCR7cHJlZml4fS0ke2FjdGlvbn1gIDogYWN0aW9uO1xuICAgIH0pO1xuICAgIHN1cGVyKGRlZmluaXRpb24pO1xuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gaGVscGVyIGZ1bmN0aW9uIHRvIHJldHVybiBhIHByZWZpeGVkIGFjdGlvbiBkZWZpbml0aW9uIG1hcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWZpeEFjdGlvbnMoYWN0aW9ucywgcHJlZml4KSB7XG4gIGlmICghcHJlZml4IHx8IHByZWZpeCA9PT0gJycpIHJldHVybiBhY3Rpb25zO1xuICBjb25zdCBkZWZpbml0aW9uID0ge307XG4gIGZvciAoY29uc3QgYWN0aW9uIGluIGFjdGlvbnMpIHtcbiAgICBpZiAoYWN0aW9uczo6aGFzT3duUHJvcGVydHkoYWN0aW9uKSkge1xuICAgICAgZGVmaW5pdGlvblthY3Rpb25dID0gYCR7cHJlZml4fS0ke2FjdGlvbn1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEVudW0oZGVmaW5pdGlvbik7XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2xpYi9yZWR1eC1oZWxwZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIGNhbGxhYmxlID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuXG4gICwgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHksIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4gICwgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgZGVzY3JpcHRvciA9IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfVxuXG4gICwgb24sIG9uY2UsIG9mZiwgZW1pdCwgbWV0aG9kcywgZGVzY3JpcHRvcnMsIGJhc2U7XG5cbm9uID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBkYXRhO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19fZWVfXycpKSB7XG5cdFx0ZGF0YSA9IGRlc2NyaXB0b3IudmFsdWUgPSBjcmVhdGUobnVsbCk7XG5cdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgJ19fZWVfXycsIGRlc2NyaXB0b3IpO1xuXHRcdGRlc2NyaXB0b3IudmFsdWUgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdGRhdGEgPSB0aGlzLl9fZWVfXztcblx0fVxuXHRpZiAoIWRhdGFbdHlwZV0pIGRhdGFbdHlwZV0gPSBsaXN0ZW5lcjtcblx0ZWxzZSBpZiAodHlwZW9mIGRhdGFbdHlwZV0gPT09ICdvYmplY3QnKSBkYXRhW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXHRlbHNlIGRhdGFbdHlwZV0gPSBbZGF0YVt0eXBlXSwgbGlzdGVuZXJdO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxub25jZSA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgb25jZSwgc2VsZjtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cdHNlbGYgPSB0aGlzO1xuXHRvbi5jYWxsKHRoaXMsIHR5cGUsIG9uY2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmLmNhbGwoc2VsZiwgdHlwZSwgb25jZSk7XG5cdFx0YXBwbHkuY2FsbChsaXN0ZW5lciwgdGhpcywgYXJndW1lbnRzKTtcblx0fSk7XG5cblx0b25jZS5fX2VlT25jZUxpc3RlbmVyX18gPSBsaXN0ZW5lcjtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5vZmYgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIGRhdGEsIGxpc3RlbmVycywgY2FuZGlkYXRlLCBpO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19fZWVfXycpKSByZXR1cm4gdGhpcztcblx0ZGF0YSA9IHRoaXMuX19lZV9fO1xuXHRpZiAoIWRhdGFbdHlwZV0pIHJldHVybiB0aGlzO1xuXHRsaXN0ZW5lcnMgPSBkYXRhW3R5cGVdO1xuXG5cdGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnb2JqZWN0Jykge1xuXHRcdGZvciAoaSA9IDA7IChjYW5kaWRhdGUgPSBsaXN0ZW5lcnNbaV0pOyArK2kpIHtcblx0XHRcdGlmICgoY2FuZGlkYXRlID09PSBsaXN0ZW5lcikgfHxcblx0XHRcdFx0XHQoY2FuZGlkYXRlLl9fZWVPbmNlTGlzdGVuZXJfXyA9PT0gbGlzdGVuZXIpKSB7XG5cdFx0XHRcdGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAyKSBkYXRhW3R5cGVdID0gbGlzdGVuZXJzW2kgPyAwIDogMV07XG5cdFx0XHRcdGVsc2UgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKChsaXN0ZW5lcnMgPT09IGxpc3RlbmVyKSB8fFxuXHRcdFx0XHQobGlzdGVuZXJzLl9fZWVPbmNlTGlzdGVuZXJfXyA9PT0gbGlzdGVuZXIpKSB7XG5cdFx0XHRkZWxldGUgZGF0YVt0eXBlXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuXHR2YXIgaSwgbCwgbGlzdGVuZXIsIGxpc3RlbmVycywgYXJncztcblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19fZWVfXycpKSByZXR1cm47XG5cdGxpc3RlbmVycyA9IHRoaXMuX19lZV9fW3R5cGVdO1xuXHRpZiAoIWxpc3RlbmVycykgcmV0dXJuO1xuXG5cdGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnb2JqZWN0Jykge1xuXHRcdGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuXHRcdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG5cdFx0bGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XG5cdFx0Zm9yIChpID0gMDsgKGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldKTsgKytpKSB7XG5cdFx0XHRhcHBseS5jYWxsKGxpc3RlbmVyLCB0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcyk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDI6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdFx0YXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG5cdFx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRcdGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0fVxuXHRcdFx0YXBwbHkuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fVxufTtcblxubWV0aG9kcyA9IHtcblx0b246IG9uLFxuXHRvbmNlOiBvbmNlLFxuXHRvZmY6IG9mZixcblx0ZW1pdDogZW1pdFxufTtcblxuZGVzY3JpcHRvcnMgPSB7XG5cdG9uOiBkKG9uKSxcblx0b25jZTogZChvbmNlKSxcblx0b2ZmOiBkKG9mZiksXG5cdGVtaXQ6IGQoZW1pdClcbn07XG5cbmJhc2UgPSBkZWZpbmVQcm9wZXJ0aWVzKHt9LCBkZXNjcmlwdG9ycyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uIChvKSB7XG5cdHJldHVybiAobyA9PSBudWxsKSA/IGNyZWF0ZShiYXNlKSA6IGRlZmluZVByb3BlcnRpZXMoT2JqZWN0KG8pLCBkZXNjcmlwdG9ycyk7XG59O1xuZXhwb3J0cy5tZXRob2RzID0gbWV0aG9kcztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V2ZW50LWVtaXR0ZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9hc3NpZ24nKVxuICAsIG5vcm1hbGl6ZU9wdHMgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9ucycpXG4gICwgaXNDYWxsYWJsZSAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlJylcbiAgLCBjb250YWlucyAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucycpXG5cbiAgLCBkO1xuXG5kID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZHNjciwgdmFsdWUvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCB3LCBvcHRpb25zLCBkZXNjO1xuXHRpZiAoKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB8fCAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSkge1xuXHRcdG9wdGlvbnMgPSB2YWx1ZTtcblx0XHR2YWx1ZSA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcblx0fVxuXHRpZiAoZHNjciA9PSBudWxsKSB7XG5cdFx0YyA9IHcgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdFx0dyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ3cnKTtcblx0fVxuXG5cdGRlc2MgPSB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlLCB3cml0YWJsZTogdyB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxuZC5ncyA9IGZ1bmN0aW9uIChkc2NyLCBnZXQsIHNldC8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIG9wdGlvbnMsIGRlc2M7XG5cdGlmICh0eXBlb2YgZHNjciAhPT0gJ3N0cmluZycpIHtcblx0XHRvcHRpb25zID0gc2V0O1xuXHRcdHNldCA9IGdldDtcblx0XHRnZXQgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbM107XG5cdH1cblx0aWYgKGdldCA9PSBudWxsKSB7XG5cdFx0Z2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKGdldCkpIHtcblx0XHRvcHRpb25zID0gZ2V0O1xuXHRcdGdldCA9IHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChzZXQgPT0gbnVsbCkge1xuXHRcdHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShzZXQpKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdH1cblxuXHRkZXNjID0geyBnZXQ6IGdldCwgc2V0OiBzZXQsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2QvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IE9iamVjdC5hc3NpZ25cblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sIG9iajtcblx0aWYgKHR5cGVvZiBhc3NpZ24gIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0b2JqID0geyBmb286ICdyYXonIH07XG5cdGFzc2lnbihvYmosIHsgYmFyOiAnZHdhJyB9LCB7IHRyenk6ICd0cnp5JyB9KTtcblx0cmV0dXJuIChvYmouZm9vICsgb2JqLmJhciArIG9iai50cnp5KSA9PT0gJ3JhemR3YXRyenknO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pcy1pbXBsZW1lbnRlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyAgPSByZXF1aXJlKCcuLi9rZXlzJylcbiAgLCB2YWx1ZSA9IHJlcXVpcmUoJy4uL3ZhbGlkLXZhbHVlJylcblxuICAsIG1heCA9IE1hdGgubWF4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkZXN0LCBzcmMvKiwg4oCmc3JjbiovKSB7XG5cdHZhciBlcnJvciwgaSwgbCA9IG1heChhcmd1bWVudHMubGVuZ3RoLCAyKSwgYXNzaWduO1xuXHRkZXN0ID0gT2JqZWN0KHZhbHVlKGRlc3QpKTtcblx0YXNzaWduID0gZnVuY3Rpb24gKGtleSkge1xuXHRcdHRyeSB7IGRlc3Rba2V5XSA9IHNyY1trZXldOyB9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGU7XG5cdFx0fVxuXHR9O1xuXHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSB7XG5cdFx0c3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdGtleXMoc3JjKS5mb3JFYWNoKGFzc2lnbik7XG5cdH1cblx0aWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHRocm93IGVycm9yO1xuXHRyZXR1cm4gZGVzdDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vc2hpbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpXG5cdD8gT2JqZWN0LmtleXNcblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmtleXMoJ3ByaW1pdGl2ZScpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvaXMtaW1wbGVtZW50ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG5cdHJldHVybiBrZXlzKG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogT2JqZWN0KG9iamVjdCkpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvc2hpbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgbnVsbCBvciB1bmRlZmluZWRcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC92YWxpZC12YWx1ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG52YXIgcHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMsIG9iaikge1xuXHR2YXIga2V5O1xuXHRmb3IgKGtleSBpbiBzcmMpIG9ialtrZXldID0gc3JjW2tleV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLyosIOKApm9wdGlvbnMqLykge1xuXHR2YXIgcmVzdWx0ID0gY3JlYXRlKG51bGwpO1xuXHRmb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zID09IG51bGwpIHJldHVybjtcblx0XHRwcm9jZXNzKE9iamVjdChvcHRpb25zKSwgcmVzdWx0KTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIERlcHJlY2F0ZWRcblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpXG5cdD8gU3RyaW5nLnByb3RvdHlwZS5jb250YWluc1xuXHQ6IHJlcXVpcmUoJy4vc2hpbScpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyID0gJ3JhemR3YXRyenknO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHR5cGVvZiBzdHIuY29udGFpbnMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuICgoc3RyLmNvbnRhaW5zKCdkd2EnKSA9PT0gdHJ1ZSkgJiYgKHN0ci5jb250YWlucygnZm9vJykgPT09IGZhbHNlKSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pcy1pbXBsZW1lbnRlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5kZXhPZiA9IFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VhcmNoU3RyaW5nLyosIHBvc2l0aW9uKi8pIHtcblx0cmV0dXJuIGluZGV4T2YuY2FsbCh0aGlzLCBzZWFyY2hTdHJpbmcsIGFyZ3VtZW50c1sxXSkgPiAtMTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL3NoaW0uanNcbiAqKiBtb2R1bGUgaWQgPSAxNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRyZXR1cm4gZm47XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBSY01vZHVsZSBmcm9tICcuLi8uLi9saWIvcmMtbW9kdWxlJztcbmltcG9ydCB7IEFjdGlvbk1hcCwgcHJlZml4QWN0aW9ucyB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAncmVkdXgnO1xuXG5pbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4uLy4uL2xpYi9zeW1ib2wtbWFwJztcblxuY29uc3Qgc3ltYm9scyA9IG5ldyBTeW1ib2xNYXAoW1xuICAncmVkdWNlcicsXG5dKTtcblxuZnVuY3Rpb24gZ2V0U2V0dGluZ3NSZWR1Y2VyKHByZWZpeCkge1xuICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHt9O1xuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXR0aW5ncyBleHRlbmRzIFJjTW9kdWxlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gICAgdGhpc1tzeW1ib2xzLnJlZHVjZXJdID0ge1xuICAgICAgYmFzZTogZ2V0U2V0dGluZ3NSZWR1Y2VyKHRoaXMucHJlZml4KSxcbiAgICB9O1xuICB9XG4gIHJlZ2lzdGVyUmVkdWNlcihuYW1lLCByZWR1Y2VyKSB7XG4gICAgdGhpc1tzeW1ib2xzLnJlZHVjZXJdW25hbWVdID0gcmVkdWNlcjtcbiAgfVxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gY29tYmluZVJlZHVjZXJzKHRoaXNbc3ltYm9scy5yZWR1Y2VyXSk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc2V0dGluZ3MvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBvc2UgPSBleHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IGV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBleHBvcnRzLmNyZWF0ZVN0b3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2NyZWF0ZVN0b3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN0b3JlKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMgPSByZXF1aXJlKCcuL2NvbWJpbmVSZWR1Y2VycycpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21iaW5lUmVkdWNlcnMpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYmluZEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmRBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlID0gcmVxdWlyZSgnLi9hcHBseU1pZGRsZXdhcmUnKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlNaWRkbGV3YXJlKTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qXG4qIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuKi9cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gICgwLCBfd2FybmluZzJbXCJkZWZhdWx0XCJdKSgnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcXCdwcm9kdWN0aW9uXFwnLiAnICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3IgRGVmaW5lUGx1Z2luIGZvciB3ZWJwYWNrIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMDMwMDMxKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydHMuY3JlYXRlU3RvcmUgPSBfY3JlYXRlU3RvcmUyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gX2NvbWJpbmVSZWR1Y2VyczJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5iaW5kQWN0aW9uQ3JlYXRvcnMgPSBfYmluZEFjdGlvbkNyZWF0b3JzMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IF9hcHBseU1pZGRsZXdhcmUyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29tcG9zZSA9IF9jb21wb3NlMltcImRlZmF1bHRcIl07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkFjdGlvblR5cGVzID0gdW5kZWZpbmVkO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjcmVhdGVTdG9yZTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUgPSByZXF1aXJlKCdzeW1ib2wtb2JzZXJ2YWJsZScpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sT2JzZXJ2YWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIEFjdGlvblR5cGVzID0gZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCdcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtpbml0aWFsU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuaGFuY2VyIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gaW5pdGlhbFN0YXRlO1xuICAgIGluaXRpYWxTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG5cbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgbmV4dExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXSgpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMge3N1YnNjcmlwdGlvbn0gQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG5cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XG4gICAgICB9XG4gICAgfSwgX3JlZltfc3ltYm9sT2JzZXJ2YWJsZTJbXCJkZWZhdWx0XCJdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMltfc3ltYm9sT2JzZXJ2YWJsZTJbXCJkZWZhdWx0XCJdXSA9IG9ic2VydmFibGUsIF9yZWYyO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jcmVhdGVTdG9yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzSG9zdE9iamVjdCA9IHJlcXVpcmUoJy4vX2lzSG9zdE9iamVjdCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fFxuICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT0gb2JqZWN0VGFnIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmXG4gICAgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0UHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG4vKipcbiAqIEdldHMgdGhlIGBbW1Byb3RvdHlwZV1dYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgYFtbUHJvdG90eXBlXV1gLlxuICovXG5mdW5jdGlvbiBnZXRQcm90b3R5cGUodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZUdldFByb3RvdHlwZShPYmplY3QodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvX2dldFByb3RvdHlwZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0hvc3RPYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvX2lzSG9zdE9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcG9ueWZpbGwnKShnbG9iYWwgfHwgd2luZG93IHx8IHRoaXMpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdFN5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3ltYm9sLW9ic2VydmFibGUvcG9ueWZpbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29tYmluZVJlZHVjZXJzO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgdmFyIGFjdGlvbk5hbWUgPSBhY3Rpb25UeXBlICYmICdcIicgKyBhY3Rpb25UeXBlLnRvU3RyaW5nKCkgKyAnXCInIHx8ICdhbiBhY3Rpb24nO1xuXG4gIHJldHVybiAnR2l2ZW4gYWN0aW9uICcgKyBhY3Rpb25OYW1lICsgJywgcmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkLiAnICsgJ1RvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4nO1xufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24pIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCA/ICdpbml0aWFsU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG5cbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShpbnB1dFN0YXRlKSkge1xuICAgIHJldHVybiAnVGhlICcgKyBhcmd1bWVudE5hbWUgKyAnIGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCInICsge30udG9TdHJpbmcuY2FsbChpbnB1dFN0YXRlKS5tYXRjaCgvXFxzKFthLXp8QS1aXSspLylbMV0gKyAnXCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgJyArICgna2V5czogXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCInKTtcbiAgfVxuXG4gIHZhciB1bmV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U3RhdGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICB9KTtcblxuICBpZiAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnVW5leHBlY3RlZCAnICsgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDEgPyAna2V5cycgOiAna2V5JykgKyAnICcgKyAoJ1wiJyArIHVuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiIGZvdW5kIGluICcgKyBhcmd1bWVudE5hbWUgKyAnLiAnKSArICdFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6ICcgKyAoJ1wiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiLiBVbmV4cGVjdGVkIGtleXMgd2lsbCBiZSBpZ25vcmVkLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlZHVjZXJTYW5pdHkocmVkdWNlcnMpIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gJyArICdJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgJyArICdleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5ICcgKyAnbm90IGJlIHVuZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9ICdAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IHR5cGUgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuICcgKyAoJ0RvblxcJ3QgdHJ5IHRvIGhhbmRsZSAnICsgX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgKyAnIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgJykgKyAnbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgJyArICdjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCAnICsgJ2luIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSAnICsgJ2FjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBmaW5hbFJlZHVjZXJzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xuICAgIH1cbiAgfVxuICB2YXIgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpO1xuXG4gIHZhciBzYW5pdHlFcnJvcjtcbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2FuaXR5KGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2FuaXR5RXJyb3IgPSBlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoc2FuaXR5RXJyb3IpIHtcbiAgICAgIHRocm93IHNhbml0eUVycm9yO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24pO1xuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgICgwLCBfd2FybmluZzJbXCJkZWZhdWx0XCJdKSh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dFN0YXRlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tpXTtcbiAgICAgIHZhciByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1trZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtrZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZVtrZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gd2FybmluZztcbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL3V0aWxzL3dhcm5pbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gYmluZEFjdGlvbkNyZWF0b3JzO1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvci5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcbiAqIG1heSBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QsIGFzIHlvdSBjYW4gY2FsbFxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCBnZXQgYSBmdW5jdGlvbiBpbiByZXR1cm4uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGFjdGlvbkNyZWF0b3JzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvblxuICogY3JlYXRvciBmdW5jdGlvbnMuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzYFxuICogc3ludGF4LiBZb3UgbWF5IGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwYXRjaCBUaGUgYGRpc3BhdGNoYCBmdW5jdGlvbiBhdmFpbGFibGUgb24geW91ciBSZWR1eFxuICogc3RvcmUuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gVGhlIG9iamVjdCBtaW1pY2tpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCwgYnV0IHdpdGhcbiAqIGV2ZXJ5IGFjdGlvbiBjcmVhdG9yIHdyYXBwZWQgaW50byB0aGUgYGRpc3BhdGNoYCBjYWxsLiBJZiB5b3UgcGFzc2VkIGFcbiAqIGZ1bmN0aW9uIGFzIGBhY3Rpb25DcmVhdG9yc2AsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBhbHNvIGJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSAnb2JqZWN0JyB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICcgKyAoYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgYWN0aW9uQ3JlYXRvcnMpICsgJy4gJyArICdEaWQgeW91IHdyaXRlIFwiaW1wb3J0IEFjdGlvbkNyZWF0b3JzIGZyb21cIiBpbnN0ZWFkIG9mIFwiaW1wb3J0ICogYXMgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiPycpO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhY3Rpb25DcmVhdG9ycyk7XG4gIHZhciBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2JpbmRBY3Rpb25DcmVhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGFwcGx5TWlkZGxld2FyZTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5mdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcikge1xuICAgICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcik7XG4gICAgICB2YXIgX2Rpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XG4gICAgICB2YXIgY2hhaW4gPSBbXTtcblxuICAgICAgdmFyIG1pZGRsZXdhcmVBUEkgPSB7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYWluID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpO1xuICAgICAgfSk7XG4gICAgICBfZGlzcGF0Y2ggPSBfY29tcG9zZTJbXCJkZWZhdWx0XCJdLmFwcGx5KHVuZGVmaW5lZCwgY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdG9yZSwge1xuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9hcHBseU1pZGRsZXdhcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb21wb3NlO1xuLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhc3QgPSBmdW5jc1tmdW5jcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciByZXN0ID0gZnVuY3Muc2xpY2UoMCwgLTEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdjogZnVuY3Rpb24gdigpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdC5yZWR1Y2VSaWdodChmdW5jdGlvbiAoY29tcG9zZWQsIGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmKGNvbXBvc2VkKTtcbiAgICAgICAgICB9LCBsYXN0LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgaWYgKHR5cGVvZiBfcmV0ID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICB9XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2NvbXBvc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBSY01vZHVsZSBmcm9tICcuLi8uLi9saWIvcmMtbW9kdWxlJztcbmltcG9ydCBicmFuZEFjdGlvbnMgZnJvbSAnLi9icmFuZC1hY3Rpb25zJztcbmltcG9ydCBnZXRSZWR1Y2VyIGZyb20gJy4vYnJhbmQtcmVkdWNlcic7XG5pbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4uLy4uL2xpYi9zeW1ib2wtbWFwJztcblxuY29uc3Qgc3ltYm9scyA9IG5ldyBTeW1ib2xNYXAoW1xuICAnaW5pdGlhbFN0YXRlJyxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcmFuZCBleHRlbmRzIFJjTW9kdWxlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyLFxuICAgIHN0YXRlTWFwcGVyID0gKHN0YXRlKSA9PiBzdGF0ZS5icmFuZCxcbiAgICBwcmVmaXgsXG4gICAgaWQsXG4gICAgbmFtZSxcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyLFxuICAgICAgc3RhdGVNYXBwZXIsXG4gICAgICBwcmVmaXgsXG4gICAgICBhY3Rpb25zOiBicmFuZEFjdGlvbnMsXG4gICAgfSk7XG4gICAgdGhpc1tzeW1ib2xzLmluaXRpYWxTdGF0ZV0gPSB7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgfTtcbiAgfVxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZ2V0UmVkdWNlcih0aGlzW3N5bWJvbHMuaW5pdGlhbFN0YXRlXSwgdGhpcy5wcmVmaXgpO1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pZDtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5uYW1lO1xuICB9XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYnJhbmQvaW5kZXguanNcbiAqKi8iLCJpbXBvcnQgeyBBY3Rpb25NYXAgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFjdGlvbk1hcChbXG4gICdzZXRCcmFuZCcsXG5dKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYnJhbmQvYnJhbmQtYWN0aW9ucy5qc1xuICoqLyIsImltcG9ydCBicmFuZEFjdGlvbnMgZnJvbSAnLi9icmFuZC1hY3Rpb25zJztcbmltcG9ydCB7IHByZWZpeEFjdGlvbnMgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgcHJlZml4KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBwcmVmaXhBY3Rpb25zKGJyYW5kQWN0aW9ucywgcHJlZml4KTtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuXG4gICAgaWYgKCFhY3Rpb24pIHJldHVybiBzdGF0ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICBjYXNlIGFjdGlvbnMuc2V0QnJhbmQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIG5hbWU6IGFjdGlvbi5wYXlsb2FkLm5hbWUsXG4gICAgICAgICAgaWQ6IGFjdGlvbi5wYXlsb2FkLmlkLFxuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gIH07XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2JyYW5kL2JyYW5kLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4uLy4uL2xpYi9zeW1ib2wtbWFwJztcbmltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcbmltcG9ydCBsb2dpblN0YXR1cyBmcm9tICcuL2xvZ2luLXN0YXR1cyc7XG5pbXBvcnQgYXV0aEFjdGlvbnMgZnJvbSAnLi9hdXRoLWFjdGlvbnMnO1xuaW1wb3J0IGdldEF1dGhSZWR1Y2VyIGZyb20gJy4vYXV0aC1yZWR1Y2VyJztcbmltcG9ydCB7IGF1dGhFdmVudHMsIGF1dGhFdmVudFR5cGVzIH0gZnJvbSAnLi9hdXRoLWV2ZW50cyc7XG5pbXBvcnQgeyBlbWl0IH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcblxuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdwbGF0Zm9ybScsXG4gICdlbWl0dGVyJyxcbiAgJ2JlZm9yZUxvZ291dEhhbmRsZXJzJyxcbl0pO1xuXG5jb25zdCBFTlVNUyA9IG5ldyBFbnVtKHtcbiAgbG9naW5TdGF0dXMsXG59KTtcblxuXG4vKipcbiAqIEBjbGFzc1xuICogQGRlc2NyaXB0aW9uIEF1dGhlbnRpY2F0aW9uIG1vZHVsZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRoIGV4dGVuZHMgUmNNb2R1bGUge1xuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGFjdGlvbnM6IGF1dGhBY3Rpb25zLFxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHBsYXRmb3JtLFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgdGhpc1tzeW1ib2xzLnBsYXRmb3JtXSA9IHBsYXRmb3JtO1xuICAgIHRoaXNbc3ltYm9scy5iZWZvcmVMb2dvdXRIYW5kbGVyc10gPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBsb2FkIGluZm8gb24gbG9naW5cbiAgICBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9naW5TdWNjZXNzLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmxvZ2luU3VjY2VzcyxcbiAgICAgIH0pO1xuICAgICAgdGhpczo6ZW1pdChhdXRoRXZlbnRUeXBlcy5sb2dpblN0YXR1c0NoYW5nZWQsIHRoaXMuc3RhdGUuc3RhdHVzKTtcbiAgICB9KTtcbiAgICAvLyBsb2dpbkVycm9yXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luRXJyb3IsIGVycm9yID0+IHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMubG9naW5FcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyB1bmxvYWQgaW5mbyBvbiBsb2dvdXRcbiAgICBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9nb3V0U3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dvdXRTdWNjZXNzLFxuICAgICAgfSk7XG4gICAgICAvLyB0aGlzLmVtaXQoYXV0aEV2ZW50cy51c2VySW5mb0NsZWFyZWQpO1xuICAgIH0pO1xuXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ291dEVycm9yLCBlcnJvciA9PiB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmxvZ291dEVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLnJlZnJlc2hFcnJvciwgZXJyb3IgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5yZWZyZXNoRXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBsb2FkIGluZm8gaWYgYWxyZWFkeSBsb2dnZWQgaW5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VkSW4gPSBhd2FpdCBwbGF0Zm9ybS5sb2dnZWRJbigpO1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5pbml0LFxuICAgICAgICBzdGF0dXM6IGxvZ2dlZEluID8gbG9naW5TdGF0dXMubG9nZ2VkSW4gOiBsb2dpblN0YXR1cy5ub3RMb2dnZWRJbixcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KGF1dGhFdmVudFR5cGVzLmF1dGhFdmVudFR5cGVzLCB0aGlzLnN0YXRlLnN0YXR1cyk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiBnZXRBdXRoUmVkdWNlcih0aGlzLnByZWZpeCk7XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQGRlc2NyaXB0aW9uIExvZ2luIGZ1bmN0aW9uIHVzaW5nIHVzZXJuYW1lIGFuZCBwYXNzd29yZFxuICAgKi9cbiAgYXN5bmMgbG9naW4oeyB1c2VybmFtZSwgcGFzc3dvcmQsIGV4dGVuc2lvbiwgcmVtZW1iZXIgfSkge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmxvZ2luLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICB1c2VybmFtZSxcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgcmVtZW1iZXIsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCBhdXRoRXZlbnRzLmxvZ2dpbmdJbik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0ubG9naW4oe1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgIHJlbWVtYmVyLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAZGVzY3JpcHRpb24gZ2V0IE9BdXRoIHBhZ2UgdXJsXG4gICAqL1xuICBsb2dpblVybCh7IHJlZGlyZWN0VXJpLCBzdGF0ZSwgYnJhbmRJZCwgZGlzcGxheSwgcHJvbXB0IH0pIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLnBsYXRmb3JtXS5sb2dpblVybCh7XG4gICAgICByZWRpcmVjdFVyaSxcbiAgICAgIHN0YXRlLFxuICAgICAgYnJhbmRJZCxcbiAgICAgIGRpc3BsYXksXG4gICAgICBwcm9tcHQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgcGFyc2VMb2dpblVybCh1cmwpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLnBsYXRmb3JtXS5wYXJzZUxvZ2luUmVkaXJlY3RVcmwodXJsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBkZXNjcmlwdGlvbiBBdXRob3JpemUgdXNpbmcgT0FhdXRoIGNvZGVcbiAgICovXG4gIGFzeW5jIGF1dGhvcml6ZSh7IGNvZGUsIHJlZGlyZWN0VXJpIH0pIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dpbixcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgY29kZSxcbiAgICAgICAgcmVkaXJlY3RVcmksXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCBhdXRoRXZlbnRzLmxvZ2dpbmdJbik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0ubG9naW4oe1xuICAgICAgY29kZSxcbiAgICAgIHJlZGlyZWN0VXJpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQGRlc2NyaXB0aW9uIExvZyB0aGUgdXNlciBvdXRcbiAgICovXG4gIGFzeW5jIGxvZ291dCgpIHtcbiAgICAvLyBkZWFsIHdpdGggcmVtb3Zpbmcgc3Vic2NyaXB0aW9uc1xuXG4gICAgdGhpczo6ZW1pdChhdXRoRXZlbnRUeXBlcy5sb2dpblN0YXR1c0NoYW5nZWQsIGF1dGhFdmVudHMubG9nZ2luZ091dCk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBbLi4udGhpc1tzeW1ib2xzLmJlZm9yZUxvZ291dEhhbmRsZXJzXV07XG4gICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB3cmFwcyB3aXRoIGFzeW5jIHNvIGV2ZW4gbm9ybWFsIGZ1bmN0aW9ucyBjYW4gYmUgYXdhaXRlZFxuICAgICAgICAvLyBUT0RPIGNhbmNlbCBsb2dvdXQgaWYgaGFuZGxlciByZXNvbHZlcyB0byBmYWxzZVxuICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4gaGFuZGxlcigpKSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgZW1pdCBlcnJvclxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpc1tzeW1ib2xzLnBsYXRmb3JtXS5sb2dvdXQoKTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKi9cbiAgYWRkQmVmb3JlTG9nb3V0SGFuZGxlcihoYW5kbGVyKSB7XG4gICAgdGhpc1tzeW1ib2xzLmJlZm9yZUxvZ291dEhhbmRsZXJzXS5hZGQoaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXNbc3ltYm9scy5iZWZvcmVMb2dvdXRIYW5kbGVyc10ucmVtb3ZlKGhhbmRsZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZW1vdmVCZWZvcmVMb2dvdXRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICB0aGlzW3N5bWJvbHMuYmVmb3JlTG9nb3V0SGFuZGxlcnNdLnJlbW92ZShoYW5kbGVyKTtcbiAgfVxuXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhdHVzO1xuICB9XG5cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gYXV0aEV2ZW50cztcbiAgfVxuXG4gIGdldCBldmVudFR5cGVzKCkge1xuICAgIHJldHVybiBhdXRoRXZlbnRUeXBlcztcbiAgfVxuXG4gIGdldCBlbnVtcygpIHtcbiAgICByZXR1cm4gRU5VTVM7XG4gIH1cblxuICBhc3luYyBpc0xvZ2dlZEluKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzW3N5bWJvbHMucGxhdGZvcm1dLmxvZ2dlZEluKCk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYXV0aC9pbmRleC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXHJcbiAgLCBjcmVhdGVEZXNjICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgaW5kZXgsIHZhbHVlKXtcclxuICBpZihpbmRleCBpbiBvYmplY3QpJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xyXG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUoKG91dGVyRm4gfHwgR2VuZXJhdG9yKS5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLmFyZykudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8XG4gICAgICAgICAgICAgIChtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBhcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9wcm9taXNlXCIpO1xuXG52YXIgX3Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvbWlzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gc3RlcChrZXksIGFyZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIpO1xuICAgIH0pO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlByb21pc2U7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2xhc3NvZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc2V0UHJvdG8gICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0XG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAxODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgcGVuZGluZzogJ1BFTkRJTkcnLCAvLyBhZnRlciBpbml0LCBiZWZvcmUgc3RhdHVzIGZyb20gcGxhdGZvcm0gaXMgZGV0ZXJtaW5lZFxuICBub3RMb2dnZWRJbjogJ05PVF9MT0dHRURfSU4nLFxuICBsb2dnaW5nSW46ICdMT0dHSU5HX0lOJyxcbiAgbG9nZ2VkSW46ICdMT0dHRURfSU4nLFxuICBsb2dnaW5nT3V0OiAnTE9HR0lOR19PVVQnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEVudW0oZGVmaW5pdGlvbik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2F1dGgvbG9naW4tc3RhdHVzLmpzXG4gKiovIiwiaW1wb3J0IHsgQWN0aW9uTWFwIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBBY3Rpb25NYXAoW1xuICAnbG9naW4nLFxuICAnbG9naW5TdWNjZXNzJyxcbiAgJ2xvZ2luRXJyb3InLFxuICAnbG9nb3V0JyxcbiAgJ2xvZ291dFN1Y2Nlc3MnLFxuICAnbG9nb3V0RXJyb3InLFxuICAncmVmcmVzaCcsXG4gICdyZWZyZXNoU3VjY2VzcycsXG4gICdyZWZyZXNoRXJyb3InLFxuICAnaW5pdCcsXG5dLCAnYXV0aCcpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtYWN0aW9ucy5qc1xuICoqLyIsImltcG9ydCB7IHByZWZpeEFjdGlvbnMgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcbmltcG9ydCBhdXRoQWN0aW9ucyBmcm9tICcuL2F1dGgtYWN0aW9ucyc7XG5pbXBvcnQgbG9naW5TdGF0dXMgZnJvbSAnLi9sb2dpbi1zdGF0dXMnO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIHN0YXR1czogbG9naW5TdGF0dXMucGVuZGluZyxcbiAgYXV0aEVycm9yOiBudWxsLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QXV0aFJlZHVjZXIocHJlZml4KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBwcmVmaXhBY3Rpb25zKGF1dGhBY3Rpb25zLCBwcmVmaXgpO1xuICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgaWYgKCFhY3Rpb24pIHJldHVybiBzdGF0ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICAgIGNhc2UgYWN0aW9ucy5pbml0OlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHsgc3RhdHVzOiBhY3Rpb24uc3RhdHVzIH0pO1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9naW46XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBsb2dpblN0YXR1cy5sb2dnaW5nSW4sXG4gICAgICAgICAgYXV0aEVycm9yOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9naW5TdWNjZXNzOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogbG9naW5TdGF0dXMubG9nZ2VkSW4sXG4gICAgICAgICAgYXV0aEVycm9yOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9nb3V0U3VjY2VzczpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IGxvZ2luU3RhdHVzLm5vdExvZ2dlZEluLFxuICAgICAgICAgIGF1dGhFcnJvcjogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBhY3Rpb25zLmxvZ2luRXJyb3I6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6IGxvZ2luU3RhdHVzLm5vdExvZ2dlZEluLFxuICAgICAgICAgIGF1dGhFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9nb3V0RXJyb3I6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBsb2dpblN0YXR1cy5sb2dnZWRJbixcbiAgICAgICAgICBhdXRoRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYXV0aC9hdXRoLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgbG9naW5TdGF0dXMgZnJvbSAnLi9sb2dpbi1zdGF0dXMnO1xuXG5jb25zdCBldmVudERlZmluaXRpb25zID0ge1xuICAuLi5sb2dpblN0YXR1cyxcbn07XG5cbmV4cG9ydCBjb25zdCBhdXRoRXZlbnRzID0gbmV3IEVudW0oZXZlbnREZWZpbml0aW9ucyk7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb25zID0ge1xuICBsb2dpblN0YXR1c0NoYW5nZWQ6ICdMT0dJTl9TVEFUVVNfQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3QgYXV0aEV2ZW50VHlwZXMgPSBuZXcgRW51bShldmVudFR5cGVEZWZpbml0aW9ucyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2F1dGgvYXV0aC1ldmVudHMuanNcbiAqKi8iLCJleHBvcnQgZnVuY3Rpb24gZXh0cmFjdERhdGEobW9kZWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWwpKSB7XG4gICAgcmV0dXJuIG1vZGVsLm1hcChpdGVtID0+IGV4dHJhY3REYXRhKGl0ZW0pKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZWwgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1vZGVsKSB7XG4gICAgICBpZiAoa2V5WzBdICE9PSAnXycgJiYgbW9kZWwuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkYXRhW2tleV0gPSBleHRyYWN0RGF0YShtb2RlbFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIG1vZGVsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hMaXN0KGZuKSB7XG4gIGxldCBmZXRjaGVkUGFnZXMgPSAwO1xuICBsZXQgdG90YWxQYWdlcyA9IDE7XG4gIGxldCBsaXN0ID0gW107XG4gIHdoaWxlIChmZXRjaGVkUGFnZXMgPCB0b3RhbFBhZ2VzKSB7XG4gICAgZmV0Y2hlZFBhZ2VzKys7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZuKHtcbiAgICAgIHBhZ2U6IGZldGNoZWRQYWdlcyxcbiAgICB9KTtcbiAgICB0b3RhbFBhZ2VzID0gZGF0YS5wYWdpbmcudG90YWxQYWdlcztcbiAgICBsaXN0ID0gbGlzdC5jb25jYXQoZGF0YS5yZWNvcmRzKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQGRlc2NyaXB0aW9uIEhlbHBlciBmdW5jdGlvbiB0byBlbWl0IGV2ZW50VHlwZWQgZXZlbnRzIGFuZCB0aGUgZXZlbnQgaXRzZWxmXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbWl0KGV2ZW50VHlwZSwgZXZlbnQsIC4uLnBheWxvYWRzKSB7XG4gIHRoaXMuZW1pdChldmVudCwgLi4ucGF5bG9hZHMpO1xuICB0aGlzLmVtaXQoZXZlbnRUeXBlLCBldmVudCwgLi4ucGF5bG9hZHMpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKHQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdCk7XG4gIH0pO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL3V0aWxzLmpzXG4gKiovIiwiaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4uLy4uL2xpYi9yYy1tb2R1bGUnO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5pbXBvcnQgc3Vic2NyaXB0aW9uQWN0aW9ucyBmcm9tICcuL3N1YnNjcmlwdGlvbi1hY3Rpb25zJztcbmltcG9ydCBnZXRTdWJzY3JpcHRpb25SZWR1Y2VyIGZyb20gJy4vc3Vic2NyaXB0aW9uLXJlZHVjZXInO1xuaW1wb3J0IHsgc3Vic2NyaXB0aW9uRXZlbnRzLCBzdWJzY3JpcHRpb25FdmVudFR5cGVzIH0gZnJvbSAnLi9zdWJzY3JpcHRpb24tZXZlbnRzJztcbmltcG9ydCBzdWJzY3JpcHRpb25TdGF0dXMgZnJvbSAnLi9zdWJzY3JpcHRpb24tc3RhdHVzJztcbmltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcbmltcG9ydCB7IGVtaXQgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdhdXRoJyxcbiAgJ3NkaycsXG4gICdwbGF0Zm9ybScsXG4gICdzdWJzY3JpcHRpb24nLFxuICAnZmlsdGVyQ2FjaGUnLFxuXSk7XG5cblxuY29uc3QgZmlsdGVyUmVnZXggPSB7XG4gIG1lc3NhZ2U6IC9tZXNzYWdlLXN0b3JlJC8sXG4gIHByZXNlbmNlOiAvcHJlc2VuY2UoXFw/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlKT8kLyxcbiAgdGVsZXBob255OiAvcHJlc2VuY2VcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUkLyxcbiAgbGluZTogL3ByZXNlbmNlXFwvbGluZSQvLFxuICBsaW5lUHJlc2VuY2U6IC9wcmVzZW5jZVxcL2xpbmVcXC9wcmVzZW5jZShcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUpPyQvLFxuICBsaW5lVGVsZXBob255OiAvcHJlc2VuY2VcXC9saW5lXFwvcHJlc2VuY2VcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUkLyxcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgbWVzc2FnZXMgZGVsaXZlcmVkIGJ5IHRoZSBzdWJzY3JpcHRvblxuICovXG5mdW5jdGlvbiBtZXNzYWdlSGFuZGxlcihtZXNzYWdlKSB7XG4gIC8vIGRldGVybWluZSB3aGljaCBldmVudHMgdGhlIG1lc3NhZ2UgZmFsbHMgdW5kZXJcbiAgY29uc3QgZXZlbnRzID0gW107XG4gIGlmIChmaWx0ZXJSZWdleC5tZXNzYWdlLnRlc3QobWVzc2FnZS5ldmVudCkpIHtcbiAgICBldmVudHMucHVzaCgnbWVzc2FnZScpO1xuICB9IGVsc2UgaWYgKGZpbHRlclJlZ2V4LmxpbmUudGVzdChtZXNzYWdlLmV2ZW50KSkge1xuICAgIGV2ZW50cy5wdXNoKCdsaW5lJyk7XG4gIH0gZWxzZSBpZiAoZmlsdGVyUmVnZXgubGluZVByZXNlbmNlLnRlc3QobWVzc2FnZS5ldmVudCkpIHtcbiAgICBldmVudHMucHVzaCgnbGluZVByZXNlbmNlJyk7XG4gICAgaWYgKGZpbHRlclJlZ2V4LmxpbmVUZWxlcGhvbnkudGVzdChtZXNzYWdlLmV2ZW50KSkgZXZlbnRzLnB1c2goJ2xpbmVUZWxlcGhvbnknKTtcbiAgfSBlbHNlIGlmIChmaWx0ZXJSZWdleC5wcmVzZW5jZS50ZXN0KG1lc3NhZ2UuZXZlbnQpKSB7XG4gICAgZXZlbnRzLnB1c2goJ3ByZXNlbmNlJyk7XG4gICAgaWYgKGZpbHRlclJlZ2V4LnRlbGVwaG9ueS50ZXN0KG1lc3NhZ2UuZXZlbnQpKSBldmVudHMucHVzaCgndGVsZXBob255Jyk7XG4gIH1cbiAgLy8gZGlzcGF0Y2ggdGhlIG1lc3NhZ2UgaW4gcmVkdXggbWFubmVyXG4gIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5ub3RpZmljYXRpb24sXG4gICAgZXZlbnRUeXBlczogZXZlbnRzLFxuICAgIHBheWxvYWQ6IG1lc3NhZ2UsXG4gIH0pO1xuICAvLyBlbWl0IHRoZSBtZXNzYWdlcyBhcyBldmVudHNcbiAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5ub3RpZmljYXRpb24sIHN1YnNjcmlwdGlvbkV2ZW50c1tldmVudF0sIG1lc3NhZ2UpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGNvbnN0IHBsYXRmb3JtID0gdGhpc1tzeW1ib2xzLnBsYXRmb3JtXTtcbiAgdGhpc1tzeW1ib2xzLnN1YnNjcmlwdGlvbl0gPSB0aGlzW3N5bWJvbHMuc2RrXS5jcmVhdGVTdWJzY3JpcHRpb24oKTtcbiAgY29uc3Qgb3duZXJJZCA9IHBsYXRmb3JtLmF1dGgoKS5kYXRhKCkub3duZXJfaWQ7XG4gIGxldCBjYWNoZUtleSA9IG51bGw7XG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNhY2hlS2V5ID0gYCR7dGhpcy5wcmVmaXh9LXN1Yi0ke293bmVySWR9YDtcbiAgICBjb25zdCBjYWNoZWRTdWJzY3JpcHRpb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZFN1YnNjcmlwdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5iYXNlLnNldFN1YnNjcmlwdGlvbihKU09OLnBhcnNlKGNhY2hlZFN1YnNjcmlwdGlvbikpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBkbyBub3RoaW5nICovXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICB0aGlzLmJhc2Uuc2V0RXZlbnRGaWx0ZXJzKHRoaXMuZmlsdGVycyk7XG5cbiAgdGhpcy5iYXNlLm9uKHRoaXMuYmFzZS5ldmVudHMubm90aWZpY2F0aW9uLCBtZXNzYWdlID0+IHtcbiAgICB0aGlzOjptZXNzYWdlSGFuZGxlcihtZXNzYWdlKTtcbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnJlbW92ZVN1Y2Nlc3MsICgpID0+IHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5ub3RTdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiBudWxsLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gIH0pO1xuICB0aGlzLmJhc2Uub24odGhpcy5iYXNlLmV2ZW50cy5yZW1vdmVFcnJvciwgKCkgPT4ge1xuICAgIC8vIFRPRE9cbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnJlbmV3U3VjY2VzcywgKCkgPT4ge1xuICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oY2FjaGVLZXksIEpTT04uc3RyaW5naWZ5KHRoaXMuYmFzZS5zdWJzY3JpcHRpb24oKSkpO1xuICAgIH1cbiAgICBjb25zdCBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5zdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiB0aGlzLmJhc2Uuc3Vic2NyaXB0aW9uKCksXG4gICAgfSk7XG4gICAgaWYgKG9sZFN0YXR1cyAhPT0gdGhpcy5zdGF0dXMpIHtcbiAgICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gICAgfVxuICB9KTtcbiAgdGhpcy5iYXNlLm9uKHRoaXMuYmFzZS5ldmVudHMucmVuZXdFcnJvciwgZXJyb3IgPT4ge1xuICAgIC8vIFRPRE8gaGFuZGxlIDQyOVxuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZVN0YXR1cyxcbiAgICAgIHN0YXR1czogc3Vic2NyaXB0aW9uU3RhdHVzLm5vdFN1YnNjcmliZWQsXG4gICAgICBzdWJzY3JpcHRpb246IG51bGwsXG4gICAgfSk7XG4gICAgdGhpczo6ZW1pdChzdWJzY3JpcHRpb25FdmVudFR5cGVzLnN0YXR1c0NoYW5nZWQsIHRoaXMuc3RhdHVzKTtcbiAgICB0aGlzLmJhc2UucmVzZXQoKS5zZXRFdmVudEZpbHRlcnModGhpcy5maWx0ZXJzKS5yZWdpc3RlcigpLmNhdGNoKGUgPT4geyB9KTtcbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnN1YnNjcmliZVN1Y2Nlc3MsICgpID0+IHtcbiAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGNhY2hlS2V5LCBKU09OLnN0cmluZ2lmeSh0aGlzLmJhc2Uuc3Vic2NyaXB0aW9uKCkpKTtcbiAgICB9XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudXBkYXRlU3RhdHVzLFxuICAgICAgc3RhdHVzOiBzdWJzY3JpcHRpb25TdGF0dXMuc3Vic2NyaWJlZCxcbiAgICAgIHN1YnNjcmlwdGlvbjogdGhpcy5iYXNlLnN1YnNjcmlwdGlvbigpLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gIH0pO1xuICB0aGlzLmJhc2Uub24odGhpcy5iYXNlLmV2ZW50cy5zdWJzY3JpYmVFcnJvciwgZXJyb3IgPT4ge1xuICAgIC8vIFRPRE9cbiAgICAvLyBoYW5kbGUgNDI5XG4gICAgLy8gaGFuZGxlIHN1YnNjcmlwdGlvbiBsaW1pdFxuICB9KTtcblxuICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgIHRoaXMuYmFzZS5yZWdpc3RlcigpLmNhdGNoKCgpID0+IHsgLyogZG8gbm90aGluZyAqLyB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJzY3JpcHRpb24gZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBvcHRpb25zLnJlZ2lzdGVyU3RvcmVIYW5kbGVyKHN0b3JlID0+IHtcbiAgICAgICAgICAvLyBzZXQgc3RvcmUgdG8gc2VsZiBmaXJzdFxuICAgICAgICAgIGhhbmRsZXIoc3RvcmUpO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHN0b3JlIHdpdGggY2FjaGVkRmlsdGVyc1xuICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZUZpbHRlcnMsXG4gICAgICAgICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzW3N5bWJvbHMuZmlsdGVyQ2FjaGVdID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYWN0aW9uczogc3Vic2NyaXB0aW9uQWN0aW9ucyxcbiAgICB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGF1dGgsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHNkayxcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzW3N5bWJvbHMuYXV0aF0gPSBhdXRoO1xuICAgIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzW3N5bWJvbHMuc2RrXSA9IHNkaztcbiAgICB0aGlzW3N5bWJvbHMuc3Vic2NyaXB0aW9uXSA9IG51bGw7XG5cbiAgICAvLyBjYWNoZXMgZmlsdGVycyBiZWZvcmUgcmVkdXggc3RvcmUgaXMgY3JlYXRlZFxuICAgIHRoaXNbc3ltYm9scy5maWx0ZXJDYWNoZV0gPSBbXTtcblxuICAgIGF1dGgub24oYXV0aC5ldmVudHMubG9nZ2VkSW4sICgpID0+IHtcbiAgICAgIHRoaXM6OmluaXQoKTtcbiAgICB9KTtcblxuICAgIGF1dGgub24oYXV0aC5ldmVudHMubG9nZ2VkT3V0LCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5iYXNlKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dpblN1Y2Nlc3MsICgpID0+IHtcbiAgICAvLyAgIHRoaXM6OmluaXQoKTtcbiAgICAvLyB9KTtcbiAgICAvLyBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9nb3V0U3VjY2VzcywgYXN5bmMgKCkgPT4ge1xuICAgIC8vICAgaWYgKHRoaXMuYmFzZSkge1xuICAgIC8vICAgICBhd2FpdCB0aGlzLnJlc2V0KCk7XG4gICAgLy8gICB9XG4gICAgLy8gICB0aGlzW3N5bWJvbHMuc3Vic2NyaXB0aW9uXSA9IG51bGw7XG4gICAgLy8gfSk7XG5cbiAgICBhdXRoLmFkZEJlZm9yZUxvZ291dEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXNldCgpO1xuICAgIH0pO1xuXG4gICAgLy8gKGFzeW5jICgpID0+IHtcbiAgICAvLyAgIGlmIChhd2FpdCBwbGF0Zm9ybS5sb2dnZWRJbigpKSB7XG4gICAgLy8gICAgIHRoaXM6OmluaXQoKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9KSgpO1xuICB9XG5cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIGdldFN1YnNjcmlwdGlvblJlZHVjZXIodGhpcy5wcmVmaXgpO1xuICB9XG5cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5zdGF0dXM7XG4gIH1cblxuICBnZXQgZmlsdGVycygpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLmZpbHRlckNhY2hlXSB8fCB0aGlzLnN0YXRlLmZpbHRlcnM7XG4gIH1cblxuICBnZXQgYmFzZSgpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLnN1YnNjcmlwdGlvbl07XG4gIH1cblxuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBzdWJzY3JpcHRpb25FdmVudHM7XG4gIH1cblxuICBnZXQgZXZlbnRUeXBlcygpIHtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uRXZlbnRUeXBlcztcbiAgfVxuXG4gIHN1YnNjcmliZShldmVudCkge1xuICAgIC8vIFRPRE8gbm9ybWFsaXplZCBlcnJvclxuICAgIGlmICghc3Vic2NyaXB0aW9uRXZlbnRzOjpFbnVtLmhhc1ZhbHVlKGV2ZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmVudCBpcyBub3QgcmVjb2duaXplZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbHRlcnMuaW5kZXhPZihldmVudCkgPT09IC0xKSB7XG4gICAgICBjb25zdCBuZXdGaWx0ZXJzID0gdGhpcy5maWx0ZXJzLnNsaWNlKCk7XG4gICAgICBuZXdGaWx0ZXJzLnB1c2goZXZlbnQpO1xuICAgICAgaWYgKHRoaXMuYmFzZSkge1xuICAgICAgICB0aGlzLmJhc2Uuc2V0RXZlbnRGaWx0ZXJzKG5ld0ZpbHRlcnMpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudXBkYXRlRmlsdGVycyxcbiAgICAgICAgICBmaWx0ZXJzOiBuZXdGaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYXNlLnJlZ2lzdGVyKCkuY2F0Y2goKCkgPT4geyAvKiBkbyBub3RoaW5nICovIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tzeW1ib2xzLmZpbHRlckNhY2hlXSA9IG5ld0ZpbHRlcnM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdW5zdWJzY3JpYmUoZXZlbnQpIHtcbiAgICAvLyBUT0RPIG5vcm1hbGl6ZWQgZXJyb3JcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkV2ZW50czo6RW51bS5oYXNWYWx1ZShldmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXZlbnQgaXMgbm90IHJlY29nbml6ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgaWR4ID0gdGhpcy5maWx0ZXJzLmluZGV4T2YoZXZlbnQpO1xuICAgIGlmICh0aGlzLmZpbHRlcnMuaW5kZXhPZihldmVudCkgPiAtMSkge1xuICAgICAgY29uc3QgbmV3RmlsdGVycyA9IHRoaXMuZmlsdGVycy5zbGljZSgpO1xuICAgICAgbmV3RmlsdGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIGlmICh0aGlzLmJhc2UpIHtcbiAgICAgICAgdGhpcy5iYXNlLnNldEV2ZW50RmlsdGVycyhuZXdGaWx0ZXJzKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZUZpbHRlcnMsXG4gICAgICAgICAgZmlsdGVyczogbmV3RmlsdGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdGaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYmFzZS5yZWdpc3RlcigpLmNhdGNoKCgpID0+IHsgLyogZG8gbm90aGluZyAqLyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJhc2UucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbc3ltYm9scy5maWx0ZXJDYWNoZV0gPSBuZXdGaWx0ZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlc2V0KCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5iYXNlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gc3Vic2NyaXB0aW9uU3RhdHVzLnN1YnNjcmliZWQpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmJhc2UucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5iYXNlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIHRoaXNbc3ltYm9scy5zdWJzY3JpcHRpb25dID0gbnVsbDtcbiAgICBjb25zdCBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5ub3RTdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiBudWxsLFxuICAgIH0pO1xuICAgIGlmIChvbGRTdGF0dXMgIT09IHRoaXMuc3RhdHVzKSB7XG4gICAgICB0aGlzOjplbWl0KHN1YnNjcmlwdGlvbkV2ZW50VHlwZXMuc3RhdHVzQ2hhbmdlZCwgdGhpcy5zdGF0dXMpO1xuICAgIH1cbiAgfVxuXG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL2luZGV4LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCB7IEFjdGlvbk1hcCB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgQWN0aW9uTWFwKFtcbiAgJ3VwZGF0ZUZpbHRlcnMnLFxuICAnbm90aWZpY2F0aW9uJyxcblxuICAndXBkYXRlU3RhdHVzJyxcblxuXSwgJ3N1YnNjcmlwdGlvbicpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5pbXBvcnQgc3Vic2NyaXB0aW9uQWN0aW9ucyBmcm9tICcuL3N1YnNjcmlwdGlvbi1hY3Rpb25zJztcbmltcG9ydCB7IHN1YnNjcmlwdGlvbkV2ZW50cyB9IGZyb20gJy4vc3Vic2NyaXB0aW9uLWV2ZW50cyc7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgY2FjaGVLZXk6IG51bGwsXG4gIGZpbHRlcnM6IFtdLFxuICBzdGF0dXM6IHN1YnNjcmlwdGlvbkV2ZW50cy5wZW5kaW5nLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uUmVkdWNlcihwcmVmaXgpIHtcbiAgY29uc3QgYWN0aW9ucyA9IHByZWZpeEFjdGlvbnMoc3Vic2NyaXB0aW9uQWN0aW9ucywgcHJlZml4KTtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgY2FzZSBhY3Rpb25zLnVwZGF0ZVN0YXR1czpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdHVzOiBhY3Rpb24uc3RhdHVzLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiBhY3Rpb25zLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICBjYXNlIGFjdGlvbnMudXBkYXRlRmlsdGVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVyczogYWN0aW9uLmZpbHRlcnMuc2xpY2UoKSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgc3Vic2NyaXB0aW9uU3RhdHVzIGZyb20gJy4vc3Vic2NyaXB0aW9uLXN0YXR1cyc7XG5cblxuY29uc3QgZXZlbnREZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vbWVzc2FnZS1zdG9yZScsXG4gIHByZXNlbmNlOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UnLFxuICB0ZWxlcGhvbnk6ICcvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vfi9wcmVzZW5jZT9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUnLFxuICBsaW5lOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UvbGluZScsXG4gIGxpbmVQcmVzZW5jZTpcbiAgICAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UvbGluZS9wcmVzZW5jZScsXG4gIGxpbmVUZWxlcGhvbnk6XG4gICAgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC9+L2V4dGVuc2lvbi9+L3ByZXNlbmNlL2xpbmUvcHJlc2VuY2U/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlJyxcbiAgLi4uc3Vic2NyaXB0aW9uU3RhdHVzLFxufTtcblxuZXhwb3J0IGNvbnN0IHN1YnNjcmlwdGlvbkV2ZW50cyA9IG5ldyBFbnVtKGV2ZW50RGVmaW5pdGlvbik7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb24gPSB7XG4gIG5vdGlmaWNhdGlvbjogJ05PVElGSUNBVElPTicsXG4gIHN0YXR1c0NoYW5nZWQ6ICdTVEFUVVNfQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3Qgc3Vic2NyaXB0aW9uRXZlbnRUeXBlcyA9IG5ldyBFbnVtKGV2ZW50VHlwZURlZmluaXRpb24pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLWV2ZW50cy5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgcGVuZGluZzogJ1BFTkRJTkcnLFxuICBzdWJzY3JpYmVkOiAnU1VCU0NSSUJFRCcsXG4gIG5vdFN1YnNjcmliZWQ6ICdOT1RfU1VCU0NSSUJFRCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgRW51bShkZWZpbml0aW9uKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1zdGF0dXMuanNcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4uLy4uL2xpYi9zeW1ib2wtbWFwJztcbmltcG9ydCB7IGV4dHJhY3REYXRhLCBmZXRjaExpc3QsIGVtaXQgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHVzZXJBY3Rpb25zIGZyb20gJy4vdXNlci1hY3Rpb25zJztcbmltcG9ydCBnZXRVc2VyUmVkdWNlciBmcm9tICcuL3VzZXItcmVkdWNlcic7XG5pbXBvcnQgeyB1c2VyRXZlbnRzLCB1c2VyRXZlbnRUeXBlcyB9IGZyb20gJy4vdXNlci1ldmVudHMnO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdhcGknLFxuICAncGxhdGZvcm0nLFxuICAnc2V0dGluZ3MnLFxuXSk7XG5cbi8vIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbi8vICAgdGVzdDogdHJ1ZSxcbi8vIH07XG5cbi8vIGZ1bmN0aW9uIGdldFVzZXJTZXR0aW5nc1JlZHVjZXIocHJlZml4KSB7XG4vLyAgIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuLy8gICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcbi8vICAgICBpZiAoIWFjdGlvbikgcmV0dXJuIHN0YXRlO1xuLy8gICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbi8vICAgICAgIGRlZmF1bHQ6XG4vLyAgICAgICAgIHJldHVybiBzdGF0ZTtcbi8vICAgICB9XG4vLyAgIH07XG4vLyB9XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxvYWRGdW5jdGlvbiAtIGFzeW5jIGxvYWRlciBmdW5jdGlvbiByZXR1cm5pbmcgYSBwcm9taXNlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGRlc2NyaXB0aW9uIEdlbmVyaWMgZGF0YSBsb2FkaW5nIGxvZ2ljIHdpdGggZXZlbnRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWREYXRhKGRhdGFUeXBlLCBsb2FkRnVuY3Rpb24pIHtcbiAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1gXSxcbiAgfSk7XG4gIHRoaXMuZW1pdCh1c2VyRXZlbnRzW2Bsb2FkJHtkYXRhVHlwZX1gXSk7XG4gIHRyeSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXM6OmxvYWRGdW5jdGlvbigpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1TdWNjZXNzYF0sXG4gICAgICBwYXlsb2FkLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQodXNlckV2ZW50VHlwZXMudXNlckluZm9DaGFuZ2VkLCB1c2VyRXZlbnRzW2Bsb2FkJHtkYXRhVHlwZX1TdWNjZXNzYF0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1GYWlsZWRgXSxcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQodXNlckV2ZW50c1tgbG9hZCR7ZGF0YVR5cGV9RmFpbGVkYF0pO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59XG4gKiBAZGVzY3JpcHRpb24gRmV0Y2ggYWNjb3VudCBpbmZvIGFuZCBleHRyYWN0IHRoZSBkYXRhXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RBY2NvdW50SW5mbygpIHtcbiAgcmV0dXJuIGV4dHJhY3REYXRhKGF3YWl0IHRoaXNbc3ltYm9scy5hcGldLmFjY291bnQoKS5sb2FkQWNjb3VudCgpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRBY2NvdW50SW5mbygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdBY2NvdW50SW5mbycsIGV4dHJhY3RBY2NvdW50SW5mbyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RFeHRlbnNpb25JbmZvKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpc1tzeW1ib2xzLmFwaV0uZXh0ZW5zaW9uKCkubG9hZEV4dGVuc2lvbkluZm8oKSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkRXh0ZW5zaW9uSW5mbygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdFeHRlbnNpb25JbmZvJywgZXh0cmFjdEV4dGVuc2lvbkluZm8pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0RGlhbGluZ1BsYW5zKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpczo6ZmV0Y2hMaXN0KG9wdGlvbnMgPT4gKFxuICAgIHRoaXNbc3ltYm9scy5hcGldLmFjY291bnQoKS5saXN0RGlhbGluZ1BsYW5zKG9wdGlvbnMpXG4gICkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWREaWFsaW5nUGxhbnMoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzOjpsb2FkRGF0YSgnRGlhbGluZ1BsYW5zJywgZXh0cmFjdERpYWxpbmdQbGFucyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RQaG9uZU51bWJlcnMoKSB7XG4gIHJldHVybiBleHRyYWN0RGF0YShhd2FpdCB0aGlzOjpmZXRjaExpc3Qob3B0aW9ucyA9PiAoXG4gICAgdGhpc1tzeW1ib2xzLmFwaV0uZXh0ZW5zaW9uKCkubGlzdEV4dGVuc2lvblBob25lTnVtYmVycyhvcHRpb25zKVxuICApKSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkUGhvbmVOdW1iZXJzKCkge1xuICByZXR1cm4gYXdhaXQgdGhpczo6bG9hZERhdGEoJ1Bob25lTnVtYmVycycsIGV4dHJhY3RQaG9uZU51bWJlcnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0Rm9yd2FyZGluZ051bWJlcnMoKSB7XG4gIHJldHVybiBleHRyYWN0RGF0YShhd2FpdCB0aGlzOjpmZXRjaExpc3Qob3B0aW9ucyA9PiAoXG4gICAgdGhpc1tzeW1ib2xzLmFwaV0uZm9yd2FyZGluZ051bWJlcnMoKS5saXN0RXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlcnMob3B0aW9ucylcbiAgKSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEZvcndhcmRpbmdOdW1iZXJzKCkge1xuICByZXR1cm4gYXdhaXQgdGhpczo6bG9hZERhdGEoJ0ZvcndhcmRpbmdOdW1iZXJzJywgZXh0cmFjdEZvcndhcmRpbmdOdW1iZXJzKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEJsb2NrZWROdW1iZXJzKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpczo6ZmV0Y2hMaXN0KG9wdGlvbnMgPT4gKFxuICAgIHRoaXNbc3ltYm9scy5hcGldLmJsb2NrZWROdW1iZXJzKCkubGlzdEJsb2NrZWROdW1iZXJzKG9wdGlvbnMpXG4gICkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRCbG9ja2VkTnVtYmVycygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdCbG9ja2VkTnVtYmVycycsIGV4dHJhY3RCbG9ja2VkTnVtYmVycyk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkSW5mbygpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzOjpsb2FkQWNjb3VudEluZm8oKSxcbiAgICAgIHRoaXM6OmxvYWRFeHRlbnNpb25JbmZvKCksXG4gICAgICB0aGlzOjpsb2FkRGlhbGluZ1BsYW5zKCksXG4gICAgICB0aGlzOjpsb2FkUGhvbmVOdW1iZXJzKCksXG4gICAgICB0aGlzOjpsb2FkRm9yd2FyZGluZ051bWJlcnMoKSxcbiAgICAgIHRoaXM6OmxvYWRCbG9ja2VkTnVtYmVycygpLFxuICAgIF0pO1xuICAgIC8vIHRoaXMuZW1pdCh1c2VyRXZlbnRzLnVzZXJJbmZvTG9hZGVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE8gc2VuZCBlcnJvciBvdXRcbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBjbGFzcyBVc2VyXG4gKiBAZXh0ZW5kcyBSY01vZHVsZVxuICogQGRlZmF1bHRcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlciBleHRlbmRzIFJjTW9kdWxlIHtcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhY3Rpb25zOiB1c2VyQWN0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhcGksXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHNldHRpbmdzLFxuICAgIH0gPSBvcHRpb25zO1xuICAgIHRoaXNbc3ltYm9scy5hcGldID0gYXBpO1xuICAgIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzW3N5bWJvbHMuc2V0dGluZ3NdID0gc2V0dGluZ3M7XG5cbiAgICAvLyBzZXR0aW5ncy5yZWdpc3RlclJlZHVjZXIoJ3VzZXInLCBnZXRVc2VyU2V0dGluZ3NSZWR1Y2VyKCkpO1xuXG4gICAgLy8gbG9hZCBpbmZvIG9uIGxvZ2luXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luU3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpczo6bG9hZEluZm8oKTtcbiAgICB9KTtcbiAgICAvLyB1bmxvYWQgaW5mbyBvbiBsb2dvdXRcbiAgICBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9nb3V0U3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jbGVhclVzZXJJbmZvLFxuICAgICAgfSk7XG4gICAgICAvLyB0aGlzLmVtaXQodXNlckV2ZW50cy51c2VySW5mb0NsZWFyZWQpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBsb2FkIGluZm8gaWYgYWxyZWFkeSBsb2dnZWQgaW5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGF3YWl0IHBsYXRmb3JtLmxvZ2dlZEluKCkpIHtcbiAgICAgICAgYXdhaXQgdGhpczo6bG9hZEluZm8oKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogVE9ETzpcbiAgICAgKiAgIDEuIERpYWxpbmcgUGxhbiBDaGVja2luZ1xuICAgICAqL1xuICB9XG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiBnZXRVc2VyUmVkdWNlcih0aGlzLnByZWZpeCk7XG4gIH1cblxuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiB1c2VyRXZlbnRzO1xuICB9XG5cbiAgZ2V0IGV2ZW50VHlwZXMoKSB7XG4gICAgcmV0dXJuIHVzZXJFdmVudFR5cGVzO1xuICB9XG5cbiAgZ2V0IGRpcmVjdE51bWJlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGhvbmVOdW1iZXJzLmZpbHRlcihuID0+IG4udXNhZ2VUeXBlID09PSAnRGlyZWN0TnVtYmVyJyk7XG4gIH1cblxuICBnZXQgbWFpbkNvbXBhbnlOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGhvbmVOdW1iZXJzLmZpbmQobiA9PiBuLnVzYWdlVHlwZSA9PT0gJ01haW5Db21wYW55TnVtYmVyJyk7XG4gIH1cblxuICBnZXQgZGlhbGluZ1BsYW5zKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRpYWxpbmdQbGFucztcbiAgfVxuXG4gIGdldCBleHRlbnNpb25OdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXh0ZW5zaW9uSW5mby5leHRlbnNpb25OdW1iZXI7XG4gIH1cblxuICBnZXQgc21zTnVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5waG9uZU51bWJlcnMuZmlsdGVyKG4gPT4gbi5mZWF0dXJlcy5pbmRleE9mKCdTbXNTZW5kZXInKSA+IC0xKTtcbiAgfVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3VzZXIvaW5kZXguanNcbiAqKi8iLCJpbXBvcnQgeyBBY3Rpb25NYXAgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFjdGlvbk1hcChbXG4gICdjbGVhclVzZXJJbmZvJyxcblxuICAnbG9hZEFjY291bnRJbmZvJyxcbiAgJ2xvYWRBY2NvdW50SW5mb1N1Y2Nlc3MnLFxuICAnbG9hZEFjY291bnRJbmZvRmFpbGVkJyxcblxuICAnbG9hZEV4dGVuc2lvbkluZm8nLFxuICAnbG9hZEV4dGVuc2lvbkluZm9TdWNjZXNzJyxcbiAgJ2xvYWRFeHRlbnNpb25JbmZvRmFpbGVkJyxcblxuICAnbG9hZERpYWxpbmdQbGFucycsXG4gICdsb2FkRGlhbGluZ1BsYW5zU3VjY2VzcycsXG4gICdsb2FkRGlhbGluZ1BsYW5zRmFpbGVkJyxcblxuICAnbG9hZFBob25lTnVtYmVycycsXG4gICdsb2FkUGhvbmVOdW1iZXJzU3VjY2VzcycsXG4gICdsb2FkUGhvbmVOdW1iZXJzRmFpbGVkJyxcblxuICAnbG9hZEZvcndhcmRpbmdOdW1iZXJzJyxcbiAgJ2xvYWRGb3J3YXJkaW5nTnVtYmVyc1N1Y2Nlc3MnLFxuICAnbG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkJyxcblxuICAnbG9hZEJsb2NrZWROdW1iZXJzJyxcbiAgJ2xvYWRCbG9ja2VkTnVtYmVyc1N1Y2Nlc3MnLFxuICAnbG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkJyxcblxuXSwgJ3VzZXInKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvdXNlci91c2VyLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5pbXBvcnQgdXNlckFjdGlvbnMgZnJvbSAnLi91c2VyLWFjdGlvbnMnO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGFjY291bnRJbmZvOiBudWxsLFxuICBhY2NvdW50SW5mb0xvYWRpbmc6IGZhbHNlLFxuICBhY2NvdW50SW5mb0Vycm9yOiBudWxsLFxuXG4gIGV4dGVuc2lvbkluZm86IG51bGwsXG4gIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiBmYWxzZSxcbiAgZXh0ZW5zaW9uSW5mb0Vycm9yOiBudWxsLFxuXG4gIGRpYWxpbmdQbGFuczogW10sXG4gIGRpYWxpbmdQbGFuc0xvYWRpbmc6IGZhbHNlLFxuICBkaWFsaW5nUGxhbnNFcnJvcjogbnVsbCxcblxuICBwaG9uZU51bWJlcnM6IFtdLFxuICBwaG9uZU51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgcGhvbmVOdW1iZXJzRXJyb3I6IG51bGwsXG5cbiAgZm9yd2FyZGluZ051bWJlcnM6IFtdLFxuICBmb3J3YXJkaW5nTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICBmb3J3YXJkaW5nTnVtYmVyc0Vycm9yOiBudWxsLFxuXG4gIGJsb2NrZWROdW1iZXJzOiBbXSxcbiAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgYmxvY2tlZE51bWJlcnNFcnJvcjogbnVsbCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVzZXJSZWR1Y2VyKHByZWZpeCkge1xuICBjb25zdCBhY3Rpb25zID0gcHJlZml4QWN0aW9ucyh1c2VyQWN0aW9ucywgcHJlZml4KTtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG4gICAgICAvLyBhY2NvdW50IGluZm9cbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkQWNjb3VudEluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFjY291bnRJbmZvTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRBY2NvdW50SW5mb1N1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFjY291bnRJbmZvOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICAgIGFjY291bnRJbmZvTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBhY2NvdW50SW5mb0Vycm9yOiBudWxsLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEFjY291bnRJbmZvRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY2NvdW50SW5mb0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYWNjb3VudEluZm9FcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGV4dGVuc2lvbiBpbmZvXG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEV4dGVuc2lvbkluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEV4dGVuc2lvbkluZm9TdWNjZXNzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHRlbnNpb25JbmZvOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9FcnJvcjogbnVsbCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRFeHRlbnNpb25JbmZvRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHRlbnNpb25JbmZvTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBleHRlbnNpb25JbmZvRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICAvLyBkaWFsaW5nIHBsYW5zXG4gICAgICBjYXNlIGFjdGlvbnMubG9hZERpYWxpbmdQbGFuczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGlhbGluZ1BsYW5zTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWREaWFsaW5nUGxhbnNTdWNjZXNzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkaWFsaW5nUGxhbnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGRpYWxpbmdQbGFuczogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgYWN0aW9uLmxvYWREaWFsaW5nUGxhbnNGYWlsZWQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRpYWxpbmdQbGFuc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZGlhbGluZ1BsYW5zRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG5cbiAgICAgIC8vIHBob25lIG51bWJlcnNcbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkUGhvbmVOdW1iZXJzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwaG9uZU51bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZFBob25lTnVtYmVyc1N1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBob25lTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZFBob25lTnVtYmVyc0ZhaWxlZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcGhvbmVOdW1iZXJzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBwaG9uZU51bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGZvcndhcmRpbmcgbnVtYmVyc1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRGb3J3YXJkaW5nTnVtYmVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEZvcndhcmRpbmdOdW1iZXJzU3VjY2VzczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcndhcmRpbmdOdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmb3J3YXJkaW5nTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGJsb2NrZWQgbnVtYmVyc1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRCbG9ja2VkTnVtYmVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEJsb2NrZWROdW1iZXJzU3VjY2VzczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGJsb2NrZWROdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBibG9ja2VkTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgYWN0aW9uLmNsZWFyVXNlckluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvdXNlci91c2VyLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5cbmNvbnN0IGV2ZW50RGVmaW5pdGlvbnMgPSB7XG4gIHVzZXJJbmZvTG9hZGVkOiAnVVNFUl9JTkZPX0xPQURFRCcsXG4gIHVzZXJJbmZvQ2xlYXJlZDogJ1VTRVJfSU5GT19DTEVBUkVEJyxcblxuICBsb2FkQWNjb3VudEluZm86ICdMT0FEX0FDQ09VTlRfSU5GTycsXG4gIGxvYWRBY2NvdW50SW5mb1N1Y2Nlc3M6ICdMT0FEX0FDQ09VTlRfSU5GT19TVUNDRVNTJyxcbiAgbG9hZEFjY291bnRJbmZvRmFpbGVkOiAnTE9BRF9BQ0NPVU5UX0lORk9fRkFJTEVEJyxcblxuICBsb2FkRXh0ZW5zaW9uSW5mbzogJ0xPQURfRVhURU5TSU9OX0lORk8nLFxuICBsb2FkRXh0ZW5zaW9uSW5mb1N1Y2Nlc3M6ICdMT0FEX0VYVEVOU0lPTl9JTkZPX1NVQ0NFU1MnLFxuICBsb2FkRXh0ZW5zaW9uSW5mb0ZhaWxlZDogJ0xPQURfRVhURU5TSU9OX0lORk9fRkFJTEVEJyxcblxuICBsb2FkRGlhbGluZ1BsYW5zOiAnTE9BRF9ESUFMSU5HX1BMQU5TJyxcbiAgbG9hZERpYWxpbmdQbGFuc1N1Y2Nlc3M6ICdMT0FEX0RJQUxJTkdfUExBTlNfU1VDQ0VTUycsXG4gIGxvYWREaWFsaW5nUGxhbnNGYWlsZWQ6ICdMT0FEX0RJQUxJTkdfUExBTlNfRkFJTEVEJyxcblxuICBsb2FkUGhvbmVOdW1iZXJzOiAnTE9BRF9QSE9ORV9OVU1CRVJTJyxcbiAgbG9hZFBob25lTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX1BIT05FX05VTUJFUlNfU1VDQ0VTUycsXG4gIGxvYWRQaG9uZU51bWJlcnNGYWlsZWQ6ICdMT0FEX1BIT05FX05VTUJFUlNfRkFJTEVEJyxcblxuICBsb2FkRm9yd2FyZGluZ051bWJlcnM6ICdMT0FEX0ZPUldBUkRJTkdfTlVNQkVSUycsXG4gIGxvYWRGb3J3YXJkaW5nTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX0ZPUldBUkRJTkdfTlVNQkVSU19TVUNDRVNTJyxcbiAgbG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkOiAnTE9BRF9GT1JXQVJESU5HX05VTUJFUlNfRkFJTEVEJyxcblxuICBsb2FkQmxvY2tlZE51bWJlcnM6ICdMT0FEX0JMT0NLRURfTlVNQkVSUycsXG4gIGxvYWRCbG9ja2VkTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX0JMT0NLRURfTlVNQkVSU19TVUNDRVNTJyxcbiAgbG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkOiAnTE9BRF9CTE9DS0VEX05VTUJFUlNfRkFJTEVEJyxcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VyRXZlbnRzID0gbmV3IEVudW0oZXZlbnREZWZpbml0aW9ucyk7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb25zID0ge1xuICB1c2VySW5mb0NoYW5nZWQ6ICdVU0VSX0lORk9fQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3QgdXNlckV2ZW50VHlwZXMgPSBuZXcgRW51bShldmVudFR5cGVEZWZpbml0aW9ucyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3VzZXIvdXNlci1ldmVudHMuanNcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4uLy4uL2xpYi9zeW1ib2wtbWFwJztcbmltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcbmltcG9ydCB3ZWJwaG9uZUFjdGlvbnMgZnJvbSAnLi93ZWJwaG9uZS1hY3Rpb25zJztcbmltcG9ydCBjYWxsQWN0aW9ucyBmcm9tICcuL2NhbGwtYWN0aW9ucyc7XG5pbXBvcnQgZ2V0UmVkdWNlciBmcm9tICcuL3dlYnBob25lLXJlZHVjZXInO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSAnZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgUmluZ0NlbnRyYWxXZWJwaG9uZSBmcm9tICdyaW5nY2VudHJhbC13ZWItcGhvbmUnO1xuaW1wb3J0IHdlYnBob25lU3RhdHVzIGZyb20gJy4uLy4uL2VudW1zL3dlYnBob25lLXN0YXR1cyc7XG5pbXBvcnQgY2FsbFN0YXR1cyBmcm9tICcuLi8uLi9lbnVtcy9jYWxsLXN0YXR1cyc7XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ2FwaScsXG4gICdwbGF0Zm9ybScsXG4gICdlbWl0dGVyJyxcbiAgJ3NldHRpbmdzJyxcbiAgJ3Bob25lSW5zdGFuY2UnLFxuXSk7XG5cbmNvbnN0IEVOVU1TID0gbmV3IEVudW0oe1xuICB3ZWJwaG9uZVN0YXR1cyxcbiAgY2FsbFN0YXR1cyxcbn0pO1xuXG5hc3luYyBmdW5jdGlvbiBpbml0UGhvbmVJbnN0YW5jZSgpIHtcbiAgY29uc3QgaW5mbyA9IGF3YWl0IHRoaXNbc3ltYm9scy5wbGF0Zm9ybV1cbiAgICAucG9zdCgnL2NsaWVudC1pbmZvL3NpcC1wcm92aXNpb24nLCB7XG4gICAgICBzaXBJbmZvOiBbeyB0cmFuc3BvcnQ6ICdXU1MnIH1dLFxuICAgIH0pXG4gICAgLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpO1xuICByZXR1cm4gbmV3IFJpbmdDZW50cmFsV2VicGhvbmUoaW5mbywge1xuICAgIGxvZ0xldmVsOiAwLFxuICAgIGF1ZGlvSGVscGVyOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICB9LFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVjb3JkKGZsYWcgPSB0cnVlKSB7XG4gIGlmICghZmxhZykge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uc3RvcFJlY29yZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMuc3RvcFJlY29yZCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi5zdGFydFJlY29yZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMucmVjb3JkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBtdXRlKGZsYWcgPSB0cnVlKSB7XG4gIGlmICghZmxhZykge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24udW5tdXRlKCk7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICB0eXBlOiBjYWxsQWN0aW9ucy51bm11dGUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24ubXV0ZSgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMubXV0ZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaG9sZChmbGFnID0gdHJ1ZSkge1xuICBpZiAoIWZsYWcpIHtcbiAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnVuaG9sZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMudW5ob2xkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLmhvbGQoKTtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmhvbGQsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhcmsoKSB7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24ucGFyaygpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLnBhcmssXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zZmVyKG51bWJlcikge1xuICB0aGlzLmNoZWNrU2Vzc2lvbigpO1xuICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnRyYW5zZmVyKG51bWJlcik7XG4gIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgIG9wZXJhdGlvbjoge1xuICAgICAgdHlwZTogY2FsbEFjdGlvbnMudHJhbnNmZXIsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZsaXAobnVtYmVyKSB7XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uZmxpcChudW1iZXIpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmZsaXAsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGR0bWYobnVtYmVyKSB7XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uZHRtZihudW1iZXIpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmR0bWYsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9wZXJhdGlvbnMobmFtZSwgLi4uYXJncykge1xuICBjb25zdCBhY3Rpb25zID0geyByZWNvcmQsIG11dGUsIGhvbGQsIHBhcmssIHRyYW5zZmVyLCBmbGlwLCBkdG1mIH07XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgYWN0aW9uc1tuYW1lXS5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMuZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICAvLyBUT0RPOiBuZWVkZWQ/XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2VicGhvbmUgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYWN0aW9uczogd2VicGhvbmVBY3Rpb25zLFxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFwaSxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgc2V0dGluZ3MsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpc1tzeW1ib2xzLmFwaV0gPSBhcGk7XG4gICAgdGhpc1tzeW1ib2xzLnBsYXRmb3JtXSA9IHBsYXRmb3JtO1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXSA9IG5ldyBFbWl0dGVyKCk7XG4gICAgdGhpc1tzeW1ib2xzLnNldHRpbmdzXSA9IHNldHRpbmdzO1xuXG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICAgIC8vIFRPRE86IGNvbW1lbnRlZCBvdXQgdW50aWwgc2V0dGluZyBtb2R1bGUgY29tcGxldGVkXG4gICAgLy8gc2V0dGluZ3MucmVnaXN0ZXJSZWR1Y2VyKCd3ZWJwaG9uZScsIGdldFdlYnBob25lUmVkdWNlcigpKVxuXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luU3VjY2VzcywgYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpc1tzeW1ib2xzLnBob25lSW5zdGFuY2VdID0gYXdhaXQgdGhpczo6aW5pdFBob25lSW5zdGFuY2UoKTtcbiAgICAgIHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQub24oJ3JlZ2lzdGVyZWQnLCAoKSA9PiB7XG4gICAgICAgIC8vIHNpcCB3aWxsIGZpcmUgbXVsdGlwbGUgcmVnaXN0ZXJlZCBldmVudHMsIG9ubHkgZGlzcGF0Y2ggb25lIHJlZ2lzdGVyIGFjdGlvbiB0byBzdGF0ZS5cbiAgICAgICAgLy8gVE9ETzogaXMgdGhpcyBpc1JlZ2lzdGVyZWQgc3RhdGUgbmVlZGVkIHRvIGJlIHN0b3JlIGFzIGluc3RhbmNlIHZhcmlhYmxlXG4gICAgICAgIC8vICAgICAgIG9yIGp1c3QgY2hlY2sgc3RvcmUgc3RhdGVcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVnaXN0ZXJlZCkge1xuICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnJlZ2lzdGVyU3VjY2VzcyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVnaXN0ZXJlZCA9IHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQuaXNSZWdpc3RlcmVkKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQub24oJ3VucmVnaXN0ZXJlZCcsICgpID0+IHtcbiAgICAgICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50LmlzUmVnaXN0ZXJlZCgpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudW5yZWdpc3RlcixcbiAgICAgICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmNsZWFyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50Lm9uKCdyZWdpc3RyYXRpb25GYWlsZWQnLCAoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnJlZ2lzdGVyRXJyb3IsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50Lm9uKCdpbnZpdGUnLCAoc2Vzc2lvbikgPT4ge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5saXN0ZW5TZXNzaW9uRXZlbnRzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNlc3Npb24pO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbEluY29taW5nLFxuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHJlbW90ZUlkZW50aXR5OiBzZXNzaW9uLnJlbW90ZUlkZW50aXR5LFxuICAgICAgICAgICAgbG9jYWxJZGVudGl0eTogc2Vzc2lvbi5sb2NhbElkZW50aXR5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZ2V0UmVkdWNlcih0aGlzLnByZWZpeCk7XG4gIH1cblxuICBnZXQgZW51bXMoKSB7XG4gICAgcmV0dXJuIEVOVU1TO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBwaG9uZSBjYWxsLCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGluIHJlZ2lzdGVyU3VjY2VzcyBzdGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9OdW1iZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tTnVtYmVyXVxuICAgKiBAcmV0dXJuIHtTZXNzaW9ufVxuICAgKi9cbiAgYXN5bmMgY2FsbCh7IHRvTnVtYmVyLCBmcm9tTnVtYmVyLCBtZWRpYSB9KSB7XG4gICAgLy8gQ2hlY2sgc3RhdHVzXG4gICAgaWYgKCF0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0pIHtcbiAgICAgIHRocm93IEVycm9yKCdub3QgcmVnaXN0ZXJlZCcpO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICB0b051bWJlcixcbiAgICAgICAgZnJvbU51bWJlcixcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQuaW52aXRlKHRvTnVtYmVyLCB7XG4gICAgICBtZWRpYToge1xuICAgICAgICByZW5kZXI6IG1lZGlhLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlblNlc3Npb25FdmVudHMoKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxFcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGEgcGhvbmUgY2FsbCwgdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGNhbGwgaXMgaW5jb21pbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lZGlhLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JpbmdjZW50cmFsL3JpbmdjZW50cmFsLXdlYi1waG9uZSNhY2NlcHRpbmctaW5jb21pbmctY2FsbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYWNjZXB0KG1lZGlhKSB7XG4gICAgdGhpcy5jaGVja1Nlc3Npb24oKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi5hY2NlcHQobWVkaWEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBUT0RPXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBieWUoKSB7XG4gICAgdGhpcy5jaGVja1Nlc3Npb24oKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi50ZXJtaW5hdGUoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVE9ET1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVjb3JkKGZsYWcpIHtcbiAgICBvcGVyYXRpb25zLmNhbGwodGhpcywgJ3JlY29yZCcsIGZsYWcpO1xuICB9XG5cbiAgYXN5bmMgbXV0ZShmbGFnKSB7XG4gICAgb3BlcmF0aW9ucy5jYWxsKHRoaXMsICdtdXRlJywgZmxhZyk7XG4gIH1cblxuICBhc3luYyBob2xkKGZsYWcpIHtcbiAgICBvcGVyYXRpb25zLmNhbGwodGhpcywgJ2hvbGQnLCBmbGFnKTtcbiAgfVxuXG4gIGFzeW5jIHBhcmsoZmxhZykge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAncGFyaycsIGZsYWcpO1xuICB9XG5cbiAgYXN5bmMgdHJhbnNmZXIobnVtYmVyKSB7XG4gICAgb3BlcmF0aW9ucy5jYWxsKHRoaXMsICd0cmFuc2ZlcicsIG51bWJlcik7XG4gIH1cblxuICBhc3luYyBmbGlwKG51bWJlcikge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAnZmxpcCcsIG51bWJlcik7XG4gIH1cblxuICBhc3luYyBkdG1mKG51bWJlcikge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAnZHRtZicsIG51bWJlcik7XG4gIH1cblxuICBjaGVja1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnNlc3Npb25FcnJvcixcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgRXJyb3IoJ05vIGFjdGl2ZSBzZXNzaW9uJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCBmb3IgbGlzdGVuIHNlc3Npb24gZXZlbnRzXG4gICAqL1xuICBsaXN0ZW5TZXNzaW9uRXZlbnRzKCkge1xuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ2FjY2VwdGVkJywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAvLyBhY2NlcHRlZCBldmVudCBmb3Igb3V0Ym91bmQgY2FsbCB3aWxsIHJldHVybmUgYSBpbmNvbWluZ1Jlc3BvbnNlXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YSkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbENvbm5lY3QsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgcmVtb3RlSWRlbnRpdHk6IHJlc3BvbnNlLnRvLFxuICAgICAgICAgICAgbG9jYWxJZGVudGl0eTogcmVzcG9uc2UuZnJvbSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIC8vIGFjY2VwdGVkIGV2ZW50IGZvciBpbmJvdW5kIGNhbGwgd2lsbCBvbmx5IGNvbnRhaW4gYSByb3cgc2lwIGRhdGFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsQWNjZXB0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBhbGwgc2l0dWF0aW9uIGFib3V0IGNhbGwgdGVybWluYXRlZCBleGNlcHQgJ2NhbGwgY2FuY2VsJ1xuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ3Rlcm1pbmF0ZWQnLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxFbmQsXG4gICAgICAgIGVycm9yOiBjYXVzZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgfSk7XG4gICAgLy8gd2hlbiB3ZSBjYWxsIG91dCBhbmQgY2FuY2VsIHRoZSBwaG9uZSBjYWxsXG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbi5vbignY2FuY2VsJywgKHJlc3BvbnNlLCBjYXVzZSkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsRW5kLFxuICAgICAgICBlcnJvcjogY2F1c2UsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgIH0pO1xuICAgIC8vIHNob3VsZCBub3QgbmVlZFxuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ2J5ZScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsRW5kLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gbnVsbDtcbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS9pbmRleC5qc1xuICoqLyIsImltcG9ydCB7IEFjdGlvbk1hcCB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgQWN0aW9uTWFwKFtcbiAgJ3JlZ2lzdGVyJyxcbiAgJ3JlZ2lzdGVyU3VjY2VzcycsXG4gICdyZWdpc3RlckVycm9yJyxcbiAgJ3VucmVnaXN0ZXInLFxuXG4gIC8vIG91dGJvdW5kIGNhbGxcbiAgJ2NhbGwnLFxuICAnY2FsbENvbm5lY3QnLFxuICAvLyBpbmJvdW5kIGNhbGxcbiAgJ2NhbGxBY2NlcHQnLFxuICAnY2FsbEluY29taW5nJyxcblxuICAnY2FsbEVuZCcsXG4gICdjYWxsRXJyb3InLFxuICAnY2FsbE9wZXJhdGlvbicsXG4gIC8vIG5vIGFjdGl2ZSBzZXNzaW9uXG4gICdzZXNzaW9uRXJyb3InLFxuXSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBBY3Rpb25NYXAgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFjdGlvbk1hcChbXG4gIC8vIG9wZXJhdGlvbmFsIGVycm9yXG4gICdlcnJvcicsXG4gIC8vIHVucmVnaXN0ZXIsIGNsZWFyIG9wZXJhdGlvbmFsIHN0YXRlXG4gICdjbGVhcicsXG4gIC8vIG9wZXJhdGlvblxuICAnZmxpcCcsXG4gICdyZWNvcmQnLFxuICAnc3RvcFJlY29yZCcsXG4gICdob2xkJyxcbiAgJ3VuaG9sZCcsXG4gICdtdXRlJyxcbiAgJ3VubXV0ZScsXG4gICdwYXJrJyxcbiAgJ3RyYW5zZmVyJyxcbiAgJ2ZvcndhcmQnLFxuICAnZHRtZicsXG5dKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1hY3Rpb25zLmpzXG4gKiovIiwiaW1wb3J0IHsgcHJlZml4QWN0aW9ucyB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuaW1wb3J0IHdlYnBob25lQWN0aW9ucyBmcm9tICcuL3dlYnBob25lLWFjdGlvbnMnO1xuaW1wb3J0IHdlYnBob25lU3RhdHVzIGZyb20gJy4uLy4uL2VudW1zL3dlYnBob25lLXN0YXR1cyc7XG5cbmltcG9ydCBjYWxsUmVkdWNlciBmcm9tICcuL2NhbGwtcmVkdWNlcic7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgc3RhdHVzOiB3ZWJwaG9uZVN0YXR1cy5wcmVSZWdpc3RlcixcbiAgLy8gYXNzaWduIGZyb20gVUlcbiAgdG9OdW1iZXI6ICcnLFxuICBmcm9tTnVtYmVyOiAnJyxcbiAgLy8gc2lwIGluZm8gcmV0dXJuIGZyb20gc2lwIHNlcnZlclxuICByZW1vdGVJZGVudGl0eTogbnVsbCxcbiAgbG9jYWxJZGVudGl0eTogbnVsbCxcbiAgb3BlcmF0aW9uOiBjYWxsUmVkdWNlcigpLFxuICBlcnJvcjogbnVsbCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJlZHVjZXIocHJlZml4KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBwcmVmaXhBY3Rpb25zKHdlYnBob25lQWN0aW9ucywgcHJlZml4KTtcblxuICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgaWYgKCFhY3Rpb24pIHJldHVybiBzdGF0ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICAgIGNhc2UgYWN0aW9ucy5yZWdpc3RlclN1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJTdWNjZXNzZWQsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBhY3Rpb25zLnJlZ2lzdGVyRXJyb3I6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJGYWlsZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMudW5yZWdpc3RlcjpcbiAgICAgICAgcmV0dXJuIGluaXRpYWxTdGF0ZTtcbiAgICAgIGNhc2UgYWN0aW9ucy5jYWxsOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxDb25uZWN0aW5nLFxuICAgICAgICAgIHRvTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC50b051bWJlcixcbiAgICAgICAgICBmcm9tTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC5mcm9tTnVtYmVyLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgYWN0aW9ucy5jYWxsSW5jb21pbmc6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMuY2FsbEluY29taW5nLFxuICAgICAgICAgIHJlbW90ZUlkZW50aXR5OiBhY3Rpb24ucGF5bG9hZC5yZW1vdGVJZGVudGl0eSxcbiAgICAgICAgICBsb2NhbElkZW50aXR5OiBhY3Rpb24ucGF5bG9hZC5sb2NhbElkZW50aXR5LFxuICAgICAgICB9KTtcbiAgICAgIC8vIFRPRE86IHVwZGF0ZSBmcm9tTnVtYmVyLCB0b051bWJlclxuICAgICAgY2FzZSBhY3Rpb25zLmNhbGxDb25uZWN0OlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxDb25uZWN0ZWQsXG4gICAgICAgICAgcmVtb3RlSWRlbnRpdHk6IGFjdGlvbi5wYXlsb2FkLnJlbW90ZUlkZW50aXR5LFxuICAgICAgICAgIGxvY2FsSWRlbnRpdHk6IGFjdGlvbi5wYXlsb2FkLmxvY2FsSWRlbnRpdHksXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBhY3Rpb25zLmNhbGxBY2NlcHQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMuY2FsbENvbm5lY3RlZCxcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbEVuZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJTdWNjZXNzZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbEVycm9yOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxGYWlsZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbE9wZXJhdGlvbjpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgICAgb3BlcmF0aW9uOiBjYWxsUmVkdWNlcihzdGF0ZS5vcGVyYXRpb24sIGFjdGlvbi5vcGVyYXRpb24pLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgYWN0aW9ucy5zZXNzaW9uRXJyb3I6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUsIHtcbiAgICAgICAgICBlcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICB9KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvd2VicGhvbmUtcmVkdWNlci5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgLy8gRm9yIHJlZ2lzdGVyaW5nXG4gIHByZVJlZ2lzdGVyOiAnUFJFX1JFR0lTVEVSJyxcbiAgcmVnaXN0ZXJTdWNjZXNzZWQ6ICdSRUdJU1RFUl9TVUNDRVNTRUQnLFxuICByZWdpc3RlckZhaWxlZDogJ1JFR0lTVEVSX0ZBSUxFRCcsXG4gIC8vIEZvciBjYWxsb3V0IGFuZCBhY3RpdmUgY2FsbFxuICBjYWxsQ29ubmVjdGluZzogJ0NBTExfQ09OTkVDVElORycsXG4gIGNhbGxDb25uZWN0ZWQ6ICdDQUxMX0NPTk5FQ1RFRCcsXG4gIGNhbGxGYWlsZWQ6ICdDQUxMX0ZBSUxFRCcsXG4gIC8vIEZvciBpbmNvbWluZyBjYWxsXG4gIGNhbGxJbmNvbWluZzogJ0NBTExfSU5DT01JTkcnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEVudW0oZGVmaW5pdGlvbik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9lbnVtcy93ZWJwaG9uZS1zdGF0dXMuanNcbiAqKi8iLCJpbXBvcnQgY2FsbEFjdGlvbnMgZnJvbSAnLi9jYWxsLWFjdGlvbnMnO1xuaW1wb3J0IGNhbGxTdGF0dXMgZnJvbSAnLi4vLi4vZW51bXMvY2FsbC1zdGF0dXMnO1xuXG5mdW5jdGlvbiBjb250YWluKGFyciwgZWxlKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZihlbGUpID4gLTE7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShhcnIsIGVsZSkge1xuICBpZiAoY29udGFpbihhcnIsIGVsZSkpIHtcbiAgICBhcnIuc3BsaWNlKGFyci5pbmRleE9mKGVsZSksIDEpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgLy8gb3BlcmF0aW9ucyB3aGljaCBpcyBlbmFibGVcbiAgc3RhdHVzOiBbXSxcbiAgLy8gc29tZSBvcGVyYXRpb25zIHdpbGwgZGlzYWJsZSBhbm90aGVyLCBzdWNoIGFzICdob2xkJ1xuICBkaXNhYmxlZDogW10sXG4gIC8vIHNvbWUgb3BlcmF0aW9ucyBoYXZlIGluZm9tYXRpb24gbmVlZCB0byBiZSBzdG9yZWRcbiAgdHJhbnNmZXJUYWdldDogbnVsbCxcbiAgZmxpcFRhcmdldDogbnVsbCxcbiAgZHRtZk51bWJlcjogbnVsbCxcbiAgLy8gb3BlcmF0aW9uIGVycm9yXG4gIGVycm9yOiBudWxsLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICBpZiAoIWFjdGlvbikgcmV0dXJuIHN0YXRlO1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICBjYXNlIGNhbGxBY3Rpb25zLmVycm9yOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIGVycm9yOiBhY3Rpb24uZXJyb3IsXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLmNsZWFyOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy5yZWNvcmQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiBjb250YWluKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5yZWNvcmRpbmcpID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMucmVjb3JkaW5nKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuc3RvcFJlY29yZDpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IHJlbW92ZShzdGF0ZS5zdGF0dXMsIGNhbGxTdGF0dXMucmVjb3JkaW5nKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMubXV0ZTpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLm11dGVkKSA/XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgOlxuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzLmNvbmNhdChjYWxsU3RhdHVzLm11dGVkKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMudW5tdXRlOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIHN0YXR1czogcmVtb3ZlKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5tdXRlZCksXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLmhvbGQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiBjb250YWluKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5ob2xkaW5nKSA/XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgOlxuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzLmNvbmNhdChjYWxsU3RhdHVzLmhvbGRpbmcpLFxuICAgICAgICBkaXNhYmxlZDogWydwYXJrJywgJ3JlY29yZCddLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy51bmhvbGQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiByZW1vdmUoc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLmhvbGRpbmcpLFxuICAgICAgICBkaXNhYmxlZDogW10sXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLnBhcms6XG4gICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWxsX3BhcmtpbmdcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLnBhcmtlcikgP1xuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzIDpcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cy5jb25jYXQoY2FsbFN0YXR1cy5wYXJrZXIpLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy50cmFuc2ZlcjpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLnRyYW5zZmVyZWQpID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMudHJhbnNmZXJlZCksXG4gICAgICAgIHRyYW5zZmVyVGFnZXQ6IGFjdGlvbi5wYXlsb2FkLm51bWJlcixcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuZmxpcDpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLmZsaXApID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMuZmxpcCksXG4gICAgICAgIGZsaXBUYXJnZXQ6IGFjdGlvbi5wYXlsb2FkLm51bWJlcixcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuZHRtZjpcbiAgICAgIC8vIFRPRE86IGNsYXJpZnkgcGFyayBhY3Rpb25cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IHN0YXRlLnN0YXR1cy5jb25jYXQoY2FsbFN0YXR1cy5wYXJrZWQpLFxuICAgICAgICBkdG1mTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC5udW1iZXIsXG4gICAgICB9KTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1yZWR1Y2VyLmpzXG4gKiovIiwiaW1wb3J0IEVudW0gZnJvbSAnLi4vbGliL2VudW0nO1xuXG5jb25zdCBkZWZpbml0aW9uID0ge1xuICBmbGlwOiAnRkxJUEVEJyxcbiAgcmVjb3JkaW5nOiAnUkVDT1JESU5HJyxcbiAgaG9sZGluZzogJ0hPTERJTkcnLFxuICBtdXRlZDogJ01VVEVEJyxcbiAgcGFya2VkOiAnUEFSS0VEJyxcbiAgdHJhbnNmZXJlZDogJ1RSQU5TRkVSRUQnLFxuICBmb3J3YXJkZWQ6ICdGT1dBUkRFRCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgRW51bShkZWZpbml0aW9uKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2VudW1zL2NhbGwtc3RhdHVzLmpzXG4gKiovIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ3NpcC5qcyddLCBmdW5jdGlvbihTSVApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KFNJUCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3NpcC5qcycpKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzOyAvL0VTNlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuUmluZ0NlbnRyYWwgPSByb290LlJpbmdDZW50cmFsIHx8IHt9O1xuICAgICAgICByb290LlJpbmdDZW50cmFsLldlYlBob25lID0gZmFjdG9yeShyb290LlNJUCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbihTSVApIHtcblxuICAgIHZhciBtZXNzYWdlcyA9IHtcbiAgICAgICAgcGFyazoge3JlcWlkOiAxLCBjb21tYW5kOiAnY2FsbHBhcmsnfSxcbiAgICAgICAgc3RhcnRSZWNvcmQ6IHtyZXFpZDogMiwgY29tbWFuZDogJ3N0YXJ0Y2FsbHJlY29yZCd9LFxuICAgICAgICBzdG9wUmVjb3JkOiB7cmVxaWQ6IDMsIGNvbW1hbmQ6ICdzdG9wY2FsbHJlY29yZCd9LFxuICAgICAgICBmbGlwOiB7cmVxaWQ6IDMsIGNvbW1hbmQ6ICdjYWxsZmxpcCcsIHRhcmdldDogJyd9LFxuICAgICAgICBtb25pdG9yOiB7cmVxaWQ6IDQsIGNvbW1hbmQ6ICdtb25pdG9yJ30sXG4gICAgICAgIGJhcmdlOiB7cmVxaWQ6IDUsIGNvbW1hbmQ6ICdiYXJnZSd9LFxuICAgICAgICB3aGlzcGVyOiB7cmVxaWQ6IDYsIGNvbW1hbmQ6ICd3aGlzcGVyJ30sXG4gICAgICAgIHRha2VvdmVyOiB7cmVxaWQ6IDcsIGNvbW1hbmQ6ICd0YWtlb3Zlcid9XG4gICAgfTtcblxuICAgIHZhciByZXNwb25zZVRpbWVvdXQgPSAxMDAwMDtcblxuICAgIGZ1bmN0aW9uIHV1aWQoKSB7XG4gICAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsYXkobXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChkc3QsIHNyYykge1xuICAgICAgICBzcmMgPSBzcmMgfHwge307XG4gICAgICAgIGRzdCA9IGRzdCB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGRzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1ZGlvSGVscGVyKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLl9lbmFibGVkID0gISFvcHRpb25zLmVuYWJsZWQ7XG4gICAgICAgIHRoaXMuX2luY29taW5nID0gb3B0aW9ucy5pbmNvbWluZyB8fCAnLi4vYXVkaW8vaW5jb21pbmcub2dnJztcbiAgICAgICAgdGhpcy5fb3V0Z29pbmcgPSBvcHRpb25zLm91dGdvaW5nIHx8ICcuLi9hdWRpby9vdXRnb2luZy5vZ2cnO1xuICAgICAgICB0aGlzLl9hdWRpbyA9IHt9O1xuXG4gICAgfVxuXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLl9wbGF5U291bmQgPSBmdW5jdGlvbih1cmwsIHZhbCwgdm9sdW1lKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoIXRoaXMuX2F1ZGlvW3VybF0pIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdID0gbmV3IEF1ZGlvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9bdXJsXS5zcmMgPSB1cmw7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9bdXJsXS5sb29wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnBsYXkoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9bdXJsXS5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLnBsYXlJbmNvbWluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxheVNvdW5kKHRoaXMuX2luY29taW5nLCB2YWwsIDAuNSk7XG4gICAgfTtcblxuICAgIEF1ZGlvSGVscGVyLnByb3RvdHlwZS5wbGF5T3V0Z29pbmcgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlTb3VuZCh0aGlzLl9vdXRnb2luZywgdmFsLCAxKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVnRGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudXVpZF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwS2V5XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcHBOYW1lXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcHBWZXJzaW9uXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hdWRpb0hlbHBlcl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub25TZXNzaW9uXSBmaXJlZCBlYWNoIHRpbWUgVXNlckFnZW50IHN0YXJ0cyB3b3JraW5nIHdpdGggc2Vzc2lvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdlYlBob25lKHJlZ0RhdGEsIG9wdGlvbnMpIHtcblxuICAgICAgICByZWdEYXRhID0gcmVnRGF0YSB8fCB7fTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5zaXBJbmZvID0gcmVnRGF0YS5zaXBJbmZvWzBdIHx8IHJlZ0RhdGEuc2lwSW5mbztcbiAgICAgICAgdGhpcy5zaXBGbGFncyA9IHJlZ0RhdGEuc2lwRmxhZ3M7XG5cbiAgICAgICAgdmFyIGlkID0gb3B0aW9ucy51dWlkIHx8IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdyYy13ZWJQaG9uZS11dWlkJykgfHwgdXVpZCgpOyAvL1RPRE8gTWFrZSBjb25maWd1cmFibGVcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JjLXdlYlBob25lLXV1aWQnLCBpZCk7XG5cbiAgICAgICAgdGhpcy5lbmRwb2ludEhlYWRlciA9ICdQLXJjLWVuZHBvaW50LWlkOiAnICsgaWQ7XG5cbiAgICAgICAgdmFyIGNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgICAgICB1cmk6ICdzaXA6JyArIHRoaXMuc2lwSW5mby51c2VybmFtZSArICdAJyArIHRoaXMuc2lwSW5mby5kb21haW4sXG4gICAgICAgICAgICB3c1NlcnZlcnM6IHRoaXMuc2lwSW5mby5vdXRib3VuZFByb3h5ICYmIHRoaXMuc2lwSW5mby50cmFuc3BvcnRcbiAgICAgICAgICAgICAgICA/IHRoaXMuc2lwSW5mby50cmFuc3BvcnQudG9Mb3dlckNhc2UoKSArICc6Ly8nICsgdGhpcy5zaXBJbmZvLm91dGJvdW5kUHJveHlcbiAgICAgICAgICAgICAgICA6IHRoaXMuc2lwSW5mby53c1NlcnZlcnMsXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uVXNlcjogdGhpcy5zaXBJbmZvLmF1dGhvcml6YXRpb25JZCxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLnNpcEluZm8ucGFzc3dvcmQsXG4gICAgICAgICAgICB0cmFjZVNpcDogdHJ1ZSxcbiAgICAgICAgICAgIHN0dW5TZXJ2ZXJzOiB0aGlzLnNpcEluZm8uc3R1blNlcnZlcnMgfHwgWydzdHVuOjc0LjEyNS4xOTQuMTI3OjE5MzAyJ10sIC8vRklYTUUgSGFyZGNvZGVkP1xuICAgICAgICAgICAgdHVyblNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgbG9nOiB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IG9wdGlvbnMubG9nTGV2ZWwgfHwgMSAvL0ZJWE1FIExPRyBMRVZFTCAzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tYWluOiB0aGlzLnNpcEluZm8uZG9tYWluLFxuICAgICAgICAgICAgYXV0b3N0YXJ0OiB0cnVlLFxuICAgICAgICAgICAgcmVnaXN0ZXI6IHRydWUsXG4gICAgICAgICAgICBpY2VHYXRoZXJpbmdUaW1lb3V0OiB0aGlzLnNpcEluZm8uaWNlR2F0aGVyaW5nVGltZW91dCB8fCAzMDAwXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hcHBLZXkgPSBvcHRpb25zLmFwcEtleTtcbiAgICAgICAgdGhpcy5hcHBOYW1lID0gb3B0aW9ucy5hcHBOYW1lO1xuICAgICAgICB0aGlzLmFwcFZlcnNpb24gPSBvcHRpb25zLmFwcFZlcnNpb247XG4gICAgICAgIHRoaXMudXNlckFnZW50SGVhZGVyID0gJ1JDLVVzZXItQWdlbnQ6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25zLmFwcE5hbWUgPyAob3B0aW9ucy5hcHBOYW1lICsgKG9wdGlvbnMuYXBwVmVyc2lvbiA/ICcvJyArIG9wdGlvbnMuYXBwVmVyc2lvbiA6ICcnKSkgKyAnICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSQ1dFQlBIT05FLycgKyBXZWJQaG9uZS52ZXJzaW9uO1xuXG4gICAgICAgIHRoaXMuY2xpZW50SWRIZWFkZXIgPSAnQ2xpZW50LWlkOicgKyBvcHRpb25zLmFwcEtleTtcblxuICAgICAgICB0aGlzLnVzZXJBZ2VudCA9IG5ldyBTSVAuVUEoY29uZmlndXJhdGlvbikucmVnaXN0ZXIoe1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBbXG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludEhlYWRlcixcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJBZ2VudEhlYWRlcixcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudElkSGVhZGVyXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudXNlckFnZW50LmVuZHBvaW50SGVhZGVyID0gdGhpcy5lbmRwb2ludEhlYWRlcjtcbiAgICAgICAgdGhpcy51c2VyQWdlbnQudXNlckFnZW50SGVhZGVyID0gdGhpcy51c2VyQWdlbnRIZWFkZXI7XG4gICAgICAgIHRoaXMudXNlckFnZW50LmNsaWVudElkSGVhZGVyID0gdGhpcy5jbGllbnRJZEhlYWRlcjtcbiAgICAgICAgdGhpcy51c2VyQWdlbnQuc2lwSW5mbyA9IHRoaXMuc2lwSW5mbztcblxuICAgICAgICB0aGlzLnVzZXJBZ2VudC5fX2ludml0ZSA9IHRoaXMudXNlckFnZW50Lmludml0ZTtcbiAgICAgICAgdGhpcy51c2VyQWdlbnQuaW52aXRlID0gaW52aXRlO1xuXG4gICAgICAgIHRoaXMudXNlckFnZW50Lm9uKCdpbnZpdGUnLCBmdW5jdGlvbihzZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJBZ2VudC5hdWRpb0hlbHBlci5wbGF5SW5jb21pbmcodHJ1ZSk7XG4gICAgICAgICAgICBwYXRjaFNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQuYXVkaW9IZWxwZXIgPSBuZXcgQXVkaW9IZWxwZXIob3B0aW9ucy5hdWRpb0hlbHBlcik7XG5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQub25TZXNzaW9uID0gb3B0aW9ucy5vblNlc3Npb24gfHwgbnVsbDtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgV2ViUGhvbmUudmVyc2lvbiA9ICcwLjMuMSc7XG4gICAgV2ViUGhvbmUudXVpZCA9IHV1aWQ7XG4gICAgV2ViUGhvbmUuZGVsYXkgPSBkZWxheTtcbiAgICBXZWJQaG9uZS5leHRlbmQgPSBleHRlbmQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIGZ1bmN0aW9uIHBhdGNoU2Vzc2lvbihzZXNzaW9uKSB7XG5cbiAgICAgICAgaWYgKHNlc3Npb24uX19wYXRjaGVkKSByZXR1cm4gc2Vzc2lvbjtcblxuICAgICAgICBzZXNzaW9uLl9fcGF0Y2hlZCA9IHRydWU7XG5cbiAgICAgICAgc2Vzc2lvbi5fX3NlbmRSZXF1ZXN0ID0gc2Vzc2lvbi5zZW5kUmVxdWVzdDtcbiAgICAgICAgc2Vzc2lvbi5fX3JlY2VpdmVSZXF1ZXN0ID0gc2Vzc2lvbi5yZWNlaXZlUmVxdWVzdDtcbiAgICAgICAgc2Vzc2lvbi5fX3JlY2VpdmVJbnZpdGVSZXNwb25zZSA9IHNlc3Npb24ucmVjZWl2ZUludml0ZVJlc3BvbnNlO1xuICAgICAgICBzZXNzaW9uLl9fcmVjZWl2ZVJlc3BvbnNlID0gc2Vzc2lvbi5yZWNlaXZlUmVzcG9uc2U7XG4gICAgICAgIHNlc3Npb24uX19hY2NlcHQgPSBzZXNzaW9uLmFjY2VwdDtcbiAgICAgICAgc2Vzc2lvbi5fX2hvbGQgPSBzZXNzaW9uLmhvbGQ7XG4gICAgICAgIHNlc3Npb24uX191bmhvbGQgPSBzZXNzaW9uLnVuaG9sZDtcbiAgICAgICAgc2Vzc2lvbi5fX2R0bWYgPSBzZXNzaW9uLmR0bWY7XG5cbiAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdCA9IHNlbmRSZXF1ZXN0O1xuICAgICAgICBzZXNzaW9uLnJlY2VpdmVSZXF1ZXN0ID0gcmVjZWl2ZVJlcXVlc3Q7XG4gICAgICAgIHNlc3Npb24ucmVjZWl2ZUludml0ZVJlc3BvbnNlID0gcmVjZWl2ZUludml0ZVJlc3BvbnNlO1xuICAgICAgICBzZXNzaW9uLnJlY2VpdmVSZXNwb25zZSA9IHJlY2VpdmVSZXNwb25zZTtcbiAgICAgICAgc2Vzc2lvbi5hY2NlcHQgPSBhY2NlcHQ7XG4gICAgICAgIHNlc3Npb24uaG9sZCA9IGhvbGQ7XG4gICAgICAgIHNlc3Npb24udW5ob2xkID0gdW5ob2xkO1xuICAgICAgICBzZXNzaW9uLmR0bWYgPSBkdG1mO1xuXG4gICAgICAgIHNlc3Npb24uYmxpbmRUcmFuc2ZlciA9IGJsaW5kVHJhbnNmZXI7XG4gICAgICAgIHNlc3Npb24udHJhbnNmZXIgPSB0cmFuc2ZlcjtcbiAgICAgICAgc2Vzc2lvbi5wYXJrID0gcGFyaztcbiAgICAgICAgc2Vzc2lvbi5mb3J3YXJkID0gZm9yd2FyZDtcbiAgICAgICAgc2Vzc2lvbi5zdGFydFJlY29yZCA9IHN0YXJ0UmVjb3JkO1xuICAgICAgICBzZXNzaW9uLnN0b3BSZWNvcmQgPSBzdG9wUmVjb3JkO1xuICAgICAgICBzZXNzaW9uLmZsaXAgPSBmbGlwO1xuXG4gICAgICAgIHNlc3Npb24ub24oJ3JlcGxhY2VkJywgcGF0Y2hTZXNzaW9uKTtcbiAgICAgICAgLy8gc2Vzc2lvbi5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG5cbiAgICAgICAgLy8gQXVkaW9cbiAgICAgICAgc2Vzc2lvbi5vbignYWNjZXB0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ub24oJ3JlamVjdGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm9uKCdieWUnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ub24oJ3Rlcm1pbmF0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ub24oJ2NhbmNlbCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5vbignZmFpbGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm9uKCdyZXBsYWNlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oJ2ljZUNvbm5lY3Rpb25Db21wbGV0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ubWVkaWFIYW5kbGVyLm9uKCdpY2VDb25uZWN0aW9uRmFpbGVkJywgc3RvcFBsYXlpbmcpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHN0b3BQbGF5aW5nKCkge1xuICAgICAgICAgICAgc2Vzc2lvbi51YS5hdWRpb0hlbHBlci5wbGF5T3V0Z29pbmcoZmFsc2UpO1xuICAgICAgICAgICAgc2Vzc2lvbi51YS5hdWRpb0hlbHBlci5wbGF5SW5jb21pbmcoZmFsc2UpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignYWNjZXB0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdyZWplY3RlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ2J5ZScsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ3Rlcm1pbmF0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdjYW5jZWwnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdmYWlsZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdyZXBsYWNlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ubWVkaWFIYW5kbGVyLnJlbW92ZUxpc3RlbmVyKCdpY2VDb25uZWN0aW9uQ29tcGxldGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5tZWRpYUhhbmRsZXIucmVtb3ZlTGlzdGVuZXIoJ2ljZUNvbm5lY3Rpb25GYWlsZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Vzc2lvbi51YS5vblNlc3Npb24pIHNlc3Npb24udWEub25TZXNzaW9uKHNlc3Npb24pO1xuXG4gICAgICAgIHJldHVybiBzZXNzaW9uO1xuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29tbWFuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlbmRSZWNlaXZlKHNlc3Npb24sIGNvbW1hbmQsIG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBleHRlbmQoY29tbWFuZCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIGNzZXEgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdChTSVAuQy5JTkZPLCB7XG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBjb21tYW5kXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi51YS51c2VyQWdlbnRIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24udWEuZW5kcG9pbnRIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24udWEuY2xpZW50SWRIZWFkZXJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NlcSA9IHJlc3BvbnNlLmNzZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25JbmZvID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5jc2VxID09PSBjc2VxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSByZXF1ZXN0ICYmIHJlcXVlc3QuYm9keSB8fCAne30nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmoucmVzcG9uc2UgJiYgb2JqLnJlc3BvbnNlLmNvbW1hbmQgPT09IGNvbW1hbmQuY29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5yZXNwb25zZS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnJlc3BvbnNlLnJlc3VsdC5jb2RlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUob2JqLnJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChvYmoucmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ1JDX1NJUF9JTkZPJywgb25JbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTsgLy9GSVhNRSBXaGF0IHRvIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0OiBubyByZXBseScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdSQ19TSVBfSU5GTycsIG9uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZXNwb25zZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5vbignUkNfU0lQX0lORk8nLCBvbkluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGhlIElORk8gcmVzcG9uc2Ugc3RhdHVzIGNvZGUgaXM6ICcgKyByZXNwb25zZS5zdGF0dXNfY29kZSArICcgKHdhaXRpbmcgZm9yIDIwMCknKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgZnVuY3Rpb24gc2VuZFJlcXVlc3QodHlwZSwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0eXBlID09IFNJUC5DLlBSQUNLKSB7XG4gICAgICAgICAgICB0eXBlID0gU0lQLkMuQUNLO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fc2VuZFJlcXVlc3QodHlwZSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGVhY2ggdGltZSBhIHByb3Zpc2lvbmFsICgxMDAtMTk5KSByZXNwb25zZSBpcyByZWNlaXZlZC5cbiAgICAgKiBFYXJseSBtZWRpYSBpcyBzdXBwb3J0ZWQgYnkgU0lQLmpzIGxpYnJhcnlcbiAgICAgKiBCdXQgaW4gY2FzZSBpdCBpcyBzZW50IHdpdGhvdXQgMTAwcmVsIHN1cHBvcnQgd2UgcGxheSBpdCBtYW51YWxseVxuICAgICAqIFNUQVRVU19FQVJMWV9NRURJQSA9PT0gMTEsIGl0IHdpbGwgYmUgc2V0IGJ5IFNJUC5qcyBpZiAxMDByZWwgaXMgc3VwcG9ydGVkXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwNzIzODhcbiAgICAgKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtmdW5jaXRvbn0gY2JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXRjaDEwMHJlbChzZXNzaW9uLCByZXNwb25zZSwgY2IpIHtcblxuICAgICAgICAvL0Vhcmx5IG1lZGlhIGlzIHN1cHBvcnRlZCBieSBTSVAuanMgbGlicmFyeVxuICAgICAgICAvL0J1dCBpbiBjYXNlIGl0IGlzIHNlbnQgd2l0aG91dCAxMDByZWwgc3VwcG9ydCB3ZSBwbGF5IGl0IG1hbnVhbGx5XG4gICAgICAgIC8vU1RBVFVTX0VBUkxZX01FRElBID09PSAxMSwgaXQgd2lsbCBiZSBzZXQgYnkgU0lQLmpzIGlmIDEwMHJlbCBpcyBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzICE9PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19FQVJMWV9NRURJQSAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA9PT0gMTgzICYmIHR5cGVvZihyZXNwb25zZS5ib2R5KSA9PT0gJ3N0cmluZycgJiYgcmVzcG9uc2UuYm9keS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UuaGFzSGVhZGVyKCdyZXF1aXJlJykpIHJlc3BvbnNlLnNldEhlYWRlcigncmVxdWlyZScsICcxMDByZWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYi5jYWxsKHNlc3Npb24sIHJlc3BvbnNlKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnZpdGVSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcGF0Y2gxMDByZWwodGhpcywgcmVzcG9uc2UsIHRoaXMuX19yZWNlaXZlSW52aXRlUmVzcG9uc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY2VpdmVSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcGF0Y2gxMDByZWwodGhpcywgcmVzcG9uc2UsIHRoaXMuX19yZWNlaXZlUmVzcG9uc2UpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRSZWNvcmQoc2Vzc2lvbiwgZmxhZykge1xuXG4gICAgICAgIHZhciBtZXNzYWdlID0gISFmbGFnXG4gICAgICAgICAgICA/IG1lc3NhZ2VzLnN0YXJ0UmVjb3JkXG4gICAgICAgICAgICA6IG1lc3NhZ2VzLnN0b3BSZWNvcmQ7XG5cbiAgICAgICAgaWYgKChzZXNzaW9uLl9fb25SZWNvcmQgJiYgIWZsYWcpIHx8ICghc2Vzc2lvbi5fX29uUmVjb3JkICYmIGZsYWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VuZFJlY2VpdmUoc2Vzc2lvbiwgbWVzc2FnZSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24uX19vblJlY29yZCA9ICEhZmxhZztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRIb2xkKHNlc3Npb24sIGZsYWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRlZDogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkOiByZWplY3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZmxhZykge1xuICAgICAgICAgICAgICAgIHNlc3Npb24uX19ob2xkKG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLl9fdW5ob2xkKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5VQX1cbiAgICAgKiBAcGFyYW0gbnVtYmVyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTSVAuU2Vzc2lvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZpdGUobnVtYmVyLCBvcHRpb25zKSB7XG5cbiAgICAgICAgdmFyIHVhID0gdGhpcztcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXTtcblxuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKHVhLnVzZXJBZ2VudEhlYWRlcik7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2godWEuZW5kcG9pbnRIZWFkZXIpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKHVhLmNsaWVudElkSGVhZGVyKTtcblxuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdQLUFzc2VydGVkLUlkZW50aXR5OiBzaXA6JyArIChvcHRpb25zLmZyb21OdW1iZXIgfHwgdWEuc2lwSW5mby51c2VybmFtZSkgKyAnQCcgKyB1YS5zaXBJbmZvLmRvbWFpbik7IC8vRklYTUUgUGhvbmUgTnVtYmVyXG5cbiAgICAgICAgLy9GSVhNRSBCYWNrZW5kIHNob3VsZCBrbm93IGl0IGFscmVhZHlcbiAgICAgICAgaWYgKG9wdGlvbnMuaG9tZUNvdW50cnlJZCkgeyBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdQLXJjLWNvdW50cnktaWQ6ICcgKyBvcHRpb25zLmhvbWVDb3VudHJ5SWQpOyB9XG5cbiAgICAgICAgb3B0aW9ucy5tZWRpYSA9IG9wdGlvbnMubWVkaWEgfHwge307XG4gICAgICAgIG9wdGlvbnMubWVkaWEuY29uc3RyYWludHMgPSBvcHRpb25zLm1lZGlhLmNvbnN0cmFpbnRzIHx8IHthdWRpbzogdHJ1ZSwgdmlkZW86IGZhbHNlfTtcblxuICAgICAgICBvcHRpb25zLlJUQ0NvbnN0cmFpbnRzID0gb3B0aW9ucy5SVENDb25zdHJhaW50cyB8fCB7b3B0aW9uYWw6IFt7RHRsc1NydHBLZXlBZ3JlZW1lbnQ6ICd0cnVlJ31dfTtcblxuICAgICAgICB1YS5hdWRpb0hlbHBlci5wbGF5T3V0Z29pbmcodHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGNoU2Vzc2lvbih1YS5fX2ludml0ZShudW1iZXIsIG9wdGlvbnMpKTtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEBwYXJhbSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWNlaXZlUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcztcbiAgICAgICAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBTSVAuQy5JTkZPOlxuICAgICAgICAgICAgICAgIHNlc3Npb24uZW1pdCgnUkNfU0lQX0lORk8nLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAvL1NJUC5qcyBkb2VzIG5vdCBzdXBwb3J0IGFwcGxpY2F0aW9uL2pzb24gY29udGVudCB0eXBlLCBzbyB3ZSBtb25rZXkgb3ZlcnJpZGUgaXRzIGJlaGF2aW91ciBpbiB0aGlzIGNhc2VcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX0NPTkZJUk1FRCB8fCBzZXNzaW9uLnN0YXR1cyA9PT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlLm1hdGNoKC9eYXBwbGljYXRpb25cXC9qc29uL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vUmVmcmVzaCBpbnZpdGUgc2hvdWxkIG5vdCBiZSByZWplY3RlZCB3aXRoIDQ4OFxuICAgICAgICAgICAgY2FzZSBTSVAuQy5JTlZJVEU6XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY2FsbF9pZCAmJiBzZXNzaW9uLmRpYWxvZyAmJiBzZXNzaW9uLmRpYWxvZy5pZCAmJiByZXF1ZXN0LmNhbGxfaWQgPT0gc2Vzc2lvbi5kaWFsb2cuaWQuY2FsbF9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBjaGVjayB0aGF0IFNEUCBkaWQgbm90IGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIubG9nKCdyZS1JTlZJVEUgcmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbFNEUCA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLnBlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb24uc2RwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBseSgyMDAsIG51bGwsIFsnQ29udGFjdDogJyArIHNlc3Npb24uY29udGFjdF0sIGxvY2FsU0RQLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnN0YXR1cyA9IFNJUC5TZXNzaW9uLkMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnNldEludml0ZTJ4eFRpbWVyKHJlcXVlc3QsIGxvY2FsU0RQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnNldEFDS1RpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vZWxzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggNDg4IGJ5IFNJUC5qc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vV2UgbmVlZCB0byBhbmFsaXplIE5PVElGWSBtZXNzYWdlcyBzb21ldGltZXMsIHNvIHdlIGZpcmUgYW4gZXZlbnRcbiAgICAgICAgICAgIGNhc2UgU0lQLkMuTk9USUZZOlxuICAgICAgICAgICAgICAgIHNlc3Npb24uZW1pdCgnUkNfU0lQX05PVElGWScsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXNzaW9uLl9fcmVjZWl2ZVJlcXVlc3QuYXBwbHkoc2Vzc2lvbiwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWNjZXB0KG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXM7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW107XG5cbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChzZXNzaW9uLnVhLnVzZXJBZ2VudEhlYWRlcik7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goc2Vzc2lvbi51YS5lbmRwb2ludEhlYWRlcik7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goc2Vzc2lvbi51YS5jbGllbnRJZEhlYWRlcik7XG5cbiAgICAgICAgb3B0aW9ucy5tZWRpYSA9IG9wdGlvbnMubWVkaWEgfHwge307XG4gICAgICAgIG9wdGlvbnMubWVkaWEuY29uc3RyYWludHMgPSBvcHRpb25zLm1lZGlhLmNvbnN0cmFpbnRzIHx8IHthdWRpbzogdHJ1ZSwgdmlkZW86IGZhbHNlfTtcblxuICAgICAgICBvcHRpb25zLlJUQ0NvbnN0cmFpbnRzID0gb3B0aW9ucy5SVENDb25zdHJhaW50cyB8fCB7b3B0aW9uYWw6IFt7RHRsc1NydHBLZXlBZ3JlZW1lbnQ6ICd0cnVlJ31dfTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uQW5zd2VyZWQoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdmYWlsZWQnLCBvbkZhaWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkZhaWwoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdhY2NlcHRlZCcsIG9uQW5zd2VyZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1RPRE8gTW9yZSBldmVudHM/XG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2FjY2VwdGVkJywgb25BbnN3ZXJlZCk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2ZhaWxlZCcsIG9uRmFpbCk7XG5cbiAgICAgICAgICAgIHNlc3Npb24uX19hY2NlcHQob3B0aW9ucyk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkdG1mXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkdG1mKGR0bWYsIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcztcbiAgICAgICAgZHVyYXRpb24gPSBwYXJzZUludChkdXJhdGlvbikgfHwgMTAwMDtcbiAgICAgICAgdmFyIHBlZXIgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5wZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHN0cmVhbSA9IHNlc3Npb24uZ2V0TG9jYWxTdHJlYW1zKClbMF07XG4gICAgICAgIHZhciBkdG1mU2VuZGVyID0gcGVlci5jcmVhdGVEVE1GU2VuZGVyKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdKTtcbiAgICAgICAgaWYgKGR0bWZTZW5kZXIgIT09IHVuZGVmaW5lZCAmJiBkdG1mU2VuZGVyLmNhbkluc2VydERUTUYpIHtcbiAgICAgICAgICAgIHJldHVybiBkdG1mU2VuZGVyLmluc2VydERUTUYoZHRtZiwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VuZCBEVE1GIGZhaWxlZDogJyArICghZHRtZlNlbmRlciA/ICdubyBzZW5kZXInIDogKCFkdG1mU2VuZGVyLmNhbkluc2VydERUTUYgPyAnY2FuXFwndCBpbnNlcnQgRFRNRicgOiAnVW5rbm93bicpKSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhvbGQoKSB7XG4gICAgICAgIHJldHVybiBzZXRIb2xkKHRoaXMsIHRydWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmhvbGQoKSB7XG4gICAgICAgIHJldHVybiBzZXRIb2xkKHRoaXMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmxpbmRUcmFuc2Zlcih0YXJnZXQsIG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXM7XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXTtcbiAgICAgICAgdmFyIG9yaWdpbmFsVGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vQmxpbmQgVHJhbnNmZXIgaXMgdGFrZW4gZnJvbSBTSVAuanMgc291cmNlXG5cbiAgICAgICAgICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgIT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcihzZXNzaW9uLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZVRhcmdldCBhbGxvd3MgaW5zdGFuY2VzIG9mIFNJUC5VUkkgdG8gcGFzcyB0aHJvdWdoIHVuYWx0ZXJlZCxcbiAgICAgICAgICAgIC8vIHNvIHRyeSB0byBtYWtlIG9uZSBhaGVhZCBvZiB0aW1lXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IFNJUC5HcmFtbWFyLnBhcnNlKHRhcmdldCwgJ1JlZmVyX1RvJykudXJpIHx8IHRhcmdldDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci5kZWJ1ZyhcIi5yZWZlcigpIGNhbm5vdCBwYXJzZSBSZWZlcl9UbyBmcm9tXCIsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIuZGVidWcoXCIuLi5mYWxsaW5nIHRocm91Z2ggdG8gbm9ybWFsaXplVGFyZ2V0KClcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRhcmdldCB2YWxpZGl0eVxuICAgICAgICAgICAgdGFyZ2V0ID0gc2Vzc2lvbi51YS5ub3JtYWxpemVUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0YXJnZXQ6ICcgKyBvcmlnaW5hbFRhcmdldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnICsgc2Vzc2lvbi5jb250YWN0KTtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJyArIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZWZlci1UbzogJyArIHRhcmdldCk7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChzZXNzaW9uLnVhLnVzZXJBZ2VudEhlYWRlcik7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChzZXNzaW9uLnVhLmVuZHBvaW50SGVhZGVyKTtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKHNlc3Npb24udWEuY2xpZW50SWRIZWFkZXIpO1xuXG4gICAgICAgICAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICBzZXNzaW9uLnNlbmRSZXF1ZXN0KFNJUC5DLlJFRkVSLCB7XG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDIwMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxJZCA9IHJlc3BvbnNlLmNhbGxfaWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbk5vdGlmeSA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5jYWxsX2lkID09PSBjYWxsSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSByZXF1ZXN0ICYmIHJlcXVlc3QuYm9keSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIC8xWzAtOV17Mn0vLnRlc3QoYm9keSk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAvMlswLTldezJ9Ly50ZXN0KGJvZHkpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24udGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ1JDX1NJUF9OT1RJRlknLCBvbk5vdGlmeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0OiBubyByZXBseScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdSQ19TSVBfTk9USUZZJywgb25Ob3RpZnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVzcG9uc2VUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ub24oJ1JDX1NJUF9OT1RJRlknLCBvbk5vdGlmeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgaXM6ICcgKyByZXNwb25zZS5zdGF0dXNfY29kZSArICcgKHdhaXRpbmcgZm9yIDIwMiknKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZmVyKHRhcmdldCwgb3B0aW9ucykge1xuXG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKHNlc3Npb24uaXNPbkhvbGQoKSA/IFByb21pc2UucmVzb2x2ZShudWxsKSA6IHNlc3Npb24uaG9sZCgpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiBkZWxheSgzMDApOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24uYmxpbmRUcmFuc2Zlcih0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFjY2VwdE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3RyYW5zZmVyT3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcndhcmQodGFyZ2V0LCBhY2NlcHRPcHRpb25zLCB0cmFuc2Zlck9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBudWxsLFxuICAgICAgICAgICAgc2Vzc2lvbiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHNlc3Npb24uYWNjZXB0KGFjY2VwdE9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0YXR1cyA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLm11dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNlc3Npb24udHJhbnNmZXIodGFyZ2V0LCB0cmFuc2Zlck9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCA3MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydFJlY29yZCgpIHtcbiAgICAgICAgcmV0dXJuIHNldFJlY29yZCh0aGlzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0b3BSZWNvcmQoKSB7XG4gICAgICAgIHJldHVybiBzZXRSZWNvcmQodGhpcywgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsaXAodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBzZW5kUmVjZWl2ZSh0aGlzLCBtZXNzYWdlcy5mbGlwLCB7dGFyZ2V0OiB0YXJnZXR9KTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcmsoKSB7XG4gICAgICAgIHJldHVybiBzZW5kUmVjZWl2ZSh0aGlzLCBtZXNzYWdlcy5wYXJrKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIHJldHVybiBXZWJQaG9uZTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JpbmdjZW50cmFsLXdlYi1waG9uZS9zcmMvcmluZ2NlbnRyYWwtd2ViLXBob25lLmpzXG4gKiogbW9kdWxlIGlkID0gMjEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9TSVAnKShyZXF1aXJlKCcuL2Vudmlyb25tZW50JykpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbmFtZSBTSVBcbiAqIEBuYW1lc3BhY2VcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG5cbnZhciBwa2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcblxudmFyIFNJUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7XG4gIHZlcnNpb246IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBwa2cudmVyc2lvbjsgfVxuICB9LFxuICBuYW1lOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gcGtnLnRpdGxlOyB9XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL1V0aWxzJykoU0lQLCBlbnZpcm9ubWVudCk7XG5TSVAuTG9nZ2VyRmFjdG9yeSA9IHJlcXVpcmUoJy4vTG9nZ2VyRmFjdG9yeScpKGVudmlyb25tZW50LmNvbnNvbGUpO1xuU0lQLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vRXZlbnRFbWl0dGVyJykoZW52aXJvbm1lbnQuY29uc29sZSk7XG5TSVAuQyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJykoU0lQLm5hbWUsIFNJUC52ZXJzaW9uKTtcblNJUC5FeGNlcHRpb25zID0gcmVxdWlyZSgnLi9FeGNlcHRpb25zJyk7XG5TSVAuVGltZXJzID0gcmVxdWlyZSgnLi9UaW1lcnMnKShlbnZpcm9ubWVudC50aW1lcnMpO1xuU0lQLlRyYW5zcG9ydCA9IGVudmlyb25tZW50LlRyYW5zcG9ydChTSVAsIGVudmlyb25tZW50LldlYlNvY2tldCk7XG5yZXF1aXJlKCcuL1BhcnNlcicpKFNJUCk7XG5yZXF1aXJlKCcuL1NJUE1lc3NhZ2UnKShTSVApO1xucmVxdWlyZSgnLi9VUkknKShTSVApO1xucmVxdWlyZSgnLi9OYW1lQWRkckhlYWRlcicpKFNJUCk7XG5yZXF1aXJlKCcuL1RyYW5zYWN0aW9ucycpKFNJUCk7XG5yZXF1aXJlKCcuL0RpYWxvZ3MnKShTSVApO1xucmVxdWlyZSgnLi9SZXF1ZXN0U2VuZGVyJykoU0lQKTtcbnJlcXVpcmUoJy4vUmVnaXN0ZXJDb250ZXh0JykoU0lQKTtcblNJUC5NZWRpYUhhbmRsZXIgPSByZXF1aXJlKCcuL01lZGlhSGFuZGxlcicpKFNJUC5FdmVudEVtaXR0ZXIpO1xucmVxdWlyZSgnLi9DbGllbnRDb250ZXh0JykoU0lQKTtcbnJlcXVpcmUoJy4vU2VydmVyQ29udGV4dCcpKFNJUCk7XG5yZXF1aXJlKCcuL1Nlc3Npb24nKShTSVAsIGVudmlyb25tZW50KTtcbnJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJykoU0lQKTtcblNJUC5XZWJSVEMgPSByZXF1aXJlKCcuL1dlYlJUQycpKFNJUCwgZW52aXJvbm1lbnQpO1xucmVxdWlyZSgnLi9VQScpKFNJUCwgZW52aXJvbm1lbnQpO1xuU0lQLkhhY2tzID0gcmVxdWlyZSgnLi9IYWNrcycpKFNJUCk7XG5yZXF1aXJlKCcuL1Nhbml0eUNoZWNrJykoU0lQKTtcblNJUC5EaWdlc3RBdXRoZW50aWNhdGlvbiA9IHJlcXVpcmUoJy4vRGlnZXN0QXV0aGVudGljYXRpb24nKShTSVAuVXRpbHMpO1xuU0lQLkdyYW1tYXIgPSByZXF1aXJlKCcuL0dyYW1tYXInKShTSVApO1xuXG5yZXR1cm4gU0lQO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvU0lQLmpzXG4gKiogbW9kdWxlIGlkID0gMjEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJfYXJnc1wiOiBbXG5cdFx0W1xuXHRcdFx0XCJzaXAuanNAMC43LjVcIixcblx0XHRcdFwiL1VzZXJzL2hvd2FyZC56aGFuZy9TaXRlcy9yaW5nY2VudHJhbC1qcy1pbnRlZ3JhdGlvbi1jb21tb25zL25vZGVfbW9kdWxlcy9yaW5nY2VudHJhbC13ZWItcGhvbmVcIlxuXHRcdF1cblx0XSxcblx0XCJfZnJvbVwiOiBcInNpcC5qc0AwLjcuNVwiLFxuXHRcIl9pZFwiOiBcInNpcC5qc0AwLjcuNVwiLFxuXHRcIl9pbkNhY2hlXCI6IHRydWUsXG5cdFwiX2luc3RhbGxhYmxlXCI6IHRydWUsXG5cdFwiX2xvY2F0aW9uXCI6IFwiL3NpcC5qc1wiLFxuXHRcIl9ub2RlVmVyc2lvblwiOiBcIjQuNC4zXCIsXG5cdFwiX25wbU9wZXJhdGlvbmFsSW50ZXJuYWxcIjoge1xuXHRcdFwiaG9zdFwiOiBcInBhY2thZ2VzLTEyLXdlc3QuaW50ZXJuYWwubnBtanMuY29tXCIsXG5cdFx0XCJ0bXBcIjogXCJ0bXAvc2lwLmpzLTAuNy41LnRnel8xNDYxNTk0NDE4NjkwXzAuNTgzOTkzMzEyNDM3MDg3M1wiXG5cdH0sXG5cdFwiX25wbVVzZXJcIjoge1xuXHRcdFwiZW1haWxcIjogXCIxMjEyanRyYWNldXJAZ21haWwuY29tXCIsXG5cdFx0XCJuYW1lXCI6IFwiam9zZXBoZnJhemllclwiXG5cdH0sXG5cdFwiX25wbVZlcnNpb25cIjogXCIyLjE1LjFcIixcblx0XCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuXHRcIl9yZXF1ZXN0ZWRcIjoge1xuXHRcdFwibmFtZVwiOiBcInNpcC5qc1wiLFxuXHRcdFwicmF3XCI6IFwic2lwLmpzQDAuNy41XCIsXG5cdFx0XCJyYXdTcGVjXCI6IFwiMC43LjVcIixcblx0XHRcInNjb3BlXCI6IG51bGwsXG5cdFx0XCJzcGVjXCI6IFwiMC43LjVcIixcblx0XHRcInR5cGVcIjogXCJ2ZXJzaW9uXCJcblx0fSxcblx0XCJfcmVxdWlyZWRCeVwiOiBbXG5cdFx0XCIvcmluZ2NlbnRyYWwtd2ViLXBob25lXCJcblx0XSxcblx0XCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9zaXAuanMvLS9zaXAuanMtMC43LjUudGd6XCIsXG5cdFwiX3NoYXN1bVwiOiBcIjg2YWNlNzA1MTU5NGY5MWI0NTUxYmRiODEyMGExNmM0NDk2MmQzYTJcIixcblx0XCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuXHRcIl9zcGVjXCI6IFwic2lwLmpzQDAuNy41XCIsXG5cdFwiX3doZXJlXCI6IFwiL1VzZXJzL2hvd2FyZC56aGFuZy9TaXRlcy9yaW5nY2VudHJhbC1qcy1pbnRlZ3JhdGlvbi1jb21tb25zL25vZGVfbW9kdWxlcy9yaW5nY2VudHJhbC13ZWItcGhvbmVcIixcblx0XCJhdXRob3JcIjoge1xuXHRcdFwiZW1haWxcIjogXCJkZXZlbG9wZXJAb25zaXAuY29tXCIsXG5cdFx0XCJuYW1lXCI6IFwiT25TSVBcIixcblx0XHRcInVybFwiOiBcImh0dHA6Ly9zaXBqcy5jb20vYXV0aG9ycy9cIlxuXHR9LFxuXHRcImJyb3dzZXJcIjoge1xuXHRcdFwiLi9zcmMvZW52aXJvbm1lbnQuanNcIjogXCIuL3NyYy9lbnZpcm9ubWVudF9icm93c2VyLmpzXCJcblx0fSxcblx0XCJidWdzXCI6IHtcblx0XHRcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbnNpcC9TSVAuanMvaXNzdWVzXCJcblx0fSxcblx0XCJjb250cmlidXRvcnNcIjogW1xuXHRcdHtcblx0XHRcdFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL29uc2lwL1NJUC5qcy9ibG9iL21hc3Rlci9USEFOS1MubWRcIlxuXHRcdH1cblx0XSxcblx0XCJkZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwicHJvbWlzY3VvdXNcIjogXCJeMC42LjBcIixcblx0XHRcIndzXCI6IFwiXjAuNi40XCJcblx0fSxcblx0XCJkZXNjcmlwdGlvblwiOiBcIkEgc2ltcGxlLCBpbnR1aXRpdmUsIGFuZCBwb3dlcmZ1bCBKYXZhU2NyaXB0IHNpZ25hbGluZyBsaWJyYXJ5XCIsXG5cdFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcImJlZWZ5XCI6IFwiXjIuMS41XCIsXG5cdFx0XCJicm93c2VyaWZ5XCI6IFwiXjQuMS44XCIsXG5cdFx0XCJncnVudFwiOiBcIn4wLjQuMFwiLFxuXHRcdFwiZ3J1bnQtYnJvd3NlcmlmeVwiOiBcIl40LjAuMVwiLFxuXHRcdFwiZ3J1bnQtY2xpXCI6IFwifjAuMS42XCIsXG5cdFx0XCJncnVudC1jb250cmliLWNvcHlcIjogXCJeMC41LjBcIixcblx0XHRcImdydW50LWNvbnRyaWItamFzbWluZVwiOiBcIl4wLjkuMlwiLFxuXHRcdFwiZ3J1bnQtY29udHJpYi1qc2hpbnRcIjogXCI+MC41LjBcIixcblx0XHRcImdydW50LWNvbnRyaWItdWdsaWZ5XCI6IFwifjAuMi4wXCIsXG5cdFx0XCJncnVudC1wZWdcIjogXCJ+MS4zLjFcIixcblx0XHRcImdydW50LXRyaW10cmFpbGluZ3NwYWNlc1wiOiBcIl4wLjQuMFwiLFxuXHRcdFwicGVnanNcIjogXCJeMC44LjBcIlxuXHR9LFxuXHRcImRpcmVjdG9yaWVzXCI6IHt9LFxuXHRcImRpc3RcIjoge1xuXHRcdFwic2hhc3VtXCI6IFwiODZhY2U3MDUxNTk0ZjkxYjQ1NTFiZGI4MTIwYTE2YzQ0OTYyZDNhMlwiLFxuXHRcdFwidGFyYmFsbFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3NpcC5qcy8tL3NpcC5qcy0wLjcuNS50Z3pcIlxuXHR9LFxuXHRcImVuZ2luZXNcIjoge1xuXHRcdFwibm9kZVwiOiBcIj49MC44XCJcblx0fSxcblx0XCJnaXRIZWFkXCI6IFwiYmFlNDRiZDAzNTlmNGQ3MGRlZDMwOWEzMjM2MWYwNGEwNGU3OGQ2ZVwiLFxuXHRcImhvbWVwYWdlXCI6IFwiaHR0cDovL3NpcGpzLmNvbVwiLFxuXHRcImtleXdvcmRzXCI6IFtcblx0XHRcInNpcFwiLFxuXHRcdFwid2Vic29ja2V0XCIsXG5cdFx0XCJ3ZWJydGNcIixcblx0XHRcImxpYnJhcnlcIixcblx0XHRcImphdmFzY3JpcHRcIlxuXHRdLFxuXHRcImxpY2Vuc2VcIjogXCJNSVRcIixcblx0XCJtYWluXCI6IFwic3JjL2luZGV4LmpzXCIsXG5cdFwibWFpbnRhaW5lcnNcIjogW1xuXHRcdHtcblx0XHRcdFwiZW1haWxcIjogXCJlcmljLmdyZWVuQG9uc2lwLmNvbVwiLFxuXHRcdFx0XCJuYW1lXCI6IFwiZWdyZWVuX29uc2lwXCJcblx0XHR9LFxuXHRcdHtcblx0XHRcdFwiZW1haWxcIjogXCJqYW1lc0BvbnNpcC5jb21cIixcblx0XHRcdFwibmFtZVwiOiBcImphbWVzLWNyaXNjdW9sb1wiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcImVtYWlsXCI6IFwiMTIxMmp0cmFjZXVyQGdtYWlsLmNvbVwiLFxuXHRcdFx0XCJuYW1lXCI6IFwiam9zZXBoZnJhemllclwiXG5cdFx0fVxuXHRdLFxuXHRcIm5hbWVcIjogXCJzaXAuanNcIixcblx0XCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJwcm9taXNjdW91c1wiOiBcIl4wLjYuMFwiXG5cdH0sXG5cdFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuXHRcInJlcG9zaXRvcnlcIjoge1xuXHRcdFwidHlwZVwiOiBcImdpdFwiLFxuXHRcdFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9vbnNpcC9TSVAuanMuZ2l0XCJcblx0fSxcblx0XCJzY3JpcHRzXCI6IHtcblx0XHRcImJ1aWxkXCI6IFwiZ3J1bnQgYnVpbGRcIixcblx0XHRcInByZXB1Ymxpc2hcIjogXCJjZCBzcmMvR3JhbW1hciAmJiBta2RpciAtcCBkaXN0ICYmIHBlZ2pzIC0tZXh0cmEtb3B0aW9ucy1maWxlIHBlZy5qc29uIHNyYy9HcmFtbWFyLnBlZ2pzIGRpc3QvR3JhbW1hci5qc1wiLFxuXHRcdFwicmVwbFwiOiBcImJlZWZ5IHRlc3QvcmVwbC5qcyAtLW9wZW5cIixcblx0XHRcInRlc3RcIjogXCJncnVudCB0cmF2aXMgLS12ZXJib3NlXCJcblx0fSxcblx0XCJ0aXRsZVwiOiBcIlNJUC5qc1wiLFxuXHRcInZlcnNpb25cIjogXCIwLjcuNVwiXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9wYWNrYWdlLmpzb25cbiAqKiBtb2R1bGUgaWQgPSAyMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQLCBlbnZpcm9ubWVudCkge1xudmFyIFV0aWxzO1xuXG5VdGlscz0ge1xuXG4gIFByb21pc2U6IGVudmlyb25tZW50LlByb21pc2UsXG5cbiAgZGVmZXI6IGZ1bmN0aW9uIGRlZmVyICgpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSB7fTtcbiAgICBkZWZlcnJlZC5wcm9taXNlID0gbmV3IFV0aWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9LFxuXG4gIHByb21pc2lmeTogZnVuY3Rpb24gcHJvbWlzaWZ5IChvYmplY3QsIG1ldGhvZE5hbWUsIGNhbGxiYWNrc0ZpcnN0KSB7XG4gICAgdmFyIG9sZE1ldGhvZCA9IG9iamVjdFttZXRob2ROYW1lXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcHJvbWlzaWZpZWRNZXRob2QgKGFyZywgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgICAgIHJldHVybiBuZXcgVXRpbHMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBvbGRBcmdzID0gW2FyZywgcmVzb2x2ZSwgcmVqZWN0XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrc0ZpcnN0KSB7XG4gICAgICAgICAgb2xkQXJncyA9IFtyZXNvbHZlLCByZWplY3QsIGFyZ107XG4gICAgICAgIH1cbiAgICAgICAgb2xkTWV0aG9kLmFwcGx5KG9iamVjdCwgb2xkQXJncyk7XG4gICAgICB9KS50aGVuKG9uU3VjY2Vzcywgb25GYWlsdXJlKTtcbiAgICB9O1xuICB9LFxuXG4gIGF1Z21lbnQ6IGZ1bmN0aW9uIChvYmplY3QsIGNvbnN0cnVjdG9yLCBhcmdzLCBvdmVycmlkZSkge1xuICAgIHZhciBpZHgsIHByb3RvO1xuXG4gICAgLy8gQWRkIHB1YmxpYyBwcm9wZXJ0aWVzIGZyb20gY29uc3RydWN0b3IncyBwcm90b3R5cGUgb250byBvYmplY3RcbiAgICBwcm90byA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICBmb3IgKGlkeCBpbiBwcm90bykge1xuICAgICAgaWYgKG92ZXJyaWRlIHx8IG9iamVjdFtpZHhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2JqZWN0W2lkeF0gPSBwcm90b1tpZHhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCB0aGUgb2JqZWN0IGFzIHRob3VnaCBpdCB3ZXJlIGp1c3QgY3JlYXRlZCBieSBjb25zdHJ1Y3RvclxuICAgIGNvbnN0cnVjdG9yLmFwcGx5KG9iamVjdCwgYXJncyk7XG4gIH0sXG5cbiAgb3B0aW9uc092ZXJyaWRlOiBmdW5jdGlvbiAob3B0aW9ucywgd2lubmVyLCBsb3NlciwgaXNEZXByZWNhdGVkLCBsb2dnZXIsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChpc0RlcHJlY2F0ZWQgJiYgb3B0aW9uc1tsb3Nlcl0pIHtcbiAgICAgIGxvZ2dlci53YXJuKGxvc2VyICsgJyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlICcgKyB3aW5uZXIgKyAnIGluc3RlYWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc1t3aW5uZXJdICYmIG9wdGlvbnNbbG9zZXJdKSB7XG4gICAgICBsb2dnZXIud2Fybih3aW5uZXIgKyAnIG92ZXJyaWRpbmcgJyArIGxvc2VyKTtcbiAgICB9XG5cbiAgICBvcHRpb25zW3dpbm5lcl0gPSBvcHRpb25zW3dpbm5lcl0gfHwgb3B0aW9uc1tsb3Nlcl0gfHwgZGVmYXVsdFZhbHVlO1xuICB9LFxuXG4gIHN0cl91dGY4X2xlbmd0aDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpLnJlcGxhY2UoLyVbQS1GXFxkXXsyfS9nLCAnVScpLmxlbmd0aDtcbiAgfSxcblxuICBnZW5lcmF0ZUZha2VTRFA6IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBib2R5LmluZGV4T2YoJ289Jyk7XG4gICAgdmFyIGVuZCA9IGJvZHkuaW5kZXhPZignXFxyXFxuJywgc3RhcnQpO1xuXG4gICAgcmV0dXJuICd2PTBcXHJcXG4nICsgYm9keS5zbGljZShzdGFydCwgZW5kKSArICdcXHJcXG5zPS1cXHJcXG50PTAgMFxcclxcbmM9SU4gSVA0IDAuMC4wLjAnO1xuICB9LFxuXG4gIGlzRnVuY3Rpb246IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKGZuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIGlzRGVjaW1hbDogZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiAhaXNOYU4obnVtKSAmJiAocGFyc2VGbG9hdChudW0pID09PSBwYXJzZUludChudW0sMTApKTtcbiAgfSxcblxuICBjcmVhdGVSYW5kb21Ub2tlbjogZnVuY3Rpb24oc2l6ZSwgYmFzZSkge1xuICAgIHZhciBpLCByLFxuICAgICAgdG9rZW4gPSAnJztcblxuICAgIGJhc2UgPSBiYXNlIHx8IDMyO1xuXG4gICAgZm9yKCBpPTA7IGkgPCBzaXplOyBpKysgKSB7XG4gICAgICByID0gTWF0aC5yYW5kb20oKSAqIGJhc2V8MDtcbiAgICAgIHRva2VuICs9IHIudG9TdHJpbmcoYmFzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VuO1xuICB9LFxuXG4gIG5ld1RhZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFNJUC5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbihTSVAuVUEuQy5UQUdfTEVOR1RIKTtcbiAgfSxcblxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vdXNlcnMvMTA5NTM4L2Jyb29mYVxuICBuZXdVVUlEOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgVVVJRCA9ICAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSoxNnwwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyJjB4M3wweDgpO1xuICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFVVSUQ7XG4gIH0sXG5cbiAgaG9zdFR5cGU6IGZ1bmN0aW9uKGhvc3QpIHtcbiAgICBpZiAoIWhvc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9zdCA9IFNJUC5HcmFtbWFyLnBhcnNlKGhvc3QsJ2hvc3QnKTtcbiAgICAgIGlmIChob3N0ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gaG9zdC5ob3N0X3R5cGU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIE5vcm1hbGl6ZSBTSVAgVVJJLlxuICAqIE5PVEU6IEl0IGRvZXMgbm90IGFsbG93IGEgU0lQIFVSSSB3aXRob3V0IHVzZXJuYW1lLlxuICAqIEFjY2VwdHMgJ3NpcCcsICdzaXBzJyBhbmQgJ3RlbCcgVVJJcyBhbmQgY29udmVydCB0aGVtIGludG8gJ3NpcCcuXG4gICogRGV0ZWN0cyB0aGUgZG9tYWluIHBhcnQgKGlmIGdpdmVuKSBhbmQgcHJvcGVybHkgaGV4LWVzY2FwZXMgdGhlIHVzZXIgcG9ydGlvbi5cbiAgKiBJZiB0aGUgdXNlciBwb3J0aW9uIGhhcyBvbmx5ICd0ZWwnIG51bWJlciBzeW1ib2xzIHRoZSB1c2VyIHBvcnRpb24gaXMgY2xlYW4gb2YgJ3RlbCcgdmlzdWFsIHNlcGFyYXRvcnMuXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0XG4gICogQHBhcmFtIHtTdHJpbmd9IFtkb21haW5dXG4gICovXG4gIG5vcm1hbGl6ZVRhcmdldDogZnVuY3Rpb24odGFyZ2V0LCBkb21haW4pIHtcbiAgICB2YXIgdXJpLCB0YXJnZXRfYXJyYXksIHRhcmdldF91c2VyLCB0YXJnZXRfZG9tYWluO1xuXG4gICAgLy8gSWYgbm8gdGFyZ2V0IGlzIGdpdmVuIHRoZW4gcmFpc2UgYW4gZXJyb3IuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICAvLyBJZiBhIFNJUC5VUkkgaW5zdGFuY2UgaXMgZ2l2ZW4gdGhlbiByZXR1cm4gaXQuXG4gICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTSVAuVVJJKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuXG4gICAgLy8gSWYgYSBzdHJpbmcgaXMgZ2l2ZW4gc3BsaXQgaXQgYnkgJ0AnOlxuICAgIC8vIC0gTGFzdCBmcmFnbWVudCBpcyB0aGUgZGVzaXJlZCBkb21haW4uXG4gICAgLy8gLSBPdGhlcndpc2UgYXBwZW5kIHRoZSBnaXZlbiBkb21haW4gYXJndW1lbnQuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGFyZ2V0X2FycmF5ID0gdGFyZ2V0LnNwbGl0KCdAJyk7XG5cbiAgICAgIHN3aXRjaCh0YXJnZXRfYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRfdXNlciA9IHRhcmdldDtcbiAgICAgICAgICB0YXJnZXRfZG9tYWluID0gZG9tYWluO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGFyZ2V0X3VzZXIgPSB0YXJnZXRfYXJyYXlbMF07XG4gICAgICAgICAgdGFyZ2V0X2RvbWFpbiA9IHRhcmdldF9hcnJheVsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0YXJnZXRfdXNlciA9IHRhcmdldF9hcnJheS5zbGljZSgwLCB0YXJnZXRfYXJyYXkubGVuZ3RoLTEpLmpvaW4oJ0AnKTtcbiAgICAgICAgICB0YXJnZXRfZG9tYWluID0gdGFyZ2V0X2FycmF5W3RhcmdldF9hcnJheS5sZW5ndGgtMV07XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgVVJJIHNjaGVtZSAoaWYgcHJlc2VudCkuXG4gICAgICB0YXJnZXRfdXNlciA9IHRhcmdldF91c2VyLnJlcGxhY2UoL14oc2lwcz98dGVsKTovaSwgJycpO1xuXG4gICAgICAvLyBSZW1vdmUgJ3RlbCcgdmlzdWFsIHNlcGFyYXRvcnMgaWYgdGhlIHVzZXIgcG9ydGlvbiBqdXN0IGNvbnRhaW5zICd0ZWwnIG51bWJlciBzeW1ib2xzLlxuICAgICAgaWYgKC9eW1xcLVxcLlxcKFxcKV0qXFwrP1swLTlcXC1cXC5cXChcXCldKyQvLnRlc3QodGFyZ2V0X3VzZXIpKSB7XG4gICAgICAgIHRhcmdldF91c2VyID0gdGFyZ2V0X3VzZXIucmVwbGFjZSgvW1xcLVxcLlxcKFxcKV0vZywgJycpO1xuICAgICAgfVxuXG4gICAgICAvLyBCdWlsZCB0aGUgY29tcGxldGUgU0lQIFVSSS5cbiAgICAgIHRhcmdldCA9IFNJUC5DLlNJUCArICc6JyArIFNJUC5VdGlscy5lc2NhcGVVc2VyKHRhcmdldF91c2VyKSArICdAJyArIHRhcmdldF9kb21haW47XG5cbiAgICAgIC8vIEZpbmFsbHkgcGFyc2UgdGhlIHJlc3VsdGluZyBVUkkuXG4gICAgICBpZiAodXJpID0gU0lQLlVSSS5wYXJzZSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogSGV4LWVzY2FwZSBhIFNJUCBVUkkgdXNlci5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gICovXG4gIGVzY2FwZVVzZXI6IGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAvLyBEb24ndCBoZXgtZXNjYXBlICc6JyAoJTNBKSwgJysnICglMkIpLCAnPycgKCUzRlwiKSwgJy8nICglMkYpLlxuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVzZXIpKS5yZXBsYWNlKC8lM0EvaWcsICc6JykucmVwbGFjZSgvJTJCL2lnLCAnKycpLnJlcGxhY2UoLyUzRi9pZywgJz8nKS5yZXBsYWNlKC8lMkYvaWcsICcvJyk7XG4gIH0sXG5cbiAgaGVhZGVyaXplOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZXhjZXB0aW9ucyA9IHtcbiAgICAgICdDYWxsLUlkJzogJ0NhbGwtSUQnLFxuICAgICAgJ0NzZXEnOiAnQ1NlcScsXG4gICAgICAnTWluLVNlJzogJ01pbi1TRScsXG4gICAgICAnUmFjayc6ICdSQWNrJyxcbiAgICAgICdSc2VxJzogJ1JTZXEnLFxuICAgICAgJ1d3dy1BdXRoZW50aWNhdGUnOiAnV1dXLUF1dGhlbnRpY2F0ZSdcbiAgICAgIH0sXG4gICAgICBuYW1lID0gc3RyaW5nLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXy9nLCctJykuc3BsaXQoJy0nKSxcbiAgICAgIGhuYW1lID0gJycsXG4gICAgICBwYXJ0cyA9IG5hbWUubGVuZ3RoLCBwYXJ0O1xuXG4gICAgZm9yIChwYXJ0ID0gMDsgcGFydCA8IHBhcnRzOyBwYXJ0KyspIHtcbiAgICAgIGlmIChwYXJ0ICE9PSAwKSB7XG4gICAgICAgIGhuYW1lICs9Jy0nO1xuICAgICAgfVxuICAgICAgaG5hbWUgKz0gbmFtZVtwYXJ0XS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuYW1lW3BhcnRdLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKGV4Y2VwdGlvbnNbaG5hbWVdKSB7XG4gICAgICBobmFtZSA9IGV4Y2VwdGlvbnNbaG5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gaG5hbWU7XG4gIH0sXG5cbiAgc2lwRXJyb3JDYXVzZTogZnVuY3Rpb24oc3RhdHVzX2NvZGUpIHtcbiAgICB2YXIgY2F1c2U7XG5cbiAgICBmb3IgKGNhdXNlIGluIFNJUC5DLlNJUF9FUlJPUl9DQVVTRVMpIHtcbiAgICAgIGlmIChTSVAuQy5TSVBfRVJST1JfQ0FVU0VTW2NhdXNlXS5pbmRleE9mKHN0YXR1c19jb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLmNhdXNlc1tjYXVzZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFNJUC5DLmNhdXNlcy5TSVBfRkFJTFVSRV9DT0RFO1xuICB9LFxuXG4gIGdldFJlYXNvblBocmFzZTogZnVuY3Rpb24gZ2V0UmVhc29uUGhyYXNlIChjb2RlLCBzcGVjaWZpYykge1xuICAgIHJldHVybiBzcGVjaWZpYyB8fCBTSVAuQy5SRUFTT05fUEhSQVNFW2NvZGVdIHx8ICcnO1xuICB9LFxuXG4gIGdldFJlYXNvbkhlYWRlclZhbHVlOiBmdW5jdGlvbiBnZXRSZWFzb25IZWFkZXJWYWx1ZSAoY29kZSwgcmVhc29uKSB7XG4gICAgcmVhc29uID0gU0lQLlV0aWxzLmdldFJlYXNvblBocmFzZShjb2RlLCByZWFzb24pO1xuICAgIHJldHVybiAnU0lQIDtjYXVzZT0nICsgY29kZSArICcgO3RleHQ9XCInICsgcmVhc29uICsgJ1wiJztcbiAgfSxcblxuICBnZXRDYW5jZWxSZWFzb246IGZ1bmN0aW9uIGdldENhbmNlbFJlYXNvbiAoY29kZSwgcmVhc29uKSB7XG4gICAgaWYgKGNvZGUgJiYgY29kZSA8IDIwMCB8fCBjb2RlID4gNjk5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0YXR1c19jb2RlOiAnICsgY29kZSk7XG4gICAgfSBlbHNlIGlmIChjb2RlKSB7XG4gICAgICByZXR1cm4gU0lQLlV0aWxzLmdldFJlYXNvbkhlYWRlclZhbHVlKGNvZGUsIHJlYXNvbik7XG4gICAgfVxuICB9LFxuXG4gIGJ1aWxkU3RhdHVzTGluZTogZnVuY3Rpb24gYnVpbGRTdGF0dXNMaW5lIChjb2RlLCByZWFzb24pIHtcbiAgICBjb2RlID0gY29kZSB8fCBudWxsO1xuICAgIHJlYXNvbiA9IHJlYXNvbiB8fCBudWxsO1xuXG4gICAgLy8gVmFsaWRhdGUgY29kZSBhbmQgcmVhc29uIHZhbHVlc1xuICAgIGlmICghY29kZSB8fCAoY29kZSA8IDEwMCB8fCBjb2RlID4gNjk5KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNfY29kZTogJysgY29kZSk7XG4gICAgfSBlbHNlIGlmIChyZWFzb24gJiYgdHlwZW9mIHJlYXNvbiAhPT0gJ3N0cmluZycgJiYgIShyZWFzb24gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHJlYXNvbl9waHJhc2U6ICcrIHJlYXNvbik7XG4gICAgfVxuXG4gICAgcmVhc29uID0gVXRpbHMuZ2V0UmVhc29uUGhyYXNlKGNvZGUsIHJlYXNvbik7XG5cbiAgICByZXR1cm4gJ1NJUC8yLjAgJyArIGNvZGUgKyAnICcgKyByZWFzb24gKyAnXFxyXFxuJztcbiAgfSxcblxuICAvKipcbiAgKiBHZW5lcmF0ZSBhIHJhbmRvbSBUZXN0LU5ldCBJUCAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTczNSlcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBnZXRSYW5kb21UZXN0TmV0SVA6IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGdldE9jdGV0KGZyb20sdG8pIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKHRvLWZyb20rMSkrZnJvbSk7XG4gICAgfVxuICAgIHJldHVybiAnMTkyLjAuMi4nICsgZ2V0T2N0ZXQoMSwgMjU0KTtcbiAgfSxcblxuICAvLyBNRDUgKE1lc3NhZ2UtRGlnZXN0IEFsZ29yaXRobSkgaHR0cDovL3d3dy53ZWJ0b29sa2l0LmluZm9cbiAgY2FsY3VsYXRlTUQ1OiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBmdW5jdGlvbiBSb3RhdGVMZWZ0KGxWYWx1ZSwgaVNoaWZ0Qml0cykge1xuICAgICAgcmV0dXJuIChsVmFsdWU8PGlTaGlmdEJpdHMpIHwgKGxWYWx1ZT4+PigzMi1pU2hpZnRCaXRzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQWRkVW5zaWduZWQobFgsbFkpIHtcbiAgICAgIHZhciBsWDQsbFk0LGxYOCxsWTgsbFJlc3VsdDtcbiAgICAgIGxYOCA9IChsWCAmIDB4ODAwMDAwMDApO1xuICAgICAgbFk4ID0gKGxZICYgMHg4MDAwMDAwMCk7XG4gICAgICBsWDQgPSAobFggJiAweDQwMDAwMDAwKTtcbiAgICAgIGxZNCA9IChsWSAmIDB4NDAwMDAwMDApO1xuICAgICAgbFJlc3VsdCA9IChsWCAmIDB4M0ZGRkZGRkYpKyhsWSAmIDB4M0ZGRkZGRkYpO1xuICAgICAgaWYgKGxYNCAmIGxZNCkge1xuICAgICAgICByZXR1cm4gKGxSZXN1bHQgXiAweDgwMDAwMDAwIF4gbFg4IF4gbFk4KTtcbiAgICAgIH1cbiAgICAgIGlmIChsWDQgfCBsWTQpIHtcbiAgICAgICAgaWYgKGxSZXN1bHQgJiAweDQwMDAwMDAwKSB7XG4gICAgICAgICAgcmV0dXJuIChsUmVzdWx0IF4gMHhDMDAwMDAwMCBeIGxYOCBeIGxZOCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChsUmVzdWx0IF4gMHg0MDAwMDAwMCBeIGxYOCBeIGxZOCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAobFJlc3VsdCBeIGxYOCBeIGxZOCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRih4LHkseikge1xuICAgICAgcmV0dXJuICh4ICYgeSkgfCAoKH54KSAmIHopO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEcoeCx5LHopIHtcbiAgICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiAofnopKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBIKHgseSx6KSB7XG4gICAgICByZXR1cm4gKHggXiB5IF4geik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSSh4LHkseikge1xuICAgICAgcmV0dXJuICh5IF4gKHggfCAofnopKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRkYoYSxiLGMsZCx4LHMsYWMpIHtcbiAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChGKGIsIGMsIGQpLCB4KSwgYWMpKTtcbiAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHRyhhLGIsYyxkLHgscyxhYykge1xuICAgICAgYSA9IEFkZFVuc2lnbmVkKGEsIEFkZFVuc2lnbmVkKEFkZFVuc2lnbmVkKEcoYiwgYywgZCksIHgpLCBhYykpO1xuICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEhIKGEsYixjLGQseCxzLGFjKSB7XG4gICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoSChiLCBjLCBkKSwgeCksIGFjKSk7XG4gICAgICByZXR1cm4gQWRkVW5zaWduZWQoUm90YXRlTGVmdChhLCBzKSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSUkoYSxiLGMsZCx4LHMsYWMpIHtcbiAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChJKGIsIGMsIGQpLCB4KSwgYWMpKTtcbiAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb252ZXJ0VG9Xb3JkQXJyYXkoc3RyaW5nKSB7XG4gICAgICB2YXIgbFdvcmRDb3VudDtcbiAgICAgIHZhciBsTWVzc2FnZUxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICB2YXIgbE51bWJlck9mV29yZHNfdGVtcDE9bE1lc3NhZ2VMZW5ndGggKyA4O1xuICAgICAgdmFyIGxOdW1iZXJPZldvcmRzX3RlbXAyPShsTnVtYmVyT2ZXb3Jkc190ZW1wMS0obE51bWJlck9mV29yZHNfdGVtcDEgJSA2NCkpLzY0O1xuICAgICAgdmFyIGxOdW1iZXJPZldvcmRzID0gKGxOdW1iZXJPZldvcmRzX3RlbXAyKzEpKjE2O1xuICAgICAgdmFyIGxXb3JkQXJyYXk9QXJyYXkobE51bWJlck9mV29yZHMtMSk7XG4gICAgICB2YXIgbEJ5dGVQb3NpdGlvbiA9IDA7XG4gICAgICB2YXIgbEJ5dGVDb3VudCA9IDA7XG4gICAgICB3aGlsZSAoIGxCeXRlQ291bnQgPCBsTWVzc2FnZUxlbmd0aCApIHtcbiAgICAgICAgbFdvcmRDb3VudCA9IChsQnl0ZUNvdW50LShsQnl0ZUNvdW50ICUgNCkpLzQ7XG4gICAgICAgIGxCeXRlUG9zaXRpb24gPSAobEJ5dGVDb3VudCAlIDQpKjg7XG4gICAgICAgIGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gPSAobFdvcmRBcnJheVtsV29yZENvdW50XSB8IChzdHJpbmcuY2hhckNvZGVBdChsQnl0ZUNvdW50KTw8bEJ5dGVQb3NpdGlvbikpO1xuICAgICAgICBsQnl0ZUNvdW50Kys7XG4gICAgICB9XG4gICAgICBsV29yZENvdW50ID0gKGxCeXRlQ291bnQtKGxCeXRlQ291bnQgJSA0KSkvNDtcbiAgICAgIGxCeXRlUG9zaXRpb24gPSAobEJ5dGVDb3VudCAlIDQpKjg7XG4gICAgICBsV29yZEFycmF5W2xXb3JkQ291bnRdID0gbFdvcmRBcnJheVtsV29yZENvdW50XSB8ICgweDgwPDxsQnl0ZVBvc2l0aW9uKTtcbiAgICAgIGxXb3JkQXJyYXlbbE51bWJlck9mV29yZHMtMl0gPSBsTWVzc2FnZUxlbmd0aDw8MztcbiAgICAgIGxXb3JkQXJyYXlbbE51bWJlck9mV29yZHMtMV0gPSBsTWVzc2FnZUxlbmd0aD4+PjI5O1xuICAgICAgcmV0dXJuIGxXb3JkQXJyYXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV29yZFRvSGV4KGxWYWx1ZSkge1xuICAgICAgdmFyIFdvcmRUb0hleFZhbHVlPVwiXCIsV29yZFRvSGV4VmFsdWVfdGVtcD1cIlwiLGxCeXRlLGxDb3VudDtcbiAgICAgIGZvciAobENvdW50ID0gMDtsQ291bnQ8PTM7bENvdW50KyspIHtcbiAgICAgICAgbEJ5dGUgPSAobFZhbHVlPj4+KGxDb3VudCo4KSkgJiAyNTU7XG4gICAgICAgIFdvcmRUb0hleFZhbHVlX3RlbXAgPSBcIjBcIiArIGxCeXRlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgV29yZFRvSGV4VmFsdWUgPSBXb3JkVG9IZXhWYWx1ZSArIFdvcmRUb0hleFZhbHVlX3RlbXAuc3Vic3RyKFdvcmRUb0hleFZhbHVlX3RlbXAubGVuZ3RoLTIsMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gV29yZFRvSGV4VmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVXRmOEVuY29kZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXHJcXG4vZyxcIlxcblwiKTtcbiAgICAgIHZhciB1dGZ0ZXh0ID0gXCJcIjtcblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBzdHJpbmcubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChuKTtcblxuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKChjID4gMTI3KSAmJiAoYyA8IDIwNDgpKSB7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjID4+IDYpIHwgMTkyKTtcbiAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiA2MykgfCAxMjgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyA+PiAxMikgfCAyMjQpO1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgPj4gNikgJiA2MykgfCAxMjgpO1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDYzKSB8IDEyOCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1dGZ0ZXh0O1xuICAgIH1cblxuICAgIHZhciB4PVtdO1xuICAgIHZhciBrLEFBLEJCLENDLERELGEsYixjLGQ7XG4gICAgdmFyIFMxMT03LCBTMTI9MTIsIFMxMz0xNywgUzE0PTIyO1xuICAgIHZhciBTMjE9NSwgUzIyPTkgLCBTMjM9MTQsIFMyND0yMDtcbiAgICB2YXIgUzMxPTQsIFMzMj0xMSwgUzMzPTE2LCBTMzQ9MjM7XG4gICAgdmFyIFM0MT02LCBTNDI9MTAsIFM0Mz0xNSwgUzQ0PTIxO1xuXG4gICAgc3RyaW5nID0gVXRmOEVuY29kZShzdHJpbmcpO1xuXG4gICAgeCA9IENvbnZlcnRUb1dvcmRBcnJheShzdHJpbmcpO1xuXG4gICAgYSA9IDB4Njc0NTIzMDE7IGIgPSAweEVGQ0RBQjg5OyBjID0gMHg5OEJBRENGRTsgZCA9IDB4MTAzMjU0NzY7XG5cbiAgICBmb3IgKGs9MDtrPHgubGVuZ3RoO2srPTE2KSB7XG4gICAgICBBQT1hOyBCQj1iOyBDQz1jOyBERD1kO1xuICAgICAgYT1GRihhLGIsYyxkLHhbayswXSwgUzExLDB4RDc2QUE0NzgpO1xuICAgICAgZD1GRihkLGEsYixjLHhbaysxXSwgUzEyLDB4RThDN0I3NTYpO1xuICAgICAgYz1GRihjLGQsYSxiLHhbaysyXSwgUzEzLDB4MjQyMDcwREIpO1xuICAgICAgYj1GRihiLGMsZCxhLHhbayszXSwgUzE0LDB4QzFCRENFRUUpO1xuICAgICAgYT1GRihhLGIsYyxkLHhbays0XSwgUzExLDB4RjU3QzBGQUYpO1xuICAgICAgZD1GRihkLGEsYixjLHhbays1XSwgUzEyLDB4NDc4N0M2MkEpO1xuICAgICAgYz1GRihjLGQsYSxiLHhbays2XSwgUzEzLDB4QTgzMDQ2MTMpO1xuICAgICAgYj1GRihiLGMsZCxhLHhbays3XSwgUzE0LDB4RkQ0Njk1MDEpO1xuICAgICAgYT1GRihhLGIsYyxkLHhbays4XSwgUzExLDB4Njk4MDk4RDgpO1xuICAgICAgZD1GRihkLGEsYixjLHhbays5XSwgUzEyLDB4OEI0NEY3QUYpO1xuICAgICAgYz1GRihjLGQsYSxiLHhbaysxMF0sUzEzLDB4RkZGRjVCQjEpO1xuICAgICAgYj1GRihiLGMsZCxhLHhbaysxMV0sUzE0LDB4ODk1Q0Q3QkUpO1xuICAgICAgYT1GRihhLGIsYyxkLHhbaysxMl0sUzExLDB4NkI5MDExMjIpO1xuICAgICAgZD1GRihkLGEsYixjLHhbaysxM10sUzEyLDB4RkQ5ODcxOTMpO1xuICAgICAgYz1GRihjLGQsYSxiLHhbaysxNF0sUzEzLDB4QTY3OTQzOEUpO1xuICAgICAgYj1GRihiLGMsZCxhLHhbaysxNV0sUzE0LDB4NDlCNDA4MjEpO1xuICAgICAgYT1HRyhhLGIsYyxkLHhbaysxXSwgUzIxLDB4RjYxRTI1NjIpO1xuICAgICAgZD1HRyhkLGEsYixjLHhbays2XSwgUzIyLDB4QzA0MEIzNDApO1xuICAgICAgYz1HRyhjLGQsYSxiLHhbaysxMV0sUzIzLDB4MjY1RTVBNTEpO1xuICAgICAgYj1HRyhiLGMsZCxhLHhbayswXSwgUzI0LDB4RTlCNkM3QUEpO1xuICAgICAgYT1HRyhhLGIsYyxkLHhbays1XSwgUzIxLDB4RDYyRjEwNUQpO1xuICAgICAgZD1HRyhkLGEsYixjLHhbaysxMF0sUzIyLDB4MjQ0MTQ1Myk7XG4gICAgICBjPUdHKGMsZCxhLGIseFtrKzE1XSxTMjMsMHhEOEExRTY4MSk7XG4gICAgICBiPUdHKGIsYyxkLGEseFtrKzRdLCBTMjQsMHhFN0QzRkJDOCk7XG4gICAgICBhPUdHKGEsYixjLGQseFtrKzldLCBTMjEsMHgyMUUxQ0RFNik7XG4gICAgICBkPUdHKGQsYSxiLGMseFtrKzE0XSxTMjIsMHhDMzM3MDdENik7XG4gICAgICBjPUdHKGMsZCxhLGIseFtrKzNdLCBTMjMsMHhGNEQ1MEQ4Nyk7XG4gICAgICBiPUdHKGIsYyxkLGEseFtrKzhdLCBTMjQsMHg0NTVBMTRFRCk7XG4gICAgICBhPUdHKGEsYixjLGQseFtrKzEzXSxTMjEsMHhBOUUzRTkwNSk7XG4gICAgICBkPUdHKGQsYSxiLGMseFtrKzJdLCBTMjIsMHhGQ0VGQTNGOCk7XG4gICAgICBjPUdHKGMsZCxhLGIseFtrKzddLCBTMjMsMHg2NzZGMDJEOSk7XG4gICAgICBiPUdHKGIsYyxkLGEseFtrKzEyXSxTMjQsMHg4RDJBNEM4QSk7XG4gICAgICBhPUhIKGEsYixjLGQseFtrKzVdLCBTMzEsMHhGRkZBMzk0Mik7XG4gICAgICBkPUhIKGQsYSxiLGMseFtrKzhdLCBTMzIsMHg4NzcxRjY4MSk7XG4gICAgICBjPUhIKGMsZCxhLGIseFtrKzExXSxTMzMsMHg2RDlENjEyMik7XG4gICAgICBiPUhIKGIsYyxkLGEseFtrKzE0XSxTMzQsMHhGREU1MzgwQyk7XG4gICAgICBhPUhIKGEsYixjLGQseFtrKzFdLCBTMzEsMHhBNEJFRUE0NCk7XG4gICAgICBkPUhIKGQsYSxiLGMseFtrKzRdLCBTMzIsMHg0QkRFQ0ZBOSk7XG4gICAgICBjPUhIKGMsZCxhLGIseFtrKzddLCBTMzMsMHhGNkJCNEI2MCk7XG4gICAgICBiPUhIKGIsYyxkLGEseFtrKzEwXSxTMzQsMHhCRUJGQkM3MCk7XG4gICAgICBhPUhIKGEsYixjLGQseFtrKzEzXSxTMzEsMHgyODlCN0VDNik7XG4gICAgICBkPUhIKGQsYSxiLGMseFtrKzBdLCBTMzIsMHhFQUExMjdGQSk7XG4gICAgICBjPUhIKGMsZCxhLGIseFtrKzNdLCBTMzMsMHhENEVGMzA4NSk7XG4gICAgICBiPUhIKGIsYyxkLGEseFtrKzZdLCBTMzQsMHg0ODgxRDA1KTtcbiAgICAgIGE9SEgoYSxiLGMsZCx4W2srOV0sIFMzMSwweEQ5RDREMDM5KTtcbiAgICAgIGQ9SEgoZCxhLGIsYyx4W2srMTJdLFMzMiwweEU2REI5OUU1KTtcbiAgICAgIGM9SEgoYyxkLGEsYix4W2srMTVdLFMzMywweDFGQTI3Q0Y4KTtcbiAgICAgIGI9SEgoYixjLGQsYSx4W2srMl0sIFMzNCwweEM0QUM1NjY1KTtcbiAgICAgIGE9SUkoYSxiLGMsZCx4W2srMF0sIFM0MSwweEY0MjkyMjQ0KTtcbiAgICAgIGQ9SUkoZCxhLGIsYyx4W2srN10sIFM0MiwweDQzMkFGRjk3KTtcbiAgICAgIGM9SUkoYyxkLGEsYix4W2srMTRdLFM0MywweEFCOTQyM0E3KTtcbiAgICAgIGI9SUkoYixjLGQsYSx4W2srNV0sIFM0NCwweEZDOTNBMDM5KTtcbiAgICAgIGE9SUkoYSxiLGMsZCx4W2srMTJdLFM0MSwweDY1NUI1OUMzKTtcbiAgICAgIGQ9SUkoZCxhLGIsYyx4W2srM10sIFM0MiwweDhGMENDQzkyKTtcbiAgICAgIGM9SUkoYyxkLGEsYix4W2srMTBdLFM0MywweEZGRUZGNDdEKTtcbiAgICAgIGI9SUkoYixjLGQsYSx4W2srMV0sIFM0NCwweDg1ODQ1REQxKTtcbiAgICAgIGE9SUkoYSxiLGMsZCx4W2srOF0sIFM0MSwweDZGQTg3RTRGKTtcbiAgICAgIGQ9SUkoZCxhLGIsYyx4W2srMTVdLFM0MiwweEZFMkNFNkUwKTtcbiAgICAgIGM9SUkoYyxkLGEsYix4W2srNl0sIFM0MywweEEzMDE0MzE0KTtcbiAgICAgIGI9SUkoYixjLGQsYSx4W2srMTNdLFM0NCwweDRFMDgxMUExKTtcbiAgICAgIGE9SUkoYSxiLGMsZCx4W2srNF0sIFM0MSwweEY3NTM3RTgyKTtcbiAgICAgIGQ9SUkoZCxhLGIsYyx4W2srMTFdLFM0MiwweEJEM0FGMjM1KTtcbiAgICAgIGM9SUkoYyxkLGEsYix4W2srMl0sIFM0MywweDJBRDdEMkJCKTtcbiAgICAgIGI9SUkoYixjLGQsYSx4W2srOV0sIFM0NCwweEVCODZEMzkxKTtcbiAgICAgIGE9QWRkVW5zaWduZWQoYSxBQSk7XG4gICAgICBiPUFkZFVuc2lnbmVkKGIsQkIpO1xuICAgICAgYz1BZGRVbnNpZ25lZChjLENDKTtcbiAgICAgIGQ9QWRkVW5zaWduZWQoZCxERCk7XG4gICAgfVxuXG4gICAgdmFyIHRlbXAgPSBXb3JkVG9IZXgoYSkrV29yZFRvSGV4KGIpK1dvcmRUb0hleChjKStXb3JkVG9IZXgoZCk7XG5cbiAgICByZXR1cm4gdGVtcC50b0xvd2VyQ2FzZSgpO1xuICB9XG59O1xuXG5TSVAuVXRpbHMgPSBVdGlscztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMjE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsZXZlbHMgPSB7XG4gICdlcnJvcic6IDAsXG4gICd3YXJuJzogMSxcbiAgJ2xvZyc6IDIsXG4gICdkZWJ1Zyc6IDNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnNvbGUpIHtcblxudmFyIExvZ2dlckZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb2dnZXIsXG4gICAgbGV2ZWwgPSAyLFxuICAgIGJ1aWx0aW5FbmFibGVkID0gdHJ1ZSxcbiAgICBjb25uZWN0b3IgPSBudWxsO1xuXG4gICAgdGhpcy5sb2dnZXJzID0ge307XG5cbiAgICBsb2dnZXIgPSB0aGlzLmdldExvZ2dlcignc2lwLmxvZ2dlcmZhY3RvcnknKTtcblxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBidWlsdGluRW5hYmxlZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gYnVpbHRpbkVuYWJsZWQ7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgYnVpbHRpbkVuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ2ludmFsaWQgXCJidWlsdGluRW5hYmxlZFwiIHBhcmFtZXRlciB2YWx1ZTogJysgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBsZXZlbDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtyZXR1cm4gbGV2ZWw7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDw9Mykge1xuICAgICAgICAgIGxldmVsID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiAzKSB7XG4gICAgICAgICAgbGV2ZWwgPSAzO1xuICAgICAgICB9IGVsc2UgaWYgKGxldmVscy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgICAgICBsZXZlbCA9IGxldmVsc1t2YWx1ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdpbnZhbGlkIFwibGV2ZWxcIiBwYXJhbWV0ZXIgdmFsdWU6ICcrIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29ubmVjdG9yOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge3JldHVybiBjb25uZWN0b3I7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgaWYodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbm5lY3RvciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29ubmVjdG9yID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdpbnZhbGlkIFwiY29ubmVjdG9yXCIgcGFyYW1ldGVyIHZhbHVlOiAnKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkxvZ2dlckZhY3RvcnkucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24odGFyZ2V0LCBjYXRlZ29yeSwgbGFiZWwsIGNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwcmVmaXggPSBbbmV3IERhdGUoKSwgY2F0ZWdvcnldO1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgcHJlZml4LnB1c2gobGFiZWwpO1xuICAgIH1cbiAgICBjb250ZW50ID0gcHJlZml4LmNvbmNhdChjb250ZW50KS5qb2luKCcgfCAnKTtcbiAgfVxuICB0YXJnZXQuY2FsbChjb25zb2xlLCBjb250ZW50KTtcbn07XG5cbmZ1bmN0aW9uIExvZ2dlciAobG9nZ2VyLCBjYXRlZ29yeSwgbGFiZWwpIHtcbiAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIHRoaXMuY2F0ZWdvcnkgPSBjYXRlZ29yeTtcbiAgdGhpcy5sYWJlbCA9IGxhYmVsO1xufVxuXG5PYmplY3Qua2V5cyhsZXZlbHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldE5hbWUpIHtcbiAgTG9nZ2VyLnByb3RvdHlwZVt0YXJnZXROYW1lXSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgdGhpcy5sb2dnZXJbdGFyZ2V0TmFtZV0odGhpcy5jYXRlZ29yeSwgdGhpcy5sYWJlbCwgY29udGVudCk7XG4gIH07XG5cbiAgTG9nZ2VyRmFjdG9yeS5wcm90b3R5cGVbdGFyZ2V0TmFtZV0gPSBmdW5jdGlvbiAoY2F0ZWdvcnksIGxhYmVsLCBjb250ZW50KSB7XG4gICAgaWYgKHRoaXMubGV2ZWwgPj0gbGV2ZWxzW3RhcmdldE5hbWVdKSB7XG4gICAgICBpZiAodGhpcy5idWlsdGluRW5hYmxlZCkge1xuICAgICAgICB0aGlzLnByaW50KGNvbnNvbGVbdGFyZ2V0TmFtZV0sIGNhdGVnb3J5LCBsYWJlbCwgY29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbm5lY3Rvcikge1xuICAgICAgICB0aGlzLmNvbm5lY3Rvcih0YXJnZXROYW1lLCBjYXRlZ29yeSwgbGFiZWwsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pO1xuXG5Mb2dnZXJGYWN0b3J5LnByb3RvdHlwZS5nZXRMb2dnZXIgPSBmdW5jdGlvbihjYXRlZ29yeSwgbGFiZWwpIHtcbiAgdmFyIGxvZ2dlcjtcblxuICBpZiAobGFiZWwgJiYgdGhpcy5sZXZlbCA9PT0gMykge1xuICAgIHJldHVybiBuZXcgTG9nZ2VyKHRoaXMsIGNhdGVnb3J5LCBsYWJlbCk7XG4gIH0gZWxzZSBpZiAodGhpcy5sb2dnZXJzW2NhdGVnb3J5XSkge1xuICAgIHJldHVybiB0aGlzLmxvZ2dlcnNbY2F0ZWdvcnldO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlciA9IG5ldyBMb2dnZXIodGhpcywgY2F0ZWdvcnkpO1xuICAgIHRoaXMubG9nZ2Vyc1tjYXRlZ29yeV0gPSBsb2dnZXI7XG4gICAgcmV0dXJuIGxvZ2dlcjtcbiAgfVxufTtcblxucmV0dXJuIExvZ2dlckZhY3Rvcnk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9Mb2dnZXJGYWN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gMjE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBOb2RlRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25zb2xlKSB7XG5cbi8vIERvbid0IHVzZSBgbmV3IFNJUC5FdmVudEVtaXR0ZXIoKWAgZm9yIGluaGVyaXRpbmcuXG4vLyBVc2UgT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdG95cGUpO1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyICgpIHtcbiAgTm9kZUV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlRXZlbnRFbWl0dGVyLnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Rvcjoge1xuICAgIHZhbHVlOiBFdmVudEVtaXR0ZXIsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgd2FybmluZyA9ICcnO1xuICB3YXJuaW5nICs9ICdTSVAuRXZlbnRFbWl0dGVyI29mZiBpcyBkZXByZWNhdGVkIGFuZCBtYXkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgU0lQLmpzIHZlcnNpb25zLlxcbic7XG4gIHdhcm5pbmcgKz0gJ1BsZWFzZSB1c2UgcmVtb3ZlTGlzdGVuZXIgb3IgcmVtb3ZlQWxsTGlzdGVuZXJzIGluc3RlYWQuXFxuJztcbiAgd2FybmluZyArPSAnU2VlIGhlcmUgZm9yIG1vcmUgZGV0YWlsczpcXG4nO1xuICB3YXJuaW5nICs9ICdodHRwOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2VtaXR0ZXJfcmVtb3ZlbGlzdGVuZXJfZXZlbnRfbGlzdGVuZXInO1xuICBjb25zb2xlLndhcm4od2FybmluZyk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cbn07XG5cbnJldHVybiBFdmVudEVtaXR0ZXI7XG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0V2ZW50RW1pdHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXZlbnRzL2V2ZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIENvbnN0YW50c1xuICovXG5cbi8qKlxuICogU0lQIENvbnN0YW50cy5cbiAqIEBhdWdtZW50cyBTSVBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lLCB2ZXJzaW9uKSB7XG5yZXR1cm4ge1xuICBVU0VSX0FHRU5UOiBuYW1lICsnLycrIHZlcnNpb24sXG5cbiAgLy8gU0lQIHNjaGVtZVxuICBTSVA6ICAnc2lwJyxcbiAgU0lQUzogJ3NpcHMnLFxuXG4gIC8vIEVuZCBhbmQgRmFpbHVyZSBjYXVzZXNcbiAgY2F1c2VzOiB7XG4gICAgLy8gR2VuZXJpYyBlcnJvciBjYXVzZXNcbiAgICBDT05ORUNUSU9OX0VSUk9SOiAgICAgICAgICdDb25uZWN0aW9uIEVycm9yJyxcbiAgICBSRVFVRVNUX1RJTUVPVVQ6ICAgICAgICAgICdSZXF1ZXN0IFRpbWVvdXQnLFxuICAgIFNJUF9GQUlMVVJFX0NPREU6ICAgICAgICAgJ1NJUCBGYWlsdXJlIENvZGUnLFxuICAgIElOVEVSTkFMX0VSUk9SOiAgICAgICAgICAgJ0ludGVybmFsIEVycm9yJyxcblxuICAgIC8vIFNJUCBlcnJvciBjYXVzZXNcbiAgICBCVVNZOiAgICAgICAgICAgICAgICAgICAgICdCdXN5JyxcbiAgICBSRUpFQ1RFRDogICAgICAgICAgICAgICAgICdSZWplY3RlZCcsXG4gICAgUkVESVJFQ1RFRDogICAgICAgICAgICAgICAnUmVkaXJlY3RlZCcsXG4gICAgVU5BVkFJTEFCTEU6ICAgICAgICAgICAgICAnVW5hdmFpbGFibGUnLFxuICAgIE5PVF9GT1VORDogICAgICAgICAgICAgICAgJ05vdCBGb3VuZCcsXG4gICAgQUREUkVTU19JTkNPTVBMRVRFOiAgICAgICAnQWRkcmVzcyBJbmNvbXBsZXRlJyxcbiAgICBJTkNPTVBBVElCTEVfU0RQOiAgICAgICAgICdJbmNvbXBhdGlibGUgU0RQJyxcbiAgICBBVVRIRU5USUNBVElPTl9FUlJPUjogICAgICdBdXRoZW50aWNhdGlvbiBFcnJvcicsXG4gICAgRElBTE9HX0VSUk9SOiAgICAgICAgICAgICAnRGlhbG9nIEVycm9yJyxcblxuICAgIC8vIFNlc3Npb24gZXJyb3IgY2F1c2VzXG4gICAgV0VCUlRDX05PVF9TVVBQT1JURUQ6ICAgICAnV2ViUlRDIE5vdCBTdXBwb3J0ZWQnLFxuICAgIFdFQlJUQ19FUlJPUjogICAgICAgICAgICAgJ1dlYlJUQyBFcnJvcicsXG4gICAgQ0FOQ0VMRUQ6ICAgICAgICAgICAgICAgICAnQ2FuY2VsZWQnLFxuICAgIE5PX0FOU1dFUjogICAgICAgICAgICAgICAgJ05vIEFuc3dlcicsXG4gICAgRVhQSVJFUzogICAgICAgICAgICAgICAgICAnRXhwaXJlcycsXG4gICAgTk9fQUNLOiAgICAgICAgICAgICAgICAgICAnTm8gQUNLJyxcbiAgICBOT19QUkFDSzogICAgICAgICAgICAgICAgICdObyBQUkFDSycsXG4gICAgVVNFUl9ERU5JRURfTUVESUFfQUNDRVNTOiAnVXNlciBEZW5pZWQgTWVkaWEgQWNjZXNzJyxcbiAgICBCQURfTUVESUFfREVTQ1JJUFRJT046ICAgICdCYWQgTWVkaWEgRGVzY3JpcHRpb24nLFxuICAgIFJUUF9USU1FT1VUOiAgICAgICAgICAgICAgJ1JUUCBUaW1lb3V0J1xuICB9LFxuXG4gIHN1cHBvcnRlZDoge1xuICAgIFVOU1VQUE9SVEVEOiAgICAgICAgJ25vbmUnLFxuICAgIFNVUFBPUlRFRDogICAgICAgICAgJ3N1cHBvcnRlZCcsXG4gICAgUkVRVUlSRUQ6ICAgICAgICAgICAncmVxdWlyZWQnXG4gIH0sXG5cbiAgU0lQX0VSUk9SX0NBVVNFUzoge1xuICAgIFJFRElSRUNURUQ6IFszMDAsMzAxLDMwMiwzMDUsMzgwXSxcbiAgICBCVVNZOiBbNDg2LDYwMF0sXG4gICAgUkVKRUNURUQ6IFs0MDMsNjAzXSxcbiAgICBOT1RfRk9VTkQ6IFs0MDQsNjA0XSxcbiAgICBVTkFWQUlMQUJMRTogWzQ4MCw0MTAsNDA4LDQzMF0sXG4gICAgQUREUkVTU19JTkNPTVBMRVRFOiBbNDg0XSxcbiAgICBJTkNPTVBBVElCTEVfU0RQOiBbNDg4LDYwNl0sXG4gICAgQVVUSEVOVElDQVRJT05fRVJST1I6WzQwMSw0MDddXG4gIH0sXG5cbiAgLy8gU0lQIE1ldGhvZHNcbiAgQUNLOiAgICAgICAgJ0FDSycsXG4gIEJZRTogICAgICAgICdCWUUnLFxuICBDQU5DRUw6ICAgICAnQ0FOQ0VMJyxcbiAgSU5GTzogICAgICAgJ0lORk8nLFxuICBJTlZJVEU6ICAgICAnSU5WSVRFJyxcbiAgTUVTU0FHRTogICAgJ01FU1NBR0UnLFxuICBOT1RJRlk6ICAgICAnTk9USUZZJyxcbiAgT1BUSU9OUzogICAgJ09QVElPTlMnLFxuICBSRUdJU1RFUjogICAnUkVHSVNURVInLFxuICBVUERBVEU6ICAgICAnVVBEQVRFJyxcbiAgU1VCU0NSSUJFOiAgJ1NVQlNDUklCRScsXG4gIFJFRkVSOiAgICAgICdSRUZFUicsXG4gIFBSQUNLOiAgICAgICdQUkFDSycsXG5cbiAgLyogU0lQIFJlc3BvbnNlIFJlYXNvbnNcbiAgICogRE9DOiBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL3NpcC1wYXJhbWV0ZXJzXG4gICAqIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJzYXRpY2EvT3ZlclNJUC9ibG9iL21hc3Rlci9saWIvb3ZlcnNpcC9zaXAvY29uc3RhbnRzLnJiI0w3XG4gICAqL1xuICBSRUFTT05fUEhSQVNFOiB7XG4gICAgMTAwOiAnVHJ5aW5nJyxcbiAgICAxODA6ICdSaW5naW5nJyxcbiAgICAxODE6ICdDYWxsIElzIEJlaW5nIEZvcndhcmRlZCcsXG4gICAgMTgyOiAnUXVldWVkJyxcbiAgICAxODM6ICdTZXNzaW9uIFByb2dyZXNzJyxcbiAgICAxOTk6ICdFYXJseSBEaWFsb2cgVGVybWluYXRlZCcsICAvLyBkcmFmdC1pZXRmLXNpcGNvcmUtMTk5XG4gICAgMjAwOiAnT0snLFxuICAgIDIwMjogJ0FjY2VwdGVkJywgIC8vIFJGQyAzMjY1XG4gICAgMjA0OiAnTm8gTm90aWZpY2F0aW9uJywgIC8vUkZDIDU4MzlcbiAgICAzMDA6ICdNdWx0aXBsZSBDaG9pY2VzJyxcbiAgICAzMDE6ICdNb3ZlZCBQZXJtYW5lbnRseScsXG4gICAgMzAyOiAnTW92ZWQgVGVtcG9yYXJpbHknLFxuICAgIDMwNTogJ1VzZSBQcm94eScsXG4gICAgMzgwOiAnQWx0ZXJuYXRpdmUgU2VydmljZScsXG4gICAgNDAwOiAnQmFkIFJlcXVlc3QnLFxuICAgIDQwMTogJ1VuYXV0aG9yaXplZCcsXG4gICAgNDAyOiAnUGF5bWVudCBSZXF1aXJlZCcsXG4gICAgNDAzOiAnRm9yYmlkZGVuJyxcbiAgICA0MDQ6ICdOb3QgRm91bmQnLFxuICAgIDQwNTogJ01ldGhvZCBOb3QgQWxsb3dlZCcsXG4gICAgNDA2OiAnTm90IEFjY2VwdGFibGUnLFxuICAgIDQwNzogJ1Byb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJyxcbiAgICA0MDg6ICdSZXF1ZXN0IFRpbWVvdXQnLFxuICAgIDQxMDogJ0dvbmUnLFxuICAgIDQxMjogJ0NvbmRpdGlvbmFsIFJlcXVlc3QgRmFpbGVkJywgIC8vIFJGQyAzOTAzXG4gICAgNDEzOiAnUmVxdWVzdCBFbnRpdHkgVG9vIExhcmdlJyxcbiAgICA0MTQ6ICdSZXF1ZXN0LVVSSSBUb28gTG9uZycsXG4gICAgNDE1OiAnVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZScsXG4gICAgNDE2OiAnVW5zdXBwb3J0ZWQgVVJJIFNjaGVtZScsXG4gICAgNDE3OiAnVW5rbm93biBSZXNvdXJjZS1Qcmlvcml0eScsICAvLyBSRkMgNDQxMlxuICAgIDQyMDogJ0JhZCBFeHRlbnNpb24nLFxuICAgIDQyMTogJ0V4dGVuc2lvbiBSZXF1aXJlZCcsXG4gICAgNDIyOiAnU2Vzc2lvbiBJbnRlcnZhbCBUb28gU21hbGwnLCAgLy8gUkZDIDQwMjhcbiAgICA0MjM6ICdJbnRlcnZhbCBUb28gQnJpZWYnLFxuICAgIDQyODogJ1VzZSBJZGVudGl0eSBIZWFkZXInLCAgLy8gUkZDIDQ0NzRcbiAgICA0Mjk6ICdQcm92aWRlIFJlZmVycmVyIElkZW50aXR5JywgIC8vIFJGQyAzODkyXG4gICAgNDMwOiAnRmxvdyBGYWlsZWQnLCAgLy8gUkZDIDU2MjZcbiAgICA0MzM6ICdBbm9ueW1pdHkgRGlzYWxsb3dlZCcsICAvLyBSRkMgNTA3OVxuICAgIDQzNjogJ0JhZCBJZGVudGl0eS1JbmZvJywgIC8vIFJGQyA0NDc0XG4gICAgNDM3OiAnVW5zdXBwb3J0ZWQgQ2VydGlmaWNhdGUnLCAgLy8gUkZDIDQ3NDRcbiAgICA0Mzg6ICdJbnZhbGlkIElkZW50aXR5IEhlYWRlcicsICAvLyBSRkMgNDc0NFxuICAgIDQzOTogJ0ZpcnN0IEhvcCBMYWNrcyBPdXRib3VuZCBTdXBwb3J0JywgIC8vIFJGQyA1NjI2XG4gICAgNDQwOiAnTWF4LUJyZWFkdGggRXhjZWVkZWQnLCAgLy8gUkZDIDUzOTNcbiAgICA0Njk6ICdCYWQgSW5mbyBQYWNrYWdlJywgIC8vIGRyYWZ0LWlldGYtc2lwY29yZS1pbmZvLWV2ZW50c1xuICAgIDQ3MDogJ0NvbnNlbnQgTmVlZGVkJywgIC8vIFJGQyA1MzYwXG4gICAgNDc4OiAnVW5yZXNvbHZhYmxlIERlc3RpbmF0aW9uJywgIC8vIEN1c3RvbSBjb2RlIGNvcGllZCBmcm9tIEthbWFpbGlvLlxuICAgIDQ4MDogJ1RlbXBvcmFyaWx5IFVuYXZhaWxhYmxlJyxcbiAgICA0ODE6ICdDYWxsL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0JyxcbiAgICA0ODI6ICdMb29wIERldGVjdGVkJyxcbiAgICA0ODM6ICdUb28gTWFueSBIb3BzJyxcbiAgICA0ODQ6ICdBZGRyZXNzIEluY29tcGxldGUnLFxuICAgIDQ4NTogJ0FtYmlndW91cycsXG4gICAgNDg2OiAnQnVzeSBIZXJlJyxcbiAgICA0ODc6ICdSZXF1ZXN0IFRlcm1pbmF0ZWQnLFxuICAgIDQ4ODogJ05vdCBBY2NlcHRhYmxlIEhlcmUnLFxuICAgIDQ4OTogJ0JhZCBFdmVudCcsICAvLyBSRkMgMzI2NVxuICAgIDQ5MTogJ1JlcXVlc3QgUGVuZGluZycsXG4gICAgNDkzOiAnVW5kZWNpcGhlcmFibGUnLFxuICAgIDQ5NDogJ1NlY3VyaXR5IEFncmVlbWVudCBSZXF1aXJlZCcsICAvLyBSRkMgMzMyOVxuICAgIDUwMDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgNTAxOiAnTm90IEltcGxlbWVudGVkJyxcbiAgICA1MDI6ICdCYWQgR2F0ZXdheScsXG4gICAgNTAzOiAnU2VydmljZSBVbmF2YWlsYWJsZScsXG4gICAgNTA0OiAnU2VydmVyIFRpbWUtb3V0JyxcbiAgICA1MDU6ICdWZXJzaW9uIE5vdCBTdXBwb3J0ZWQnLFxuICAgIDUxMzogJ01lc3NhZ2UgVG9vIExhcmdlJyxcbiAgICA1ODA6ICdQcmVjb25kaXRpb24gRmFpbHVyZScsICAvLyBSRkMgMzMxMlxuICAgIDYwMDogJ0J1c3kgRXZlcnl3aGVyZScsXG4gICAgNjAzOiAnRGVjbGluZScsXG4gICAgNjA0OiAnRG9lcyBOb3QgRXhpc3QgQW55d2hlcmUnLFxuICAgIDYwNjogJ05vdCBBY2NlcHRhYmxlJ1xuICB9LFxuXG4gIC8qIFNJUCBPcHRpb24gVGFnc1xuICAgKiBET0M6IGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvc2lwLXBhcmFtZXRlcnMvc2lwLXBhcmFtZXRlcnMueGh0bWwjc2lwLXBhcmFtZXRlcnMtNFxuICAgKi9cbiAgT1BUSU9OX1RBR1M6IHtcbiAgICAnMTAwcmVsJzogICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzMjYyXG4gICAgMTk5OiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNjIyOFxuICAgIGFuc3dlcm1vZGU6ICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDUzNzNcbiAgICAnZWFybHktc2Vzc2lvbic6ICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzOTU5XG4gICAgZXZlbnRsaXN0OiAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDY2MlxuICAgIGV4cGxpY2l0c3ViOiAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDLWlldGYtc2lwY29yZS1yZWZlci1leHBsaWNpdC1zdWJzY3JpcHRpb24tMDNcbiAgICAnZnJvbS1jaGFuZ2UnOiAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA0OTE2XG4gICAgJ2dlb2xvY2F0aW9uLWh0dHAnOiAgICAgICAgIHRydWUsICAvLyBSRkMgNjQ0MlxuICAgICdnZW9sb2NhdGlvbi1zaXAnOiAgICAgICAgICB0cnVlLCAgLy8gUkZDIDY0NDJcbiAgICBnaW46ICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA2MTQwXG4gICAgZ3J1dTogICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNTYyN1xuICAgIGhpc3RpbmZvOiAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDcwNDRcbiAgICBpY2U6ICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1NzY4XG4gICAgam9pbjogICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzkxMVxuICAgICdtdWx0aXBsZS1yZWZlcic6ICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDUzNjhcbiAgICBub3JlZmVyc3ViOiAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA0NDg4XG4gICAgbm9zdWI6ICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMtaWV0Zi1zaXBjb3JlLXJlZmVyLWV4cGxpY2l0LXN1YnNjcmlwdGlvbi0wM1xuICAgIG91dGJvdW5kOiAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDU2MjZcbiAgICBwYXRoOiAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzMzI3XG4gICAgcG9saWN5OiAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNjc5NFxuICAgIHByZWNvbmRpdGlvbjogICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDMzMTJcbiAgICBwcmVmOiAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzODQwXG4gICAgcHJpdmFjeTogICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzMyM1xuICAgICdyZWNpcGllbnQtbGlzdC1pbnZpdGUnOiAgICB0cnVlLCAgLy8gUkZDIDUzNjZcbiAgICAncmVjaXBpZW50LWxpc3QtbWVzc2FnZSc6ICAgdHJ1ZSwgIC8vIFJGQyA1MzY1XG4gICAgJ3JlY2lwaWVudC1saXN0LXN1YnNjcmliZSc6IHRydWUsICAvLyBSRkMgNTM2N1xuICAgIHJlcGxhY2VzOiAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDM4OTFcbiAgICAncmVzb3VyY2UtcHJpb3JpdHknOiAgICAgICAgdHJ1ZSwgIC8vIFJGQyA0NDEyXG4gICAgJ3NkcC1hbmF0JzogICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDA5MlxuICAgICdzZWMtYWdyZWUnOiAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDMzMjlcbiAgICB0ZGlhbG9nOiAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA0NTM4XG4gICAgdGltZXI6ICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDAyOFxuICAgIHV1aTogICAgICAgICAgICAgICAgICAgICAgICB0cnVlICAgLy8gUkZDIDc0MzNcbiAgfVxufTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0NvbnN0YW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXhjZXB0aW9uc1xuICovXG5cbi8qKlxuICogU0lQIEV4Y2VwdGlvbnMuXG4gKiBAYXVnbWVudHMgU0lQXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDb25maWd1cmF0aW9uRXJyb3I6IChmdW5jdGlvbigpe1xuICAgIHZhciBleGNlcHRpb24gPSBmdW5jdGlvbihwYXJhbWV0ZXIsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNvZGUgPSAxO1xuICAgICAgdGhpcy5uYW1lID0gJ0NPTkZJR1VSQVRJT05fRVJST1InO1xuICAgICAgdGhpcy5wYXJhbWV0ZXIgPSBwYXJhbWV0ZXI7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSAoIXRoaXMudmFsdWUpPyAnTWlzc2luZyBwYXJhbWV0ZXI6ICcrIHRoaXMucGFyYW1ldGVyIDogJ0ludmFsaWQgdmFsdWUgJysgSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSkgKycgZm9yIHBhcmFtZXRlciBcIicrIHRoaXMucGFyYW1ldGVyICsnXCInO1xuICAgIH07XG4gICAgZXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgIHJldHVybiBleGNlcHRpb247XG4gIH0oKSksXG5cbiAgSW52YWxpZFN0YXRlRXJyb3I6IChmdW5jdGlvbigpe1xuICAgIHZhciBleGNlcHRpb24gPSBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIHRoaXMuY29kZSA9IDI7XG4gICAgICB0aGlzLm5hbWUgPSAnSU5WQUxJRF9TVEFURV9FUlJPUic7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgIHRoaXMubWVzc2FnZSA9ICdJbnZhbGlkIHN0YXR1czogJyArIHN0YXR1cztcbiAgICB9O1xuICAgIGV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICByZXR1cm4gZXhjZXB0aW9uO1xuICB9KCkpLFxuXG4gIE5vdFN1cHBvcnRlZEVycm9yOiAoZnVuY3Rpb24oKXtcbiAgICB2YXIgZXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgdGhpcy5jb2RlID0gMztcbiAgICAgIHRoaXMubmFtZSA9ICdOT1RfU1VQUE9SVEVEX0VSUk9SJztcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfTtcbiAgICBleGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgcmV0dXJuIGV4Y2VwdGlvbjtcbiAgfSgpKSxcblxuICBHZXREZXNjcmlwdGlvbkVycm9yOiAoZnVuY3Rpb24oKXtcbiAgICB2YXIgZXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgdGhpcy5jb2RlID0gNDtcbiAgICAgIHRoaXMubmFtZSA9ICdHRVRfREVTQ1JJUFRJT05fRVJST1InO1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9O1xuICAgIGV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICByZXR1cm4gZXhjZXB0aW9uO1xuICB9KCkpXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9FeGNlcHRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgVElNRVJTXG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKi9cbnZhclxuICBUMSA9IDUwMCxcbiAgVDIgPSA0MDAwLFxuICBUNCA9IDUwMDA7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aW1lcnMpIHtcbiAgdmFyIFRpbWVycyA9IHtcbiAgICBUMTogVDEsXG4gICAgVDI6IFQyLFxuICAgIFQ0OiBUNCxcbiAgICBUSU1FUl9COiA2NCAqIFQxLFxuICAgIFRJTUVSX0Q6IDAgICogVDEsXG4gICAgVElNRVJfRjogNjQgKiBUMSxcbiAgICBUSU1FUl9IOiA2NCAqIFQxLFxuICAgIFRJTUVSX0k6IDAgICogVDEsXG4gICAgVElNRVJfSjogMCAgKiBUMSxcbiAgICBUSU1FUl9LOiAwICAqIFQ0LFxuICAgIFRJTUVSX0w6IDY0ICogVDEsXG4gICAgVElNRVJfTTogNjQgKiBUMSxcbiAgICBUSU1FUl9OOiA2NCAqIFQxLFxuICAgIFBST1ZJU0lPTkFMX1JFU1BPTlNFX0lOVEVSVkFMOiA2MDAwMCAgLy8gU2VlIFJGQyAzMjYxIFNlY3Rpb24gMTMuMy4xLjFcbiAgfTtcblxuICBbJ3NldFRpbWVvdXQnLCAnY2xlYXJUaW1lb3V0JywgJ3NldEludGVydmFsJywgJ2NsZWFySW50ZXJ2YWwnXVxuICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIGNhbid0IGp1c3QgdXNlIHRpbWVyc1tuYW1lXS5iaW5kKHRpbWVycykgc2luY2UgaXQgYnlwYXNzZXMgamFzbWluZSdzXG4gICAgLy8gY2xvY2stbW9ja2luZ1xuICAgIFRpbWVyc1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aW1lcnNbbmFtZV0uYXBwbHkodGltZXJzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBUaW1lcnM7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9UaW1lcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBNZXNzYWdlIFBhcnNlclxuICovXG5cbi8qKlxuICogRXh0cmFjdCBhbmQgcGFyc2UgZXZlcnkgaGVhZGVyIG9mIGEgU0lQIG1lc3NhZ2UuXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAbmFtZXNwYWNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIFBhcnNlcjtcblxuZnVuY3Rpb24gZ2V0SGVhZGVyKGRhdGEsIGhlYWRlclN0YXJ0KSB7XG4gIHZhclxuICAgIC8vICdzdGFydCcgcG9zaXRpb24gb2YgdGhlIGhlYWRlci5cbiAgICBzdGFydCA9IGhlYWRlclN0YXJ0LFxuICAgIC8vICdlbmQnIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIuXG4gICAgZW5kID0gMCxcbiAgICAvLyAncGFydGlhbCBlbmQnIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIuXG4gICAgcGFydGlhbEVuZCA9IDA7XG5cbiAgLy9FbmQgb2YgbWVzc2FnZS5cbiAgaWYgKGRhdGEuc3Vic3RyaW5nKHN0YXJ0LCBzdGFydCArIDIpLm1hdGNoKC8oXlxcclxcbikvKSkge1xuICAgIHJldHVybiAtMjtcbiAgfVxuXG4gIHdoaWxlKGVuZCA9PT0gMCkge1xuICAgIC8vIFBhcnRpYWwgRW5kIG9mIEhlYWRlci5cbiAgICBwYXJ0aWFsRW5kID0gZGF0YS5pbmRleE9mKCdcXHJcXG4nLCBzdGFydCk7XG5cbiAgICAvLyAnaW5kZXhPZicgcmV0dXJucyAtMSBpZiB0aGUgdmFsdWUgdG8gYmUgZm91bmQgbmV2ZXIgb2NjdXJzLlxuICAgIGlmIChwYXJ0aWFsRW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIHBhcnRpYWxFbmQ7XG4gICAgfVxuXG4gICAgaWYoIWRhdGEuc3Vic3RyaW5nKHBhcnRpYWxFbmQgKyAyLCBwYXJ0aWFsRW5kICsgNCkubWF0Y2goLyheXFxyXFxuKS8pICYmIGRhdGEuY2hhckF0KHBhcnRpYWxFbmQgKyAyKS5tYXRjaCgvKF5cXHMrKS8pKSB7XG4gICAgICAvLyBOb3QgdGhlIGVuZCBvZiB0aGUgbWVzc2FnZS4gQ29udGludWUgZnJvbSB0aGUgbmV4dCBwb3NpdGlvbi5cbiAgICAgIHN0YXJ0ID0gcGFydGlhbEVuZCArIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IHBhcnRpYWxFbmQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVuZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIobWVzc2FnZSwgZGF0YSwgaGVhZGVyU3RhcnQsIGhlYWRlckVuZCkge1xuICB2YXIgaGVhZGVyLCBpZHgsIGxlbmd0aCwgcGFyc2VkLFxuICAgIGhjb2xvbkluZGV4ID0gZGF0YS5pbmRleE9mKCc6JywgaGVhZGVyU3RhcnQpLFxuICAgIGhlYWRlck5hbWUgPSBkYXRhLnN1YnN0cmluZyhoZWFkZXJTdGFydCwgaGNvbG9uSW5kZXgpLnRyaW0oKSxcbiAgICBoZWFkZXJWYWx1ZSA9IGRhdGEuc3Vic3RyaW5nKGhjb2xvbkluZGV4ICsgMSwgaGVhZGVyRW5kKS50cmltKCk7XG5cbiAgLy8gSWYgaGVhZGVyLWZpZWxkIGlzIHdlbGwta25vd24sIHBhcnNlIGl0LlxuICBzd2l0Y2goaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAndmlhJzpcbiAgICBjYXNlICd2JzpcbiAgICAgIG1lc3NhZ2UuYWRkSGVhZGVyKCd2aWEnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBpZihtZXNzYWdlLmdldEhlYWRlcnMoJ3ZpYScpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdWaWEnKTtcbiAgICAgICAgaWYocGFyc2VkKSB7XG4gICAgICAgICAgbWVzc2FnZS52aWEgPSBwYXJzZWQ7XG4gICAgICAgICAgbWVzc2FnZS52aWFfYnJhbmNoID0gcGFyc2VkLmJyYW5jaDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zyb20nOlxuICAgIGNhc2UgJ2YnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ2Zyb20nLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdmcm9tJyk7XG4gICAgICBpZihwYXJzZWQpIHtcbiAgICAgICAgbWVzc2FnZS5mcm9tID0gcGFyc2VkO1xuICAgICAgICBtZXNzYWdlLmZyb21fdGFnID0gcGFyc2VkLmdldFBhcmFtKCd0YWcnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RvJzpcbiAgICBjYXNlICd0JzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCd0bycsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ3RvJyk7XG4gICAgICBpZihwYXJzZWQpIHtcbiAgICAgICAgbWVzc2FnZS50byA9IHBhcnNlZDtcbiAgICAgICAgbWVzc2FnZS50b190YWcgPSBwYXJzZWQuZ2V0UGFyYW0oJ3RhZycpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmVjb3JkLXJvdXRlJzpcbiAgICAgIHBhcnNlZCA9IFNJUC5HcmFtbWFyLnBhcnNlKGhlYWRlclZhbHVlLCAnUmVjb3JkX1JvdXRlJyk7XG5cbiAgICAgIGlmIChwYXJzZWQgPT09IC0xKSB7XG4gICAgICAgIHBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IHBhcnNlZC5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaGVhZGVyID0gcGFyc2VkW2lkeF07XG4gICAgICAgIG1lc3NhZ2UuYWRkSGVhZGVyKCdyZWNvcmQtcm91dGUnLCBoZWFkZXJWYWx1ZS5zdWJzdHJpbmcoaGVhZGVyLnBvc2l0aW9uLCBoZWFkZXIub2Zmc2V0KSk7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyc1snUmVjb3JkLVJvdXRlJ11bbWVzc2FnZS5nZXRIZWFkZXJzKCdyZWNvcmQtcm91dGUnKS5sZW5ndGggLSAxXS5wYXJzZWQgPSBoZWFkZXIucGFyc2VkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2FsbC1pZCc6XG4gICAgY2FzZSAnaSc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcignY2FsbC1pZCcsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2NhbGwtaWQnKTtcbiAgICAgIGlmKHBhcnNlZCkge1xuICAgICAgICBtZXNzYWdlLmNhbGxfaWQgPSBoZWFkZXJWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbnRhY3QnOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcGFyc2VkID0gU0lQLkdyYW1tYXIucGFyc2UoaGVhZGVyVmFsdWUsICdDb250YWN0Jyk7XG5cbiAgICAgIGlmIChwYXJzZWQgPT09IC0xKSB7XG4gICAgICAgIHBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IHBhcnNlZC5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaGVhZGVyID0gcGFyc2VkW2lkeF07XG4gICAgICAgIG1lc3NhZ2UuYWRkSGVhZGVyKCdjb250YWN0JywgaGVhZGVyVmFsdWUuc3Vic3RyaW5nKGhlYWRlci5wb3NpdGlvbiwgaGVhZGVyLm9mZnNldCkpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlcnNbJ0NvbnRhY3QnXVttZXNzYWdlLmdldEhlYWRlcnMoJ2NvbnRhY3QnKS5sZW5ndGggLSAxXS5wYXJzZWQgPSBoZWFkZXIucGFyc2VkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY29udGVudC1sZW5ndGgnOlxuICAgIGNhc2UgJ2wnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignY29udGVudC1sZW5ndGgnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbnRlbnQtdHlwZSc6XG4gICAgY2FzZSAnYyc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcignY29udGVudC10eXBlJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignY29udGVudC10eXBlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjc2VxJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdjc2VxJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignY3NlcScpO1xuICAgICAgaWYocGFyc2VkKSB7XG4gICAgICAgIG1lc3NhZ2UuY3NlcSA9IHBhcnNlZC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXNwb25zZSkge1xuICAgICAgICBtZXNzYWdlLm1ldGhvZCA9IHBhcnNlZC5tZXRob2Q7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtYXgtZm9yd2FyZHMnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ21heC1mb3J3YXJkcycsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ21heC1mb3J3YXJkcycpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnd3d3LWF1dGhlbnRpY2F0ZSc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcignd3d3LWF1dGhlbnRpY2F0ZScsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ3d3dy1hdXRoZW50aWNhdGUnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3Byb3h5LWF1dGhlbnRpY2F0ZSc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcigncHJveHktYXV0aGVudGljYXRlJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcigncHJveHktYXV0aGVudGljYXRlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWZlci10byc6XG4gICAgY2FzZSAncic6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcigncmVmZXItdG8nLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdyZWZlci10bycpO1xuICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICBtZXNzYWdlLnJlZmVyX3RvID0gcGFyc2VkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIERvIG5vdCBwYXJzZSB0aGlzIGhlYWRlci5cbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IDA7XG4gIH1cblxuICBpZiAocGFyc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6ICdlcnJvciBwYXJzaW5nIGhlYWRlciBcIicrIGhlYWRlck5hbWUgKydcIidcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKiBQYXJzZSBTSVAgTWVzc2FnZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBTSVAgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2dnZXIgb2JqZWN0LlxuICogQHJldHVybnMge1NJUC5JbmNvbWluZ1JlcXVlc3R8U0lQLkluY29taW5nUmVzcG9uc2V8dW5kZWZpbmVkfVxuICovXG5QYXJzZXIgPSB7fTtcblBhcnNlci5wYXJzZU1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhLCB1YSkge1xuICB2YXIgbWVzc2FnZSwgZmlyc3RMaW5lLCBjb250ZW50TGVuZ3RoLCBib2R5U3RhcnQsIHBhcnNlZCxcbiAgICBoZWFkZXJTdGFydCA9IDAsXG4gICAgaGVhZGVyRW5kID0gZGF0YS5pbmRleE9mKCdcXHJcXG4nKSxcbiAgICBsb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5wYXJzZXInKTtcblxuICBpZihoZWFkZXJFbmQgPT09IC0xKSB7XG4gICAgbG9nZ2VyLndhcm4oJ25vIENSTEYgZm91bmQsIG5vdCBhIFNJUCBtZXNzYWdlLCBkaXNjYXJkZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBQYXJzZSBmaXJzdCBsaW5lLiBDaGVjayBpZiBpdCBpcyBhIFJlcXVlc3Qgb3IgYSBSZXBseS5cbiAgZmlyc3RMaW5lID0gZGF0YS5zdWJzdHJpbmcoMCwgaGVhZGVyRW5kKTtcbiAgcGFyc2VkID0gU0lQLkdyYW1tYXIucGFyc2UoZmlyc3RMaW5lLCAnUmVxdWVzdF9SZXNwb25zZScpO1xuXG4gIGlmKHBhcnNlZCA9PT0gLTEpIHtcbiAgICBsb2dnZXIud2FybignZXJyb3IgcGFyc2luZyBmaXJzdCBsaW5lIG9mIFNJUCBtZXNzYWdlOiBcIicgKyBmaXJzdExpbmUgKyAnXCInKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZighcGFyc2VkLnN0YXR1c19jb2RlKSB7XG4gICAgbWVzc2FnZSA9IG5ldyBTSVAuSW5jb21pbmdSZXF1ZXN0KHVhKTtcbiAgICBtZXNzYWdlLm1ldGhvZCA9IHBhcnNlZC5tZXRob2Q7XG4gICAgbWVzc2FnZS5ydXJpID0gcGFyc2VkLnVyaTtcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlID0gbmV3IFNJUC5JbmNvbWluZ1Jlc3BvbnNlKHVhKTtcbiAgICBtZXNzYWdlLnN0YXR1c19jb2RlID0gcGFyc2VkLnN0YXR1c19jb2RlO1xuICAgIG1lc3NhZ2UucmVhc29uX3BocmFzZSA9IHBhcnNlZC5yZWFzb25fcGhyYXNlO1xuICB9XG5cbiAgbWVzc2FnZS5kYXRhID0gZGF0YTtcbiAgaGVhZGVyU3RhcnQgPSBoZWFkZXJFbmQgKyAyO1xuXG4gIC8qIExvb3Agb3ZlciBldmVyeSBsaW5lIGluIGRhdGEuIERldGVjdCB0aGUgZW5kIG9mIGVhY2ggaGVhZGVyIGFuZCBwYXJzZVxuICAqIGl0IG9yIHNpbXBseSBhZGQgdG8gdGhlIGhlYWRlcnMgY29sbGVjdGlvbi5cbiAgKi9cbiAgd2hpbGUodHJ1ZSkge1xuICAgIGhlYWRlckVuZCA9IGdldEhlYWRlcihkYXRhLCBoZWFkZXJTdGFydCk7XG5cbiAgICAvLyBUaGUgU0lQIG1lc3NhZ2UgaGFzIG5vcm1hbGx5IGZpbmlzaGVkLlxuICAgIGlmKGhlYWRlckVuZCA9PT0gLTIpIHtcbiAgICAgIGJvZHlTdGFydCA9IGhlYWRlclN0YXJ0ICsgMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBkYXRhLmluZGV4T2YgcmV0dXJuZWQgLTEgZHVlIHRvIGEgbWFsZm9ybWVkIG1lc3NhZ2UuXG4gICAgZWxzZSBpZihoZWFkZXJFbmQgPT09IC0xKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ21hbGZvcm1lZCBtZXNzYWdlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFyc2VkID0gcGFyc2VIZWFkZXIobWVzc2FnZSwgZGF0YSwgaGVhZGVyU3RhcnQsIGhlYWRlckVuZCk7XG5cbiAgICBpZihwYXJzZWQgIT09IHRydWUpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihwYXJzZWQuZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhlYWRlclN0YXJ0ID0gaGVhZGVyRW5kICsgMjtcbiAgfVxuXG4gIC8qIFJGQzMyNjEgMTguMy5cbiAgICogSWYgdGhlcmUgYXJlIGFkZGl0aW9uYWwgYnl0ZXMgaW4gdGhlIHRyYW5zcG9ydCBwYWNrZXRcbiAgICogYmV5b25kIHRoZSBlbmQgb2YgdGhlIGJvZHksIHRoZXkgTVVTVCBiZSBkaXNjYXJkZWQuXG4gICAqL1xuICBpZihtZXNzYWdlLmhhc0hlYWRlcignY29udGVudC1sZW5ndGgnKSkge1xuICAgIGNvbnRlbnRMZW5ndGggPSBtZXNzYWdlLmdldEhlYWRlcignY29udGVudC1sZW5ndGgnKTtcbiAgICBtZXNzYWdlLmJvZHkgPSBkYXRhLnN1YnN0cihib2R5U3RhcnQsIGNvbnRlbnRMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UuYm9keSA9IGRhdGEuc3Vic3RyaW5nKGJvZHlTdGFydCk7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZTtcbn07XG5cblNJUC5QYXJzZXIgPSBQYXJzZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9QYXJzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBNZXNzYWdlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXJcbiAgT3V0Z29pbmdSZXF1ZXN0LFxuICBJbmNvbWluZ01lc3NhZ2UsXG4gIEluY29taW5nUmVxdWVzdCxcbiAgSW5jb21pbmdSZXNwb25zZTtcblxuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkSGVhZGVyIChyZXF1ZXN0KSB7XG4gIHZhciBhbGxvd1VucmVnaXN0ZXJlZCA9IHJlcXVlc3QudWEuY29uZmlndXJhdGlvbi5oYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzO1xuICB2YXIgb3B0aW9uVGFncyA9IFtdO1xuICB2YXIgb3B0aW9uVGFnU2V0ID0ge307XG5cbiAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5SRUdJU1RFUikge1xuICAgIG9wdGlvblRhZ3MucHVzaCgncGF0aCcsICdncnV1Jyk7XG4gIH0gZWxzZSBpZiAocmVxdWVzdC5tZXRob2QgPT09IFNJUC5DLklOVklURSAmJlxuICAgICAgICAgICAgIChyZXF1ZXN0LnVhLmNvbnRhY3QucHViX2dydXUgfHwgcmVxdWVzdC51YS5jb250YWN0LnRlbXBfZ3J1dSkpIHtcbiAgICBvcHRpb25UYWdzLnB1c2goJ2dydXUnKTtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LnVhLmNvbmZpZ3VyYXRpb24ucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgb3B0aW9uVGFncy5wdXNoKCcxMDByZWwnKTtcbiAgfVxuICBpZiAocmVxdWVzdC51YS5jb25maWd1cmF0aW9uLnJlcGxhY2VzID09PSBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgb3B0aW9uVGFncy5wdXNoKCdyZXBsYWNlcycpO1xuICB9XG5cbiAgb3B0aW9uVGFncy5wdXNoKCdvdXRib3VuZCcpO1xuXG4gIG9wdGlvblRhZ3MgPSBvcHRpb25UYWdzLmNvbmNhdChyZXF1ZXN0LnVhLmNvbmZpZ3VyYXRpb24uZXh0cmFTdXBwb3J0ZWQpO1xuXG4gIG9wdGlvblRhZ3MgPSBvcHRpb25UYWdzLmZpbHRlcihmdW5jdGlvbihvcHRpb25UYWcpIHtcbiAgICB2YXIgcmVnaXN0ZXJlZCA9IFNJUC5DLk9QVElPTl9UQUdTW29wdGlvblRhZ107XG4gICAgdmFyIHVuaXF1ZSA9ICFvcHRpb25UYWdTZXRbb3B0aW9uVGFnXTtcbiAgICBvcHRpb25UYWdTZXRbb3B0aW9uVGFnXSA9IHRydWU7XG4gICAgcmV0dXJuIChyZWdpc3RlcmVkIHx8IGFsbG93VW5yZWdpc3RlcmVkKSAmJiB1bmlxdWU7XG4gIH0pO1xuXG4gIHJldHVybiAnU3VwcG9ydGVkOiAnICsgb3B0aW9uVGFncy5qb2luKCcsICcpICsgJ1xcclxcbic7XG59XG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGZvciBvdXRnb2luZyBTSVAgcmVxdWVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgcmVxdWVzdCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBydXJpIHJlcXVlc3QgdXJpXG4gKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVycyB0aGF0IHdpbGwgaGF2ZSBwcmlvcml0eSBvdmVyIHVhLmNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAqIDxicj5cbiAqICAtIGNzZXEsIGNhbGxfaWQsIGZyb21fdGFnLCBmcm9tX3VyaSwgZnJvbV9kaXNwbGF5TmFtZSwgdG9fdXJpLCB0b190YWcsIHJvdXRlX3NldFxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBleHRyYSBoZWFkZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gW2JvZHldXG4gKi9cbk91dGdvaW5nUmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgcnVyaSwgdWEsIHBhcmFtcywgZXh0cmFIZWFkZXJzLCBib2R5KSB7XG4gIHZhclxuICAgIHRvLFxuICAgIGZyb20sXG4gICAgY2FsbF9pZCxcbiAgICBjc2VxLFxuICAgIHRvX3VyaSxcbiAgICBmcm9tX3VyaTtcblxuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgLy8gTWFuZGF0b3J5IHBhcmFtZXRlcnMgY2hlY2tcbiAgaWYoIW1ldGhvZCB8fCAhcnVyaSB8fCAhdWEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuc2lwbWVzc2FnZScpO1xuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMuaGVhZGVycyA9IHt9O1xuICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgdGhpcy5ydXJpID0gcnVyaTtcbiAgdGhpcy5ib2R5ID0gYm9keTtcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSAoZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICB0aGlzLnN0YXR1c0NvZGUgPSBwYXJhbXMuc3RhdHVzX2NvZGU7XG4gIHRoaXMucmVhc29uUGhyYXNlID0gcGFyYW1zLnJlYXNvbl9waHJhc2U7XG5cbiAgLy8gRmlsbCB0aGUgQ29tbW9uIFNJUCBSZXF1ZXN0IEhlYWRlcnNcblxuICAvLyBSb3V0ZVxuICBpZiAocGFyYW1zLnJvdXRlX3NldCkge1xuICAgIHRoaXMuc2V0SGVhZGVyKCdyb3V0ZScsIHBhcmFtcy5yb3V0ZV9zZXQpO1xuICB9IGVsc2UgaWYgKHVhLmNvbmZpZ3VyYXRpb24udXNlUHJlbG9hZGVkUm91dGUpe1xuICAgIHRoaXMuc2V0SGVhZGVyKCdyb3V0ZScsIHVhLnRyYW5zcG9ydC5zZXJ2ZXIuc2lwX3VyaSk7XG4gIH1cblxuICAvLyBWaWFcbiAgLy8gRW1wdHkgVmlhIGhlYWRlci4gV2lsbCBiZSBmaWxsZWQgYnkgdGhlIGNsaWVudCB0cmFuc2FjdGlvbi5cbiAgdGhpcy5zZXRIZWFkZXIoJ3ZpYScsICcnKTtcblxuICAvLyBNYXgtRm9yd2FyZHNcbiAgdGhpcy5zZXRIZWFkZXIoJ21heC1mb3J3YXJkcycsIFNJUC5VQS5DLk1BWF9GT1JXQVJEUyk7XG5cbiAgLy8gVG9cbiAgdG9fdXJpID0gcGFyYW1zLnRvX3VyaSB8fCBydXJpO1xuICB0byA9IChwYXJhbXMudG9fZGlzcGxheU5hbWUgfHwgcGFyYW1zLnRvX2Rpc3BsYXlOYW1lID09PSAwKSA/ICdcIicgKyBwYXJhbXMudG9fZGlzcGxheU5hbWUgKyAnXCIgJyA6ICcnO1xuICB0byArPSAnPCcgKyAodG9fdXJpICYmIHRvX3VyaS50b1JhdyA/IHRvX3VyaS50b1JhdygpIDogdG9fdXJpKSArICc+JztcbiAgdG8gKz0gcGFyYW1zLnRvX3RhZyA/ICc7dGFnPScgKyBwYXJhbXMudG9fdGFnIDogJyc7XG4gIHRoaXMudG8gPSBuZXcgU0lQLk5hbWVBZGRySGVhZGVyLnBhcnNlKHRvKTtcbiAgdGhpcy5zZXRIZWFkZXIoJ3RvJywgdG8pO1xuXG4gIC8vIEZyb21cbiAgZnJvbV91cmkgPSBwYXJhbXMuZnJvbV91cmkgfHwgdWEuY29uZmlndXJhdGlvbi51cmk7XG4gIGlmIChwYXJhbXMuZnJvbV9kaXNwbGF5TmFtZSB8fCBwYXJhbXMuZnJvbV9kaXNwbGF5TmFtZSA9PT0gMCkge1xuICAgIGZyb20gPSAnXCInICsgcGFyYW1zLmZyb21fZGlzcGxheU5hbWUgKyAnXCIgJztcbiAgfSBlbHNlIGlmICh1YS5jb25maWd1cmF0aW9uLmRpc3BsYXlOYW1lKSB7XG4gICAgZnJvbSA9ICdcIicgKyB1YS5jb25maWd1cmF0aW9uLmRpc3BsYXlOYW1lICsgJ1wiICc7XG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9ICcnO1xuICB9XG4gIGZyb20gKz0gJzwnICsgKGZyb21fdXJpICYmIGZyb21fdXJpLnRvUmF3ID8gZnJvbV91cmkudG9SYXcoKSA6IGZyb21fdXJpKSArICc+O3RhZz0nO1xuICBmcm9tICs9IHBhcmFtcy5mcm9tX3RhZyB8fCBTSVAuVXRpbHMubmV3VGFnKCk7XG4gIHRoaXMuZnJvbSA9IG5ldyBTSVAuTmFtZUFkZHJIZWFkZXIucGFyc2UoZnJvbSk7XG4gIHRoaXMuc2V0SGVhZGVyKCdmcm9tJywgZnJvbSk7XG5cbiAgLy8gQ2FsbC1JRFxuICBjYWxsX2lkID0gcGFyYW1zLmNhbGxfaWQgfHwgKHVhLmNvbmZpZ3VyYXRpb24uc2lwanNJZCArIFNJUC5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbigxNSkpO1xuICB0aGlzLmNhbGxfaWQgPSBjYWxsX2lkO1xuICB0aGlzLnNldEhlYWRlcignY2FsbC1pZCcsIGNhbGxfaWQpO1xuXG4gIC8vIENTZXFcbiAgY3NlcSA9IHBhcmFtcy5jc2VxIHx8IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgdGhpcy5jc2VxID0gY3NlcTtcbiAgdGhpcy5zZXRIZWFkZXIoJ2NzZXEnLCBjc2VxICsgJyAnICsgbWV0aG9kKTtcbn07XG5cbk91dGdvaW5nUmVxdWVzdC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSB0aGUgZ2l2ZW4gaGVhZGVyIGJ5IHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gdmFsdWUgaGVhZGVyIHZhbHVlXG4gICAqL1xuICBzZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldID0gKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpID8gdmFsdWUgOiBbdmFsdWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBoZWFkZXIgbmFtZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtTdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgaGVhZGVyLCB1bmRlZmluZWQgaWYgaGVhZGVyIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBnZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgcmVnZXhwLCBpZHgsXG4gICAgICBsZW5ndGggPSB0aGlzLmV4dHJhSGVhZGVycy5sZW5ndGgsXG4gICAgICBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV07XG5cbiAgICBpZihoZWFkZXIpIHtcbiAgICAgIGlmKGhlYWRlclswXSkge1xuICAgICAgICByZXR1cm4gaGVhZGVyWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWdleHAgPSBuZXcgUmVnRXhwKCdeXFxcXHMqJyArIG5hbWUgKyAnXFxcXHMqOicsJ2knKTtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBoZWFkZXIgPSB0aGlzLmV4dHJhSGVhZGVyc1tpZHhdO1xuICAgICAgICBpZiAocmVnZXhwLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICAgIHJldHVybiBoZWFkZXIuc3Vic3RyaW5nKGhlYWRlci5pbmRleE9mKCc6JykrMSkudHJpbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhlYWRlci9zIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IHdpdGggYWxsIHRoZSBoZWFkZXJzIG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICovXG4gIGdldEhlYWRlcnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaWR4LCBsZW5ndGgsIHJlZ2V4cCxcbiAgICAgIGhlYWRlciA9IHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgaWYoaGVhZGVyKSB7XG4gICAgICBsZW5ndGggPSBoZWFkZXIubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGhlYWRlcltpZHhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRoaXMuZXh0cmFIZWFkZXJzLmxlbmd0aDtcbiAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ15cXFxccyonICsgbmFtZSArICdcXFxccyo6JywnaScpO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGhlYWRlciA9IHRoaXMuZXh0cmFIZWFkZXJzW2lkeF07XG4gICAgICAgIGlmIChyZWdleHAudGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaGVhZGVyLnN1YnN0cmluZyhoZWFkZXIuaW5kZXhPZignOicpKzEpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBoZWFkZXIgd2l0aCBnaXZlbiBuYW1lIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBoYXNIZWFkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgcmVnZXhwLCBpZHgsXG4gICAgICBsZW5ndGggPSB0aGlzLmV4dHJhSGVhZGVycy5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxzKicgKyBuYW1lICsgJ1xcXFxzKjonLCdpJyk7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KHRoaXMuZXh0cmFIZWFkZXJzW2lkeF0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtc2cgPSAnJywgaGVhZGVyLCBsZW5ndGgsIGlkeDtcblxuICAgIG1zZyArPSB0aGlzLm1ldGhvZCArICcgJyArICh0aGlzLnJ1cmkudG9SYXcgPyB0aGlzLnJ1cmkudG9SYXcoKSA6IHRoaXMucnVyaSkgKyAnIFNJUC8yLjBcXHJcXG4nO1xuXG4gICAgZm9yIChoZWFkZXIgaW4gdGhpcy5oZWFkZXJzKSB7XG4gICAgICBsZW5ndGggPSB0aGlzLmhlYWRlcnNbaGVhZGVyXS5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgbXNnICs9IGhlYWRlciArICc6ICcgKyB0aGlzLmhlYWRlcnNbaGVhZGVyXVtpZHhdICsgJ1xcclxcbic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGVuZ3RoID0gdGhpcy5leHRyYUhlYWRlcnMubGVuZ3RoO1xuICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgbXNnICs9IHRoaXMuZXh0cmFIZWFkZXJzW2lkeF0udHJpbSgpICsnXFxyXFxuJztcbiAgICB9XG5cbiAgICBtc2cgKz0gZ2V0U3VwcG9ydGVkSGVhZGVyKHRoaXMpO1xuICAgIG1zZyArPSAnVXNlci1BZ2VudDogJyArIHRoaXMudWEuY29uZmlndXJhdGlvbi51c2VyQWdlbnRTdHJpbmcgKydcXHJcXG4nO1xuXG4gICAgaWYodGhpcy5ib2R5KSB7XG4gICAgICBsZW5ndGggPSBTSVAuVXRpbHMuc3RyX3V0ZjhfbGVuZ3RoKHRoaXMuYm9keSk7XG4gICAgICBtc2cgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAnICsgbGVuZ3RoICsgJ1xcclxcblxcclxcbic7XG4gICAgICBtc2cgKz0gdGhpcy5ib2R5O1xuICAgIH0gZWxzZSB7XG4gICAgICBtc2cgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAwXFxyXFxuXFxyXFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gbXNnO1xuICB9XG59O1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBmb3IgaW5jb21pbmcgU0lQIG1lc3NhZ2UuXG4gKi9cbkluY29taW5nTWVzc2FnZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZGF0YSA9IG51bGw7XG4gIHRoaXMuaGVhZGVycyA9IG51bGw7XG4gIHRoaXMubWV0aG9kID0gIG51bGw7XG4gIHRoaXMudmlhID0gbnVsbDtcbiAgdGhpcy52aWFfYnJhbmNoID0gbnVsbDtcbiAgdGhpcy5jYWxsX2lkID0gbnVsbDtcbiAgdGhpcy5jc2VxID0gbnVsbDtcbiAgdGhpcy5mcm9tID0gbnVsbDtcbiAgdGhpcy5mcm9tX3RhZyA9IG51bGw7XG4gIHRoaXMudG8gPSBudWxsO1xuICB0aGlzLnRvX3RhZyA9IG51bGw7XG4gIHRoaXMuYm9keSA9IG51bGw7XG59O1xuXG5JbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlID0ge1xuICAvKipcbiAgKiBJbnNlcnQgYSBoZWFkZXIgb2YgdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlIGludG8gdGhlIGxhc3QgcG9zaXRpb24gb2YgdGhlXG4gICogaGVhZGVyIGFycmF5LlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGhlYWRlciB2YWx1ZVxuICAqL1xuICBhZGRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGhlYWRlciA9IHsgcmF3OiB2YWx1ZSB9O1xuXG4gICAgbmFtZSA9IFNJUC5VdGlscy5oZWFkZXJpemUobmFtZSk7XG5cbiAgICBpZih0aGlzLmhlYWRlcnNbbmFtZV0pIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tuYW1lXS5wdXNoKGhlYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tuYW1lXSA9IFtoZWFkZXJdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyIG5hbWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUgc3BlY2lmaWVkIGhlYWRlciwgbnVsbCBpZiBoZWFkZXIgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGdldEhlYWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV07XG5cbiAgICBpZihoZWFkZXIpIHtcbiAgICAgIGlmKGhlYWRlclswXSkge1xuICAgICAgICByZXR1cm4gaGVhZGVyWzBdLnJhdztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBoZWFkZXIvcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge0FycmF5fSBBcnJheSB3aXRoIGFsbCB0aGUgaGVhZGVycyBvZiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gICAqL1xuICBnZXRIZWFkZXJzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGlkeCwgbGVuZ3RoLFxuICAgICAgaGVhZGVyID0gdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgICBpZighaGVhZGVyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGVuZ3RoID0gaGVhZGVyLmxlbmd0aDtcbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGhlYWRlcltpZHhdLnJhdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogVmVyaWZ5IHRoZSBleGlzdGVuY2Ugb2YgdGhlIGdpdmVuIGhlYWRlci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaGVhZGVyIHdpdGggZ2l2ZW4gbmFtZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgaGFzSGVhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuKHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSkgPyB0cnVlIDogZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBvbiB0aGUgZ2l2ZW4gaW5kZXguXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgKiBAcGFyYW0ge051bWJlcn0gW2lkeD0wXSBoZWFkZXIgaW5kZXhcbiAgKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH0gUGFyc2VkIGhlYWRlciBvYmplY3QsIHVuZGVmaW5lZCBpZiB0aGUgaGVhZGVyIGlzIG5vdCBwcmVzZW50IG9yIGluIGNhc2Ugb2YgYSBwYXJzaW5nIGVycm9yLlxuICAqL1xuICBwYXJzZUhlYWRlcjogZnVuY3Rpb24obmFtZSwgaWR4KSB7XG4gICAgdmFyIGhlYWRlciwgdmFsdWUsIHBhcnNlZDtcblxuICAgIG5hbWUgPSBTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpO1xuXG4gICAgaWR4ID0gaWR4IHx8IDA7XG5cbiAgICBpZighdGhpcy5oZWFkZXJzW25hbWVdKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ2hlYWRlciBcIicgKyBuYW1lICsgJ1wiIG5vdCBwcmVzZW50Jyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmKGlkeCA+PSB0aGlzLmhlYWRlcnNbbmFtZV0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ25vdCBzbyBtYW55IFwiJyArIG5hbWUgKyAnXCIgaGVhZGVycyBwcmVzZW50Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGVhZGVyID0gdGhpcy5oZWFkZXJzW25hbWVdW2lkeF07XG4gICAgdmFsdWUgPSBoZWFkZXIucmF3O1xuXG4gICAgaWYoaGVhZGVyLnBhcnNlZCkge1xuICAgICAgcmV0dXJuIGhlYWRlci5wYXJzZWQ7XG4gICAgfVxuXG4gICAgLy9zdWJzdGl0dXRlICctJyBieSAnXycgZm9yIGdyYW1tYXIgcnVsZSBtYXRjaGluZy5cbiAgICBwYXJzZWQgPSBTSVAuR3JhbW1hci5wYXJzZSh2YWx1ZSwgbmFtZS5yZXBsYWNlKC8tL2csICdfJykpO1xuXG4gICAgaWYocGFyc2VkID09PSAtMSkge1xuICAgICAgdGhpcy5oZWFkZXJzW25hbWVdLnNwbGljZShpZHgsIDEpOyAvL2RlbGV0ZSBmcm9tIGhlYWRlcnNcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2Vycm9yIHBhcnNpbmcgXCInICsgbmFtZSArICdcIiBoZWFkZXIgZmllbGQgd2l0aCB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIicpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIucGFyc2VkID0gcGFyc2VkO1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lc3NhZ2UgSGVhZGVyIGF0dHJpYnV0ZSBzZWxlY3Rvci4gQWxpYXMgb2YgcGFyc2VIZWFkZXIuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaWR4PTBdIGhlYWRlciBpbmRleFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH0gUGFyc2VkIGhlYWRlciBvYmplY3QsIHVuZGVmaW5lZCBpZiB0aGUgaGVhZGVyIGlzIG5vdCBwcmVzZW50IG9yIGluIGNhc2Ugb2YgYSBwYXJzaW5nIGVycm9yLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBtZXNzYWdlLnMoJ3ZpYScsMykucG9ydFxuICAgKi9cbiAgczogZnVuY3Rpb24obmFtZSwgaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VIZWFkZXIobmFtZSwgaWR4KTtcbiAgfSxcblxuICAvKipcbiAgKiBSZXBsYWNlIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyIGJ5IHRoZSB2YWx1ZS5cbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBoZWFkZXIgdmFsdWVcbiAgKi9cbiAgc2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBoZWFkZXIgPSB7IHJhdzogdmFsdWUgfTtcbiAgICB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV0gPSBbaGVhZGVyXTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBAYXVnbWVudHMgSW5jb21pbmdNZXNzYWdlXG4gKiBAY2xhc3MgQ2xhc3MgZm9yIGluY29taW5nIFNJUCByZXF1ZXN0LlxuICovXG5JbmNvbWluZ1JlcXVlc3QgPSBmdW5jdGlvbih1YSkge1xuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnNpcG1lc3NhZ2UnKTtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgdGhpcy5ydXJpID0gbnVsbDtcbiAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB0aGlzLnNlcnZlcl90cmFuc2FjdGlvbiA9IG51bGw7XG59O1xuSW5jb21pbmdSZXF1ZXN0LnByb3RvdHlwZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2UoKTtcblxuLyoqXG4qIFN0YXRlZnVsIHJlcGx5LlxuKiBAcGFyYW0ge051bWJlcn0gY29kZSBzdGF0dXMgY29kZVxuKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIHJlYXNvbiBwaHJhc2VcbiogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgZXh0cmEgaGVhZGVyc1xuKiBAcGFyYW0ge1N0cmluZ30gYm9keSBib2R5XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIG9uU3VjY2VzcyBjYWxsYmFja1xuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GYWlsdXJlXSBvbkZhaWx1cmUgY2FsbGJhY2tcbiovXG5JbmNvbWluZ1JlcXVlc3QucHJvdG90eXBlLnJlcGx5ID0gZnVuY3Rpb24oY29kZSwgcmVhc29uLCBleHRyYUhlYWRlcnMsIGJvZHksIG9uU3VjY2Vzcywgb25GYWlsdXJlKSB7XG4gIHZhciByciwgdmlhcywgbGVuZ3RoLCBpZHgsIHJlc3BvbnNlLFxuICAgIHRvID0gdGhpcy5nZXRIZWFkZXIoJ1RvJyksXG4gICAgciA9IDAsXG4gICAgdiA9IDA7XG5cbiAgcmVzcG9uc2UgPSBTSVAuVXRpbHMuYnVpbGRTdGF0dXNMaW5lKGNvZGUsIHJlYXNvbik7XG4gIGV4dHJhSGVhZGVycyA9IChleHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgaWYodGhpcy5tZXRob2QgPT09IFNJUC5DLklOVklURSAmJiBjb2RlID4gMTAwICYmIGNvZGUgPD0gMjAwKSB7XG4gICAgcnIgPSB0aGlzLmdldEhlYWRlcnMoJ3JlY29yZC1yb3V0ZScpO1xuICAgIGxlbmd0aCA9IHJyLmxlbmd0aDtcblxuICAgIGZvcihyOyByIDwgbGVuZ3RoOyByKyspIHtcbiAgICAgIHJlc3BvbnNlICs9ICdSZWNvcmQtUm91dGU6ICcgKyBycltyXSArICdcXHJcXG4nO1xuICAgIH1cbiAgfVxuXG4gIHZpYXMgPSB0aGlzLmdldEhlYWRlcnMoJ3ZpYScpO1xuICBsZW5ndGggPSB2aWFzLmxlbmd0aDtcblxuICBmb3IodjsgdiA8IGxlbmd0aDsgdisrKSB7XG4gICAgcmVzcG9uc2UgKz0gJ1ZpYTogJyArIHZpYXNbdl0gKyAnXFxyXFxuJztcbiAgfVxuXG4gIGlmKCF0aGlzLnRvX3RhZyAmJiBjb2RlID4gMTAwKSB7XG4gICAgdG8gKz0gJzt0YWc9JyArIFNJUC5VdGlscy5uZXdUYWcoKTtcbiAgfSBlbHNlIGlmKHRoaXMudG9fdGFnICYmICF0aGlzLnMoJ3RvJykuaGFzUGFyYW0oJ3RhZycpKSB7XG4gICAgdG8gKz0gJzt0YWc9JyArIHRoaXMudG9fdGFnO1xuICB9XG5cbiAgcmVzcG9uc2UgKz0gJ1RvOiAnICsgdG8gKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0Zyb206ICcgKyB0aGlzLmdldEhlYWRlcignRnJvbScpICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdDYWxsLUlEOiAnICsgdGhpcy5jYWxsX2lkICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdDU2VxOiAnICsgdGhpcy5jc2VxICsgJyAnICsgdGhpcy5tZXRob2QgKyAnXFxyXFxuJztcblxuICBsZW5ndGggPSBleHRyYUhlYWRlcnMubGVuZ3RoO1xuICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICByZXNwb25zZSArPSBleHRyYUhlYWRlcnNbaWR4XS50cmltKCkgKydcXHJcXG4nO1xuICB9XG5cbiAgcmVzcG9uc2UgKz0gZ2V0U3VwcG9ydGVkSGVhZGVyKHRoaXMpO1xuICByZXNwb25zZSArPSAnVXNlci1BZ2VudDogJyArIHRoaXMudWEuY29uZmlndXJhdGlvbi51c2VyQWdlbnRTdHJpbmcgKydcXHJcXG4nO1xuXG4gIGlmKGJvZHkpIHtcbiAgICBsZW5ndGggPSBTSVAuVXRpbHMuc3RyX3V0ZjhfbGVuZ3RoKGJvZHkpO1xuICAgIHJlc3BvbnNlICs9ICdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL3NkcFxcclxcbic7XG4gICAgcmVzcG9uc2UgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAnICsgbGVuZ3RoICsgJ1xcclxcblxcclxcbic7XG4gICAgcmVzcG9uc2UgKz0gYm9keTtcbiAgfSBlbHNlIHtcbiAgICByZXNwb25zZSArPSAnQ29udGVudC1MZW5ndGg6ICcgKyAwICsgJ1xcclxcblxcclxcbic7XG4gIH1cblxuICB0aGlzLnNlcnZlcl90cmFuc2FjdGlvbi5yZWNlaXZlUmVzcG9uc2UoY29kZSwgcmVzcG9uc2UpLnRoZW4ob25TdWNjZXNzLCBvbkZhaWx1cmUpO1xuXG4gIHJldHVybiByZXNwb25zZTtcbn07XG5cbi8qKlxuKiBTdGF0ZWxlc3MgcmVwbHkuXG4qIEBwYXJhbSB7TnVtYmVyfSBjb2RlIHN0YXR1cyBjb2RlXG4qIEBwYXJhbSB7U3RyaW5nfSByZWFzb24gcmVhc29uIHBocmFzZVxuKi9cbkluY29taW5nUmVxdWVzdC5wcm90b3R5cGUucmVwbHlfc2wgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgdmFyIHRvLCByZXNwb25zZSxcbiAgICB2ID0gMCxcbiAgICB2aWFzID0gdGhpcy5nZXRIZWFkZXJzKCd2aWEnKSxcbiAgICBsZW5ndGggPSB2aWFzLmxlbmd0aDtcblxuICByZXNwb25zZSA9IFNJUC5VdGlscy5idWlsZFN0YXR1c0xpbmUoY29kZSwgcmVhc29uKTtcblxuICBmb3IodjsgdiA8IGxlbmd0aDsgdisrKSB7XG4gICAgcmVzcG9uc2UgKz0gJ1ZpYTogJyArIHZpYXNbdl0gKyAnXFxyXFxuJztcbiAgfVxuXG4gIHRvID0gdGhpcy5nZXRIZWFkZXIoJ1RvJyk7XG5cbiAgaWYoIXRoaXMudG9fdGFnICYmIGNvZGUgPiAxMDApIHtcbiAgICB0byArPSAnO3RhZz0nICsgU0lQLlV0aWxzLm5ld1RhZygpO1xuICB9IGVsc2UgaWYodGhpcy50b190YWcgJiYgIXRoaXMucygndG8nKS5oYXNQYXJhbSgndGFnJykpIHtcbiAgICB0byArPSAnO3RhZz0nICsgdGhpcy50b190YWc7XG4gIH1cblxuICByZXNwb25zZSArPSAnVG86ICcgKyB0byArICdcXHJcXG4nO1xuICByZXNwb25zZSArPSAnRnJvbTogJyArIHRoaXMuZ2V0SGVhZGVyKCdGcm9tJykgKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0NhbGwtSUQ6ICcgKyB0aGlzLmNhbGxfaWQgKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0NTZXE6ICcgKyB0aGlzLmNzZXEgKyAnICcgKyB0aGlzLm1ldGhvZCArICdcXHJcXG4nO1xuICByZXNwb25zZSArPSAnVXNlci1BZ2VudDogJyArIHRoaXMudWEuY29uZmlndXJhdGlvbi51c2VyQWdlbnRTdHJpbmcgKydcXHJcXG4nO1xuICByZXNwb25zZSArPSAnQ29udGVudC1MZW5ndGg6ICcgKyAwICsgJ1xcclxcblxcclxcbic7XG5cbiAgdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSk7XG59O1xuXG5cbi8qKlxuICogQGF1Z21lbnRzIEluY29taW5nTWVzc2FnZVxuICogQGNsYXNzIENsYXNzIGZvciBpbmNvbWluZyBTSVAgcmVzcG9uc2UuXG4gKi9cbkluY29taW5nUmVzcG9uc2UgPSBmdW5jdGlvbih1YSkge1xuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnNpcG1lc3NhZ2UnKTtcbiAgdGhpcy5oZWFkZXJzID0ge307XG4gIHRoaXMuc3RhdHVzX2NvZGUgPSBudWxsO1xuICB0aGlzLnJlYXNvbl9waHJhc2UgPSBudWxsO1xufTtcbkluY29taW5nUmVzcG9uc2UucHJvdG90eXBlID0gbmV3IEluY29taW5nTWVzc2FnZSgpO1xuXG5TSVAuT3V0Z29pbmdSZXF1ZXN0ID0gT3V0Z29pbmdSZXF1ZXN0O1xuU0lQLkluY29taW5nUmVxdWVzdCA9IEluY29taW5nUmVxdWVzdDtcblNJUC5JbmNvbWluZ1Jlc3BvbnNlID0gSW5jb21pbmdSZXNwb25zZTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1NJUE1lc3NhZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBVUklcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIFNJUCBVUkkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtzY2hlbWVdXG4gKiBAcGFyYW0ge1N0cmluZ30gW3VzZXJdXG4gKiBAcGFyYW0ge1N0cmluZ30gaG9zdFxuICogQHBhcmFtIHtTdHJpbmd9IFtwb3J0XVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgVVJJO1xuXG5VUkkgPSBmdW5jdGlvbihzY2hlbWUsIHVzZXIsIGhvc3QsIHBvcnQsIHBhcmFtZXRlcnMsIGhlYWRlcnMpIHtcbiAgdmFyIHBhcmFtLCBoZWFkZXIsIHJhdywgbm9ybWFsO1xuXG4gIC8vIENoZWNrc1xuICBpZighaG9zdCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3Npbmcgb3IgaW52YWxpZCBcImhvc3RcIiBwYXJhbWV0ZXInKTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgcGFyYW1ldGVyc1xuICBzY2hlbWUgPSBzY2hlbWUgfHwgU0lQLkMuU0lQO1xuICB0aGlzLnBhcmFtZXRlcnMgPSB7fTtcbiAgdGhpcy5oZWFkZXJzID0ge307XG5cbiAgZm9yIChwYXJhbSBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5zZXRQYXJhbShwYXJhbSwgcGFyYW1ldGVyc1twYXJhbV0pO1xuICB9XG5cbiAgZm9yIChoZWFkZXIgaW4gaGVhZGVycykge1xuICAgIHRoaXMuc2V0SGVhZGVyKGhlYWRlciwgaGVhZGVyc1toZWFkZXJdKTtcbiAgfVxuXG4gIC8vIFJhdyBVUklcbiAgcmF3ID0ge1xuICAgIHNjaGVtZTogc2NoZW1lLFxuICAgIHVzZXI6IHVzZXIsXG4gICAgaG9zdDogaG9zdCxcbiAgICBwb3J0OiBwb3J0XG4gIH07XG5cbiAgLy8gTm9ybWFsaXplZCBVUklcbiAgbm9ybWFsID0ge1xuICAgIHNjaGVtZTogc2NoZW1lLnRvTG93ZXJDYXNlKCksXG4gICAgdXNlcjogdXNlcixcbiAgICBob3N0OiBob3N0LnRvTG93ZXJDYXNlKCksXG4gICAgcG9ydDogcG9ydFxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBfbm9ybWFsOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsOyB9XG4gICAgfSxcblxuICAgIF9yYXc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiByYXc7IH1cbiAgICB9LFxuXG4gICAgc2NoZW1lOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsLnNjaGVtZTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmF3LnNjaGVtZSA9IHZhbHVlO1xuICAgICAgICBub3JtYWwuc2NoZW1lID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXNlcjoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbC51c2VyOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBub3JtYWwudXNlciA9IHJhdy51c2VyID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhvc3Q6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWwuaG9zdDsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmF3Lmhvc3QgPSB2YWx1ZTtcbiAgICAgICAgbm9ybWFsLmhvc3QgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhb3I6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWwudXNlciArICdAJyArIG5vcm1hbC5ob3N0OyB9XG4gICAgfSxcblxuICAgIHBvcnQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWwucG9ydDsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgbm9ybWFsLnBvcnQgPSByYXcucG9ydCA9IHZhbHVlID09PSAwID8gdmFsdWUgOiAocGFyc2VJbnQodmFsdWUsMTApIHx8IG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5VUkkucHJvdG90eXBlID0ge1xuICBzZXRQYXJhbTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmKGtleSkge1xuICAgICAgdGhpcy5wYXJhbWV0ZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9ICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSA/IG51bGwgOiB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9LFxuXG4gIGdldFBhcmFtOiBmdW5jdGlvbihrZXkpIHtcbiAgICBpZihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgfSxcblxuICBoYXNQYXJhbTogZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYoa2V5KSB7XG4gICAgICByZXR1cm4gKHRoaXMucGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShrZXkudG9Mb3dlckNhc2UoKSkgJiYgdHJ1ZSkgfHwgZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIGRlbGV0ZVBhcmFtOiBmdW5jdGlvbihwYXJhbWV0ZXIpIHtcbiAgICB2YXIgdmFsdWU7XG4gICAgcGFyYW1ldGVyID0gcGFyYW1ldGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRoaXMucGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdO1xuICAgICAgZGVsZXRlIHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBjbGVhclBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge307XG4gIH0sXG5cbiAgc2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSA9ICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgfSxcblxuICBnZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldO1xuICAgIH1cbiAgfSxcblxuICBoYXNIZWFkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZihuYW1lKSB7XG4gICAgICByZXR1cm4gKHRoaXMuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpKSAmJiB0cnVlKSB8fCBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgZGVsZXRlSGVhZGVyOiBmdW5jdGlvbihoZWFkZXIpIHtcbiAgICB2YXIgdmFsdWU7XG4gICAgaGVhZGVyID0gU0lQLlV0aWxzLmhlYWRlcml6ZShoZWFkZXIpO1xuICAgIGlmKHRoaXMuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoZWFkZXIpKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuaGVhZGVyc1toZWFkZXJdO1xuICAgICAgZGVsZXRlIHRoaXMuaGVhZGVyc1toZWFkZXJdO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBjbGVhckhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFVSSShcbiAgICAgIHRoaXMuX3Jhdy5zY2hlbWUsXG4gICAgICB0aGlzLl9yYXcudXNlcixcbiAgICAgIHRoaXMuX3Jhdy5ob3N0LFxuICAgICAgdGhpcy5fcmF3LnBvcnQsXG4gICAgICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGFyYW1ldGVycykpLFxuICAgICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmhlYWRlcnMpKSk7XG4gIH0sXG5cbiAgdG9SYXc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90b1N0cmluZyh0aGlzLl9yYXcpO1xuICB9LFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9TdHJpbmcodGhpcy5fbm9ybWFsKTtcbiAgfSxcblxuICBfdG9TdHJpbmc6IGZ1bmN0aW9uKHVyaSkge1xuICAgIHZhciBoZWFkZXIsIHBhcmFtZXRlciwgaWR4LCB1cmlTdHJpbmcsIGhlYWRlcnMgPSBbXTtcblxuICAgIHVyaVN0cmluZyAgPSB1cmkuc2NoZW1lICsgJzonO1xuICAgIC8vIGFkZCBzbGFzaGVzIGlmIGl0J3Mgbm90IGEgc2lwKHMpIFVSSVxuICAgIGlmICghdXJpLnNjaGVtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKFwiXnNpcHM/JFwiKSkge1xuICAgICAgdXJpU3RyaW5nICs9IFwiLy9cIjtcbiAgICB9XG4gICAgaWYgKHVyaS51c2VyKSB7XG4gICAgICB1cmlTdHJpbmcgKz0gU0lQLlV0aWxzLmVzY2FwZVVzZXIodXJpLnVzZXIpICsgJ0AnO1xuICAgIH1cbiAgICB1cmlTdHJpbmcgKz0gdXJpLmhvc3Q7XG4gICAgaWYgKHVyaS5wb3J0IHx8IHVyaS5wb3J0ID09PSAwKSB7XG4gICAgICB1cmlTdHJpbmcgKz0gJzonICsgdXJpLnBvcnQ7XG4gICAgfVxuXG4gICAgZm9yIChwYXJhbWV0ZXIgaW4gdGhpcy5wYXJhbWV0ZXJzKSB7XG4gICAgICB1cmlTdHJpbmcgKz0gJzsnICsgcGFyYW1ldGVyO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl0gIT09IG51bGwpIHtcbiAgICAgICAgdXJpU3RyaW5nICs9ICc9JysgdGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKGhlYWRlciBpbiB0aGlzLmhlYWRlcnMpIHtcbiAgICAgIGZvcihpZHggaW4gdGhpcy5oZWFkZXJzW2hlYWRlcl0pIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGhlYWRlciArICc9JyArIHRoaXMuaGVhZGVyc1toZWFkZXJdW2lkeF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVyaVN0cmluZyArPSAnPycgKyBoZWFkZXJzLmpvaW4oJyYnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJpU3RyaW5nO1xuICB9XG59O1xuXG5cbi8qKlxuICAqIFBhcnNlIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgYSBTSVAuVVJJIGluc3RhbmNlIG9yIHVuZGVmaW5lZCBpZlxuICAqIGl0IGlzIGFuIGludmFsaWQgVVJJLlxuICAqIEBwdWJsaWNcbiAgKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gICovXG5VUkkucGFyc2UgPSBmdW5jdGlvbih1cmkpIHtcbiAgdXJpID0gU0lQLkdyYW1tYXIucGFyc2UodXJpLCdTSVBfVVJJJyk7XG5cbiAgaWYgKHVyaSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdXJpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cblNJUC5VUkkgPSBVUkk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9VUkkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBOYW1lQWRkckhlYWRlclxuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGEgTmFtZSBBZGRyZXNzIFNJUCBoZWFkZXIuXG4gKlxuICogQHBhcmFtIHtTSVAuVVJJfSB1cmlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZGlzcGxheU5hbWVdXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBOYW1lQWRkckhlYWRlcjtcblxuTmFtZUFkZHJIZWFkZXIgPSBmdW5jdGlvbih1cmksIGRpc3BsYXlOYW1lLCBwYXJhbWV0ZXJzKSB7XG4gIHZhciBwYXJhbTtcblxuICAvLyBDaGVja3NcbiAgaWYoIXVyaSB8fCAhKHVyaSBpbnN0YW5jZW9mIFNJUC5VUkkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBvciBpbnZhbGlkIFwidXJpXCIgcGFyYW1ldGVyJyk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHBhcmFtZXRlcnNcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMucGFyYW1ldGVycyA9IHt9O1xuXG4gIGZvciAocGFyYW0gaW4gcGFyYW1ldGVycykge1xuICAgIHRoaXMuc2V0UGFyYW0ocGFyYW0sIHBhcmFtZXRlcnNbcGFyYW1dKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBmcmllbmRseU5hbWU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRpc3BsYXlOYW1lIHx8IHVyaS5hb3I7IH1cbiAgICB9LFxuXG4gICAgZGlzcGxheU5hbWU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBkaXNwbGF5TmFtZTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgZGlzcGxheU5hbWUgPSAodmFsdWUgPT09IDApID8gJzAnIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5OYW1lQWRkckhlYWRlci5wcm90b3R5cGUgPSB7XG4gIHNldFBhcmFtOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmKGtleSkge1xuICAgICAgdGhpcy5wYXJhbWV0ZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9ICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSA/IG51bGwgOiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgfSxcbiAgZ2V0UGFyYW06IFNJUC5VUkkucHJvdG90eXBlLmdldFBhcmFtLFxuICBoYXNQYXJhbTogU0lQLlVSSS5wcm90b3R5cGUuaGFzUGFyYW0sXG4gIGRlbGV0ZVBhcmFtOiBTSVAuVVJJLnByb3RvdHlwZS5kZWxldGVQYXJhbSxcbiAgY2xlYXJQYXJhbXM6IFNJUC5VUkkucHJvdG90eXBlLmNsZWFyUGFyYW1zLFxuXG4gIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE5hbWVBZGRySGVhZGVyKFxuICAgICAgdGhpcy51cmkuY2xvbmUoKSxcbiAgICAgIHRoaXMuZGlzcGxheU5hbWUsXG4gICAgICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGFyYW1ldGVycykpKTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvZHksIHBhcmFtZXRlcjtcblxuICAgIGJvZHkgID0gKHRoaXMuZGlzcGxheU5hbWUgfHwgdGhpcy5kaXNwbGF5TmFtZSA9PT0gMCkgPyAnXCInICsgdGhpcy5kaXNwbGF5TmFtZSArICdcIiAnIDogJyc7XG4gICAgYm9keSArPSAnPCcgKyB0aGlzLnVyaS50b1N0cmluZygpICsgJz4nO1xuXG4gICAgZm9yIChwYXJhbWV0ZXIgaW4gdGhpcy5wYXJhbWV0ZXJzKSB7XG4gICAgICBib2R5ICs9ICc7JyArIHBhcmFtZXRlcjtcblxuICAgICAgaWYgKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdICE9PSBudWxsKSB7XG4gICAgICAgIGJvZHkgKz0gJz0nKyB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYm9keTtcbiAgfVxufTtcblxuXG4vKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIGEgU0lQLk5hbWVBZGRySGVhZGVyIGluc3RhbmNlIG9yIHVuZGVmaW5lZCBpZlxuICAqIGl0IGlzIGFuIGludmFsaWQgTmFtZUFkZHJIZWFkZXIuXG4gICogQHB1YmxpY1xuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lX2FkZHJfaGVhZGVyXG4gICovXG5OYW1lQWRkckhlYWRlci5wYXJzZSA9IGZ1bmN0aW9uKG5hbWVfYWRkcl9oZWFkZXIpIHtcbiAgbmFtZV9hZGRyX2hlYWRlciA9IFNJUC5HcmFtbWFyLnBhcnNlKG5hbWVfYWRkcl9oZWFkZXIsJ05hbWVfQWRkcl9IZWFkZXInKTtcblxuICBpZiAobmFtZV9hZGRyX2hlYWRlciAhPT0gLTEpIHtcbiAgICByZXR1cm4gbmFtZV9hZGRyX2hlYWRlcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG5TSVAuTmFtZUFkZHJIZWFkZXIgPSBOYW1lQWRkckhlYWRlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL05hbWVBZGRySGVhZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgVHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBTSVAgVHJhbnNhY3Rpb25zIG1vZHVsZS5cbiAqIEBhdWdtZW50cyBTSVBcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXJcbiAgQyA9IHtcbiAgICAvLyBUcmFuc2FjdGlvbiBzdGF0ZXNcbiAgICBTVEFUVVNfVFJZSU5HOiAgICAgMSxcbiAgICBTVEFUVVNfUFJPQ0VFRElORzogMixcbiAgICBTVEFUVVNfQ0FMTElORzogICAgMyxcbiAgICBTVEFUVVNfQUNDRVBURUQ6ICAgNCxcbiAgICBTVEFUVVNfQ09NUExFVEVEOiAgNSxcbiAgICBTVEFUVVNfVEVSTUlOQVRFRDogNixcbiAgICBTVEFUVVNfQ09ORklSTUVEOiAgNyxcblxuICAgIC8vIFRyYW5zYWN0aW9uIHR5cGVzXG4gICAgTk9OX0lOVklURV9DTElFTlQ6ICduaWN0JyxcbiAgICBOT05fSU5WSVRFX1NFUlZFUjogJ25pc3QnLFxuICAgIElOVklURV9DTElFTlQ6ICdpY3QnLFxuICAgIElOVklURV9TRVJWRVI6ICdpc3QnXG4gIH07XG5cbmZ1bmN0aW9uIGJ1aWxkVmlhSGVhZGVyIChyZXF1ZXN0X3NlbmRlciwgdHJhbnNwb3J0LCBpZCkge1xuICB2YXIgdmlhO1xuICB2aWEgPSAnU0lQLzIuMC8nICsgKHJlcXVlc3Rfc2VuZGVyLnVhLmNvbmZpZ3VyYXRpb24uaGFja1ZpYVRjcCA/ICdUQ1AnIDogdHJhbnNwb3J0LnNlcnZlci5zY2hlbWUpO1xuICB2aWEgKz0gJyAnICsgcmVxdWVzdF9zZW5kZXIudWEuY29uZmlndXJhdGlvbi52aWFIb3N0ICsgJzticmFuY2g9JyArIGlkO1xuICBpZiAocmVxdWVzdF9zZW5kZXIudWEuY29uZmlndXJhdGlvbi5mb3JjZVJwb3J0KSB7XG4gICAgdmlhICs9ICc7cnBvcnQnO1xuICB9XG4gIHJldHVybiB2aWE7XG59XG5cbi8qKlxuKiBAYXVnbWVudHMgU0lQLlRyYW5zYWN0aW9uc1xuKiBAY2xhc3MgTm9uIEludml0ZSBDbGllbnQgVHJhbnNhY3Rpb25cbiogQHBhcmFtIHtTSVAuUmVxdWVzdFNlbmRlcn0gcmVxdWVzdF9zZW5kZXJcbiogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fSByZXF1ZXN0XG4qIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0XG4qL1xudmFyIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocmVxdWVzdF9zZW5kZXIsIHJlcXVlc3QsIHRyYW5zcG9ydCkge1xuICB2YXIgdmlhO1xuXG4gIHRoaXMudHlwZSA9IEMuTk9OX0lOVklURV9DTElFTlQ7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLmlkID0gJ3o5aEc0YksnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyID0gcmVxdWVzdF9zZW5kZXI7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgdGhpcy5sb2dnZXIgPSByZXF1ZXN0X3NlbmRlci51YS5nZXRMb2dnZXIoJ3NpcC50cmFuc2FjdGlvbi5uaWN0JywgdGhpcy5pZCk7XG5cbiAgdmlhID0gYnVpbGRWaWFIZWFkZXIocmVxdWVzdF9zZW5kZXIsIHRyYW5zcG9ydCwgdGhpcy5pZCk7XG4gIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoJ3ZpYScsIHZpYSk7XG5cbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5uZXdUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZWQnKTtcbn07XG5cbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ciA9IHRoaXM7XG5cbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVFJZSU5HKTtcbiAgdGhpcy5GID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0YuYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfRik7XG5cbiAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5yZXF1ZXN0KSkge1xuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG59O1xuXG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ3RyYW5zcG9ydCBlcnJvciBvY2N1cnJlZCwgZGVsZXRpbmcgbm9uLUlOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkYpO1xuICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkspO1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIub25UcmFuc3BvcnRFcnJvcigpO1xufTtcblxuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0YgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCdUaW1lciBGIGV4cGlyZWQgZm9yIG5vbi1JTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLm9uUmVxdWVzdFRpbWVvdXQoKTtcbn07XG5cbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9LID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5cbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICB2YXJcbiAgICB0ciA9IHRoaXMsXG4gICAgc3RhdHVzX2NvZGUgPSByZXNwb25zZS5zdGF0dXNfY29kZTtcblxuICBpZihzdGF0dXNfY29kZSA8IDIwMCkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1RSWUlORzpcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfUFJPQ0VFRElORyk7XG4gICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1RSWUlORzpcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQ09NUExFVEVEKTtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5GKTtcblxuICAgICAgICBpZihzdGF0dXNfY29kZSA9PT0gNDA4KSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5LID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0suYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfSyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlNUQVRVU19DT01QTEVURUQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8qKlxuKiBAYXVnbWVudHMgU0lQLlRyYW5zYWN0aW9uc1xuKiBAY2xhc3MgSW52aXRlIENsaWVudCBUcmFuc2FjdGlvblxuKiBAcGFyYW0ge1NJUC5SZXF1ZXN0U2VuZGVyfSByZXF1ZXN0X3NlbmRlclxuKiBAcGFyYW0ge1NJUC5PdXRnb2luZ1JlcXVlc3R9IHJlcXVlc3RcbiogQHBhcmFtIHtTSVAuVHJhbnNwb3J0fSB0cmFuc3BvcnRcbiovXG52YXIgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24gPSBmdW5jdGlvbihyZXF1ZXN0X3NlbmRlciwgcmVxdWVzdCwgdHJhbnNwb3J0KSB7XG4gIHZhciB2aWEsXG4gICAgdHIgPSB0aGlzO1xuXG4gIHRoaXMudHlwZSA9IEMuSU5WSVRFX0NMSUVOVDtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMuaWQgPSAnejloRzRiSycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIgPSByZXF1ZXN0X3NlbmRlcjtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcblxuICB0aGlzLmxvZ2dlciA9IHJlcXVlc3Rfc2VuZGVyLnVhLmdldExvZ2dlcignc2lwLnRyYW5zYWN0aW9uLmljdCcsIHRoaXMuaWQpO1xuXG4gIHZpYSA9IGJ1aWxkVmlhSGVhZGVyKHJlcXVlc3Rfc2VuZGVyLCB0cmFuc3BvcnQsIHRoaXMuaWQpO1xuICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKCd2aWEnLCB2aWEpO1xuXG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEubmV3VHJhbnNhY3Rpb24odGhpcyk7XG5cbiAgLy8gQWRkIHRoZSBjYW5jZWwgcHJvcGVydHkgdG8gdGhlIHJlcXVlc3QuXG4gIC8vV2lsbCBiZSBjYWxsZWQgZnJvbSB0aGUgcmVxdWVzdCBpbnN0YW5jZSwgbm90IHRoZSB0cmFuc2FjdGlvbiBpdHNlbGYuXG4gIHRoaXMucmVxdWVzdC5jYW5jZWwgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICB0ci5jYW5jZWxfcmVxdWVzdCh0ciwgcmVhc29uKTtcbiAgfTtcbn07XG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZWQnKTtcbn07XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ciA9IHRoaXM7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX0NBTExJTkcpO1xuICB0aGlzLkIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfQi5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9CKTtcblxuICBpZighdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLnJlcXVlc3QpKSB7XG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cbn07XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygndHJhbnNwb3J0IGVycm9yIG9jY3VycmVkLCBkZWxldGluZyBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5CKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5EKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5NKTtcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuXG4gIGlmICh0aGlzLnN0YXRlICE9PSBDLlNUQVRVU19BQ0NFUFRFRCkge1xuICAgIHRoaXMucmVxdWVzdF9zZW5kZXIub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG59O1xuXG4vLyBSRkMgNjAyNiA3LjJcbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9NID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgTSBleHBpcmVkIGZvciBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcblxuICBpZih0aGlzLnN0YXRlID09PSBDLlNUQVRVU19BQ0NFUFRFRCkge1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuQik7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gICAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gIH1cbn07XG5cbi8vIFJGQyAzMjYxIDE3LjEuMVxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCdUaW1lciBCIGV4cGlyZWQgZm9yIElOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuICBpZih0aGlzLnN0YXRlID09PSBDLlNUQVRVU19DQUxMSU5HKSB7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gICAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5vblJlcXVlc3RUaW1lb3V0KCk7XG4gIH1cbn07XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9EID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgRCBleHBpcmVkIGZvciBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5CKTtcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xufTtcblxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnNlbmRBQ0sgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICB2YXIgdHIgPSB0aGlzO1xuXG4gIHRoaXMuYWNrID0gJ0FDSyAnICsgdGhpcy5yZXF1ZXN0LnJ1cmkgKyAnIFNJUC8yLjBcXHJcXG4nO1xuICB0aGlzLmFjayArPSAnVmlhOiAnICsgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1ZpYSddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcblxuICBpZih0aGlzLnJlcXVlc3QuaGVhZGVyc1snUm91dGUnXSkge1xuICAgIHRoaXMuYWNrICs9ICdSb3V0ZTogJyArIHRoaXMucmVxdWVzdC5oZWFkZXJzWydSb3V0ZSddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgfVxuXG4gIHRoaXMuYWNrICs9ICdUbzogJyArIHJlc3BvbnNlLmdldEhlYWRlcigndG8nKSArICdcXHJcXG4nO1xuICB0aGlzLmFjayArPSAnRnJvbTogJyArIHRoaXMucmVxdWVzdC5oZWFkZXJzWydGcm9tJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB0aGlzLmFjayArPSAnQ2FsbC1JRDogJyArIHRoaXMucmVxdWVzdC5oZWFkZXJzWydDYWxsLUlEJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB0aGlzLmFjayArPSAnQ29udGVudC1MZW5ndGg6IDBcXHJcXG4nO1xuICB0aGlzLmFjayArPSAnQ1NlcTogJyArIHRoaXMucmVxdWVzdC5oZWFkZXJzWydDU2VxJ10udG9TdHJpbmcoKS5zcGxpdCgnICcpWzBdO1xuICB0aGlzLmFjayArPSAnIEFDS1xcclxcblxcclxcbic7XG5cbiAgdGhpcy5EID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0QuYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfRCk7XG5cbiAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLmFjayk7XG59O1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuY2FuY2VsX3JlcXVlc3QgPSBmdW5jdGlvbih0ciwgcmVhc29uKSB7XG4gIHZhciByZXF1ZXN0ID0gdHIucmVxdWVzdDtcblxuICB0aGlzLmNhbmNlbCA9IFNJUC5DLkNBTkNFTCArICcgJyArIHJlcXVlc3QucnVyaSArICcgU0lQLzIuMFxcclxcbic7XG4gIHRoaXMuY2FuY2VsICs9ICdWaWE6ICcgKyByZXF1ZXN0LmhlYWRlcnNbJ1ZpYSddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcblxuICBpZih0aGlzLnJlcXVlc3QuaGVhZGVyc1snUm91dGUnXSkge1xuICAgIHRoaXMuY2FuY2VsICs9ICdSb3V0ZTogJyArIHJlcXVlc3QuaGVhZGVyc1snUm91dGUnXS50b1N0cmluZygpICsgJ1xcclxcbic7XG4gIH1cblxuICB0aGlzLmNhbmNlbCArPSAnVG86ICcgKyByZXF1ZXN0LmhlYWRlcnNbJ1RvJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB0aGlzLmNhbmNlbCArPSAnRnJvbTogJyArIHJlcXVlc3QuaGVhZGVyc1snRnJvbSddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgdGhpcy5jYW5jZWwgKz0gJ0NhbGwtSUQ6ICcgKyByZXF1ZXN0LmhlYWRlcnNbJ0NhbGwtSUQnXS50b1N0cmluZygpICsgJ1xcclxcbic7XG4gIHRoaXMuY2FuY2VsICs9ICdDU2VxOiAnICsgcmVxdWVzdC5oZWFkZXJzWydDU2VxJ10udG9TdHJpbmcoKS5zcGxpdCgnICcpWzBdICtcbiAgJyBDQU5DRUxcXHJcXG4nO1xuXG4gIGlmKHJlYXNvbikge1xuICAgIHRoaXMuY2FuY2VsICs9ICdSZWFzb246ICcgKyByZWFzb24gKyAnXFxyXFxuJztcbiAgfVxuXG4gIHRoaXMuY2FuY2VsICs9ICdDb250ZW50LUxlbmd0aDogMFxcclxcblxcclxcbic7XG5cbiAgLy8gU2VuZCBvbmx5IGlmIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UgKD4xMDApIGhhcyBiZWVuIHJlY2VpdmVkLlxuICBpZih0aGlzLnN0YXRlID09PSBDLlNUQVRVU19QUk9DRUVESU5HKSB7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLmNhbmNlbCk7XG4gIH1cbn07XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICB2YXJcbiAgdHIgPSB0aGlzLFxuICBzdGF0dXNfY29kZSA9IHJlc3BvbnNlLnN0YXR1c19jb2RlO1xuXG4gIGlmKHN0YXR1c19jb2RlID49IDEwMCAmJiBzdGF0dXNfY29kZSA8PSAxOTkpIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19DQUxMSU5HOlxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19QUk9DRUVESU5HKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBpZih0aGlzLmNhbmNlbCkge1xuICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5jYW5jZWwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIGlmKHN0YXR1c19jb2RlID49IDIwMCAmJiBzdGF0dXNfY29kZSA8PSAyOTkpIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19DQUxMSU5HOlxuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19BQ0NFUFRFRCk7XG4gICAgICAgIHRoaXMuTSA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9NLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX00pO1xuICAgICAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlNUQVRVU19BQ0NFUFRFRDpcbiAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSBpZihzdGF0dXNfY29kZSA+PSAzMDAgJiYgc3RhdHVzX2NvZGUgPD0gNjk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ0FMTElORzpcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQ09NUExFVEVEKTtcbiAgICAgICAgdGhpcy5zZW5kQUNLKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ09NUExFVEVEOlxuICAgICAgICB0aGlzLnNlbmRBQ0socmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQLlRyYW5zYWN0aW9uc1xuICogQGNsYXNzIEFDSyBDbGllbnQgVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U0lQLlJlcXVlc3RTZW5kZXJ9IHJlcXVlc3Rfc2VuZGVyXG4gKiBAcGFyYW0ge1NJUC5PdXRnb2luZ1JlcXVlc3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0XG4gKi9cbnZhciBBY2tDbGllbnRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHJlcXVlc3Rfc2VuZGVyLCByZXF1ZXN0LCB0cmFuc3BvcnQpIHtcbiAgdmFyIHZpYTtcblxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdGhpcy5pZCA9ICd6OWhHNGJLJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlciA9IHJlcXVlc3Rfc2VuZGVyO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuXG4gIHRoaXMubG9nZ2VyID0gcmVxdWVzdF9zZW5kZXIudWEuZ2V0TG9nZ2VyKCdzaXAudHJhbnNhY3Rpb24ubmljdCcsIHRoaXMuaWQpO1xuXG4gIHZpYSA9IGJ1aWxkVmlhSGVhZGVyKHJlcXVlc3Rfc2VuZGVyLCB0cmFuc3BvcnQsIHRoaXMuaWQpO1xuICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKCd2aWEnLCB2aWEpO1xufTtcbkFja0NsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG5BY2tDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCkge1xuICBpZighdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLnJlcXVlc3QpKSB7XG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cbn07XG5cbkFja0NsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygndHJhbnNwb3J0IGVycm9yIG9jY3VycmVkLCBmb3IgYW4gQUNLIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIub25UcmFuc3BvcnRFcnJvcigpO1xufTtcblxuXG4vKipcbiogQGF1Z21lbnRzIFNJUC5UcmFuc2FjdGlvbnNcbiogQGNsYXNzIE5vbiBJbnZpdGUgU2VydmVyIFRyYW5zYWN0aW9uXG4qIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdH0gcmVxdWVzdFxuKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiovXG52YXIgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24gPSBmdW5jdGlvbihyZXF1ZXN0LCB1YSkge1xuICB0aGlzLnR5cGUgPSBDLk5PTl9JTlZJVEVfU0VSVkVSO1xuICB0aGlzLmlkID0gcmVxdWVzdC52aWFfYnJhbmNoO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICB0aGlzLnRyYW5zcG9ydCA9IHJlcXVlc3QudHJhbnNwb3J0O1xuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMubGFzdF9yZXNwb25zZSA9ICcnO1xuICByZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbiA9IHRoaXM7XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC50cmFuc2FjdGlvbi5uaXN0JywgdGhpcy5pZCk7XG5cbiAgdGhpcy5zdGF0ZSA9IEMuU1RBVFVTX1RSWUlORztcblxuICB1YS5uZXdUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZWQnKTtcbn07XG5cbk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9KID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgSiBleHBpcmVkIGZvciBub24tSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5cbk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy50cmFuc3BvcnRFcnJvcikge1xuICAgIHRoaXMudHJhbnNwb3J0RXJyb3IgPSB0cnVlO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKCd0cmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQsIGRlbGV0aW5nIG5vbi1JTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcblxuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuSik7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gICAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gIH1cbn07XG5cbk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihzdGF0dXNfY29kZSwgcmVzcG9uc2UpIHtcbiAgdmFyIHRyID0gdGhpcztcbiAgdmFyIGRlZmVycmVkID0gU0lQLlV0aWxzLmRlZmVyKCk7XG5cbiAgaWYoc3RhdHVzX2NvZGUgPT09IDEwMCkge1xuICAgIC8qIFJGQyA0MzIwIDQuMVxuICAgICAqICdBIFNJUCBlbGVtZW50IE1VU1QgTk9UXG4gICAgICogc2VuZCBhbnkgcHJvdmlzaW9uYWwgcmVzcG9uc2Ugd2l0aCBhXG4gICAgICogU3RhdHVzLUNvZGUgb3RoZXIgdGhhbiAxMDAgdG8gYSBub24tSU5WSVRFIHJlcXVlc3QuJ1xuICAgICAqL1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1RSWUlORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfUFJPQ0VFRElORyk7XG4gICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKSkgIHtcbiAgICAgICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5sYXN0X3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKSkge1xuICAgICAgICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSBpZihzdGF0dXNfY29kZSA+PSAyMDAgJiYgc3RhdHVzX2NvZGUgPD0gNjk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfVFJZSU5HOlxuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19DT01QTEVURUQpO1xuICAgICAgICB0aGlzLmxhc3RfcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5KID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0ouYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfSik7XG4gICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKSkge1xuICAgICAgICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ09NUExFVEVEOlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuKiBAYXVnbWVudHMgU0lQLlRyYW5zYWN0aW9uc1xuKiBAY2xhc3MgSW52aXRlIFNlcnZlciBUcmFuc2FjdGlvblxuKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3RcbiogQHBhcmFtIHtTSVAuVUF9IHVhXG4qL1xudmFyIEludml0ZVNlcnZlclRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocmVxdWVzdCwgdWEpIHtcbiAgdGhpcy50eXBlID0gQy5JTlZJVEVfU0VSVkVSO1xuICB0aGlzLmlkID0gcmVxdWVzdC52aWFfYnJhbmNoO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICB0aGlzLnRyYW5zcG9ydCA9IHJlcXVlc3QudHJhbnNwb3J0O1xuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMubGFzdF9yZXNwb25zZSA9ICcnO1xuICByZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbiA9IHRoaXM7XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC50cmFuc2FjdGlvbi5pc3QnLCB0aGlzLmlkKTtcblxuICB0aGlzLnN0YXRlID0gQy5TVEFUVVNfUFJPQ0VFRElORztcblxuICB1YS5uZXdUcmFuc2FjdGlvbih0aGlzKTtcblxuICB0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPSBudWxsO1xuXG4gIHJlcXVlc3QucmVwbHkoMTAwKTtcbn07XG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZWQnKTtcbn07XG5cbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9IID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgSCBleHBpcmVkIGZvciBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcblxuICBpZih0aGlzLnN0YXRlID09PSBDLlNUQVRVU19DT01QTEVURUQpIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCd0cmFuc2FjdGlvbnMnLCAnQUNLIGZvciBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uIHdhcyBuZXZlciByZWNlaXZlZCwgY2FsbCB3aWxsIGJlIHRlcm1pbmF0ZWQnKTtcbiAgfVxuXG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5cbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9JID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5cbi8vIFJGQyA2MDI2IDcuMVxuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0wgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCdUaW1lciBMIGV4cGlyZWQgZm9yIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuXG4gIGlmKHRoaXMuc3RhdGUgPT09IEMuU1RBVFVTX0FDQ0VQVEVEKSB7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gICAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gIH1cbn07XG5cbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy50cmFuc3BvcnRFcnJvcikge1xuICAgIHRoaXMudHJhbnNwb3J0RXJyb3IgPSB0cnVlO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKCd0cmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQsIGRlbGV0aW5nIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuXG4gICAgaWYgKHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciAhPT0gbnVsbCkge1xuICAgICAgU0lQLlRpbWVycy5jbGVhckludGVydmFsKHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lcik7XG4gICAgICB0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuTCk7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5IKTtcbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkkpO1xuXG4gICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gICAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gIH1cbn07XG5cbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZXNlbmRfcHJvdmlzaW9uYWwgPSBmdW5jdGlvbigpIHtcbiAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5sYXN0X3Jlc3BvbnNlKSkge1xuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG59O1xuXG4vLyBJTlZJVEUgU2VydmVyIFRyYW5zYWN0aW9uIFJGQyAzMjYxIDE3LjIuMVxuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uKHN0YXR1c19jb2RlLCByZXNwb25zZSkge1xuICB2YXIgdHIgPSB0aGlzO1xuICB2YXIgZGVmZXJyZWQgPSBTSVAuVXRpbHMuZGVmZXIoKTtcblxuICBpZihzdGF0dXNfY29kZSA+PSAxMDAgJiYgc3RhdHVzX2NvZGUgPD0gMTk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0X3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmKHN0YXR1c19jb2RlID4gMTAwICYmIHN0YXR1c19jb2RlIDw9IDE5OSAmJiB0aGlzLnN0YXRlID09PSBDLlNUQVRVU19QUk9DRUVESU5HKSB7XG4gICAgLy8gVHJpZ2dlciB0aGUgcmVzZW5kUHJvdmlzaW9uYWxUaW1lciBvbmx5IGZvciB0aGUgZmlyc3Qgbm9uIDEwMCBwcm92aXNpb25hbCByZXNwb25zZS5cbiAgICBpZih0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciA9IFNJUC5UaW1lcnMuc2V0SW50ZXJ2YWwodHIucmVzZW5kX3Byb3Zpc2lvbmFsLmJpbmQodHIpLFxuICAgICAgICBTSVAuVGltZXJzLlBST1ZJU0lPTkFMX1JFU1BPTlNFX0lOVEVSVkFMKTtcbiAgICB9XG4gIH0gZWxzZSBpZihzdGF0dXNfY29kZSA+PSAyMDAgJiYgc3RhdHVzX2NvZGUgPD0gMjk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQUNDRVBURUQpO1xuICAgICAgICB0aGlzLmxhc3RfcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5MID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0wuYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfTCk7XG5cbiAgICAgICAgaWYgKHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJJbnRlcnZhbCh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIpO1xuICAgICAgICAgIHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlIEMuU1RBVFVTX0FDQ0VQVEVEOlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHBvaW50IHdpbGwgYmUgcmVhY2hlZCBmb3IgcHJvY2VlZGluZyB0ci5zdGF0ZSBhbHNvLlxuICAgICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSBpZihzdGF0dXNfY29kZSA+PSAzMDAgJiYgc3RhdHVzX2NvZGUgPD0gNjk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgaWYgKHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJJbnRlcnZhbCh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIpO1xuICAgICAgICAgIHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSkpIHtcbiAgICAgICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19DT01QTEVURUQpO1xuICAgICAgICAgIHRoaXMuSCA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9ILmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0gpO1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiAqIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdH0gcmVxdWVzdFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBJTlZJVEU6XG4gKiAgX3RydWVfIGlmIHJldHJhbnNtaXNzaW9uXG4gKiAgX2ZhbHNlXyBuZXcgcmVxdWVzdFxuICpcbiAqIEFDSzpcbiAqICBfdHJ1ZV8gIEFDSyB0byBub24yeHggcmVzcG9uc2VcbiAqICBfZmFsc2VfIEFDSyBtdXN0IGJlIHBhc3NlZCB0byBUVSAoYWNjZXB0ZWQgc3RhdGUpXG4gKiAgICAgICAgICBBQ0sgdG8gMnh4IHJlc3BvbnNlXG4gKlxuICogQ0FOQ0VMOlxuICogIF90cnVlXyAgbm8gbWF0Y2hpbmcgaW52aXRlIHRyYW5zYWN0aW9uXG4gKiAgX2ZhbHNlXyBtYXRjaGluZyBpbnZpdGUgdHJhbnNhY3Rpb24gYW5kIG5vIGZpbmFsIHJlc3BvbnNlIHNlbnRcbiAqXG4gKiBPVEhFUjpcbiAqICBfdHJ1ZV8gIHJldHJhbnNtaXNzaW9uXG4gKiAgX2ZhbHNlXyBuZXcgcmVxdWVzdFxuICovXG52YXIgY2hlY2tUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHVhLCByZXF1ZXN0KSB7XG4gIHZhciB0cjtcblxuICBzd2l0Y2gocmVxdWVzdC5tZXRob2QpIHtcbiAgICBjYXNlIFNJUC5DLklOVklURTpcbiAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLmlzdFtyZXF1ZXN0LnZpYV9icmFuY2hdO1xuICAgICAgaWYodHIpIHtcbiAgICAgICAgc3dpdGNoKHRyLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICAgICAgdHIudHJhbnNwb3J0LnNlbmQodHIubGFzdF9yZXNwb25zZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gUkZDIDYwMjYgNy4xIEludml0ZSByZXRyYW5zbWlzc2lvblxuICAgICAgICAgICAgLy9yZWNlaXZlZCB3aGlsZSBpbiBDLlNUQVRVU19BQ0NFUFRFRCBzdGF0ZS4gQWJzb3JiIGl0LlxuICAgICAgICAgIGNhc2UgQy5TVEFUVVNfQUNDRVBURUQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0lQLkMuQUNLOlxuICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMuaXN0W3JlcXVlc3QudmlhX2JyYW5jaF07XG5cbiAgICAgIC8vIFJGQyA2MDI2IDcuMVxuICAgICAgaWYodHIpIHtcbiAgICAgICAgaWYodHIuc3RhdGUgPT09IEMuU1RBVFVTX0FDQ0VQVEVEKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYodHIuc3RhdGUgPT09IEMuU1RBVFVTX0NPTVBMRVRFRCkge1xuICAgICAgICAgIHRyLnN0YXRlID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgICAgIHRyLkkgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfSS5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9JKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBQ0sgdG8gMlhYIFJlc3BvbnNlLlxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0lQLkMuQ0FOQ0VMOlxuICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMuaXN0W3JlcXVlc3QudmlhX2JyYW5jaF07XG4gICAgICBpZih0cikge1xuICAgICAgICByZXF1ZXN0LnJlcGx5X3NsKDIwMCk7XG4gICAgICAgIGlmKHRyLnN0YXRlID09PSBDLlNUQVRVU19QUk9DRUVESU5HKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0LnJlcGx5X3NsKDQ4MSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcblxuICAgICAgLy8gTm9uLUlOVklURSBTZXJ2ZXIgVHJhbnNhY3Rpb24gUkZDIDMyNjEgMTcuMi4yXG4gICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5uaXN0W3JlcXVlc3QudmlhX2JyYW5jaF07XG4gICAgICBpZih0cikge1xuICAgICAgICBzd2l0Y2godHIuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlIEMuU1RBVFVTX1RSWUlORzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgICBjYXNlIEMuU1RBVFVTX0NPTVBMRVRFRDpcbiAgICAgICAgICAgIHRyLnRyYW5zcG9ydC5zZW5kKHRyLmxhc3RfcmVzcG9uc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuU0lQLlRyYW5zYWN0aW9ucyA9IHtcbiAgQzogQyxcbiAgY2hlY2tUcmFuc2FjdGlvbjogY2hlY2tUcmFuc2FjdGlvbixcbiAgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb246IE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLFxuICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbjogSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sXG4gIEFja0NsaWVudFRyYW5zYWN0aW9uOiBBY2tDbGllbnRUcmFuc2FjdGlvbixcbiAgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb246IE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLFxuICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbjogSW52aXRlU2VydmVyVHJhbnNhY3Rpb25cbn07XG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1RyYW5zYWN0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIERpYWxvZ1xuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGEgU0lQIGRpYWxvZy5cbiAqIEBwYXJhbSB7U0lQLlJUQ1Nlc3Npb259IG93bmVyXG4gKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R8U0lQLkluY29taW5nUmVzcG9uc2V9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7RW51bX0gdHlwZSBVQUMgLyBVQVNcbiAqIEBwYXJhbSB7RW51bX0gc3RhdGUgU0lQLkRpYWxvZy5DLlNUQVRVU19FQVJMWSAvIFNJUC5EaWFsb2cuQy5TVEFUVVNfQ09ORklSTUVEXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuXG52YXIgUmVxdWVzdFNlbmRlciA9IHJlcXVpcmUoJy4vRGlhbG9nL1JlcXVlc3RTZW5kZXInKShTSVApO1xuXG52YXIgRGlhbG9nLFxuICBDID0ge1xuICAgIC8vIERpYWxvZyBzdGF0ZXNcbiAgICBTVEFUVVNfRUFSTFk6ICAgICAgIDEsXG4gICAgU1RBVFVTX0NPTkZJUk1FRDogICAyXG4gIH07XG5cbi8vIFJGQyAzMjYxIDEyLjFcbkRpYWxvZyA9IGZ1bmN0aW9uKG93bmVyLCBtZXNzYWdlLCB0eXBlLCBzdGF0ZSkge1xuICB2YXIgY29udGFjdDtcblxuICB0aGlzLnVhY19wZW5kaW5nX3JlcGx5ID0gZmFsc2U7XG4gIHRoaXMudWFzX3BlbmRpbmdfcmVwbHkgPSBmYWxzZTtcblxuICBpZighbWVzc2FnZS5oYXNIZWFkZXIoJ2NvbnRhY3QnKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogJ3VuYWJsZSB0byBjcmVhdGUgYSBEaWFsb2cgd2l0aG91dCBDb250YWN0IGhlYWRlciBmaWVsZCdcbiAgICB9O1xuICB9XG5cbiAgaWYobWVzc2FnZSBpbnN0YW5jZW9mIFNJUC5JbmNvbWluZ1Jlc3BvbnNlKSB7XG4gICAgc3RhdGUgPSAobWVzc2FnZS5zdGF0dXNfY29kZSA8IDIwMCkgPyBDLlNUQVRVU19FQVJMWSA6IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgfSBlbHNlIHtcbiAgICAvLyBDcmVhdGUgY29uZmlybWVkIGRpYWxvZyBpZiBzdGF0ZSBpcyBub3QgZGVmaW5lZFxuICAgIHN0YXRlID0gc3RhdGUgfHwgQy5TVEFUVVNfQ09ORklSTUVEO1xuICB9XG5cbiAgY29udGFjdCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2NvbnRhY3QnKTtcblxuICAvLyBSRkMgMzI2MSAxMi4xLjFcbiAgaWYodHlwZSA9PT0gJ1VBUycpIHtcbiAgICB0aGlzLmlkID0ge1xuICAgICAgY2FsbF9pZDogbWVzc2FnZS5jYWxsX2lkLFxuICAgICAgbG9jYWxfdGFnOiBtZXNzYWdlLnRvX3RhZyxcbiAgICAgIHJlbW90ZV90YWc6IG1lc3NhZ2UuZnJvbV90YWcsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxfaWQgKyB0aGlzLmxvY2FsX3RhZyArIHRoaXMucmVtb3RlX3RhZztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLnJlbW90ZV9zZXFudW0gPSBtZXNzYWdlLmNzZXE7XG4gICAgdGhpcy5sb2NhbF91cmkgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCd0bycpLnVyaTtcbiAgICB0aGlzLnJlbW90ZV91cmkgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdmcm9tJykudXJpO1xuICAgIHRoaXMucmVtb3RlX3RhcmdldCA9IGNvbnRhY3QudXJpO1xuICAgIHRoaXMucm91dGVfc2V0ID0gbWVzc2FnZS5nZXRIZWFkZXJzKCdyZWNvcmQtcm91dGUnKTtcbiAgICB0aGlzLmludml0ZV9zZXFudW0gPSBtZXNzYWdlLmNzZXE7XG4gICAgdGhpcy5sb2NhbF9zZXFudW0gPSBtZXNzYWdlLmNzZXE7XG4gIH1cbiAgLy8gUkZDIDMyNjEgMTIuMS4yXG4gIGVsc2UgaWYodHlwZSA9PT0gJ1VBQycpIHtcbiAgICB0aGlzLmlkID0ge1xuICAgICAgY2FsbF9pZDogbWVzc2FnZS5jYWxsX2lkLFxuICAgICAgbG9jYWxfdGFnOiBtZXNzYWdlLmZyb21fdGFnLFxuICAgICAgcmVtb3RlX3RhZzogbWVzc2FnZS50b190YWcsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxfaWQgKyB0aGlzLmxvY2FsX3RhZyArIHRoaXMucmVtb3RlX3RhZztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmludml0ZV9zZXFudW0gPSBtZXNzYWdlLmNzZXE7XG4gICAgdGhpcy5sb2NhbF9zZXFudW0gPSBtZXNzYWdlLmNzZXE7XG4gICAgdGhpcy5sb2NhbF91cmkgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdmcm9tJykudXJpO1xuICAgIHRoaXMucHJhY2tlZCA9IFtdO1xuICAgIHRoaXMucmVtb3RlX3VyaSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ3RvJykudXJpO1xuICAgIHRoaXMucmVtb3RlX3RhcmdldCA9IGNvbnRhY3QudXJpO1xuICAgIHRoaXMucm91dGVfc2V0ID0gbWVzc2FnZS5nZXRIZWFkZXJzKCdyZWNvcmQtcm91dGUnKS5yZXZlcnNlKCk7XG5cbiAgICAvL1JFTkRFUkJPRFlcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfRUFSTFkgJiYgKCFvd25lci5oYXNPZmZlcikpIHtcbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyID0gb3duZXIubWVkaWFIYW5kbGVyRmFjdG9yeShvd25lcik7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5sb2dnZXIgPSBvd25lci51YS5nZXRMb2dnZXIoJ3NpcC5kaWFsb2cnLCB0aGlzLmlkLnRvU3RyaW5nKCkpO1xuICB0aGlzLm93bmVyID0gb3duZXI7XG4gIG93bmVyLnVhLmRpYWxvZ3NbdGhpcy5pZC50b1N0cmluZygpXSA9IHRoaXM7XG4gIHRoaXMubG9nZ2VyLmxvZygnbmV3ICcgKyB0eXBlICsgJyBkaWFsb2cgY3JlYXRlZCB3aXRoIHN0YXR1cyAnICsgKHRoaXMuc3RhdGUgPT09IEMuU1RBVFVTX0VBUkxZID8gJ0VBUkxZJzogJ0NPTkZJUk1FRCcpKTtcbiAgb3duZXIuZW1pdCgnZGlhbG9nJywgdGhpcyk7XG59O1xuXG5EaWFsb2cucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtTSVAuSW5jb21pbmdNZXNzYWdlfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RW51bX0gVUFDL1VBU1xuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbihtZXNzYWdlLCB0eXBlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcblxuICAgIHRoaXMubG9nZ2VyLmxvZygnZGlhbG9nICcrIHRoaXMuaWQudG9TdHJpbmcoKSArJyAgY2hhbmdlZCB0byBDT05GSVJNRUQgc3RhdGUnKTtcblxuICAgIGlmKHR5cGUgPT09ICdVQUMnKSB7XG4gICAgICAvLyBSRkMgMzI2MSAxMy4yLjIuNFxuICAgICAgdGhpcy5yb3V0ZV9zZXQgPSBtZXNzYWdlLmdldEhlYWRlcnMoJ3JlY29yZC1yb3V0ZScpLnJldmVyc2UoKTtcbiAgICB9XG4gIH0sXG5cbiAgdGVybWluYXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ2RpYWxvZyAnICsgdGhpcy5pZC50b1N0cmluZygpICsgJyBkZWxldGVkJyk7XG4gICAgaWYgKHRoaXMubWVkaWFIYW5kbGVyICYmIHRoaXMuc3RhdGUgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIucGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMub3duZXIudWEuZGlhbG9nc1t0aGlzLmlkLnRvU3RyaW5nKCldO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgcmVxdWVzdCBtZXRob2RcbiAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmFIZWFkZXJzIGV4dHJhIGhlYWRlcnNcbiAgKiBAcmV0dXJucyB7U0lQLk91dGdvaW5nUmVxdWVzdH1cbiAgKi9cblxuICAvLyBSRkMgMzI2MSAxMi4yLjEuMVxuICBjcmVhdGVSZXF1ZXN0OiBmdW5jdGlvbihtZXRob2QsIGV4dHJhSGVhZGVycywgYm9keSkge1xuICAgIHZhciBjc2VxLCByZXF1ZXN0O1xuICAgIGV4dHJhSGVhZGVycyA9IChleHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgICBpZighdGhpcy5sb2NhbF9zZXFudW0pIHsgdGhpcy5sb2NhbF9zZXFudW0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7IH1cblxuICAgIGNzZXEgPSAobWV0aG9kID09PSBTSVAuQy5DQU5DRUwgfHwgbWV0aG9kID09PSBTSVAuQy5BQ0spID8gdGhpcy5pbnZpdGVfc2VxbnVtIDogdGhpcy5sb2NhbF9zZXFudW0gKz0gMTtcblxuICAgIHJlcXVlc3QgPSBuZXcgU0lQLk91dGdvaW5nUmVxdWVzdChcbiAgICAgIG1ldGhvZCxcbiAgICAgIHRoaXMucmVtb3RlX3RhcmdldCxcbiAgICAgIHRoaXMub3duZXIudWEsIHtcbiAgICAgICAgJ2NzZXEnOiBjc2VxLFxuICAgICAgICAnY2FsbF9pZCc6IHRoaXMuaWQuY2FsbF9pZCxcbiAgICAgICAgJ2Zyb21fdXJpJzogdGhpcy5sb2NhbF91cmksXG4gICAgICAgICdmcm9tX3RhZyc6IHRoaXMuaWQubG9jYWxfdGFnLFxuICAgICAgICAndG9fdXJpJzogdGhpcy5yZW1vdGVfdXJpLFxuICAgICAgICAndG9fdGFnJzogdGhpcy5pZC5yZW1vdGVfdGFnLFxuICAgICAgICAncm91dGVfc2V0JzogdGhpcy5yb3V0ZV9zZXRcbiAgICAgIH0sIGV4dHJhSGVhZGVycywgYm9keSk7XG5cbiAgICByZXF1ZXN0LmRpYWxvZyA9IHRoaXM7XG5cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3RcbiAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgKi9cblxuICAvLyBSRkMgMzI2MSAxMi4yLjJcbiAgY2hlY2tJbkRpYWxvZ1JlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZighdGhpcy5yZW1vdGVfc2VxbnVtKSB7XG4gICAgICB0aGlzLnJlbW90ZV9zZXFudW0gPSByZXF1ZXN0LmNzZXE7XG4gICAgfSBlbHNlIGlmKHJlcXVlc3QuY3NlcSA8IHRoaXMucmVtb3RlX3NlcW51bSkge1xuICAgICAgICAvL0RvIG5vdCB0cnkgdG8gcmVwbHkgdG8gYW4gQUNLIHJlcXVlc3QuXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gU0lQLkMuQUNLKSB7XG4gICAgICAgICAgcmVxdWVzdC5yZXBseSg1MDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0LmNzZXEgPT09IHRoaXMuaW52aXRlX3NlcW51bSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYocmVxdWVzdC5jc2VxID4gdGhpcy5yZW1vdGVfc2VxbnVtKSB7XG4gICAgICB0aGlzLnJlbW90ZV9zZXFudW0gPSByZXF1ZXN0LmNzZXE7XG4gICAgfVxuXG4gICAgc3dpdGNoKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgICAvLyBSRkMzMjYxIDE0LjIgTW9kaWZ5aW5nIGFuIEV4aXN0aW5nIFNlc3Npb24gLVVBUyBCRUhBVklPUi1cbiAgICAgIGNhc2UgU0lQLkMuSU5WSVRFOlxuICAgICAgICBpZiAodGhpcy51YWNfcGVuZGluZ19yZXBseSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJlcXVlc3QucmVwbHkoNDkxKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnVhc19wZW5kaW5nX3JlcGx5ID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJldHJ5QWZ0ZXIgPSAoTWF0aC5yYW5kb20oKSAqIDEwIHwgMCkgKyAxO1xuICAgICAgICAgIHJlcXVlc3QucmVwbHkoNTAwLCBudWxsLCBbJ1JldHJ5LUFmdGVyOicgKyByZXRyeUFmdGVyXSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudWFzX3BlbmRpbmdfcmVwbHkgPSB0cnVlO1xuICAgICAgICAgIHJlcXVlc3Quc2VydmVyX3RyYW5zYWN0aW9uLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoKXtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX0FDQ0VQVEVEIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19DT01QTEVURUQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX1RFUk1JTkFURUQpIHtcblxuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgICAgICBzZWxmLnVhc19wZW5kaW5nX3JlcGx5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgaWYgKHNlbGYudWFjX3BlbmRpbmdfcmVwbHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vd25lci5vblJlYWR5VG9SZWludml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSRkMzMjYxIDEyLjIuMiBSZXBsYWNlIHRoZSBkaWFsb2dgcyByZW1vdGUgdGFyZ2V0IFVSSSBpZiB0aGUgcmVxdWVzdCBpcyBhY2NlcHRlZFxuICAgICAgICBpZihyZXF1ZXN0Lmhhc0hlYWRlcignY29udGFjdCcpKSB7XG4gICAgICAgICAgcmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24ub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19BQ0NFUFRFRCkge1xuICAgICAgICAgICAgICBzZWxmLnJlbW90ZV90YXJnZXQgPSByZXF1ZXN0LnBhcnNlSGVhZGVyKCdjb250YWN0JykudXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5OT1RJRlk6XG4gICAgICAgIC8vIFJGQzY2NjUgMy4yIFJlcGxhY2UgdGhlIGRpYWxvZ2BzIHJlbW90ZSB0YXJnZXQgVVJJIGlmIHRoZSByZXF1ZXN0IGlzIGFjY2VwdGVkXG4gICAgICAgIGlmKHJlcXVlc3QuaGFzSGVhZGVyKCdjb250YWN0JykpIHtcbiAgICAgICAgICByZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbi5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX0NPTVBMRVRFRCkge1xuICAgICAgICAgICAgICBzZWxmLnJlbW90ZV90YXJnZXQgPSByZXF1ZXN0LnBhcnNlSGVhZGVyKCdjb250YWN0JykudXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHNlbmRSZXF1ZXN0OiBmdW5jdGlvbihhcHBsaWNhbnQsIG1ldGhvZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyXG4gICAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgICBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG51bGwsXG4gICAgICByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KG1ldGhvZCwgZXh0cmFIZWFkZXJzLCBib2R5KSxcbiAgICAgIHJlcXVlc3Rfc2VuZGVyID0gbmV3IFJlcXVlc3RTZW5kZXIodGhpcywgYXBwbGljYW50LCByZXF1ZXN0KTtcblxuICAgIHJlcXVlc3Rfc2VuZGVyLnNlbmQoKTtcblxuICAgIHJldHVybiByZXF1ZXN0O1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdH0gcmVxdWVzdFxuICAqL1xuICByZWNlaXZlUmVxdWVzdDogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIC8vQ2hlY2sgaW4tZGlhbG9nIHJlcXVlc3RcbiAgICBpZighdGhpcy5jaGVja0luRGlhbG9nUmVxdWVzdChyZXF1ZXN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub3duZXIucmVjZWl2ZVJlcXVlc3QocmVxdWVzdCk7XG4gIH1cbn07XG5cbkRpYWxvZy5DID0gQztcblNJUC5EaWFsb2cgPSBEaWFsb2c7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9EaWFsb2dzLmpzXG4gKiogbW9kdWxlIGlkID0gMjI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEluLURpYWxvZyBSZXF1ZXN0IFNlbmRlclxuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUC5EaWFsb2dcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhbiBJbi1kaWFsb2cgcmVxdWVzdCBzZW5kZXIuXG4gKiBAcGFyYW0ge1NJUC5EaWFsb2d9IGRpYWxvZ1xuICogQHBhcmFtIHtPYmplY3R9IGFwcGxpY2FudFxuICogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fSByZXF1ZXN0XG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBpbi1EaWFsb2cgUmVxdWVzdCBTZW5kZXJcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBSZXF1ZXN0U2VuZGVyO1xuXG5SZXF1ZXN0U2VuZGVyID0gZnVuY3Rpb24oZGlhbG9nLCBhcHBsaWNhbnQsIHJlcXVlc3QpIHtcblxuICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcbiAgdGhpcy5hcHBsaWNhbnQgPSBhcHBsaWNhbnQ7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgLy8gUkZDMzI2MSAxNC4xIE1vZGlmeWluZyBhbiBFeGlzdGluZyBTZXNzaW9uLiBVQUMgQmVoYXZpb3IuXG4gIHRoaXMucmVhdHRlbXB0ID0gZmFsc2U7XG4gIHRoaXMucmVhdHRlbXB0VGltZXIgPSBudWxsO1xufTtcblxuUmVxdWVzdFNlbmRlci5wcm90b3R5cGUgPSB7XG4gIHNlbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHJlcXVlc3Rfc2VuZGVyID0gbmV3IFNJUC5SZXF1ZXN0U2VuZGVyKHRoaXMsIHRoaXMuZGlhbG9nLm93bmVyLnVhKTtcblxuICAgICAgcmVxdWVzdF9zZW5kZXIuc2VuZCgpO1xuXG4gICAgLy8gUkZDMzI2MSAxNC4yIE1vZGlmeWluZyBhbiBFeGlzdGluZyBTZXNzaW9uIC1VQUMgQkVIQVZJT1ItXG4gICAgaWYgKHRoaXMucmVxdWVzdC5tZXRob2QgPT09IFNJUC5DLklOVklURSAmJiByZXF1ZXN0X3NlbmRlci5jbGllbnRUcmFuc2FjdGlvbi5zdGF0ZSAhPT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmRpYWxvZy51YWNfcGVuZGluZ19yZXBseSA9IHRydWU7XG4gICAgICByZXF1ZXN0X3NlbmRlci5jbGllbnRUcmFuc2FjdGlvbi5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gc3RhdGVDaGFuZ2VkKCl7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX0FDQ0VQVEVEIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX0NPTVBMRVRFRCB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG5cbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgIHNlbGYuZGlhbG9nLnVhY19wZW5kaW5nX3JlcGx5ID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoc2VsZi5kaWFsb2cudWFzX3BlbmRpbmdfcmVwbHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzZWxmLmRpYWxvZy5vd25lci5vblJlYWR5VG9SZWludml0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXBwbGljYW50Lm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgfSxcblxuICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFwcGxpY2FudC5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH0sXG5cbiAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFJGQzMyNjEgMTIuMi4xLjIgNDA4IG9yIDQ4MSBpcyByZWNlaXZlZCBmb3IgYSByZXF1ZXN0IHdpdGhpbiBhIGRpYWxvZy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDQwOCB8fCByZXNwb25zZS5zdGF0dXNfY29kZSA9PT0gNDgxKSB7XG4gICAgICB0aGlzLmFwcGxpY2FudC5vbkRpYWxvZ0Vycm9yKHJlc3BvbnNlKTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLm1ldGhvZCA9PT0gU0lQLkMuSU5WSVRFICYmIHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSA0OTEpIHtcbiAgICAgIGlmICh0aGlzLnJlYXR0ZW1wdCkge1xuICAgICAgICB0aGlzLmFwcGxpY2FudC5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0LmNzZXEudmFsdWUgPSB0aGlzLmRpYWxvZy5sb2NhbF9zZXFudW0gKz0gMTtcbiAgICAgICAgdGhpcy5yZWF0dGVtcHRUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmFwcGxpY2FudC5vd25lci5zdGF0dXMgIT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgICAgc2VsZi5yZWF0dGVtcHQgPSB0cnVlO1xuICAgICAgICAgICAgICBzZWxmLnJlcXVlc3Rfc2VuZGVyLnNlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRoaXMuZ2V0UmVhdHRlbXB0VGltZW91dCgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbGljYW50LnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfVxuICB9XG59O1xuXG5yZXR1cm4gUmVxdWVzdFNlbmRlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0RpYWxvZy9SZXF1ZXN0U2VuZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcXVlc3QgU2VuZGVyXG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSByZXF1ZXN0IHNlbmRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhcHBsaWNhbnRcbiAqIEBwYXJhbSB7U0lQLlVBfSB1YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBSZXF1ZXN0U2VuZGVyO1xuXG5SZXF1ZXN0U2VuZGVyID0gZnVuY3Rpb24oYXBwbGljYW50LCB1YSkge1xuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnJlcXVlc3RzZW5kZXInKTtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmFwcGxpY2FudCA9IGFwcGxpY2FudDtcbiAgdGhpcy5tZXRob2QgPSBhcHBsaWNhbnQucmVxdWVzdC5tZXRob2Q7XG4gIHRoaXMucmVxdWVzdCA9IGFwcGxpY2FudC5yZXF1ZXN0O1xuICB0aGlzLmNyZWRlbnRpYWxzID0gbnVsbDtcbiAgdGhpcy5jaGFsbGVuZ2VkID0gZmFsc2U7XG4gIHRoaXMuc3RhbGVkID0gZmFsc2U7XG5cbiAgLy8gSWYgdWEgaXMgaW4gY2xvc2luZyBwcm9jZXNzIG9yIGV2ZW4gY2xvc2VkIGp1c3QgYWxsb3cgc2VuZGluZyBCeWUgYW5kIEFDS1xuICBpZiAodWEuc3RhdHVzID09PSBTSVAuVUEuQy5TVEFUVVNfVVNFUl9DTE9TRUQgJiYgKHRoaXMubWV0aG9kICE9PSBTSVAuQy5CWUUgfHwgdGhpcy5tZXRob2QgIT09IFNJUC5DLkFDSykpIHtcbiAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxufTtcblxuLyoqXG4qIENyZWF0ZSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIGFuZCBzZW5kIHRoZSBtZXNzYWdlLlxuKi9cblJlcXVlc3RTZW5kZXIucHJvdG90eXBlID0ge1xuICBzZW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2godGhpcy5tZXRob2QpIHtcbiAgICAgIGNhc2UgXCJJTlZJVEVcIjpcbiAgICAgICAgdGhpcy5jbGllbnRUcmFuc2FjdGlvbiA9IG5ldyBTSVAuVHJhbnNhY3Rpb25zLkludml0ZUNsaWVudFRyYW5zYWN0aW9uKHRoaXMsIHRoaXMucmVxdWVzdCwgdGhpcy51YS50cmFuc3BvcnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBQ0tcIjpcbiAgICAgICAgdGhpcy5jbGllbnRUcmFuc2FjdGlvbiA9IG5ldyBTSVAuVHJhbnNhY3Rpb25zLkFja0NsaWVudFRyYW5zYWN0aW9uKHRoaXMsIHRoaXMucmVxdWVzdCwgdGhpcy51YS50cmFuc3BvcnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuY2xpZW50VHJhbnNhY3Rpb24gPSBuZXcgU0lQLlRyYW5zYWN0aW9ucy5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLnJlcXVlc3QsIHRoaXMudWEudHJhbnNwb3J0KTtcbiAgICB9XG4gICAgdGhpcy5jbGllbnRUcmFuc2FjdGlvbi5zZW5kKCk7XG5cbiAgICByZXR1cm4gdGhpcy5jbGllbnRUcmFuc2FjdGlvbjtcbiAgfSxcblxuICAvKipcbiAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHJlY2VpdmluZyBhIHJlcXVlc3QgdGltZW91dCBlcnJvciBmcm9tIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24uXG4gICogVG8gYmUgcmUtZGVmaW5lZCBieSB0aGUgYXBwbGljYW50LlxuICAqIEBldmVudFxuICAqL1xuICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFwcGxpY2FudC5vblJlcXVlc3RUaW1lb3V0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICogQ2FsbGJhY2sgZmlyZWQgd2hlbiByZWNlaXZpbmcgYSB0cmFuc3BvcnQgZXJyb3IgZnJvbSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uLlxuICAqIFRvIGJlIHJlLWRlZmluZWQgYnkgdGhlIGFwcGxpY2FudC5cbiAgKiBAZXZlbnRcbiAgKi9cbiAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hcHBsaWNhbnQub25UcmFuc3BvcnRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAqIENhbGxlZCBmcm9tIGNsaWVudCB0cmFuc2FjdGlvbiB3aGVuIHJlY2VpdmluZyBhIGNvcnJlY3QgcmVzcG9uc2UgdG8gdGhlIHJlcXVlc3QuXG4gICogQXV0aGVudGljYXRlIHJlcXVlc3QgaWYgbmVlZGVkIG9yIHBhc3MgdGhlIHJlc3BvbnNlIGJhY2sgdG8gdGhlIGFwcGxpY2FudC5cbiAgKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1Jlc3BvbnNlfSByZXNwb25zZVxuICAqL1xuICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgdmFyIGNzZXEsIGNoYWxsZW5nZSwgYXV0aG9yaXphdGlvbl9oZWFkZXJfbmFtZSxcbiAgICAgIHN0YXR1c19jb2RlID0gcmVzcG9uc2Uuc3RhdHVzX2NvZGU7XG5cbiAgICAvKlxuICAgICogQXV0aGVudGljYXRpb25cbiAgICAqIEF1dGhlbnRpY2F0ZSBvbmNlLiBfY2hhbGxlbmdlZF8gZmxhZyB1c2VkIHRvIGF2b2lkIGluZmluaXRlIGF1dGhlbnRpY2F0aW9ucy5cbiAgICAqL1xuICAgIGlmIChzdGF0dXNfY29kZSA9PT0gNDAxIHx8IHN0YXR1c19jb2RlID09PSA0MDcpIHtcblxuICAgICAgLy8gR2V0IGFuZCBwYXJzZSB0aGUgYXBwcm9wcmlhdGUgV1dXLUF1dGhlbnRpY2F0ZSBvciBQcm94eS1BdXRoZW50aWNhdGUgaGVhZGVyLlxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSA0MDEpIHtcbiAgICAgICAgY2hhbGxlbmdlID0gcmVzcG9uc2UucGFyc2VIZWFkZXIoJ3d3dy1hdXRoZW50aWNhdGUnKTtcbiAgICAgICAgYXV0aG9yaXphdGlvbl9oZWFkZXJfbmFtZSA9ICdhdXRob3JpemF0aW9uJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYWxsZW5nZSA9IHJlc3BvbnNlLnBhcnNlSGVhZGVyKCdwcm94eS1hdXRoZW50aWNhdGUnKTtcbiAgICAgICAgYXV0aG9yaXphdGlvbl9oZWFkZXJfbmFtZSA9ICdwcm94eS1hdXRob3JpemF0aW9uJztcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IGl0IHNlZW1zIGEgdmFsaWQgY2hhbGxlbmdlLlxuICAgICAgaWYgKCEgY2hhbGxlbmdlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4ocmVzcG9uc2Uuc3RhdHVzX2NvZGUgKyAnIHdpdGggd3Jvbmcgb3IgbWlzc2luZyBjaGFsbGVuZ2UsIGNhbm5vdCBhdXRoZW50aWNhdGUnKTtcbiAgICAgICAgdGhpcy5hcHBsaWNhbnQucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuY2hhbGxlbmdlZCB8fCAoIXRoaXMuc3RhbGVkICYmIGNoYWxsZW5nZS5zdGFsZSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHRoaXMudWEuY29uZmlndXJhdGlvbi5hdXRoZW50aWNhdGlvbkZhY3RvcnkodGhpcy51YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY2hhbGxlbmdlIGlzIHJlYWxseSB2YWxpZC5cbiAgICAgICAgaWYgKCF0aGlzLmNyZWRlbnRpYWxzLmF1dGhlbnRpY2F0ZSh0aGlzLnJlcXVlc3QsIGNoYWxsZW5nZSkpIHtcbiAgICAgICAgICB0aGlzLmFwcGxpY2FudC5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYWxsZW5nZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChjaGFsbGVuZ2Uuc3RhbGUpIHtcbiAgICAgICAgICB0aGlzLnN0YWxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzcG9uc2UubWV0aG9kID09PSBTSVAuQy5SRUdJU1RFUikge1xuICAgICAgICAgIGNzZXEgPSB0aGlzLmFwcGxpY2FudC5jc2VxICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXF1ZXN0LmRpYWxvZyl7XG4gICAgICAgICAgY3NlcSA9IHRoaXMucmVxdWVzdC5kaWFsb2cubG9jYWxfc2VxbnVtICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3NlcSA9IHRoaXMucmVxdWVzdC5jc2VxICsgMTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3QuY3NlcSA9IGNzZXE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcignY3NlcScsIGNzZXEgKycgJysgdGhpcy5tZXRob2QpO1xuXG4gICAgICAgIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoYXV0aG9yaXphdGlvbl9oZWFkZXJfbmFtZSwgdGhpcy5jcmVkZW50aWFscy50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5zZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGxpY2FudC5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGxpY2FudC5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgfVxufTtcblxuU0lQLlJlcXVlc3RTZW5kZXIgPSBSZXF1ZXN0U2VuZGVyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvUmVxdWVzdFNlbmRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblxudmFyIFJlZ2lzdGVyQ29udGV4dDtcblxuUmVnaXN0ZXJDb250ZXh0ID0gZnVuY3Rpb24gKHVhKSB7XG4gIHZhciBwYXJhbXMgPSB7fSxcbiAgICAgIHJlZ0lkID0gMTtcblxuICB0aGlzLnJlZ2lzdHJhciA9IHVhLmNvbmZpZ3VyYXRpb24ucmVnaXN0cmFyU2VydmVyO1xuICB0aGlzLmV4cGlyZXMgPSB1YS5jb25maWd1cmF0aW9uLnJlZ2lzdGVyRXhwaXJlcztcblxuXG4gIC8vIENvbnRhY3QgaGVhZGVyXG4gIHRoaXMuY29udGFjdCA9IHVhLmNvbnRhY3QudG9TdHJpbmcoKTtcblxuICBpZihyZWdJZCkge1xuICAgIHRoaXMuY29udGFjdCArPSAnO3JlZy1pZD0nKyByZWdJZDtcbiAgICB0aGlzLmNvbnRhY3QgKz0gJzsrc2lwLmluc3RhbmNlPVwiPHVybjp1dWlkOicrIHVhLmNvbmZpZ3VyYXRpb24uaW5zdGFuY2VJZCsnPlwiJztcbiAgfVxuXG4gIC8vIENhbGwtSUQgYW5kIENTZXEgdmFsdWVzIFJGQzMyNjEgMTAuMlxuICB0aGlzLmNhbGxfaWQgPSBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oMjIpO1xuICB0aGlzLmNzZXEgPSA4MDtcblxuICB0aGlzLnRvX3VyaSA9IHVhLmNvbmZpZ3VyYXRpb24udXJpO1xuXG4gIHBhcmFtcy50b191cmkgPSB0aGlzLnRvX3VyaTtcbiAgcGFyYW1zLnRvX2Rpc3BsYXlOYW1lID0gdWEuY29uZmlndXJhdGlvbi5kaXNwbGF5TmFtZTtcbiAgcGFyYW1zLmNhbGxfaWQgPSB0aGlzLmNhbGxfaWQ7XG4gIHBhcmFtcy5jc2VxID0gdGhpcy5jc2VxO1xuXG4gIC8vIEV4dGVuZHMgQ2xpZW50Q29udGV4dFxuICBTSVAuVXRpbHMuYXVnbWVudCh0aGlzLCBTSVAuQ2xpZW50Q29udGV4dCwgW3VhLCAnUkVHSVNURVInLCB0aGlzLnJlZ2lzdHJhciwge3BhcmFtczogcGFyYW1zfV0pO1xuXG4gIHRoaXMucmVnaXN0cmF0aW9uVGltZXIgPSBudWxsO1xuICB0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciA9IG51bGw7XG5cbiAgLy8gU2V0IHN0YXR1c1xuICB0aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnJlZ2lzdGVyY29udGV4dCcpO1xufTtcblxuUmVnaXN0ZXJDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBleHRyYUhlYWRlcnM7XG5cbiAgICAvLyBIYW5kbGUgT3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgZXh0cmFIZWFkZXJzID0gKHRoaXMub3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcgKyB0aGlzLmNvbnRhY3QgKyAnO2V4cGlyZXM9JyArIHRoaXMuZXhwaXJlcyk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnICsgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCkpO1xuXG4gICAgLy8gU2F2ZSBvcmlnaW5hbCBleHRyYUhlYWRlcnMgdG8gYmUgdXNlZCBpbiAuY2xvc2VcbiAgICB0aGlzLmNsb3NlSGVhZGVycyA9IHRoaXMub3B0aW9ucy5jbG9zZVdpdGhIZWFkZXJzID9cbiAgICAgICh0aGlzLm9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpIDogW107XG5cbiAgICB0aGlzLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB2YXIgY29udGFjdCwgZXhwaXJlcyxcbiAgICAgICAgY29udGFjdHMgPSByZXNwb25zZS5nZXRIZWFkZXJzKCdjb250YWN0JykubGVuZ3RoLFxuICAgICAgICBjYXVzZTtcblxuICAgICAgLy8gRGlzY2FyZCByZXNwb25zZXMgdG8gb2xkZXIgUkVHSVNURVIvdW4tUkVHSVNURVIgcmVxdWVzdHMuXG4gICAgICBpZihyZXNwb25zZS5jc2VxICE9PSB0aGlzLmNzZXEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciByZWdpc3RyYXRpb24gdGltZXJcbiAgICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uVGltZXIpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoKHRydWUpIHtcbiAgICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgICB0aGlzLmVtaXQoJ2FjY2VwdGVkJywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgaWYocmVzcG9uc2UuaGFzSGVhZGVyKCdleHBpcmVzJykpIHtcbiAgICAgICAgICAgIGV4cGlyZXMgPSByZXNwb25zZS5nZXRIZWFkZXIoJ2V4cGlyZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZWFyY2ggdGhlIENvbnRhY3QgcG9pbnRpbmcgdG8gdXMgYW5kIHVwZGF0ZSB0aGUgZXhwaXJlcyB2YWx1ZSBhY2NvcmRpbmdseS5cbiAgICAgICAgICBpZiAoIWNvbnRhY3RzKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdubyBDb250YWN0IGhlYWRlciBpbiByZXNwb25zZSB0byBSRUdJU1RFUiwgcmVzcG9uc2UgaWdub3JlZCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUoY29udGFjdHMtLSkge1xuICAgICAgICAgICAgY29udGFjdCA9IHJlc3BvbnNlLnBhcnNlSGVhZGVyKCdjb250YWN0JywgY29udGFjdHMpO1xuICAgICAgICAgICAgaWYoY29udGFjdC51cmkudXNlciA9PT0gdGhpcy51YS5jb250YWN0LnVyaS51c2VyKSB7XG4gICAgICAgICAgICAgIGV4cGlyZXMgPSBjb250YWN0LmdldFBhcmFtKCdleHBpcmVzJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGFjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjb250YWN0KSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdubyBDb250YWN0IGhlYWRlciBwb2ludGluZyB0byB1cywgcmVzcG9uc2UgaWdub3JlZCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIWV4cGlyZXMpIHtcbiAgICAgICAgICAgIGV4cGlyZXMgPSB0aGlzLmV4cGlyZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmUtUmVnaXN0ZXIgYmVmb3JlIHRoZSBleHBpcmF0aW9uIGludGVydmFsIGhhcyBlbGFwc2VkLlxuICAgICAgICAgIC8vIEZvciB0aGF0LCBkZWNyZWFzZSB0aGUgZXhwaXJlcyB2YWx1ZS4gaWU6IDMgc2Vjb25kc1xuICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnJlZ2lzdHJhdGlvblRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYucmVnaXN0ZXIoc2VsZi5vcHRpb25zKTtcbiAgICAgICAgICB9LCAoZXhwaXJlcyAqIDEwMDApIC0gMzAwMCk7XG4gICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5sb2dnZXIud2FybigncmVnaXN0cmF0aW9uIGV4cGlyZWQnKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgICAgc2VsZi51bnJlZ2lzdGVyZWQobnVsbCwgU0lQLkMuY2F1c2VzLkVYUElSRVMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGV4cGlyZXMgKiAxMDAwKTtcblxuICAgICAgICAgIC8vU2F2ZSBncnV1IHZhbHVlc1xuICAgICAgICAgIGlmIChjb250YWN0Lmhhc1BhcmFtKCd0ZW1wLWdydXUnKSkge1xuICAgICAgICAgICAgdGhpcy51YS5jb250YWN0LnRlbXBfZ3J1dSA9IFNJUC5VUkkucGFyc2UoY29udGFjdC5nZXRQYXJhbSgndGVtcC1ncnV1JykucmVwbGFjZSgvXCIvZywnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udGFjdC5oYXNQYXJhbSgncHViLWdydXUnKSkge1xuICAgICAgICAgICAgdGhpcy51YS5jb250YWN0LnB1Yl9ncnV1ID0gU0lQLlVSSS5wYXJzZShjb250YWN0LmdldFBhcmFtKCdwdWItZ3J1dScpLnJlcGxhY2UoL1wiL2csJycpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZW1pdCgncmVnaXN0ZXJlZCcsIHJlc3BvbnNlIHx8IG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBJbnRlcnZhbCB0b28gYnJpZWYgUkZDMzI2MSAxMC4yLjhcbiAgICAgICAgY2FzZSAvXjQyMyQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICAgIGlmKHJlc3BvbnNlLmhhc0hlYWRlcignbWluLWV4cGlyZXMnKSkge1xuICAgICAgICAgICAgLy8gSW5jcmVhc2Ugb3VyIHJlZ2lzdHJhdGlvbiBpbnRlcnZhbCB0byB0aGUgc3VnZ2VzdGVkIG1pbmltdW1cbiAgICAgICAgICAgIHRoaXMuZXhwaXJlcyA9IHJlc3BvbnNlLmdldEhlYWRlcignbWluLWV4cGlyZXMnKTtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdGhlIHJlZ2lzdHJhdGlvbiBhZ2FpbiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7IC8vVGhpcyByZXNwb25zZSBNVVNUIGNvbnRhaW4gYSBNaW4tRXhwaXJlcyBoZWFkZXIgZmllbGRcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJzQyMyByZXNwb25zZSByZWNlaXZlZCBmb3IgUkVHSVNURVIgd2l0aG91dCBNaW4tRXhwaXJlcycpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25GYWlsdXJlKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuU0lQX0ZBSUxVUkVfQ09ERSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhdXNlID0gU0lQLlV0aWxzLnNpcEVycm9yQ2F1c2UocmVzcG9uc2Uuc3RhdHVzX2NvZGUpO1xuICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uRmFpbHVyZShyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uRmFpbHVyZShudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvbkZhaWx1cmUobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH07XG5cbiAgICB0aGlzLmNzZXErKztcbiAgICB0aGlzLnJlcXVlc3QuY3NlcSA9IHRoaXMuY3NlcTtcbiAgICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKCdjc2VxJywgdGhpcy5jc2VxICsgJyBSRUdJU1RFUicpO1xuICAgIHRoaXMucmVxdWVzdC5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgdGhpcy5zZW5kKCk7XG4gIH0sXG5cbiAgcmVnaXN0cmF0aW9uRmFpbHVyZTogZnVuY3Rpb24gKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgIHRoaXMuZW1pdCgnZmFpbGVkJywgcmVzcG9uc2UgfHwgbnVsbCwgY2F1c2UgfHwgbnVsbCk7XG4gIH0sXG5cbiAgb25UcmFuc3BvcnRDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVnaXN0ZXJlZF9iZWZvcmUgPSB0aGlzLnJlZ2lzdGVyZWQ7XG4gICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uVGltZXIgIT09IG51bGwpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uVGltZXIpO1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyICE9PSBudWxsKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lcik7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYodGhpcy5yZWdpc3RlcmVkKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfVxuICB9LFxuXG4gIG9uVHJhbnNwb3J0Q29ubmVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKHRoaXMub3B0aW9ucyk7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYWxsOiBmYWxzZSxcbiAgICAgIGV4dHJhSGVhZGVyczogdGhpcy5jbG9zZUhlYWRlcnNcbiAgICB9O1xuXG4gICAgdGhpcy5yZWdpc3RlcmVkX2JlZm9yZSA9IHRoaXMucmVnaXN0ZXJlZDtcbiAgICB0aGlzLnVucmVnaXN0ZXIob3B0aW9ucyk7XG4gIH0sXG5cbiAgdW5yZWdpc3RlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBleHRyYUhlYWRlcnM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmKCF0aGlzLnJlZ2lzdGVyZWQgJiYgIW9wdGlvbnMuYWxsKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdhbHJlYWR5IHVucmVnaXN0ZXJlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcblxuICAgIHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG4gICAgLy8gQ2xlYXIgdGhlIHJlZ2lzdHJhdGlvbiB0aW1lci5cbiAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25UaW1lciAhPT0gbnVsbCkge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWdpc3RyYXRpb25UaW1lcik7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZihvcHRpb25zLmFsbCkge1xuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6IConKTtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdFeHBpcmVzOiAwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnKyB0aGlzLmNvbnRhY3QgKyAnO2V4cGlyZXM9MCcpO1xuICAgIH1cblxuXG4gICAgdGhpcy5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgdmFyIGNhdXNlO1xuXG4gICAgICBzd2l0Y2godHJ1ZSkge1xuICAgICAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICAgIHRoaXMuZW1pdCgnYWNjZXB0ZWQnLCByZXNwb25zZSk7XG4gICAgICAgICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudW5yZWdpc3RlcmVkKHJlc3BvbnNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYXVzZSA9IFNJUC5VdGlscy5zaXBFcnJvckNhdXNlKHJlc3BvbnNlLnN0YXR1c19jb2RlKTtcbiAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJlZChyZXNwb25zZSxjYXVzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gTm90IGFjdHVhbGx5IHVucmVnaXN0ZXJlZC4uLlxuICAgICAgLy90aGlzLnVucmVnaXN0ZXJlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBOb3QgYWN0dWFsbHkgdW5yZWdpc3RlcmVkLi4uXG4gICAgICAvL3RoaXMudW5yZWdpc3RlcmVkKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jc2VxKys7XG4gICAgdGhpcy5yZXF1ZXN0LmNzZXEgPSB0aGlzLmNzZXE7XG4gICAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcignY3NlcScsIHRoaXMuY3NlcSArICcgUkVHSVNURVInKTtcbiAgICB0aGlzLnJlcXVlc3QuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuXG4gICAgdGhpcy5zZW5kKCk7XG4gIH0sXG5cbiAgdW5yZWdpc3RlcmVkOiBmdW5jdGlvbihyZXNwb25zZSwgY2F1c2UpIHtcbiAgICB0aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3VucmVnaXN0ZXJlZCcsIHJlc3BvbnNlIHx8IG51bGwsIGNhdXNlIHx8IG51bGwpO1xuICB9XG5cbn07XG5cblxuU0lQLlJlZ2lzdGVyQ29udGV4dCA9IFJlZ2lzdGVyQ29udGV4dDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1JlZ2lzdGVyQ29udGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWVkaWFIYW5kbGVyXG4gKi9cblxuLyogTWVkaWFIYW5kbGVyXG4gKiBAY2xhc3MgUGVlckNvbm5lY3Rpb24gaGVscGVyIENsYXNzLlxuICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChFdmVudEVtaXR0ZXIpIHtcbnZhciBNZWRpYUhhbmRsZXIgPSBmdW5jdGlvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gIC8vIGtlZXAganNoaW50IGhhcHB5XG4gIHNlc3Npb24gPSBzZXNzaW9uO1xuICBvcHRpb25zID0gb3B0aW9ucztcbn07XG5cbk1lZGlhSGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUsIHtcbiAgaXNSZWFkeToge3ZhbHVlOiBmdW5jdGlvbiBpc1JlYWR5ICgpIHt9fSxcblxuICBjbG9zZToge3ZhbHVlOiBmdW5jdGlvbiBjbG9zZSAoKSB7fX0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbWVkaWFIaW50XSBBIGN1c3RvbSBvYmplY3QgZGVzY3JpYmluZyB0aGUgbWVkaWEgdG8gYmUgdXNlZCBkdXJpbmcgdGhpcyBzZXNzaW9uLlxuICAgKi9cbiAgZ2V0RGVzY3JpcHRpb246IHt2YWx1ZTogZnVuY3Rpb24gZ2V0RGVzY3JpcHRpb24gKG1lZGlhSGludCkge1xuICAgIC8vIGtlZXAganNoaW50IGhhcHB5XG4gICAgbWVkaWFIaW50ID0gbWVkaWFIaW50O1xuICB9fSxcblxuICAvKipcbiAgKiBNZXNzYWdlIHJlY2VwdGlvbi5cbiAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvblxuICAqL1xuICBzZXREZXNjcmlwdGlvbjoge3ZhbHVlOiBmdW5jdGlvbiBzZXREZXNjcmlwdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAvLyBrZWVwIGpzaGludCBoYXBweVxuICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIH19XG59KTtcblxucmV0dXJuIE1lZGlhSGFuZGxlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL01lZGlhSGFuZGxlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBDbGllbnRDb250ZXh0O1xuXG5DbGllbnRDb250ZXh0ID0gZnVuY3Rpb24gKHVhLCBtZXRob2QsIHRhcmdldCwgb3B0aW9ucykge1xuICB2YXIgb3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgLy8gVmFsaWRhdGUgYXJndW1lbnRzXG4gIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIH1cblxuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuY2xpZW50Y29udGV4dCcpO1xuICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgdGFyZ2V0ID0gdWEubm9ybWFsaXplVGFyZ2V0KHRhcmdldCk7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0YXJnZXQ6ICcgKyBvcmlnaW5hbFRhcmdldCk7XG4gIH1cblxuICAvKiBPcHRpb25zXG4gICAqIC0gZXh0cmFIZWFkZXJzXG4gICAqIC0gcGFyYW1zXG4gICAqIC0gY29udGVudFR5cGVcbiAgICogLSBib2R5XG4gICAqL1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcblxuICBpZiAob3B0aW9ucy5jb250ZW50VHlwZSkge1xuICAgIHRoaXMuY29udGVudFR5cGUgPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogJyArIHRoaXMuY29udGVudFR5cGUpO1xuICB9XG5cbiAgLy8gQnVpbGQgdGhlIHJlcXVlc3RcbiAgdGhpcy5yZXF1ZXN0ID0gbmV3IFNJUC5PdXRnb2luZ1JlcXVlc3QodGhpcy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzKTtcbiAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgIHRoaXMuYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICB0aGlzLnJlcXVlc3QuYm9keSA9IHRoaXMuYm9keTtcbiAgfVxuXG4gIC8qIFNldCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gdGhlIHJlcXVlc3QgKi9cbiAgdGhpcy5sb2NhbElkZW50aXR5ID0gdGhpcy5yZXF1ZXN0LmZyb207XG4gIHRoaXMucmVtb3RlSWRlbnRpdHkgPSB0aGlzLnJlcXVlc3QudG87XG5cbiAgdGhpcy5kYXRhID0ge307XG59O1xuQ2xpZW50Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuQ2xpZW50Q29udGV4dC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgKG5ldyBTSVAuUmVxdWVzdFNlbmRlcih0aGlzLCB0aGlzLnVhKSkuc2VuZCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkNsaWVudENvbnRleHQucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBjYW5jZWxfcmVhc29uID0gU0lQLlV0aWxzLmdldENhbmNlbFJlYXNvbihvcHRpb25zLnN0YXR1c19jb2RlLCBvcHRpb25zLnJlYXNvbl9waHJhc2UpO1xuICB0aGlzLnJlcXVlc3QuY2FuY2VsKGNhbmNlbF9yZWFzb24pO1xuXG4gIHRoaXMuZW1pdCgnY2FuY2VsJyk7XG59O1xuXG5DbGllbnRDb250ZXh0LnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgdmFyIGNhdXNlID0gU0lQLlV0aWxzLmdldFJlYXNvblBocmFzZShyZXNwb25zZS5zdGF0dXNfY29kZSk7XG5cbiAgc3dpdGNoKHRydWUpIHtcbiAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgaWYodGhpcy51YS5hcHBsaWNhbnRzW3RoaXNdKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVhLmFwcGxpY2FudHNbdGhpc107XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ2FjY2VwdGVkJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmKHRoaXMudWEuYXBwbGljYW50c1t0aGlzXSkge1xuICAgICAgICBkZWxldGUgdGhpcy51YS5hcHBsaWNhbnRzW3RoaXNdO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdyZWplY3RlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICBicmVhaztcbiAgfVxuXG59O1xuXG5DbGllbnRDb250ZXh0LnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xufTtcblxuQ2xpZW50Q29udGV4dC5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG59O1xuXG5TSVAuQ2xpZW50Q29udGV4dCA9IENsaWVudENvbnRleHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9DbGllbnRDb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMjMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIFNlcnZlckNvbnRleHQ7XG5cblNlcnZlckNvbnRleHQgPSBmdW5jdGlvbiAodWEsIHJlcXVlc3QpIHtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnNlcnZlcmNvbnRleHQnKTtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5JTlZJVEUpIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gbmV3IFNJUC5UcmFuc2FjdGlvbnMuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ocmVxdWVzdCwgdWEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSBuZXcgU0lQLlRyYW5zYWN0aW9ucy5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbihyZXF1ZXN0LCB1YSk7XG4gIH1cblxuICBpZiAocmVxdWVzdC5ib2R5KSB7XG4gICAgdGhpcy5ib2R5ID0gcmVxdWVzdC5ib2R5O1xuICB9XG4gIGlmIChyZXF1ZXN0Lmhhc0hlYWRlcignQ29udGVudC1UeXBlJykpIHtcbiAgICB0aGlzLmNvbnRlbnRUeXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICB9XG4gIHRoaXMubWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG5cbiAgdGhpcy5kYXRhID0ge307XG5cbiAgdGhpcy5sb2NhbElkZW50aXR5ID0gcmVxdWVzdC50bztcbiAgdGhpcy5yZW1vdGVJZGVudGl0eSA9IHJlcXVlc3QuZnJvbTtcbn07XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgb3B0aW9ucy5zdGF0dXNDb2RlIHx8IChvcHRpb25zLnN0YXR1c0NvZGUgPSAxODApO1xuICBvcHRpb25zLm1pbkNvZGUgPSAxMDA7XG4gIG9wdGlvbnMubWF4Q29kZSA9IDE5OTtcbiAgb3B0aW9ucy5ldmVudHMgPSBbJ3Byb2dyZXNzJ107XG4gIHJldHVybiB0aGlzLnJlcGx5KG9wdGlvbnMpO1xufTtcblxuU2VydmVyQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgb3B0aW9ucy5zdGF0dXNDb2RlIHx8IChvcHRpb25zLnN0YXR1c0NvZGUgPSAyMDApO1xuICBvcHRpb25zLm1pbkNvZGUgPSAyMDA7XG4gIG9wdGlvbnMubWF4Q29kZSA9IDI5OTtcbiAgb3B0aW9ucy5ldmVudHMgPSBbJ2FjY2VwdGVkJ107XG4gIHJldHVybiB0aGlzLnJlcGx5KG9wdGlvbnMpO1xufTtcblxuU2VydmVyQ29udGV4dC5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgb3B0aW9ucy5zdGF0dXNDb2RlIHx8IChvcHRpb25zLnN0YXR1c0NvZGUgPSA0ODApO1xuICBvcHRpb25zLm1pbkNvZGUgPSAzMDA7XG4gIG9wdGlvbnMubWF4Q29kZSA9IDY5OTtcbiAgb3B0aW9ucy5ldmVudHMgPSBbJ3JlamVjdGVkJywgJ2ZhaWxlZCddO1xuICByZXR1cm4gdGhpcy5yZXBseShvcHRpb25zKTtcbn07XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlLnJlcGx5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIFRoaXMgaXMgb2theSwgc28gbG9uZyBhcyB3ZSB0cmVhdCBvcHRpb25zIGFzIHJlYWQtb25seSBpbiB0aGlzIG1ldGhvZFxuICB2YXJcbiAgICBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDEwMCxcbiAgICBtaW5Db2RlID0gb3B0aW9ucy5taW5Db2RlIHx8IDEwMCxcbiAgICBtYXhDb2RlID0gb3B0aW9ucy5tYXhDb2RlIHx8IDY5OSxcbiAgICByZWFzb25QaHJhc2UgPSBTSVAuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHN0YXR1c0NvZGUsIG9wdGlvbnMucmVhc29uUGhyYXNlKSxcbiAgICBleHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSxcbiAgICBib2R5ID0gb3B0aW9ucy5ib2R5LFxuICAgIGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzIHx8IFtdLFxuICAgIHJlc3BvbnNlO1xuXG4gIGlmIChzdGF0dXNDb2RlIDwgbWluQ29kZSB8fCBzdGF0dXNDb2RlID4gbWF4Q29kZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzQ29kZTogJyArIHN0YXR1c0NvZGUpO1xuICB9XG4gIHJlc3BvbnNlID0gdGhpcy5yZXF1ZXN0LnJlcGx5KHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzLCBib2R5KTtcbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5lbWl0KGV2ZW50LCByZXNwb25zZSwgcmVhc29uUGhyYXNlKTtcbiAgfSwgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xufTtcblxuU2VydmVyQ29udGV4dC5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG59O1xuXG5TSVAuU2VydmVyQ29udGV4dCA9IFNlcnZlckNvbnRleHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TZXJ2ZXJDb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMjMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgZW52aXJvbm1lbnQpIHtcblxudmFyIERUTUYgPSByZXF1aXJlKCcuL1Nlc3Npb24vRFRNRicpKFNJUCk7XG5cbnZhciBTZXNzaW9uLCBJbnZpdGVTZXJ2ZXJDb250ZXh0LCBJbnZpdGVDbGllbnRDb250ZXh0LFxuIEMgPSB7XG4gICAgLy9TZXNzaW9uIHN0YXRlc1xuICAgIFNUQVRVU19OVUxMOiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgU1RBVFVTX0lOVklURV9TRU5UOiAgICAgICAgICAgICAgICAgMSxcbiAgICBTVEFUVVNfMVhYX1JFQ0VJVkVEOiAgICAgICAgICAgICAgICAyLFxuICAgIFNUQVRVU19JTlZJVEVfUkVDRUlWRUQ6ICAgICAgICAgICAgIDMsXG4gICAgU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUjogICAgICAgICAgNCxcbiAgICBTVEFUVVNfQU5TV0VSRUQ6ICAgICAgICAgICAgICAgICAgICA1LFxuICAgIFNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSzogICAgICAgICAgIDYsXG4gICAgU1RBVFVTX1dBSVRJTkdfRk9SX0FDSzogICAgICAgICAgICAgNyxcbiAgICBTVEFUVVNfQ0FOQ0VMRUQ6ICAgICAgICAgICAgICAgICAgICA4LFxuICAgIFNUQVRVU19URVJNSU5BVEVEOiAgICAgICAgICAgICAgICAgIDksXG4gICAgU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLOiAxMCxcbiAgICBTVEFUVVNfRUFSTFlfTUVESUE6ICAgICAgICAgICAgICAgIDExLFxuICAgIFNUQVRVU19DT05GSVJNRUQ6ICAgICAgICAgICAgICAgICAgMTJcbiAgfTtcblxuLypcbiAqIEBwYXJhbSB7ZnVuY3Rpb24gcmV0dXJuaW5nIFNJUC5NZWRpYUhhbmRsZXJ9IFttZWRpYUhhbmRsZXJGYWN0b3J5XVxuICogICAgICAgIChTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBtZWRpYUhhbmRsZXJGYWN0b3J5IGFyZ3VtZW50IG9mIHRoZSBVQSBjb25zdHJ1Y3Rvci4pXG4gKi9cblNlc3Npb24gPSBmdW5jdGlvbiAobWVkaWFIYW5kbGVyRmFjdG9yeSkge1xuICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX05VTEw7XG4gIHRoaXMuZGlhbG9nID0gbnVsbDtcbiAgdGhpcy5lYXJseURpYWxvZ3MgPSB7fTtcbiAgdGhpcy5tZWRpYUhhbmRsZXJGYWN0b3J5ID0gbWVkaWFIYW5kbGVyRmFjdG9yeSB8fCBTSVAuV2ViUlRDLk1lZGlhSGFuZGxlci5kZWZhdWx0RmFjdG9yeTtcbiAgLy8gdGhpcy5tZWRpYUhhbmRsZXIgZ2V0cyBzZXQgYnkgSUNDL0lTQyBjb25zdHJ1Y3RvcnNcbiAgdGhpcy5oYXNPZmZlciA9IGZhbHNlO1xuICB0aGlzLmhhc0Fuc3dlciA9IGZhbHNlO1xuXG4gIC8vIFNlc3Npb24gVGltZXJzXG4gIHRoaXMudGltZXJzID0ge1xuICAgIGFja1RpbWVyOiBudWxsLFxuICAgIGV4cGlyZXNUaW1lcjogbnVsbCxcbiAgICBpbnZpdGUyeHhUaW1lcjogbnVsbCxcbiAgICB1c2VyTm9BbnN3ZXJUaW1lcjogbnVsbCxcbiAgICByZWwxeHhUaW1lcjogbnVsbCxcbiAgICBwcmFja1RpbWVyOiBudWxsXG4gIH07XG5cbiAgLy8gU2Vzc2lvbiBpbmZvXG4gIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgdGhpcy5lbmRUaW1lID0gbnVsbDtcbiAgdGhpcy50b25lcyA9IG51bGw7XG5cbiAgLy8gTXV0ZS9Ib2xkIHN0YXRlXG4gIHRoaXMubG9jYWxfaG9sZCA9IGZhbHNlO1xuICB0aGlzLnJlbW90ZV9ob2xkID0gZmFsc2U7XG5cbiAgdGhpcy5wZW5kaW5nX2FjdGlvbnMgPSB7XG4gICAgYWN0aW9uczogW10sXG5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5sZW5ndGg7XG4gICAgfSxcblxuICAgIGlzUGVuZGluZzogZnVuY3Rpb24obmFtZSl7XG4gICAgICB2YXJcbiAgICAgIGlkeCA9IDAsXG4gICAgICBsZW5ndGggPSB0aGlzLmFjdGlvbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGlkeDsgaWR4PGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpZHhdLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBzaGlmdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnNoaWZ0KCk7XG4gICAgfSxcblxuICAgIHB1c2g6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMuYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHBvcDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyXG4gICAgICBpZHggPSAwLFxuICAgICAgbGVuZ3RoID0gdGhpcy5hY3Rpb25zLmxlbmd0aDtcblxuICAgICAgZm9yIChpZHg7IGlkeDxsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaWR4XS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdGhpcy5hY3Rpb25zLnNwbGljZShpZHgsMSk7XG4gICAgICAgICAgbGVuZ3RoIC0tO1xuICAgICAgICAgIGlkeC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgfTtcblxuICB0aGlzLmVhcmx5X3NkcCA9IG51bGw7XG4gIHRoaXMucmVsMTAwID0gU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEO1xufTtcblxuU2Vzc2lvbi5wcm90b3R5cGUgPSB7XG4gIGR0bWY6IGZ1bmN0aW9uKHRvbmVzLCBvcHRpb25zKSB7XG4gICAgdmFyIHRvbmUsIGR0bWZzID0gW10sXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAodG9uZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEICYmIHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdG9uZXNcbiAgICBpZiAoKHR5cGVvZiB0b25lcyAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHRvbmVzICE9PSAnbnVtYmVyJykgfHwgIXRvbmVzLnRvU3RyaW5nKCkubWF0Y2goL15bMC05QS1EIyosXSskL2kpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRvbmVzOiAnKyB0b25lcyk7XG4gICAgfVxuXG4gICAgdG9uZXMgPSB0b25lcy50b1N0cmluZygpLnNwbGl0KCcnKTtcblxuICAgIHdoaWxlICh0b25lcy5sZW5ndGggPiAwKSB7IGR0bWZzLnB1c2gobmV3IERUTUYodGhpcywgdG9uZXMuc2hpZnQoKSwgb3B0aW9ucykpOyB9XG5cbiAgICBpZiAodGhpcy50b25lcykge1xuICAgICAgLy8gVG9uZXMgYXJlIGFscmVhZHkgcXVldWVkLCBqdXN0IGFkZCB0byB0aGUgcXVldWVcbiAgICAgIHRoaXMudG9uZXMgPSAgdGhpcy50b25lcy5jb25jYXQoZHRtZnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNlbmREVE1GID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGR0bWYsIHRpbWVvdXQ7XG5cbiAgICAgIGlmIChzZWxmLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCB8fCAhc2VsZi50b25lcyB8fCBzZWxmLnRvbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBTdG9wIHNlbmRpbmcgRFRNRlxuICAgICAgICBzZWxmLnRvbmVzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGR0bWYgPSBzZWxmLnRvbmVzLnNoaWZ0KCk7XG5cbiAgICAgIGlmICh0b25lID09PSAnLCcpIHtcbiAgICAgICAgdGltZW91dCA9IDIwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkdG1mLm9uKCdmYWlsZWQnLCBmdW5jdGlvbigpe3NlbGYudG9uZXMgPSBudWxsO30pO1xuICAgICAgICBkdG1mLnNlbmQob3B0aW9ucyk7XG4gICAgICAgIHRpbWVvdXQgPSBkdG1mLmR1cmF0aW9uICsgZHRtZi5pbnRlclRvbmVHYXA7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aW1lb3V0IGZvciB0aGUgbmV4dCB0b25lXG4gICAgICBTSVAuVGltZXJzLnNldFRpbWVvdXQoc2VuZERUTUYsIHRpbWVvdXQpO1xuICAgIH07XG5cbiAgICB0aGlzLnRvbmVzID0gZHRtZnM7XG4gICAgc2VuZERUTUYoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBieWU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHZhciBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlO1xuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdFcnJvcjogQXR0ZW1wdGVkIHRvIHNlbmQgQllFIGluIGEgdGVybWluYXRlZCBzZXNzaW9uLicpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIubG9nKCd0ZXJtaW5hdGluZyBTZXNzaW9uJyk7XG5cbiAgICBpZiAoc3RhdHVzQ29kZSAmJiAoc3RhdHVzQ29kZSA8IDIwMCB8fCBzdGF0dXNDb2RlID49IDcwMCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzQ29kZTogJysgc3RhdHVzQ29kZSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHJldHVybiB0aGlzLlxuICAgICAgc2VuZFJlcXVlc3QoU0lQLkMuQllFLCBvcHRpb25zKS5cbiAgICAgIHRlcm1pbmF0ZWQoKTtcbiAgfSxcblxuICByZWZlcjogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSxcbiAgICAgICAgd2l0aFJlcGxhY2VzID1cbiAgICAgICAgICB0YXJnZXQgaW5zdGFuY2VvZiBTSVAuSW52aXRlU2VydmVyQ29udGV4dCB8fFxuICAgICAgICAgIHRhcmdldCBpbnN0YW5jZW9mIFNJUC5JbnZpdGVDbGllbnRDb250ZXh0LFxuICAgICAgICBvcmlnaW5hbFRhcmdldCA9IHRhcmdldDtcblxuICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIC8vIHRyYW5zZm9ybSBgdGFyZ2V0YCBzbyB0aGF0IGl0IGNhbiBiZSBhIFJlZmVyLVRvIGhlYWRlciB2YWx1ZVxuICAgIGlmICh3aXRoUmVwbGFjZXMpIHtcbiAgICAgIC8vQXR0ZW5kZWQgVHJhbnNmZXJcbiAgICAgIC8vIEIudHJhbnNmZXIoQylcbiAgICAgIHRhcmdldCA9ICdcIicgKyB0YXJnZXQucmVtb3RlSWRlbnRpdHkuZnJpZW5kbHlOYW1lICsgJ1wiICcgK1xuICAgICAgICAnPCcgKyB0YXJnZXQuZGlhbG9nLnJlbW90ZV90YXJnZXQudG9TdHJpbmcoKSArXG4gICAgICAgICc/UmVwbGFjZXM9JyArIHRhcmdldC5kaWFsb2cuaWQuY2FsbF9pZCArXG4gICAgICAgICclM0J0by10YWclM0QnICsgdGFyZ2V0LmRpYWxvZy5pZC5yZW1vdGVfdGFnICtcbiAgICAgICAgJyUzQmZyb20tdGFnJTNEJyArIHRhcmdldC5kaWFsb2cuaWQubG9jYWxfdGFnICsgJz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL0JsaW5kIFRyYW5zZmVyXG4gICAgICAvLyBub3JtYWxpemVUYXJnZXQgYWxsb3dzIGluc3RhbmNlcyBvZiBTSVAuVVJJIHRvIHBhc3MgdGhyb3VnaCB1bmFsdGVyZWQsXG4gICAgICAvLyBzbyB0cnkgdG8gbWFrZSBvbmUgYWhlYWQgb2YgdGltZVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGFyZ2V0ID0gU0lQLkdyYW1tYXIucGFyc2UodGFyZ2V0LCAnUmVmZXJfVG8nKS51cmkgfHwgdGFyZ2V0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIi5yZWZlcigpIGNhbm5vdCBwYXJzZSBSZWZlcl9UbyBmcm9tXCIsIHRhcmdldCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiLi4uZmFsbGluZyB0aHJvdWdoIHRvIG5vcm1hbGl6ZVRhcmdldCgpXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0YXJnZXQgdmFsaWRpdHlcbiAgICAgIHRhcmdldCA9IHRoaXMudWEubm9ybWFsaXplVGFyZ2V0KHRhcmdldCk7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRhcmdldDogJyArIG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJysgdGhpcy5jb250YWN0KTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcrIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVmZXItVG86ICcrIHRhcmdldCk7XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5SRUZFUiwge1xuICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAoICEgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKSApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZyB1cCBvbmx5IGlmIHdlIHRyYW5zZmVycmVkIHRvIGEgU0lQIGFkZHJlc3NcbiAgICAgICAgaWYgKHdpdGhSZXBsYWNlcyB8fCAodGFyZ2V0LnNjaGVtZSAmJiB0YXJnZXQuc2NoZW1lLm1hdGNoKFwiXnNpcHM/JFwiKSkpIHtcbiAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBmb2xsb3dSZWZlcjogZnVuY3Rpb24gZm9sbG93UmVmZXIgKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlZmVyTGlzdGVuZXIgKGNhbGxiYWNrLCByZXF1ZXN0KSB7XG4gICAgICAvLyBvcGVuIG5vbi1TSVAgVVJJcyBpZiBwb3NzaWJsZSBhbmQga2VlcCBzZXNzaW9uIG9wZW5cbiAgICAgIHZhciByZWZlclRvID0gcmVxdWVzdC5wYXJzZUhlYWRlcigncmVmZXItdG8nKTtcbiAgICAgIHZhciB0YXJnZXQgPSByZWZlclRvLnVyaTtcbiAgICAgIGlmICghdGFyZ2V0LnNjaGVtZS5tYXRjaChcIl5zaXBzPyRcIikpIHtcbiAgICAgICAgdmFyIHRhcmdldFN0cmluZyA9IHRhcmdldC50b1N0cmluZygpO1xuICAgICAgICBpZiAodHlwZW9mIGVudmlyb25tZW50Lm9wZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGVudmlyb25tZW50Lm9wZW4odGFyZ2V0U3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwicmVmZXJyZWQgdG8gbm9uLVNJUCBVUkkgYnV0IGBvcGVuYCBpc24ndCBpbiB0aGUgZW52aXJvbm1lbnQ6IFwiICsgdGFyZ2V0U3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXTtcblxuICAgICAgLyogQ29weSB0aGUgUmVwbGFjZXMgcXVlcnkgaW50byBhIFJlcGxhY2VzIGhlYWRlciAqL1xuICAgICAgLyogVE9ETyAtIG1ha2Ugc3VyZSB3ZSBkb24ndCBjb3B5IGEgcG9vcmx5IGZvcm1hdHRlZCBoZWFkZXI/ICovXG4gICAgICB2YXIgcmVwbGFjZXMgPSB0YXJnZXQuZ2V0SGVhZGVyKCdSZXBsYWNlcycpO1xuICAgICAgaWYgKHJlcGxhY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JlcGxhY2VzOiAnICsgZGVjb2RlVVJJQ29tcG9uZW50KHJlcGxhY2VzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbid0IGVtYmVkIGhlYWRlcnMgaW50byBSZXF1ZXN0LVVSSSBvZiBJTlZJVEVcbiAgICAgIHRhcmdldC5jbGVhckhlYWRlcnMoKTtcblxuICAgICAgLypcbiAgICAgICAgSGFybWxlc3MgcmFjZSBjb25kaXRpb24uICBCb3RoIHNpZGVzIG9mIFJFRkVSXG4gICAgICAgIG1heSBzZW5kIGEgQllFLCBidXQgaW4gdGhlIGVuZCB0aGUgZGlhbG9ncyBhcmUgZGVzdHJveWVkLlxuICAgICAgKi9cbiAgICAgIHZhciBnZXRSZWZlck1lZGlhID0gdGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVmZXJNZWRpYTtcbiAgICAgIHZhciBtZWRpYUhpbnQgPSBnZXRSZWZlck1lZGlhID8gZ2V0UmVmZXJNZWRpYS5jYWxsKHRoaXMubWVkaWFIYW5kbGVyKSA6IHRoaXMubWVkaWFIaW50O1xuXG4gICAgICBTSVAuSGFja3MuQ2hyb21lLmdldHNDb25mdXNlZEFib3V0R1VNKHRoaXMpO1xuXG4gICAgICB2YXIgcmVmZXJTZXNzaW9uID0gdGhpcy51YS5pbnZpdGUodGFyZ2V0LCB7XG4gICAgICAgIG1lZGlhOiBtZWRpYUhpbnQsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIHRvX2Rpc3BsYXlOYW1lOiByZWZlclRvLmZyaWVuZGx5TmFtZVxuICAgICAgICB9LFxuICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVyc1xuICAgICAgfSk7XG5cbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgcmVxdWVzdCwgcmVmZXJTZXNzaW9uKTtcblxuICAgICAgdGhpcy50ZXJtaW5hdGUoKTtcbiAgICB9LmJpbmQodGhpcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIHNlbmRSZXF1ZXN0OiBmdW5jdGlvbihtZXRob2Qsb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFNJUC5PdXRnb2luZ1JlcXVlc3QoXG4gICAgICBtZXRob2QsXG4gICAgICB0aGlzLmRpYWxvZy5yZW1vdGVfdGFyZ2V0LFxuICAgICAgdGhpcy51YSxcbiAgICAgIHtcbiAgICAgICAgY3NlcTogb3B0aW9ucy5jc2VxIHx8ICh0aGlzLmRpYWxvZy5sb2NhbF9zZXFudW0gKz0gMSksXG4gICAgICAgIGNhbGxfaWQ6IHRoaXMuZGlhbG9nLmlkLmNhbGxfaWQsXG4gICAgICAgIGZyb21fdXJpOiB0aGlzLmRpYWxvZy5sb2NhbF91cmksXG4gICAgICAgIGZyb21fdGFnOiB0aGlzLmRpYWxvZy5pZC5sb2NhbF90YWcsXG4gICAgICAgIHRvX3VyaTogdGhpcy5kaWFsb2cucmVtb3RlX3VyaSxcbiAgICAgICAgdG9fdGFnOiB0aGlzLmRpYWxvZy5pZC5yZW1vdGVfdGFnLFxuICAgICAgICByb3V0ZV9zZXQ6IHRoaXMuZGlhbG9nLnJvdXRlX3NldCxcbiAgICAgICAgc3RhdHVzQ29kZTogb3B0aW9ucy5zdGF0dXNDb2RlLFxuICAgICAgICByZWFzb25QaHJhc2U6IG9wdGlvbnMucmVhc29uUGhyYXNlXG4gICAgICB9LFxuICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10sXG4gICAgICBvcHRpb25zLmJvZHlcbiAgICApO1xuXG4gICAgbmV3IFNJUC5SZXF1ZXN0U2VuZGVyKHtcbiAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICB9LFxuICAgICAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgfSxcbiAgICAgIHJlY2VpdmVSZXNwb25zZTogb3B0aW9ucy5yZWNlaXZlUmVzcG9uc2UgfHwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgc2VsZi5yZWNlaXZlTm9uSW52aXRlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sIHRoaXMudWEpLnNlbmQoKTtcblxuICAgIC8vIEVtaXQgdGhlIHJlcXVlc3QgZXZlbnRcbiAgICB0aGlzLmVtaXQobWV0aG9kLnRvTG93ZXJDYXNlKCksIHJlcXVlc3QpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZHg7XG5cbiAgICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIubG9nKCdjbG9zaW5nIElOVklURSBzZXNzaW9uICcgKyB0aGlzLmlkKTtcblxuICAgIC8vIDFzdCBTdGVwLiBUZXJtaW5hdGUgbWVkaWEuXG4gICAgaWYgKHRoaXMubWVkaWFIYW5kbGVyKXtcbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gMm5kIFN0ZXAuIFRlcm1pbmF0ZSBzaWduYWxpbmcuXG5cbiAgICAvLyBDbGVhciBzZXNzaW9uIHRpbWVyc1xuICAgIGZvcihpZHggaW4gdGhpcy50aW1lcnMpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzW2lkeF0pO1xuICAgIH1cblxuICAgIC8vIFRlcm1pbmF0ZSBkaWFsb2dzXG5cbiAgICAvLyBUZXJtaW5hdGUgY29uZmlybWVkIGRpYWxvZ1xuICAgIGlmKHRoaXMuZGlhbG9nKSB7XG4gICAgICB0aGlzLmRpYWxvZy50ZXJtaW5hdGUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRpYWxvZztcbiAgICB9XG5cbiAgICAvLyBUZXJtaW5hdGUgZWFybHkgZGlhbG9nc1xuICAgIGZvcihpZHggaW4gdGhpcy5lYXJseURpYWxvZ3MpIHtcbiAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkeF0udGVybWluYXRlKCk7XG4gICAgICBkZWxldGUgdGhpcy5lYXJseURpYWxvZ3NbaWR4XTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX1RFUk1JTkFURUQ7XG5cbiAgICBkZWxldGUgdGhpcy51YS5zZXNzaW9uc1t0aGlzLmlkXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjcmVhdGVEaWFsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIHR5cGUsIGVhcmx5KSB7XG4gICAgdmFyIGRpYWxvZywgZWFybHlfZGlhbG9nLFxuICAgICAgbG9jYWxfdGFnID0gbWVzc2FnZVsodHlwZSA9PT0gJ1VBUycpID8gJ3RvX3RhZycgOiAnZnJvbV90YWcnXSxcbiAgICAgIHJlbW90ZV90YWcgPSBtZXNzYWdlWyh0eXBlID09PSAnVUFTJykgPyAnZnJvbV90YWcnIDogJ3RvX3RhZyddLFxuICAgICAgaWQgPSBtZXNzYWdlLmNhbGxfaWQgKyBsb2NhbF90YWcgKyByZW1vdGVfdGFnO1xuXG4gICAgZWFybHlfZGlhbG9nID0gdGhpcy5lYXJseURpYWxvZ3NbaWRdO1xuXG4gICAgLy8gRWFybHkgRGlhbG9nXG4gICAgaWYgKGVhcmx5KSB7XG4gICAgICBpZiAoZWFybHlfZGlhbG9nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFybHlfZGlhbG9nID0gbmV3IFNJUC5EaWFsb2codGhpcywgbWVzc2FnZSwgdHlwZSwgU0lQLkRpYWxvZy5DLlNUQVRVU19FQVJMWSk7XG5cbiAgICAgICAgLy8gRGlhbG9nIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjcmVhdGVkLlxuICAgICAgICBpZihlYXJseV9kaWFsb2cuZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlYXJseV9kaWFsb2cuZXJyb3IpO1xuICAgICAgICAgIHRoaXMuZmFpbGVkKG1lc3NhZ2UsIFNJUC5DLmNhdXNlcy5JTlRFUk5BTF9FUlJPUik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkXSA9IGVhcmx5X2RpYWxvZztcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBDb25maXJtZWQgRGlhbG9nXG4gICAgZWxzZSB7XG4gICAgICAvLyBJbiBjYXNlIHRoZSBkaWFsb2cgaXMgaW4gX2Vhcmx5XyBzdGF0ZSwgdXBkYXRlIGl0XG4gICAgICBpZiAoZWFybHlfZGlhbG9nKSB7XG4gICAgICAgIGVhcmx5X2RpYWxvZy51cGRhdGUobWVzc2FnZSwgdHlwZSk7XG4gICAgICAgIHRoaXMuZGlhbG9nID0gZWFybHlfZGlhbG9nO1xuICAgICAgICBkZWxldGUgdGhpcy5lYXJseURpYWxvZ3NbaWRdO1xuICAgICAgICBmb3IgKHZhciBkaWEgaW4gdGhpcy5lYXJseURpYWxvZ3MpIHtcbiAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9nc1tkaWFdLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmVhcmx5RGlhbG9nc1tkaWFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIF9jb25maXJtZWRfIGRpYWxvZ1xuICAgICAgZGlhbG9nID0gbmV3IFNJUC5EaWFsb2codGhpcywgbWVzc2FnZSwgdHlwZSk7XG5cbiAgICAgIGlmKGRpYWxvZy5lcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihkaWFsb2cuZXJyb3IpO1xuICAgICAgICB0aGlzLmZhaWxlZChtZXNzYWdlLCBTSVAuQy5jYXVzZXMuSU5URVJOQUxfRVJST1IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvX3RhZyA9IG1lc3NhZ2UudG9fdGFnO1xuICAgICAgICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIENoZWNrIGlmIFNlc3Npb24gaXMgcmVhZHkgZm9yIGEgcmUtSU5WSVRFXG4gICpcbiAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgKi9cbiAgaXNSZWFkeVRvUmVpbnZpdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lZGlhSGFuZGxlci5pc1JlYWR5KCkgJiZcbiAgICAgICF0aGlzLmRpYWxvZy51YWNfcGVuZGluZ19yZXBseSAmJlxuICAgICAgIXRoaXMuZGlhbG9nLnVhc19wZW5kaW5nX3JlcGx5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBNdXRlXG4gICAqL1xuICBtdXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHJldCA9IHRoaXMubWVkaWFIYW5kbGVyLm11dGUob3B0aW9ucyk7XG4gICAgaWYgKHJldCkge1xuICAgICAgdGhpcy5vbm11dGUocmV0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubXV0ZVxuICAgKi9cbiAgdW5tdXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHJldCA9IHRoaXMubWVkaWFIYW5kbGVyLnVubXV0ZShvcHRpb25zKTtcbiAgICBpZiAocmV0KSB7XG4gICAgICB0aGlzLm9udW5tdXRlKHJldCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIb2xkXG4gICAqL1xuICBob2xkOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSyAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIHRoaXMubWVkaWFIYW5kbGVyLmhvbGQoKTtcblxuICAgIC8vIENoZWNrIGlmIFJUQ1Nlc3Npb24gaXMgcmVhZHkgdG8gc2VuZCBhIHJlSU5WSVRFXG4gICAgaWYgKCF0aGlzLmlzUmVhZHlUb1JlaW52aXRlKCkpIHtcbiAgICAgIC8qIElmIHRoZXJlIGlzIGEgcGVuZGluZyAndW5ob2xkJyBhY3Rpb24sIGNhbmNlbCBpdCBhbmQgZG9uJ3QgcXVldWUgdGhpcyBvbmVcbiAgICAgICAqIEVsc2UsIGlmIHRoZXJlIGlzbid0IGFueSAnaG9sZCcgYWN0aW9uLCBhZGQgdGhpcyBvbmUgdG8gdGhlIHF1ZXVlXG4gICAgICAgKiBFbHNlLCBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ2hvbGQnIGFjdGlvbiwgc2tpcFxuICAgICAgICovXG4gICAgICBpZiAodGhpcy5wZW5kaW5nX2FjdGlvbnMuaXNQZW5kaW5nKCd1bmhvbGQnKSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdfYWN0aW9ucy5wb3AoJ3VuaG9sZCcpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5wZW5kaW5nX2FjdGlvbnMuaXNQZW5kaW5nKCdob2xkJykpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2FjdGlvbnMucHVzaCgnaG9sZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbF9ob2xkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9uaG9sZCgnbG9jYWwnKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMubWFuZ2xlID0gZnVuY3Rpb24oYm9keSl7XG5cbiAgICAgIC8vIERvbid0IHJlY2VpdmUgbWVkaWFcbiAgICAgIC8vIFRPRE8gLSBUaGlzIHdpbGwgYnJlYWsgZm9yIG1lZGlhIHN0cmVhbXMgd2l0aCBkaWZmZXJlbnQgZGlyZWN0aW9ucy5cbiAgICAgIGlmICghKC9hPShzZW5kcmVjdnxzZW5kb25seXxyZWN2b25seXxpbmFjdGl2ZSkvKS50ZXN0KGJvZHkpKSB7XG4gICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoLyhtPVteXFxyXSpcXHJcXG4pL2csICckMWE9c2VuZG9ubHlcXHJcXG4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoL2E9c2VuZHJlY3ZcXHJcXG4vZywgJ2E9c2VuZG9ubHlcXHJcXG4nKTtcbiAgICAgICAgYm9keSA9IGJvZHkucmVwbGFjZSgvYT1yZWN2b25seVxcclxcbi9nLCAnYT1pbmFjdGl2ZVxcclxcbicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZW5kUmVpbnZpdGUob3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuaG9sZFxuICAgKi9cbiAgdW5ob2xkOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSyAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIHRoaXMubWVkaWFIYW5kbGVyLnVuaG9sZCgpO1xuXG4gICAgaWYgKCF0aGlzLmlzUmVhZHlUb1JlaW52aXRlKCkpIHtcbiAgICAgIC8qIElmIHRoZXJlIGlzIGEgcGVuZGluZyAnaG9sZCcgYWN0aW9uLCBjYW5jZWwgaXQgYW5kIGRvbid0IHF1ZXVlIHRoaXMgb25lXG4gICAgICAgKiBFbHNlLCBpZiB0aGVyZSBpc24ndCBhbnkgJ3VuaG9sZCcgYWN0aW9uLCBhZGQgdGhpcyBvbmUgdG8gdGhlIHF1ZXVlXG4gICAgICAgKiBFbHNlLCBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ3VuaG9sZCcgYWN0aW9uLCBza2lwXG4gICAgICAgKi9cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdfYWN0aW9ucy5pc1BlbmRpbmcoJ2hvbGQnKSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdfYWN0aW9ucy5wb3AoJ2hvbGQnKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucGVuZGluZ19hY3Rpb25zLmlzUGVuZGluZygndW5ob2xkJykpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2FjdGlvbnMucHVzaCgndW5ob2xkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLmxvY2FsX2hvbGQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vbnVuaG9sZCgnbG9jYWwnKTtcblxuICAgIHRoaXMuc2VuZFJlaW52aXRlKG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBpc09uSG9sZFxuICAgKi9cbiAgaXNPbkhvbGQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhbDogdGhpcy5sb2NhbF9ob2xkLFxuICAgICAgcmVtb3RlOiB0aGlzLnJlbW90ZV9ob2xkXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogSW4gZGlhbG9nIElOVklURSBSZWNlcHRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlY2VpdmVSZWludml0ZTogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghcmVxdWVzdC5ib2R5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKSAhPT0gJ2FwcGxpY2F0aW9uL3NkcCcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2ludmFsaWQgQ29udGVudC1UeXBlJyk7XG4gICAgICByZXF1ZXN0LnJlcGx5KDQxNSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVxdWVzdC5ib2R5KVxuICAgIC50aGVuKHRoaXMubWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uLmJpbmQodGhpcy5tZWRpYUhhbmRsZXIsIHRoaXMubWVkaWFIaW50KSlcbiAgICAudGhlbihmdW5jdGlvbihib2R5KSB7XG4gICAgICByZXF1ZXN0LnJlcGx5KDIwMCwgbnVsbCwgWydDb250YWN0OiAnICsgc2VsZi5jb250YWN0XSwgYm9keSxcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5zdGF0dXMgPSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0s7XG4gICAgICAgICAgc2VsZi5zZXRJbnZpdGUyeHhUaW1lcihyZXF1ZXN0LCBib2R5KTtcbiAgICAgICAgICBzZWxmLnNldEFDS1RpbWVyKCk7XG5cbiAgICAgICAgICAvLyBBcmUgd2UgaG9sZGluZz9cbiAgICAgICAgICB2YXIgaG9sZCA9ICgvYT0oc2VuZG9ubHl8aW5hY3RpdmUpLykudGVzdChyZXF1ZXN0LmJvZHkpO1xuXG4gICAgICAgICAgaWYgKHNlbGYucmVtb3RlX2hvbGQgJiYgIWhvbGQpIHtcbiAgICAgICAgICAgIHNlbGYub251bmhvbGQoJ3JlbW90ZScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXNlbGYucmVtb3RlX2hvbGQgJiYgaG9sZCkge1xuICAgICAgICAgICAgc2VsZi5vbmhvbGQoJ3JlbW90ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAuY2F0Y2goZnVuY3Rpb24gb25GYWlsdXJlIChlKSB7XG4gICAgICB2YXIgc3RhdHVzQ29kZTtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU0lQLkV4Y2VwdGlvbnMuR2V0RGVzY3JpcHRpb25FcnJvcikge1xuICAgICAgICBzdGF0dXNDb2RlID0gNTAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoZSk7XG4gICAgICAgIHN0YXR1c0NvZGUgPSA0ODg7XG4gICAgICB9XG4gICAgICByZXF1ZXN0LnJlcGx5KHN0YXR1c0NvZGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIHNlbmRSZWludml0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSxcbiAgICAgIGV2ZW50SGFuZGxlcnMgPSBvcHRpb25zLmV2ZW50SGFuZGxlcnMgfHwge30sXG4gICAgICBtYW5nbGUgPSBvcHRpb25zLm1hbmdsZSB8fCBudWxsLFxuICAgICAgc3VjY2VlZGVkO1xuXG4gICAgaWYgKGV2ZW50SGFuZGxlcnMuc3VjY2VlZGVkKSB7XG4gICAgICBzdWNjZWVkZWQgPSBldmVudEhhbmRsZXJzLnN1Y2NlZWRlZDtcbiAgICB9XG4gICAgdGhpcy5yZWludml0ZVN1Y2NlZWRlZCA9IGZ1bmN0aW9uKCl7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dChzZWxmLnRpbWVycy5hY2tUaW1lcik7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dChzZWxmLnRpbWVycy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICBzZWxmLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgIHN1Y2NlZWRlZCAmJiBzdWNjZWVkZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIGlmIChldmVudEhhbmRsZXJzLmZhaWxlZCkge1xuICAgICAgdGhpcy5yZWludml0ZUZhaWxlZCA9IGV2ZW50SGFuZGxlcnMuZmFpbGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlaW52aXRlRmFpbGVkID0gZnVuY3Rpb24oKXt9O1xuICAgIH1cblxuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnICsgdGhpcy5jb250YWN0KTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcrIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9zZHAnKTtcblxuICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlID0gdGhpcy5yZWNlaXZlUmVpbnZpdGVSZXNwb25zZTtcbiAgICAvL1JFVklTSVRcbiAgICB0aGlzLm1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbihzZWxmLm1lZGlhSGludClcbiAgICAudGhlbihtYW5nbGUpXG4gICAgLnRoZW4oXG4gICAgICBmdW5jdGlvbihib2R5KXtcbiAgICAgICAgc2VsZi5kaWFsb2cuc2VuZFJlcXVlc3Qoc2VsZiwgU0lQLkMuSU5WSVRFLCB7XG4gICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgYm9keTogYm9keVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuaXNSZWFkeVRvUmVpbnZpdGUoKSkge1xuICAgICAgICAgIHNlbGYub25SZWFkeVRvUmVpbnZpdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnJlaW52aXRlRmFpbGVkKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfSxcblxuICByZWNlaXZlUmVxdWVzdDogZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICBzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgICBjYXNlIFNJUC5DLkJZRTpcbiAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuICAgICAgICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdieWUnLCByZXF1ZXN0KTtcbiAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJZRSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLklOVklURTpcbiAgICAgICAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygncmUtSU5WSVRFIHJlY2VpdmVkJyk7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlUmVpbnZpdGUocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLklORk86XG4gICAgICAgIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQgfHwgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICAgIHZhciBib2R5LCB0b25lLCBkdXJhdGlvbixcbiAgICAgICAgICAgICAgY29udGVudFR5cGUgPSByZXF1ZXN0LmdldEhlYWRlcignY29udGVudC10eXBlJyksXG4gICAgICAgICAgICAgIHJlZ190b25lID0gL14oU2lnbmFsXFxzKj89XFxzKj8pKFswLTlBLUQjKl17MX0pKFxccyk/LiovLFxuICAgICAgICAgICAgICByZWdfZHVyYXRpb24gPSAvXihEdXJhdGlvblxccz89XFxzPykoWzAtOV17MSw0fSkoXFxzKT8uKi87XG5cbiAgICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZS5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvZHRtZi1yZWxheS9pKSkge1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHJlcXVlc3QuYm9keS5zcGxpdCgnXFxyXFxuJywgMik7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVnX3RvbmUudGVzdChib2R5WzBdKSkge1xuICAgICAgICAgICAgICAgICAgICB0b25lID0gYm9keVswXS5yZXBsYWNlKHJlZ190b25lLFwiJDJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocmVnX2R1cmF0aW9uLnRlc3QoYm9keVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBwYXJzZUludChib2R5WzFdLnJlcGxhY2UocmVnX2R1cmF0aW9uLFwiJDJcIiksIDEwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuZXcgRFRNRih0aGlzLCB0b25lLCB7ZHVyYXRpb246IGR1cmF0aW9ufSkuaW5pdF9pbmNvbWluZyhyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoNDE1LCBudWxsLCBbXCJBY2NlcHQ6IGFwcGxpY2F0aW9uL2R0bWYtcmVsYXlcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuUkVGRVI6XG4gICAgICAgIGlmKHRoaXMuc3RhdHVzID09PSAgQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdSRUZFUiByZWNlaXZlZCcpO1xuICAgICAgICAgIHZhciBoYXNSZWZlckxpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnMoJ3JlZmVyJykubGVuZ3RoLFxuICAgICAgICAgICAgICBub3RpZnlCb2R5O1xuXG4gICAgICAgICAgaWYgKGhhc1JlZmVyTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoMjAyLCAnQWNjZXB0ZWQnKTtcbiAgICAgICAgICAgIG5vdGlmeUJvZHkgPSAnU0lQLzIuMCAxMDAgVHJ5aW5nJztcblxuICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5OT1RJRlksIHtcbiAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOltcbiAgICAgICAgICAgICAgICAnRXZlbnQ6IHJlZmVyJyxcbiAgICAgICAgICAgICAgICAnU3Vic2NyaXB0aW9uLVN0YXRlOiB0ZXJtaW5hdGVkJyxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlOiBtZXNzYWdlL3NpcGZyYWcnXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGJvZHk6IG5vdGlmeUJvZHksXG4gICAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVmZXInLCByZXF1ZXN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUkZDIDM1MTUuMi40LjI6ICd0aGUgVUEgTUFZIGRlY2xpbmUgdGhlIHJlcXVlc3QuJ1xuICAgICAgICAgICAgcmVxdWVzdC5yZXBseSg2MDMsICdEZWNsaW5lZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuTk9USUZZOlxuICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMCwgJ09LJyk7XG4gICAgICAgIHRoaXMuZW1pdCgnbm90aWZ5JywgcmVxdWVzdCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZXB0aW9uIG9mIFJlc3BvbnNlIGZvciBpbi1kaWFsb2cgSU5WSVRFXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWNlaXZlUmVpbnZpdGVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKTtcblxuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCh0cnVlKSB7XG4gICAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcblxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSyx7Y3NlcTpyZXNwb25zZS5jc2VxfSk7XG5cbiAgICAgICAgaWYoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICB0aGlzLnJlaW52aXRlRmFpbGVkKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGVudFR5cGUgIT09ICdhcHBsaWNhdGlvbi9zZHAnKSB7XG4gICAgICAgICAgdGhpcy5yZWludml0ZUZhaWxlZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9SRVZJU0lUXG4gICAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyAoKSB7XG4gICAgICAgICAgICBzZWxmLnJlaW52aXRlU3VjY2VlZGVkKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUgKCkge1xuICAgICAgICAgICAgc2VsZi5yZWludml0ZUZhaWxlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJlaW52aXRlRmFpbGVkKCk7XG4gICAgfVxuICB9LFxuXG4gIGFjY2VwdEFuZFRlcm1pbmF0ZTogZnVuY3Rpb24ocmVzcG9uc2UsIHN0YXR1c19jb2RlLCByZWFzb25fcGhyYXNlKSB7XG4gICAgdmFyIGV4dHJhSGVhZGVycyA9IFtdO1xuXG4gICAgaWYgKHN0YXR1c19jb2RlKSB7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVhc29uOiAnICsgU0lQLlV0aWxzLmdldFJlYXNvbkhlYWRlclZhbHVlKHN0YXR1c19jb2RlLCByZWFzb25fcGhyYXNlKSk7XG4gICAgfVxuXG4gICAgLy8gQW4gZXJyb3Igb24gZGlhbG9nIGNyZWF0aW9uIHdpbGwgZmlyZSAnZmFpbGVkJyBldmVudFxuICAgIGlmICh0aGlzLmRpYWxvZyB8fCB0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycpKSB7XG4gICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSyx7Y3NlcTogcmVzcG9uc2UuY3NlcX0pO1xuICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5CWUUsIHtcbiAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSRkMzMjYxIDEzLjMuMS40XG4gICAqIFJlc3BvbnNlIHJldHJhbnNtaXNzaW9ucyBjYW5ub3QgYmUgYWNjb21wbGlzaGVkIGJ5IHRyYW5zYWN0aW9uIGxheWVyXG4gICAqICBzaW5jZSBpdCBpcyBkZXN0cm95ZWQgd2hlbiByZWNlaXZpbmcgdGhlIGZpcnN0IDJ4eCBhbnN3ZXJcbiAgICovXG4gIHNldEludml0ZTJ4eFRpbWVyOiBmdW5jdGlvbihyZXF1ZXN0LCBib2R5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0aW1lb3V0ID0gU0lQLlRpbWVycy5UMTtcblxuICAgIHRoaXMudGltZXJzLmludml0ZTJ4eFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uIGludml0ZTJ4eFJldHJhbnNtaXNzaW9uKCkge1xuICAgICAgaWYgKHNlbGYuc3RhdHVzICE9PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ25vIEFDSyByZWNlaXZlZCwgYXR0ZW1wdGluZyB0byByZXRyYW5zbWl0IE9LJyk7XG5cbiAgICAgIHJlcXVlc3QucmVwbHkoMjAwLCBudWxsLCBbJ0NvbnRhY3Q6ICcgKyBzZWxmLmNvbnRhY3RdLCBib2R5KTtcblxuICAgICAgdGltZW91dCA9IE1hdGgubWluKHRpbWVvdXQgKiAyLCBTSVAuVGltZXJzLlQyKTtcblxuICAgICAgc2VsZi50aW1lcnMuaW52aXRlMnh4VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoaW52aXRlMnh4UmV0cmFuc21pc3Npb24sIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSRkMzMjYxIDE0LjJcbiAgICogSWYgYSBVQVMgZ2VuZXJhdGVzIGEgMnh4IHJlc3BvbnNlIGFuZCBuZXZlciByZWNlaXZlcyBhbiBBQ0ssXG4gICAqICBpdCBTSE9VTEQgZ2VuZXJhdGUgYSBCWUUgdG8gdGVybWluYXRlIHRoZSBkaWFsb2cuXG4gICAqL1xuICBzZXRBQ0tUaW1lcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy50aW1lcnMuYWNrVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZihzZWxmLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLmxvZygnbm8gQUNLIHJlY2VpdmVkIGZvciBhbiBleHRlbmRlZCBwZXJpb2Qgb2YgdGltZSwgdGVybWluYXRpbmcgdGhlIGNhbGwnKTtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQoc2VsZi50aW1lcnMuaW52aXRlMnh4VGltZXIpO1xuICAgICAgICBzZWxmLnNlbmRSZXF1ZXN0KFNJUC5DLkJZRSk7XG4gICAgICAgIHNlbGYudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuTk9fQUNLKTtcbiAgICAgIH1cbiAgICB9LCBTSVAuVGltZXJzLlRJTUVSX0gpO1xuICB9LFxuXG4gIC8qXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblJlYWR5VG9SZWludml0ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFjdGlvbiA9IHRoaXMucGVuZGluZ19hY3Rpb25zLnNoaWZ0KCk7XG5cbiAgICBpZiAoIWFjdGlvbiB8fCAhdGhpc1thY3Rpb24ubmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzW2FjdGlvbi5uYW1lXSgpO1xuICB9LFxuXG4gIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEICYmIHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfVxuICB9LFxuXG4gIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfVxuICB9LFxuXG4gIG9uRGlhbG9nRXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMudGVybWluYXRlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5ESUFMT0dfRVJST1IpO1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuRElBTE9HX0VSUk9SKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbmhvbGQ6IGZ1bmN0aW9uKG9yaWdpbmF0b3IpIHtcbiAgICB0aGlzW29yaWdpbmF0b3IgPT09ICdsb2NhbCcgPyAnbG9jYWxfaG9sZCcgOiAncmVtb3RlX2hvbGQnXSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdob2xkJywgeyBvcmlnaW5hdG9yOiBvcmlnaW5hdG9yIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb251bmhvbGQ6IGZ1bmN0aW9uKG9yaWdpbmF0b3IpIHtcbiAgICB0aGlzW29yaWdpbmF0b3IgPT09ICdsb2NhbCcgPyAnbG9jYWxfaG9sZCcgOiAncmVtb3RlX2hvbGQnXSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgndW5ob2xkJywgeyBvcmlnaW5hdG9yOiBvcmlnaW5hdG9yIH0pO1xuICB9LFxuXG4gIC8qXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbm11dGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmVtaXQoJ211dGVkJywge1xuICAgICAgYXVkaW86IG9wdGlvbnMuYXVkaW8sXG4gICAgICB2aWRlbzogb3B0aW9ucy52aWRlb1xuICAgIH0pO1xuICB9LFxuXG4gIC8qXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbnVubXV0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuZW1pdCgndW5tdXRlZCcsIHtcbiAgICAgIGF1ZGlvOiBvcHRpb25zLmF1ZGlvLFxuICAgICAgdmlkZW86IG9wdGlvbnMudmlkZW9cbiAgICB9KTtcbiAgfSxcblxuICBmYWlsZWQ6IGZ1bmN0aW9uKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnZmFpbGVkJywgcmVzcG9uc2UgfHwgbnVsbCwgY2F1c2UgfHwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVqZWN0ZWQ6IGZ1bmN0aW9uKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgIHRoaXMuZW1pdCgncmVqZWN0ZWQnLFxuICAgICAgcmVzcG9uc2UgfHwgbnVsbCxcbiAgICAgIGNhdXNlIHx8IG51bGxcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNhbmNlbGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVtaXQoJ2NhbmNlbCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGFjY2VwdGVkOiBmdW5jdGlvbihyZXNwb25zZSwgY2F1c2UpIHtcbiAgICBjYXVzZSA9IFNJUC5VdGlscy5nZXRSZWFzb25QaHJhc2UocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUsIGNhdXNlKTtcblxuICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcblxuICAgIGlmICh0aGlzLnJlcGxhY2VlKSB7XG4gICAgICB0aGlzLnJlcGxhY2VlLmVtaXQoJ3JlcGxhY2VkJywgdGhpcyk7XG4gICAgICB0aGlzLnJlcGxhY2VlLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2FjY2VwdGVkJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0ZXJtaW5hdGVkOiBmdW5jdGlvbihtZXNzYWdlLCBjYXVzZSkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5lbmRUaW1lID0gbmV3IERhdGUoKTtcblxuICAgIHRoaXMuY2xvc2UoKTtcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLFxuICAgICAgbWVzc2FnZSB8fCBudWxsLFxuICAgICAgY2F1c2UgfHwgbnVsbFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY29ubmVjdGluZzogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdGluZycsIHsgcmVxdWVzdDogcmVxdWVzdCB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuU2Vzc2lvbi5kZXN1Z2FyID0gZnVuY3Rpb24gZGVzdWdhcihvcHRpb25zKSB7XG4gIGlmIChlbnZpcm9ubWVudC5IVE1MTWVkaWFFbGVtZW50ICYmIG9wdGlvbnMgaW5zdGFuY2VvZiBlbnZpcm9ubWVudC5IVE1MTWVkaWFFbGVtZW50KSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1lZGlhOiB7XG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICAgICAgdmlkZW86IG9wdGlvbnMudGFnTmFtZSA9PT0gJ1ZJREVPJ1xuICAgICAgICB9LFxuICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICByZW1vdGU6IG9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMgfHwge307XG59O1xuXG5cblNlc3Npb24uQyA9IEM7XG5TSVAuU2Vzc2lvbiA9IFNlc3Npb247XG5cblxuSW52aXRlU2VydmVyQ29udGV4dCA9IGZ1bmN0aW9uKHVhLCByZXF1ZXN0KSB7XG4gIHZhciBleHBpcmVzLFxuICAgIHNlbGYgPSB0aGlzLFxuICAgIGNvbnRlbnRUeXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpLFxuICAgIGNvbnRlbnREaXNwID0gcmVxdWVzdC5wYXJzZUhlYWRlcignQ29udGVudC1EaXNwb3NpdGlvbicpO1xuXG4gIC8vIENoZWNrIGJvZHkgYW5kIGNvbnRlbnQgdHlwZVxuICBpZiAoKCFjb250ZW50RGlzcCAmJiBjb250ZW50VHlwZSAhPT0gJ2FwcGxpY2F0aW9uL3NkcCcpIHx8IChjb250ZW50RGlzcCAmJiBjb250ZW50RGlzcC50eXBlID09PSAncmVuZGVyJykpIHtcbiAgICB0aGlzLnJlbmRlcmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgdGhpcy5yZW5kZXJ0eXBlID0gY29udGVudFR5cGU7XG4gIH0gZWxzZSBpZiAoY29udGVudFR5cGUgIT09ICdhcHBsaWNhdGlvbi9zZHAnICYmIChjb250ZW50RGlzcCAmJiBjb250ZW50RGlzcC50eXBlID09PSAnc2Vzc2lvbicpKSB7XG4gICAgcmVxdWVzdC5yZXBseSg0MTUpO1xuICAgIC8vVE9ETzogaW5zdGVhZCBvZiA0MTUsIHBhc3Mgb2ZmIHRvIHRoZSBtZWRpYSBoYW5kbGVyLCB3aG8gY2FuIHRoZW4gZGVjaWRlIGlmIHdlIGNhbiB1c2UgaXRcbiAgICByZXR1cm47XG4gIH1cblxuICAvL1RPRE86IG1vdmUgdGhpcyBpbnRvIG1lZGlhIGhhbmRsZXJcbiAgU0lQLkhhY2tzLkZpcmVmb3guY2Fubm90SGFuZGxlRXh0cmFXaGl0ZXNwYWNlKHJlcXVlc3QpO1xuICBTSVAuSGFja3MuQWxsQnJvd3NlcnMubWFza0R0bHMocmVxdWVzdCk7XG5cbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLlNlcnZlckNvbnRleHQsIFt1YSwgcmVxdWVzdF0pO1xuICBTSVAuVXRpbHMuYXVnbWVudCh0aGlzLCBTSVAuU2Vzc2lvbiwgW3VhLmNvbmZpZ3VyYXRpb24ubWVkaWFIYW5kbGVyRmFjdG9yeV0pO1xuXG4gIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfSU5WSVRFX1JFQ0VJVkVEO1xuICB0aGlzLmZyb21fdGFnID0gcmVxdWVzdC5mcm9tX3RhZztcbiAgdGhpcy5pZCA9IHJlcXVlc3QuY2FsbF9pZCArIHRoaXMuZnJvbV90YWc7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHRoaXMuY29udGFjdCA9IHRoaXMudWEuY29udGFjdC50b1N0cmluZygpO1xuXG4gIHRoaXMucmVjZWl2ZU5vbkludml0ZVJlc3BvbnNlID0gZnVuY3Rpb24gKCkge307IC8vIGludGVudGlvbmFsIG5vLW9wXG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5pbnZpdGVzZXJ2ZXJjb250ZXh0JywgdGhpcy5pZCk7XG5cbiAgLy9TYXZlIHRoZSBzZXNzaW9uIGludG8gdGhlIHVhIHNlc3Npb25zIGNvbGxlY3Rpb24uXG4gIHRoaXMudWEuc2Vzc2lvbnNbdGhpcy5pZF0gPSB0aGlzO1xuXG4gIC8vR2V0IHRoZSBFeHBpcmVzIGhlYWRlciB2YWx1ZSBpZiBleGlzdHNcbiAgaWYocmVxdWVzdC5oYXNIZWFkZXIoJ2V4cGlyZXMnKSkge1xuICAgIGV4cGlyZXMgPSByZXF1ZXN0LmdldEhlYWRlcignZXhwaXJlcycpICogMTAwMDtcbiAgfVxuXG4gIC8vU2V0IDEwMHJlbCBpZiBuZWNlc3NhcnlcbiAgZnVuY3Rpb24gc2V0MTAwcmVsKGgsYykge1xuICAgIGlmIChyZXF1ZXN0Lmhhc0hlYWRlcihoKSAmJiByZXF1ZXN0LmdldEhlYWRlcihoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJzEwMHJlbCcpID49IDApIHtcbiAgICAgIHNlbGYucmVsMTAwID0gYztcbiAgICB9XG4gIH1cbiAgc2V0MTAwcmVsKCdyZXF1aXJlJywgU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEKTtcbiAgc2V0MTAwcmVsKCdzdXBwb3J0ZWQnLCBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKTtcblxuICAvKiBTZXQgdGhlIHRvX3RhZyBiZWZvcmVcbiAgICogcmVwbHlpbmcgYSByZXNwb25zZSBjb2RlIHRoYXQgd2lsbCBjcmVhdGUgYSBkaWFsb2cuXG4gICAqL1xuICByZXF1ZXN0LnRvX3RhZyA9IFNJUC5VdGlscy5uZXdUYWcoKTtcblxuICAvLyBBbiBlcnJvciBvbiBkaWFsb2cgY3JlYXRpb24gd2lsbCBmaXJlICdmYWlsZWQnIGV2ZW50XG4gIGlmKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXF1ZXN0LCAnVUFTJywgdHJ1ZSkpIHtcbiAgICByZXF1ZXN0LnJlcGx5KDUwMCwgJ01pc3NpbmcgQ29udGFjdCBoZWFkZXIgZmllbGQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvL0luaXRpYWxpemUgTWVkaWEgU2Vzc2lvblxuICB0aGlzLm1lZGlhSGFuZGxlciA9IHRoaXMubWVkaWFIYW5kbGVyRmFjdG9yeSh0aGlzLCB7XG4gICAgUlRDQ29uc3RyYWludHM6IHtcIm9wdGlvbmFsXCI6IFt7J0R0bHNTcnRwS2V5QWdyZWVtZW50JzogJ3RydWUnfV19XG4gIH0pO1xuXG4gIGlmICh0aGlzLm1lZGlhSGFuZGxlciAmJiB0aGlzLm1lZGlhSGFuZGxlci5nZXRSZW1vdGVTdHJlYW1zKSB7XG4gICAgdGhpcy5nZXRSZW1vdGVTdHJlYW1zID0gdGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVtb3RlU3RyZWFtcy5iaW5kKHRoaXMubWVkaWFIYW5kbGVyKTtcbiAgICB0aGlzLmdldExvY2FsU3RyZWFtcyA9IHRoaXMubWVkaWFIYW5kbGVyLmdldExvY2FsU3RyZWFtcy5iaW5kKHRoaXMubWVkaWFIYW5kbGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVOZXdTZXNzaW9uKCkge1xuICAgIHZhciBvcHRpb25zID0ge2V4dHJhSGVhZGVyczogWydDb250YWN0OiAnICsgc2VsZi5jb250YWN0XX07XG5cbiAgICBpZiAoc2VsZi5yZWwxMDAgIT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgICAgc2VsZi5wcm9ncmVzcyhvcHRpb25zKTtcbiAgICB9XG4gICAgc2VsZi5zdGF0dXMgPSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVI7XG5cbiAgICAvLyBTZXQgdXNlck5vQW5zd2VyVGltZXJcbiAgICBzZWxmLnRpbWVycy51c2VyTm9BbnN3ZXJUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHJlcXVlc3QucmVwbHkoNDA4KTtcbiAgICAgIHNlbGYuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5OT19BTlNXRVIpO1xuICAgICAgc2VsZi50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5OT19BTlNXRVIpO1xuICAgIH0sIHNlbGYudWEuY29uZmlndXJhdGlvbi5ub0Fuc3dlclRpbWVvdXQpO1xuXG4gICAgLyogU2V0IGV4cGlyZXNUaW1lclxuICAgICAqIFJGQzMyNjEgMTMuMy4xXG4gICAgICovXG4gICAgaWYgKGV4cGlyZXMpIHtcbiAgICAgIHNlbGYudGltZXJzLmV4cGlyZXNUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoc2VsZi5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUikge1xuICAgICAgICAgIHJlcXVlc3QucmVwbHkoNDg3KTtcbiAgICAgICAgICBzZWxmLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuRVhQSVJFUyk7XG4gICAgICAgICAgc2VsZi50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5FWFBJUkVTKTtcbiAgICAgICAgfVxuICAgICAgfSwgZXhwaXJlcyk7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdpbnZpdGUnLHJlcXVlc3QpO1xuICB9XG5cbiAgaWYgKCFyZXF1ZXN0LmJvZHkgfHwgdGhpcy5yZW5kZXJib2R5KSB7XG4gICAgU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZpcmVOZXdTZXNzaW9uLCAwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhc09mZmVyID0gdHJ1ZTtcbiAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXF1ZXN0LmJvZHkpXG4gICAgLnRoZW4oXG4gICAgICBmaXJlTmV3U2Vzc2lvbixcbiAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSAoZSkge1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKCdpbnZhbGlkIFNEUCcpO1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICByZXF1ZXN0LnJlcGx5KDQ4OCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcblxuSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gIHJlamVjdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZygncmVqZWN0aW5nIFJUQ1Nlc3Npb24nKTtcblxuICAgIFNJUC5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5yZWplY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy50ZXJtaW5hdGVkKCk7XG4gIH0sXG5cbiAgdGVybWluYXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXJcbiAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgYm9keSA9IG9wdGlvbnMuYm9keSxcbiAgICBkaWFsb2csXG4gICAgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSyAmJlxuICAgICAgIHRoaXMucmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24uc3RhdGUgIT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgZGlhbG9nID0gdGhpcy5kaWFsb2c7XG5cbiAgICAgIHRoaXMucmVjZWl2ZVJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gU0lQLkMuQUNLKSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0KFNJUC5DLkJZRSwge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGlhbG9nLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnJlcXVlc3Quc2VydmVyX3RyYW5zYWN0aW9uLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbigpe1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0ID0gbmV3IFNJUC5PdXRnb2luZ1JlcXVlc3QoXG4gICAgICAgICAgICBTSVAuQy5CWUUsXG4gICAgICAgICAgICB0aGlzLmRpYWxvZy5yZW1vdGVfdGFyZ2V0LFxuICAgICAgICAgICAgdGhpcy51YSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgJ2NzZXEnOiB0aGlzLmRpYWxvZy5sb2NhbF9zZXFudW0rPTEsXG4gICAgICAgICAgICAgICdjYWxsX2lkJzogdGhpcy5kaWFsb2cuaWQuY2FsbF9pZCxcbiAgICAgICAgICAgICAgJ2Zyb21fdXJpJzogdGhpcy5kaWFsb2cubG9jYWxfdXJpLFxuICAgICAgICAgICAgICAnZnJvbV90YWcnOiB0aGlzLmRpYWxvZy5pZC5sb2NhbF90YWcsXG4gICAgICAgICAgICAgICd0b191cmknOiB0aGlzLmRpYWxvZy5yZW1vdGVfdXJpLFxuICAgICAgICAgICAgICAndG9fdGFnJzogdGhpcy5kaWFsb2cuaWQucmVtb3RlX3RhZyxcbiAgICAgICAgICAgICAgJ3JvdXRlX3NldCc6IHRoaXMuZGlhbG9nLnJvdXRlX3NldFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgbmV3IFNJUC5SZXF1ZXN0U2VuZGVyKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLnJlcXVlc3QsXG4gICAgICAgICAgICAgIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYub25SZXF1ZXN0VGltZW91dCgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLnVhXG4gICAgICAgICAgKS5zZW5kKCk7XG4gICAgICAgICAgZGlhbG9nLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5lbWl0KCdieWUnLCB0aGlzLnJlcXVlc3QpO1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKCk7XG5cbiAgICAgIC8vIFJlc3RvcmUgdGhlIGRpYWxvZyBpbnRvICd0aGlzJyBpbiBvcmRlciB0byBiZSBhYmxlIHRvIHNlbmQgdGhlIGluLWRpYWxvZyBCWUUgOi0pXG4gICAgICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcblxuICAgICAgLy8gUmVzdG9yZSB0aGUgZGlhbG9nIGludG8gJ3VhJyBzbyB0aGUgQUNLIGNhbiByZWFjaCAndGhpcycgc2Vzc2lvblxuICAgICAgdGhpcy51YS5kaWFsb2dzW2RpYWxvZy5pZC50b1N0cmluZygpXSA9IGRpYWxvZztcblxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhpcy5ieWUob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVqZWN0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tZWRpYV0gZ2V0cyBwYXNzZWQgdG8gU0lQLk1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbiBhcyBtZWRpYUhpbnRcbiAgICovXG4gIHByb2dyZXNzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhclxuICAgICAgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAxODAsXG4gICAgICByZWFzb25QaHJhc2UgPSBvcHRpb25zLnJlYXNvblBocmFzZSxcbiAgICAgIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSxcbiAgICAgIGljZVNlcnZlcnMsXG4gICAgICBzdHVuU2VydmVycyA9IG9wdGlvbnMuc3R1blNlcnZlcnMgfHwgbnVsbCxcbiAgICAgIHR1cm5TZXJ2ZXJzID0gb3B0aW9ucy50dXJuU2VydmVycyB8fCBudWxsLFxuICAgICAgYm9keSA9IG9wdGlvbnMuYm9keSxcbiAgICAgIHJlc3BvbnNlO1xuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAxMDAgfHwgc3RhdHVzQ29kZSA+IDE5OSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNDb2RlOiAnICsgc3RhdHVzQ29kZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDYW5jZWxlZCB8fCB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHN0dW5TZXJ2ZXJzIHx8IHR1cm5TZXJ2ZXJzKSB7XG4gICAgICBpZiAoc3R1blNlcnZlcnMpIHtcbiAgICAgICAgaWNlU2VydmVycyA9IFNJUC5VQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsWydzdHVuU2VydmVycyddKHN0dW5TZXJ2ZXJzKTtcbiAgICAgICAgaWYgKCFpY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdHVuU2VydmVyczogJysgc3R1blNlcnZlcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3R1blNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0dXJuU2VydmVycykge1xuICAgICAgICBpY2VTZXJ2ZXJzID0gU0lQLlVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbJ3R1cm5TZXJ2ZXJzJ10odHVyblNlcnZlcnMpO1xuICAgICAgICBpZiAoIWljZVNlcnZlcnMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHR1cm5TZXJ2ZXJzOiAnKyB0dXJuU2VydmVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50dXJuU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIudXBkYXRlSWNlU2VydmVycyh7XG4gICAgICAgIHN0dW5TZXJ2ZXJzOiB0aGlzLnN0dW5TZXJ2ZXJzLFxuICAgICAgICB0dXJuU2VydmVyczogdGhpcy50dXJuU2VydmVyc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG8xMDByZWwoKSB7XG4gICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgICBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDE4MztcblxuICAgICAgLy8gU2V0IHN0YXR1cyBhbmQgYWRkIGV4dHJhIGhlYWRlcnNcbiAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0s7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJysgdGhpcy5jb250YWN0KTtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZXF1aXJlOiAxMDByZWwnKTtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSU2VxOiAnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApKTtcblxuICAgICAgLy8gU2F2ZSBtZWRpYSBoaW50IGZvciBsYXRlciAocmVmZXJyZWQgc2Vzc2lvbnMpXG4gICAgICB0aGlzLm1lZGlhSGludCA9IG9wdGlvbnMubWVkaWE7XG5cbiAgICAgIC8vIEdldCB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvbiB0byBhZGQgdG8gcHJlYWNjZXB0IHdpdGhcbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uKG9wdGlvbnMubWVkaWEpXG4gICAgICAudGhlbihcbiAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzIChib2R5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxlZCB8fCB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZWFybHlfc2RwID0gYm9keTtcbiAgICAgICAgICB0aGlzW3RoaXMuaGFzT2ZmZXIgPyAnaGFzQW5zd2VyJyA6ICdoYXNPZmZlciddID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIFJldHJhbnNtaXQgdW50aWwgd2UgZ2V0IGEgcmVzcG9uc2Ugb3Igd2UgdGltZSBvdXQgKHNlZSBwcmFja1RpbWVyIGJlbG93KVxuICAgICAgICAgIHZhciB0aW1lb3V0ID0gU0lQLlRpbWVycy5UMTtcbiAgICAgICAgICB0aGlzLnRpbWVycy5yZWwxeHhUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbiByZWwxeHhSZXRyYW5zbWlzc2lvbigpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5yZXBseShzdGF0dXNDb2RlLCBudWxsLCBleHRyYUhlYWRlcnMsIGJvZHkpO1xuICAgICAgICAgICAgdGltZW91dCAqPSAyO1xuICAgICAgICAgICAgdGhpcy50aW1lcnMucmVsMXh4VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQocmVsMXh4UmV0cmFuc21pc3Npb24uYmluZCh0aGlzKSwgdGltZW91dCk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpLCB0aW1lb3V0KTtcblxuICAgICAgICAgIC8vIFRpbWVvdXQgYW5kIHJlamVjdCBJTlZJVEUgaWYgbm8gcmVzcG9uc2VcbiAgICAgICAgICB0aGlzLnRpbWVycy5wcmFja1RpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ25vIFBSQUNLIHJlY2VpdmVkLCByZWplY3RpbmcgdGhlIGNhbGwnKTtcbiAgICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnJlbDF4eFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5yZXBseSg1MDQpO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5OT19QUkFDSyk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpLCBTSVAuVGltZXJzLlQxICogNjQpO1xuXG4gICAgICAgICAgLy8gU2VuZCB0aGUgaW5pdGlhbCByZXNwb25zZVxuICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5yZXF1ZXN0LnJlcGx5KHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzLCBib2R5KTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UsIHJlYXNvblBocmFzZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcblxuICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUgKCkge1xuICAgICAgICAgIHRoaXMucmVxdWVzdC5yZXBseSg0ODApO1xuICAgICAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICApO1xuICAgIH0gLy8gZW5kIGRvMTAwcmVsXG5cbiAgICBmdW5jdGlvbiBub3JtYWxSZXBseSgpIHtcbiAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgcmVzcG9uc2UgPSB0aGlzLnJlcXVlc3QucmVwbHkoc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlLCBleHRyYUhlYWRlcnMsIGJvZHkpO1xuICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlLCByZWFzb25QaHJhc2UpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXR1c0NvZGUgIT09IDEwMCAmJlxuICAgICAgICAodGhpcy5yZWwxMDAgPT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCB8fFxuICAgICAgICAgKHRoaXMucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEICYmIG9wdGlvbnMucmVsMTAwKSB8fFxuICAgICAgICAgKHRoaXMucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEICYmICh0aGlzLnVhLmNvbmZpZ3VyYXRpb24ucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpKSkpIHtcbiAgICAgIGRvMTAwcmVsLmFwcGx5KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxSZXBseS5hcHBseSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLypcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1lZGlhXSBnZXRzIHBhc3NlZCB0byBTSVAuTWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uIGFzIG1lZGlhSGludFxuICAgKi9cbiAgYWNjZXB0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoU2Vzc2lvbi5kZXN1Z2FyKG9wdGlvbnMpKTtcbiAgICBTSVAuVXRpbHMub3B0aW9uc092ZXJyaWRlKG9wdGlvbnMsICdtZWRpYScsICdtZWRpYUNvbnN0cmFpbnRzJywgdHJ1ZSwgdGhpcy5sb2dnZXIsIHRoaXMudWEuY29uZmlndXJhdGlvbi5tZWRpYSk7XG4gICAgdGhpcy5tZWRpYUhpbnQgPSBvcHRpb25zLm1lZGlhO1xuXG4gICAgLy8gY29tbWVudGVkIG91dCBub3ctdW51c2VkIGhvbGQtcmVsYXRlZCB2YXJpYWJsZXMgZm9yIGpzaGludC4gU2VlIGJlbG93LiBKTUYgMjAxNC0xLTIxXG4gICAgdmFyXG4gICAgICAvL2lkeCwgbGVuZ3RoLCBoYXNBdWRpbywgaGFzVmlkZW8sXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3QsXG4gICAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgLy9tZWRpYVN0cmVhbSA9IG9wdGlvbnMubWVkaWFTdHJlYW0gfHwgbnVsbCxcbiAgICAgIGljZVNlcnZlcnMsXG4gICAgICBzdHVuU2VydmVycyA9IG9wdGlvbnMuc3R1blNlcnZlcnMgfHwgbnVsbCxcbiAgICAgIHR1cm5TZXJ2ZXJzID0gb3B0aW9ucy50dXJuU2VydmVycyB8fCBudWxsLFxuICAgICAgc2RwQ3JlYXRpb25TdWNjZWVkZWQgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgIHZhclxuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIC8vIHJ1biBmb3IgcmVwbHkgc3VjY2VzcyBjYWxsYmFja1xuICAgICAgICAgIHJlcGx5U3VjY2VlZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXR1cyA9IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSztcblxuICAgICAgICAgICAgc2VsZi5zZXRJbnZpdGUyeHhUaW1lcihyZXF1ZXN0LCBib2R5KTtcbiAgICAgICAgICAgIHNlbGYuc2V0QUNLVGltZXIoKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gcnVuIGZvciByZXBseSBmYWlsdXJlIGNhbGxiYWNrXG4gICAgICAgICAgcmVwbHlGYWlsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICAgICAgICAgIHNlbGYudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAvLyBDaHJvbWUgbWlnaHQgY2FsbCBvbmFkZHN0cmVhbSBiZWZvcmUgYWNjZXB0KCkgaXMgY2FsbGVkLCB3aGljaCBtZWFuc1xuICAgICAgICAvLyBtZWRpYUhhbmRsZXIucmVuZGVyKCkgd2FzIGNhbGxlZCB3aXRob3V0IGEgcmVuZGVySGludCwgc28gd2UgbmVlZCB0b1xuICAgICAgICAvLyByZS1yZW5kZXIgbm93IHRoYXQgbWVkaWFIaW50LnJlbmRlciBoYXMgYmVlbiBzZXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIENocm9tZSBzZWVtcyB0byBiZSBpbiB0aGUgcmlnaHQgcmVnYXJkaW5nIHRoaXMsIHNlZVxuICAgICAgICAvLyBodHRwOi8vZGV2LnczLm9yZy8yMDExL3dlYnJ0Yy9lZGl0b3Ivd2VicnRjLmh0bWwjd2lkbC1SVENQZWVyQ29ubmVjdGlvbi1vbmFkZHN0cmVhbVxuICAgICAgICBzZWxmLm1lZGlhSGFuZGxlci5yZW5kZXIoKTtcblxuICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJyArIHNlbGYuY29udGFjdCk7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJyArIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcblxuICAgICAgICBpZighc2VsZi5oYXNPZmZlcikge1xuICAgICAgICAgIHNlbGYuaGFzT2ZmZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXNwb25zZSA9IHJlcXVlc3QucmVwbHkoMjAwLCBudWxsLCBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICByZXBseVN1Y2NlZWRlZCxcbiAgICAgICAgICAgICAgICAgICAgICByZXBseUZhaWxlZFxuICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgaWYgKHNlbGYuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7IC8vIERpZG4ndCBmYWlsXG4gICAgICAgICAgc2VsZi5hY2NlcHRlZChyZXNwb25zZSwgU0lQLlV0aWxzLmdldFJlYXNvblBocmFzZSgyMDApKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgc2RwQ3JlYXRpb25GYWlsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gLSBmYWlsIG91dCBvbiBlcnJvclxuICAgICAgICBzZWxmLnJlcXVlc3QucmVwbHkoNDgwKTtcbiAgICAgICAgLy9zZWxmLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLlVTRVJfREVOSUVEX01FRElBX0FDQ0VTUyk7XG4gICAgICAgIHNlbGYuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICBzZWxmLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICB9O1xuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0FOU1dFUkVEO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0VBUkxZX01FRElBKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIGlmICgoc3R1blNlcnZlcnMgfHwgdHVyblNlcnZlcnMpICYmXG4gICAgICAgICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfRUFSTFlfTUVESUEgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLKSkge1xuICAgICAgaWYgKHN0dW5TZXJ2ZXJzKSB7XG4gICAgICAgIGljZVNlcnZlcnMgPSBTSVAuVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFsnc3R1blNlcnZlcnMnXShzdHVuU2VydmVycyk7XG4gICAgICAgIGlmICghaWNlU2VydmVycykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3R1blNlcnZlcnM6ICcrIHN0dW5TZXJ2ZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0dW5TZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHVyblNlcnZlcnMpIHtcbiAgICAgICAgaWNlU2VydmVycyA9IFNJUC5VQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsWyd0dXJuU2VydmVycyddKHR1cm5TZXJ2ZXJzKTtcbiAgICAgICAgaWYgKCFpY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0dXJuU2VydmVyczogJysgdHVyblNlcnZlcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHVyblNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnVwZGF0ZUljZVNlcnZlcnMoe1xuICAgICAgICBzdHVuU2VydmVyczogdGhpcy5zdHVuU2VydmVycyxcbiAgICAgICAgdHVyblNlcnZlcnM6IHRoaXMudHVyblNlcnZlcnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFuIGVycm9yIG9uIGRpYWxvZyBjcmVhdGlvbiB3aWxsIGZpcmUgJ2ZhaWxlZCcgZXZlbnRcbiAgICBpZighdGhpcy5jcmVhdGVEaWFsb2cocmVxdWVzdCwgJ1VBUycpKSB7XG4gICAgICByZXF1ZXN0LnJlcGx5KDUwMCwgJ01pc3NpbmcgQ29udGFjdCBoZWFkZXIgZmllbGQnKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnVzZXJOb0Fuc3dlclRpbWVyKTtcblxuICAgIC8vIHRoaXMgaG9sZC1yZWxhdGVkIGNvZGUgYnJlYWtzIEZGIGFjY2VwdGluZyBuZXcgY2FsbHMgLSBKTUYgMjAxNC0xLTIxXG4gICAgLypcbiAgICBsZW5ndGggPSB0aGlzLmdldFJlbW90ZVN0cmVhbXMoKS5sZW5ndGg7XG5cbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhSGFuZGxlci5nZXRSZW1vdGVTdHJlYW1zKClbaWR4XS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaGFzVmlkZW8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWVkaWFIYW5kbGVyLmdldFJlbW90ZVN0cmVhbXMoKVtpZHhdLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICBoYXNBdWRpbyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYXNBdWRpbyAmJiB0aGlzLm1lZGlhQ29uc3RyYWludHMuYXVkaW8gPT09IHRydWUpIHtcbiAgICAgIHRoaXMubWVkaWFDb25zdHJhaW50cy5hdWRpbyA9IGZhbHNlO1xuICAgICAgaWYgKG1lZGlhU3RyZWFtKSB7XG4gICAgICAgIGxlbmd0aCA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoO1xuICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayhtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpW2lkeF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYXNWaWRlbyAmJiB0aGlzLm1lZGlhQ29uc3RyYWludHMudmlkZW8gPT09IHRydWUpIHtcbiAgICAgIHRoaXMubWVkaWFDb25zdHJhaW50cy52aWRlbyA9IGZhbHNlO1xuICAgICAgaWYgKG1lZGlhU3RyZWFtKSB7XG4gICAgICAgIGxlbmd0aCA9IG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoO1xuICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayhtZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpW2lkeF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICovXG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBKSB7XG4gICAgICBzZHBDcmVhdGlvblN1Y2NlZWRlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbihzZWxmLm1lZGlhSGludClcbiAgICAgIC50aGVuKFxuICAgICAgICBzZHBDcmVhdGlvblN1Y2NlZWRlZCxcbiAgICAgICAgc2RwQ3JlYXRpb25GYWlsZWRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVjZWl2ZVJlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcblxuICAgIC8vIElTQyBSRUNFSVZFIFJFUVVFU1RcblxuICAgIGZ1bmN0aW9uIGNvbmZpcm1TZXNzaW9uKCkge1xuICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgY29udGVudFR5cGU7XG5cbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmFja1RpbWVyKTtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmludml0ZTJ4eFRpbWVyKTtcbiAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgdGhpcy51bm11dGUoKTtcblxuICAgICAgLy8gVE9ETyAtIHRoaXMgbG9naWMgYXNzdW1lcyBDb250ZW50LURpc3Bvc2l0aW9uIGRlZmF1bHRzXG4gICAgICBjb250ZW50VHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgIGlmIChjb250ZW50VHlwZSAhPT0gJ2FwcGxpY2F0aW9uL3NkcCcpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICB0aGlzLnJlbmRlcnR5cGUgPSBjb250ZW50VHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2gocmVxdWVzdC5tZXRob2QpIHtcbiAgICBjYXNlIFNJUC5DLkNBTkNFTDpcbiAgICAgIC8qIFJGQzMyNjEgMTUgU3RhdGVzIHRoYXQgYSBVQVMgbWF5IGhhdmUgYWNjZXB0ZWQgYW4gaW52aXRhdGlvbiB3aGlsZSBhIENBTkNFTFxuICAgICAgICogd2FzIGluIHByb2dyZXNzIGFuZCB0aGF0IHRoZSBVQUMgTUFZIGNvbnRpbnVlIHdpdGggdGhlIHNlc3Npb24gZXN0YWJsaXNoZWQgYnlcbiAgICAgICAqIGFueSAyeHggcmVzcG9uc2UsIG9yIE1BWSB0ZXJtaW5hdGUgd2l0aCBCWUUuIFNJUCBkb2VzIGNvbnRpbnVlIHdpdGggdGhlXG4gICAgICAgKiBlc3RhYmxpc2hlZCBzZXNzaW9uLiBTbyB0aGUgQ0FOQ0VMIGlzIHByb2Nlc3NlZCBvbmx5IGlmIHRoZSBzZXNzaW9uIGlzIG5vdCB5ZXRcbiAgICAgICAqIGVzdGFibGlzaGVkLlxuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICAgKiBUZXJtaW5hdGUgdGhlIHdob2xlIHNlc3Npb24gaW4gY2FzZSB0aGUgdXNlciBkaWRuJ3QgYWNjZXB0IChvciB5ZXQgdG8gc2VuZCB0aGUgYW5zd2VyKSBub3IgcmVqZWN0IHRoZVxuICAgICAgICpyZXF1ZXN0IG9wZW5pbmcgdGhlIHNlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVIgfHxcbiAgICAgICAgIHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSyB8fFxuICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLIHx8XG4gICAgICAgICB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfRUFSTFlfTUVESUEgfHxcbiAgICAgICAgIHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19BTlNXRVJFRCkge1xuXG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfQ0FOQ0VMRUQ7XG4gICAgICAgIHRoaXMucmVxdWVzdC5yZXBseSg0ODcpO1xuICAgICAgICB0aGlzLmNhbmNlbGVkKHJlcXVlc3QpO1xuICAgICAgICB0aGlzLnJlamVjdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5DQU5DRUxFRCk7XG4gICAgICAgIHRoaXMuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5DQU5DRUxFRCk7XG4gICAgICAgIHRoaXMudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQ0FOQ0VMRUQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSVAuQy5BQ0s6XG4gICAgICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNBbnN3ZXIpIHtcbiAgICAgICAgICBpZihyZXF1ZXN0LmJvZHkgJiYgcmVxdWVzdC5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpID09PSAnYXBwbGljYXRpb24vc2RwJykge1xuICAgICAgICAgICAgLy8gQUNLIGNvbnRhaW5zIGFuc3dlciB0byBhbiBJTlZJVEUgdy9vIFNEUCBuZWdvdGlhdGlvblxuICAgICAgICAgICAgU0lQLkhhY2tzLkZpcmVmb3guY2Fubm90SGFuZGxlRXh0cmFXaGl0ZXNwYWNlKHJlcXVlc3QpO1xuICAgICAgICAgICAgU0lQLkhhY2tzLkFsbEJyb3dzZXJzLm1hc2tEdGxzKHJlcXVlc3QpO1xuXG4gICAgICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXF1ZXN0LmJvZHkpXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgY29uZmlybVNlc3Npb24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSh7XG4gICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAnNDg4JyxcbiAgICAgICAgICAgICAgICAgIHJlYXNvblBocmFzZTogJ0JhZCBNZWRpYSBEZXNjcmlwdGlvbidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZWFybHlfc2RwKSB7XG4gICAgICAgICAgICBjb25maXJtU2Vzc2lvbi5hcHBseSh0aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9UT0RPOiBQYXNzIHRvIG1lZGlhaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmZpcm1TZXNzaW9uLmFwcGx5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNJUC5DLlBSQUNLOlxuICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSyB8fCB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgLy9sb2NhbE1lZGlhID0gc2Vzc2lvbi5tZWRpYUhhbmRsZXIubG9jYWxNZWRpYTtcbiAgICAgICAgaWYoIXRoaXMuaGFzQW5zd2VyKSB7XG4gICAgICAgICAgaWYocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSA9PT0gJ2FwcGxpY2F0aW9uL3NkcCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlcXVlc3QuYm9keSlcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiBvblN1Y2Nlc3MgKCkge1xuICAgICAgICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnJlbDF4eFRpbWVyKTtcbiAgICAgICAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5wcmFja1RpbWVyKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgICAgLy9SRVZJU0lUXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlKCk7XG4gICAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlIChlKSB7XG4gICAgICAgICAgICAgICAgLy9UT0RPOiBTZW5kIHRvIG1lZGlhIGhhbmRsZXJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMudGVybWluYXRlKHtcbiAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6ICc0ODgnLFxuICAgICAgICAgICAgICAgICAgcmVhc29uUGhyYXNlOiAnQmFkIE1lZGlhIERlc2NyaXB0aW9uJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgIHRoaXMudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSh7XG4gICAgICAgICAgICAgIHN0YXR1c0NvZGU6ICc0ODgnLFxuICAgICAgICAgICAgICByZWFzb25QaHJhc2U6ICdCYWQgTWVkaWEgRGVzY3JpcHRpb24nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5yZWwxeHhUaW1lcik7XG4gICAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMucHJhY2tUaW1lcik7XG4gICAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgLy9SRVZJU0lUXG4gICAgICAgICAgdGhpcy5tdXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfRUFSTFlfTUVESUEpIHtcbiAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIFNlc3Npb24ucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0LmFwcGx5KHRoaXMsIFtyZXF1ZXN0XSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19DT05GSVJNRUQgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9XG4gIH0sXG5cbiAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9XG4gIH1cblxufTtcblxuU0lQLkludml0ZVNlcnZlckNvbnRleHQgPSBJbnZpdGVTZXJ2ZXJDb250ZXh0O1xuXG5JbnZpdGVDbGllbnRDb250ZXh0ID0gZnVuY3Rpb24odWEsIHRhcmdldCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShTZXNzaW9uLmRlc3VnYXIob3B0aW9ucykpO1xuICBvcHRpb25zLnBhcmFtcyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5wYXJhbXMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG5cbiAgdmFyIGljZVNlcnZlcnMsXG4gICAgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpLFxuICAgIHN0dW5TZXJ2ZXJzID0gb3B0aW9ucy5zdHVuU2VydmVycyB8fCBudWxsLFxuICAgIHR1cm5TZXJ2ZXJzID0gb3B0aW9ucy50dXJuU2VydmVycyB8fCBudWxsLFxuICAgIG1lZGlhSGFuZGxlckZhY3RvcnkgPSBvcHRpb25zLm1lZGlhSGFuZGxlckZhY3RvcnkgfHwgdWEuY29uZmlndXJhdGlvbi5tZWRpYUhhbmRsZXJGYWN0b3J5LFxuICAgIGlzTWVkaWFTdXBwb3J0ZWQgPSBtZWRpYUhhbmRsZXJGYWN0b3J5LmlzU3VwcG9ydGVkO1xuXG4gIC8vIENoZWNrIFdlYlJUQyBzdXBwb3J0XG4gIGlmIChpc01lZGlhU3VwcG9ydGVkICYmICFpc01lZGlhU3VwcG9ydGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuTm90U3VwcG9ydGVkRXJyb3IoJ01lZGlhIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIHRoaXMuUlRDQ29uc3RyYWludHMgPSBvcHRpb25zLlJUQ0NvbnN0cmFpbnRzIHx8IHt9O1xuICB0aGlzLmludml0ZVdpdGhvdXRTZHAgPSBvcHRpb25zLmludml0ZVdpdGhvdXRTZHAgfHwgZmFsc2U7XG5cbiAgLy8gU2V0IGFub255bW91cyBwcm9wZXJ0eVxuICB0aGlzLmFub255bW91cyA9IG9wdGlvbnMuYW5vbnltb3VzIHx8IGZhbHNlO1xuXG4gIC8vIEN1c3RvbSBkYXRhIHRvIGJlIHNlbnQgZWl0aGVyIGluIElOVklURSBvciBpbiBBQ0tcbiAgdGhpcy5yZW5kZXJib2R5ID0gb3B0aW9ucy5yZW5kZXJib2R5IHx8IG51bGw7XG4gIHRoaXMucmVuZGVydHlwZSA9IG9wdGlvbnMucmVuZGVydHlwZSB8fCAndGV4dC9wbGFpbic7XG5cbiAgb3B0aW9ucy5wYXJhbXMuZnJvbV90YWcgPSB0aGlzLmZyb21fdGFnO1xuXG4gIC8qIERvIG5vdCBhZGQgO29iIGluIGluaXRpYWwgZm9ybWluZyBkaWFsb2cgcmVxdWVzdHMgaWYgdGhlIHJlZ2lzdHJhdGlvbiBvdmVyXG4gICAqICB0aGUgY3VycmVudCBjb25uZWN0aW9uIGdvdCBhIEdSVVUgVVJJLlxuICAgKi9cbiAgdGhpcy5jb250YWN0ID0gdWEuY29udGFjdC50b1N0cmluZyh7XG4gICAgYW5vbnltb3VzOiB0aGlzLmFub255bW91cyxcbiAgICBvdXRib3VuZDogdGhpcy5hbm9ueW1vdXMgPyAhdWEuY29udGFjdC50ZW1wX2dydXUgOiAhdWEuY29udGFjdC5wdWJfZ3J1dVxuICB9KTtcblxuICBpZiAodGhpcy5hbm9ueW1vdXMpIHtcbiAgICBvcHRpb25zLnBhcmFtcy5mcm9tX2Rpc3BsYXlOYW1lID0gJ0Fub255bW91cyc7XG4gICAgb3B0aW9ucy5wYXJhbXMuZnJvbV91cmkgPSAnc2lwOmFub255bW91c0Bhbm9ueW1vdXMuaW52YWxpZCc7XG5cbiAgICBleHRyYUhlYWRlcnMucHVzaCgnUC1QcmVmZXJyZWQtSWRlbnRpdHk6ICcrIHVhLmNvbmZpZ3VyYXRpb24udXJpLnRvU3RyaW5nKCkpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdQcml2YWN5OiBpZCcpO1xuICB9XG4gIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnKyB0aGlzLmNvbnRhY3QpO1xuICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcrIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcbiAgaWYgKCF0aGlzLmludml0ZVdpdGhvdXRTZHApIHtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9zZHAnKTtcbiAgfSBlbHNlIGlmICh0aGlzLnJlbmRlcmJvZHkpIHtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiAnICsgdGhpcy5yZW5kZXJ0eXBlKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1EaXNwb3NpdGlvbjogcmVuZGVyO2hhbmRsaW5nPW9wdGlvbmFsJyk7XG4gIH1cblxuICBpZiAodWEuY29uZmlndXJhdGlvbi5yZWwxMDAgPT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZXF1aXJlOiAxMDByZWwnKTtcbiAgfVxuICBpZiAodWEuY29uZmlndXJhdGlvbi5yZXBsYWNlcyA9PT0gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSB7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JlcXVpcmU6IHJlcGxhY2VzJyk7XG4gIH1cblxuICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcblxuICBTSVAuVXRpbHMuYXVnbWVudCh0aGlzLCBTSVAuQ2xpZW50Q29udGV4dCwgW3VhLCBTSVAuQy5JTlZJVEUsIHRhcmdldCwgb3B0aW9uc10pO1xuICBTSVAuVXRpbHMuYXVnbWVudCh0aGlzLCBTSVAuU2Vzc2lvbiwgW21lZGlhSGFuZGxlckZhY3RvcnldKTtcblxuICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX05VTEwpIHtcbiAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICB9XG5cbiAgLy8gU2Vzc2lvbiBwYXJhbWV0ZXIgaW5pdGlhbGl6YXRpb25cbiAgdGhpcy5mcm9tX3RhZyA9IFNJUC5VdGlscy5uZXdUYWcoKTtcblxuICAvLyBPdXRnb2luZ1Nlc3Npb24gc3BlY2lmaWMgcGFyYW1ldGVyc1xuICB0aGlzLmlzQ2FuY2VsZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWNlaXZlZF8xMDAgPSBmYWxzZTtcblxuICB0aGlzLm1ldGhvZCA9IFNJUC5DLklOVklURTtcblxuICB0aGlzLnJlY2VpdmVOb25JbnZpdGVSZXNwb25zZSA9IHRoaXMucmVjZWl2ZVJlc3BvbnNlO1xuICB0aGlzLnJlY2VpdmVSZXNwb25zZSA9IHRoaXMucmVjZWl2ZUludml0ZVJlc3BvbnNlO1xuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuaW52aXRlY2xpZW50Y29udGV4dCcpO1xuXG4gIGlmIChzdHVuU2VydmVycykge1xuICAgIGljZVNlcnZlcnMgPSBTSVAuVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFsnc3R1blNlcnZlcnMnXShzdHVuU2VydmVycyk7XG4gICAgaWYgKCFpY2VTZXJ2ZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0dW5TZXJ2ZXJzOiAnKyBzdHVuU2VydmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R1blNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0dXJuU2VydmVycykge1xuICAgIGljZVNlcnZlcnMgPSBTSVAuVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFsndHVyblNlcnZlcnMnXSh0dXJuU2VydmVycyk7XG4gICAgaWYgKCFpY2VTZXJ2ZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHR1cm5TZXJ2ZXJzOiAnKyB0dXJuU2VydmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHVyblNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgIH1cbiAgfVxuXG4gIHVhLmFwcGxpY2FudHNbdGhpc10gPSB0aGlzO1xuXG4gIHRoaXMuaWQgPSB0aGlzLnJlcXVlc3QuY2FsbF9pZCArIHRoaXMuZnJvbV90YWc7XG5cbiAgLy9Jbml0aWFsaXplIE1lZGlhIFNlc3Npb25cbiAgdGhpcy5tZWRpYUhhbmRsZXIgPSB0aGlzLm1lZGlhSGFuZGxlckZhY3RvcnkodGhpcywge1xuICAgIFJUQ0NvbnN0cmFpbnRzOiB0aGlzLlJUQ0NvbnN0cmFpbnRzLFxuICAgIHN0dW5TZXJ2ZXJzOiB0aGlzLnN0dW5TZXJ2ZXJzLFxuICAgIHR1cm5TZXJ2ZXJzOiB0aGlzLnR1cm5TZXJ2ZXJzXG4gIH0pO1xuXG4gIGlmICh0aGlzLm1lZGlhSGFuZGxlciAmJiB0aGlzLm1lZGlhSGFuZGxlci5nZXRSZW1vdGVTdHJlYW1zKSB7XG4gICAgdGhpcy5nZXRSZW1vdGVTdHJlYW1zID0gdGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVtb3RlU3RyZWFtcy5iaW5kKHRoaXMubWVkaWFIYW5kbGVyKTtcbiAgICB0aGlzLmdldExvY2FsU3RyZWFtcyA9IHRoaXMubWVkaWFIYW5kbGVyLmdldExvY2FsU3RyZWFtcy5iaW5kKHRoaXMubWVkaWFIYW5kbGVyKTtcbiAgfVxuXG4gIFNJUC5VdGlscy5vcHRpb25zT3ZlcnJpZGUob3B0aW9ucywgJ21lZGlhJywgJ21lZGlhQ29uc3RyYWludHMnLCB0cnVlLCB0aGlzLmxvZ2dlciwgdGhpcy51YS5jb25maWd1cmF0aW9uLm1lZGlhKTtcbiAgdGhpcy5tZWRpYUhpbnQgPSBvcHRpb25zLm1lZGlhO1xufTtcblxuSW52aXRlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUgPSB7XG4gIGludml0ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vU2F2ZSB0aGUgc2Vzc2lvbiBpbnRvIHRoZSB1YSBzZXNzaW9ucyBjb2xsZWN0aW9uLlxuICAgIC8vTm90ZTogcGxhY2luZyBpbiBjb25zdHJ1Y3RvciBicmVha3MgY2FsbCB0byByZXF1ZXN0LmNhbmNlbCBvbiBjbG9zZS4uLiBVc2VyIGRvZXMgbm90IG5lZWQgdGhpcyBhbnl3YXlcbiAgICB0aGlzLnVhLnNlc3Npb25zW3RoaXMuaWRdID0gdGhpcztcblxuICAgIC8vTm90ZTogZHVlIHRvIHRoZSB3YXkgRmlyZWZveCBoYW5kbGVzIGdVTSBjYWxscywgaXQgaXMgcmVjb21tZW5kZWQgdG8gbWFrZSB0aGUgZ1VNIGNhbGwgYXQgdGhlIGFwcCBsZXZlbFxuICAgIC8vIGFuZCBoYW5kIHNpcC5qcyBhIHN0cmVhbSBhcyB0aGUgbWVkaWFIaW50XG4gICAgaWYgKHRoaXMuaW52aXRlV2l0aG91dFNkcCkge1xuICAgICAgLy9qdXN0IHNlbmQgYW4gaW52aXRlIHdpdGggbm8gc2RwLi4uXG4gICAgICB0aGlzLnJlcXVlc3QuYm9keSA9IHNlbGYucmVuZGVyYm9keTtcbiAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfSU5WSVRFX1NFTlQ7XG4gICAgICB0aGlzLnNlbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24oc2VsZi5tZWRpYUhpbnQpXG4gICAgICAudGhlbihcbiAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzKG9mZmVyKSB7XG4gICAgICAgICAgaWYgKHNlbGYuaXNDYW5jZWxlZCB8fCBzZWxmLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmhhc09mZmVyID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLnJlcXVlc3QuYm9keSA9IG9mZmVyO1xuICAgICAgICAgIHNlbGYuc3RhdHVzID0gQy5TVEFUVVNfSU5WSVRFX1NFTlQ7XG4gICAgICAgICAgc2VsZi5zZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSgpIHtcbiAgICAgICAgICBpZiAoc2VsZi5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETy4uLmZhaWwgb3V0XG4gICAgICAgICAgLy9zZWxmLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuVVNFUl9ERU5JRURfTUVESUFfQUNDRVNTKTtcbiAgICAgICAgICAvL3NlbGYuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgIHNlbGYuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgIHNlbGYudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZWNlaXZlSW52aXRlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgdmFyIGNhdXNlLCAvL2xvY2FsTWVkaWEsXG4gICAgICBzZXNzaW9uID0gdGhpcyxcbiAgICAgIGlkID0gcmVzcG9uc2UuY2FsbF9pZCArIHJlc3BvbnNlLmZyb21fdGFnICsgcmVzcG9uc2UudG9fdGFnLFxuICAgICAgZXh0cmFIZWFkZXJzID0gW10sXG4gICAgICBvcHRpb25zID0ge307XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQgfHwgcmVzcG9uc2UubWV0aG9kICE9PSBTSVAuQy5JTlZJVEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kaWFsb2cgJiYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA8PSAyOTkpKSB7XG4gICAgICBpZiAoaWQgIT09IHRoaXMuZGlhbG9nLmlkLnRvU3RyaW5nKCkgKSB7XG4gICAgICAgIGlmICghdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnLCB0cnVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0uc2VuZFJlcXVlc3QodGhpcywgU0lQLkMuQUNLLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBTSVAuVXRpbHMuZ2VuZXJhdGVGYWtlU0RQKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnNlbmRSZXF1ZXN0KHRoaXMsIFNJUC5DLkJZRSk7XG5cbiAgICAgICAgLyogTk9URTogVGhpcyBmYWlscyBiZWNhdXNlIHRoZSBmb3JraW5nIHByb3h5IGRvZXMgbm90IHJlY29nbml6ZSB0aGF0IGFuIHVuYW5zd2VyYWJsZVxuICAgICAgICAgKiBsZWcgKGR1ZSB0byBwZWVyQ29ubmVjdGlvbiBsaW1pdGF0aW9ucykgaGFzIGJlZW4gYW5zd2VyZWQgZmlyc3QuIElmIHlvdXIgZm9ya2luZ1xuICAgICAgICAgKiBwcm94eSBkb2VzIG5vdCBoYW5nIHVwIGFsbCB1bmFuc3dlcmVkIGJyYW5jaGVzIG9uIHRoZSBmaXJzdCBicmFuY2ggYW5zd2VyZWQsIHJlbW92ZSB0aGlzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSyx7Y3NlcTogcmVzcG9uc2UuY3NlcX0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmhhc0Fuc3dlcikge1xuICAgICAgICAvLyBpbnZpdGUgdy9vIHNkcCBpcyB3YWl0aW5nIGZvciBjYWxsYmFja1xuICAgICAgICAvL2FuIGludml0ZSB3aXRoIHNkcCBtdXN0IGdvIG9uLCBhbmQgaGFzQW5zd2VyIGlzIHRydWVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmRpYWxvZyAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA8IDIwMCkge1xuICAgICAgLypcbiAgICAgICAgRWFybHkgbWVkaWEgaGFzIGJlZW4gc2V0IHVwIHdpdGggYXQgbGVhc3Qgb25lIG90aGVyIGRpZmZlcmVudCBicmFuY2gsXG4gICAgICAgIGJ1dCBhIGZpbmFsIDJ4eCByZXNwb25zZSBoYXNuJ3QgYmVlbiByZWNlaXZlZFxuICAgICAgKi9cbiAgICAgIGlmICh0aGlzLmRpYWxvZy5wcmFja2VkLmluZGV4T2YocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpICE9PSAtMSB8fFxuICAgICAgICAgICh0aGlzLmRpYWxvZy5wcmFja2VkW3RoaXMuZGlhbG9nLnByYWNrZWQubGVuZ3RoLTFdID49IHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICYmIHRoaXMuZGlhbG9nLnByYWNrZWQubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZWFybHlEaWFsb2dzW2lkXSAmJiAhdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnLCB0cnVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5pbmRleE9mKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKSAhPT0gLTEgfHxcbiAgICAgICAgICAodGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWRbdGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQubGVuZ3RoLTFdID49IHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICYmIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JBY2s6ICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSArICcgJyArIHJlc3BvbnNlLmdldEhlYWRlcignY3NlcScpKTtcbiAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLnB1c2gocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpO1xuXG4gICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0uc2VuZFJlcXVlc3QodGhpcywgU0lQLkMuUFJBQ0ssIHtcbiAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgIGJvZHk6IFNJUC5VdGlscy5nZW5lcmF0ZUZha2VTRFAocmVzcG9uc2UuYm9keSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByb2NlZWQgdG8gY2FuY2VsbGF0aW9uIGlmIHRoZSB1c2VyIHJlcXVlc3RlZC5cbiAgICBpZih0aGlzLmlzQ2FuY2VsZWQpIHtcbiAgICAgIGlmKHJlc3BvbnNlLnN0YXR1c19jb2RlID49IDEwMCAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA8IDIwMCkge1xuICAgICAgICB0aGlzLnJlcXVlc3QuY2FuY2VsKHRoaXMuY2FuY2VsUmVhc29uKTtcbiAgICAgICAgdGhpcy5jYW5jZWxlZChudWxsKTtcbiAgICAgIH0gZWxzZSBpZihyZXNwb25zZS5zdGF0dXNfY29kZSA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPCAyOTkpIHtcbiAgICAgICAgdGhpcy5hY2NlcHRBbmRUZXJtaW5hdGUocmVzcG9uc2UpO1xuICAgICAgICB0aGlzLmVtaXQoJ2J5ZScsIHRoaXMucmVxdWVzdCk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID49IDMwMCkge1xuICAgICAgICBjYXVzZSA9IFNJUC5DLlJFQVNPTl9QSFJBU0VbcmVzcG9uc2Uuc3RhdHVzX2NvZGVdIHx8IFNJUC5DLmNhdXNlcy5DQU5DRUxFRDtcbiAgICAgICAgdGhpcy5yZWplY3RlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2godHJ1ZSkge1xuICAgICAgY2FzZSAvXjEwMCQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICB0aGlzLnJlY2VpdmVkXzEwMCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAoL14xWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKSk6XG4gICAgICAgIC8vIERvIG5vdGhpbmcgd2l0aCAxeHggcmVzcG9uc2VzIHdpdGhvdXQgVG8gdGFnLlxuICAgICAgICBpZighcmVzcG9uc2UudG9fdGFnKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybignMXh4IHJlc3BvbnNlIHJlY2VpdmVkIHdpdGhvdXQgdG8gdGFnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgRWFybHkgRGlhbG9nIGlmIDFYWCBjb21lcyB3aXRoIGNvbnRhY3RcbiAgICAgICAgaWYocmVzcG9uc2UuaGFzSGVhZGVyKCdjb250YWN0JykpIHtcbiAgICAgICAgICAvLyBBbiBlcnJvciBvbiBkaWFsb2cgY3JlYXRpb24gd2lsbCBmaXJlICdmYWlsZWQnIGV2ZW50XG4gICAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycsIHRydWUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTXzFYWF9SRUNFSVZFRDtcblxuICAgICAgICBpZihyZXNwb25zZS5oYXNIZWFkZXIoJ3JlcXVpcmUnKSAmJlxuICAgICAgICAgICByZXNwb25zZS5nZXRIZWFkZXIoJ3JlcXVpcmUnKS5pbmRleE9mKCcxMDByZWwnKSAhPT0gLTEpIHtcblxuICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhpcy5kaWFsb2cgaXMgYWxyZWFkeSBjb25maXJtZWRcbiAgICAgICAgICBpZiAodGhpcy5kaWFsb2cgfHwgIXRoaXMuZWFybHlEaWFsb2dzW2lkXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLmluZGV4T2YocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAodGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWRbdGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQubGVuZ3RoLTFdID49IHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICYmIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgU0lQLkhhY2tzLkZpcmVmb3guY2Fubm90SGFuZGxlRXh0cmFXaGl0ZXNwYWNlKHJlc3BvbnNlKTtcbiAgICAgICAgICBTSVAuSGFja3MuQWxsQnJvd3NlcnMubWFza0R0bHMocmVzcG9uc2UpO1xuXG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnUkFjazogJyArIHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICsgJyAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdjc2VxJykpO1xuICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQucHVzaChyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSk7XG4gICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0uc2VuZFJlcXVlc3QodGhpcywgU0lQLkMuUFJBQ0ssIHtcbiAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNPZmZlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kaWFsb2cucHJhY2tlZC5wdXNoKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKTtcblxuICAgICAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVzcG9uc2UuYm9keSlcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiBvblN1Y2Nlc3MgKCkge1xuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSQWNrOiAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykgKyAnICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ2NzZXEnKSk7XG5cbiAgICAgICAgICAgICAgICBzZXNzaW9uLnNlbmRSZXF1ZXN0KFNJUC5DLlBSQUNLLCB7XG4gICAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5tdXRlKCk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0YXR1cyA9PT0gQy5TVEFUVVNfRUFSTFlfTUVESUEpIHtcbiAgICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpWzBdLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlIChlKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmFjY2VwdEFuZFRlcm1pbmF0ZShyZXNwb25zZSwgNDg4LCAnTm90IEFjY2VwdGFibGUgSGVyZScpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVhcmx5RGlhbG9nID0gdGhpcy5lYXJseURpYWxvZ3NbaWRdO1xuICAgICAgICAgICAgdmFyIGVhcmx5TWVkaWEgPSBlYXJseURpYWxvZy5tZWRpYUhhbmRsZXI7XG5cbiAgICAgICAgICAgIGVhcmx5RGlhbG9nLnByYWNrZWQucHVzaChyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSk7XG5cbiAgICAgICAgICAgIGVhcmx5TWVkaWEuc2V0RGVzY3JpcHRpb24ocmVzcG9uc2UuYm9keSlcbiAgICAgICAgICAgIC50aGVuKGVhcmx5TWVkaWEuZ2V0RGVzY3JpcHRpb24uYmluZChlYXJseU1lZGlhLCBzZXNzaW9uLm1lZGlhSGludCkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiBvblN1Y2Nlc3Moc2RwKSB7XG4gICAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL3NkcCcpO1xuICAgICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnUkFjazogJyArIHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICsgJyAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdjc2VxJykpO1xuICAgICAgICAgICAgICBlYXJseURpYWxvZy5zZW5kUmVxdWVzdChzZXNzaW9uLCBTSVAuQy5QUkFDSywge1xuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHNkcFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5zdGF0dXMgPSBDLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gb25GYWlsdXJlKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTSVAuRXhjZXB0aW9ucy5HZXREZXNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgZWFybHlEaWFsb2cucHJhY2tlZC5wdXNoKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIGZhaWwgb3V0IG9uIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gc2Vzc2lvbi5mYWlsZWQoZ3VtIGVycm9yKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWFybHlEaWFsb2cucHJhY2tlZC5zcGxpY2UoZWFybHlEaWFsb2cucHJhY2tlZC5pbmRleE9mKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKSwgMSk7XG4gICAgICAgICAgICAgICAgLy8gQ291bGQgbm90IHNldCByZW1vdGUgZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKCdpbnZhbGlkIFNEUCcpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICB2YXIgY3NlcSA9IHRoaXMucmVxdWVzdC5jc2VxICsgJyAnICsgdGhpcy5yZXF1ZXN0Lm1ldGhvZDtcbiAgICAgICAgaWYgKGNzZXEgIT09IHJlc3BvbnNlLmdldEhlYWRlcignY3NlcScpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBICYmIHRoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgdGhpcy51bm11dGUoKTtcbiAgICAgICAgICAvKmxvY2FsTWVkaWEgPSB0aGlzLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhO1xuICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9Ki9cbiAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgaWYgKHRoaXMucmVuZGVyYm9keSkge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogJyArIHRoaXMucmVuZGVydHlwZSk7XG4gICAgICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcbiAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IHRoaXMucmVuZGVyYm9keTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0aW9ucy5jc2VxID0gcmVzcG9uc2UuY3NlcTtcbiAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSywgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5hY2NlcHRlZChyZXNwb25zZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGlzLmRpYWxvZyBpcyBhbHJlYWR5IGNvbmZpcm1lZFxuICAgICAgICBpZiAodGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIFNJUC5IYWNrcy5GaXJlZm94LmNhbm5vdEhhbmRsZUV4dHJhV2hpdGVzcGFjZShyZXNwb25zZSk7XG4gICAgICAgIFNJUC5IYWNrcy5BbGxCcm93c2Vycy5tYXNrRHRscyhyZXNwb25zZSk7XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnZpdGUgd2l0aG91dCBzZHBcbiAgICAgICAgaWYgKCF0aGlzLmhhc09mZmVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWFybHlEaWFsb2dzW2lkXSAmJiB0aGlzLmVhcmx5RGlhbG9nc1tpZF0ubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWEpIHtcbiAgICAgICAgICAgIC8vUkVWSVNJVFxuICAgICAgICAgICAgdGhpcy5oYXNPZmZlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1lZGlhSGFuZGxlciA9IHRoaXMuZWFybHlEaWFsb2dzW2lkXS5tZWRpYUhhbmRsZXI7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuQUNLLCB7Y3NlcTpyZXNwb25zZS5jc2VxfSk7XG5cbiAgICAgICAgICAgIHRoaXMudW5tdXRlKCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgbG9jYWxNZWRpYSA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWE7XG4gICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdGhpcy5hY2NlcHRlZChyZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICAgIHRoaXMuYWNjZXB0QW5kVGVybWluYXRlKHJlc3BvbnNlLCA0MDAsICdNaXNzaW5nIHNlc3Npb24gZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFzT2ZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVzcG9uc2UuYm9keSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMubWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uLmJpbmQodGhpcy5tZWRpYUhhbmRsZXIsIHRoaXMubWVkaWFIaW50KSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIG9uU3VjY2VzcyhzZHApIHtcbiAgICAgICAgICAgICAgLy92YXIgbG9jYWxNZWRpYTtcbiAgICAgICAgICAgICAgaWYoc2Vzc2lvbi5pc0NhbmNlbGVkIHx8IHNlc3Npb24uc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2RwID0gU0lQLkhhY2tzLkZpcmVmb3guaGFzTWlzc2luZ0NMaW5lSW5TRFAoc2RwKTtcblxuICAgICAgICAgICAgICBzZXNzaW9uLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5oYXNBbnN3ZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIHNlc3Npb24udW5tdXRlKCk7XG4gICAgICAgICAgICAgIC8qbG9jYWxNZWRpYSA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWE7XG4gICAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgICBzZXNzaW9uLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSyx7XG4gICAgICAgICAgICAgICAgYm9keTogc2RwLFxuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczpbJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vc2RwJ10sXG4gICAgICAgICAgICAgICAgY3NlcTpyZXNwb25zZS5jc2VxXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZXNzaW9uLmFjY2VwdGVkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gb25GYWlsdXJlKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTSVAuRXhjZXB0aW9ucy5HZXREZXNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBkbyBzb21ldGhpbmcgaGVyZVxuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oXCJ0aGVyZSB3YXMgYSBwcm9ibGVtXCIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oJ2ludmFsaWQgU0RQJyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5yZXBseSg0ODgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNBbnN3ZXIpe1xuICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmJvZHkpIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6ICcgKyBzZXNzaW9uLnJlbmRlcnR5cGUpO1xuICAgICAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSB0aGlzLnJlbmRlcmJvZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuQUNLLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZighcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgdGhpcy5hY2NlcHRBbmRUZXJtaW5hdGUocmVzcG9uc2UsIDQwMCwgJ01pc3Npbmcgc2Vzc2lvbiBkZXNjcmlwdGlvbicpO1xuICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5ib2R5KVxuICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzICgpIHtcbiAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTsvLyxsb2NhbE1lZGlhO1xuICAgICAgICAgICAgICBzZXNzaW9uLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgICAgICAgICAgc2Vzc2lvbi51bm11dGUoKTtcbiAgICAgICAgICAgICAgLypsb2NhbE1lZGlhID0gc2Vzc2lvbi5tZWRpYUhhbmRsZXIubG9jYWxNZWRpYTtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgIGlmIChzZXNzaW9uLnJlbmRlcmJvZHkpIHtcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiAnICsgc2Vzc2lvbi5yZW5kZXJ0eXBlKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBzZXNzaW9uLnJlbmRlcmJvZHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3B0aW9ucy5jc2VxID0gcmVzcG9uc2UuY3NlcTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdChTSVAuQy5BQ0ssIG9wdGlvbnMpO1xuICAgICAgICAgICAgICBzZXNzaW9uLmFjY2VwdGVkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUgKGUpIHtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5hY2NlcHRBbmRUZXJtaW5hdGUocmVzcG9uc2UsIDQ4OCwgJ05vdCBBY2NlcHRhYmxlIEhlcmUnKTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjYXVzZSA9IFNJUC5VdGlscy5zaXBFcnJvckNhdXNlKHJlc3BvbnNlLnN0YXR1c19jb2RlKTtcbiAgICAgICAgdGhpcy5yZWplY3RlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICB9XG4gIH0sXG5cbiAgY2FuY2VsOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCB8fCB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZygnY2FuY2VsaW5nIFJUQ1Nlc3Npb24nKTtcblxuICAgIHZhciBjYW5jZWxfcmVhc29uID0gU0lQLlV0aWxzLmdldENhbmNlbFJlYXNvbihvcHRpb25zLnN0YXR1c19jb2RlLCBvcHRpb25zLnJlYXNvbl9waHJhc2UpO1xuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX05VTEwgfHxcbiAgICAgICAgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19JTlZJVEVfU0VOVCAmJiAhdGhpcy5yZWNlaXZlZF8xMDApKSB7XG4gICAgICB0aGlzLmlzQ2FuY2VsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jYW5jZWxSZWFzb24gPSBjYW5jZWxfcmVhc29uO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0lOVklURV9TRU5UIHx8XG4gICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfMVhYX1JFQ0VJVkVEIHx8XG4gICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfRUFSTFlfTUVESUEpIHtcbiAgICAgIHRoaXMucmVxdWVzdC5jYW5jZWwoY2FuY2VsX3JlYXNvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2FuY2VsZWQoKTtcbiAgfSxcblxuICB0ZXJtaW5hdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLIHx8IHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMuYnllKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbmNlbChvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZWNlaXZlUmVxdWVzdDogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIC8vIElDQyBSRUNFSVZFIFJFUVVFU1RcblxuICAgIC8vIFJlamVjdCBDQU5DRUxzXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5DQU5DRUwpIHtcbiAgICAgIC8vIFRPRE87IG1ha2UgdGhpcyBhIHN3aXRjaCB3aGVuIGl0IGdldHMgYWRkZWRcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFNJUC5DLkFDSyAmJiB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5hY2tUaW1lcik7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgIHRoaXMudW5tdXRlKCk7XG5cbiAgICAgIHRoaXMuYWNjZXB0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU2Vzc2lvbi5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QuYXBwbHkodGhpcywgW3JlcXVlc3RdKTtcbiAgfSxcblxuICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH1cbiAgfSxcblxuICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5TSVAuSW52aXRlQ2xpZW50Q29udGV4dCA9IEludml0ZUNsaWVudENvbnRleHQ7XG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1Nlc3Npb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERUTUZcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBEVE1GXG4gKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuXG52YXIgRFRNRixcbiAgQyA9IHtcbiAgICBNSU5fRFVSQVRJT046ICAgICAgICAgICAgNzAsXG4gICAgTUFYX0RVUkFUSU9OOiAgICAgICAgICAgIDYwMDAsXG4gICAgREVGQVVMVF9EVVJBVElPTjogICAgICAgIDEwMCxcbiAgICBNSU5fSU5URVJfVE9ORV9HQVA6ICAgICAgNTAsXG4gICAgREVGQVVMVF9JTlRFUl9UT05FX0dBUDogIDUwMFxuICB9O1xuXG5EVE1GID0gZnVuY3Rpb24oc2Vzc2lvbiwgdG9uZSwgb3B0aW9ucykge1xuICB2YXIgZHVyYXRpb24sIGludGVyVG9uZUdhcDtcblxuICBpZiAodG9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgfVxuXG4gIHRoaXMubG9nZ2VyID0gc2Vzc2lvbi51YS5nZXRMb2dnZXIoJ3NpcC5pbnZpdGVjb250ZXh0LmR0bWYnLCBzZXNzaW9uLmlkKTtcbiAgdGhpcy5vd25lciA9IHNlc3Npb247XG4gIHRoaXMuZGlyZWN0aW9uID0gbnVsbDtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IG51bGw7XG4gIGludGVyVG9uZUdhcCA9IG9wdGlvbnMuaW50ZXJUb25lR2FwIHx8IG51bGw7XG5cbiAgLy8gQ2hlY2sgdG9uZSB0eXBlXG4gIGlmICh0eXBlb2YgdG9uZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgdG9uZSA9IHRvbmUudG9VcHBlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdG9uZSA9PT0gJ251bWJlcicpIHtcbiAgICB0b25lID0gdG9uZS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdG9uZTogJysgdG9uZSk7XG4gIH1cblxuICAvLyBDaGVjayB0b25lIHZhbHVlXG4gIGlmICghdG9uZS5tYXRjaCgvXlswLTlBLUQjKl0kLykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRvbmU6ICcrIHRvbmUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9uZSA9IHRvbmU7XG4gIH1cblxuICAvLyBDaGVjayBkdXJhdGlvblxuICBpZiAoZHVyYXRpb24gJiYgIVNJUC5VdGlscy5pc0RlY2ltYWwoZHVyYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0b25lIGR1cmF0aW9uOiAnKyBkdXJhdGlvbik7XG4gIH0gZWxzZSBpZiAoIWR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gPSBEVE1GLkMuREVGQVVMVF9EVVJBVElPTjtcbiAgfSBlbHNlIGlmIChkdXJhdGlvbiA8IERUTUYuQy5NSU5fRFVSQVRJT04pIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdcImR1cmF0aW9uXCIgdmFsdWUgaXMgbG93ZXIgdGhhbiB0aGUgbWluaW11bSBhbGxvd2VkLCBzZXR0aW5nIGl0IHRvICcrIERUTUYuQy5NSU5fRFVSQVRJT04rICcgbWlsbGlzZWNvbmRzJyk7XG4gICAgZHVyYXRpb24gPSBEVE1GLkMuTUlOX0RVUkFUSU9OO1xuICB9IGVsc2UgaWYgKGR1cmF0aW9uID4gRFRNRi5DLk1BWF9EVVJBVElPTikge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ1wiZHVyYXRpb25cIiB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCwgc2V0dGluZyBpdCB0byAnKyBEVE1GLkMuTUFYX0RVUkFUSU9OICsnIG1pbGxpc2Vjb25kcycpO1xuICAgIGR1cmF0aW9uID0gRFRNRi5DLk1BWF9EVVJBVElPTjtcbiAgfSBlbHNlIHtcbiAgICBkdXJhdGlvbiA9IE1hdGguYWJzKGR1cmF0aW9uKTtcbiAgfVxuICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG5cbiAgLy8gQ2hlY2sgaW50ZXJUb25lR2FwXG4gIGlmIChpbnRlclRvbmVHYXAgJiYgIVNJUC5VdGlscy5pc0RlY2ltYWwoaW50ZXJUb25lR2FwKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaW50ZXJUb25lR2FwOiAnKyBpbnRlclRvbmVHYXApO1xuICB9IGVsc2UgaWYgKCFpbnRlclRvbmVHYXApIHtcbiAgICBpbnRlclRvbmVHYXAgPSBEVE1GLkMuREVGQVVMVF9JTlRFUl9UT05FX0dBUDtcbiAgfSBlbHNlIGlmIChpbnRlclRvbmVHYXAgPCBEVE1GLkMuTUlOX0lOVEVSX1RPTkVfR0FQKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignXCJpbnRlclRvbmVHYXBcIiB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBtaW5pbXVtIGFsbG93ZWQsIHNldHRpbmcgaXQgdG8gJysgRFRNRi5DLk1JTl9JTlRFUl9UT05FX0dBUCArJyBtaWxsaXNlY29uZHMnKTtcbiAgICBpbnRlclRvbmVHYXAgPSBEVE1GLkMuTUlOX0lOVEVSX1RPTkVfR0FQO1xuICB9IGVsc2Uge1xuICAgIGludGVyVG9uZUdhcCA9IE1hdGguYWJzKGludGVyVG9uZUdhcCk7XG4gIH1cbiAgdGhpcy5pbnRlclRvbmVHYXAgPSBpbnRlclRvbmVHYXA7XG59O1xuRFRNRi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuXG5EVE1GLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgZXh0cmFIZWFkZXJzLCBib2R5O1xuXG4gIHRoaXMuZGlyZWN0aW9uID0gJ291dGdvaW5nJztcblxuICAvLyBDaGVjayBSVENTZXNzaW9uIFN0YXR1c1xuICBpZiAodGhpcy5vd25lci5zdGF0dXMgIT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX0NPTkZJUk1FRCAmJlxuICAgIHRoaXMub3duZXIuc3RhdHVzICE9PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5vd25lci5zdGF0dXMpO1xuICB9XG5cbiAgLy8gR2V0IERUTUYgb3B0aW9uc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgPyBvcHRpb25zLmV4dHJhSGVhZGVycy5zbGljZSgpIDogW107XG5cbiAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vZHRtZi1yZWxheScpO1xuXG4gIGJvZHkgPSBcIlNpZ25hbD0gXCIgKyB0aGlzLnRvbmUgKyBcIlxcclxcblwiO1xuICBib2R5ICs9IFwiRHVyYXRpb249IFwiICsgdGhpcy5kdXJhdGlvbjtcblxuICB0aGlzLnJlcXVlc3QgPSB0aGlzLm93bmVyLmRpYWxvZy5zZW5kUmVxdWVzdCh0aGlzLCBTSVAuQy5JTkZPLCB7XG4gICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgYm9keTogYm9keVxuICB9KTtcblxuICB0aGlzLm93bmVyLmVtaXQoJ2R0bWYnLCB0aGlzLnJlcXVlc3QsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5EVE1GLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICB2YXIgY2F1c2U7XG5cbiAgc3dpdGNoKHRydWUpIHtcbiAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAvLyBJZ25vcmUgcHJvdmlzaW9uYWwgcmVzcG9uc2VzLlxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICB0aGlzLmVtaXQoJ3N1Y2NlZWRlZCcsIHtcbiAgICAgICAgb3JpZ2luYXRvcjogJ3JlbW90ZScsXG4gICAgICAgIHJlc3BvbnNlOiByZXNwb25zZVxuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBjYXVzZSA9IFNJUC5VdGlscy5zaXBFcnJvckNhdXNlKHJlc3BvbnNlLnN0YXR1c19jb2RlKTtcbiAgICAgIHRoaXMuZW1pdCgnZmFpbGVkJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkRUTUYucHJvdG90eXBlLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgdGhpcy5vd25lci5vblJlcXVlc3RUaW1lb3V0KCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkRUTUYucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gIHRoaXMub3duZXIub25UcmFuc3BvcnRFcnJvcigpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5EVE1GLnByb3RvdHlwZS5vbkRpYWxvZ0Vycm9yID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCByZXNwb25zZSwgU0lQLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gIHRoaXMub3duZXIub25EaWFsb2dFcnJvcihyZXNwb25zZSk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkRUTUYucHJvdG90eXBlLmluaXRfaW5jb21pbmcgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHRoaXMuZGlyZWN0aW9uID0gJ2luY29taW5nJztcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcblxuICByZXF1ZXN0LnJlcGx5KDIwMCk7XG5cbiAgaWYgKCF0aGlzLnRvbmUgfHwgIXRoaXMuZHVyYXRpb24pIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdpbnZhbGlkIElORk8gRFRNRiByZWNlaXZlZCwgZGlzY2FyZGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vd25lci5lbWl0KCdkdG1mJywgcmVxdWVzdCwgdGhpcyk7XG4gIH1cbn07XG5cbkRUTUYuQyA9IEM7XG5yZXR1cm4gRFRNRjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1Nlc3Npb24vRFRNRi5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgU3Vic2NyaWJlciAoU0lQLVNwZWNpZmljIEV2ZW50IE5vdGlmaWNhdGlvbnMgUkZDNjY2NSlcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIFNJUCBTdWJzY3JpcHRpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuU0lQLlN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICh1YSwgdGFyZ2V0LCBldmVudCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuXG4gIHRoaXMuaWQgPSBudWxsO1xuICB0aGlzLnN0YXRlID0gJ2luaXQnO1xuXG4gIGlmICghZXZlbnQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFdmVudCBuZWNlc3NhcnkgdG8gY3JlYXRlIGEgc3Vic2NyaXB0aW9uLicpO1xuICB9IGVsc2Uge1xuICAgIC8vVE9ETzogY2hlY2sgZm9yIHZhbGlkIGV2ZW50cyBoZXJlIHByb2JhYmx5IG1ha2UgYSBsaXN0IGluIFNJUC5DOyBvciBsZWF2ZSBpdCB1cCB0byBhcHAgdG8gY2hlY2s/XG4gICAgLy9UaGUgY2hlY2sgbWF5IG5lZWQgdG8vc2hvdWxkIHByb2JhYmx5IG9jY3VyIG9uIHRoZSBvdGhlciBzaWRlLFxuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgfVxuXG4gIGlmKHR5cGVvZiBvcHRpb25zLmV4cGlyZXMgIT09ICdudW1iZXInKXtcbiAgICB1YS5sb2dnZXIud2FybignZXhwaXJlcyBtdXN0IGJlIGEgbnVtYmVyLiBVc2luZyBkZWZhdWx0IG9mIDM2MDAuJyk7XG4gICAgdGhpcy5leHBpcmVzID0gMzYwMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmV4cGlyZXMgPSBvcHRpb25zLmV4cGlyZXM7XG4gIH1cblxuICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdFdmVudDogJyArIHRoaXMuZXZlbnQpO1xuICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdFeHBpcmVzOiAnICsgdGhpcy5leHBpcmVzKTtcblxuICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgdGhpcy5ib2R5ID0gb3B0aW9ucy5ib2R5O1xuICB9XG5cbiAgdGhpcy5jb250YWN0ID0gdWEuY29udGFjdC50b1N0cmluZygpO1xuXG4gIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcrIHRoaXMuY29udGFjdCk7XG4gIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG5cbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLkNsaWVudENvbnRleHQsIFt1YSwgU0lQLkMuU1VCU0NSSUJFLCB0YXJnZXQsIG9wdGlvbnNdKTtcblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnN1YnNjcmlwdGlvbicpO1xuXG4gIHRoaXMuZGlhbG9nID0gbnVsbDtcbiAgdGhpcy50aW1lcnMgPSB7TjogbnVsbCwgc3ViX2R1cmF0aW9uOiBudWxsfTtcbiAgdGhpcy5lcnJvckNvZGVzICA9IFs0MDQsNDA1LDQxMCw0MTYsNDgwLDQ4MSw0ODIsNDgzLDQ4NCw0ODUsNDg5LDUwMSw2MDRdO1xufTtcblxuU0lQLlN1YnNjcmlwdGlvbi5wcm90b3R5cGUgPSB7XG4gIHN1YnNjcmliZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN1YiA9IHRoaXM7XG5cbiAgICAgLy90aGVzZSBzdGF0ZXMgcG9pbnQgdG8gYW4gZXhpc3Rpbmcgc3Vic2NyaXB0aW9uLCBubyBzdWJzY3JpYmUgaXMgbmVjZXNzYXJ5XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICdhY3RpdmUnKSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ25vdGlmeV93YWl0Jykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uKTtcbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcbiAgICB0aGlzLnRpbWVycy5OID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHN1Yi50aW1lcl9maXJlLmJpbmQoc3ViKSwgU0lQLlRpbWVycy5USU1FUl9OKTtcblxuICAgIHRoaXMuc2VuZCgpO1xuXG4gICAgdGhpcy5zdGF0ZSA9ICdub3RpZnlfd2FpdCc7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICd0ZXJtaW5hdGVkJyB8fCB0aGlzLnN0YXRlID09PSAncGVuZGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ25vdGlmeV93YWl0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGlhbG9nLnNlbmRSZXF1ZXN0KHRoaXMsIFNJUC5DLlNVQlNDUklCRSwge1xuICAgICAgZXh0cmFIZWFkZXJzOiB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICAgIGJvZHk6IHRoaXMuYm9keVxuICAgIH0pO1xuICB9LFxuXG4gIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB2YXIgZXhwaXJlcywgc3ViID0gdGhpcyxcbiAgICAgICAgY2F1c2UgPSBTSVAuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHJlc3BvbnNlLnN0YXR1c19jb2RlKTtcblxuICAgIGlmICgodGhpcy5zdGF0ZSA9PT0gJ25vdGlmeV93YWl0JyAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA+PSAzMDApIHx8XG4gICAgICAgICh0aGlzLnN0YXRlICE9PSAnbm90aWZ5X3dhaXQnICYmIHRoaXMuZXJyb3JDb2Rlcy5pbmRleE9mKHJlc3BvbnNlLnN0YXR1c19jb2RlKSAhPT0gLTEpKSB7XG4gICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgbnVsbCk7XG4gICAgfSBlbHNlIGlmICgvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpKXtcbiAgICAgIGV4cGlyZXMgPSByZXNwb25zZS5nZXRIZWFkZXIoJ0V4cGlyZXMnKTtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLk4pO1xuXG4gICAgICBpZiAodGhpcy5jcmVhdGVDb25maXJtZWREaWFsb2cocmVzcG9uc2UsJ1VBQycpKSB7XG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLmRpYWxvZy5pZC50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnVhLnN1YnNjcmlwdGlvbnNbdGhpcy5pZF0gPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXQoJ2FjY2VwdGVkJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgLy8gVVBEQVRFIFJPVVRFIFNFVCBUTyBCRSBCQUNLV0FSRFMgQ09NUEFUSUJMRT9cbiAgICAgIH1cblxuICAgICAgaWYgKGV4cGlyZXMgJiYgZXhwaXJlcyA8PSB0aGlzLmV4cGlyZXMpIHtcbiAgICAgICAgLy8gUHJlc2VydmUgbmV3IGV4cGlyZXMgdmFsdWUgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHNcbiAgICAgICAgdGhpcy5leHBpcmVzID0gZXhwaXJlcztcbiAgICAgICAgdGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHN1Yi5yZWZyZXNoLmJpbmQoc3ViKSwgZXhwaXJlcyAqIDkwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWV4cGlyZXMpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdFeHBpcmVzIGhlYWRlciBtaXNzaW5nIGluIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIFNVQlNDUklCRScpO1xuICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5FWFBJUkVTX0hFQURFUl9NSVNTSU5HKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdFeHBpcmVzIGhlYWRlciBpbiBhIDIwMC1jbGFzcyByZXNwb25zZSB0byBTVUJTQ1JJQkUgd2l0aCBhIGhpZ2hlciB2YWx1ZSB0aGFuIHRoZSBvbmUgaW4gdGhlIHJlcXVlc3QnKTtcbiAgICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuSU5WQUxJRF9FWFBJUkVTX0hFQURFUik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vVXNlZCB0byBqdXN0IGlnbm9yZSBwcm92aXNpb25hbCByZXNwb25zZXM7IG5vdyBpZ25vcmVzIGV2ZXJ5dGhpbmcgZXhjZXB0IGVycm9yQ29kZXMgYW5kIDJ4eFxuICB9LFxuXG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0cmFIZWFkZXJzID0gW10sIHN1YiA9IHRoaXM7XG5cbiAgICB0aGlzLnN0YXRlID0gJ3Rlcm1pbmF0ZWQnO1xuXG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0V2ZW50OiAnICsgdGhpcy5ldmVudCk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0V4cGlyZXM6IDAnKTtcblxuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnKyB0aGlzLmNvbnRhY3QpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJysgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCkpO1xuXG4gICAgLy9tYWtlcyBzdXJlIGV4cGlyZXMgaXNuJ3Qgc2V0LCBhbmQgb3RoZXIgdHlwaWNhbCByZXN1YnNjcmliZSBiZWhhdmlvclxuICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24oKXt9O1xuXG4gICAgdGhpcy5kaWFsb2cuc2VuZFJlcXVlc3QodGhpcywgdGhpcy5tZXRob2QsIHtcbiAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgYm9keTogdGhpcy5ib2R5XG4gICAgfSk7XG5cbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zdWJfZHVyYXRpb24pO1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLk4pO1xuICAgIHRoaXMudGltZXJzLk4gPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoc3ViLnRpbWVyX2ZpcmUuYmluZChzdWIpLCBTSVAuVGltZXJzLlRJTUVSX04pO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICovXG4gIHRpbWVyX2ZpcmU6IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICd0ZXJtaW5hdGVkJykge1xuICAgICAgdGhpcy50ZXJtaW5hdGVEaWFsb2coKTtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLk4pO1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uKTtcblxuICAgICAgZGVsZXRlIHRoaXMudWEuc3Vic2NyaXB0aW9uc1t0aGlzLmlkXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdwZW5kaW5nJyB8fCB0aGlzLnN0YXRlID09PSAnbm90aWZ5X3dhaXQnKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5zdGF0ZSAhPT0gJ25vdGlmeV93YWl0JyAmJiB0aGlzLnN0YXRlICE9PSAndGVybWluYXRlZCcpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKi9cbiAgY3JlYXRlQ29uZmlybWVkRGlhbG9nOiBmdW5jdGlvbihtZXNzYWdlLCB0eXBlKSB7XG4gICAgdmFyIGRpYWxvZztcblxuICAgIHRoaXMudGVybWluYXRlRGlhbG9nKCk7XG4gICAgZGlhbG9nID0gbmV3IFNJUC5EaWFsb2codGhpcywgbWVzc2FnZSwgdHlwZSk7XG5cbiAgICBpZighZGlhbG9nLmVycm9yKSB7XG4gICAgICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBEaWFsb2cgbm90IGNyZWF0ZWQgZHVlIHRvIGFuIGVycm9yXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICovXG4gIHRlcm1pbmF0ZURpYWxvZzogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5kaWFsb2cpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnVhLnN1YnNjcmlwdGlvbnNbdGhpcy5pZF07XG4gICAgICB0aGlzLmRpYWxvZy50ZXJtaW5hdGUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRpYWxvZztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKi9cbiAgcmVjZWl2ZVJlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgc3ViX3N0YXRlLCBzdWIgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gc2V0RXhwaXJlc1RpbWVvdXQoKSB7XG4gICAgICBpZiAoc3ViX3N0YXRlLmV4cGlyZXMpIHtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQoc3ViLnRpbWVycy5zdWJfZHVyYXRpb24pO1xuICAgICAgICBzdWJfc3RhdGUuZXhwaXJlcyA9IE1hdGgubWluKHN1Yi5leHBpcmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHN1Yl9zdGF0ZS5leHBpcmVzLCAwKSk7XG4gICAgICAgIHN1Yi50aW1lcnMuc3ViX2R1cmF0aW9uID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHN1Yi5yZWZyZXNoLmJpbmQoc3ViKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJfc3RhdGUuZXhwaXJlcyAqIDkwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm1hdGNoRXZlbnQocmVxdWVzdCkpIHsgLy9jaGVja3MgZXZlbnQgYW5kIHN1YnNjcmlwdGlvbl9zdGF0ZSBoZWFkZXJzXG4gICAgICByZXF1ZXN0LnJlcGx5KDQ4OSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3ViX3N0YXRlID0gcmVxdWVzdC5wYXJzZUhlYWRlcignU3Vic2NyaXB0aW9uLVN0YXRlJyk7XG5cbiAgICByZXF1ZXN0LnJlcGx5KDIwMCwgU0lQLkMuUkVBU09OXzIwMCk7XG5cbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcblxuICAgIHRoaXMuZW1pdCgnbm90aWZ5Jywge3JlcXVlc3Q6IHJlcXVlc3R9KTtcblxuICAgIC8vIGlmIHdlJ3ZlIHNldCBzdGF0ZSB0byB0ZXJtaW5hdGVkLCBubyBmdXJ0aGVyIHByb2Nlc3Npbmcgc2hvdWxkIHRha2UgcGxhY2VcbiAgICAvLyBhbmQgd2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBjbGVhbmluZyB1cCBhZnRlciB0aGUgYXBwcm9wcmlhdGUgTk9USUZZXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICd0ZXJtaW5hdGVkJykge1xuICAgICAgaWYgKHN1Yl9zdGF0ZS5zdGF0ZSA9PT0gJ3Rlcm1pbmF0ZWQnKSB7XG4gICAgICAgIHRoaXMudGVybWluYXRlRGlhbG9nKCk7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLk4pO1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zdWJfZHVyYXRpb24pO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLnVhLnN1YnNjcmlwdGlvbnNbdGhpcy5pZF07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoIChzdWJfc3RhdGUuc3RhdGUpIHtcbiAgICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnYWN0aXZlJztcbiAgICAgICAgc2V0RXhwaXJlc1RpbWVvdXQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdub3RpZnlfd2FpdCcpIHtcbiAgICAgICAgICBzZXRFeHBpcmVzVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAncGVuZGluZyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGVybWluYXRlZCc6XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbik7XG4gICAgICAgIGlmIChzdWJfc3RhdGUucmVhc29uKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCd0ZXJtaW5hdGluZyBzdWJzY3JpcHRpb24gd2l0aCByZWFzb24gJysgc3ViX3N0YXRlLnJlYXNvbik7XG4gICAgICAgICAgc3dpdGNoIChzdWJfc3RhdGUucmVhc29uKSB7XG4gICAgICAgICAgICBjYXNlICdkZWFjdGl2YXRlZCc6XG4gICAgICAgICAgICBjYXNlICd0aW1lb3V0JzpcbiAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAncHJvYmF0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ2dpdmV1cCc6XG4gICAgICAgICAgICAgIGlmKHN1Yl9zdGF0ZS5wYXJhbXMgJiYgc3ViX3N0YXRlLnBhcmFtc1sncmV0cnktYWZ0ZXInXSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChzdWIuc3Vic2NyaWJlLmJpbmQoc3ViKSwgc3ViX3N0YXRlLnBhcmFtc1sncmV0cnktYWZ0ZXInXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICBjYXNlICdub3Jlc291cmNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2ludmFyaWFudCc6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICBmYWlsZWQ6IGZ1bmN0aW9uKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb25EaWFsb2dFcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gIH0sXG5cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKi9cbiAgbWF0Y2hFdmVudDogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHZhciBldmVudDtcblxuICAgIC8vIENoZWNrIG1hbmRhdG9yeSBoZWFkZXIgRXZlbnRcbiAgICBpZiAoIXJlcXVlc3QuaGFzSGVhZGVyKCdFdmVudCcpKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdtaXNzaW5nIEV2ZW50IGhlYWRlcicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayBtYW5kYXRvcnkgaGVhZGVyIFN1YnNjcmlwdGlvbi1TdGF0ZVxuICAgIGlmICghcmVxdWVzdC5oYXNIZWFkZXIoJ1N1YnNjcmlwdGlvbi1TdGF0ZScpKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdtaXNzaW5nIFN1YnNjcmlwdGlvbi1TdGF0ZSBoZWFkZXInKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBldmVudCBpbiBOT1RJRlkgbWF0Y2hlcyB0aGUgZXZlbnQgaW4gU1VCU0NSSUJFXG4gICAgZXZlbnQgPSByZXF1ZXN0LnBhcnNlSGVhZGVyKCdldmVudCcpLmV2ZW50O1xuXG4gICAgaWYgKHRoaXMuZXZlbnQgIT09IGV2ZW50KSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdldmVudCBtYXRjaCBmYWlsZWQnKTtcbiAgICAgIHJlcXVlc3QucmVwbHkoNDgxLCAnRXZlbnQgTWF0Y2ggRmFpbGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1N1YnNjcmlwdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgV2ViUlRDXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQLCBlbnZpcm9ubWVudCkge1xudmFyIFdlYlJUQztcblxuV2ViUlRDID0ge307XG5cbldlYlJUQy5NZWRpYUhhbmRsZXIgPSByZXF1aXJlKCcuL1dlYlJUQy9NZWRpYUhhbmRsZXInKShTSVApO1xuV2ViUlRDLk1lZGlhU3RyZWFtTWFuYWdlciA9IHJlcXVpcmUoJy4vV2ViUlRDL01lZGlhU3RyZWFtTWFuYWdlcicpKFNJUCwgZW52aXJvbm1lbnQpO1xuXG52YXIgX2lzU3VwcG9ydGVkO1xuXG5XZWJSVEMuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBfaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBXZWJSVEMuTWVkaWFTdHJlYW0gPSBlbnZpcm9ubWVudC5NZWRpYVN0cmVhbTtcbiAgV2ViUlRDLmdldFVzZXJNZWRpYSA9IGVudmlyb25tZW50LmdldFVzZXJNZWRpYTtcbiAgV2ViUlRDLlJUQ1BlZXJDb25uZWN0aW9uID0gZW52aXJvbm1lbnQuUlRDUGVlckNvbm5lY3Rpb247XG4gIFdlYlJUQy5SVENTZXNzaW9uRGVzY3JpcHRpb24gPSBlbnZpcm9ubWVudC5SVENTZXNzaW9uRGVzY3JpcHRpb247XG5cbiAgaWYgKFdlYlJUQy5SVENQZWVyQ29ubmVjdGlvbiAmJiBXZWJSVEMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKFdlYlJUQy5nZXRVc2VyTWVkaWEpIHtcbiAgICAgIFdlYlJUQy5nZXRVc2VyTWVkaWEgPSBTSVAuVXRpbHMucHJvbWlzaWZ5KGVudmlyb25tZW50LCAnZ2V0VXNlck1lZGlhJyk7XG4gICAgfVxuICAgIF9pc1N1cHBvcnRlZCA9IHRydWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgX2lzU3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIF9pc1N1cHBvcnRlZDtcbn07XG5cbnJldHVybiBXZWJSVEM7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9XZWJSVEMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1lZGlhSGFuZGxlclxuICovXG5cbi8qIE1lZGlhSGFuZGxlclxuICogQGNsYXNzIFBlZXJDb25uZWN0aW9uIGhlbHBlciBDbGFzcy5cbiAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7U0lQLldlYlJUQy5NZWRpYVN0cmVhbU1hbmFnZXJ9IFtvcHRpb25zLm1lZGlhU3RyZWFtTWFuYWdlcl1cbiAqICAgICAgICBUaGUgTWVkaWFTdHJlYW1NYW5hZ2VyIHRvIGFjcXVpcmUvcmVsZWFzZSBzdHJlYW1zIGZyb20vdG8uXG4gKiAgICAgICAgSWYgbm90IHByb3ZpZGVkLCBhIGRlZmF1bHQgTWVkaWFTdHJlYW1NYW5hZ2VyIHdpbGwgYmUgdXNlZC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG5cbnZhciBNZWRpYUhhbmRsZXIgPSBmdW5jdGlvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMubG9nZ2VyID0gc2Vzc2lvbi51YS5nZXRMb2dnZXIoJ3NpcC5pbnZpdGVjb250ZXh0Lm1lZGlhaGFuZGxlcicsIHNlc3Npb24uaWQpO1xuICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICB0aGlzLmxvY2FsTWVkaWEgPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgdGhpcy5tZWRpYVN0cmVhbU1hbmFnZXIgPSBvcHRpb25zLm1lZGlhU3RyZWFtTWFuYWdlciB8fCBuZXcgU0lQLldlYlJUQy5NZWRpYVN0cmVhbU1hbmFnZXIodGhpcy5sb2dnZXIpO1xuICB0aGlzLmF1ZGlvTXV0ZWQgPSBmYWxzZTtcbiAgdGhpcy52aWRlb011dGVkID0gZmFsc2U7XG5cbiAgLy8gb2xkIGluaXQoKSBmcm9tIGhlcmUgb25cbiAgdmFyIHNlcnZlcnMgPSB0aGlzLnByZXBhcmVJY2VTZXJ2ZXJzKG9wdGlvbnMuc3R1blNlcnZlcnMsIG9wdGlvbnMudHVyblNlcnZlcnMpO1xuICB0aGlzLlJUQ0NvbnN0cmFpbnRzID0gb3B0aW9ucy5SVENDb25zdHJhaW50cyB8fCB7fTtcblxuICB0aGlzLmluaXRQZWVyQ29ubmVjdGlvbihzZXJ2ZXJzLCB0aGlzLlJUQ0NvbnN0cmFpbnRzKTtcblxuICBmdW5jdGlvbiBzZWxmRW1pdChtaCwgZXZlbnQpIHtcbiAgICBpZiAobWgubWVkaWFTdHJlYW1NYW5hZ2VyLm9uKSB7XG4gICAgICBtaC5tZWRpYVN0cmVhbU1hbmFnZXIub24oZXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWguZW1pdC5hcHBseShtaCwgW2V2ZW50XS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc2VsZkVtaXQodGhpcywgJ3VzZXJNZWRpYVJlcXVlc3QnKTtcbiAgc2VsZkVtaXQodGhpcywgJ3VzZXJNZWRpYScpO1xuICBzZWxmRW1pdCh0aGlzLCAndXNlck1lZGlhRmFpbGVkJyk7XG59O1xuXG5NZWRpYUhhbmRsZXIuZGVmYXVsdEZhY3RvcnkgPSBmdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAoc2Vzc2lvbiwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IE1lZGlhSGFuZGxlcihzZXNzaW9uLCBvcHRpb25zKTtcbn07XG5NZWRpYUhhbmRsZXIuZGVmYXVsdEZhY3RvcnkuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBTSVAuV2ViUlRDLmlzU3VwcG9ydGVkKCk7XG59O1xuXG5NZWRpYUhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuTWVkaWFIYW5kbGVyLnByb3RvdHlwZSwge1xuLy8gRnVuY3Rpb25zIHRoZSBzZXNzaW9uIGNhbiB1c2VcbiAgaXNSZWFkeToge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gaXNSZWFkeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZHk7XG4gIH19LFxuXG4gIGNsb3NlOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdjbG9zaW5nIFBlZXJDb25uZWN0aW9uJyk7XG4gICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgIC8vIGhhdmUgdG8gY2hlY2sgc2lnbmFsaW5nU3RhdGUgc2luY2UgdGhpcy5jbG9zZSgpIGdldHMgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gVE9ETyBmaWd1cmUgb3V0IHdoeSB0aGF0IGhhcHBlbnNcbiAgICBpZih0aGlzLnBlZXJDb25uZWN0aW9uICYmIHRoaXMucGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG5cbiAgICAgIGlmKHRoaXMubG9jYWxNZWRpYSkge1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtTWFuYWdlci5yZWxlYXNlKHRoaXMubG9jYWxNZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICB9fSxcblxuICAvKipcbiAgICogQHBhcmFtIHtTSVAuV2ViUlRDLk1lZGlhU3RyZWFtIHwgKGdldFVzZXJNZWRpYSBjb25zdHJhaW50cyl9IFttZWRpYUhpbnRdXG4gICAqICAgICAgICB0aGUgTWVkaWFTdHJlYW0gKG9yIHRoZSBjb25zdHJhaW50cyBkZXNjcmliaW5nIGl0KSB0byBiZSB1c2VkIGZvciB0aGUgc2Vzc2lvblxuICAgKi9cbiAgZ2V0RGVzY3JpcHRpb246IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGdldERlc2NyaXB0aW9uIChtZWRpYUhpbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFjcXVpcmUgPSBzZWxmLm1lZGlhU3RyZWFtTWFuYWdlci5hY3F1aXJlO1xuICAgIGlmIChhY3F1aXJlLmxlbmd0aCA+IDEpIHtcbiAgICAgIGFjcXVpcmUgPSBTSVAuVXRpbHMucHJvbWlzaWZ5KHRoaXMubWVkaWFTdHJlYW1NYW5hZ2VyLCAnYWNxdWlyZScsIHRydWUpO1xuICAgIH1cbiAgICBtZWRpYUhpbnQgPSBtZWRpYUhpbnQgfHwge307XG4gICAgaWYgKG1lZGlhSGludC5kYXRhQ2hhbm5lbCA9PT0gdHJ1ZSkge1xuICAgICAgbWVkaWFIaW50LmRhdGFDaGFubmVsID0ge307XG4gICAgfVxuICAgIHRoaXMubWVkaWFIaW50ID0gbWVkaWFIaW50O1xuXG4gICAgLypcbiAgICAgKiAxLiBhY3F1aXJlIHN0cmVhbXMgKHNraXAgaWYgTWVkaWFTdHJlYW1zIHBhc3NlZCBpbilcbiAgICAgKiAyLiBhZGRTdHJlYW1zXG4gICAgICogMy4gY3JlYXRlT2ZmZXIvY3JlYXRlQW5zd2VyXG4gICAgICovXG5cbiAgICB2YXIgc3RyZWFtUHJvbWlzZTtcbiAgICBpZiAoc2VsZi5sb2NhbE1lZGlhKSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ2FscmVhZHkgaGF2ZSBsb2NhbCBtZWRpYScpO1xuICAgICAgc3RyZWFtUHJvbWlzZSA9IFNJUC5VdGlscy5Qcm9taXNlLnJlc29sdmUoc2VsZi5sb2NhbE1lZGlhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ2FjcXVpcmluZyBsb2NhbCBtZWRpYScpO1xuICAgICAgc3RyZWFtUHJvbWlzZSA9IGFjcXVpcmUuY2FsbChzZWxmLm1lZGlhU3RyZWFtTWFuYWdlciwgbWVkaWFIaW50KVxuICAgICAgICAudGhlbihmdW5jdGlvbiBhY3F1aXJlU3VjY2VlZGVkKHN0cmVhbXMpIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5sb2coJ2FjcXVpcmVkIGxvY2FsIG1lZGlhIHN0cmVhbXMnKTtcbiAgICAgICAgICBzZWxmLmxvY2FsTWVkaWEgPSBzdHJlYW1zO1xuICAgICAgICAgIHNlbGYuc2Vzc2lvbi5jb25uZWN0aW5nKCk7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbXM7XG4gICAgICAgIH0sIGZ1bmN0aW9uIGFjcXVpcmVGYWlsZWQoZXJyKSB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoJ3VuYWJsZSB0byBhY3F1aXJlIHN0cmVhbXMnKTtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgIHNlbGYuc2Vzc2lvbi5jb25uZWN0aW5nKCk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbih0aGlzLmFkZFN0cmVhbXMuYmluZCh0aGlzKSlcbiAgICAgIDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyZWFtUHJvbWlzZVxuICAgICAgLnRoZW4oZnVuY3Rpb24gc3RyZWFtQWRkaXRpb25TdWNjZWVkZWQoKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc09mZmVyKCdyZW1vdGUnKSkge1xuICAgICAgICAgIHNlbGYucGVlckNvbm5lY3Rpb24ub25kYXRhY2hhbm5lbCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIHNlbGYuZGF0YUNoYW5uZWwgPSBldnQuY2hhbm5lbDtcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZGF0YUNoYW5uZWwnLCBzZWxmLmRhdGFDaGFubmVsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhSGludC5kYXRhQ2hhbm5lbCAmJlxuICAgICAgICAgICAgICAgICAgIHNlbGYucGVlckNvbm5lY3Rpb24uY3JlYXRlRGF0YUNoYW5uZWwpIHtcbiAgICAgICAgICBzZWxmLmRhdGFDaGFubmVsID0gc2VsZi5wZWVyQ29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbChcbiAgICAgICAgICAgICdzaXBqcycsXG4gICAgICAgICAgICBtZWRpYUhpbnQuZGF0YUNoYW5uZWxcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlbGYuZW1pdCgnZGF0YUNoYW5uZWwnLCBzZWxmLmRhdGFDaGFubmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICAgIHJldHVybiBzZWxmLmNyZWF0ZU9mZmVyT3JBbnN3ZXIoc2VsZi5SVENDb25zdHJhaW50cyk7XG4gICAgICB9KVxuICAgIDtcbiAgfX0sXG5cbiAgLyoqXG4gICogTWVzc2FnZSByZWNlcHRpb24uXG4gICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gc2RwXG4gICovXG4gIHNldERlc2NyaXB0aW9uOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBzZXREZXNjcmlwdGlvbiAoc2RwKSB7XG4gICAgdmFyIHJhd0Rlc2NyaXB0aW9uID0ge1xuICAgICAgdHlwZTogdGhpcy5oYXNPZmZlcignbG9jYWwnKSA/ICdhbnN3ZXInIDogJ29mZmVyJyxcbiAgICAgIHNkcDogc2RwXG4gICAgfTtcblxuICAgIHRoaXMuZW1pdCgnc2V0RGVzY3JpcHRpb24nLCByYXdEZXNjcmlwdGlvbik7XG5cbiAgICB2YXIgZGVzY3JpcHRpb24gPSBuZXcgU0lQLldlYlJUQy5SVENTZXNzaW9uRGVzY3JpcHRpb24ocmF3RGVzY3JpcHRpb24pO1xuICAgIHJldHVybiBTSVAuVXRpbHMucHJvbWlzaWZ5KHRoaXMucGVlckNvbm5lY3Rpb24sICdzZXRSZW1vdGVEZXNjcmlwdGlvbicpKGRlc2NyaXB0aW9uKTtcbiAgfX0sXG5cbiAgLyoqXG4gICAqIElmIHRoZSBTZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1lZGlhSGFuZGxlciB3ZXJlIHRvIGJlIHJlZmVycmVkLFxuICAgKiB3aGF0IG1lZGlhSGludCBzaG91bGQgYmUgcHJvdmlkZWQgdG8gdGhlIFVBJ3MgaW52aXRlIG1ldGhvZD9cbiAgICovXG4gIGdldFJlZmVyTWVkaWE6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGdldFJlZmVyTWVkaWEgKCkge1xuICAgIGZ1bmN0aW9uIGhhc1RyYWNrcyAodHJhY2tHZXR0ZXIsIHN0cmVhbSkge1xuICAgICAgcmV0dXJuIHN0cmVhbVt0cmFja0dldHRlcl0oKS5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJvdGhIYXZlVHJhY2tzICh0cmFja0dldHRlcikge1xuICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICByZXR1cm4gdGhpcy5nZXRMb2NhbFN0cmVhbXMoKS5zb21lKGhhc1RyYWNrcy5iaW5kKG51bGwsIHRyYWNrR2V0dGVyKSkgJiZcbiAgICAgICAgICAgICB0aGlzLmdldFJlbW90ZVN0cmVhbXMoKS5zb21lKGhhc1RyYWNrcy5iaW5kKG51bGwsIHRyYWNrR2V0dGVyKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgIGF1ZGlvOiBib3RoSGF2ZVRyYWNrcy5jYWxsKHRoaXMsICdnZXRBdWRpb1RyYWNrcycpLFxuICAgICAgICB2aWRlbzogYm90aEhhdmVUcmFja3MuY2FsbCh0aGlzLCAnZ2V0VmlkZW9UcmFja3MnKVxuICAgICAgfVxuICAgIH07XG4gIH19LFxuXG4gIHVwZGF0ZUljZVNlcnZlcnM6IHt3cml0ZWFibGU6dHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlcnZlcnMgPSB0aGlzLnByZXBhcmVJY2VTZXJ2ZXJzKG9wdGlvbnMuc3R1blNlcnZlcnMsIG9wdGlvbnMudHVyblNlcnZlcnMpO1xuICAgIHRoaXMuUlRDQ29uc3RyYWludHMgPSBvcHRpb25zLlJUQ0NvbnN0cmFpbnRzIHx8IHRoaXMuUlRDQ29uc3RyYWludHM7XG5cbiAgICB0aGlzLmluaXRQZWVyQ29ubmVjdGlvbihzZXJ2ZXJzLCB0aGlzLlJUQ0NvbnN0cmFpbnRzKTtcblxuICAgIC8qIG9uY2UgdXBkYXRlSWNlIGlzIGltcGxlbWVudGVkIGNvcnJlY3RseSwgdGhpcyBpcyBiZXR0ZXIgdGhhbiBhYm92ZVxuICAgIC8vbm8gb3AgaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoaXNcbiAgICBpZiAoIXRoaXMucGVlckNvbm5lY3Rpb24udXBkYXRlSWNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi51cGRhdGVJY2UoeydpY2VTZXJ2ZXJzJzogc2VydmVyc30sIHRoaXMuUlRDQ29uc3RyYWludHMpO1xuICAgICovXG4gIH19LFxuXG4vLyBGdW5jdGlvbnMgdGhlIHNlc3Npb24gY2FuIHVzZSwgYnV0IG9ubHkgYmVjYXVzZSBpdCdzIGNvbnZlbmllbnQgZm9yIHRoZSBhcHBsaWNhdGlvblxuICBpc011dGVkOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBpc011dGVkICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW86IHRoaXMuYXVkaW9NdXRlZCxcbiAgICAgIHZpZGVvOiB0aGlzLnZpZGVvTXV0ZWRcbiAgICB9O1xuICB9fSxcblxuICBtdXRlOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBtdXRlIChvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuZ2V0TG9jYWxTdHJlYW1zKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgYXVkaW86IHRoaXMuZ2V0TG9jYWxTdHJlYW1zKClbMF0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwLFxuICAgICAgdmlkZW86IHRoaXMuZ2V0TG9jYWxTdHJlYW1zKClbMF0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwXG4gICAgfTtcblxuICAgIHZhciBhdWRpb011dGVkID0gZmFsc2UsXG4gICAgICAgIHZpZGVvTXV0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmF1ZGlvICYmICF0aGlzLmF1ZGlvTXV0ZWQpIHtcbiAgICAgIGF1ZGlvTXV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5hdWRpb011dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZUF1ZGlvKHRydWUpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnZpZGVvICYmICF0aGlzLnZpZGVvTXV0ZWQpIHtcbiAgICAgIHZpZGVvTXV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy52aWRlb011dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZVZpZGVvKHRydWUpO1xuICAgIH1cblxuICAgIC8vUkVWSVNJVFxuICAgIGlmIChhdWRpb011dGVkIHx8IHZpZGVvTXV0ZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1ZGlvOiBhdWRpb011dGVkLFxuICAgICAgICB2aWRlbzogdmlkZW9NdXRlZFxuICAgICAgfTtcbiAgICAgIC8qdGhpcy5zZXNzaW9uLm9ubXV0ZSh7XG4gICAgICAgIGF1ZGlvOiBhdWRpb011dGVkLFxuICAgICAgICB2aWRlbzogdmlkZW9NdXRlZFxuICAgICAgfSk7Ki9cbiAgICB9XG4gIH19LFxuXG4gIHVubXV0ZToge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gdW5tdXRlIChvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuZ2V0TG9jYWxTdHJlYW1zKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgYXVkaW86IHRoaXMuZ2V0TG9jYWxTdHJlYW1zKClbMF0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwLFxuICAgICAgdmlkZW86IHRoaXMuZ2V0TG9jYWxTdHJlYW1zKClbMF0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwXG4gICAgfTtcblxuICAgIHZhciBhdWRpb1VuTXV0ZWQgPSBmYWxzZSxcbiAgICAgICAgdmlkZW9Vbk11dGVkID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hdWRpbyAmJiB0aGlzLmF1ZGlvTXV0ZWQpIHtcbiAgICAgIGF1ZGlvVW5NdXRlZCA9IHRydWU7XG4gICAgICB0aGlzLmF1ZGlvTXV0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZUF1ZGlvKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy52aWRlbyAmJiB0aGlzLnZpZGVvTXV0ZWQpIHtcbiAgICAgIHZpZGVvVW5NdXRlZCA9IHRydWU7XG4gICAgICB0aGlzLnZpZGVvTXV0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZVZpZGVvKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvL1JFVklTSVRcbiAgICBpZiAoYXVkaW9Vbk11dGVkIHx8IHZpZGVvVW5NdXRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW86IGF1ZGlvVW5NdXRlZCxcbiAgICAgICAgdmlkZW86IHZpZGVvVW5NdXRlZFxuICAgICAgfTtcbiAgICAgIC8qdGhpcy5zZXNzaW9uLm9udW5tdXRlKHtcbiAgICAgICAgYXVkaW86IGF1ZGlvVW5NdXRlZCxcbiAgICAgICAgdmlkZW86IHZpZGVvVW5NdXRlZFxuICAgICAgfSk7Ki9cbiAgICB9XG4gIH19LFxuXG4gIGhvbGQ6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGhvbGQgKCkge1xuICAgIHRoaXMudG9nZ2xlTXV0ZUF1ZGlvKHRydWUpO1xuICAgIHRoaXMudG9nZ2xlTXV0ZVZpZGVvKHRydWUpO1xuICB9fSxcblxuICB1bmhvbGQ6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHVuaG9sZCAoKSB7XG4gICAgaWYgKCF0aGlzLmF1ZGlvTXV0ZWQpIHtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZUF1ZGlvKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudmlkZW9NdXRlZCkge1xuICAgICAgdGhpcy50b2dnbGVNdXRlVmlkZW8oZmFsc2UpO1xuICAgIH1cbiAgfX0sXG5cbi8vIEZ1bmN0aW9ucyB0aGUgYXBwbGljYXRpb24gY2FuIHVzZSwgYnV0IG5vdCB0aGUgc2Vzc2lvblxuICBnZXRMb2NhbFN0cmVhbXM6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcyAoKSB7XG4gICAgdmFyIHBjID0gdGhpcy5wZWVyQ29ubmVjdGlvbjtcbiAgICBpZiAocGMgJiYgcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdwZWVyQ29ubmVjdGlvbiBpcyBjbG9zZWQsIGdldExvY2FsU3RyZWFtcyByZXR1cm5pbmcgW10nKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIChwYy5nZXRMb2NhbFN0cmVhbXMgJiYgcGMuZ2V0TG9jYWxTdHJlYW1zKCkpIHx8XG4gICAgICBwYy5sb2NhbFN0cmVhbXMgfHwgW107XG4gIH19LFxuXG4gIGdldFJlbW90ZVN0cmVhbXM6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGdldFJlbW90ZVN0cmVhbXMgKCkge1xuICAgIHZhciBwYyA9IHRoaXMucGVlckNvbm5lY3Rpb247XG4gICAgaWYgKHBjICYmIHBjLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhpcy5sb2dnZXIud2FybigncGVlckNvbm5lY3Rpb24gaXMgY2xvc2VkLCBnZXRSZW1vdGVTdHJlYW1zIHJldHVybmluZyB0aGlzLl9yZW1vdGVTdHJlYW1zJyk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3RlU3RyZWFtcztcbiAgICB9XG4gICAgcmV0dXJuKHBjLmdldFJlbW90ZVN0cmVhbXMgJiYgcGMuZ2V0UmVtb3RlU3RyZWFtcygpKSB8fFxuICAgICAgcGMucmVtb3RlU3RyZWFtcyB8fCBbXTtcbiAgfX0sXG5cbiAgcmVuZGVyOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIgKHJlbmRlckhpbnQpIHtcbiAgICByZW5kZXJIaW50ID0gcmVuZGVySGludCB8fCAodGhpcy5tZWRpYUhpbnQgJiYgdGhpcy5tZWRpYUhpbnQucmVuZGVyKTtcbiAgICBpZiAoIXJlbmRlckhpbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHN0cmVhbUdldHRlcnMgPSB7XG4gICAgICBsb2NhbDogJ2dldExvY2FsU3RyZWFtcycsXG4gICAgICByZW1vdGU6ICdnZXRSZW1vdGVTdHJlYW1zJ1xuICAgIH07XG4gICAgT2JqZWN0LmtleXMoc3RyZWFtR2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAobG9jKSB7XG4gICAgICB2YXIgc3RyZWFtR2V0dGVyID0gc3RyZWFtR2V0dGVyc1tsb2NdO1xuICAgICAgdmFyIHN0cmVhbXMgPSB0aGlzW3N0cmVhbUdldHRlcl0oKTtcbiAgICAgIFNJUC5XZWJSVEMuTWVkaWFTdHJlYW1NYW5hZ2VyLnJlbmRlcihzdHJlYW1zLCByZW5kZXJIaW50W2xvY10pO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH19LFxuXG4vLyBJbnRlcm5hbCBmdW5jdGlvbnNcbiAgaGFzT2ZmZXI6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGhhc09mZmVyICh3aGVyZSkge1xuICAgIHZhciBvZmZlclN0YXRlID0gJ2hhdmUtJyArIHdoZXJlICsgJy1vZmZlcic7XG4gICAgcmV0dXJuIHRoaXMucGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgPT09IG9mZmVyU3RhdGU7XG4gICAgLy8gVE9ETyBjb25zaWRlciBzaWduYWxpbmdTdGF0ZXMgd2l0aCAncHJhbnN3ZXInP1xuICB9fSxcblxuICBwcmVwYXJlSWNlU2VydmVyczoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZUljZVNlcnZlcnMgKHN0dW5TZXJ2ZXJzLCB0dXJuU2VydmVycykge1xuICAgIHZhciBzZXJ2ZXJzID0gW10sXG4gICAgICBjb25maWcgPSB0aGlzLnNlc3Npb24udWEuY29uZmlndXJhdGlvbjtcblxuICAgIHN0dW5TZXJ2ZXJzID0gc3R1blNlcnZlcnMgfHwgY29uZmlnLnN0dW5TZXJ2ZXJzO1xuICAgIHR1cm5TZXJ2ZXJzID0gdHVyblNlcnZlcnMgfHwgY29uZmlnLnR1cm5TZXJ2ZXJzO1xuXG4gICAgW10uY29uY2F0KHN0dW5TZXJ2ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICAgIHNlcnZlcnMucHVzaCh7J3VybHMnOiBzZXJ2ZXJ9KTtcbiAgICB9KTtcblxuICAgIFtdLmNvbmNhdCh0dXJuU2VydmVycykuZm9yRWFjaChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICBzZXJ2ZXJzLnB1c2goe1xuICAgICAgICAndXJscyc6IHNlcnZlci51cmxzLFxuICAgICAgICAndXNlcm5hbWUnOiBzZXJ2ZXIudXNlcm5hbWUsXG4gICAgICAgICdjcmVkZW50aWFsJzogc2VydmVyLnBhc3N3b3JkXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzZXJ2ZXJzO1xuICB9fSxcblxuICBpbml0UGVlckNvbm5lY3Rpb246IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGluaXRQZWVyQ29ubmVjdGlvbihzZXJ2ZXJzLCBSVENDb25zdHJhaW50cykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGNvbmZpZyA9IHRoaXMuc2Vzc2lvbi51YS5jb25maWd1cmF0aW9uO1xuXG4gICAgdGhpcy5vbkljZUNvbXBsZXRlZCA9IFNJUC5VdGlscy5kZWZlcigpO1xuICAgIHRoaXMub25JY2VDb21wbGV0ZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uKHBjKSB7XG4gICAgICBzZWxmLmVtaXQoJ2ljZUdhdGhlcmluZ0NvbXBsZXRlJywgcGMpO1xuICAgICAgaWYgKHNlbGYuaWNlQ2hlY2tpbmdUaW1lcikge1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dChzZWxmLmljZUNoZWNraW5nVGltZXIpO1xuICAgICAgICBzZWxmLmljZUNoZWNraW5nVGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMucGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uID0gbmV3IFNJUC5XZWJSVEMuUlRDUGVlckNvbm5lY3Rpb24oeydpY2VTZXJ2ZXJzJzogc2VydmVyc30sIFJUQ0NvbnN0cmFpbnRzKTtcblxuICAgIC8vIEZpcmVmb3ggKDM1LjAuMSkgc29tZXRpbWVzIHRocm93cyBvbiBjYWxscyB0byBwZWVyQ29ubmVjdGlvbi5nZXRSZW1vdGVTdHJlYW1zXG4gICAgLy8gZXZlbiBpZiBwZWVyQ29ubmVjdGlvbi5vbmFkZHN0cmVhbSB3YXMganVzdCBjYWxsZWQuIEluIG9yZGVyIHRvIG1ha2VcbiAgICAvLyBNZWRpYUhhbmRsZXIucHJvdG90eXBlLmdldFJlbW90ZVN0cmVhbXMgd29yaywga2VlcCB0cmFjayBvZiB0aGVtIG1hbnVhbGx5XG4gICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmFkZHN0cmVhbSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHNlbGYubG9nZ2VyLmxvZygnc3RyZWFtIGFkZGVkOiAnKyBlLnN0cmVhbS5pZCk7XG4gICAgICBzZWxmLl9yZW1vdGVTdHJlYW1zLnB1c2goZS5zdHJlYW0pO1xuICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICAgIHNlbGYuZW1pdCgnYWRkU3RyZWFtJywgZSk7XG4gICAgfTtcblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25yZW1vdmVzdHJlYW0gPSBmdW5jdGlvbihlKSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ3N0cmVhbSByZW1vdmVkOiAnKyBlLnN0cmVhbS5pZCk7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnRJY2VDaGVja2luZ1RpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzZWxmLmljZUNoZWNraW5nVGltZXIpIHtcbiAgICAgICAgc2VsZi5pY2VDaGVja2luZ1RpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmxvZygnUlRDSWNlQ2hlY2tpbmcgVGltZW91dCBUcmlnZ2VyZWQgYWZ0ZXIgJytjb25maWcuaWNlQ2hlY2tpbmdUaW1lb3V0KycgbWlsbGlzZWNvbmRzJyk7XG4gICAgICAgICAgc2VsZi5vbkljZUNvbXBsZXRlZC5yZXNvbHZlKHRoaXMpO1xuICAgICAgICB9LmJpbmQodGhpcy5wZWVyQ29ubmVjdGlvbiksIGNvbmZpZy5pY2VDaGVja2luZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5lbWl0KCdpY2VDYW5kaWRhdGUnLCBlKTtcbiAgICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgICBzZWxmLmxvZ2dlci5sb2coJ0lDRSBjYW5kaWRhdGUgcmVjZWl2ZWQ6ICcrIChlLmNhbmRpZGF0ZS5jYW5kaWRhdGUgPT09IG51bGwgPyBudWxsIDogZS5jYW5kaWRhdGUuY2FuZGlkYXRlLnRyaW0oKSkpO1xuICAgICAgICBzZWxmLnN0YXJ0SWNlQ2hlY2tpbmdUaW1lcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5vbkljZUNvbXBsZXRlZC5yZXNvbHZlKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ1JUQ0ljZUdhdGhlcmluZ1N0YXRlIGNoYW5nZWQ6ICcgKyB0aGlzLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgIGlmICh0aGlzLmljZUdhdGhlcmluZ1N0YXRlID09PSAnZ2F0aGVyaW5nJykge1xuICAgICAgICBzZWxmLmVtaXQoJ2ljZUdhdGhlcmluZycsIHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaWNlR2F0aGVyaW5nU3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgc2VsZi5vbkljZUNvbXBsZXRlZC5yZXNvbHZlKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7ICAvL25lZWQgZSBmb3IgY29tbWVudGVkIG91dCBjYXNlXG4gICAgICB2YXIgc3RhdGVFdmVudDtcblxuICAgICAgaWYgKHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY2hlY2tpbmcnKSB7XG4gICAgICAgIHNlbGYuc3RhcnRJY2VDaGVja2luZ1RpbWVyKCk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodGhpcy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgIGNhc2UgJ25ldyc6XG4gICAgICAgIHN0YXRlRXZlbnQgPSAnaWNlQ29ubmVjdGlvbic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2hlY2tpbmcnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb25DaGVja2luZyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uQ29ubmVjdGVkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb25Db21wbGV0ZWQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgIHN0YXRlRXZlbnQgPSAnaWNlQ29ubmVjdGlvbkZhaWxlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb25DbG9zZWQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oJ1Vua25vd24gaWNlQ29ubmVjdGlvbiBzdGF0ZTonLCB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW1pdChzdGF0ZUV2ZW50LCB0aGlzKTtcblxuICAgICAgLy9CcmlhIHN0YXRlIGNoYW5nZXMgYXJlIGFsd2F5cyBjb25uZWN0ZWQgLT4gZGlzY29ubmVjdGVkIC0+IGNvbm5lY3RlZCBvbiBhY2NlcHQsIHNvIHNlc3Npb24gZ2V0cyB0ZXJtaW5hdGVkXG4gICAgICAvL25vcm1hbCBjYWxscyBzd2l0Y2ggZnJvbSBmYWlsZWQgdG8gY29ubmVjdGVkIGluIHNvbWUgY2FzZXMsIHNvIGNoZWNraW5nIGZvciBmYWlsZWQgYW5kIHRlcm1pbmF0ZWRcbiAgICAgIC8qaWYgKHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICBzZWxmLnNlc3Npb24udGVybWluYXRlKHtcbiAgICAgICAgY2F1c2U6IFNJUC5DLmNhdXNlcy5SVFBfVElNRU9VVCxcbiAgICAgICAgc3RhdHVzX2NvZGU6IDIwMCxcbiAgICAgICAgcmVhc29uX3BocmFzZTogU0lQLkMuY2F1c2VzLlJUUF9USU1FT1VUXG4gICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZS5jdXJyZW50VGFyZ2V0LmljZUdhdGhlcmluZ1N0YXRlID09PSAnY29tcGxldGUnICYmIHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgc2VsZi5vbkljZUNvbXBsZXRlZCh0aGlzKTtcbiAgICAgIH0qL1xuICAgIH07XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYubG9nZ2VyLmxvZygnUGVlckNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZCB0byBcIicrIHRoaXMucmVhZHlTdGF0ZSArJ1wiJyk7XG4gICAgfTtcbiAgfX0sXG5cbiAgY3JlYXRlT2ZmZXJPckFuc3dlcjoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlT2ZmZXJPckFuc3dlciAoY29uc3RyYWludHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1ldGhvZE5hbWU7XG4gICAgdmFyIHBjID0gc2VsZi5wZWVyQ29ubmVjdGlvbjtcblxuICAgIHNlbGYucmVhZHkgPSBmYWxzZTtcbiAgICBtZXRob2ROYW1lID0gc2VsZi5oYXNPZmZlcigncmVtb3RlJykgPyAnY3JlYXRlQW5zd2VyJyA6ICdjcmVhdGVPZmZlcic7XG5cbiAgICByZXR1cm4gU0lQLlV0aWxzLnByb21pc2lmeShwYywgbWV0aG9kTmFtZSwgdHJ1ZSkoY29uc3RyYWludHMpXG4gICAgICAudGhlbihTSVAuVXRpbHMucHJvbWlzaWZ5KHBjLCAnc2V0TG9jYWxEZXNjcmlwdGlvbicpKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gb25TZXRMb2NhbERlc2NyaXB0aW9uU3VjY2VzcygpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gU0lQLlV0aWxzLmRlZmVyKCk7XG4gICAgICAgIGlmIChwYy5pY2VHYXRoZXJpbmdTdGF0ZSA9PT0gJ2NvbXBsZXRlJyAmJiAocGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJyB8fCBwYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb21wbGV0ZWQnKSkge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLm9uSWNlQ29tcGxldGVkLnByb21pc2UudGhlbihkZWZlcnJlZC5yZXNvbHZlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbiByZWFkeVN1Y2Nlc3MgKCkge1xuICAgICAgICB2YXIgc2RwID0gcGMubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG5cbiAgICAgICAgc2RwID0gU0lQLkhhY2tzLkNocm9tZS5uZWVkc0V4cGxpY2l0bHlJbmFjdGl2ZVNEUChzZHApO1xuICAgICAgICBzZHAgPSBTSVAuSGFja3MuQWxsQnJvd3NlcnMudW5tYXNrRHRscyhzZHApO1xuXG4gICAgICAgIHZhciBzZHBXcmFwcGVyID0ge1xuICAgICAgICAgIHR5cGU6IG1ldGhvZE5hbWUgPT09ICdjcmVhdGVPZmZlcicgPyAnb2ZmZXInIDogJ2Fuc3dlcicsXG4gICAgICAgICAgc2RwOiBzZHBcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLmVtaXQoJ2dldERlc2NyaXB0aW9uJywgc2RwV3JhcHBlcik7XG5cbiAgICAgICAgc2VsZi5yZWFkeSA9IHRydWU7XG4gICAgICAgIHJldHVybiBzZHBXcmFwcGVyLnNkcDtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gbWV0aG9kRmFpbGVkIChlKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICBzZWxmLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkdldERlc2NyaXB0aW9uRXJyb3IoZSk7XG4gICAgICB9KVxuICAgIDtcbiAgfX0sXG5cbiAgYWRkU3RyZWFtczoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gYWRkU3RyZWFtcyAoc3RyZWFtcykge1xuICAgIHRyeSB7XG4gICAgICBzdHJlYW1zID0gW10uY29uY2F0KHN0cmVhbXMpO1xuICAgICAgc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5hZGRTdHJlYW0oc3RyZWFtKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ2Vycm9yIGFkZGluZyBzdHJlYW0nKTtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgcmV0dXJuIFNJUC5VdGlscy5Qcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU0lQLlV0aWxzLlByb21pc2UucmVzb2x2ZSgpO1xuICB9fSxcblxuICB0b2dnbGVNdXRlSGVscGVyOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNdXRlSGVscGVyICh0cmFja0dldHRlciwgbXV0ZSkge1xuICAgIHRoaXMuZ2V0TG9jYWxTdHJlYW1zKCkuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICBzdHJlYW1bdHJhY2tHZXR0ZXJdKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdHJhY2suZW5hYmxlZCA9ICFtdXRlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH19LFxuXG4gIHRvZ2dsZU11dGVBdWRpbzoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlTXV0ZUF1ZGlvIChtdXRlKSB7XG4gICAgdGhpcy50b2dnbGVNdXRlSGVscGVyKCdnZXRBdWRpb1RyYWNrcycsIG11dGUpO1xuICB9fSxcblxuICB0b2dnbGVNdXRlVmlkZW86IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZU11dGVWaWRlbyAobXV0ZSkge1xuICAgIHRoaXMudG9nZ2xlTXV0ZUhlbHBlcignZ2V0VmlkZW9UcmFja3MnLCBtdXRlKTtcbiAgfX1cbn0pO1xuXG4vLyBSZXR1cm4gc2luY2UgaXQgd2lsbCBiZSBhc3NpZ25lZCB0byBhIHZhcmlhYmxlLlxucmV0dXJuIE1lZGlhSGFuZGxlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYUhhbmRsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1lZGlhU3RyZWFtTWFuYWdlclxuICovXG5cbi8qIE1lZGlhU3RyZWFtTWFuYWdlclxuICogQGNsYXNzIE1hbmFnZXMgdGhlIGFjcXVpc2l0aW9uIGFuZCByZWxlYXNlIG9mIE1lZGlhU3RyZWFtcy5cbiAqIEBwYXJhbSB7bWVkaWFIaW50fSBbZGVmYXVsdE1lZGlhSGludF0gVGhlIG1lZGlhSGludCB0byB1c2UgaWYgbm9uZSBpcyBwcm92aWRlZCB0byBhY3F1aXJlKClcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQLCBlbnZpcm9ubWVudCkge1xuXG4vLyBEZWZhdWx0IE1lZGlhU3RyZWFtTWFuYWdlciBwcm92aWRlcyBzaW5nbGUtdXNlIHN0cmVhbXMgY3JlYXRlZCB3aXRoIGdldFVzZXJNZWRpYVxudmFyIE1lZGlhU3RyZWFtTWFuYWdlciA9IGZ1bmN0aW9uIE1lZGlhU3RyZWFtTWFuYWdlciAobG9nZ2VyLCBkZWZhdWx0TWVkaWFIaW50KSB7XG4gIGlmICghU0lQLldlYlJUQy5pc1N1cHBvcnRlZCgpKSB7XG4gICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLk5vdFN1cHBvcnRlZEVycm9yKCdNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICB0aGlzLm1lZGlhSGludCA9IGRlZmF1bHRNZWRpYUhpbnQgfHwge1xuICAgIGNvbnN0cmFpbnRzOiB7YXVkaW86IHRydWUsIHZpZGVvOiB0cnVlfVxuICB9O1xuXG4gIC8vIG1hcCBvZiBzdHJlYW1zIHRvIGFjcXVpc2l0aW9uIG1hbm5lcjpcbiAgLy8gdHJ1ZSAtPiBwYXNzZWQgaW4gYXMgbWVkaWFIaW50LnN0cmVhbVxuICAvLyBmYWxzZSAtPiBnZXRVc2VyTWVkaWFcbiAgdGhpcy5hY3F1aXNpdGlvbnMgPSB7fTtcbn07XG5NZWRpYVN0cmVhbU1hbmFnZXIuc3RyZWFtSWQgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5jb25jYXQoc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkpXG4gICAgLm1hcChmdW5jdGlvbiB0cmFja0lkICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrLmlkO1xuICAgIH0pXG4gICAgLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyhBcnJheSBvZikgTWVkaWFTdHJlYW19IHN0cmVhbXMgLSBUaGUgc3RyZWFtcyB0byByZW5kZXJcbiAqXG4gKiBAcGFyYW0geyhBcnJheSBvZikgSFRNTE1lZGlhRWxlbWVudH0gZWxlbWVudHNcbiAqICAgICAgICAtIFRoZSA8YXVkaW8+Lzx2aWRlbz4gZWxlbWVudChzKSB0aGF0IHNob3VsZCByZW5kZXIgdGhlIHN0cmVhbXNcbiAqXG4gKiBFYWNoIHN0cmVhbSBpbiBzdHJlYW1zIHJlbmRlcnMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBlbGVtZW50cyxcbiAqIHdyYXBwaW5nIGFyb3VuZCBlbGVtZW50cyBpZiBuZWVkZWQuXG4gKi9cbk1lZGlhU3RyZWFtTWFuYWdlci5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHN0cmVhbXMsIGVsZW1lbnRzKSB7XG4gIGlmICghZWxlbWVudHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudHMpICYmICFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbGVtZW50cyBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0YWNoTWVkaWFTdHJlYW0oZWxlbWVudCwgc3RyZWFtKSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LnNyYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVudmlyb25tZW50LnJldm9rZU9iamVjdFVSTChlbGVtZW50LnNyYyk7XG4gICAgICBlbGVtZW50LnNyYyA9IGVudmlyb25tZW50LmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIChlbGVtZW50LnNyY09iamVjdCB8fCBlbGVtZW50Lm1velNyY09iamVjdCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbGVtZW50LnNyY09iamVjdCA9IGVsZW1lbnQubW96U3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVNZWRpYVBsYXlpbmcgKG1lZGlhRWxlbWVudCkge1xuICAgIHZhciBpbnRlcnZhbCA9IDEwMDtcbiAgICBtZWRpYUVsZW1lbnQuZW5zdXJlUGxheWluZ0ludGVydmFsSWQgPSBTSVAuVGltZXJzLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtZWRpYUVsZW1lbnQucGF1c2VkKSB7XG4gICAgICAgIG1lZGlhRWxlbWVudC5wbGF5KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhckludGVydmFsKG1lZGlhRWxlbWVudC5lbnN1cmVQbGF5aW5nSW50ZXJ2YWxJZCk7XG4gICAgICB9XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0YWNoQW5kUGxheSAoZWxlbWVudHMsIHN0cmVhbSwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlbGVtZW50cyA9IGVsZW1lbnRzKCk7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXggJSBlbGVtZW50cy5sZW5ndGhdO1xuICAgIChlbnZpcm9ubWVudC5hdHRhY2hNZWRpYVN0cmVhbSB8fCBhdHRhY2hNZWRpYVN0cmVhbSkoZWxlbWVudCwgc3RyZWFtKTtcbiAgICBlbnN1cmVNZWRpYVBsYXlpbmcoZWxlbWVudCk7XG4gIH1cblxuICAvLyBbXS5jb25jYXQgXCJjYXN0c1wiIGBlbGVtZW50c2AgaW50byBhbiBhcnJheVxuICAvLyBzbyBmb3JFYWNoIHdvcmtzIGV2ZW4gaWYgYGVsZW1lbnRzYCB3YXMgYSBzaW5nbGUgZWxlbWVudFxuICBlbGVtZW50cyA9IFtdLmNvbmNhdChlbGVtZW50cyk7XG4gIFtdLmNvbmNhdChzdHJlYW1zKS5mb3JFYWNoKGF0dGFjaEFuZFBsYXkuYmluZChudWxsLCBlbGVtZW50cykpO1xufTtcblxuTWVkaWFTdHJlYW1NYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUsIHtcbiAgJ2FjcXVpcmUnOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBhY3F1aXJlIChtZWRpYUhpbnQpIHtcbiAgICBtZWRpYUhpbnQgPSBPYmplY3Qua2V5cyhtZWRpYUhpbnQgfHwge30pLmxlbmd0aCA/IG1lZGlhSGludCA6IHRoaXMubWVkaWFIaW50O1xuXG4gICAgdmFyIHNhdmVTdWNjZXNzID0gZnVuY3Rpb24gKGlzSGludFN0cmVhbSwgc3RyZWFtcykge1xuICAgICAgc3RyZWFtcyA9IFtdLmNvbmNhdChzdHJlYW1zKTtcbiAgICAgIHN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHZhciBzdHJlYW1JZCA9IE1lZGlhU3RyZWFtTWFuYWdlci5zdHJlYW1JZChzdHJlYW0pO1xuICAgICAgICB0aGlzLmFjcXVpc2l0aW9uc1tzdHJlYW1JZF0gPSAhIWlzSGludFN0cmVhbTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIFNJUC5VdGlscy5Qcm9taXNlLnJlc29sdmUoc3RyZWFtcyk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKG1lZGlhSGludC5zdHJlYW0pIHtcbiAgICAgIHJldHVybiBzYXZlU3VjY2Vzcyh0cnVlLCBtZWRpYUhpbnQuc3RyZWFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gYXVkaW8vdmlkZW8gZW5hYmxlZCBpZiBubyBtZWRpYUhpbnQgY2FuIGJlIGZvdW5kLlxuICAgICAgdmFyIGNvbnN0cmFpbnRzID0gbWVkaWFIaW50LmNvbnN0cmFpbnRzIHx8XG4gICAgICAgICh0aGlzLm1lZGlhSGludCAmJiB0aGlzLm1lZGlhSGludC5jb25zdHJhaW50cykgfHxcbiAgICAgICAge2F1ZGlvOiB0cnVlLCB2aWRlbzogdHJ1ZX07XG5cbiAgICAgIHZhciBkZWZlcnJlZCA9IFNJUC5VdGlscy5kZWZlcigpO1xuXG4gICAgICAvKlxuICAgICAgICogTWFrZSB0aGUgY2FsbCBhc3luY2hyb25vdXMsIHNvIHRoYXQgSUNDcyBoYXZlIGEgY2hhbmNlXG4gICAgICAgKiB0byBkZWZpbmUgY2FsbGJhY2tzIHRvIGB1c2VyTWVkaWFSZXF1ZXN0YFxuICAgICAgICovXG4gICAgICBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3VzZXJNZWRpYVJlcXVlc3QnLCBjb25zdHJhaW50cyk7XG5cbiAgICAgICAgdmFyIGVtaXRUaGVuQ2FsbCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgLy8gRW1pdCB3aXRoIGFsbCBvZiB0aGUgYXJndW1lbnRzIGZyb20gdGhlIHJlYWwgY2FsbGJhY2suXG4gICAgICAgICAgdmFyIG5ld0FyZ3MgPSBbZXZlbnROYW1lXS5jb25jYXQoY2FsbGJhY2tBcmdzKTtcblxuICAgICAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBuZXdBcmdzKTtcblxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3MpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmF1ZGlvIHx8IGNvbnN0cmFpbnRzLnZpZGVvKSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShcbiAgICAgICAgICAgIFNJUC5XZWJSVEMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgIGVtaXRUaGVuQ2FsbC5iaW5kKHRoaXMsICd1c2VyTWVkaWEnLCBzYXZlU3VjY2Vzcy5iaW5kKG51bGwsIGZhbHNlKSksXG4gICAgICAgICAgICAgIGVtaXRUaGVuQ2FsbC5iaW5kKHRoaXMsICd1c2VyTWVkaWFGYWlsZWQnLCBmdW5jdGlvbihlKXt0aHJvdyBlO30pXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMb2NhbCBzdHJlYW1zIHdlcmUgZXhwbGljaXRseSBleGNsdWRlZC5cbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKFtdKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcblxuICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICB9fSxcblxuICAncmVsZWFzZSc6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHJlbGVhc2UgKHN0cmVhbXMpIHtcbiAgICBzdHJlYW1zID0gW10uY29uY2F0KHN0cmVhbXMpO1xuICAgIHN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICB2YXIgc3RyZWFtSWQgPSBNZWRpYVN0cmVhbU1hbmFnZXIuc3RyZWFtSWQoc3RyZWFtKTtcbiAgICAgIGlmICh0aGlzLmFjcXVpc2l0aW9uc1tzdHJlYW1JZF0gPT09IGZhbHNlKSB7XG4gICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5hY3F1aXNpdGlvbnNbc3RyZWFtSWRdO1xuICAgIH0sIHRoaXMpO1xuICB9fSxcbn0pO1xuXG4vLyBSZXR1cm4gc2luY2UgaXQgd2lsbCBiZSBhc3NpZ25lZCB0byBhIHZhcmlhYmxlLlxucmV0dXJuIE1lZGlhU3RyZWFtTWFuYWdlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYVN0cmVhbU1hbmFnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSBTSVAgVXNlciBBZ2VudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24gcmV0dXJuaW5nIFNJUC5NZWRpYUhhbmRsZXJ9IFtjb25maWd1cmF0aW9uLm1lZGlhSGFuZGxlckZhY3RvcnldXG4gKiAgICAgICAgQSBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYnkgZWFjaCBvZiB0aGUgVUEncyBTZXNzaW9ucyB0byBidWlsZCB0aGUgTWVkaWFIYW5kbGVyIGZvciB0aGF0IFNlc3Npb24uXG4gKiAgICAgICAgSWYgbm8gKG9yIGEgZmFsc3kpIHZhbHVlIGlzIHByb3ZpZGVkLCBlYWNoIFNlc3Npb24gd2lsbCB1c2UgYSBkZWZhdWx0IChXZWJSVEMpIE1lZGlhSGFuZGxlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ3VyYXRpb24ubWVkaWFdIGdldHMgcGFzc2VkIHRvIFNJUC5NZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24gYXMgbWVkaWFIaW50XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgZW52aXJvbm1lbnQpIHtcbnZhciBVQSxcbiAgQyA9IHtcbiAgICAvLyBVQSBzdGF0dXMgY29kZXNcbiAgICBTVEFUVVNfSU5JVDogICAgICAgICAgICAgICAgMCxcbiAgICBTVEFUVVNfU1RBUlRJTkc6ICAgICAgICAgICAgMSxcbiAgICBTVEFUVVNfUkVBRFk6ICAgICAgICAgICAgICAgMixcbiAgICBTVEFUVVNfVVNFUl9DTE9TRUQ6ICAgICAgICAgMyxcbiAgICBTVEFUVVNfTk9UX1JFQURZOiAgICAgICAgICAgNCxcblxuICAgIC8vIFVBIGVycm9yIGNvZGVzXG4gICAgQ09ORklHVVJBVElPTl9FUlJPUjogIDEsXG4gICAgTkVUV09SS19FUlJPUjogICAgICAgIDIsXG5cbiAgICBBTExPV0VEX01FVEhPRFM6IFtcbiAgICAgICdBQ0snLFxuICAgICAgJ0NBTkNFTCcsXG4gICAgICAnSU5WSVRFJyxcbiAgICAgICdNRVNTQUdFJyxcbiAgICAgICdCWUUnLFxuICAgICAgJ09QVElPTlMnLFxuICAgICAgJ0lORk8nLFxuICAgICAgJ05PVElGWScsXG4gICAgICAnUkVGRVInXG4gICAgXSxcblxuICAgIEFDQ0VQVEVEX0JPRFlfVFlQRVM6IFtcbiAgICAgICdhcHBsaWNhdGlvbi9zZHAnLFxuICAgICAgJ2FwcGxpY2F0aW9uL2R0bWYtcmVsYXknXG4gICAgXSxcblxuICAgIE1BWF9GT1JXQVJEUzogNzAsXG4gICAgVEFHX0xFTkdUSDogMTBcbiAgfTtcblxuVUEgPSBmdW5jdGlvbihjb25maWd1cmF0aW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGZvcndhcmRpbmcgZXZlbnRzXG4gIGZ1bmN0aW9uIHNlbGZFbWl0KHR5cGUpIHtcbiAgICAvL3JlZ2lzdHJhdGlvbkZhaWxlZCBoYW5kbGVyIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzLiBBbGxvdyBldmVudCBoYW5kbGVycyB0byBiZSBpbnZva2VkIHdpdGggYSB2YXJpYWJsZSBuby4gb2YgYXJndW1lbnRzXG4gICAgcmV0dXJuIHNlbGYuZW1pdC5iaW5kKHNlbGYsIHR5cGUpO1xuICB9XG5cbiAgLy8gU2V0IEFjY2VwdGVkIEJvZHkgVHlwZXNcbiAgQy5BQ0NFUFRFRF9CT0RZX1RZUEVTID0gQy5BQ0NFUFRFRF9CT0RZX1RZUEVTLnRvU3RyaW5nKCk7XG5cbiAgdGhpcy5sb2cgPSBuZXcgU0lQLkxvZ2dlckZhY3RvcnkoKTtcbiAgdGhpcy5sb2dnZXIgPSB0aGlzLmdldExvZ2dlcignc2lwLnVhJyk7XG5cbiAgdGhpcy5jYWNoZSA9IHtcbiAgICBjcmVkZW50aWFsczoge31cbiAgfTtcblxuICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgdGhpcy5kaWFsb2dzID0ge307XG5cbiAgLy9Vc2VyIGFjdGlvbnMgb3V0c2lkZSBhbnkgc2Vzc2lvbi9kaWFsb2cgKE1FU1NBR0UpXG4gIHRoaXMuYXBwbGljYW50cyA9IHt9O1xuXG4gIHRoaXMuZGF0YSA9IHt9O1xuICB0aGlzLnNlc3Npb25zID0ge307XG4gIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHt9O1xuICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIHRoaXMuY29udGFjdCA9IG51bGw7XG4gIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfSU5JVDtcbiAgdGhpcy5lcnJvciA9IG51bGw7XG4gIHRoaXMudHJhbnNhY3Rpb25zID0ge1xuICAgIG5pc3Q6IHt9LFxuICAgIG5pY3Q6IHt9LFxuICAgIGlzdDoge30sXG4gICAgaWN0OiB7fVxuICB9O1xuXG4gIHRoaXMudHJhbnNwb3J0UmVjb3ZlckF0dGVtcHRzID0gMDtcbiAgdGhpcy50cmFuc3BvcnRSZWNvdmVyeVRpbWVyID0gbnVsbDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgdHJhbnNhY3Rpb25zQ291bnQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0eXBlLFxuICAgICAgICAgIHRyYW5zYWN0aW9ucyA9IFsnbmlzdCcsJ25pY3QnLCdpc3QnLCdpY3QnXSxcbiAgICAgICAgICBjb3VudCA9IDA7XG5cbiAgICAgICAgZm9yICh0eXBlIGluIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgIGNvdW50ICs9IE9iamVjdC5rZXlzKHRoaXMudHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uc1t0eXBlXV0pLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmljdFRyYW5zYWN0aW9uc0NvdW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50cmFuc2FjdGlvbnNbJ25pY3QnXSkubGVuZ3RoO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuaXN0VHJhbnNhY3Rpb25zQ291bnQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRyYW5zYWN0aW9uc1snbmlzdCddKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGljdFRyYW5zYWN0aW9uc0NvdW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50cmFuc2FjdGlvbnNbJ2ljdCddKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzdFRyYW5zYWN0aW9uc0NvdW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50cmFuc2FjdGlvbnNbJ2lzdCddKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogTG9hZCBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEB0aHJvd3Mge1NJUC5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcn1cbiAgICogQHRocm93cyB7VHlwZUVycm9yfVxuICAgKi9cblxuICBpZihjb25maWd1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25maWd1cmF0aW9uID0ge307XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24gPT09ICdzdHJpbmcnIHx8IGNvbmZpZ3VyYXRpb24gaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICBjb25maWd1cmF0aW9uID0ge1xuICAgICAgdXJpOiBjb25maWd1cmF0aW9uXG4gICAgfTtcbiAgfVxuXG4gIC8vIEFwcGx5IGxvZyBjb25maWd1cmF0aW9uIGlmIHByZXNlbnRcbiAgaWYgKGNvbmZpZ3VyYXRpb24ubG9nKSB7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24ubG9nLmhhc093blByb3BlcnR5KCdidWlsdGluRW5hYmxlZCcpKSB7XG4gICAgICB0aGlzLmxvZy5idWlsdGluRW5hYmxlZCA9IGNvbmZpZ3VyYXRpb24ubG9nLmJ1aWx0aW5FbmFibGVkO1xuICAgIH1cblxuICAgIGlmIChjb25maWd1cmF0aW9uLmxvZy5oYXNPd25Qcm9wZXJ0eSgnbGV2ZWwnKSkge1xuICAgICAgdGhpcy5sb2cubGV2ZWwgPSBjb25maWd1cmF0aW9uLmxvZy5sZXZlbDtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlndXJhdGlvbi5sb2cuaGFzT3duUHJvcGVydHkoJ2Nvbm5lY3RvcicpKSB7XG4gICAgICB0aGlzLmxvZy5jb25uZWN0b3IgPSBjb25maWd1cmF0aW9uLmxvZy5jb25uZWN0b3I7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmxvYWRDb25maWcoY29uZmlndXJhdGlvbik7XG4gIH0gY2F0Y2goZSkge1xuICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfTk9UX1JFQURZO1xuICAgIHRoaXMuZXJyb3IgPSBDLkNPTkZJR1VSQVRJT05fRVJST1I7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgcmVnaXN0ZXJDb250ZXh0XG4gIHRoaXMucmVnaXN0ZXJDb250ZXh0ID0gbmV3IFNJUC5SZWdpc3RlckNvbnRleHQodGhpcyk7XG4gIHRoaXMucmVnaXN0ZXJDb250ZXh0Lm9uKCdmYWlsZWQnLCBzZWxmRW1pdCgncmVnaXN0cmF0aW9uRmFpbGVkJykpO1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5vbigncmVnaXN0ZXJlZCcsIHNlbGZFbWl0KCdyZWdpc3RlcmVkJykpO1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5vbigndW5yZWdpc3RlcmVkJywgc2VsZkVtaXQoJ3VucmVnaXN0ZXJlZCcpKTtcblxuICBpZih0aGlzLmNvbmZpZ3VyYXRpb24uYXV0b3N0YXJ0KSB7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnZpcm9ubWVudC5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gR29vZ2xlIENocm9tZSBQYWNrYWdlZCBBcHBzIGRvbid0IGFsbG93ICd1bmxvYWQnIGxpc3RlbmVyczpcbiAgICAvLyB1bmxvYWQgaXMgbm90IGF2YWlsYWJsZSBpbiBwYWNrYWdlZCBhcHBzXG4gICAgaWYgKCEoZ2xvYmFsLmNocm9tZSAmJiBnbG9iYWwuY2hyb21lLmFwcCAmJiBnbG9iYWwuY2hyb21lLmFwcC5ydW50aW1lKSkge1xuICAgICAgZW52aXJvbm1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgdGhpcy5zdG9wLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxufTtcblVBLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG4vLz09PT09PT09PT09PT09PT09XG4vLyAgSGlnaCBMZXZlbCBBUElcbi8vPT09PT09PT09PT09PT09PT1cblxuVUEucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLmNvbmZpZ3VyYXRpb24ucmVnaXN0ZXIgPSB0cnVlO1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5yZWdpc3RlcihvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVW5yZWdpc3Rlci5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxdIHVucmVnaXN0ZXIgYWxsIHVzZXIgYmluZGluZ3MuXG4gKlxuICovXG5VQS5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5jb25maWd1cmF0aW9uLnJlZ2lzdGVyID0gZmFsc2U7XG5cbiAgdmFyIGNvbnRleHQgPSB0aGlzLnJlZ2lzdGVyQ29udGV4dDtcbiAgdGhpcy5hZnRlckNvbm5lY3RlZChjb250ZXh0LnVucmVnaXN0ZXIuYmluZChjb250ZXh0LCBvcHRpb25zKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5VQS5wcm90b3R5cGUuaXNSZWdpc3RlcmVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlZ2lzdGVyQ29udGV4dC5yZWdpc3RlcmVkO1xufTtcblxuLyoqXG4gKiBDb25uZWN0aW9uIHN0YXRlLlxuICogQHBhcmFtIHtCb29sZWFufVxuICovXG5VQS5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHJhbnNwb3J0ID8gdGhpcy50cmFuc3BvcnQuY29ubmVjdGVkIDogZmFsc2U7XG59O1xuXG5VQS5wcm90b3R5cGUuYWZ0ZXJDb25uZWN0ZWQgPSBmdW5jdGlvbiBhZnRlckNvbm5lY3RlZCAoY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgIGNhbGxiYWNrKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vbmNlKCdjb25uZWN0ZWQnLCBjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFrZSBhbiBvdXRnb2luZyBjYWxsLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3c1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1lZGlhXSBnZXRzIHBhc3NlZCB0byBTSVAuTWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uIGFzIG1lZGlhSGludFxuICpcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqXG4gKi9cblVBLnByb3RvdHlwZS5pbnZpdGUgPSBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgU0lQLkludml0ZUNsaWVudENvbnRleHQodGhpcywgdGFyZ2V0LCBvcHRpb25zKTtcblxuICB0aGlzLmFmdGVyQ29ubmVjdGVkKGNvbnRleHQuaW52aXRlLmJpbmQoY29udGV4dCkpO1xuICByZXR1cm4gY29udGV4dDtcbn07XG5cblVBLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50LCBvcHRpb25zKSB7XG4gIHZhciBzdWIgPSBuZXcgU0lQLlN1YnNjcmlwdGlvbih0aGlzLCB0YXJnZXQsIGV2ZW50LCBvcHRpb25zKTtcblxuICB0aGlzLmFmdGVyQ29ubmVjdGVkKHN1Yi5zdWJzY3JpYmUuYmluZChzdWIpKTtcbiAgcmV0dXJuIHN1Yjtcbn07XG5cbi8qKlxuICogU2VuZCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKlxuICovXG5VQS5wcm90b3R5cGUubWVzc2FnZSA9IGZ1bmN0aW9uKHRhcmdldCwgYm9keSwgb3B0aW9ucykge1xuICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgfVxuXG4gIC8vIFRoZXJlIGlzIG5vIE1lc3NhZ2UgbW9kdWxlLCBzbyBpdCBpcyBva2F5IHRoYXQgdGhlIFVBIGhhbmRsZXMgZGVmYXVsdHMgaGVyZS5cbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgb3B0aW9ucy5jb250ZW50VHlwZSB8fCAob3B0aW9ucy5jb250ZW50VHlwZSA9ICd0ZXh0L3BsYWluJyk7XG4gIG9wdGlvbnMuYm9keSA9IGJvZHk7XG5cbiAgcmV0dXJuIHRoaXMucmVxdWVzdChTSVAuQy5NRVNTQUdFLCB0YXJnZXQsIG9wdGlvbnMpO1xufTtcblxuVUEucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlcSA9IG5ldyBTSVAuQ2xpZW50Q29udGV4dCh0aGlzLCBtZXRob2QsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgdGhpcy5hZnRlckNvbm5lY3RlZChyZXEuc2VuZC5iaW5kKHJlcSkpO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBHcmFjZWZ1bGx5IGNsb3NlLlxuICpcbiAqL1xuVUEucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlc3Npb24sIHN1YnNjcmlwdGlvbiwgYXBwbGljYW50LFxuICAgIHVhID0gdGhpcztcblxuICBmdW5jdGlvbiB0cmFuc2FjdGlvbnNMaXN0ZW5lcigpIHtcbiAgICBpZiAodWEubmlzdFRyYW5zYWN0aW9uc0NvdW50ID09PSAwICYmIHVhLm5pY3RUcmFuc2FjdGlvbnNDb3VudCA9PT0gMCkge1xuICAgICAgICB1YS5yZW1vdmVMaXN0ZW5lcigndHJhbnNhY3Rpb25EZXN0cm95ZWQnLCB0cmFuc2FjdGlvbnNMaXN0ZW5lcik7XG4gICAgICAgIHVhLnRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5sb2dnZXIubG9nKCd1c2VyIHJlcXVlc3RlZCBjbG9zdXJlLi4uJyk7XG5cbiAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1VTRVJfQ0xPU0VEKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignVUEgYWxyZWFkeSBjbG9zZWQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIENsZWFyIHRyYW5zcG9ydFJlY292ZXJ5VGltZXJcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50cmFuc3BvcnRSZWNvdmVyeVRpbWVyKTtcblxuICAvLyBDbG9zZSByZWdpc3RlckNvbnRleHRcbiAgdGhpcy5sb2dnZXIubG9nKCdjbG9zaW5nIHJlZ2lzdGVyQ29udGV4dCcpO1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5jbG9zZSgpO1xuXG4gIC8vIFJ1biAgX3Rlcm1pbmF0ZV8gb24gZXZlcnkgU2Vzc2lvblxuICBmb3Ioc2Vzc2lvbiBpbiB0aGlzLnNlc3Npb25zKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdjbG9zaW5nIHNlc3Npb24gJyArIHNlc3Npb24pO1xuICAgIHRoaXMuc2Vzc2lvbnNbc2Vzc2lvbl0udGVybWluYXRlKCk7XG4gIH1cblxuICAvL1J1biBfY2xvc2VfIG9uIGV2ZXJ5IFN1YnNjcmlwdGlvblxuICBmb3Ioc3Vic2NyaXB0aW9uIGluIHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyLmxvZygndW5zdWJzY3JpYmluZyBmcm9tIHN1YnNjcmlwdGlvbiAnICsgc3Vic2NyaXB0aW9uKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnNbc3Vic2NyaXB0aW9uXS5jbG9zZSgpO1xuICB9XG5cbiAgLy8gUnVuICBfY2xvc2VfIG9uIGV2ZXJ5IGFwcGxpY2FudFxuICBmb3IoYXBwbGljYW50IGluIHRoaXMuYXBwbGljYW50cykge1xuICAgIHRoaXMuYXBwbGljYW50c1thcHBsaWNhbnRdLmNsb3NlKCk7XG4gIH1cblxuICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX1VTRVJfQ0xPU0VEO1xuXG4gIC8qXG4gICAqIElmIHRoZSByZW1haW5pbmcgdHJhbnNhY3Rpb25zIGFyZSBhbGwgSU5WSVRFIHRyYW5zYWN0aW9ucywgdGhlcmUgaXMgbm8gbmVlZCB0b1xuICAgKiB3YWl0IGFueW1vcmUgYmVjYXVzZSBldmVyeSBzZXNzaW9uIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ5IHRoaXMgbWV0aG9kLlxuICAgKiAtIGxvY2FsbHkgb3JpZ2luYXRlZCBzZXNzaW9ucyB3aGVyZSB0ZXJtaW5hdGVkIChDQU5DRUwgb3IgQllFKVxuICAgKiAtIHJlbW90ZWx5IG9yaWdpbmF0ZWQgc2Vzc2lvbnMgd2hlcmUgcmVqZWN0ZWQgKDRYWCkgb3IgdGVybWluYXRlZCAoQllFKVxuICAgKiBSZW1haW5pbmcgSU5WSVRFIHRyYW5zYWN0aW9ucyBiZWxvbmcgdGhvIHNlc3Npb25zIHRoYXQgd2hlcmUgYW5zd2VyZWQuIFRoaXMgYXJlIGluXG4gICAqICdhY2NlcHRlZCcgc3RhdGUgZHVlIHRvIHRpbWVycyAnTCcgYW5kICdNJyBkZWZpbmVkIGluIFtSRkMgNjAyNl1cbiAgICovXG4gIGlmICh0aGlzLm5pc3RUcmFuc2FjdGlvbnNDb3VudCA9PT0gMCAmJiB0aGlzLm5pY3RUcmFuc2FjdGlvbnNDb3VudCA9PT0gMCkge1xuICAgIHRoaXMudHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9uKCd0cmFuc2FjdGlvbkRlc3Ryb3llZCcsIHRyYW5zYWN0aW9uc0xpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb25uZWN0IHRvIHRoZSBXUyBzZXJ2ZXIgaWYgc3RhdHVzID0gU1RBVFVTX0lOSVQuXG4gKiBSZXN1bWUgVUEgYWZ0ZXIgYmVpbmcgY2xvc2VkLlxuICpcbiAqL1xuVUEucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZXJ2ZXI7XG5cbiAgdGhpcy5sb2dnZXIubG9nKCd1c2VyIHJlcXVlc3RlZCBzdGFydHVwLi4uJyk7XG4gIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfSU5JVCkge1xuICAgIHNlcnZlciA9IHRoaXMuZ2V0TmV4dFdzU2VydmVyKCk7XG4gICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19TVEFSVElORztcbiAgICBuZXcgU0lQLlRyYW5zcG9ydCh0aGlzLCBzZXJ2ZXIpO1xuICB9IGVsc2UgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1VTRVJfQ0xPU0VEKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdyZXN1bWluZycpO1xuICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfUkVBRFk7XG4gICAgdGhpcy50cmFuc3BvcnQuY29ubmVjdCgpO1xuICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19TVEFSVElORykge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnVUEgaXMgaW4gU1RBUlRJTkcgc3RhdHVzLCBub3Qgb3BlbmluZyBuZXcgY29ubmVjdGlvbicpO1xuICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19SRUFEWSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnVUEgaXMgaW4gUkVBRFkgc3RhdHVzLCBub3QgcmVzdW1pbmcnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxvZ2dlci5lcnJvcignQ29ubmVjdGlvbiBpcyBkb3duLiBBdXRvLVJlY292ZXJ5IHN5c3RlbSBpcyB0cnlpbmcgdG8gY29ubmVjdCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHN0cmluZyBpbnRvIGEgdmFsaWQgU0lQIHJlcXVlc3QgVVJJXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICpcbiAqIEByZXR1cm5zIHtTSVAuVVJJfHVuZGVmaW5lZH1cbiAqL1xuVUEucHJvdG90eXBlLm5vcm1hbGl6ZVRhcmdldCA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICByZXR1cm4gU0lQLlV0aWxzLm5vcm1hbGl6ZVRhcmdldCh0YXJnZXQsIHRoaXMuY29uZmlndXJhdGlvbi5ob3N0cG9ydFBhcmFtcyk7XG59O1xuXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gIFByaXZhdGUgKEZvciBpbnRlcm5hbCB1c2UpXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuVUEucHJvdG90eXBlLnNhdmVDcmVkZW50aWFscyA9IGZ1bmN0aW9uKGNyZWRlbnRpYWxzKSB7XG4gIHRoaXMuY2FjaGUuY3JlZGVudGlhbHNbY3JlZGVudGlhbHMucmVhbG1dID0gdGhpcy5jYWNoZS5jcmVkZW50aWFsc1tjcmVkZW50aWFscy5yZWFsbV0gfHwge307XG4gIHRoaXMuY2FjaGUuY3JlZGVudGlhbHNbY3JlZGVudGlhbHMucmVhbG1dW2NyZWRlbnRpYWxzLnVyaV0gPSBjcmVkZW50aWFscztcblxuICByZXR1cm4gdGhpcztcbn07XG5cblVBLnByb3RvdHlwZS5nZXRDcmVkZW50aWFscyA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgdmFyIHJlYWxtLCBjcmVkZW50aWFscztcblxuICByZWFsbSA9IHJlcXVlc3QucnVyaS5ob3N0O1xuXG4gIGlmICh0aGlzLmNhY2hlLmNyZWRlbnRpYWxzW3JlYWxtXSAmJiB0aGlzLmNhY2hlLmNyZWRlbnRpYWxzW3JlYWxtXVtyZXF1ZXN0LnJ1cmldKSB7XG4gICAgY3JlZGVudGlhbHMgPSB0aGlzLmNhY2hlLmNyZWRlbnRpYWxzW3JlYWxtXVtyZXF1ZXN0LnJ1cmldO1xuICAgIGNyZWRlbnRpYWxzLm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICB9XG5cbiAgcmV0dXJuIGNyZWRlbnRpYWxzO1xufTtcblxuVUEucHJvdG90eXBlLmdldExvZ2dlciA9IGZ1bmN0aW9uKGNhdGVnb3J5LCBsYWJlbCkge1xuICByZXR1cm4gdGhpcy5sb2cuZ2V0TG9nZ2VyKGNhdGVnb3J5LCBsYWJlbCk7XG59O1xuXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFdmVudCBIYW5kbGVyc1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBUcmFuc3BvcnQgQ2xvc2UgZXZlbnRcbiAqIEBwcml2YXRlXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0LlxuICovXG5VQS5wcm90b3R5cGUub25UcmFuc3BvcnRDbG9zZWQgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcbiAgLy8gUnVuIF9vblRyYW5zcG9ydEVycm9yXyBjYWxsYmFjayBvbiBldmVyeSBjbGllbnQgdHJhbnNhY3Rpb24gdXNpbmcgX3RyYW5zcG9ydF9cbiAgdmFyIHR5cGUsIGlkeCwgbGVuZ3RoLFxuICAgIGNsaWVudF90cmFuc2FjdGlvbnMgPSBbJ25pY3QnLCAnaWN0JywgJ25pc3QnLCAnaXN0J107XG5cbiAgdHJhbnNwb3J0LnNlcnZlci5zdGF0dXMgPSBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX0RJU0NPTk5FQ1RFRDtcbiAgdGhpcy5sb2dnZXIubG9nKCdjb25uZWN0aW9uIHN0YXRlIHNldCB0byAnKyBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX0RJU0NPTk5FQ1RFRCk7XG5cbiAgbGVuZ3RoID0gY2xpZW50X3RyYW5zYWN0aW9ucy5sZW5ndGg7XG4gIGZvciAodHlwZSA9IDA7IHR5cGUgPCBsZW5ndGg7IHR5cGUrKykge1xuICAgIGZvcihpZHggaW4gdGhpcy50cmFuc2FjdGlvbnNbY2xpZW50X3RyYW5zYWN0aW9uc1t0eXBlXV0pIHtcbiAgICAgIHRoaXMudHJhbnNhY3Rpb25zW2NsaWVudF90cmFuc2FjdGlvbnNbdHlwZV1dW2lkeF0ub25UcmFuc3BvcnRFcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENsb3NlIHNlc3Npb25zIGlmIEdSVVUgaXMgbm90IGJlaW5nIHVzZWRcbiAgaWYgKCF0aGlzLmNvbnRhY3QucHViX2dydXUpIHtcbiAgICB0aGlzLmNsb3NlU2Vzc2lvbnNPblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBVbnJlY292ZXJhYmxlIHRyYW5zcG9ydCBldmVudC5cbiAqIENvbm5lY3Rpb24gcmVhdHRlbXB0IGxvZ2ljIGhhcyBiZWVuIGRvbmUgYW5kIGRpZG4ndCBzdWNjZXNzLlxuICogQHByaXZhdGVcbiAqIEBldmVudFxuICogQHBhcmFtIHtTSVAuVHJhbnNwb3J0fSB0cmFuc3BvcnQuXG4gKi9cblVBLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG4gIHZhciBzZXJ2ZXI7XG5cbiAgdGhpcy5sb2dnZXIubG9nKCd0cmFuc3BvcnQgJyArIHRyYW5zcG9ydC5zZXJ2ZXIud3NfdXJpICsgJyBmYWlsZWQgfCBjb25uZWN0aW9uIHN0YXRlIHNldCB0byAnKyBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX0VSUk9SKTtcblxuICAvLyBDbG9zZSBzZXNzaW9ucy5cbiAgLy9NYXJrIHRoaXMgdHJhbnNwb3J0IGFzICdkb3duJ1xuICB0cmFuc3BvcnQuc2VydmVyLnN0YXR1cyA9IFNJUC5UcmFuc3BvcnQuQy5TVEFUVVNfRVJST1I7XG5cbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0ZWQnLCB7XG4gICAgdHJhbnNwb3J0OiB0cmFuc3BvcnRcbiAgfSk7XG5cbiAgLy8gdHJ5IHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgVUEgaXNuJ3QgY2xvc2VkXG4gIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19VU0VSX0NMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlcnZlciA9IHRoaXMuZ2V0TmV4dFdzU2VydmVyKCk7XG5cbiAgaWYoc2VydmVyKSB7XG4gICAgbmV3IFNJUC5UcmFuc3BvcnQodGhpcywgc2VydmVyKTtcbiAgfWVsc2Uge1xuICAgIHRoaXMuY2xvc2VTZXNzaW9uc09uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICBpZiAoIXRoaXMuZXJyb3IgfHwgdGhpcy5lcnJvciAhPT0gQy5ORVRXT1JLX0VSUk9SKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX05PVF9SRUFEWTtcbiAgICAgIHRoaXMuZXJyb3IgPSBDLk5FVFdPUktfRVJST1I7XG4gICAgfVxuICAgIC8vIFRyYW5zcG9ydCBSZWNvdmVyeSBwcm9jZXNzXG4gICAgdGhpcy5yZWNvdmVyVHJhbnNwb3J0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogVHJhbnNwb3J0IGNvbm5lY3Rpb24gZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICogQGV2ZW50XG4gKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydC5cbiAqL1xuVUEucHJvdG90eXBlLm9uVHJhbnNwb3J0Q29ubmVjdGVkID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIFJlc2V0IHRyYW5zcG9ydCByZWNvdmVyeSBjb3VudGVyXG4gIHRoaXMudHJhbnNwb3J0UmVjb3ZlckF0dGVtcHRzID0gMDtcblxuICB0cmFuc3BvcnQuc2VydmVyLnN0YXR1cyA9IFNJUC5UcmFuc3BvcnQuQy5TVEFUVVNfUkVBRFk7XG4gIHRoaXMubG9nZ2VyLmxvZygnY29ubmVjdGlvbiBzdGF0ZSBzZXQgdG8gJysgU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19SRUFEWSk7XG5cbiAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1VTRVJfQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19SRUFEWTtcbiAgdGhpcy5lcnJvciA9IG51bGw7XG5cbiAgaWYodGhpcy5jb25maWd1cmF0aW9uLnJlZ2lzdGVyKSB7XG4gICAgdGhpcy5jb25maWd1cmF0aW9uLmF1dGhlbnRpY2F0aW9uRmFjdG9yeS5pbml0aWFsaXplKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5vblRyYW5zcG9ydENvbm5lY3RlZCgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICB0aGlzLmVtaXQoJ2Nvbm5lY3RlZCcsIHtcbiAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydFxuICB9KTtcbn07XG5cblxuLyoqXG4gKiBUcmFuc3BvcnQgY29ubmVjdGluZyBldmVudFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0LlxuICogI3BhcmFtIHtJbnRlZ2VyfSBhdHRlbXB0cy5cbiAqL1xuICBVQS5wcm90b3R5cGUub25UcmFuc3BvcnRDb25uZWN0aW5nID0gZnVuY3Rpb24odHJhbnNwb3J0LCBhdHRlbXB0cykge1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdGluZycsIHtcbiAgICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0LFxuICAgICAgYXR0ZW1wdHM6IGF0dGVtcHRzXG4gICAgfSk7XG4gIH07XG5cblxuLyoqXG4gKiBuZXcgVHJhbnNhY3Rpb25cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5UcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24uXG4gKi9cblVBLnByb3RvdHlwZS5uZXdUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIHRoaXMudHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uLnR5cGVdW3RyYW5zYWN0aW9uLmlkXSA9IHRyYW5zYWN0aW9uO1xuICB0aGlzLmVtaXQoJ25ld1RyYW5zYWN0aW9uJywge3RyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbn0pO1xufTtcblxuXG4vKipcbiAqIGRlc3Ryb3kgVHJhbnNhY3Rpb25cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5UcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24uXG4gKi9cblVBLnByb3RvdHlwZS5kZXN0cm95VHJhbnNhY3Rpb24gPSBmdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICBkZWxldGUgdGhpcy50cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb24udHlwZV1bdHJhbnNhY3Rpb24uaWRdO1xuICB0aGlzLmVtaXQoJ3RyYW5zYWN0aW9uRGVzdHJveWVkJywge1xuICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICB9KTtcbn07XG5cblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyByZWNlaXZlUmVxdWVzdFxuLy89PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogUmVxdWVzdCByZWNlcHRpb25cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3QuXG4gKi9cblVBLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgdmFyIGRpYWxvZywgc2Vzc2lvbiwgbWVzc2FnZSxcbiAgICBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZCxcbiAgICB0cmFuc2FjdGlvbixcbiAgICByZXBsYWNlcyxcbiAgICByZXBsYWNlZERpYWxvZyxcbiAgICBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBydXJpTWF0Y2hlcyAodXJpKSB7XG4gICAgcmV0dXJuIHVyaSAmJiB1cmkudXNlciA9PT0gcmVxdWVzdC5ydXJpLnVzZXI7XG4gIH1cblxuICAvLyBDaGVjayB0aGF0IHJlcXVlc3QgVVJJIHBvaW50cyB0byB1c1xuICBpZighKHJ1cmlNYXRjaGVzKHRoaXMuY29uZmlndXJhdGlvbi51cmkpIHx8XG4gICAgICAgcnVyaU1hdGNoZXModGhpcy5jb250YWN0LnVyaSkgfHxcbiAgICAgICBydXJpTWF0Y2hlcyh0aGlzLmNvbnRhY3QucHViX2dydXUpIHx8XG4gICAgICAgcnVyaU1hdGNoZXModGhpcy5jb250YWN0LnRlbXBfZ3J1dSkpKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignUmVxdWVzdC1VUkkgZG9lcyBub3QgcG9pbnQgdG8gdXMnKTtcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFNJUC5DLkFDSykge1xuICAgICAgcmVxdWVzdC5yZXBseV9zbCg0MDQpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDaGVjayByZXF1ZXN0IFVSSSBzY2hlbWVcbiAgaWYocmVxdWVzdC5ydXJpLnNjaGVtZSA9PT0gU0lQLkMuU0lQUykge1xuICAgIHJlcXVlc3QucmVwbHlfc2woNDE2KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDaGVjayB0cmFuc2FjdGlvblxuICBpZihTSVAuVHJhbnNhY3Rpb25zLmNoZWNrVHJhbnNhY3Rpb24odGhpcywgcmVxdWVzdCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBSRkMzMjYxIDEyLjIuMlxuICAgKiBSZXF1ZXN0cyB0aGF0IGRvIG5vdCBjaGFuZ2UgaW4gYW55IHdheSB0aGUgc3RhdGUgb2YgYSBkaWFsb2cgbWF5IGJlXG4gICAqIHJlY2VpdmVkIHdpdGhpbiBhIGRpYWxvZyAoZm9yIGV4YW1wbGUsIGFuIE9QVElPTlMgcmVxdWVzdCkuXG4gICAqIFRoZXkgYXJlIHByb2Nlc3NlZCBhcyBpZiB0aGV5IGhhZCBiZWVuIHJlY2VpdmVkIG91dHNpZGUgdGhlIGRpYWxvZy5cbiAgICovXG4gIGlmKG1ldGhvZCA9PT0gU0lQLkMuT1BUSU9OUykge1xuICAgIG5ldyBTSVAuVHJhbnNhY3Rpb25zLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uKHJlcXVlc3QsIHRoaXMpO1xuICAgIHJlcXVlc3QucmVwbHkoMjAwLCBudWxsLCBbXG4gICAgICAnQWxsb3c6ICcrIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpLFxuICAgICAgJ0FjY2VwdDogJysgQy5BQ0NFUFRFRF9CT0RZX1RZUEVTXG4gICAgXSk7XG4gIH0gZWxzZSBpZiAobWV0aG9kID09PSBTSVAuQy5NRVNTQUdFKSB7XG4gICAgbWVzc2FnZSA9IG5ldyBTSVAuU2VydmVyQ29udGV4dCh0aGlzLCByZXF1ZXN0KTtcbiAgICBtZXNzYWdlLmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgbWVzc2FnZS5jb250ZW50X3R5cGUgPSByZXF1ZXN0LmdldEhlYWRlcignQ29udGVudC1UeXBlJykgfHwgJ3RleHQvcGxhaW4nO1xuXG4gICAgcmVxdWVzdC5yZXBseSgyMDAsIG51bGwpO1xuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICB9IGVsc2UgaWYgKG1ldGhvZCAhPT0gU0lQLkMuSU5WSVRFICYmXG4gICAgICAgICAgICAgbWV0aG9kICE9PSBTSVAuQy5BQ0spIHtcbiAgICAvLyBMZXQgdGhvc2UgbWV0aG9kcyBwYXNzIHRocm91Z2ggdG8gbm9ybWFsIHByb2Nlc3NpbmcgZm9yIG5vdy5cbiAgICB0cmFuc2FjdGlvbiA9IG5ldyBTSVAuU2VydmVyQ29udGV4dCh0aGlzLCByZXF1ZXN0KTtcbiAgfVxuXG4gIC8vIEluaXRpYWwgUmVxdWVzdFxuICBpZighcmVxdWVzdC50b190YWcpIHtcbiAgICBzd2l0Y2gobWV0aG9kKSB7XG4gICAgICBjYXNlIFNJUC5DLklOVklURTpcbiAgICAgICAgcmVwbGFjZXMgPVxuICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5yZXBsYWNlcyAhPT0gU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEICYmXG4gICAgICAgICAgcmVxdWVzdC5wYXJzZUhlYWRlcigncmVwbGFjZXMnKTtcblxuICAgICAgICBpZiAocmVwbGFjZXMpIHtcbiAgICAgICAgICByZXBsYWNlZERpYWxvZyA9IHRoaXMuZGlhbG9nc1tyZXBsYWNlcy5jYWxsX2lkICsgcmVwbGFjZXMucmVwbGFjZXNfdG9fdGFnICsgcmVwbGFjZXMucmVwbGFjZXNfZnJvbV90YWddO1xuXG4gICAgICAgICAgaWYgKCFyZXBsYWNlZERpYWxvZykge1xuICAgICAgICAgICAgLy9SZXBsYWNlZCBoZWFkZXIgd2l0aG91dCBhIG1hdGNoaW5nIGRpYWxvZywgcmVqZWN0XG4gICAgICAgICAgICByZXF1ZXN0LnJlcGx5X3NsKDQ4MSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlZERpYWxvZy5vd25lci5zdGF0dXMgPT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVwbHlfc2woNjAzLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcGxhY2VkRGlhbG9nLnN0YXRlID09PSBTSVAuRGlhbG9nLkMuU1RBVFVTX0NPTkZJUk1FRCAmJiByZXBsYWNlcy5lYXJseV9vbmx5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlcGx5X3NsKDQ4NiwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzTWVkaWFTdXBwb3J0ZWQgPSB0aGlzLmNvbmZpZ3VyYXRpb24ubWVkaWFIYW5kbGVyRmFjdG9yeS5pc1N1cHBvcnRlZDtcbiAgICAgICAgaWYoIWlzTWVkaWFTdXBwb3J0ZWQgfHwgaXNNZWRpYVN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgc2Vzc2lvbiA9IG5ldyBTSVAuSW52aXRlU2VydmVyQ29udGV4dCh0aGlzLCByZXF1ZXN0KTtcbiAgICAgICAgICBzZXNzaW9uLnJlcGxhY2VlID0gcmVwbGFjZWREaWFsb2cgJiYgcmVwbGFjZWREaWFsb2cub3duZXI7XG4gICAgICAgICAgc2Vzc2lvbi5vbignaW52aXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2ludml0ZScsIHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0lOVklURSByZWNlaXZlZCBidXQgV2ViUlRDIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICByZXF1ZXN0LnJlcGx5KDQ4OCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLkJZRTpcbiAgICAgICAgLy8gT3V0IG9mIGRpYWxvZyBCWUUgcmVjZWl2ZWRcbiAgICAgICAgcmVxdWVzdC5yZXBseSg0ODEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuQ0FOQ0VMOlxuICAgICAgICBzZXNzaW9uID0gdGhpcy5maW5kU2Vzc2lvbihyZXF1ZXN0KTtcbiAgICAgICAgaWYoc2Vzc2lvbikge1xuICAgICAgICAgIHNlc3Npb24ucmVjZWl2ZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybigncmVjZWl2ZWQgQ0FOQ0VMIHJlcXVlc3QgZm9yIGEgbm9uIGV4aXN0ZW50IHNlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuQUNLOlxuICAgICAgICAvKiBBYnNvcmIgaXQuXG4gICAgICAgICAqIEFDSyByZXF1ZXN0IHdpdGhvdXQgYSBjb3JyZXNwb25kaW5nIEludml0ZSBUcmFuc2FjdGlvblxuICAgICAgICAgKiBhbmQgd2l0aG91dCBUbyB0YWcuXG4gICAgICAgICAqL1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlcXVlc3QucmVwbHkoNDA1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8vIEluLWRpYWxvZyByZXF1ZXN0XG4gIGVsc2Uge1xuICAgIGRpYWxvZyA9IHRoaXMuZmluZERpYWxvZyhyZXF1ZXN0KTtcblxuICAgIGlmKGRpYWxvZykge1xuICAgICAgaWYgKG1ldGhvZCA9PT0gU0lQLkMuSU5WSVRFKSB7XG4gICAgICAgIG5ldyBTSVAuVHJhbnNhY3Rpb25zLkludml0ZVNlcnZlclRyYW5zYWN0aW9uKHJlcXVlc3QsIHRoaXMpO1xuICAgICAgfVxuICAgICAgZGlhbG9nLnJlY2VpdmVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBTSVAuQy5OT1RJRlkpIHtcbiAgICAgIHNlc3Npb24gPSB0aGlzLmZpbmRTZXNzaW9uKHJlcXVlc3QpO1xuICAgICAgaWYoc2Vzc2lvbikge1xuICAgICAgICBzZXNzaW9uLnJlY2VpdmVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybigncmVjZWl2ZWQgTk9USUZZIHJlcXVlc3QgZm9yIGEgbm9uIGV4aXN0ZW50IHNlc3Npb24nKTtcbiAgICAgICAgcmVxdWVzdC5yZXBseSg0ODEsICdTdWJzY3JpcHRpb24gZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogUkZDMzI2MSAxMi4yLjJcbiAgICAgKiBSZXF1ZXN0IHdpdGggdG8gdGFnLCBidXQgbm8gbWF0Y2hpbmcgZGlhbG9nIGZvdW5kLlxuICAgICAqIEV4Y2VwdGlvbjogQUNLIGZvciBhbiBJbnZpdGUgcmVxdWVzdCBmb3Igd2hpY2ggYSBkaWFsb2cgaGFzIG5vdFxuICAgICAqIGJlZW4gY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbHNlIHtcbiAgICAgIGlmKG1ldGhvZCAhPT0gU0lQLkMuQUNLKSB7XG4gICAgICAgIHJlcXVlc3QucmVwbHkoNDgxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vPT09PT09PT09PT09PT09PT1cbi8vIFV0aWxzXG4vLz09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogR2V0IHRoZSBzZXNzaW9uIHRvIHdoaWNoIHRoZSByZXF1ZXN0IGJlbG9uZ3MgdG8sIGlmIGFueS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3QuXG4gKiBAcmV0dXJucyB7U0lQLk91dGdvaW5nU2Vzc2lvbnxTSVAuSW5jb21pbmdTZXNzaW9ufG51bGx9XG4gKi9cblVBLnByb3RvdHlwZS5maW5kU2Vzc2lvbiA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHRoaXMuc2Vzc2lvbnNbcmVxdWVzdC5jYWxsX2lkICsgcmVxdWVzdC5mcm9tX3RhZ10gfHxcbiAgICAgICAgICB0aGlzLnNlc3Npb25zW3JlcXVlc3QuY2FsbF9pZCArIHJlcXVlc3QudG9fdGFnXSB8fFxuICAgICAgICAgIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZGlhbG9nIHRvIHdoaWNoIHRoZSByZXF1ZXN0IGJlbG9uZ3MgdG8sIGlmIGFueS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9XG4gKiBAcmV0dXJucyB7U0lQLkRpYWxvZ3xudWxsfVxuICovXG5VQS5wcm90b3R5cGUuZmluZERpYWxvZyA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHRoaXMuZGlhbG9nc1tyZXF1ZXN0LmNhbGxfaWQgKyByZXF1ZXN0LmZyb21fdGFnICsgcmVxdWVzdC50b190YWddIHx8XG4gICAgICAgICAgdGhpcy5kaWFsb2dzW3JlcXVlc3QuY2FsbF9pZCArIHJlcXVlc3QudG9fdGFnICsgcmVxdWVzdC5mcm9tX3RhZ10gfHxcbiAgICAgICAgICBudWxsO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbmV4dCBzZXJ2ZXIgdG8gd2hpY2ggY29ubmVjdC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB3c19zZXJ2ZXJcbiAqL1xuVUEucHJvdG90eXBlLmdldE5leHRXc1NlcnZlciA9IGZ1bmN0aW9uKCkge1xuICAvLyBPcmRlciBzZXJ2ZXJzIGJ5IHdlaWdodFxuICB2YXIgaWR4LCBsZW5ndGgsIHdzX3NlcnZlcixcbiAgICBjYW5kaWRhdGVzID0gW107XG5cbiAgbGVuZ3RoID0gdGhpcy5jb25maWd1cmF0aW9uLndzU2VydmVycy5sZW5ndGg7XG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgIHdzX3NlcnZlciA9IHRoaXMuY29uZmlndXJhdGlvbi53c1NlcnZlcnNbaWR4XTtcblxuICAgIGlmICh3c19zZXJ2ZXIuc3RhdHVzID09PSBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX0VSUk9SKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYW5kaWRhdGVzLnB1c2god3Nfc2VydmVyKTtcbiAgICB9IGVsc2UgaWYgKHdzX3NlcnZlci53ZWlnaHQgPiBjYW5kaWRhdGVzWzBdLndlaWdodCkge1xuICAgICAgY2FuZGlkYXRlcyA9IFt3c19zZXJ2ZXJdO1xuICAgIH0gZWxzZSBpZiAod3Nfc2VydmVyLndlaWdodCA9PT0gY2FuZGlkYXRlc1swXS53ZWlnaHQpIHtcbiAgICAgIGNhbmRpZGF0ZXMucHVzaCh3c19zZXJ2ZXIpO1xuICAgIH1cbiAgfVxuXG4gIGlkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNhbmRpZGF0ZXMubGVuZ3RoKTtcblxuICByZXR1cm4gY2FuZGlkYXRlc1tpZHhdO1xufTtcblxuLyoqXG4gKiBDbG9zZSBhbGwgc2Vzc2lvbnMgb24gdHJhbnNwb3J0IGVycm9yLlxuICogQHByaXZhdGVcbiAqL1xuVUEucHJvdG90eXBlLmNsb3NlU2Vzc2lvbnNPblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpZHg7XG5cbiAgLy8gUnVuIF90cmFuc3BvcnRFcnJvcl8gZm9yIGV2ZXJ5IFNlc3Npb25cbiAgZm9yKGlkeCBpbiB0aGlzLnNlc3Npb25zKSB7XG4gICAgdGhpcy5zZXNzaW9uc1tpZHhdLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxuICAvLyBDYWxsIHJlZ2lzdGVyQ29udGV4dCBfb25UcmFuc3BvcnRDbG9zZWRfXG4gIHRoaXMucmVnaXN0ZXJDb250ZXh0Lm9uVHJhbnNwb3J0Q2xvc2VkKCk7XG59O1xuXG5VQS5wcm90b3R5cGUucmVjb3ZlclRyYW5zcG9ydCA9IGZ1bmN0aW9uKHVhKSB7XG4gIHZhciBpZHgsIGxlbmd0aCwgaywgbmV4dFJldHJ5LCBjb3VudCwgc2VydmVyO1xuXG4gIHVhID0gdWEgfHwgdGhpcztcbiAgY291bnQgPSB1YS50cmFuc3BvcnRSZWNvdmVyQXR0ZW1wdHM7XG5cbiAgbGVuZ3RoID0gdWEuY29uZmlndXJhdGlvbi53c1NlcnZlcnMubGVuZ3RoO1xuICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICB1YS5jb25maWd1cmF0aW9uLndzU2VydmVyc1tpZHhdLnN0YXR1cyA9IDA7XG4gIH1cblxuICBzZXJ2ZXIgPSB1YS5nZXROZXh0V3NTZXJ2ZXIoKTtcblxuICBrID0gTWF0aC5mbG9vcigoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsY291bnQpKSArMSk7XG4gIG5leHRSZXRyeSA9IGsgKiB1YS5jb25maWd1cmF0aW9uLmNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsO1xuXG4gIGlmIChuZXh0UmV0cnkgPiB1YS5jb25maWd1cmF0aW9uLmNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCd0aW1lIGZvciBuZXh0IGNvbm5lY3Rpb24gYXR0ZW1wdCBleGNlZWRzIGNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsLCByZXNldHRpbmcgY291bnRlcicpO1xuICAgIG5leHRSZXRyeSA9IHVhLmNvbmZpZ3VyYXRpb24uY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWw7XG4gICAgY291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5sb2dnZXIubG9nKCduZXh0IGNvbm5lY3Rpb24gYXR0ZW1wdCBpbiAnKyBuZXh0UmV0cnkgKycgc2Vjb25kcycpO1xuXG4gIHRoaXMudHJhbnNwb3J0UmVjb3ZlcnlUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChcbiAgICBmdW5jdGlvbigpe1xuICAgICAgdWEudHJhbnNwb3J0UmVjb3ZlckF0dGVtcHRzID0gY291bnQgKyAxO1xuICAgICAgbmV3IFNJUC5UcmFuc3BvcnQodWEsIHNlcnZlcik7XG4gICAgfSwgbmV4dFJldHJ5ICogMTAwMCk7XG59O1xuXG5mdW5jdGlvbiBjaGVja0F1dGhlbnRpY2F0aW9uRmFjdG9yeSAoYXV0aGVudGljYXRpb25GYWN0b3J5KSB7XG4gIGlmICghKGF1dGhlbnRpY2F0aW9uRmFjdG9yeSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWF1dGhlbnRpY2F0aW9uRmFjdG9yeS5pbml0aWFsaXplKSB7XG4gICAgYXV0aGVudGljYXRpb25GYWN0b3J5LmluaXRpYWxpemUgPSBmdW5jdGlvbiBpbml0aWFsaXplICgpIHtcbiAgICAgIHJldHVybiBTSVAuVXRpbHMuUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYXV0aGVudGljYXRpb25GYWN0b3J5O1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gbG9hZC5cbiAqIEBwcml2YXRlXG4gKiByZXR1cm5zIHtCb29sZWFufVxuICovXG5VQS5wcm90b3R5cGUubG9hZENvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgLy8gU2V0dGluZ3MgYW5kIGRlZmF1bHQgdmFsdWVzXG4gIHZhciBwYXJhbWV0ZXIsIHZhbHVlLCBjaGVja2VkX3ZhbHVlLCBob3N0cG9ydFBhcmFtcywgcmVnaXN0cmFyU2VydmVyLFxuICAgIHNldHRpbmdzID0ge1xuICAgICAgLyogSG9zdCBhZGRyZXNzXG4gICAgICAqIFZhbHVlIHRvIGJlIHNldCBpbiBWaWEgc2VudF9ieSBhbmQgaG9zdCBwYXJ0IG9mIENvbnRhY3QgRlFETlxuICAgICAgKi9cbiAgICAgIHZpYUhvc3Q6IFNJUC5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbigxMikgKyAnLmludmFsaWQnLFxuXG4gICAgICB1cmk6IG5ldyBTSVAuVVJJKCdzaXAnLCAnYW5vbnltb3VzLicgKyBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oNiksICdhbm9ueW1vdXMuaW52YWxpZCcsIG51bGwsIG51bGwpLFxuICAgICAgd3NTZXJ2ZXJzOiBbe1xuICAgICAgICBzY2hlbWU6ICdXU1MnLFxuICAgICAgICBzaXBfdXJpOiAnPHNpcDplZGdlLnNpcC5vbnNpcC5jb207dHJhbnNwb3J0PXdzO2xyPicsXG4gICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgd2VpZ2h0OiAwLFxuICAgICAgICB3c191cmk6ICd3c3M6Ly9lZGdlLnNpcC5vbnNpcC5jb20nXG4gICAgICB9XSxcblxuICAgICAgLy8gUGFzc3dvcmRcbiAgICAgIHBhc3N3b3JkOiBudWxsLFxuXG4gICAgICAvLyBSZWdpc3RyYXRpb24gcGFyYW1ldGVyc1xuICAgICAgcmVnaXN0ZXJFeHBpcmVzOiA2MDAsXG4gICAgICByZWdpc3RlcjogdHJ1ZSxcbiAgICAgIHJlZ2lzdHJhclNlcnZlcjogbnVsbCxcblxuICAgICAgLy8gVHJhbnNwb3J0IHJlbGF0ZWQgcGFyYW1ldGVyc1xuICAgICAgd3NTZXJ2ZXJNYXhSZWNvbm5lY3Rpb246IDMsXG4gICAgICB3c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXQ6IDQsXG5cbiAgICAgIGNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsOiAyLFxuICAgICAgY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWw6IDMwLFxuXG4gICAgICBrZWVwQWxpdmVJbnRlcnZhbDogMCxcblxuICAgICAgZXh0cmFTdXBwb3J0ZWQ6IFtdLFxuXG4gICAgICB1c2VQcmVsb2FkZWRSb3V0ZTogZmFsc2UsXG5cbiAgICAgIC8vc3RyaW5nIHRvIGJlIGluc2VydGVkIGludG8gVXNlci1BZ2VudCByZXF1ZXN0IGhlYWRlclxuICAgICAgdXNlckFnZW50U3RyaW5nOiBTSVAuQy5VU0VSX0FHRU5ULFxuXG4gICAgICAvLyBTZXNzaW9uIHBhcmFtZXRlcnNcbiAgICAgIGljZUNoZWNraW5nVGltZW91dDogNTAwMCxcbiAgICAgIG5vQW5zd2VyVGltZW91dDogNjAsXG4gICAgICBzdHVuU2VydmVyczogWydzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJ10sXG4gICAgICB0dXJuU2VydmVyczogW10sXG5cbiAgICAgIC8vIExvZ2dpbmcgcGFyYW1ldGVyc1xuICAgICAgdHJhY2VTaXA6IGZhbHNlLFxuXG4gICAgICAvLyBIYWNrc1xuICAgICAgaGFja1ZpYVRjcDogZmFsc2UsXG4gICAgICBoYWNrSXBJbkNvbnRhY3Q6IGZhbHNlLFxuICAgICAgaGFja1dzc0luVHJhbnNwb3J0OiBmYWxzZSxcbiAgICAgIGhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3M6IGZhbHNlLFxuXG4gICAgICBjb250YWN0VHJhbnNwb3J0OiAnd3MnLFxuICAgICAgZm9yY2VScG9ydDogZmFsc2UsXG5cbiAgICAgIC8vYXV0b3N0YXJ0aW5nXG4gICAgICBhdXRvc3RhcnQ6IHRydWUsXG5cbiAgICAgIC8vUmVsaWFibGUgUHJvdmlzaW9uYWwgUmVzcG9uc2VzXG4gICAgICByZWwxMDA6IFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRCxcblxuICAgICAgLy8gUmVwbGFjZXMgaGVhZGVyIChSRkMgMzg5MSlcbiAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM4OTFcbiAgICAgIHJlcGxhY2VzOiBTSVAuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQsXG5cbiAgICAgIG1lZGlhSGFuZGxlckZhY3Rvcnk6IFNJUC5XZWJSVEMuTWVkaWFIYW5kbGVyLmRlZmF1bHRGYWN0b3J5LFxuXG4gICAgICBhdXRoZW50aWNhdGlvbkZhY3Rvcnk6IGNoZWNrQXV0aGVudGljYXRpb25GYWN0b3J5KGZ1bmN0aW9uIGF1dGhlbnRpY2F0aW9uRmFjdG9yeSAodWEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTSVAuRGlnZXN0QXV0aGVudGljYXRpb24odWEpO1xuICAgICAgfSlcbiAgICB9O1xuXG4gIC8vIFByZS1Db25maWd1cmF0aW9uXG4gIGZ1bmN0aW9uIGFsaWFzVW5kZXJzY29yZWQgKHBhcmFtZXRlciwgbG9nZ2VyKSB7XG4gICAgdmFyIHVuZGVyc2NvcmVkID0gcGFyYW1ldGVyLnJlcGxhY2UoLyhbYS16XVtBLVpdKS9nLCBmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG1bMF0gKyAnXycgKyBtWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICBpZiAocGFyYW1ldGVyID09PSB1bmRlcnNjb3JlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoYXNQYXJhbWV0ZXIgPSBjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KHBhcmFtZXRlcik7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkodW5kZXJzY29yZWQpKSB7XG4gICAgICBsb2dnZXIud2Fybih1bmRlcnNjb3JlZCArICcgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAnICsgcGFyYW1ldGVyKTtcbiAgICAgIGlmIChoYXNQYXJhbWV0ZXIpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4ocGFyYW1ldGVyICsgJyBvdmVycmlkaW5nICcgKyB1bmRlcnNjb3JlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdID0gaGFzUGFyYW1ldGVyID8gY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdIDogY29uZmlndXJhdGlvblt1bmRlcnNjb3JlZF07XG4gIH1cblxuICAvLyBDaGVjayBNYW5kYXRvcnkgcGFyYW1ldGVyc1xuICBmb3IocGFyYW1ldGVyIGluIFVBLmNvbmZpZ3VyYXRpb25fY2hlY2subWFuZGF0b3J5KSB7XG4gICAgYWxpYXNVbmRlcnNjb3JlZChwYXJhbWV0ZXIsIHRoaXMubG9nZ2VyKTtcbiAgICBpZighY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdO1xuICAgICAgY2hlY2tlZF92YWx1ZSA9IFVBLmNvbmZpZ3VyYXRpb25fY2hlY2subWFuZGF0b3J5W3BhcmFtZXRlcl0odmFsdWUpO1xuICAgICAgaWYgKGNoZWNrZWRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXR0aW5nc1twYXJhbWV0ZXJdID0gY2hlY2tlZF92YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IocGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgU0lQLlV0aWxzLm9wdGlvbnNPdmVycmlkZShjb25maWd1cmF0aW9uLCAncmVsMTAwJywgJ3JlbGlhYmxlJywgdHJ1ZSwgdGhpcy5sb2dnZXIsIFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRCk7XG5cbiAgdmFyIGVtcHR5QXJyYXlzQWxsb3dlZCA9IFsnc3R1blNlcnZlcnMnLCAndHVyblNlcnZlcnMnXTtcblxuICAvLyBDaGVjayBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gIGZvcihwYXJhbWV0ZXIgaW4gVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbCkge1xuICAgIGFsaWFzVW5kZXJzY29yZWQocGFyYW1ldGVyLCB0aGlzLmxvZ2dlcik7XG4gICAgaWYoY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICB2YWx1ZSA9IGNvbmZpZ3VyYXRpb25bcGFyYW1ldGVyXTtcblxuICAgICAgLy8gSWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSwgYnV0IHNob3VsZG4ndCBiZSwgYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSAmJiB2YWx1ZS5sZW5ndGggPT09IDAgJiYgZW1wdHlBcnJheXNBbGxvd2VkLmluZGV4T2YocGFyYW1ldGVyKSA8IDApIHsgY29udGludWU7IH1cblxuICAgICAgLy8gSWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBudWxsLCBlbXB0eSBzdHJpbmcsIG9yIHVuZGVmaW5lZCB0aGVuIGFwcGx5IGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgaWYodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgeyBjb250aW51ZTsgfVxuICAgICAgLy8gSWYgaXQncyBhIG51bWJlciB3aXRoIE5hTiB2YWx1ZSB0aGVuIGFsc28gYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICAvLyBOT1RFOiBKUyBkb2VzIG5vdCBhbGxvdyBcInZhbHVlID09PSBOYU5cIiwgdGhlIGZvbGxvd2luZyBkb2VzIHRoZSB3b3JrOlxuICAgICAgZWxzZSBpZih0eXBlb2YodmFsdWUpID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHsgY29udGludWU7IH1cblxuICAgICAgY2hlY2tlZF92YWx1ZSA9IFVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbcGFyYW1ldGVyXSh2YWx1ZSk7XG4gICAgICBpZiAoY2hlY2tlZF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldHRpbmdzW3BhcmFtZXRlcl0gPSBjaGVja2VkX3ZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcihwYXJhbWV0ZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTYW5pdHkgQ2hlY2tzXG5cbiAgLy8gQ29ubmVjdGlvbiByZWNvdmVyeSBpbnRlcnZhbHNcbiAgaWYoc2V0dGluZ3MuY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWwgPCBzZXR0aW5ncy5jb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbCkge1xuICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IoJ2Nvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsJywgc2V0dGluZ3MuY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWwpO1xuICB9XG5cbiAgLy8gUG9zdCBDb25maWd1cmF0aW9uIFByb2Nlc3NcblxuICAvLyBBbGxvdyBwYXNzaW5nIDAgbnVtYmVyIGFzIGRpc3BsYXlOYW1lLlxuICBpZiAoc2V0dGluZ3MuZGlzcGxheU5hbWUgPT09IDApIHtcbiAgICBzZXR0aW5ncy5kaXNwbGF5TmFtZSA9ICcwJztcbiAgfVxuXG4gIC8vIEluc3RhbmNlLWlkIGZvciBHUlVVXG4gIGlmICghc2V0dGluZ3MuaW5zdGFuY2VJZCkge1xuICAgIHNldHRpbmdzLmluc3RhbmNlSWQgPSBTSVAuVXRpbHMubmV3VVVJRCgpO1xuICB9XG5cbiAgLy8gc2lwanNJZCBpbnN0YW5jZSBwYXJhbWV0ZXIuIFN0YXRpYyByYW5kb20gdGFnIG9mIGxlbmd0aCA1XG4gIHNldHRpbmdzLnNpcGpzSWQgPSBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oNSk7XG5cbiAgLy8gU3RyaW5nIGNvbnRhaW5pbmcgc2V0dGluZ3MudXJpIHdpdGhvdXQgc2NoZW1lIGFuZCB1c2VyLlxuICBob3N0cG9ydFBhcmFtcyA9IHNldHRpbmdzLnVyaS5jbG9uZSgpO1xuICBob3N0cG9ydFBhcmFtcy51c2VyID0gbnVsbDtcbiAgc2V0dGluZ3MuaG9zdHBvcnRQYXJhbXMgPSBob3N0cG9ydFBhcmFtcy50b1JhdygpLnJlcGxhY2UoL15zaXA6L2ksICcnKTtcblxuICAvKiBDaGVjayB3aGV0aGVyIGF1dGhvcml6YXRpb25Vc2VyIGlzIGV4cGxpY2l0bHkgZGVmaW5lZC5cbiAgICogVGFrZSAnc2V0dGluZ3MudXJpLnVzZXInIHZhbHVlIGlmIG5vdC5cbiAgICovXG4gIGlmICghc2V0dGluZ3MuYXV0aG9yaXphdGlvblVzZXIpIHtcbiAgICBzZXR0aW5ncy5hdXRob3JpemF0aW9uVXNlciA9IHNldHRpbmdzLnVyaS51c2VyO1xuICB9XG5cbiAgLyogSWYgbm8gJ3JlZ2lzdHJhclNlcnZlcicgaXMgc2V0IHVzZSB0aGUgJ3VyaScgdmFsdWUgd2l0aG91dCB1c2VyIHBvcnRpb24uICovXG4gIGlmICghc2V0dGluZ3MucmVnaXN0cmFyU2VydmVyKSB7XG4gICAgcmVnaXN0cmFyU2VydmVyID0gc2V0dGluZ3MudXJpLmNsb25lKCk7XG4gICAgcmVnaXN0cmFyU2VydmVyLnVzZXIgPSBudWxsO1xuICAgIHNldHRpbmdzLnJlZ2lzdHJhclNlcnZlciA9IHJlZ2lzdHJhclNlcnZlcjtcbiAgfVxuXG4gIC8vIFVzZXIgbm9BbnN3ZXJUaW1lb3V0XG4gIHNldHRpbmdzLm5vQW5zd2VyVGltZW91dCA9IHNldHRpbmdzLm5vQW5zd2VyVGltZW91dCAqIDEwMDA7XG5cbiAgLy8gVmlhIEhvc3RcbiAgaWYgKHNldHRpbmdzLmhhY2tJcEluQ29udGFjdCkge1xuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuaGFja0lwSW5Db250YWN0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHNldHRpbmdzLnZpYUhvc3QgPSBTSVAuVXRpbHMuZ2V0UmFuZG9tVGVzdE5ldElQKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzZXR0aW5ncy5oYWNrSXBJbkNvbnRhY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZXR0aW5ncy52aWFIb3N0ID0gc2V0dGluZ3MuaGFja0lwSW5Db250YWN0O1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbnRhY3QgdHJhbnNwb3J0IHBhcmFtZXRlclxuICBpZiAoc2V0dGluZ3MuaGFja1dzc0luVHJhbnNwb3J0KSB7XG4gICAgc2V0dGluZ3MuY29udGFjdFRyYW5zcG9ydCA9ICd3c3MnO1xuICB9XG5cbiAgdGhpcy5jb250YWN0ID0ge1xuICAgIHB1Yl9ncnV1OiBudWxsLFxuICAgIHRlbXBfZ3J1dTogbnVsbCxcbiAgICB1cmk6IG5ldyBTSVAuVVJJKCdzaXAnLCBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oOCksIHNldHRpbmdzLnZpYUhvc3QsIG51bGwsIHt0cmFuc3BvcnQ6IHNldHRpbmdzLmNvbnRhY3RUcmFuc3BvcnR9KSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyXG4gICAgICAgIGFub255bW91cyA9IG9wdGlvbnMuYW5vbnltb3VzIHx8IG51bGwsXG4gICAgICAgIG91dGJvdW5kID0gb3B0aW9ucy5vdXRib3VuZCB8fCBudWxsLFxuICAgICAgICBjb250YWN0ID0gJzwnO1xuXG4gICAgICBpZiAoYW5vbnltb3VzKSB7XG4gICAgICAgIGNvbnRhY3QgKz0gKHRoaXMudGVtcF9ncnV1IHx8ICgnc2lwOmFub255bW91c0Bhbm9ueW1vdXMuaW52YWxpZDt0cmFuc3BvcnQ9JytzZXR0aW5ncy5jb250YWN0VHJhbnNwb3J0KSkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhY3QgKz0gKHRoaXMucHViX2dydXUgfHwgdGhpcy51cmkpLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdXRib3VuZCkge1xuICAgICAgICBjb250YWN0ICs9ICc7b2InO1xuICAgICAgfVxuXG4gICAgICBjb250YWN0ICs9ICc+JztcblxuICAgICAgcmV0dXJuIGNvbnRhY3Q7XG4gICAgfVxuICB9O1xuXG4gIC8vIG1lZGlhIG92ZXJyaWRlcyBtZWRpYUNvbnN0cmFpbnRzXG4gIFNJUC5VdGlscy5vcHRpb25zT3ZlcnJpZGUoc2V0dGluZ3MsICdtZWRpYScsICdtZWRpYUNvbnN0cmFpbnRzJywgdHJ1ZSwgdGhpcy5sb2dnZXIpO1xuXG4gIC8vIEZpbGwgdGhlIHZhbHVlIG9mIHRoZSBjb25maWd1cmF0aW9uX3NrZWxldG9uXG4gIGZvcihwYXJhbWV0ZXIgaW4gc2V0dGluZ3MpIHtcbiAgICBVQS5jb25maWd1cmF0aW9uX3NrZWxldG9uW3BhcmFtZXRlcl0udmFsdWUgPSBzZXR0aW5nc1twYXJhbWV0ZXJdO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5jb25maWd1cmF0aW9uLCBVQS5jb25maWd1cmF0aW9uX3NrZWxldG9uKTtcblxuICAvLyBDbGVhbiBVQS5jb25maWd1cmF0aW9uX3NrZWxldG9uXG4gIGZvcihwYXJhbWV0ZXIgaW4gc2V0dGluZ3MpIHtcbiAgICBVQS5jb25maWd1cmF0aW9uX3NrZWxldG9uW3BhcmFtZXRlcl0udmFsdWUgPSAnJztcbiAgfVxuXG4gIHRoaXMubG9nZ2VyLmxvZygnY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGFmdGVyIHZhbGlkYXRpb246Jyk7XG4gIGZvcihwYXJhbWV0ZXIgaW4gc2V0dGluZ3MpIHtcbiAgICBzd2l0Y2gocGFyYW1ldGVyKSB7XG4gICAgICBjYXNlICd1cmknOlxuICAgICAgY2FzZSAncmVnaXN0cmFyU2VydmVyJzpcbiAgICAgIGNhc2UgJ21lZGlhSGFuZGxlckZhY3RvcnknOlxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ8K3ICcgKyBwYXJhbWV0ZXIgKyAnOiAnICsgc2V0dGluZ3NbcGFyYW1ldGVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGFzc3dvcmQnOlxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ8K3ICcgKyBwYXJhbWV0ZXIgKyAnOiAnICsgJ05PVCBTSE9XTicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnwrcgJyArIHBhcmFtZXRlciArICc6ICcgKyBKU09OLnN0cmluZ2lmeShzZXR0aW5nc1twYXJhbWV0ZXJdKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIE9iamVjdCBza2VsZXRvbi5cbiAqIEBwcml2YXRlXG4gKi9cblVBLmNvbmZpZ3VyYXRpb25fc2tlbGV0b24gPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBpZHgsICBwYXJhbWV0ZXIsXG4gICAgc2tlbGV0b24gPSB7fSxcbiAgICBwYXJhbWV0ZXJzID0gW1xuICAgICAgLy8gSW50ZXJuYWwgcGFyYW1ldGVyc1xuICAgICAgXCJzaXBqc0lkXCIsXG4gICAgICBcImhvc3Rwb3J0UGFyYW1zXCIsXG5cbiAgICAgIC8vIE9wdGlvbmFsIHVzZXIgY29uZmlndXJhYmxlIHBhcmFtZXRlcnNcbiAgICAgIFwidXJpXCIsXG4gICAgICBcIndzU2VydmVyc1wiLFxuICAgICAgXCJhdXRob3JpemF0aW9uVXNlclwiLFxuICAgICAgXCJjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbFwiLFxuICAgICAgXCJjb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbFwiLFxuICAgICAgXCJrZWVwQWxpdmVJbnRlcnZhbFwiLFxuICAgICAgXCJleHRyYVN1cHBvcnRlZFwiLFxuICAgICAgXCJkaXNwbGF5TmFtZVwiLFxuICAgICAgXCJoYWNrVmlhVGNwXCIsIC8vIGZhbHNlLlxuICAgICAgXCJoYWNrSXBJbkNvbnRhY3RcIiwgLy9mYWxzZVxuICAgICAgXCJoYWNrV3NzSW5UcmFuc3BvcnRcIiwgLy9mYWxzZVxuICAgICAgXCJoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzXCIsIC8vZmFsc2VcbiAgICAgIFwiY29udGFjdFRyYW5zcG9ydFwiLCAvLyAnd3MnXG4gICAgICBcImZvcmNlUnBvcnRcIiwgLy8gZmFsc2VcbiAgICAgIFwiaWNlQ2hlY2tpbmdUaW1lb3V0XCIsXG4gICAgICBcImluc3RhbmNlSWRcIixcbiAgICAgIFwibm9BbnN3ZXJUaW1lb3V0XCIsIC8vIDMwIHNlY29uZHMuXG4gICAgICBcInBhc3N3b3JkXCIsXG4gICAgICBcInJlZ2lzdGVyRXhwaXJlc1wiLCAvLyA2MDAgc2Vjb25kcy5cbiAgICAgIFwicmVnaXN0cmFyU2VydmVyXCIsXG4gICAgICBcInJlbGlhYmxlXCIsXG4gICAgICBcInJlbDEwMFwiLFxuICAgICAgXCJyZXBsYWNlc1wiLFxuICAgICAgXCJ1c2VyQWdlbnRTdHJpbmdcIiwgLy9TSVAuQy5VU0VSX0FHRU5UXG4gICAgICBcImF1dG9zdGFydFwiLFxuICAgICAgXCJzdHVuU2VydmVyc1wiLFxuICAgICAgXCJ0cmFjZVNpcFwiLFxuICAgICAgXCJ0dXJuU2VydmVyc1wiLFxuICAgICAgXCJ1c2VQcmVsb2FkZWRSb3V0ZVwiLFxuICAgICAgXCJ3c1NlcnZlck1heFJlY29ubmVjdGlvblwiLFxuICAgICAgXCJ3c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXRcIixcbiAgICAgIFwibWVkaWFIYW5kbGVyRmFjdG9yeVwiLFxuICAgICAgXCJtZWRpYVwiLFxuICAgICAgXCJtZWRpYUNvbnN0cmFpbnRzXCIsXG4gICAgICBcImF1dGhlbnRpY2F0aW9uRmFjdG9yeVwiLFxuXG4gICAgICAvLyBQb3N0LWNvbmZpZ3VyYXRpb24gZ2VuZXJhdGVkIHBhcmFtZXRlcnNcbiAgICAgIFwidmlhX2NvcmVfdmFsdWVcIixcbiAgICAgIFwidmlhSG9zdFwiXG4gICAgXTtcblxuICBmb3IoaWR4IGluIHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzW2lkeF07XG4gICAgc2tlbGV0b25bcGFyYW1ldGVyXSA9IHtcbiAgICAgIHZhbHVlOiAnJyxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgc2tlbGV0b25bJ3JlZ2lzdGVyJ10gPSB7XG4gICAgdmFsdWU6ICcnLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfTtcblxuICByZXR1cm4gc2tlbGV0b247XG59KCkpO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gY2hlY2tlci5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5VQS5jb25maWd1cmF0aW9uX2NoZWNrID0ge1xuICBtYW5kYXRvcnk6IHtcbiAgfSxcblxuICBvcHRpb25hbDoge1xuXG4gICAgdXJpOiBmdW5jdGlvbih1cmkpIHtcbiAgICAgIHZhciBwYXJzZWQ7XG5cbiAgICAgIGlmICghKC9ec2lwOi9pKS50ZXN0KHVyaSkpIHtcbiAgICAgICAgdXJpID0gU0lQLkMuU0lQICsgJzonICsgdXJpO1xuICAgICAgfVxuICAgICAgcGFyc2VkID0gU0lQLlVSSS5wYXJzZSh1cmkpO1xuXG4gICAgICBpZighcGFyc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZighcGFyc2VkLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy9Ob3RlOiB0aGlzIGZ1bmN0aW9uIHVzZWQgdG8gY2FsbCAndGhpcy5sb2dnZXIuZXJyb3InIGJ1dCBjYWxsaW5nICd0aGlzJyB3aXRoIGFueXRoaW5nIGhlcmUgaXMgaW52YWxpZFxuICAgIHdzU2VydmVyczogZnVuY3Rpb24od3NTZXJ2ZXJzKSB7XG4gICAgICB2YXIgaWR4LCBsZW5ndGgsIHVybDtcblxuICAgICAgLyogQWxsb3cgZGVmaW5pbmcgd3NTZXJ2ZXJzIHBhcmFtZXRlciBhczpcbiAgICAgICAqICBTdHJpbmc6IFwiaG9zdFwiXG4gICAgICAgKiAgQXJyYXkgb2YgU3RyaW5nczogW1wiaG9zdDFcIiwgXCJob3N0MlwiXVxuICAgICAgICogIEFycmF5IG9mIE9iamVjdHM6IFt7d3NfdXJpOlwiaG9zdDFcIiwgd2VpZ2h0OjF9LCB7d3NfdXJpOlwiaG9zdDJcIiwgd2VpZ2h0OjB9XVxuICAgICAgICogIEFycmF5IG9mIE9iamVjdHMgYW5kIFN0cmluZ3M6IFt7d3NfdXJpOlwiaG9zdDFcIn0sIFwiaG9zdDJcIl1cbiAgICAgICAqL1xuICAgICAgaWYgKHR5cGVvZiB3c1NlcnZlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHdzU2VydmVycyA9IFt7d3NfdXJpOiB3c1NlcnZlcnN9XTtcbiAgICAgIH0gZWxzZSBpZiAod3NTZXJ2ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgbGVuZ3RoID0gd3NTZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3c1NlcnZlcnNbaWR4XSA9PT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgd3NTZXJ2ZXJzW2lkeF0gPSB7d3NfdXJpOiB3c1NlcnZlcnNbaWR4XX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh3c1NlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoID0gd3NTZXJ2ZXJzLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAoIXdzU2VydmVyc1tpZHhdLndzX3VyaSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3NTZXJ2ZXJzW2lkeF0ud2VpZ2h0ICYmICFOdW1iZXIod3NTZXJ2ZXJzW2lkeF0ud2VpZ2h0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybCA9IFNJUC5HcmFtbWFyLnBhcnNlKHdzU2VydmVyc1tpZHhdLndzX3VyaSwgJ2Fic29sdXRlVVJJJyk7XG5cbiAgICAgICAgaWYodXJsID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmKFsnd3NzJywgJ3dzJywgJ3VkcCddLmluZGV4T2YodXJsLnNjaGVtZSkgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdzU2VydmVyc1tpZHhdLnNpcF91cmkgPSAnPHNpcDonICsgdXJsLmhvc3QgKyAodXJsLnBvcnQgPyAnOicgKyB1cmwucG9ydCA6ICcnKSArICc7dHJhbnNwb3J0PScgKyB1cmwuc2NoZW1lLnJlcGxhY2UoL153c3MkL2ksICd3cycpICsgJztscj4nO1xuXG4gICAgICAgICAgaWYgKCF3c1NlcnZlcnNbaWR4XS53ZWlnaHQpIHtcbiAgICAgICAgICAgIHdzU2VydmVyc1tpZHhdLndlaWdodCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd3NTZXJ2ZXJzW2lkeF0uc3RhdHVzID0gMDtcbiAgICAgICAgICB3c1NlcnZlcnNbaWR4XS5zY2hlbWUgPSB1cmwuc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB3c1NlcnZlcnM7XG4gICAgfSxcblxuICAgIGF1dGhvcml6YXRpb25Vc2VyOiBmdW5jdGlvbihhdXRob3JpemF0aW9uVXNlcikge1xuICAgICAgaWYoU0lQLkdyYW1tYXIucGFyc2UoJ1wiJysgYXV0aG9yaXphdGlvblVzZXIgKydcIicsICdxdW90ZWRfc3RyaW5nJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhdXRob3JpemF0aW9uVXNlcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWw6IGZ1bmN0aW9uKGNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZihTSVAuVXRpbHMuaXNEZWNpbWFsKGNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsKSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcihjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCk7XG4gICAgICAgIGlmKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbDogZnVuY3Rpb24oY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmKFNJUC5VdGlscy5pc0RlY2ltYWwoY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWwpKSB7XG4gICAgICAgIHZhbHVlID0gTnVtYmVyKGNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsKTtcbiAgICAgICAgaWYodmFsdWUgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRpc3BsYXlOYW1lOiBmdW5jdGlvbihkaXNwbGF5TmFtZSkge1xuICAgICAgaWYoU0lQLkdyYW1tYXIucGFyc2UoJ1wiJyArIGRpc3BsYXlOYW1lICsgJ1wiJywgJ2Rpc3BsYXlOYW1lJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFja1ZpYVRjcDogZnVuY3Rpb24oaGFja1ZpYVRjcCkge1xuICAgICAgaWYgKHR5cGVvZiBoYWNrVmlhVGNwID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGhhY2tWaWFUY3A7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhY2tJcEluQ29udGFjdDogZnVuY3Rpb24oaGFja0lwSW5Db250YWN0KSB7XG4gICAgICBpZiAodHlwZW9mIGhhY2tJcEluQ29udGFjdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBoYWNrSXBJbkNvbnRhY3Q7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgaGFja0lwSW5Db250YWN0ID09PSAnc3RyaW5nJyAmJiBTSVAuR3JhbW1hci5wYXJzZShoYWNrSXBJbkNvbnRhY3QsICdob3N0JykgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBoYWNrSXBJbkNvbnRhY3Q7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGljZUNoZWNraW5nVGltZW91dDogZnVuY3Rpb24oaWNlQ2hlY2tpbmdUaW1lb3V0KSB7XG4gICAgICBpZihTSVAuVXRpbHMuaXNEZWNpbWFsKGljZUNoZWNraW5nVGltZW91dCkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDUwMCwgaWNlQ2hlY2tpbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFja1dzc0luVHJhbnNwb3J0OiBmdW5jdGlvbihoYWNrV3NzSW5UcmFuc3BvcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFja1dzc0luVHJhbnNwb3J0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGhhY2tXc3NJblRyYW5zcG9ydDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFnczogZnVuY3Rpb24oaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncykge1xuICAgICAgaWYgKHR5cGVvZiBoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbnRhY3RUcmFuc3BvcnQ6IGZ1bmN0aW9uKGNvbnRhY3RUcmFuc3BvcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29udGFjdFRyYW5zcG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhY3RUcmFuc3BvcnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZvcmNlUnBvcnQ6IGZ1bmN0aW9uKGZvcmNlUnBvcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZm9yY2VScG9ydCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBmb3JjZVJwb3J0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbnN0YW5jZUlkOiBmdW5jdGlvbihpbnN0YW5jZUlkKSB7XG4gICAgICBpZih0eXBlb2YgaW5zdGFuY2VJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoKC9edXVpZDovaS50ZXN0KGluc3RhbmNlSWQpKSkge1xuICAgICAgICBpbnN0YW5jZUlkID0gaW5zdGFuY2VJZC5zdWJzdHIoNSk7XG4gICAgICB9XG5cbiAgICAgIGlmKFNJUC5HcmFtbWFyLnBhcnNlKGluc3RhbmNlSWQsICd1dWlkJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZUlkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBrZWVwQWxpdmVJbnRlcnZhbDogZnVuY3Rpb24oa2VlcEFsaXZlSW50ZXJ2YWwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChTSVAuVXRpbHMuaXNEZWNpbWFsKGtlZXBBbGl2ZUludGVydmFsKSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcihrZWVwQWxpdmVJbnRlcnZhbCk7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZXh0cmFTdXBwb3J0ZWQ6IGZ1bmN0aW9uKG9wdGlvblRhZ3MpIHtcbiAgICAgIHZhciBpZHgsIGxlbmd0aDtcblxuICAgICAgaWYgKCEob3B0aW9uVGFncyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IG9wdGlvblRhZ3MubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uVGFnc1tpZHhdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9uVGFncztcbiAgICB9LFxuXG4gICAgbm9BbnN3ZXJUaW1lb3V0OiBmdW5jdGlvbihub0Fuc3dlclRpbWVvdXQpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChTSVAuVXRpbHMuaXNEZWNpbWFsKG5vQW5zd2VyVGltZW91dCkpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIobm9BbnN3ZXJUaW1lb3V0KTtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXNzd29yZDogZnVuY3Rpb24ocGFzc3dvcmQpIHtcbiAgICAgIHJldHVybiBTdHJpbmcocGFzc3dvcmQpO1xuICAgIH0sXG5cbiAgICByZWwxMDA6IGZ1bmN0aW9uKHJlbDEwMCkge1xuICAgICAgaWYocmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRDtcbiAgICAgIH0gZWxzZSBpZiAocmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgICAgIHJldHVybiBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEO1xuICAgICAgfSBlbHNlICB7XG4gICAgICAgIHJldHVybiBTSVAuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlcGxhY2VzOiBmdW5jdGlvbihyZXBsYWNlcykge1xuICAgICAgaWYocmVwbGFjZXMgPT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgICAgICByZXR1cm4gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEO1xuICAgICAgfSBlbHNlIGlmIChyZXBsYWNlcyA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCkge1xuICAgICAgICByZXR1cm4gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRDtcbiAgICAgIH0gZWxzZSAge1xuICAgICAgICByZXR1cm4gU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZWdpc3RlcjogZnVuY3Rpb24ocmVnaXN0ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVnaXN0ZXIgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyRXhwaXJlczogZnVuY3Rpb24ocmVnaXN0ZXJFeHBpcmVzKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAoU0lQLlV0aWxzLmlzRGVjaW1hbChyZWdpc3RlckV4cGlyZXMpKSB7XG4gICAgICAgIHZhbHVlID0gTnVtYmVyKHJlZ2lzdGVyRXhwaXJlcyk7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVnaXN0cmFyU2VydmVyOiBmdW5jdGlvbihyZWdpc3RyYXJTZXJ2ZXIpIHtcbiAgICAgIHZhciBwYXJzZWQ7XG5cbiAgICAgIGlmKHR5cGVvZiByZWdpc3RyYXJTZXJ2ZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCEvXnNpcDovaS50ZXN0KHJlZ2lzdHJhclNlcnZlcikpIHtcbiAgICAgICAgcmVnaXN0cmFyU2VydmVyID0gU0lQLkMuU0lQICsgJzonICsgcmVnaXN0cmFyU2VydmVyO1xuICAgICAgfVxuICAgICAgcGFyc2VkID0gU0lQLlVSSS5wYXJzZShyZWdpc3RyYXJTZXJ2ZXIpO1xuXG4gICAgICBpZighcGFyc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZihwYXJzZWQudXNlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdHVuU2VydmVyczogZnVuY3Rpb24oc3R1blNlcnZlcnMpIHtcbiAgICAgIHZhciBpZHgsIGxlbmd0aCwgc3R1bl9zZXJ2ZXI7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3R1blNlcnZlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0dW5TZXJ2ZXJzID0gW3N0dW5TZXJ2ZXJzXTtcbiAgICAgIH0gZWxzZSBpZiAoIShzdHVuU2VydmVycyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IHN0dW5TZXJ2ZXJzLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBzdHVuX3NlcnZlciA9IHN0dW5TZXJ2ZXJzW2lkeF07XG4gICAgICAgIGlmICghKC9ec3R1bnM/Oi8udGVzdChzdHVuX3NlcnZlcikpKSB7XG4gICAgICAgICAgc3R1bl9zZXJ2ZXIgPSAnc3R1bjonICsgc3R1bl9zZXJ2ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZihTSVAuR3JhbW1hci5wYXJzZShzdHVuX3NlcnZlciwgJ3N0dW5fVVJJJykgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0dW5TZXJ2ZXJzW2lkeF0gPSBzdHVuX3NlcnZlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0dW5TZXJ2ZXJzO1xuICAgIH0sXG5cbiAgICB0cmFjZVNpcDogZnVuY3Rpb24odHJhY2VTaXApIHtcbiAgICAgIGlmICh0eXBlb2YgdHJhY2VTaXAgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gdHJhY2VTaXA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHR1cm5TZXJ2ZXJzOiBmdW5jdGlvbih0dXJuU2VydmVycykge1xuICAgICAgdmFyIGlkeCwgamR4LCBsZW5ndGgsIHR1cm5fc2VydmVyLCBudW1fdHVybl9zZXJ2ZXJfdXJscywgdXJsO1xuXG4gICAgICBpZiAodHVyblNlcnZlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0dXJuU2VydmVycyA9IFt0dXJuU2VydmVyc107XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IHR1cm5TZXJ2ZXJzLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB0dXJuX3NlcnZlciA9IHR1cm5TZXJ2ZXJzW2lkeF07XG4gICAgICAgIC8vQmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IEFsbG93IGRlZmluaW5nIHRoZSB0dXJuX3NlcnZlciB1cmwgd2l0aCB0aGUgJ3NlcnZlcicgcHJvcGVydHkuXG4gICAgICAgIGlmICh0dXJuX3NlcnZlci5zZXJ2ZXIpIHtcbiAgICAgICAgICB0dXJuX3NlcnZlci51cmxzID0gW3R1cm5fc2VydmVyLnNlcnZlcl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXR1cm5fc2VydmVyLnVybHMgfHwgIXR1cm5fc2VydmVyLnVzZXJuYW1lIHx8ICF0dXJuX3NlcnZlci5wYXNzd29yZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0dXJuX3NlcnZlci51cmxzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBudW1fdHVybl9zZXJ2ZXJfdXJscyA9IHR1cm5fc2VydmVyLnVybHMubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR1cm5fc2VydmVyLnVybHMgPSBbdHVybl9zZXJ2ZXIudXJsc107XG4gICAgICAgICAgbnVtX3R1cm5fc2VydmVyX3VybHMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqZHggPSAwOyBqZHggPCBudW1fdHVybl9zZXJ2ZXJfdXJsczsgamR4KyspIHtcbiAgICAgICAgICB1cmwgPSB0dXJuX3NlcnZlci51cmxzW2pkeF07XG5cbiAgICAgICAgICBpZiAoISgvXnR1cm5zPzovLnRlc3QodXJsKSkpIHtcbiAgICAgICAgICAgIHVybCA9ICd0dXJuOicgKyB1cmw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoU0lQLkdyYW1tYXIucGFyc2UodXJsLCAndHVybl9VUkknKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0dXJuU2VydmVycztcbiAgICB9LFxuXG4gICAgdXNlckFnZW50U3RyaW5nOiBmdW5jdGlvbih1c2VyQWdlbnRTdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2YgdXNlckFnZW50U3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdXNlckFnZW50U3RyaW5nO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1c2VQcmVsb2FkZWRSb3V0ZTogZnVuY3Rpb24odXNlUHJlbG9hZGVkUm91dGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdXNlUHJlbG9hZGVkUm91dGUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gdXNlUHJlbG9hZGVkUm91dGU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHdzU2VydmVyTWF4UmVjb25uZWN0aW9uOiBmdW5jdGlvbih3c1NlcnZlck1heFJlY29ubmVjdGlvbikge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKFNJUC5VdGlscy5pc0RlY2ltYWwod3NTZXJ2ZXJNYXhSZWNvbm5lY3Rpb24pKSB7XG4gICAgICAgIHZhbHVlID0gTnVtYmVyKHdzU2VydmVyTWF4UmVjb25uZWN0aW9uKTtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB3c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXQ6IGZ1bmN0aW9uKHdzU2VydmVyUmVjb25uZWN0aW9uVGltZW91dCkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKFNJUC5VdGlscy5pc0RlY2ltYWwod3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0KSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcih3c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGF1dG9zdGFydDogZnVuY3Rpb24oYXV0b3N0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGF1dG9zdGFydCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBhdXRvc3RhcnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG1lZGlhSGFuZGxlckZhY3Rvcnk6IGZ1bmN0aW9uKG1lZGlhSGFuZGxlckZhY3RvcnkpIHtcbiAgICAgIGlmIChtZWRpYUhhbmRsZXJGYWN0b3J5IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHByb21pc2lmaWVkRmFjdG9yeSA9IGZ1bmN0aW9uIHByb21pc2lmaWVkRmFjdG9yeSAoKSB7XG4gICAgICAgICAgdmFyIG1lZGlhSGFuZGxlciA9IG1lZGlhSGFuZGxlckZhY3RvcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHBhdGNoTWV0aG9kIChtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gbWVkaWFIYW5kbGVyW21ldGhvZE5hbWVdO1xuICAgICAgICAgICAgaWYgKG1ldGhvZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHZhciBjYWxsYmFja3NGaXJzdCA9IG1ldGhvZE5hbWUgPT09ICdnZXREZXNjcmlwdGlvbic7XG4gICAgICAgICAgICAgIG1lZGlhSGFuZGxlclttZXRob2ROYW1lXSA9IFNJUC5VdGlscy5wcm9taXNpZnkobWVkaWFIYW5kbGVyLCBtZXRob2ROYW1lLCBjYWxsYmFja3NGaXJzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0Y2hNZXRob2QoJ2dldERlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgcGF0Y2hNZXRob2QoJ3NldERlc2NyaXB0aW9uJyk7XG5cbiAgICAgICAgICByZXR1cm4gbWVkaWFIYW5kbGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHByb21pc2lmaWVkRmFjdG9yeS5pc1N1cHBvcnRlZCA9IG1lZGlhSGFuZGxlckZhY3RvcnkuaXNTdXBwb3J0ZWQ7XG4gICAgICAgIHJldHVybiBwcm9taXNpZmllZEZhY3Rvcnk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGF1dGhlbnRpY2F0aW9uRmFjdG9yeTogY2hlY2tBdXRoZW50aWNhdGlvbkZhY3RvcnlcbiAgfVxufTtcblxuVUEuQyA9IEM7XG5TSVAuVUEgPSBVQTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1VBLmpzXG4gKiogbW9kdWxlIGlkID0gMjM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBIYWNrcyAtIFRoaXMgZmlsZSBjb250YWlucyBhbGwgb2YgdGhlIHRoaW5ncyB3ZVxuICogd2lzaCB3ZSBkaWRuJ3QgaGF2ZSB0byBkbywganVzdCBmb3IgaW50ZXJvcC4gIEl0IGlzIHNpbWlsYXIgdG9cbiAqIFV0aWxzLCB3aGljaCBwcm92aWRlcyBhY3R1YWxseSB1c2VmdWwgYW5kIHJlbGV2YW50IGZ1bmN0aW9ucyBmb3JcbiAqIGEgU0lQIGxpYnJhcnkuIE1ldGhvZHMgaW4gdGhpcyBmaWxlIGFyZSBncm91cGVkIGJ5IHZlbmRvciwgc29cbiAqIGFzIHRvIG1vc3QgZWFzaWx5IHRyYWNrIHdoZW4gcGFydGljdWxhciBoYWNrcyBtYXkgbm90IGJlIG5lY2Vzc2FyeSBhbnltb3JlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuXG4vL2tlZXAgdG8gcXVpZXQganNoaW50LCBhbmQgcmVtYWluIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBmaWxlc1xuU0lQID0gU0lQO1xuXG52YXIgSGFja3MgPSB7XG4gIEFsbEJyb3dzZXJzOiB7XG4gICAgbWFza0R0bHM6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAobWVzc2FnZS5ib2R5KSB7XG4gICAgICAgIG1lc3NhZ2UuYm9keSA9IG1lc3NhZ2UuYm9keS5yZXBsYWNlKC8gVURQXFwvVExTXFwvUlRQXFwvU0FWUC9nbWksIFwiIFJUUC9TQVZQXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdW5tYXNrRHRsczogZnVuY3Rpb24gKHNkcCkge1xuICAgICAgLyoqXG4gICAgICAgKiBDaHJvbWUgZG9lcyBub3QgaGFuZGxlIERUTFMgY29ycmVjdGx5IChDYW5hcmF5IGRvZXMsIGJ1dCBub3QgcHJvZHVjdGlvbilcbiAgICAgICAqIGtlZXBpbmcgQ2hyb21lIGFzIFNERVMgdW50aWwgRFRMUyBpcyBmaXhlZCAoY29tbWVudCBvdXQgJ2lzX29wZXJhJyBjb25kaXRpb24pXG4gICAgICAgKlxuICAgICAgICogVVBEQVRFOiBNYXkgMjEsIDIwMTRcbiAgICAgICAqIENocm9tZSAzNSBub3cgcHJvcGVybHkgZGVmYXVsdHMgdG8gRFRMUy4gIE9ubHkgT3BlcmEgcmVtYWlucyB1c2luZyBTREVTXG4gICAgICAgKlxuICAgICAgICogVVBEQVRFOiAyMDE0LTA5LTI0XG4gICAgICAgKiBPcGVyYSBub3cgc3VwcG9ydHMgRFRMUyBieSBkZWZhdWx0IGFzIHdlbGwuXG4gICAgICAgKlxuICAgICAgICoqL1xuICAgICAgcmV0dXJuIHNkcC5yZXBsYWNlKC8gUlRQXFwvU0FWUC9nbWksIFwiIFVEUC9UTFMvUlRQL1NBVlBcIik7XG4gICAgfVxuICB9LFxuICBGaXJlZm94OiB7XG4gICAgLyogQ29uZGl0aW9uIHRvIGRldGVjdCBpZiBoYWNrcyBhcmUgYXBwbGljYWJsZSAqL1xuICAgIGlzRmlyZWZveDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBtb3pSVENQZWVyQ29ubmVjdGlvbiAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfSxcblxuICAgIGNhbm5vdEhhbmRsZUV4dHJhV2hpdGVzcGFjZTogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0aGlzLmlzRmlyZWZveCgpICYmIG1lc3NhZ2UuYm9keSkge1xuICAgICAgICBtZXNzYWdlLmJvZHkgPSBtZXNzYWdlLmJvZHkucmVwbGFjZSgvIFxcclxcbi9nLCBcIlxcclxcblwiKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFzTWlzc2luZ0NMaW5lSW5TRFA6IGZ1bmN0aW9uIChzZHApIHtcbiAgICAgIC8qXG4gICAgICAgKiBUaGlzIGlzIGEgRmlyZWZveCBoYWNrIHRvIGluc2VydCB2YWxpZCBzZHAgd2hlbiBnZXREZXNjcmlwdGlvbiBpc1xuICAgICAgICogY2FsbGVkIHdpdGggdGhlIGNvbnN0cmFpbnQgb2ZmZXJUb1JlY2VpdmVWaWRlbyA9IGZhbHNlLlxuICAgICAgICogV2Ugc2VhcmNoIGZvciBlaXRoZXIgYSBjLWxpbmUgYXQgdGhlIHRvcCBvZiB0aGUgc2RwIGFib3ZlIGFsbFxuICAgICAgICogbS1saW5lcy4gSWYgdGhhdCBkb2VzIG5vdCBleGlzdCB0aGVuIHdlIHNlYXJjaCBmb3IgYSBjLWxpbmVcbiAgICAgICAqIGJlbmVhdGggZWFjaCBtLWxpbmUuIElmIGl0IGlzIG1pc3NpbmcgYSBjLWxpbmUsIHdlIGluc2VydFxuICAgICAgICogYSBmYWtlIGMtbGluZSB3aXRoIHRoZSBpcCBhZGRyZXNzIDAuMC4wLjAuIFRoaXMgaXMgdGhlbiB2YWxpZFxuICAgICAgICogc2RwIGFuZCBubyBtZWRpYSB3aWxsIGJlIHNlbnQgZm9yIHRoYXQgbS1saW5lLlxuICAgICAgICpcbiAgICAgICAqIFZhbGlkIFNEUCBpczpcbiAgICAgICAqIG09XG4gICAgICAgKiBpPVxuICAgICAgICogYz1cbiAgICAgICAqL1xuICAgICAgdmFyIGluc2VydEF0LCBtbGluZXM7XG4gICAgICBpZiAoc2RwLmluZGV4T2YoJ2M9JykgPiBzZHAuaW5kZXhPZignbT0nKSkge1xuXG4gICAgICAgIC8vIEZpbmQgYWxsIG09IGxpbmVzXG4gICAgICAgIG1saW5lcyA9IHNkcC5tYXRjaCgvbT0uKlxcclxcbi4qL2cpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8bWxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAvLyBJZiBpdCBoYXMgYW4gaT0gbGluZSwgY2hlY2sgaWYgdGhlIG5leHQgbGluZSBpcyB0aGUgYz0gbGluZVxuICAgICAgICAgIGlmIChtbGluZXNbaV0udG9TdHJpbmcoKS5zZWFyY2goL2k9LiovKSA+PSAwKSB7XG4gICAgICAgICAgICBpbnNlcnRBdCA9IHNkcC5pbmRleE9mKG1saW5lc1tpXS50b1N0cmluZygpKSttbGluZXNbaV0udG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc2RwLnN1YnN0cihpbnNlcnRBdCwyKSE9PSdjPScpIHtcbiAgICAgICAgICAgICAgc2RwID0gc2RwLnN1YnN0cigwLGluc2VydEF0KSArICdcXHJcXG5jPUlOIElQNCAwLjAuMC4wJyArIHNkcC5zdWJzdHIoaW5zZXJ0QXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZWxzZSBhZGQgdGhlIEMgbGluZSBpZiBpdCdzIG1pc3NpbmdcbiAgICAgICAgICB9IGVsc2UgaWYgKG1saW5lc1tpXS50b1N0cmluZygpLnNlYXJjaCgvYz0uKi8pIDwgMCkge1xuICAgICAgICAgICAgaW5zZXJ0QXQgPSBzZHAuaW5kZXhPZihtbGluZXNbaV0udG9TdHJpbmcoKS5tYXRjaCgvLiovKSkrbWxpbmVzW2ldLnRvU3RyaW5nKCkubWF0Y2goLy4qLykudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICBzZHAgPSBzZHAuc3Vic3RyKDAsaW5zZXJ0QXQpICsgJ1xcclxcbmM9SU4gSVA0IDAuMC4wLjAnICsgc2RwLnN1YnN0cihpbnNlcnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2RwO1xuICAgIH0sXG4gIH0sXG5cbiAgQ2hyb21lOiB7XG4gICAgbmVlZHNFeHBsaWNpdGx5SW5hY3RpdmVTRFA6IGZ1bmN0aW9uIChzZHApIHtcbiAgICAgIHZhciBzdWIsIGluZGV4O1xuXG4gICAgICBpZiAoSGFja3MuRmlyZWZveC5pc0ZpcmVmb3goKSkgeyAvLyBGaXggdGhpcyBpbiBGaXJlZm94IGJlZm9yZSBzZW5kaW5nXG4gICAgICAgIGluZGV4ID0gc2RwLmluZGV4T2YoJ209dmlkZW8gMCcpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgc3ViID0gc2RwLnN1YnN0cihpbmRleCk7XG4gICAgICAgICAgc3ViID0gc3ViLnJlcGxhY2UoL1xcclxcbmM9SU4gSVA0LipcXHJcXG4kLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxyXFxuYz1JTiBJUDQgMC4wLjAuMFxcclxcbmE9aW5hY3RpdmVcXHJcXG4nKTtcbiAgICAgICAgICByZXR1cm4gc2RwLnN1YnN0cigwLCBpbmRleCkgKyBzdWI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZHA7XG4gICAgfSxcblxuICAgIGdldHNDb25mdXNlZEFib3V0R1VNOiBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgaWYgKHNlc3Npb24ubWVkaWFIYW5kbGVyKSB7XG4gICAgICAgIHNlc3Npb24ubWVkaWFIYW5kbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xucmV0dXJuIEhhY2tzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0hhY2tzLmpzXG4gKiogbW9kdWxlIGlkID0gMjQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBJbmNvbWluZyBTSVAgTWVzc2FnZSBTYW5pdHkgQ2hlY2tcbiAqL1xuXG4vKipcbiAqIFNJUCBtZXNzYWdlIHNhbml0eSBjaGVjay5cbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTSVAuSW5jb21pbmdNZXNzYWdlfSBtZXNzYWdlXG4gKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgc2FuaXR5Q2hlY2ssXG4gbG9nZ2VyLFxuIG1lc3NhZ2UsIHVhLCB0cmFuc3BvcnQsXG4gcmVxdWVzdHMgPSBbXSxcbiByZXNwb25zZXMgPSBbXSxcbiBhbGwgPSBbXTtcblxuLy8gUmVwbHlcbmZ1bmN0aW9uIHJlcGx5KHN0YXR1c19jb2RlKSB7XG4gIHZhciB0byxcbiAgICByZXNwb25zZSA9IFNJUC5VdGlscy5idWlsZFN0YXR1c0xpbmUoc3RhdHVzX2NvZGUpLFxuICAgIHZpYXMgPSBtZXNzYWdlLmdldEhlYWRlcnMoJ3ZpYScpLFxuICAgIGxlbmd0aCA9IHZpYXMubGVuZ3RoLFxuICAgIGlkeCA9IDA7XG5cbiAgZm9yKGlkeDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgIHJlc3BvbnNlICs9IFwiVmlhOiBcIiArIHZpYXNbaWR4XSArIFwiXFxyXFxuXCI7XG4gIH1cblxuICB0byA9IG1lc3NhZ2UuZ2V0SGVhZGVyKCdUbycpO1xuXG4gIGlmKCFtZXNzYWdlLnRvX3RhZykge1xuICAgIHRvICs9ICc7dGFnPScgKyBTSVAuVXRpbHMubmV3VGFnKCk7XG4gIH1cblxuICByZXNwb25zZSArPSBcIlRvOiBcIiArIHRvICsgXCJcXHJcXG5cIjtcbiAgcmVzcG9uc2UgKz0gXCJGcm9tOiBcIiArIG1lc3NhZ2UuZ2V0SGVhZGVyKCdGcm9tJykgKyBcIlxcclxcblwiO1xuICByZXNwb25zZSArPSBcIkNhbGwtSUQ6IFwiICsgbWVzc2FnZS5jYWxsX2lkICsgXCJcXHJcXG5cIjtcbiAgcmVzcG9uc2UgKz0gXCJDU2VxOiBcIiArIG1lc3NhZ2UuY3NlcSArIFwiIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIlxcclxcblwiO1xuICByZXNwb25zZSArPSBcIlxcclxcblwiO1xuXG4gIHRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKTtcbn1cblxuLypcbiAqIFNhbml0eSBDaGVjayBmb3IgaW5jb21pbmcgTWVzc2FnZXNcbiAqXG4gKiBSZXF1ZXN0czpcbiAqICAtIF9yZmMzMjYxXzhfMl8yXzFfIFJlY2VpdmUgYSBSZXF1ZXN0IHdpdGggYSBub24gc3VwcG9ydGVkIFVSSSBzY2hlbWVcbiAqICAtIF9yZmMzMjYxXzE2XzNfNF8gUmVjZWl2ZSBhIFJlcXVlc3QgYWxyZWFkeSBzZW50IGJ5IHVzXG4gKiAgIERvZXMgbm90IGxvb2sgYXQgdmlhIHNlbnQtYnkgYnV0IGF0IHNpcGpzSWQsIHdoaWNoIGlzIGluc2VydGVkIGFzXG4gKiAgIGEgcHJlZml4IGluIGFsbCBpbml0aWFsIHJlcXVlc3RzIGdlbmVyYXRlZCBieSB0aGUgdWFcbiAqICAtIF9yZmMzMjYxXzE4XzNfcmVxdWVzdF8gQm9keSBDb250ZW50LUxlbmd0aFxuICogIC0gX3JmYzMyNjFfOF8yXzJfMl8gTWVyZ2VkIFJlcXVlc3RzXG4gKlxuICogUmVzcG9uc2VzOlxuICogIC0gX3JmYzMyNjFfOF8xXzNfM18gTXVsdGlwbGUgVmlhIGhlYWRlcnNcbiAqICAtIF9yZmMzMjYxXzE4XzFfMl8gc2VudC1ieSBtaXNtYXRjaFxuICogIC0gX3JmYzMyNjFfMThfM19yZXNwb25zZV8gQm9keSBDb250ZW50LUxlbmd0aFxuICpcbiAqIEFsbDpcbiAqICAtIE1pbmltdW0gaGVhZGVycyBpbiBhIFNJUCBtZXNzYWdlXG4gKi9cblxuLy8gU2FuaXR5IENoZWNrIGZ1bmN0aW9ucyBmb3IgcmVxdWVzdHNcbmZ1bmN0aW9uIHJmYzMyNjFfOF8yXzJfMSgpIHtcbiAgaWYoIW1lc3NhZ2UucnVyaSB8fCBtZXNzYWdlLnJ1cmkuc2NoZW1lICE9PSAnc2lwJykge1xuICAgIHJlcGx5KDQxNik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJmYzMyNjFfMTZfM180KCkge1xuICBpZighbWVzc2FnZS50b190YWcpIHtcbiAgICBpZihtZXNzYWdlLmNhbGxfaWQuc3Vic3RyKDAsIDUpID09PSB1YS5jb25maWd1cmF0aW9uLnNpcGpzSWQpIHtcbiAgICAgIHJlcGx5KDQ4Mik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJmYzMyNjFfMThfM19yZXF1ZXN0KCkge1xuICB2YXIgbGVuID0gU0lQLlV0aWxzLnN0cl91dGY4X2xlbmd0aChtZXNzYWdlLmJvZHkpLFxuICBjb250ZW50TGVuZ3RoID0gbWVzc2FnZS5nZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cbiAgaWYobGVuIDwgY29udGVudExlbmd0aCkge1xuICAgIHJlcGx5KDQwMCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJmYzMyNjFfOF8yXzJfMigpIHtcbiAgdmFyIHRyLCBpZHgsXG4gICAgZnJvbVRhZyA9IG1lc3NhZ2UuZnJvbV90YWcsXG4gICAgY2FsbF9pZCA9IG1lc3NhZ2UuY2FsbF9pZCxcbiAgICBjc2VxID0gbWVzc2FnZS5jc2VxO1xuXG4gIGlmKCFtZXNzYWdlLnRvX3RhZykge1xuICAgIGlmKG1lc3NhZ2UubWV0aG9kID09PSBTSVAuQy5JTlZJVEUpIHtcbiAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLmlzdFttZXNzYWdlLnZpYV9icmFuY2hdO1xuICAgICAgaWYodHIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKGlkeCBpbiB1YS50cmFuc2FjdGlvbnMuaXN0KSB7XG4gICAgICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMuaXN0W2lkeF07XG4gICAgICAgICAgaWYodHIucmVxdWVzdC5mcm9tX3RhZyA9PT0gZnJvbVRhZyAmJiB0ci5yZXF1ZXN0LmNhbGxfaWQgPT09IGNhbGxfaWQgJiYgdHIucmVxdWVzdC5jc2VxID09PSBjc2VxKSB7XG4gICAgICAgICAgICByZXBseSg0ODIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5uaXN0W21lc3NhZ2UudmlhX2JyYW5jaF07XG4gICAgICBpZih0cikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IoaWR4IGluIHVhLnRyYW5zYWN0aW9ucy5uaXN0KSB7XG4gICAgICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMubmlzdFtpZHhdO1xuICAgICAgICAgIGlmKHRyLnJlcXVlc3QuZnJvbV90YWcgPT09IGZyb21UYWcgJiYgdHIucmVxdWVzdC5jYWxsX2lkID09PSBjYWxsX2lkICYmIHRyLnJlcXVlc3QuY3NlcSA9PT0gY3NlcSkge1xuICAgICAgICAgICAgcmVwbHkoNDgyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gU2FuaXR5IENoZWNrIGZ1bmN0aW9ucyBmb3IgcmVzcG9uc2VzXG5mdW5jdGlvbiByZmMzMjYxXzhfMV8zXzMoKSB7XG4gIGlmKG1lc3NhZ2UuZ2V0SGVhZGVycygndmlhJykubGVuZ3RoID4gMSkge1xuICAgIGxvZ2dlci53YXJuKCdNb3JlIHRoYW4gb25lIFZpYSBoZWFkZXIgZmllbGQgcHJlc2VudCBpbiB0aGUgcmVzcG9uc2UuIERyb3BwaW5nIHRoZSByZXNwb25zZScpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZmMzMjYxXzE4XzFfMigpIHtcbiAgdmFyIHZpYUhvc3QgPSB1YS5jb25maWd1cmF0aW9uLnZpYUhvc3Q7XG4gIGlmKG1lc3NhZ2UudmlhLmhvc3QgIT09IHZpYUhvc3QgfHwgbWVzc2FnZS52aWEucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbG9nZ2VyLndhcm4oJ1ZpYSBzZW50LWJ5IGluIHRoZSByZXNwb25zZSBkb2VzIG5vdCBtYXRjaCBVQSBWaWEgaG9zdCB2YWx1ZS4gRHJvcHBpbmcgdGhlIHJlc3BvbnNlJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJmYzMyNjFfMThfM19yZXNwb25zZSgpIHtcbiAgdmFyXG4gICAgbGVuID0gU0lQLlV0aWxzLnN0cl91dGY4X2xlbmd0aChtZXNzYWdlLmJvZHkpLFxuICAgIGNvbnRlbnRMZW5ndGggPSBtZXNzYWdlLmdldEhlYWRlcignY29udGVudC1sZW5ndGgnKTtcblxuICAgIGlmKGxlbiA8IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdNZXNzYWdlIGJvZHkgbGVuZ3RoIGlzIGxvd2VyIHRoYW4gdGhlIHZhbHVlIGluIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZC4gRHJvcHBpbmcgdGhlIHJlc3BvbnNlJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBTYW5pdHkgQ2hlY2sgZnVuY3Rpb25zIGZvciByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzXG5mdW5jdGlvbiBtaW5pbXVtSGVhZGVycygpIHtcbiAgdmFyXG4gICAgbWFuZGF0b3J5SGVhZGVycyA9IFsnZnJvbScsICd0bycsICdjYWxsX2lkJywgJ2NzZXEnLCAndmlhJ10sXG4gICAgaWR4ID0gbWFuZGF0b3J5SGVhZGVycy5sZW5ndGg7XG5cbiAgd2hpbGUoaWR4LS0pIHtcbiAgICBpZighbWVzc2FnZS5oYXNIZWFkZXIobWFuZGF0b3J5SGVhZGVyc1tpZHhdKSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ01pc3NpbmcgbWFuZGF0b3J5IGhlYWRlciBmaWVsZCA6ICcrIG1hbmRhdG9yeUhlYWRlcnNbaWR4XSArJy4gRHJvcHBpbmcgdGhlIHJlc3BvbnNlJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbnJlcXVlc3RzLnB1c2gocmZjMzI2MV84XzJfMl8xKTtcbnJlcXVlc3RzLnB1c2gocmZjMzI2MV8xNl8zXzQpO1xucmVxdWVzdHMucHVzaChyZmMzMjYxXzE4XzNfcmVxdWVzdCk7XG5yZXF1ZXN0cy5wdXNoKHJmYzMyNjFfOF8yXzJfMik7XG5cbnJlc3BvbnNlcy5wdXNoKHJmYzMyNjFfOF8xXzNfMyk7XG5yZXNwb25zZXMucHVzaChyZmMzMjYxXzE4XzFfMik7XG5yZXNwb25zZXMucHVzaChyZmMzMjYxXzE4XzNfcmVzcG9uc2UpO1xuXG5hbGwucHVzaChtaW5pbXVtSGVhZGVycyk7XG5cbnNhbml0eUNoZWNrID0gZnVuY3Rpb24obSwgdSwgdCkge1xuICB2YXIgbGVuLCBwYXNzO1xuXG4gIG1lc3NhZ2UgPSBtO1xuICB1YSA9IHU7XG4gIHRyYW5zcG9ydCA9IHQ7XG5cbiAgbG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuc2FuaXR5Y2hlY2snKTtcblxuICBsZW4gPSBhbGwubGVuZ3RoO1xuICB3aGlsZShsZW4tLSkge1xuICAgIHBhc3MgPSBhbGxbbGVuXShtZXNzYWdlKTtcbiAgICBpZihwYXNzID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXF1ZXN0KSB7XG4gICAgbGVuID0gcmVxdWVzdHMubGVuZ3RoO1xuICAgIHdoaWxlKGxlbi0tKSB7XG4gICAgICBwYXNzID0gcmVxdWVzdHNbbGVuXShtZXNzYWdlKTtcbiAgICAgIGlmKHBhc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXNwb25zZSkge1xuICAgIGxlbiA9IHJlc3BvbnNlcy5sZW5ndGg7XG4gICAgd2hpbGUobGVuLS0pIHtcbiAgICAgIHBhc3MgPSByZXNwb25zZXNbbGVuXShtZXNzYWdlKTtcbiAgICAgIGlmKHBhc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvL0V2ZXJ5dGhpbmcgaXMgT0tcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5TSVAuc2FuaXR5Q2hlY2sgPSBzYW5pdHlDaGVjaztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1Nhbml0eUNoZWNrLmpzXG4gKiogbW9kdWxlIGlkID0gMjQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBEaWdlc3QgQXV0aGVudGljYXRpb25cbiAqL1xuXG4vKipcbiAqIFNJUCBEaWdlc3QgQXV0aGVudGljYXRpb24uXG4gKiBAYXVnbWVudHMgU0lQLlxuICogQGZ1bmN0aW9uIERpZ2VzdCBBdXRoZW50aWNhdGlvblxuICogQHBhcmFtIHtTSVAuVUF9IHVhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFV0aWxzKSB7XG52YXIgRGlnZXN0QXV0aGVudGljYXRpb247XG5cbkRpZ2VzdEF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24odWEpIHtcbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcGpzLmRpZ2VzdGF1dGhlbnRpY2F0aW9uJyk7XG4gIHRoaXMudXNlcm5hbWUgPSB1YS5jb25maWd1cmF0aW9uLmF1dGhvcml6YXRpb25Vc2VyO1xuICB0aGlzLnBhc3N3b3JkID0gdWEuY29uZmlndXJhdGlvbi5wYXNzd29yZDtcbiAgdGhpcy5jbm9uY2UgPSBudWxsO1xuICB0aGlzLm5jID0gMDtcbiAgdGhpcy5uY0hleCA9ICcwMDAwMDAwMCc7XG4gIHRoaXMucmVzcG9uc2UgPSBudWxsO1xufTtcblxuXG4vKipcbiogUGVyZm9ybXMgRGlnZXN0IGF1dGhlbnRpY2F0aW9uIGdpdmVuIGEgU0lQIHJlcXVlc3QgYW5kIHRoZSBjaGFsbGVuZ2VcbiogcmVjZWl2ZWQgaW4gYSByZXNwb25zZSB0byB0aGF0IHJlcXVlc3QuXG4qIFJldHVybnMgdHJ1ZSBpZiBjcmVkZW50aWFscyB3ZXJlIHN1Y2Nlc3NmdWxseSBnZW5lcmF0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbipcbiogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fSByZXF1ZXN0XG4qIEBwYXJhbSB7T2JqZWN0fSBjaGFsbGVuZ2VcbiovXG5EaWdlc3RBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24ocmVxdWVzdCwgY2hhbGxlbmdlKSB7XG4gIC8vIEluc3BlY3QgYW5kIHZhbGlkYXRlIHRoZSBjaGFsbGVuZ2UuXG5cbiAgdGhpcy5hbGdvcml0aG0gPSBjaGFsbGVuZ2UuYWxnb3JpdGhtO1xuICB0aGlzLnJlYWxtID0gY2hhbGxlbmdlLnJlYWxtO1xuICB0aGlzLm5vbmNlID0gY2hhbGxlbmdlLm5vbmNlO1xuICB0aGlzLm9wYXF1ZSA9IGNoYWxsZW5nZS5vcGFxdWU7XG4gIHRoaXMuc3RhbGUgPSBjaGFsbGVuZ2Uuc3RhbGU7XG5cbiAgaWYgKHRoaXMuYWxnb3JpdGhtKSB7XG4gICAgaWYgKHRoaXMuYWxnb3JpdGhtICE9PSAnTUQ1Jykge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignY2hhbGxlbmdlIHdpdGggRGlnZXN0IGFsZ29yaXRobSBkaWZmZXJlbnQgdGhhbiBcIk1ENVwiLCBhdXRoZW50aWNhdGlvbiBhYm9ydGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuYWxnb3JpdGhtID0gJ01ENSc7XG4gIH1cblxuICBpZiAoISB0aGlzLnJlYWxtKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignY2hhbGxlbmdlIHdpdGhvdXQgRGlnZXN0IHJlYWxtLCBhdXRoZW50aWNhdGlvbiBhYm9ydGVkJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCEgdGhpcy5ub25jZSkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ2NoYWxsZW5nZSB3aXRob3V0IERpZ2VzdCBub25jZSwgYXV0aGVudGljYXRpb24gYWJvcnRlZCcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vICdxb3AnIGNhbiBjb250YWluIGEgbGlzdCBvZiB2YWx1ZXMgKEFycmF5KS4gTGV0J3MgY2hvb3NlIGp1c3Qgb25lLlxuICBpZiAoY2hhbGxlbmdlLnFvcCkge1xuICAgIGlmIChjaGFsbGVuZ2UucW9wLmluZGV4T2YoJ2F1dGgnKSA+IC0xKSB7XG4gICAgICB0aGlzLnFvcCA9ICdhdXRoJztcbiAgICB9IGVsc2UgaWYgKGNoYWxsZW5nZS5xb3AuaW5kZXhPZignYXV0aC1pbnQnKSA+IC0xKSB7XG4gICAgICB0aGlzLnFvcCA9ICdhdXRoLWludCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSAncW9wJyBpcyBwcmVzZW50IGJ1dCBkb2VzIG5vdCBjb250YWluICdhdXRoJyBvciAnYXV0aC1pbnQnLCBzbyBhYm9ydCBoZXJlLlxuICAgICAgdGhpcy5sb2dnZXIud2FybignY2hhbGxlbmdlIHdpdGhvdXQgRGlnZXN0IHFvcCBkaWZmZXJlbnQgdGhhbiBcImF1dGhcIiBvciBcImF1dGgtaW50XCIsIGF1dGhlbnRpY2F0aW9uIGFib3J0ZWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5xb3AgPSBudWxsO1xuICB9XG5cbiAgLy8gRmlsbCBvdGhlciBhdHRyaWJ1dGVzLlxuXG4gIHRoaXMubWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gIHRoaXMudXJpID0gcmVxdWVzdC5ydXJpO1xuICB0aGlzLmNub25jZSA9IFV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDEyKTtcbiAgdGhpcy5uYyArPSAxO1xuICB0aGlzLnVwZGF0ZU5jSGV4KCk7XG5cbiAgLy8gbmMtdmFsdWUgPSA4TEhFWC4gTWF4IHZhbHVlID0gJ0ZGRkZGRkZGJy5cbiAgaWYgKHRoaXMubmMgPT09IDQyOTQ5NjcyOTYpIHtcbiAgICB0aGlzLm5jID0gMTtcbiAgICB0aGlzLm5jSGV4ID0gJzAwMDAwMDAxJztcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSB0aGUgRGlnZXN0IFwicmVzcG9uc2VcIiB2YWx1ZS5cbiAgdGhpcy5jYWxjdWxhdGVSZXNwb25zZSgpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiogR2VuZXJhdGUgRGlnZXN0ICdyZXNwb25zZScgdmFsdWUuXG4qIEBwcml2YXRlXG4qL1xuRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLmNhbGN1bGF0ZVJlc3BvbnNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYTEsIGhhMjtcblxuICAvLyBIQTEgPSBNRDUoQTEpID0gTUQ1KHVzZXJuYW1lOnJlYWxtOnBhc3N3b3JkKVxuICBoYTEgPSBVdGlscy5jYWxjdWxhdGVNRDUodGhpcy51c2VybmFtZSArIFwiOlwiICsgdGhpcy5yZWFsbSArIFwiOlwiICsgdGhpcy5wYXNzd29yZCk7XG5cbiAgaWYgKHRoaXMucW9wID09PSAnYXV0aCcpIHtcbiAgICAvLyBIQTIgPSBNRDUoQTIpID0gTUQ1KG1ldGhvZDpkaWdlc3RVUkkpXG4gICAgaGEyID0gVXRpbHMuY2FsY3VsYXRlTUQ1KHRoaXMubWV0aG9kICsgXCI6XCIgKyB0aGlzLnVyaSk7XG4gICAgLy8gcmVzcG9uc2UgPSBNRDUoSEExOm5vbmNlOm5vbmNlQ291bnQ6Y3JlZGVudGlhbHNOb25jZTpxb3A6SEEyKVxuICAgIHRoaXMucmVzcG9uc2UgPSBVdGlscy5jYWxjdWxhdGVNRDUoaGExICsgXCI6XCIgKyB0aGlzLm5vbmNlICsgXCI6XCIgKyB0aGlzLm5jSGV4ICsgXCI6XCIgKyB0aGlzLmNub25jZSArIFwiOmF1dGg6XCIgKyBoYTIpO1xuXG4gIH0gZWxzZSBpZiAodGhpcy5xb3AgPT09ICdhdXRoLWludCcpIHtcbiAgICAvLyBIQTIgPSBNRDUoQTIpID0gTUQ1KG1ldGhvZDpkaWdlc3RVUkk6TUQ1KGVudGl0eUJvZHkpKVxuICAgIGhhMiA9IFV0aWxzLmNhbGN1bGF0ZU1ENSh0aGlzLm1ldGhvZCArIFwiOlwiICsgdGhpcy51cmkgKyBcIjpcIiArIFV0aWxzLmNhbGN1bGF0ZU1ENSh0aGlzLmJvZHkgPyB0aGlzLmJvZHkgOiBcIlwiKSk7XG4gICAgLy8gcmVzcG9uc2UgPSBNRDUoSEExOm5vbmNlOm5vbmNlQ291bnQ6Y3JlZGVudGlhbHNOb25jZTpxb3A6SEEyKVxuICAgIHRoaXMucmVzcG9uc2UgPSBVdGlscy5jYWxjdWxhdGVNRDUoaGExICsgXCI6XCIgKyB0aGlzLm5vbmNlICsgXCI6XCIgKyB0aGlzLm5jSGV4ICsgXCI6XCIgKyB0aGlzLmNub25jZSArIFwiOmF1dGgtaW50OlwiICsgaGEyKTtcblxuICB9IGVsc2UgaWYgKHRoaXMucW9wID09PSBudWxsKSB7XG4gICAgLy8gSEEyID0gTUQ1KEEyKSA9IE1ENShtZXRob2Q6ZGlnZXN0VVJJKVxuICAgIGhhMiA9IFV0aWxzLmNhbGN1bGF0ZU1ENSh0aGlzLm1ldGhvZCArIFwiOlwiICsgdGhpcy51cmkpO1xuICAgIC8vIHJlc3BvbnNlID0gTUQ1KEhBMTpub25jZTpIQTIpXG4gICAgdGhpcy5yZXNwb25zZSA9IFV0aWxzLmNhbGN1bGF0ZU1ENShoYTEgKyBcIjpcIiArIHRoaXMubm9uY2UgKyBcIjpcIiArIGhhMik7XG4gIH1cbn07XG5cblxuLyoqXG4qIFJldHVybiB0aGUgUHJveHktQXV0aG9yaXphdGlvbiBvciBXV1ctQXV0aG9yaXphdGlvbiBoZWFkZXIgdmFsdWUuXG4qL1xuRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoX3BhcmFtcyA9IFtdO1xuXG4gIGlmICghIHRoaXMucmVzcG9uc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3BvbnNlIGZpZWxkIGRvZXMgbm90IGV4aXN0LCBjYW5ub3QgZ2VuZXJhdGUgQXV0aG9yaXphdGlvbiBoZWFkZXInKTtcbiAgfVxuXG4gIGF1dGhfcGFyYW1zLnB1c2goJ2FsZ29yaXRobT0nICsgdGhpcy5hbGdvcml0aG0pO1xuICBhdXRoX3BhcmFtcy5wdXNoKCd1c2VybmFtZT1cIicgKyB0aGlzLnVzZXJuYW1lICsgJ1wiJyk7XG4gIGF1dGhfcGFyYW1zLnB1c2goJ3JlYWxtPVwiJyArIHRoaXMucmVhbG0gKyAnXCInKTtcbiAgYXV0aF9wYXJhbXMucHVzaCgnbm9uY2U9XCInICsgdGhpcy5ub25jZSArICdcIicpO1xuICBhdXRoX3BhcmFtcy5wdXNoKCd1cmk9XCInICsgdGhpcy51cmkgKyAnXCInKTtcbiAgYXV0aF9wYXJhbXMucHVzaCgncmVzcG9uc2U9XCInICsgdGhpcy5yZXNwb25zZSArICdcIicpO1xuICBpZiAodGhpcy5vcGFxdWUpIHtcbiAgICBhdXRoX3BhcmFtcy5wdXNoKCdvcGFxdWU9XCInICsgdGhpcy5vcGFxdWUgKyAnXCInKTtcbiAgfVxuICBpZiAodGhpcy5xb3ApIHtcbiAgICBhdXRoX3BhcmFtcy5wdXNoKCdxb3A9JyArIHRoaXMucW9wKTtcbiAgICBhdXRoX3BhcmFtcy5wdXNoKCdjbm9uY2U9XCInICsgdGhpcy5jbm9uY2UgKyAnXCInKTtcbiAgICBhdXRoX3BhcmFtcy5wdXNoKCduYz0nICsgdGhpcy5uY0hleCk7XG4gIH1cblxuICByZXR1cm4gJ0RpZ2VzdCAnICsgYXV0aF9wYXJhbXMuam9pbignLCAnKTtcbn07XG5cblxuLyoqXG4qIEdlbmVyYXRlIHRoZSAnbmMnIHZhbHVlIGFzIHJlcXVpcmVkIGJ5IERpZ2VzdCBpbiB0aGlzLm5jSGV4IGJ5IHJlYWRpbmcgdGhpcy5uYy5cbiogQHByaXZhdGVcbiovXG5EaWdlc3RBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUudXBkYXRlTmNIZXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhleCA9IE51bWJlcih0aGlzLm5jKS50b1N0cmluZygxNik7XG4gIHRoaXMubmNIZXggPSAnMDAwMDAwMDAnLnN1YnN0cigwLCA4LWhleC5sZW5ndGgpICsgaGV4O1xufTtcblxucmV0dXJuIERpZ2VzdEF1dGhlbnRpY2F0aW9uO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvRGlnZXN0QXV0aGVudGljYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIEdyYW1tYXIgPSByZXF1aXJlKCcuL0dyYW1tYXIvZGlzdC9HcmFtbWFyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuXG5yZXR1cm4ge1xuICBwYXJzZTogZnVuY3Rpb24gcGFyc2VDdXN0b20gKGlucHV0LCBzdGFydFJ1bGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtzdGFydFJ1bGU6IHN0YXJ0UnVsZSwgU0lQOiBTSVB9O1xuICAgIHRyeSB7XG4gICAgICBHcmFtbWFyLnBhcnNlKGlucHV0LCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMuZGF0YTtcbiAgfVxufTtcblxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvR3JhbW1hci5qc1xuICoqIG1vZHVsZSBpZCA9IDI0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIC8qXG4gICAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC44LjAuXG4gICAqXG4gICAqIGh0dHA6Ly9wZWdqcy5tYWpkYS5jei9cbiAgICovXG5cbiAgZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgICBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH1cbiAgICBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHtcbiAgICB0aGlzLm1lc3NhZ2UgID0gbWVzc2FnZTtcbiAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICAgIHRoaXMub2Zmc2V0ICAgPSBvZmZzZXQ7XG4gICAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gICA9IGNvbHVtbjtcblxuICAgIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7XG4gIH1cblxuICBwZWckc3ViY2xhc3MoU3ludGF4RXJyb3IsIEVycm9yKTtcblxuICBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB7fSxcblxuICAgICAgICBwZWckRkFJTEVEID0ge30sXG5cbiAgICAgICAgcGVnJHN0YXJ0UnVsZUluZGljZXMgPSB7IENvbnRhY3Q6IDExOCwgTmFtZV9BZGRyX0hlYWRlcjogMTU1LCBSZWNvcmRfUm91dGU6IDE3NSwgUmVxdWVzdF9SZXNwb25zZTogODEsIFNJUF9VUkk6IDQ1LCBTdWJzY3JpcHRpb25fU3RhdGU6IDE4NSwgU3VwcG9ydGVkOiAxOTAsIFJlcXVpcmU6IDE4MSwgVmlhOiAxOTMsIGFic29sdXRlVVJJOiA4NCwgQ2FsbF9JRDogMTE3LCBDb250ZW50X0Rpc3Bvc2l0aW9uOiAxMjksIENvbnRlbnRfTGVuZ3RoOiAxMzQsIENvbnRlbnRfVHlwZTogMTM1LCBDU2VxOiAxNDUsIGRpc3BsYXlOYW1lOiAxMjEsIEV2ZW50OiAxNDgsIEZyb206IDE1MCwgaG9zdDogNTIsIE1heF9Gb3J3YXJkczogMTUzLCBNaW5fU0U6IDIxMiwgUHJveHlfQXV0aGVudGljYXRlOiAxNTYsIHF1b3RlZF9zdHJpbmc6IDQwLCBSZWZlcl9UbzogMTc3LCBSZXBsYWNlczogMTc4LCBTZXNzaW9uX0V4cGlyZXM6IDIwOSwgc3R1bl9VUkk6IDIxNiwgVG86IDE5MSwgdHVybl9VUkk6IDIyMywgdXVpZDogMjI2LCBXV1dfQXV0aGVudGljYXRlOiAyMDgsIGNoYWxsZW5nZTogMTU3IH0sXG4gICAgICAgIHBlZyRzdGFydFJ1bGVJbmRleCAgID0gMTE4LFxuXG4gICAgICAgIHBlZyRjb25zdHMgPSBbXG4gICAgICAgICAgXCJcXHJcXG5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXHJcXG5cIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxyXFxcXG5cXFwiXCIgfSxcbiAgICAgICAgICAvXlswLTldLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzAtOV1cIiwgZGVzY3JpcHRpb246IFwiWzAtOV1cIiB9LFxuICAgICAgICAgIC9eW2EtekEtWl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aXVwiLCBkZXNjcmlwdGlvbjogXCJbYS16QS1aXVwiIH0sXG4gICAgICAgICAgL15bMC05YS1mQS1GXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlswLTlhLWZBLUZdXCIsIGRlc2NyaXB0aW9uOiBcIlswLTlhLWZBLUZdXCIgfSxcbiAgICAgICAgICAvXltcXDAtXFx4RkZdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFwwLVxcXFx4RkZdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxcMC1cXFxceEZGXVwiIH0sXG4gICAgICAgICAgL15bXCJdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXCJdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFwiXVwiIH0sXG4gICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiIFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiIFxcXCJcIiB9LFxuICAgICAgICAgIFwiXFx0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFx0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcdFxcXCJcIiB9LFxuICAgICAgICAgIC9eW2EtekEtWjAtOV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aMC05XVwiLCBkZXNjcmlwdGlvbjogXCJbYS16QS1aMC05XVwiIH0sXG4gICAgICAgICAgXCI7XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiO1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiO1xcXCJcIiB9LFxuICAgICAgICAgIFwiL1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi9cIiwgZGVzY3JpcHRpb246IFwiXFxcIi9cXFwiXCIgfSxcbiAgICAgICAgICBcIj9cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI/XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI/XFxcIlwiIH0sXG4gICAgICAgICAgXCI6XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiOlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiOlxcXCJcIiB9LFxuICAgICAgICAgIFwiQFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIkBcIiwgZGVzY3JpcHRpb246IFwiXFxcIkBcXFwiXCIgfSxcbiAgICAgICAgICBcIiZcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCImXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCImXFxcIlwiIH0sXG4gICAgICAgICAgXCI9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPVxcXCJcIiB9LFxuICAgICAgICAgIFwiK1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIitcIiwgZGVzY3JpcHRpb246IFwiXFxcIitcXFwiXCIgfSxcbiAgICAgICAgICBcIiRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIkXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIkXFxcIlwiIH0sXG4gICAgICAgICAgXCIsXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiLFxcXCJcIiB9LFxuICAgICAgICAgIFwiLVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi1cIiwgZGVzY3JpcHRpb246IFwiXFxcIi1cXFwiXCIgfSxcbiAgICAgICAgICBcIl9cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJfXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJfXFxcIlwiIH0sXG4gICAgICAgICAgXCIuXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiLlxcXCJcIiB9LFxuICAgICAgICAgIFwiIVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiFcIiwgZGVzY3JpcHRpb246IFwiXFxcIiFcXFwiXCIgfSxcbiAgICAgICAgICBcIn5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ+XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ+XFxcIlwiIH0sXG4gICAgICAgICAgXCIqXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKlxcXCJcIiB9LFxuICAgICAgICAgIFwiJ1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIidcIiwgZGVzY3JpcHRpb246IFwiXFxcIidcXFwiXCIgfSxcbiAgICAgICAgICBcIihcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIoXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIoXFxcIlwiIH0sXG4gICAgICAgICAgXCIpXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKVxcXCJcIiB9LFxuICAgICAgICAgIHBlZyRGQUlMRUQsXG4gICAgICAgICAgXCIlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiJVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiJVxcXCJcIiB9LFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgW10sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiIFwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiAnOic7IH0sXG4gICAgICAgICAgL15bIS1+XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlshLX5dXCIsIGRlc2NyaXB0aW9uOiBcIlshLX5dXCIgfSxcbiAgICAgICAgICAvXltcXHg4MC1cXHVGRkZGXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxceDgwLVxcXFx1RkZGRl1cIiwgZGVzY3JpcHRpb246IFwiW1xcXFx4ODAtXFxcXHVGRkZGXVwiIH0sXG4gICAgICAgICAgL15bXFx4ODAtXFx4QkZdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFx4ODAtXFxcXHhCRl1cIiwgZGVzY3JpcHRpb246IFwiW1xcXFx4ODAtXFxcXHhCRl1cIiB9LFxuICAgICAgICAgIC9eW2EtZl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS1mXVwiLCBkZXNjcmlwdGlvbjogXCJbYS1mXVwiIH0sXG4gICAgICAgICAgXCJgXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYFxcXCJcIiB9LFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjxcIiwgZGVzY3JpcHRpb246IFwiXFxcIjxcXFwiXCIgfSxcbiAgICAgICAgICBcIj5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI+XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI+XFxcIlwiIH0sXG4gICAgICAgICAgXCJcXFxcXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxcXFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFxcXFwiXCIgfSxcbiAgICAgICAgICBcIltcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJbXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJbXFxcIlwiIH0sXG4gICAgICAgICAgXCJdXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXVxcXCJcIiB9LFxuICAgICAgICAgIFwie1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIntcIiwgZGVzY3JpcHRpb246IFwiXFxcIntcXFwiXCIgfSxcbiAgICAgICAgICBcIn1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ9XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiKlwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIi9cIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCI9XCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiKFwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIilcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCI+XCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiPFwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIixcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCI7XCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiOlwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIlxcXCJcIjsgfSxcbiAgICAgICAgICAvXlshLSddLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyEtJ11cIiwgZGVzY3JpcHRpb246IFwiWyEtJ11cIiB9LFxuICAgICAgICAgIC9eWyotW10vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbKi1bXVwiLCBkZXNjcmlwdGlvbjogXCJbKi1bXVwiIH0sXG4gICAgICAgICAgL15bXFxdLX5dLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFxdLX5dXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxcXS1+XVwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oY29udGVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudHM7IH0sXG4gICAgICAgICAgL15bIy1bXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsjLVtdXCIsIGRlc2NyaXB0aW9uOiBcIlsjLVtdXCIgfSxcbiAgICAgICAgICAvXltcXDAtXFx0XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxcMC1cXFxcdF1cIiwgZGVzY3JpcHRpb246IFwiW1xcXFwwLVxcXFx0XVwiIH0sXG4gICAgICAgICAgL15bXFx4MEItXFxmXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxceDBCLVxcXFxmXVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcXHgwQi1cXFxcZl1cIiB9LFxuICAgICAgICAgIC9eW1xceDBFLX9dLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFx4MEUtf11cIiwgZGVzY3JpcHRpb246IFwiW1xcXFx4MEUtf11cIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmkgPSBuZXcgb3B0aW9ucy5TSVAuVVJJKG9wdGlvbnMuZGF0YS5zY2hlbWUsIG9wdGlvbnMuZGF0YS51c2VyLCBvcHRpb25zLmRhdGEuaG9zdCwgb3B0aW9ucy5kYXRhLnBvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuc2NoZW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5wb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmkgPSBuZXcgb3B0aW9ucy5TSVAuVVJJKG9wdGlvbnMuZGF0YS5zY2hlbWUsIG9wdGlvbnMuZGF0YS51c2VyLCBvcHRpb25zLmRhdGEuaG9zdCwgb3B0aW9ucy5kYXRhLnBvcnQsIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zLCBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuc2NoZW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5wb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1NJUF9VUkknKSB7IG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YS51cmk7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwic2lwc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInNpcHNcIiwgZGVzY3JpcHRpb246IFwiXFxcInNpcHNcXFwiXCIgfSxcbiAgICAgICAgICBcInNpcFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInNpcFwiLCBkZXNjcmlwdGlvbjogXCJcXFwic2lwXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odXJpX3NjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNjaGVtZSA9IHVyaV9zY2hlbWU7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXNlciA9IGRlY29kZVVSSUNvbXBvbmVudCh0ZXh0KCkuc2xpY2UoMCwgLTEpKTt9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhc3N3b3JkID0gdGV4dCgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3QgPSB0ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXRhLmhvc3Q7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZSA9ICdkb21haW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0KCk7IH0sXG4gICAgICAgICAgL15bYS16QS1aMC05X1xcLV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aMC05X1xcXFwtXVwiLCBkZXNjcmlwdGlvbjogXCJbYS16QS1aMC05X1xcXFwtXVwiIH0sXG4gICAgICAgICAgL15bYS16QS1aMC05XFwtXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlthLXpBLVowLTlcXFxcLV1cIiwgZGVzY3JpcHRpb246IFwiW2EtekEtWjAtOVxcXFwtXVwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdF90eXBlID0gJ0lQdjYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQoKTsgfSxcbiAgICAgICAgICBcIjo6XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiOjpcIiwgZGVzY3JpcHRpb246IFwiXFxcIjo6XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZSA9ICdJUHY2JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZSA9ICdJUHY0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0KCk7IH0sXG4gICAgICAgICAgXCIyNVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjI1XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIyNVxcXCJcIiB9LFxuICAgICAgICAgIC9eWzAtNV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC01XVwiLCBkZXNjcmlwdGlvbjogXCJbMC01XVwiIH0sXG4gICAgICAgICAgXCIyXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiMlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiMlxcXCJcIiB9LFxuICAgICAgICAgIC9eWzAtNF0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC00XVwiLCBkZXNjcmlwdGlvbjogXCJbMC00XVwiIH0sXG4gICAgICAgICAgXCIxXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiMVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiMVxcXCJcIiB9LFxuICAgICAgICAgIC9eWzEtOV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMS05XVwiLCBkZXNjcmlwdGlvbjogXCJbMS05XVwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydCA9IHBhcnNlSW50KHBvcnQuam9pbignJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBvcnQgPSBwb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcnQ7IH0sXG4gICAgICAgICAgXCJ0cmFuc3BvcnQ9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidHJhbnNwb3J0PVwiLCBkZXNjcmlwdGlvbjogXCJcXFwidHJhbnNwb3J0PVxcXCJcIiB9LFxuICAgICAgICAgIFwidWRwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidWRwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ1ZHBcXFwiXCIgfSxcbiAgICAgICAgICBcInRjcFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRjcFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidGNwXFxcIlwiIH0sXG4gICAgICAgICAgXCJzY3RwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic2N0cFwiLCBkZXNjcmlwdGlvbjogXCJcXFwic2N0cFxcXCJcIiB9LFxuICAgICAgICAgIFwidGxzXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidGxzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0bHNcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ3RyYW5zcG9ydCddID0gdHJhbnNwb3J0LnRvTG93ZXJDYXNlKCk7IH0sXG4gICAgICAgICAgXCJ1c2VyPVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInVzZXI9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ1c2VyPVxcXCJcIiB9LFxuICAgICAgICAgIFwicGhvbmVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJwaG9uZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwicGhvbmVcXFwiXCIgfSxcbiAgICAgICAgICBcImlwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiaXBcIiwgZGVzY3JpcHRpb246IFwiXFxcImlwXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zPXt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1sndXNlciddID0gdXNlci50b0xvd2VyQ2FzZSgpOyB9LFxuICAgICAgICAgIFwibWV0aG9kPVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1ldGhvZD1cIiwgZGVzY3JpcHRpb246IFwiXFxcIm1ldGhvZD1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ21ldGhvZCddID0gbWV0aG9kOyB9LFxuICAgICAgICAgIFwidHRsPVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInR0bD1cIiwgZGVzY3JpcHRpb246IFwiXFxcInR0bD1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih0dGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5wYXJhbXMpIG9wdGlvbnMuZGF0YS5wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXNbJ3R0bCddID0gdHRsOyB9LFxuICAgICAgICAgIFwibWFkZHI9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibWFkZHI9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtYWRkcj1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihtYWRkcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zPXt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1snbWFkZHInXSA9IG1hZGRyOyB9LFxuICAgICAgICAgIFwibHJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJsclwiLCBkZXNjcmlwdGlvbjogXCJcXFwibHJcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ2xyJ10gPSB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgZnVuY3Rpb24ocGFyYW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zW3BhcmFtLnRvTG93ZXJDYXNlKCldID0gdmFsdWUgJiYgdmFsdWUudG9Mb3dlckNhc2UoKTt9LFxuICAgICAgICAgIGZ1bmN0aW9uKGhuYW1lLCBodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG5hbWUgPSBobmFtZS5qb2luKCcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodmFsdWUgPSBodmFsdWUuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX2hlYWRlcnMpIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YS51cmlfaGVhZGVyc1tobmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnNbaG5hbWVdID0gW2h2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzW2huYW1lXS5wdXNoKGh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb3RzIG9mIHRlc3RzIGZhaWwgaWYgdGhpcyBpc24ndCBndWFyZGVkLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1JlZmVyX1RvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmkgPSBuZXcgb3B0aW9ucy5TSVAuVVJJKG9wdGlvbnMuZGF0YS5zY2hlbWUsIG9wdGlvbnMuZGF0YS51c2VyLCBvcHRpb25zLmRhdGEuaG9zdCwgb3B0aW9ucy5kYXRhLnBvcnQsIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zLCBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuc2NoZW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5wb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcIi8vXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLy9cIiwgZGVzY3JpcHRpb246IFwiXFxcIi8vXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuc2NoZW1lPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiU0lQXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJTSVBcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zaXBfdmVyc2lvbiA9IHRleHQoKTsgfSxcbiAgICAgICAgICBcIklOVklURVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIklOVklURVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiSU5WSVRFXFxcIlwiIH0sXG4gICAgICAgICAgXCJBQ0tcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJBQ0tcIiwgZGVzY3JpcHRpb246IFwiXFxcIkFDS1xcXCJcIiB9LFxuICAgICAgICAgIFwiVlhBQ0hcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJWWEFDSFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiVlhBQ0hcXFwiXCIgfSxcbiAgICAgICAgICBcIk9QVElPTlNcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJPUFRJT05TXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJPUFRJT05TXFxcIlwiIH0sXG4gICAgICAgICAgXCJCWUVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJCWUVcIiwgZGVzY3JpcHRpb246IFwiXFxcIkJZRVxcXCJcIiB9LFxuICAgICAgICAgIFwiQ0FOQ0VMXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiQ0FOQ0VMXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJDQU5DRUxcXFwiXCIgfSxcbiAgICAgICAgICBcIlJFR0lTVEVSXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiUkVHSVNURVJcIiwgZGVzY3JpcHRpb246IFwiXFxcIlJFR0lTVEVSXFxcIlwiIH0sXG4gICAgICAgICAgXCJTVUJTQ1JJQkVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJTVUJTQ1JJQkVcIiwgZGVzY3JpcHRpb246IFwiXFxcIlNVQlNDUklCRVxcXCJcIiB9LFxuICAgICAgICAgIFwiTk9USUZZXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiTk9USUZZXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJOT1RJRllcXFwiXCIgfSxcbiAgICAgICAgICBcIlJFRkVSXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiUkVGRVJcIiwgZGVzY3JpcHRpb246IFwiXFxcIlJFRkVSXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tZXRob2QgPSB0ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXRhLm1ldGhvZDsgfSxcbiAgICAgICAgICBmdW5jdGlvbihzdGF0dXNfY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zdGF0dXNfY29kZSA9IHBhcnNlSW50KHN0YXR1c19jb2RlLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmVhc29uX3BocmFzZSA9IHRleHQoKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHRleHQoKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4LCBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcltpZHhdLnBhcnNlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcikgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlci5wdXNoKCB7ICdwb3NpdGlvbic6IHBlZyRjdXJyUG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29mZnNldCc6IG9mZnNldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BhcnNlZCc6IGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO30sXG4gICAgICAgICAgZnVuY3Rpb24oZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZSA9IHRleHQoKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3BsYXlOYW1lWzBdID09PSAnXFxcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWUuc3Vic3RyaW5nKDEsIGRpc3BsYXlOYW1lLmxlbmd0aC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7IH0sXG4gICAgICAgICAgXCJxXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicVwiLCBkZXNjcmlwdGlvbjogXCJcXFwicVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnBhcmFtcykgb3B0aW9ucy5kYXRhLnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXNbJ3EnXSA9IHE7IH0sXG4gICAgICAgICAgXCJleHBpcmVzXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZXhwaXJlc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiZXhwaXJlc1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGV4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnBhcmFtcykgb3B0aW9ucy5kYXRhLnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXNbJ2V4cGlyZXMnXSA9IGV4cGlyZXM7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZGVsdGFfc2Vjb25kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChkZWx0YV9zZWNvbmRzLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBcIjBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIwXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGV4dCgpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihwYXJhbSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnBhcmFtcykgb3B0aW9ucy5kYXRhLnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zW3BhcmFtLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7fSxcbiAgICAgICAgICBcInJlbmRlclwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJlbmRlclwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVuZGVyXFxcIlwiIH0sXG4gICAgICAgICAgXCJzZXNzaW9uXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic2Vzc2lvblwiLCBkZXNjcmlwdGlvbjogXCJcXFwic2Vzc2lvblxcXCJcIiB9LFxuICAgICAgICAgIFwiaWNvblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImljb25cIiwgZGVzY3JpcHRpb246IFwiXFxcImljb25cXFwiXCIgfSxcbiAgICAgICAgICBcImFsZXJ0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYWxlcnRcIiwgZGVzY3JpcHRpb246IFwiXFxcImFsZXJ0XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ0NvbnRlbnRfRGlzcG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnR5cGUgPSB0ZXh0KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcImhhbmRsaW5nXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiaGFuZGxpbmdcIiwgZGVzY3JpcHRpb246IFwiXFxcImhhbmRsaW5nXFxcIlwiIH0sXG4gICAgICAgICAgXCJvcHRpb25hbFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm9wdGlvbmFsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJvcHRpb25hbFxcXCJcIiB9LFxuICAgICAgICAgIFwicmVxdWlyZWRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZXF1aXJlZFwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVxdWlyZWRcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBwYXJzZUludChsZW5ndGguam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHRleHQoKTsgfSxcbiAgICAgICAgICBcInRleHRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0ZXh0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0ZXh0XFxcIlwiIH0sXG4gICAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImltYWdlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJpbWFnZVxcXCJcIiB9LFxuICAgICAgICAgIFwiYXVkaW9cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhdWRpb1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiYXVkaW9cXFwiXCIgfSxcbiAgICAgICAgICBcInZpZGVvXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidmlkZW9cIiwgZGVzY3JpcHRpb246IFwiXFxcInZpZGVvXFxcIlwiIH0sXG4gICAgICAgICAgXCJhcHBsaWNhdGlvblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImFwcGxpY2F0aW9uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhcHBsaWNhdGlvblxcXCJcIiB9LFxuICAgICAgICAgIFwibWVzc2FnZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1lc3NhZ2VcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1lc3NhZ2VcXFwiXCIgfSxcbiAgICAgICAgICBcIm11bHRpcGFydFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm11bHRpcGFydFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibXVsdGlwYXJ0XFxcIlwiIH0sXG4gICAgICAgICAgXCJ4LVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIngtXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ4LVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGNzZXFfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudmFsdWU9cGFyc2VJbnQoY3NlcV92YWx1ZS5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXhwaXJlcykge29wdGlvbnMuZGF0YSA9IGV4cGlyZXM7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXZlbnRfdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmV2ZW50ID0gZXZlbnRfdHlwZS50b0xvd2VyQ2FzZSgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gb3B0aW9ucy5kYXRhLnRhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnKSB7b3B0aW9ucy5kYXRhLnNldFBhcmFtKCd0YWcnLHRhZyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0YWdcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0YWdcIiwgZGVzY3JpcHRpb246IFwiXFxcInRhZ1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHRhZykge29wdGlvbnMuZGF0YS50YWcgPSB0YWc7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZm9yd2FyZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBwYXJzZUludChmb3J3YXJkcy5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24obWluX2V4cGlyZXMpIHtvcHRpb25zLmRhdGEgPSBtaW5fZXhwaXJlczsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcImRpZ2VzdFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIkRpZ2VzdFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiRGlnZXN0XFxcIlwiIH0sXG4gICAgICAgICAgXCJyZWFsbVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJlYWxtXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyZWFsbVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHJlYWxtKSB7IG9wdGlvbnMuZGF0YS5yZWFsbSA9IHJlYWxtOyB9LFxuICAgICAgICAgIFwiZG9tYWluXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZG9tYWluXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJkb21haW5cXFwiXCIgfSxcbiAgICAgICAgICBcIm5vbmNlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibm9uY2VcIiwgZGVzY3JpcHRpb246IFwiXFxcIm5vbmNlXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24obm9uY2UpIHsgb3B0aW9ucy5kYXRhLm5vbmNlPW5vbmNlOyB9LFxuICAgICAgICAgIFwib3BhcXVlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwib3BhcXVlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJvcGFxdWVcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihvcGFxdWUpIHsgb3B0aW9ucy5kYXRhLm9wYXF1ZT1vcGFxdWU7IH0sXG4gICAgICAgICAgXCJzdGFsZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInN0YWxlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzdGFsZVxcXCJcIiB9LFxuICAgICAgICAgIFwidHJ1ZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRydWVcIiwgZGVzY3JpcHRpb246IFwiXFxcInRydWVcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgb3B0aW9ucy5kYXRhLnN0YWxlPXRydWU7IH0sXG4gICAgICAgICAgXCJmYWxzZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImZhbHNlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJmYWxzZVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyBvcHRpb25zLmRhdGEuc3RhbGU9ZmFsc2U7IH0sXG4gICAgICAgICAgXCJhbGdvcml0aG1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhbGdvcml0aG1cIiwgZGVzY3JpcHRpb246IFwiXFxcImFsZ29yaXRobVxcXCJcIiB9LFxuICAgICAgICAgIFwibWQ1XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiTUQ1XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJNRDVcXFwiXCIgfSxcbiAgICAgICAgICBcIm1kNS1zZXNzXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiTUQ1LXNlc3NcIiwgZGVzY3JpcHRpb246IFwiXFxcIk1ENS1zZXNzXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5hbGdvcml0aG09YWxnb3JpdGhtLnRvVXBwZXJDYXNlKCk7IH0sXG4gICAgICAgICAgXCJxb3BcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJxb3BcIiwgZGVzY3JpcHRpb246IFwiXFxcInFvcFxcXCJcIiB9LFxuICAgICAgICAgIFwiYXV0aC1pbnRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhdXRoLWludFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYXV0aC1pbnRcXFwiXCIgfSxcbiAgICAgICAgICBcImF1dGhcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhdXRoXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhdXRoXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocW9wX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnFvcCB8fCAob3B0aW9ucy5kYXRhLnFvcD1bXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnFvcC5wdXNoKHFvcF92YWx1ZS50b0xvd2VyQ2FzZSgpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihyYWNrX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnZhbHVlPXBhcnNlSW50KHJhY2tfdmFsdWUuam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHgsIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyW2lkeF0ucGFyc2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyKSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IG5ldyBvcHRpb25zLlNJUC5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51cmk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyLnB1c2goIHsgJ3Bvc2l0aW9uJzogcGVnJGN1cnJQb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0Jzogb2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyc2VkJzogaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7fSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG5ldyBvcHRpb25zLlNJUC5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG9wdGlvbnMuZGF0YS5yZXBsYWNlc19mcm9tX3RhZyAmJiBvcHRpb25zLmRhdGEucmVwbGFjZXNfdG9fdGFnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbF9pZDogb3B0aW9ucy5kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwiZnJvbS10YWdcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJmcm9tLXRhZ1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiZnJvbS10YWdcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihmcm9tX3RhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmVwbGFjZXNfZnJvbV90YWcgPSBmcm9tX3RhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0by10YWdcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0by10YWdcIiwgZGVzY3JpcHRpb246IFwiXFxcInRvLXRhZ1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHRvX3RhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmVwbGFjZXNfdG9fdGFnID0gdG9fdGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcImVhcmx5LW9ubHlcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJlYXJseS1vbmx5XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJlYXJseS1vbmx5XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5lYXJseV9vbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocikge3JldHVybiByO30sXG4gICAgICAgICAgZnVuY3Rpb24oZmlyc3QsIHJlc3QpIHsgcmV0dXJuIGxpc3QoZmlyc3QsIHJlc3QpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1JlcXVpcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gdmFsdWUgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocnNlcV92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS52YWx1ZT1wYXJzZUludChyc2VxX3ZhbHVlLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBcImFjdGl2ZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImFjdGl2ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYWN0aXZlXFxcIlwiIH0sXG4gICAgICAgICAgXCJwZW5kaW5nXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicGVuZGluZ1wiLCBkZXNjcmlwdGlvbjogXCJcXFwicGVuZGluZ1xcXCJcIiB9LFxuICAgICAgICAgIFwidGVybWluYXRlZFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRlcm1pbmF0ZWRcIiwgZGVzY3JpcHRpb246IFwiXFxcInRlcm1pbmF0ZWRcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuc3RhdGUgPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgXCJyZWFzb25cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZWFzb25cIiwgZGVzY3JpcHRpb246IFwiXFxcInJlYXNvblxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhc29uICE9PSAndW5kZWZpbmVkJykgb3B0aW9ucy5kYXRhLnJlYXNvbiA9IHJlYXNvbjsgfSxcbiAgICAgICAgICBmdW5jdGlvbihleHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBpcmVzICE9PSAndW5kZWZpbmVkJykgb3B0aW9ucy5kYXRhLmV4cGlyZXMgPSBleHBpcmVzOyB9LFxuICAgICAgICAgIFwicmV0cnlfYWZ0ZXJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZXRyeV9hZnRlclwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmV0cnlfYWZ0ZXJcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihyZXRyeV9hZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0cnlfYWZ0ZXIgIT09ICd1bmRlZmluZWQnKSBvcHRpb25zLmRhdGEucmV0cnlfYWZ0ZXIgPSByZXRyeV9hZnRlcjsgfSxcbiAgICAgICAgICBcImRlYWN0aXZhdGVkXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZGVhY3RpdmF0ZWRcIiwgZGVzY3JpcHRpb246IFwiXFxcImRlYWN0aXZhdGVkXFxcIlwiIH0sXG4gICAgICAgICAgXCJwcm9iYXRpb25cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJwcm9iYXRpb25cIiwgZGVzY3JpcHRpb246IFwiXFxcInByb2JhdGlvblxcXCJcIiB9LFxuICAgICAgICAgIFwicmVqZWN0ZWRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZWplY3RlZFwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVqZWN0ZWRcXFwiXCIgfSxcbiAgICAgICAgICBcInRpbWVvdXRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0aW1lb3V0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0aW1lb3V0XFxcIlwiIH0sXG4gICAgICAgICAgXCJnaXZldXBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJnaXZldXBcIiwgZGVzY3JpcHRpb246IFwiXFxcImdpdmV1cFxcXCJcIiB9LFxuICAgICAgICAgIFwibm9yZXNvdXJjZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm5vcmVzb3VyY2VcIiwgZGVzY3JpcHRpb246IFwiXFxcIm5vcmVzb3VyY2VcXFwiXCIgfSxcbiAgICAgICAgICBcImludmFyaWFudFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImludmFyaWFudFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiaW52YXJpYW50XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnU3VwcG9ydGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHZhbHVlIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IG9wdGlvbnMuZGF0YS50YWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG5ldyBvcHRpb25zLlNJUC5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnKSB7b3B0aW9ucy5kYXRhLnNldFBhcmFtKCd0YWcnLHRhZyl9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwidHRsXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidHRsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0dGxcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih2aWFfdHRsX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS50dGwgPSB2aWFfdHRsX3ZhbHVlOyB9LFxuICAgICAgICAgIFwibWFkZHJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtYWRkclwiLCBkZXNjcmlwdGlvbjogXCJcXFwibWFkZHJcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih2aWFfbWFkZHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm1hZGRyID0gdmlhX21hZGRyOyB9LFxuICAgICAgICAgIFwicmVjZWl2ZWRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZWNlaXZlZFwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVjZWl2ZWRcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih2aWFfcmVjZWl2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlY2VpdmVkID0gdmlhX3JlY2VpdmVkOyB9LFxuICAgICAgICAgIFwiYnJhbmNoXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYnJhbmNoXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJicmFuY2hcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih2aWFfYnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5icmFuY2ggPSB2aWFfYnJhbmNoOyB9LFxuICAgICAgICAgIFwicnBvcnRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJycG9ydFwiLCBkZXNjcmlwdGlvbjogXCJcXFwicnBvcnRcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHJlc3BvbnNlX3BvcnQgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ycG9ydCA9IHJlc3BvbnNlX3BvcnQuam9pbignJyk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX3Byb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wcm90b2NvbCA9IHZpYV9wcm90b2NvbDsgfSxcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJVRFBcIiwgZGVzY3JpcHRpb246IFwiXFxcIlVEUFxcXCJcIiB9LFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlRDUFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiVENQXFxcIlwiIH0sXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiVExTXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJUTFNcXFwiXCIgfSxcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJTQ1RQXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJTQ1RQXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX3RyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudHJhbnNwb3J0ID0gdmlhX3RyYW5zcG9ydDsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3QgPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX3NlbnRfYnlfcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucG9ydCA9IHBhcnNlSW50KHZpYV9zZW50X2J5X3BvcnQuam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHR0bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodHRsLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihkZWx0YVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnU2Vzc2lvbl9FeHBpcmVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5kZWx0YVNlY29uZHMgPSBkZWx0YVNlY29uZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZWZyZXNoZXJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZWZyZXNoZXJcIiwgZGVzY3JpcHRpb246IFwiXFxcInJlZnJlc2hlclxcXCJcIiB9LFxuICAgICAgICAgIFwidWFzXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidWFzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ1YXNcXFwiXCIgfSxcbiAgICAgICAgICBcInVhY1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInVhY1wiLCBkZXNjcmlwdGlvbjogXCJcXFwidWFjXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnU2Vzc2lvbl9FeHBpcmVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZWZyZXNoZXIgPSBlbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihkZWx0YVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnTWluX1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IGRlbHRhU2Vjb25kcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcInN0dW5zXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic3R1bnNcIiwgZGVzY3JpcHRpb246IFwiXFxcInN0dW5zXFxcIlwiIH0sXG4gICAgICAgICAgXCJzdHVuXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic3R1blwiLCBkZXNjcmlwdGlvbjogXCJcXFwic3R1blxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuc2NoZW1lID0gc2NoZW1lOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3QgPSBob3N0OyB9LFxuICAgICAgICAgIFwiP3RyYW5zcG9ydD1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI/dHJhbnNwb3J0PVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiP3RyYW5zcG9ydD1cXFwiXCIgfSxcbiAgICAgICAgICBcInR1cm5zXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidHVybnNcIiwgZGVzY3JpcHRpb246IFwiXFxcInR1cm5zXFxcIlwiIH0sXG4gICAgICAgICAgXCJ0dXJuXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidHVyblwiLCBkZXNjcmlwdGlvbjogXCJcXFwidHVyblxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudHJhbnNwb3J0ID0gdHJhbnNwb3J0OyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHRleHQoKTsgfVxuICAgICAgICBdLFxuXG4gICAgICAgIHBlZyRieXRlY29kZSA9IFtcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLiBcXFwiXFxcIjIgMyFcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjBcXFwiXFxcIlxcXCIxITMjXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwJFxcXCJcXFwiMSEzJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMCZcXFwiXFxcIjEhMydcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcnKiMgXFxcIjcoXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwKFxcXCJcXFwiMSEzKVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMCpcXFwiXFxcIjEhMytcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi4sXFxcIlxcXCIyLDMtXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuLlxcXCJcXFwiMi4zL1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMDBcXFwiXFxcIjEhMzFcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi4yXFxcIlxcXCIyMjMzKlxceDg5IFxcXCIuNFxcXCJcXFwiMjQzNSp9IFxcXCIuNlxcXCJcXFwiMjYzNypxIFxcXCIuOFxcXCJcXFwiMjgzOSplIFxcXCIuOlxcXCJcXFwiMjozOypZIFxcXCIuPFxcXCJcXFwiMjwzPSpNIFxcXCIuPlxcXCJcXFwiMj4zPypBIFxcXCIuQFxcXCJcXFwiMkAzQSo1IFxcXCIuQlxcXCJcXFwiMkIzQyopIFxcXCIuRFxcXCJcXFwiMkQzRVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNykqIyBcXFwiNyxcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5GXFxcIlxcXCIyRjNHKn0gXFxcIi5IXFxcIlxcXCIySDNJKnEgXFxcIi5KXFxcIlxcXCIySjNLKmUgXFxcIi5MXFxcIlxcXCIyTDNNKlkgXFxcIi5OXFxcIlxcXCIyTjNPKk0gXFxcIi5QXFxcIlxcXCIyUDNRKkEgXFxcIi5SXFxcIlxcXCIyUjNTKjUgXFxcIi5UXFxcIlxcXCIyVDNVKikgXFxcIi5WXFxcIlxcXCIyVjNXXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIS5ZXFxcIlxcXCIyWTNaKzckNyMrLSU3IysjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhIFxcXFw3JCwjJjckXFxcIistJDcgKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK0AkIFxcXFw3JCsmJCwjJjckXFxcIlxcXCJcXFwiIFgrJyU0XFxcIjZdXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3LiojIFxcXCIgW1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNycqIyBcXFwiNygsKSY3JyojIFxcXCI3KFxcXCIrQSQuOFxcXCJcXFwiMjgzOSsxJTcvKyclNCM2XiMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhISBcXFxcNzIrJiQsIyY3MlxcXCJcXFwiXFxcIiBYK28kIFxcXFwhIFxcXFw3LiwjJjcuXFxcIistJDcyKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLEAmISBcXFxcNy4sIyY3LlxcXCIrLSQ3MisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMF9cXFwiXFxcIjEhM2AqIyBcXFwiNzNcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjBhXFxcIlxcXCIxITNiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwY1xcXCJcXFwiMSEzZFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNyEqKSBcXFwiMGVcXFwiXFxcIjEhM2ZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDcpKlxceDk1IFxcXCIuRlxcXCJcXFwiMkYzRypcXHg4OSBcXFwiLkpcXFwiXFxcIjJKM0sqfSBcXFwiLkxcXFwiXFxcIjJMM00qcSBcXFwiLllcXFwiXFxcIjJZM1oqZSBcXFwiLlBcXFwiXFxcIjJQM1EqWSBcXFwiLkhcXFwiXFxcIjJIM0kqTSBcXFwiLkBcXFwiXFxcIjJAM0EqQSBcXFwiLmdcXFwiXFxcIjJnM2gqNSBcXFwiLlJcXFwiXFxcIjJSM1MqKSBcXFwiLk5cXFwiXFxcIjJOM08rXFx4OUUkLFxceDlCJjcpKlxceDk1IFxcXCIuRlxcXCJcXFwiMkYzRypcXHg4OSBcXFwiLkpcXFwiXFxcIjJKM0sqfSBcXFwiLkxcXFwiXFxcIjJMM00qcSBcXFwiLllcXFwiXFxcIjJZM1oqZSBcXFwiLlBcXFwiXFxcIjJQM1EqWSBcXFwiLkhcXFwiXFxcIjJIM0kqTSBcXFwiLkBcXFwiXFxcIjJAM0EqQSBcXFwiLmdcXFwiXFxcIjJnM2gqNSBcXFwiLlJcXFwiXFxcIjJSM1MqKSBcXFwiLk5cXFwiXFxcIjJOM09cXFwiXFxcIlxcXCIgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3KSpcXHg4OSBcXFwiLkZcXFwiXFxcIjJGM0cqfSBcXFwiLkxcXFwiXFxcIjJMM00qcSBcXFwiLllcXFwiXFxcIjJZM1oqZSBcXFwiLlBcXFwiXFxcIjJQM1EqWSBcXFwiLkhcXFwiXFxcIjJIM0kqTSBcXFwiLkBcXFwiXFxcIjJAM0EqQSBcXFwiLmdcXFwiXFxcIjJnM2gqNSBcXFwiLlJcXFwiXFxcIjJSM1MqKSBcXFwiLk5cXFwiXFxcIjJOM08rXFx4OTIkLFxceDhGJjcpKlxceDg5IFxcXCIuRlxcXCJcXFwiMkYzRyp9IFxcXCIuTFxcXCJcXFwiMkwzTSpxIFxcXCIuWVxcXCJcXFwiMlkzWiplIFxcXCIuUFxcXCJcXFwiMlAzUSpZIFxcXCIuSFxcXCJcXFwiMkgzSSpNIFxcXCIuQFxcXCJcXFwiMkAzQSpBIFxcXCIuZ1xcXCJcXFwiMmczaCo1IFxcXCIuUlxcXCJcXFwiMlIzUyopIFxcXCIuTlxcXCJcXFwiMk4zT1xcXCJcXFwiXFxcIiBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5UXFxcIlxcXCIyVDNVKlxceEUzIFxcXCIuVlxcXCJcXFwiMlYzVypcXHhENyBcXFwiLmlcXFwiXFxcIjJpM2oqXFx4Q0IgXFxcIi5rXFxcIlxcXCIyazNsKlxceEJGIFxcXCIuOlxcXCJcXFwiMjozOypcXHhCMyBcXFwiLkRcXFwiXFxcIjJEM0UqXFx4QTcgXFxcIi4yXFxcIlxcXCIyMjMzKlxceDlCIFxcXCIuOFxcXCJcXFwiMjgzOSpcXHg4RiBcXFwiLm1cXFwiXFxcIjJtM24qXFx4ODMgXFxcIjcmKn0gXFxcIi40XFxcIlxcXCIyNDM1KnEgXFxcIi5vXFxcIlxcXCIybzNwKmUgXFxcIi5xXFxcIlxcXCIycTNyKlkgXFxcIi42XFxcIlxcXCIyNjM3Kk0gXFxcIi4+XFxcIlxcXCIyPjM/KkEgXFxcIi5zXFxcIlxcXCIyczN0KjUgXFxcIi51XFxcIlxcXCIydTN2KikgXFxcIjcnKiMgXFxcIjcoXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3KSpcXHUwMTJCIFxcXCIuRlxcXCJcXFwiMkYzRypcXHUwMTFGIFxcXCIuSlxcXCJcXFwiMkozSypcXHUwMTEzIFxcXCIuTFxcXCJcXFwiMkwzTSpcXHUwMTA3IFxcXCIuWVxcXCJcXFwiMlkzWipcXHhGQiBcXFwiLlBcXFwiXFxcIjJQM1EqXFx4RUYgXFxcIi5IXFxcIlxcXCIySDNJKlxceEUzIFxcXCIuQFxcXCJcXFwiMkAzQSpcXHhENyBcXFwiLmdcXFwiXFxcIjJnM2gqXFx4Q0IgXFxcIi5SXFxcIlxcXCIyUjNTKlxceEJGIFxcXCIuTlxcXCJcXFwiMk4zTypcXHhCMyBcXFwiLlRcXFwiXFxcIjJUM1UqXFx4QTcgXFxcIi5WXFxcIlxcXCIyVjNXKlxceDlCIFxcXCIuaVxcXCJcXFwiMmkzaipcXHg4RiBcXFwiLmtcXFwiXFxcIjJrM2wqXFx4ODMgXFxcIi44XFxcIlxcXCIyODM5KncgXFxcIi5tXFxcIlxcXCIybTNuKmsgXFxcIjcmKmUgXFxcIi40XFxcIlxcXCIyNDM1KlkgXFxcIi5vXFxcIlxcXCIybzNwKk0gXFxcIi5xXFxcIlxcXCIycTNyKkEgXFxcIi42XFxcIlxcXCIyNjM3KjUgXFxcIi5zXFxcIlxcXCIyczN0KikgXFxcIi51XFxcIlxcXCIydTN2K1xcdTAxMzQkLFxcdTAxMzEmNykqXFx1MDEyQiBcXFwiLkZcXFwiXFxcIjJGM0cqXFx1MDExRiBcXFwiLkpcXFwiXFxcIjJKM0sqXFx1MDExMyBcXFwiLkxcXFwiXFxcIjJMM00qXFx1MDEwNyBcXFwiLllcXFwiXFxcIjJZM1oqXFx4RkIgXFxcIi5QXFxcIlxcXCIyUDNRKlxceEVGIFxcXCIuSFxcXCJcXFwiMkgzSSpcXHhFMyBcXFwiLkBcXFwiXFxcIjJAM0EqXFx4RDcgXFxcIi5nXFxcIlxcXCIyZzNoKlxceENCIFxcXCIuUlxcXCJcXFwiMlIzUypcXHhCRiBcXFwiLk5cXFwiXFxcIjJOM08qXFx4QjMgXFxcIi5UXFxcIlxcXCIyVDNVKlxceEE3IFxcXCIuVlxcXCJcXFwiMlYzVypcXHg5QiBcXFwiLmlcXFwiXFxcIjJpM2oqXFx4OEYgXFxcIi5rXFxcIlxcXCIyazNsKlxceDgzIFxcXCIuOFxcXCJcXFwiMjgzOSp3IFxcXCIubVxcXCJcXFwiMm0zbiprIFxcXCI3JiplIFxcXCIuNFxcXCJcXFwiMjQzNSpZIFxcXCIub1xcXCJcXFwiMm8zcCpNIFxcXCIucVxcXCJcXFwiMnEzcipBIFxcXCIuNlxcXCJcXFwiMjYzNyo1IFxcXCIuc1xcXCJcXFwiMnMzdCopIFxcXCIudVxcXCJcXFwiMnUzdlxcXCJcXFwiXFxcIiBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC5QXFxcIlxcXCIyUDNRKzElNy8rJyU0IzZ3IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC40XFxcIlxcXCIyNDM1KzElNy8rJyU0IzZ4IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC4+XFxcIlxcXCIyPjM/KzElNy8rJyU0IzZ5IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC5UXFxcIlxcXCIyVDNVKzElNy8rJyU0IzZ6IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC5WXFxcIlxcXCIyVjNXKzElNy8rJyU0IzZ7IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEua1xcXCJcXFwiMmszbCsxJDcvKyclNFxcXCI2fFxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvKzckLmlcXFwiXFxcIjJpM2orJyU0XFxcIjZ9XFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuRFxcXCJcXFwiMkQzRSsxJTcvKyclNCM2fiMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuMlxcXCJcXFwiMjIzMysxJTcvKyclNCM2fyMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuOFxcXCJcXFwiMjgzOSsxJTcvKyclNCM2XFx4ODAjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvKzEkNyYrJyU0XFxcIjZcXHg4MVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcmKzEkNy8rJyU0XFxcIjZcXHg4MVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc9K1ckIFxcXFw3RyopIFxcXCI3SyojIFxcXCI3RiwvJjdHKikgXFxcIjdLKiMgXFxcIjdGXFxcIistJTc+KyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjBcXHg4MlxcXCJcXFwiMSEzXFx4ODMqQSBcXFwiMFxceDg0XFxcIlxcXCIxITNcXHg4NSo1IFxcXCIwXFx4ODZcXFwiXFxcIjEhM1xceDg3KikgXFxcIjczKiMgXFxcIjcuXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITcvK1UkNyYrSyUgXFxcXDdKKiMgXFxcIjdLLCkmN0oqIyBcXFwiN0tcXFwiKy0lNyYrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytgJDcmK1YlISBcXFxcN0oqIyBcXFwiN0ssKSY3SiojIFxcXCI3S1xcXCIrISAoJSsyJTcmKyglNCQ2XFx4ODgkISElJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNy4qRyBcXFwiLkxcXFwiXFxcIjJMM00qOyBcXFwiMFxceDg5XFxcIlxcXCIxITNcXHg4QSovIFxcXCIwXFx4ODZcXFwiXFxcIjEhM1xceDg3KiMgXFxcIjczXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLm1cXFwiXFxcIjJtM24rSyQwXFx4OEJcXFwiXFxcIjEhM1xceDhDKjUgXFxcIjBcXHg4RFxcXCJcXFwiMSEzXFx4OEUqKSBcXFwiMFxceDhGXFxcIlxcXCIxITNcXHg5MCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdOK1EkLjhcXFwiXFxcIjI4MzkrQSU3TyojIFxcXCIgWysxJTdTKyclNCQ2XFx4OTEkICUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN04rayQuOFxcXCJcXFwiMjgzOStbJTdPKiMgXFxcIiBbK0slN1MrQSU3Xys3JTdsKiMgXFxcIiBbKyclNCY2XFx4OTImICUkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHg5M1xcXCJcXFwiMSQzXFx4OTQqKSBcXFwiL1xceDk1XFxcIlxcXCIxIzNcXHg5NisnIDQhNlxceDk3ISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdQK2IkIS44XFxcIlxcXCIyODM5Ky0kN1IrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrNyUuOlxcXCJcXFwiMjozOysnJTQjNlxceDk4IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcNysqKSBcXFwiNy0qIyBcXFwiN1ErMiQsLyY3KyopIFxcXCI3LSojIFxcXCI3UVxcXCJcXFwiXFxcIiBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuPFxcXCJcXFwiMjwzPSpxIFxcXCIuPlxcXCJcXFwiMj4zPyplIFxcXCIuQFxcXCJcXFwiMkAzQSpZIFxcXCIuQlxcXCJcXFwiMkIzQypNIFxcXCIuRFxcXCJcXFwiMkQzRSpBIFxcXCIuMlxcXCJcXFwiMjIzMyo1IFxcXCIuNlxcXCJcXFwiMjYzNyopIFxcXCIuNFxcXCJcXFwiMjQzNVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNysqXyBcXFwiNy0qWSBcXFwiLjxcXFwiXFxcIjI8Mz0qTSBcXFwiLj5cXFwiXFxcIjI+Mz8qQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkJcXFwiXFxcIjJCM0MqKSBcXFwiLkRcXFwiXFxcIjJEM0UsZSY3KypfIFxcXCI3LSpZIFxcXCIuPFxcXCJcXFwiMjwzPSpNIFxcXCIuPlxcXCJcXFwiMj4zPypBIFxcXCIuQFxcXCJcXFwiMkAzQSo1IFxcXCIuQlxcXCJcXFwiMkIzQyopIFxcXCIuRFxcXCJcXFwiMkQzRVxcXCIrJiA0ITZcXHg5OSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdUK04kIS44XFxcIlxcXCIyODM5Ky0kN14rIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3VSopIFxcXCI3XFxcXCojIFxcXCI3WCsmIDQhNlxceDlBISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFwhN1YrMyQuSlxcXCJcXFwiMkozSysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw+JiE3ViszJC5KXFxcIlxcXCIySjNLKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIitHJDdXKz0lLkpcXFwiXFxcIjJKM0sqIyBcXFwiIFsrJyU0IzZcXHg5QiMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDBcXHg5Q1xcXCJcXFwiMSEzXFx4OUQrLCQsKSYwXFx4OUNcXFwiXFxcIjEhM1xceDlEXFxcIlxcXCJcXFwiIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEwJFxcXCJcXFwiMSEzJStBJCBcXFxcMFxceDlFXFxcIlxcXCIxITNcXHg5RiwpJjBcXHg5RVxcXCJcXFwiMSEzXFx4OUZcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLm9cXFwiXFxcIjJvM3ArQSQ3WSs3JS5xXFxcIlxcXCIycTNyKyclNCM2XFx4QTAjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3WitcXHhCRiQuOFxcXCJcXFwiMjgzOStcXHhBRiU3WitcXHhBNSUuOFxcXCJcXFwiMjgzOStcXHg5NSU3WitcXHg4QiUuOFxcXCJcXFwiMjgzOSt7JTdaK3ElLjhcXFwiXFxcIjI4MzkrYSU3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJy0lJC0jIFgkLCMgWCQrIyBYJCojIFgkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwODM4IFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrXFx4QUYkN1orXFx4QTUlLjhcXFwiXFxcIjI4MzkrXFx4OTUlN1orXFx4OEIlLjhcXFwiXFxcIjI4MzkreyU3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScsJSQsIyBYJCsjIFgkKiMgWCQpIyBYJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTA3OTUgXFxcIiEuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMitcXHg5NSQ3WitcXHg4QiUuOFxcXCJcXFwiMjgzOSt7JTdaK3ElLjhcXFwiXFxcIjI4MzkrYSU3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyolJCojIFgkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNzBDIFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIreyQ3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScoJSQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNjlEIFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrYSQ3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyYlJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDY0OCBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK0ckN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNjBEIFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrLSQ3WysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCpcXHUwNUVDIFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCpcXHUwNUNCIFxcXCIhN1orXFx4QTUkLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrXFx4OTUlN1orXFx4OEIlLjhcXFwiXFxcIjI4MzkreyU3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScrJSQrIyBYJCojIFgkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNTM4IFxcXCIhN1orXFx4QjYkIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4OEIlLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIreyU3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScqJSQqIyBYJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDQ5NCBcXFwiITdaK1xceEM3JCEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceDlDJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK3ElLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrYSU3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyklJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDNERiBcXFwiITdaK1xceEQ4JCEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceEFEJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceDgyJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1clLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnKCUkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDMxOSBcXFwiITdaK1xceEU5JCEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceEJFJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceDkzJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK2glIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrPSUuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMistJTdbKyMlJyclJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwMjQyIFxcXCIhN1orXFx1MDExNCQhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhFOSUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhCRSUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHg5MyUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytoJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKz0lLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrLSU3WisjJScoJSQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwMTQwIFxcXCIhN1orXFx1MDEzNSQhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHUwMTBBJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceERGJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceEI0JSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceDg5JSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK14lIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrMyUuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMisjJScoJSQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCsmIDQhNlxceEEzISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNyMrUyQ3IyojIFxcXCIgWytDJTcjKiMgXFxcIiBbKzMlNyMqIyBcXFwiIFsrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1orPSQuOFxcXCJcXFwiMjgzOSstJTdaKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFgqIyBcXFwiN1xcXFxcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XSt1JC5KXFxcIlxcXCIySjNLK2UlN10rWyUuSlxcXCJcXFwiMkozSytLJTddK0ElLkpcXFwiXFxcIjJKM0srMSU3XSsnJTQnNlxceEE0JyAlJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHhBNVxcXCJcXFwiMlxceEE1M1xceEE2KzMkMFxceEE3XFxcIlxcXCIxITNcXHhBOCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCpcXHhBMCBcXFwiIS5cXHhBOVxcXCJcXFwiMlxceEE5M1xceEFBKz0kMFxceEFCXFxcIlxcXCIxITNcXHhBQystJTchKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFgqbyBcXFwiIS5cXHhBRFxcXCJcXFwiMlxceEFEM1xceEFFKzckNyErLSU3ISsjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYKkQgXFxcIiEwXFx4QUZcXFwiXFxcIjEhM1xceEIwKy0kNyErIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiNyFcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhNyEqIyBcXFwiIFsrYyQ3ISojIFxcXCIgWytTJTchKiMgXFxcIiBbK0MlNyEqIyBcXFwiIFsrMyU3ISojIFxcXCIgWysjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCsnIDQhNlxceEIxISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFwhLjJcXFwiXFxcIjIyMzMrLSQ3YCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw+JiEuMlxcXCJcXFwiMjIzMystJDdgKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN2EqQSBcXFwiN2IqOyBcXFwiN2MqNSBcXFwiN2QqLyBcXFwiN2UqKSBcXFwiN2YqIyBcXFwiN2dcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4QjJcXFwiXFxcIjEqM1xceEIzK2IkL1xceEI0XFxcIlxcXCIxIzNcXHhCNSpHIFxcXCIvXFx4QjZcXFwiXFxcIjEjM1xceEI3KjsgXFxcIi9cXHhCOFxcXCJcXFwiMSQzXFx4QjkqLyBcXFwiL1xceEJBXFxcIlxcXCIxIzNcXHhCQiojIFxcXCI3NisoJTRcXFwiNlxceEJDXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhCRFxcXCJcXFwiMSUzXFx4QkUrSiQvXFx4QkZcXFwiXFxcIjElM1xceEMwKi8gXFxcIi9cXHhDMVxcXCJcXFwiMVxcXCIzXFx4QzIqIyBcXFwiNzYrKCU0XFxcIjZcXHhDM1xcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4QzRcXFwiXFxcIjEnM1xceEM1KzIkN1xceDhGKyglNFxcXCI2XFx4QzZcXFwiISAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEM3XFxcIlxcXCIxJDNcXHhDOCsyJDdcXHhFRisoJTRcXFwiNlxceEM5XFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhDQVxcXCJcXFwiMSYzXFx4Q0IrMiQ3VCsoJTRcXFwiNlxceENDXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhDRFxcXCJcXFwiMVxcXCIzXFx4Q0UrUiQhLj5cXFwiXFxcIjI+Mz8rLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysnJTRcXFwiNlxceENGXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN2grVCQhLj5cXFwiXFxcIjI+Mz8rLSQ3aSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWyspJTRcXFwiNlxceEQwXFxcIlxcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDdqKyYkLCMmN2pcXFwiXFxcIlxcXCIgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3aismJCwjJjdqXFxcIlxcXCJcXFwiIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN2sqKSBcXFwiNysqIyBcXFwiNy1cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5vXFxcIlxcXCIybzNwKmUgXFxcIi5xXFxcIlxcXCIycTNyKlkgXFxcIi40XFxcIlxcXCIyNDM1Kk0gXFxcIi44XFxcIlxcXCIyODM5KkEgXFxcIi48XFxcIlxcXCIyPDM9KjUgXFxcIi5AXFxcIlxcXCIyQDNBKikgXFxcIi5CXFxcIlxcXCIyQjNDXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLjZcXFwiXFxcIjI2MzcrdSQ3bStrJSBcXFxcIS48XFxcIlxcXCIyPDM9Ky0kN20rIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLjxcXFwiXFxcIjI8Mz0rLSQ3bSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITduK0MkLj5cXFwiXFxcIjI+Mz8rMyU3byspJTQjNlxceEQxI1xcXCJcXFwiICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3cCopIFxcXCI3KyojIFxcXCI3LSsyJCwvJjdwKikgXFxcIjcrKiMgXFxcIjctXFxcIlxcXCJcXFwiIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcN3AqKSBcXFwiNysqIyBcXFwiNy0sLyY3cCopIFxcXCI3KyojIFxcXCI3LVxcXCJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5vXFxcIlxcXCIybzNwKmUgXFxcIi5xXFxcIlxcXCIycTNyKlkgXFxcIi40XFxcIlxcXCIyNDM1Kk0gXFxcIi42XFxcIlxcXCIyNjM3KkEgXFxcIi44XFxcIlxcXCIyODM5KjUgXFxcIi5AXFxcIlxcXCIyQDNBKikgXFxcIi5CXFxcIlxcXCIyQjNDXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4OTAqIyBcXFwiN3JcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OEYrSyQ3JytBJTdzKzclNycrLSU3XFx4ODQrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdNKiMgXFxcIjd0XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN38rRyQuOFxcXCJcXFwiMjgzOSs3JTd1KiMgXFxcIjd4KyclNCM2XFx4RDIjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITd2KiMgXFxcIjd3K04kIS42XFxcIlxcXCIyNjM3Ky0kN1xceDgzKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEQzXFxcIlxcXCIyXFx4RDMzXFx4RDQrPSQ3XFx4ODArMyU3dyojIFxcXCIgWysjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLjRcXFwiXFxcIjI0MzUrLSQ3eysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITd6KzUkIFxcXFw3eSwjJjd5XFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNyoqKSBcXFwiNysqIyBcXFwiNy1cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcrKlxceDhGIFxcXCI3LSpcXHg4OSBcXFwiLjJcXFwiXFxcIjIyMzMqfSBcXFwiLjZcXFwiXFxcIjI2MzcqcSBcXFwiLjhcXFwiXFxcIjI4MzkqZSBcXFwiLjpcXFwiXFxcIjI6MzsqWSBcXFwiLjxcXFwiXFxcIjI8Mz0qTSBcXFwiLj5cXFwiXFxcIjI+Mz8qQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkJcXFwiXFxcIjJCM0MqKSBcXFwiLkRcXFwiXFxcIjJEM0VcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3fCtrJCBcXFxcIS40XFxcIlxcXCIyNDM1Ky0kN3wrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLjRcXFwiXFxcIjI0MzUrLSQ3fCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDd+LCMmN35cXFwiK2skIFxcXFwhLjJcXFwiXFxcIjIyMzMrLSQ3fSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw+JiEuMlxcXCJcXFwiMjIzMystJDd9KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3fiwjJjd+XFxcIlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNysqdyBcXFwiNy0qcSBcXFwiLjhcXFwiXFxcIjI4MzkqZSBcXFwiLjpcXFwiXFxcIjI6MzsqWSBcXFwiLjxcXFwiXFxcIjI8Mz0qTSBcXFwiLj5cXFwiXFxcIjI+Mz8qQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkJcXFwiXFxcIjJCM0MqKSBcXFwiLkRcXFwiXFxcIjJEM0VcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFxcIitcXHg4RCQgXFxcXDdcXFwiKkcgXFxcIjchKkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5GXFxcIlxcXCIyRjNHKikgXFxcIi5KXFxcIlxcXCIySjNLLE0mN1xcXCIqRyBcXFwiNyEqQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkZcXFwiXFxcIjJGM0cqKSBcXFwiLkpcXFwiXFxcIjJKM0tcXFwiKyclNFxcXCI2XFx4RDVcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHg4MSojIFxcXCI3XFx4ODJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhN08rMyQuOlxcXCJcXFwiMjozOysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWystJDdTKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDcrKlxceDgzIFxcXCI3LSp9IFxcXCIuQlxcXCJcXFwiMkIzQypxIFxcXCIuRFxcXCJcXFwiMkQzRSplIFxcXCIuMlxcXCJcXFwiMjIzMypZIFxcXCIuOFxcXCJcXFwiMjgzOSpNIFxcXCIuOlxcXCJcXFwiMjozOypBIFxcXCIuPFxcXCJcXFwiMjwzPSo1IFxcXCIuPlxcXCJcXFwiMj4zPyopIFxcXCIuQFxcXCJcXFwiMkAzQStcXHg4QyQsXFx4ODkmNysqXFx4ODMgXFxcIjctKn0gXFxcIi5CXFxcIlxcXCIyQjNDKnEgXFxcIi5EXFxcIlxcXCIyRDNFKmUgXFxcIi4yXFxcIlxcXCIyMjMzKlkgXFxcIi44XFxcIlxcXCIyODM5Kk0gXFxcIi46XFxcIlxcXCIyOjM7KkEgXFxcIi48XFxcIlxcXCIyPDM9KjUgXFxcIi4+XFxcIlxcXCIyPjM/KikgXFxcIi5AXFxcIlxcXCIyQDNBXFxcIlxcXCJcXFwiIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcN3ksIyY3eVxcXCJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4OTVcXFwiXFxcIjEjM1xceEQ2K3kkLjRcXFwiXFxcIjI0MzUraSUgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCtQJS5KXFxcIlxcXCIySjNLK0AlIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrJyU0JTZcXHhENyUgJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEQ4XFxcIlxcXCIyXFx4RDgzXFx4RDlcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhEQVxcXCJcXFwiMlxceERBM1xceERCXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RENcXFwiXFxcIjJcXHhEQzNcXHhERFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceERFXFxcIlxcXCIyXFx4REUzXFx4REZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhFMFxcXCJcXFwiMlxceEUwM1xceEUxXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RTJcXFwiXFxcIjJcXHhFMjNcXHhFM1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEU0XFxcIlxcXCIyXFx4RTQzXFx4RTVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhFNlxcXCJcXFwiMlxceEU2M1xceEU3XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RThcXFwiXFxcIjJcXHhFODNcXHhFOVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEVBXFxcIlxcXCIyXFx4RUEzXFx4RUJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4ODUqUyBcXFwiN1xceDg2Kk0gXFxcIjdcXHg4OCpHIFxcXCI3XFx4ODkqQSBcXFwiN1xceDhBKjsgXFxcIjdcXHg4Qio1IFxcXCI3XFx4OEMqLyBcXFwiN1xceDhEKikgXFxcIjdcXHg4RSojIFxcXCI3NismIDQhNlxceEVDISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDg0K0skNycrQSU3XFx4OTErNyU3JystJTdcXHg5MysjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5MisnIDQhNlxceEVEISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITchKzckNyErLSU3ISsjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3KipBIFxcXCI3Kyo7IFxcXCI3LSo1IFxcXCI3MyovIFxcXCI3NCopIFxcXCI3JyojIFxcXCI3KCxHJjcqKkEgXFxcIjcrKjsgXFxcIjctKjUgXFxcIjczKi8gXFxcIjc0KikgXFxcIjcnKiMgXFxcIjcoXFxcIismIDQhNlxceEVFISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEI1K18kIFxcXFwhN0ErLSQ3XFx4QjUrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3XFx4QjUrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzkrUiQhLjpcXFwiXFxcIjI6MzsrLSQ3OSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysnJTRcXFwiNlxceEVGXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzoqaiBcXFwiITdcXHg5NytfJCBcXFxcITdBKy0kN1xceDk3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceDk3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCsmIDQhNlxceEYwISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN0wqIyBcXFwiN1xceDk4K2MkIFxcXFwhN0IrLSQ3XFx4OUErIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4OUErIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx4RjFcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTkqIyBcXFwiIFsrQSQ3QCs3JTdNKy0lNz8rIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITc2K18kIFxcXFwhNy4rLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3ListJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCI3SCsnIDQhNlxceEYyISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceDlCKikgXFxcIjdcXHg5QyojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4RjNcXFwiXFxcIjEhM1xceEY0KzwkNzwrMiU3XFx4OUUrKCU0IzZcXHhGNSMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhGNlxcXCJcXFwiMSczXFx4RjcrPCQ3PCsyJTdcXHg5RCsoJTQjNlxceEY4IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrJyA0ITZcXHhGOSEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4RkFcXFwiXFxcIjJcXHhGQTNcXHhGQit4JCEuSlxcXCJcXFwiMkozSytTJDchKiMgXFxcIiBbK0MlNyEqIyBcXFwiIFsrMyU3ISojIFxcXCIgWysjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyU0XFxcIjZcXHhGQ1xcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2K04kITc8Ky0kN1xceEEwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyklNFxcXCI2XFx4RkRcXFwiXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNzYqKSBcXFwiN1QqIyBcXFwiN0hcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QTIrXyQgXFxcXCE3QistJDdcXHhBMysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhBMysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4RkVcXFwiXFxcIjEmM1xceEZGKkcgXFxcIi9cXHUwMTAwXFxcIlxcXCIxJzNcXHUwMTAxKjsgXFxcIi9cXHUwMTAyXFxcIlxcXCIxJDNcXHUwMTAzKi8gXFxcIi9cXHUwMTA0XFxcIlxcXCIxJTNcXHUwMTA1KiMgXFxcIjc2KyYgNCE2XFx1MDEwNiEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEE0KiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTA3XFxcIlxcXCIxKDNcXHUwMTA4K08kNzwrRSUvXFx1MDEwOVxcXCJcXFwiMSgzXFx1MDEwQSovIFxcXCIvXFx1MDEwQlxcXCJcXFwiMSgzXFx1MDEwQyojIFxcXCI3NisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrXyQgXFxcXCE3QSstJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrJyA0ITZcXHUwMTBEISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhBOCsmIDQhNlxcdTAxMEUhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QTkrcyQ3OytpJTdcXHhBRStfJSBcXFxcITdCKy0kN1xceEFGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEFGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhBQSojIFxcXCI3XFx4QUJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi9cXHUwMTBGXFxcIlxcXCIxJDNcXHUwMTEwKlMgXFxcIi9cXHUwMTExXFxcIlxcXCIxJTNcXHUwMTEyKkcgXFxcIi9cXHUwMTEzXFxcIlxcXCIxJTNcXHUwMTE0KjsgXFxcIi9cXHUwMTE1XFxcIlxcXCIxJTNcXHUwMTE2Ki8gXFxcIi9cXHUwMTE3XFxcIlxcXCIxKzNcXHUwMTE4KiMgXFxcIjdcXHhBQ1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiL1xcdTAxMTlcXFwiXFxcIjEnM1xcdTAxMUEqLyBcXFwiL1xcdTAxMUJcXFwiXFxcIjEpM1xcdTAxMUMqIyBcXFwiN1xceEFDXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3NiojIFxcXCI3XFx4QURcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDExRFxcXCJcXFwiMVxcXCIzXFx1MDExRSstJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QUMqIyBcXFwiNzZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3Nis3JDc8Ky0lN1xceEIwKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjc2KiMgXFxcIjdIXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEIyKzckNy4rLSU3XFx4OEYrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKycgNCE2XFx1MDExRiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OUQrJyA0ITZcXHUwMTIwISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhCNStkJCBcXFxcITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisoJTRcXFwiNlxcdTAxMjFcXFwiISElJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITc3K2skIFxcXFwhLkpcXFwiXFxcIjJKM0srLSQ3NysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw+JiEuSlxcXCJcXFwiMkozSystJDc3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN0wqIyBcXFwiN1xceDk4K2MkIFxcXFwhN0IrLSQ3XFx4QjcrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4QjcrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx1MDEyMlxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEI4KiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTIzXFxcIlxcXCIxIzNcXHUwMTI0KzwkNzwrMiU3NisoJTQjNlxcdTAxMjUjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCsnIDQhNlxcdTAxMjYhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDlEKycgNCE2XFx1MDEyNyEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDdcXHg5OSwjJjdcXHg5OVxcXCIrXFx4ODEkN0ArdyU3TSttJTc/K2MlIFxcXFwhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNCU2XFx1MDEyOCUgJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEJEXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMjlcXFwiXFxcIjEmM1xcdTAxMkErcyQ3LitpJTdcXHhDMCtfJSBcXFxcITdBKy0kN1xceEMwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceEMwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqIyBcXFwiN1xceEJFXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrcyQ3LitpJTdcXHhCRitfJSBcXFxcITdBKy0kN1xceEJGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceEJGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3Nis9JDc8KzMlNzYqIyBcXFwiN0grIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEMxKkcgXFxcIjdcXHhDMypBIFxcXCI3XFx4QzUqOyBcXFwiN1xceEM3KjUgXFxcIjdcXHhDOCovIFxcXCI3XFx4QzkqKSBcXFwiN1xceENBKiMgXFxcIjdcXHhCRlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTJCXFxcIlxcXCIxJTNcXHUwMTJDKzckNzwrLSU3XFx4QzIrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdJKycgNCE2XFx1MDEyRCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEyRVxcXCJcXFwiMSYzXFx1MDEyRitcXHhBNSQ3PCtcXHg5QiU3RCtcXHg5MSU3XFx4QzQrXFx4ODclIFxcXFwhIFxcXFw3JysmJCwjJjcnXFxcIlxcXCJcXFwiIFgrLSQ3XFx4QzQrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsRyYhIFxcXFw3JysmJCwjJjcnXFxcIlxcXCJcXFwiIFgrLSQ3XFx4QzQrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKy0lN0UrIyUnJiUkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN3QqIyBcXFwiN3dcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEzMFxcXCJcXFwiMSUzXFx1MDEzMSs3JDc8Ky0lN1xceEM2KyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3SSsnIDQhNlxcdTAxMzIhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMzNcXFwiXFxcIjEmM1xcdTAxMzQrPCQ3PCsyJTdJKyglNCM2XFx1MDEzNSMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTM2XFxcIlxcXCIxJTNcXHUwMTM3K18kNzwrVSUhL1xcdTAxMzhcXFwiXFxcIjEkM1xcdTAxMzkrJiA0ITZcXHUwMTNBISAlKjQgXFxcIiEvXFx1MDEzQlxcXCJcXFwiMSUzXFx1MDEzQysmIDQhNlxcdTAxM0QhICUrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTNFXFxcIlxcXCIxKTNcXHUwMTNGK1QkNzwrSiUvXFx1MDE0MFxcXCJcXFwiMSMzXFx1MDE0MSovIFxcXCIvXFx1MDE0MlxcXCJcXFwiMSgzXFx1MDE0MyojIFxcXCI3NisoJTQjNlxcdTAxNDQjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE0NVxcXCJcXFwiMSMzXFx1MDE0NitcXHg5RSQ3PCtcXHg5NCU3RCtcXHg4QSUhN1xceENCK2skIFxcXFwhLkRcXFwiXFxcIjJEM0UrLSQ3XFx4Q0IrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLkRcXFwiXFxcIjJEM0UrLSQ3XFx4Q0IrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKy0lN0UrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE0N1xcXCJcXFwiMSgzXFx1MDE0OCovIFxcXCIvXFx1MDE0OVxcXCJcXFwiMSQzXFx1MDE0QSojIFxcXCI3NisnIDQhNlxcdTAxNEIhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrXyQgXFxcXCE3QSstJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceENFK0skNy4rQSU3XFx4Q0UrNyU3ListJTdcXHg4RisjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKycgNCE2XFx1MDE0QyEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RDArYyQgXFxcXCE3QSstJDdcXHhEMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHhEMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrJyU0XFxcIjZcXHUwMTREXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDk4K2MkIFxcXFwhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx1MDE0RVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdMKlQgXFxcIjdcXHg5OCpOIFxcXCIhN0AqIyBcXFwiIFsrPSQ3dCszJTc/KiMgXFxcIiBbKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFgrYyQgXFxcXCE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrJyU0XFxcIjZcXHUwMTRGXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEQzK2MkIFxcXFwhN0IrLSQ3XFx4RDQrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4RDQrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx1MDE1MFxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5NSsmIDQhNlxcdTAxNTEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE1MlxcXCJcXFwiMSgzXFx1MDE1Mys8JDc8KzIlNzYrKCU0IzZcXHUwMTU0IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYKmogXFxcIiEvXFx1MDE1NVxcXCJcXFwiMSYzXFx1MDE1Nis8JDc8KzIlNzYrKCU0IzZcXHUwMTU3IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYKjogXFxcIiEvXFx1MDE1OFxcXCJcXFwiMSozXFx1MDE1OSsmIDQhNlxcdTAxNUEhICUqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITc2K28kIFxcXFwhN0ErMiQ3NisoJTRcXFwiNlxcdTAxNUJcXFwiISAlJFxcXCIjIFhcXFwiIyBYLD0mITdBKzIkNzYrKCU0XFxcIjZcXHUwMTVCXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFxcXCIrKSU0XFxcIjZcXHUwMTVDXFxcIlxcXCIhICUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyA0ITZcXHUwMTVEISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhENytfJCBcXFxcITdBKy0kN1xceEQ3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceEQ3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5OCtfJCBcXFxcITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKycgNCE2XFx1MDE1RSEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4REErXyQgXFxcXCE3QistJDdcXHhEQisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhEQisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE1RlxcXCJcXFwiMSYzXFx1MDE2MCo7IFxcXCIvXFx1MDE2MVxcXCJcXFwiMSczXFx1MDE2MiovIFxcXCIvXFx1MDE2M1xcXCJcXFwiMSozXFx1MDE2NCojIFxcXCI3NismIDQhNlxcdTAxNjUhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE2NlxcXCJcXFwiMSYzXFx1MDE2Nys8JDc8KzIlN1xceERDKyglNCM2XFx1MDE2OCMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHg4MyBcXFwiIS9cXHhGNlxcXCJcXFwiMSczXFx4RjcrPCQ3PCsyJTdcXHg5RCsoJTQjNlxcdTAxNjkjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFgqUyBcXFwiIS9cXHUwMTZBXFxcIlxcXCIxKzNcXHUwMTZCKzwkNzwrMiU3XFx4OUQrKCU0IzZcXHUwMTZDIyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYKiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiL1xcdTAxNkRcXFwiXFxcIjErM1xcdTAxNkUqayBcXFwiL1xcdTAxNkZcXFwiXFxcIjEpM1xcdTAxNzAqXyBcXFwiL1xcdTAxNzFcXFwiXFxcIjEoM1xcdTAxNzIqUyBcXFwiL1xcdTAxNzNcXFwiXFxcIjEnM1xcdTAxNzQqRyBcXFwiL1xcdTAxNzVcXFwiXFxcIjEmM1xcdTAxNzYqOyBcXFwiL1xcdTAxNzdcXFwiXFxcIjEqM1xcdTAxNzgqLyBcXFwiL1xcdTAxNzlcXFwiXFxcIjEpM1xcdTAxN0EqIyBcXFwiNzZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcxKiMgXFxcIiBbXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITc2K28kIFxcXFwhN0ErMiQ3NisoJTRcXFwiNlxcdTAxNUJcXFwiISAlJFxcXCIjIFhcXFwiIyBYLD0mITdBKzIkNzYrKCU0XFxcIjZcXHUwMTVCXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFxcXCIrKSU0XFxcIjZcXHUwMTVDXFxcIlxcXCIhICUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyA0ITZcXHUwMTdCISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdMKiMgXFxcIjdcXHg5OCtjJCBcXFxcITdCKy0kN1xceEUwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEUwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxcdTAxN0NcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhCOCojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RTIrXyQgXFxcXCE3QSstJDdcXHhFMisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHhFMisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RTkrcyQ3LitpJTdcXHhFQytfJSBcXFxcITdCKy0kN1xceEUzKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEUzKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhFNCo7IFxcXCI3XFx4RTUqNSBcXFwiN1xceEU2Ki8gXFxcIjdcXHhFNyopIFxcXCI3XFx4RTgqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxN0RcXFwiXFxcIjEjM1xcdTAxN0UrPCQ3PCsyJTdcXHhFRisoJTQjNlxcdTAxN0YjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE4MFxcXCJcXFwiMSUzXFx1MDE4MSs8JDc8KzIlN1QrKCU0IzZcXHUwMTgyIyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxODNcXFwiXFxcIjEoM1xcdTAxODQrQiQ3PCs4JTdcXFxcKiMgXFxcIjdZKyglNCM2XFx1MDE4NSMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTg2XFxcIlxcXCIxJjNcXHUwMTg3KzwkNzwrMiU3NisoJTQjNlxcdTAxODgjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE4OVxcXCJcXFwiMSUzXFx1MDE4QStUJCE3PCs1JCBcXFxcNyEsIyY3IVxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyU0XFxcIjZcXHUwMThCXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEVBK0skNzsrQSU3Nis3JTc7Ky0lN1xceEVCKyMlJyUlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceDk1XFxcIlxcXCIxIzNcXHhENiojIFxcXCI3NisnIDQhNlxcdTAxOEMhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEI0XFxcIlxcXCIxIzNcXHUwMThEKkcgXFxcIi9cXHhCNlxcXCJcXFwiMSMzXFx1MDE4RSo7IFxcXCIvXFx4QkFcXFwiXFxcIjEjM1xcdTAxOEYqLyBcXFwiL1xceEI4XFxcIlxcXCIxJDNcXHUwMTkwKiMgXFxcIjc2KycgNCE2XFx1MDE5MSEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RUQrSCQhN0MrLSQ3XFx4RUUrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3VSopIFxcXCI3XFxcXCojIFxcXCI3WCsmIDQhNlxcdTAxOTIhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhNyEqIyBcXFwiIFsrYyQ3ISojIFxcXCIgWytTJTchKiMgXFxcIiBbK0MlNyEqIyBcXFwiIFsrMyU3ISojIFxcXCIgWysjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCsnIDQhNlxcdTAxOTMhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITchK0MkNyEqIyBcXFwiIFsrMyU3ISojIFxcXCIgWysjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYKycgNCE2XFx1MDE5NCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhCRFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5RCtkJCBcXFxcITdCKy0kN1xceEYyKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEYyKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisoJTRcXFwiNlxcdTAxOTVcXFwiISElJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4RjMqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxcdTAxOTZcXFwiXFxcIjJcXHUwMTk2M1xcdTAxOTcrTiQ3PCtEJS5cXHUwMTk4XFxcIlxcXCIyXFx1MDE5ODNcXHUwMTk5KikgXFxcIi5cXHUwMTlBXFxcIlxcXCIyXFx1MDE5QTNcXHUwMTlCKyglNCM2XFx1MDE5QyMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5RCtkJCBcXFxcITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisoJTRcXFwiNlxcdTAxOURcXFwiISElJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrNyQ3MCstJTdcXHhGNisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDcyKikgXFxcIjc0KiMgXFxcIjcuLC8mNzIqKSBcXFwiNzQqIyBcXFwiNy5cXFwiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDclLCMmNyVcXFwiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEY5Kz0kLjhcXFwiXFxcIjI4MzkrLSU3XFx4RkErIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTlFXFxcIlxcXCIxJTNcXHUwMTlGKikgXFxcIi9cXHUwMUEwXFxcIlxcXCIxJDNcXHUwMUExKycgNCE2XFx1MDFBMiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RkIrTiQhLjhcXFwiXFxcIjI4MzkrLSQ3XisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXFxcKikgXFxcIjdYKiMgXFxcIjdcXHg4MisnIDQhNlxcdTAxQTMhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3XFx4RkQqKSBcXFwiNy0qIyBcXFwiN1xceEZFLC8mN1xceEZEKikgXFxcIjctKiMgXFxcIjdcXHhGRVxcXCIrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xcXCIqUyBcXFwiNyEqTSBcXFwiLkZcXFwiXFxcIjJGM0cqQSBcXFwiLkpcXFwiXFxcIjJKM0sqNSBcXFwiLkhcXFwiXFxcIjJIM0kqKSBcXFwiLk5cXFwiXFxcIjJOM09cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5MXFxcIlxcXCIyTDNNKlxceDk1IFxcXCIuQlxcXCJcXFwiMkIzQypcXHg4OSBcXFwiLjxcXFwiXFxcIjI8Mz0qfSBcXFwiLlJcXFwiXFxcIjJSM1MqcSBcXFwiLlRcXFwiXFxcIjJUM1UqZSBcXFwiLlZcXFwiXFxcIjJWM1cqWSBcXFwiLlBcXFwiXFxcIjJQM1EqTSBcXFwiLkBcXFwiXFxcIjJAM0EqQSBcXFwiLkRcXFwiXFxcIjJEM0UqNSBcXFwiLjJcXFwiXFxcIjIyMzMqKSBcXFwiLj5cXFwiXFxcIjI+Mz9cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx1MDEwMCtoJC44XFxcIlxcXCIyODM5K1glN1xceEZBK04lIS5cXHUwMUE0XFxcIlxcXCIyXFx1MDFBNDNcXHUwMUE1Ky0kN1xceEVCKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMUE2XFxcIlxcXCIxJTNcXHUwMUE3KikgXFxcIi9cXHUwMUE4XFxcIlxcXCIxJDNcXHUwMUE5KycgNCE2XFx1MDFBMiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RUIrUSQvXFx4QjRcXFwiXFxcIjEjM1xceEI1KjcgXFxcIi9cXHhCNlxcXCJcXFwiMSMzXFx4QjcqKyBcXFwiIFxcXFw3KywjJjcrXFxcIisnJTRcXFwiNlxcdTAxQUFcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx1MDEwNCtcXHg4RiQuRlxcXCJcXFwiMkYzRyt/JTdcXHUwMTAzK3UlLkZcXFwiXFxcIjJGM0crZSU3XFx1MDEwMytbJS5GXFxcIlxcXCIyRjNHK0slN1xcdTAxMDMrQSUuRlxcXCJcXFwiMkYzRysxJTdcXHUwMTA1KyclNCk2XFx1MDFBQikgJSQpIyBYJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNyMrQSQ3Iys3JTcjKy0lNyMrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xcdTAxMDMrLSQ3XFx1MDEwMysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHUwMTAzKzckN1xcdTAxMDMrLSU3XFx1MDEwMysjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpXG4gICAgICAgIF0sXG5cbiAgICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLFxuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgICAgICA9IDAsXG4gICAgICAgIHBlZyRjYWNoZWRQb3MgICAgICAgID0gMCxcbiAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9LFxuICAgICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXG4gICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgID0gW10sXG4gICAgICAgIHBlZyRzaWxlbnRGYWlscyAgICAgID0gMCxcblxuICAgICAgICBwZWckcmVzdWx0O1xuXG4gICAgaWYgKFwic3RhcnRSdWxlXCIgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUluZGljZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcbiAgICAgIH1cblxuICAgICAgcGVnJHN0YXJ0UnVsZUluZGV4ID0gcGVnJHN0YXJ0UnVsZUluZGljZXNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRyZXBvcnRlZFBvcywgcGVnJGN1cnJQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICAgIHJldHVybiBwZWckcmVwb3J0ZWRQb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZSgpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5saW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtbigpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5jb2x1bW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24pIHtcbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihcbiAgICAgICAgbnVsbCxcbiAgICAgICAgW3sgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfV0sXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgbnVsbCwgcGVnJHJlcG9ydGVkUG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgICBmdW5jdGlvbiBhZHZhbmNlKGRldGFpbHMsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgICAgdmFyIHAsIGNoO1xuXG4gICAgICAgIGZvciAocCA9IHN0YXJ0UG9zOyBwIDwgZW5kUG9zOyBwKyspIHtcbiAgICAgICAgICBjaCA9IGlucHV0LmNoYXJBdChwKTtcbiAgICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGlmICghZGV0YWlscy5zZWVuQ1IpIHsgZGV0YWlscy5saW5lKys7IH1cbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwZWckY2FjaGVkUG9zICE9PSBwb3MpIHtcbiAgICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgPiBwb3MpIHtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zID0gMDtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZShwZWckY2FjaGVkUG9zRGV0YWlscywgcGVnJGNhY2hlZFBvcywgcG9zKTtcbiAgICAgICAgcGVnJGNhY2hlZFBvcyA9IHBvcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlZyRjYWNoZWRQb3NEZXRhaWxzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgICAgfVxuXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBleHBlY3RlZCwgcG9zKSB7XG4gICAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuXG4gICAgICAgIGV4cGVjdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIGlmIChhLmRlc2NyaXB0aW9uIDwgYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYS5kZXNjcmlwdGlvbiA+IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoaWxlIChpIDwgZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkW2kgLSAxXSA9PT0gZXhwZWN0ZWRbaV0pIHtcbiAgICAgICAgICAgIGV4cGVjdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ0VzY2FwZShzKSB7XG4gICAgICAgICAgZnVuY3Rpb24gaGV4KGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG5cbiAgICAgICAgICByZXR1cm4gc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgICAnXFxcXFxcXFwnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICAgICdcXFxcXCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICAgJ1xcXFx0JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgICAnXFxcXG4nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCAgICdcXFxcZicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICAgJ1xcXFxyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4ODAtXFx4RkZdL2csICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgnICArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTAxODAtXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUxMDgwLVxcdUZGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdScgICsgaGV4KGNoKTsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWREZXNjcyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICAgICAgZXhwZWN0ZWREZXNjLCBmb3VuZERlc2MsIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZXhwZWN0ZWREZXNjc1tpXSA9IGV4cGVjdGVkW2ldLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0ZWREZXNjID0gZXhwZWN0ZWQubGVuZ3RoID4gMVxuICAgICAgICAgID8gZXhwZWN0ZWREZXNjcy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICAgKyBleHBlY3RlZERlc2NzW2V4cGVjdGVkLmxlbmd0aCAtIDFdXG4gICAgICAgICAgOiBleHBlY3RlZERlc2NzWzBdO1xuXG4gICAgICAgIGZvdW5kRGVzYyA9IGZvdW5kID8gXCJcXFwiXCIgKyBzdHJpbmdFc2NhcGUoZm91bmQpICsgXCJcXFwiXCIgOiBcImVuZCBvZiBpbnB1dFwiO1xuXG4gICAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWREZXNjICsgXCIgYnV0IFwiICsgZm91bmREZXNjICsgXCIgZm91bmQuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcyksXG4gICAgICAgICAgZm91bmQgICAgICA9IHBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwb3MpIDogbnVsbDtcblxuICAgICAgaWYgKGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgIG1lc3NhZ2UgIT09IG51bGwgPyBtZXNzYWdlIDogYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgcG9zLFxuICAgICAgICBwb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIHBvc0RldGFpbHMuY29sdW1uXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRkZWNvZGUocykge1xuICAgICAgdmFyIGJjID0gbmV3IEFycmF5KHMubGVuZ3RoKSwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmNbaV0gPSBzLmNoYXJDb2RlQXQoaSkgLSAzMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVJ1bGUoaW5kZXgpIHtcbiAgICAgIHZhciBiYyAgICA9IHBlZyRieXRlY29kZVtpbmRleF0sXG4gICAgICAgICAgaXAgICAgPSAwLFxuICAgICAgICAgIGlwcyAgID0gW10sXG4gICAgICAgICAgZW5kICAgPSBiYy5sZW5ndGgsXG4gICAgICAgICAgZW5kcyAgPSBbXSxcbiAgICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICAgIHBhcmFtcywgaTtcblxuICAgICAgZnVuY3Rpb24gcHJvdGVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2JqZWN0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiID8gW10gOiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHdoaWxlIChpcCA8IGVuZCkge1xuICAgICAgICAgIHN3aXRjaCAoYmNbaXBdKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocHJvdGVjdChwZWckY29uc3RzW2JjW2lwICsgMV1dKSk7XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgc3RhY2subGVuZ3RoIC09IGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHN0YWNrLnNwbGljZSgtMiwgMSk7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnB1c2goc3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSBiY1tpcCArIDFdLCBiY1tpcCArIDFdKSk7XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKGlucHV0LnN1YnN0cmluZyhzdGFja1tzdGFjay5sZW5ndGggLSAxXSwgcGVnJGN1cnJQb3MpKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgICAgaXBzLnB1c2goaXApO1xuXG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAyICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlwICs9IDIgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBlZyRjdXJyUG9zKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5sZW5ndGgpID09PSBwZWckY29uc3RzW2JjW2lwICsgMV1dKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM107XG4gICAgICAgICAgICAgICAgaXAgKz0gNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdKTtcblxuICAgICAgICAgICAgICBpZiAocGVnJGNvbnN0c1tiY1tpcCArIDFdXS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCBiY1tpcCArIDFdKSk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSBwZWckY29uc3RzW2JjW2lwICsgMV1dLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJEZBSUxFRCk7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckY29uc3RzW2JjW2lwICsgMV1dKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIGJjW2lwICsgMV1dO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBwYXJhbXMgPSBiYy5zbGljZShpcCArIDQsIGlwICsgNCArIGJjW2lwICsgM10pO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmNbaXAgKyAzXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2ldID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIHBhcmFtc1tpXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdGFjay5zcGxpY2UoXG4gICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoIC0gYmNbaXAgKyAyXSxcbiAgICAgICAgICAgICAgICBiY1tpcCArIDJdLFxuICAgICAgICAgICAgICAgIHBlZyRjb25zdHNbYmNbaXAgKyAxXV0uYXBwbHkobnVsbCwgcGFyYW1zKVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChwZWckcGFyc2VSdWxlKGJjW2lwICsgMV0pKTtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wY29kZTogXCIgKyBiY1tpcF0gKyBcIi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVuZCA9IGVuZHMucG9wKCk7XG4gICAgICAgICAgaXAgPSBpcHMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YWNrWzBdO1xuICAgIH1cblxuXG4gICAgICBvcHRpb25zLmRhdGEgPSB7fTsgLy8gT2JqZWN0IHRvIHdoaWNoIGhlYWRlciBhdHRyaWJ1dGVzIHdpbGwgYmUgYXNzaWduZWQgZHVyaW5nIHBhcnNpbmdcblxuICAgICAgZnVuY3Rpb24gbGlzdCAoZmlyc3QsIHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIFtmaXJzdF0uY29uY2F0KHJlc3QpO1xuICAgICAgfVxuXG5cbiAgICBwZWckcmVzdWx0ID0gcGVnJHBhcnNlUnVsZShwZWckc3RhcnRSdWxlSW5kZXgpO1xuXG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHBlZyRmYWlsKHsgdHlwZTogXCJlbmRcIiwgZGVzY3JpcHRpb246IFwiZW5kIG9mIGlucHV0XCIgfSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihudWxsLCBwZWckbWF4RmFpbEV4cGVjdGVkLCBwZWckbWF4RmFpbFBvcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBTeW50YXhFcnJvcjogU3ludGF4RXJyb3IsXG4gICAgcGFyc2U6ICAgICAgIHBhcnNlXG4gIH07XG59KSgpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9HcmFtbWFyL2Rpc3QvR3JhbW1hci5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0b3BsZXZlbCA9IGdsb2JhbC53aW5kb3cgfHwgZ2xvYmFsO1xuXG5mdW5jdGlvbiBnZXRQcmVmaXhlZFByb3BlcnR5IChvYmplY3QsIG5hbWUpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjYXBpdGFsaXplZE5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgdmFyIHByZWZpeGVkTmFtZXMgPSBbbmFtZSwgJ3dlYmtpdCcgKyBjYXBpdGFsaXplZE5hbWUsICdtb3onICsgY2FwaXRhbGl6ZWROYW1lXTtcbiAgZm9yICh2YXIgaSBpbiBwcmVmaXhlZE5hbWVzKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gb2JqZWN0W3ByZWZpeGVkTmFtZXNbaV1dO1xuICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHByb3BlcnR5LmJpbmQob2JqZWN0KTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYlNvY2tldDogdG9wbGV2ZWwuV2ViU29ja2V0LFxuICBUcmFuc3BvcnQ6IHJlcXVpcmUoJy4vVHJhbnNwb3J0JyksXG4gIG9wZW46IHRvcGxldmVsLm9wZW4sXG4gIFByb21pc2U6IHRvcGxldmVsLlByb21pc2UsXG4gIHRpbWVyczogdG9wbGV2ZWwsXG5cbiAgLy8gQ29uc29sZSBpcyBub3QgZGVmaW5lZCBpbiBFQ01BU2NyaXB0LCBzbyBqdXN0IGluIGNhc2UuLi5cbiAgY29uc29sZTogdG9wbGV2ZWwuY29uc29sZSB8fCB7XG4gICAgZGVidWc6IGZ1bmN0aW9uICgpIHt9LFxuICAgIGxvZzogZnVuY3Rpb24gKCkge30sXG4gICAgd2FybjogZnVuY3Rpb24gKCkge30sXG4gICAgZXJyb3I6IGZ1bmN0aW9uICgpIHt9XG4gIH0sXG5cbiAgTWVkaWFTdHJlYW06IGdldFByZWZpeGVkUHJvcGVydHkodG9wbGV2ZWwsICdNZWRpYVN0cmVhbScpLFxuICBnZXRVc2VyTWVkaWE6IGdldFByZWZpeGVkUHJvcGVydHkodG9wbGV2ZWwubmF2aWdhdG9yLCAnZ2V0VXNlck1lZGlhJyksXG4gIFJUQ1BlZXJDb25uZWN0aW9uOiBnZXRQcmVmaXhlZFByb3BlcnR5KHRvcGxldmVsLCAnUlRDUGVlckNvbm5lY3Rpb24nKSxcbiAgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uOiBnZXRQcmVmaXhlZFByb3BlcnR5KHRvcGxldmVsLCAnUlRDU2Vzc2lvbkRlc2NyaXB0aW9uJyksXG5cbiAgYWRkRXZlbnRMaXN0ZW5lcjogZ2V0UHJlZml4ZWRQcm9wZXJ0eSh0b3BsZXZlbCwgJ2FkZEV2ZW50TGlzdGVuZXInKSxcbiAgSFRNTE1lZGlhRWxlbWVudDogdG9wbGV2ZWwuSFRNTE1lZGlhRWxlbWVudCxcblxuICBhdHRhY2hNZWRpYVN0cmVhbTogdG9wbGV2ZWwuYXR0YWNoTWVkaWFTdHJlYW0sXG4gIGNyZWF0ZU9iamVjdFVSTDogdG9wbGV2ZWwuVVJMICYmIHRvcGxldmVsLlVSTC5jcmVhdGVPYmplY3RVUkwsXG4gIHJldm9rZU9iamVjdFVSTDogdG9wbGV2ZWwuVVJMICYmIHRvcGxldmVsLlVSTC5yZXZva2VPYmplY3RVUkxcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL2Vudmlyb25tZW50X2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRyYW5zcG9ydFxuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIFRyYW5zcG9ydFxuICogQHBhcmFtIHtTSVAuVUF9IHVhXG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmVyIHdzX3NlcnZlciBPYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQLCBXZWJTb2NrZXQpIHtcbnZhciBUcmFuc3BvcnQsXG4gIEMgPSB7XG4gICAgLy8gVHJhbnNwb3J0IHN0YXR1cyBjb2Rlc1xuICAgIFNUQVRVU19SRUFEWTogICAgICAgIDAsXG4gICAgU1RBVFVTX0RJU0NPTk5FQ1RFRDogMSxcbiAgICBTVEFUVVNfRVJST1I6ICAgICAgICAyXG4gIH07XG5cbi8qKlxuICogQ29tcHV0ZSBhbiBhbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHNlbmRpbmcgYW5vdGhlclxuICoga2VlcC1hbGl2ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVLZWVwQWxpdmVUaW1lb3V0KHVwcGVyQm91bmQpIHtcbiAgdmFyIGxvd2VyQm91bmQgPSB1cHBlckJvdW5kICogMC44O1xuICByZXR1cm4gMTAwMCAqIChNYXRoLnJhbmRvbSgpICogKHVwcGVyQm91bmQgLSBsb3dlckJvdW5kKSArIGxvd2VyQm91bmQpO1xufVxuXG5UcmFuc3BvcnQgPSBmdW5jdGlvbih1YSwgc2VydmVyKSB7XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC50cmFuc3BvcnQnKTtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLndzID0gbnVsbDtcbiAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gIHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzID0gMDtcbiAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gIHRoaXMubGFzdFRyYW5zcG9ydEVycm9yID0ge307XG5cbiAgdGhpcy5rZWVwQWxpdmVJbnRlcnZhbCA9IHVhLmNvbmZpZ3VyYXRpb24ua2VlcEFsaXZlSW50ZXJ2YWw7XG4gIHRoaXMua2VlcEFsaXZlVGltZW91dCA9IG51bGw7XG4gIHRoaXMua2VlcEFsaXZlVGltZXIgPSBudWxsO1xuXG4gIHRoaXMudWEudHJhbnNwb3J0ID0gdGhpcztcblxuICAvLyBDb25uZWN0XG4gIHRoaXMuY29ubmVjdCgpO1xufTtcblxuVHJhbnNwb3J0LnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge1NJUC5PdXRnb2luZ1JlcXVlc3R8U3RyaW5nfSBtc2dcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBzZW5kOiBmdW5jdGlvbihtc2cpIHtcbiAgICB2YXIgbWVzc2FnZSA9IG1zZy50b1N0cmluZygpO1xuXG4gICAgaWYodGhpcy53cyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBpZiAodGhpcy51YS5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnc2VuZGluZyBXZWJTb2NrZXQgbWVzc2FnZTpcXG5cXG4nICsgbWVzc2FnZSArICdcXG4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud3Muc2VuZChtZXNzYWdlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCd1bmFibGUgdG8gc2VuZCBtZXNzYWdlLCBXZWJTb2NrZXQgaXMgbm90IG9wZW4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgYSBrZWVwLWFsaXZlIChhIGRvdWJsZS1DUkxGIHNlcXVlbmNlKS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBzZW5kS2VlcEFsaXZlOiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLmtlZXBBbGl2ZVRpbWVvdXQpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLmtlZXBBbGl2ZVRpbWVvdXQgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnVhLmVtaXQoJ2tlZXBBbGl2ZVRpbWVvdXQnKTtcbiAgICB9LmJpbmQodGhpcyksIDEwMDAwKTtcblxuICAgIHJldHVybiB0aGlzLnNlbmQoJ1xcclxcblxcclxcbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdGFydCBzZW5kaW5nIGtlZXAtYWxpdmVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRTZW5kaW5nS2VlcEFsaXZlczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwgJiYgIXRoaXMua2VlcEFsaXZlVGltZXIpIHtcbiAgICAgIHRoaXMua2VlcEFsaXZlVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VuZEtlZXBBbGl2ZSgpO1xuICAgICAgICB0aGlzLmtlZXBBbGl2ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydFNlbmRpbmdLZWVwQWxpdmVzKCk7XG4gICAgICB9LmJpbmQodGhpcyksIGNvbXB1dGVLZWVwQWxpdmVUaW1lb3V0KHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3Agc2VuZGluZyBrZWVwLWFsaXZlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0b3BTZW5kaW5nS2VlcEFsaXZlczogZnVuY3Rpb24oKSB7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5rZWVwQWxpdmVUaW1lcik7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5rZWVwQWxpdmVUaW1lb3V0KTtcbiAgICB0aGlzLmtlZXBBbGl2ZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLmtlZXBBbGl2ZVRpbWVvdXQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAqIERpc2Nvbm5lY3Qgc29ja2V0LlxuICAqL1xuICBkaXNjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLndzKSB7XG4gICAgICAvLyBDbGVhciByZWNvbm5lY3RUaW1lclxuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lcik7XG5cbiAgICAgIHRoaXMuc3RvcFNlbmRpbmdLZWVwQWxpdmVzKCk7XG5cbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnY2xvc2luZyBXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSk7XG4gICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZXIpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgICB0aGlzLnVhLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcsIHtcbiAgICAgICAgdHJhbnNwb3J0OiB0aGlzLFxuICAgICAgICBjb2RlOiB0aGlzLmxhc3RUcmFuc3BvcnRFcnJvci5jb2RlLFxuICAgICAgICByZWFzb246IHRoaXMubGFzdFRyYW5zcG9ydEVycm9yLnJlYXNvblxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIENvbm5lY3Qgc29ja2V0LlxuICAqL1xuICBjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcztcblxuICAgIGlmKHRoaXMud3MgJiYgKHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4gfHwgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkgKyAnIGlzIGFscmVhZHkgY29ubmVjdGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodGhpcy53cykge1xuICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZygnY29ubmVjdGluZyB0byBXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSk7XG4gICAgdGhpcy51YS5vblRyYW5zcG9ydENvbm5lY3RpbmcodGhpcyxcbiAgICAgICh0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyA9PT0gMCk/MTp0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyk7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodGhpcy5zZXJ2ZXIud3NfdXJpLCAnc2lwJyk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdlcnJvciBjb25uZWN0aW5nIHRvIFdlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpICsgJzogJyArIGUpO1xuICAgIH1cblxuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdHJhbnNwb3J0Lm9uT3BlbigpO1xuICAgIH07XG5cbiAgICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICB0cmFuc3BvcnQub25DbG9zZShlKTtcbiAgICB9O1xuXG4gICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICB0cmFuc3BvcnQub25NZXNzYWdlKGUpO1xuICAgIH07XG5cbiAgICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICB0cmFuc3BvcnQub25FcnJvcihlKTtcbiAgICB9O1xuICB9LFxuXG4gIC8vIFRyYW5zcG9ydCBFdmVudCBIYW5kbGVyc1xuXG4gIC8qKlxuICAqIEBldmVudFxuICAqIEBwYXJhbSB7ZXZlbnR9IGVcbiAgKi9cbiAgb25PcGVuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ1dlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpICsgJyBjb25uZWN0ZWQnKTtcbiAgICAvLyBDbGVhciByZWNvbm5lY3RUaW1lciBzaW5jZSB3ZSBhcmUgbm90IGRpc2Nvbm5lY3RlZFxuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVyKTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICAgIH1cbiAgICAvLyBSZXNldCByZWNvbm5lY3Rpb25fYXR0ZW1wdHNcbiAgICB0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyA9IDA7XG4gICAgLy8gRGlzYWJsZSBjbG9zZWRcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIC8vIFRyaWdnZXIgb25UcmFuc3BvcnRDb25uZWN0ZWQgY2FsbGJhY2tcbiAgICB0aGlzLnVhLm9uVHJhbnNwb3J0Q29ubmVjdGVkKHRoaXMpO1xuICAgIC8vIFN0YXJ0IHNlbmRpbmcga2VlcC1hbGl2ZXNcbiAgICB0aGlzLnN0YXJ0U2VuZGluZ0tlZXBBbGl2ZXMoKTtcbiAgfSxcblxuICAvKipcbiAgKiBAZXZlbnRcbiAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICovXG4gIG9uQ2xvc2U6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY29ubmVjdGVkX2JlZm9yZSA9IHRoaXMuY29ubmVjdGVkO1xuXG4gICAgdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IuY29kZSA9IGUuY29kZTtcbiAgICB0aGlzLmxhc3RUcmFuc3BvcnRFcnJvci5yZWFzb24gPSBlLnJlYXNvbjtcblxuICAgIHRoaXMuc3RvcFNlbmRpbmdLZWVwQWxpdmVzKCk7XG5cbiAgICBpZiAodGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgPiAwKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ1JlY29ubmVjdGlvbiBhdHRlbXB0ICcgKyB0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyArICcgZmFpbGVkIChjb2RlOiAnICsgZS5jb2RlICsgKGUucmVhc29uPyAnfCByZWFzb246ICcgKyBlLnJlYXNvbiA6ICcnKSArJyknKTtcbiAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ1dlYlNvY2tldCBkaXNjb25uZWN0ZWQgKGNvZGU6ICcgKyBlLmNvZGUgKyAoZS5yZWFzb24/ICd8IHJlYXNvbjogJyArIGUucmVhc29uIDogJycpICsnKScpO1xuXG4gICAgICBpZihlLndhc0NsZWFuID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdXZWJTb2NrZXQgYWJydXB0IGRpc2Nvbm5lY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIC8vIFRyYW5zcG9ydCB3YXMgY29ubmVjdGVkXG4gICAgICBpZihjb25uZWN0ZWRfYmVmb3JlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudWEub25UcmFuc3BvcnRDbG9zZWQodGhpcyk7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgcmVxdWVzdGVkIHRvIGNsb3NlLlxuICAgICAgICBpZighdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudWEuZW1pdCgnZGlzY29ubmVjdGVkJywge1xuICAgICAgICAgICAgdHJhbnNwb3J0OiB0aGlzLFxuICAgICAgICAgICAgY29kZTogdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IuY29kZSxcbiAgICAgICAgICAgIHJlYXNvbjogdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IucmVhc29uXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgY29ubmVjdGlvbiBhdHRlbXB0XG4gICAgICAgIC8vTmV0d29yayBlcnJvclxuICAgICAgICB0aGlzLnVhLm9uVHJhbnNwb3J0RXJyb3IodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBldmVudFxuICAqIEBwYXJhbSB7ZXZlbnR9IGVcbiAgKi9cbiAgb25NZXNzYWdlOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG1lc3NhZ2UsIHRyYW5zYWN0aW9uLFxuICAgICAgZGF0YSA9IGUuZGF0YTtcblxuICAgIC8vIENSTEYgS2VlcCBBbGl2ZSByZXNwb25zZSBmcm9tIHNlcnZlci4gSWdub3JlIGl0LlxuICAgIGlmKGRhdGEgPT09ICdcXHJcXG4nKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLmtlZXBBbGl2ZVRpbWVvdXQpO1xuICAgICAgdGhpcy5rZWVwQWxpdmVUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMudWEuY29uZmlndXJhdGlvbi50cmFjZVNpcCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3JlY2VpdmVkIFdlYlNvY2tldCBtZXNzYWdlIHdpdGggQ1JMRiBLZWVwIEFsaXZlIHJlc3BvbnNlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZWJTb2NrZXQgYmluYXJ5IG1lc3NhZ2UuXG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgICB9IGNhdGNoKGV2dCkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdyZWNlaXZlZCBXZWJTb2NrZXQgYmluYXJ5IG1lc3NhZ2UgZmFpbGVkIHRvIGJlIGNvbnZlcnRlZCBpbnRvIHN0cmluZywgbWVzc2FnZSBkaXNjYXJkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51YS5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygncmVjZWl2ZWQgV2ViU29ja2V0IGJpbmFyeSBtZXNzYWdlOlxcblxcbicgKyBkYXRhICsgJ1xcbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlYlNvY2tldCB0ZXh0IG1lc3NhZ2UuXG4gICAgZWxzZSB7XG4gICAgICBpZiAodGhpcy51YS5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygncmVjZWl2ZWQgV2ViU29ja2V0IHRleHQgbWVzc2FnZTpcXG5cXG4nICsgZGF0YSArICdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZXNzYWdlID0gU0lQLlBhcnNlci5wYXJzZU1lc3NhZ2UoZGF0YSwgdGhpcy51YSk7XG5cbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZih0aGlzLnVhLnN0YXR1cyA9PT0gU0lQLlVBLkMuU1RBVFVTX1VTRVJfQ0xPU0VEICYmIG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRG8gc29tZSBzYW5pdHkgY2hlY2tcbiAgICBpZihTSVAuc2FuaXR5Q2hlY2sobWVzc2FnZSwgdGhpcy51YSwgdGhpcykpIHtcbiAgICAgIGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXF1ZXN0KSB7XG4gICAgICAgIG1lc3NhZ2UudHJhbnNwb3J0ID0gdGhpcztcbiAgICAgICAgdGhpcy51YS5yZWNlaXZlUmVxdWVzdChtZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZihtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVzcG9uc2UpIHtcbiAgICAgICAgLyogVW5pa2Ugc3RhdGVkIGluIDE4LjEuMiwgaWYgYSByZXNwb25zZSBkb2VzIG5vdCBtYXRjaFxuICAgICAgICAqIGFueSB0cmFuc2FjdGlvbiwgaXQgaXMgZGlzY2FyZGVkIGhlcmUgYW5kIG5vIHBhc3NlZCB0byB0aGUgY29yZVxuICAgICAgICAqIGluIG9yZGVyIHRvIGJlIGRpc2NhcmRlZCB0aGVyZS5cbiAgICAgICAgKi9cbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UubWV0aG9kKSB7XG4gICAgICAgICAgY2FzZSBTSVAuQy5JTlZJVEU6XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRoaXMudWEudHJhbnNhY3Rpb25zLmljdFttZXNzYWdlLnZpYV9icmFuY2hdO1xuICAgICAgICAgICAgaWYodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBTSVAuQy5BQ0s6XG4gICAgICAgICAgICAvLyBKdXN0IGluIGNhc2UgOy0pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB0aGlzLnVhLnRyYW5zYWN0aW9ucy5uaWN0W21lc3NhZ2UudmlhX2JyYW5jaF07XG4gICAgICAgICAgICBpZih0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5yZWNlaXZlUmVzcG9uc2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAZXZlbnRcbiAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICovXG4gIG9uRXJyb3I6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdXZWJTb2NrZXQgY29ubmVjdGlvbiBlcnJvcjogJyArIEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgfSxcblxuICAvKipcbiAgKiBSZWNvbm5lY3Rpb24gYXR0ZW1wdCBsb2dpYy5cbiAgKiBAcHJpdmF0ZVxuICAqL1xuICByZWNvbm5lY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzO1xuXG4gICAgdGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgKz0gMTtcblxuICAgIGlmKHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzID4gdGhpcy51YS5jb25maWd1cmF0aW9uLndzU2VydmVyTWF4UmVjb25uZWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdtYXhpbXVtIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBmb3IgV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkpO1xuICAgICAgdGhpcy51YS5vblRyYW5zcG9ydEVycm9yKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgPT09IDEpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnQ29ubmVjdGlvbiB0byBXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSArICcgc2V2ZXJlZCwgYXR0ZW1wdGluZyBmaXJzdCByZWNvbm5lY3QnKTtcbiAgICAgIHRyYW5zcG9ydC5jb25uZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygndHJ5aW5nIHRvIHJlY29ubmVjdCB0byBXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSArICcgKHJlY29ubmVjdGlvbiBhdHRlbXB0ICcgKyB0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyArICcpJyk7XG5cbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyYW5zcG9ydC5jb25uZWN0KCk7XG4gICAgICAgIHRyYW5zcG9ydC5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgICB9LCB0aGlzLnVhLmNvbmZpZ3VyYXRpb24ud3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0ICogMTAwMCk7XG4gICAgfVxuICB9XG59O1xuXG5UcmFuc3BvcnQuQyA9IEM7XG5yZXR1cm4gVHJhbnNwb3J0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvVHJhbnNwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9