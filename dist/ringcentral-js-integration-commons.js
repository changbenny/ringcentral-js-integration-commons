(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RcPhone"] = factory();
	else
		root["RcPhone"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _slicedToArray2 = __webpack_require__(45);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _addModule = __webpack_require__(119);
	
	var _addModule2 = _interopRequireDefault(_addModule);
	
	var _ringcentral = __webpack_require__(120);
	
	var _ringcentral2 = _interopRequireDefault(_ringcentral);
	
	var _ringcentralClient = __webpack_require__(132);
	
	var _ringcentralClient2 = _interopRequireDefault(_ringcentralClient);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _settings = __webpack_require__(152);
	
	var _settings2 = _interopRequireDefault(_settings);
	
	var _brand = __webpack_require__(166);
	
	var _brand2 = _interopRequireDefault(_brand);
	
	var _auth = __webpack_require__(169);
	
	var _auth2 = _interopRequireDefault(_auth);
	
	var _subscription = __webpack_require__(192);
	
	var _subscription2 = _interopRequireDefault(_subscription);
	
	var _user = __webpack_require__(199);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _webphone = __webpack_require__(203);
	
	var _webphone2 = _interopRequireDefault(_webphone);
	
	var _redux = __webpack_require__(153);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var REDUCER = (0, _symbol2.default)();
	
	function getStoreRegisterAndResolver() {
	  var handlers = new _set2.default();
	  return [function (fn) {
	    return handlers.add(fn);
	  }, function (store) {
	    return handlers.forEach(function (fn) {
	      return fn(store);
	    });
	  }];
	}
	
	var RcPhone = function (_RcModule) {
	  (0, _inherits3.default)(RcPhone, _RcModule);
	
	  function RcPhone(_ref) {
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var getStore = _ref.getStore;
	    var _stateMapper = _ref.stateMapper;
	    var _ref$prefix = _ref.prefix;
	    var prefix = _ref$prefix === undefined ? 'rc' : _ref$prefix;
	    var sdkSettings = _ref.sdkSettings;
	    var defaultBrand = _ref.defaultBrand;
	    (0, _classCallCheck3.default)(this, RcPhone);
	
	    var register = registerStoreHandler;
	    var resolve = void 0;
	    if (!register) {
	      var _getStoreRegisterAndR = getStoreRegisterAndResolver();
	
	      var _getStoreRegisterAndR2 = (0, _slicedToArray3.default)(_getStoreRegisterAndR, 2);
	
	      register = _getStoreRegisterAndR2[0];
	      resolve = _getStoreRegisterAndR2[1];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RcPhone).call(this, {
	      registerStoreHandler: register,
	      stateMapper: _stateMapper
	    }));
	
	    _addModule2.default.call(_this, 'sdk', new _ringcentral2.default((0, _extends3.default)({
	
	      cachePrefix: prefix + '-'
	    }, sdkSettings)));
	
	    _addModule2.default.call(_this, 'platform', _this.sdk.platform());
	
	    _addModule2.default.call(_this, 'api', new _ringcentralClient2.default(_this.sdk));
	
	    _addModule2.default.call(_this, 'auth', new _auth2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).auth;
	      },
	      prefix: prefix,
	      platform: _this.platform
	    }));
	
	    _addModule2.default.call(_this, 'settings', new _settings2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).settings;
	      }
	    }));
	
	    _addModule2.default.call(_this, 'defaultBrand', new _brand2.default((0, _extends3.default)({
	      registerStoreHandler: register,
	      prefix: prefix + '-default',
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).defaultBrand;
	      }
	    }, defaultBrand)));
	
	    _addModule2.default.call(_this, 'subscription', new _subscription2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).subscription;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      sdk: _this.sdk,
	      auth: _this.auth
	    }));
	
	    _addModule2.default.call(_this, 'user', new _user2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).user;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      settings: _this.settings
	    }));
	
	    _addModule2.default.call(_this, 'webphone', new _webphone2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).webphone;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      settings: _this.settings
	    }));
	
	    // combine reducers
	    _this[REDUCER] = (0, _redux.combineReducers)({
	      auth: _this.auth.reducer,
	      defaultBrand: _this.defaultBrand.reducer,
	      subscription: _this.subscription.reducer,
	      user: _this.user.reducer,
	      webphone: _this.webphone.reducer,
	      settings: _this.settings.reducer
	    });
	
	    if (resolve) {
	      resolve(getStore(_this.reducer));
	      // resolve(createStore(this.reducer));
	    }
	    return _this;
	  }
	
	  (0, _createClass3.default)(RcPhone, [{
	    key: 'reducer',
	    get: function get() {
	      return this[REDUCER];
	    }
	  }]);
	  return RcPhone;
	}(_rcModule2.default);
	
	exports.default = RcPhone;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	
	  return target;
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(4), __esModule: true };

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(5);
	module.exports = __webpack_require__(8).Object.assign;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(6);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(21)});

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(7)
	  , core      = __webpack_require__(8)
	  , ctx       = __webpack_require__(9)
	  , hide      = __webpack_require__(11)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 7 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 8 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(10);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(12)
	  , createDesc = __webpack_require__(20);
	module.exports = __webpack_require__(16) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(13)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , toPrimitive    = __webpack_require__(19)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(16) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(16) && !__webpack_require__(17)(function(){
	  return Object.defineProperty(__webpack_require__(18)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(17)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , document = __webpack_require__(7).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(14);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(22)
	  , gOPS     = __webpack_require__(37)
	  , pIE      = __webpack_require__(38)
	  , toObject = __webpack_require__(39)
	  , IObject  = __webpack_require__(26)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(17)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(23)
	  , enumBugKeys = __webpack_require__(36);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(24)
	  , toIObject    = __webpack_require__(25)
	  , arrayIndexOf = __webpack_require__(29)(false)
	  , IE_PROTO     = __webpack_require__(33)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(26)
	  , defined = __webpack_require__(28);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(27);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(25)
	  , toLength  = __webpack_require__(30)
	  , toIndex   = __webpack_require__(32);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(31)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(34)('keys')
	  , uid    = __webpack_require__(35);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(7)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 37 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 38 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(28);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(41), __esModule: true };

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(42);
	module.exports = __webpack_require__(8).Object.getPrototypeOf;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(39)
	  , $getPrototypeOf = __webpack_require__(43);
	
	__webpack_require__(44)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(24)
	  , toObject    = __webpack_require__(39)
	  , IE_PROTO    = __webpack_require__(33)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(6)
	  , core    = __webpack_require__(8)
	  , fails   = __webpack_require__(17);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(46);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(66);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(47), __esModule: true };

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(62);
	module.exports = __webpack_require__(64);

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(49);
	var global        = __webpack_require__(7)
	  , hide          = __webpack_require__(11)
	  , Iterators     = __webpack_require__(52)
	  , TO_STRING_TAG = __webpack_require__(61)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(50)
	  , step             = __webpack_require__(51)
	  , Iterators        = __webpack_require__(52)
	  , toIObject        = __webpack_require__(25);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(53)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(54)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(55)
	  , hide           = __webpack_require__(11)
	  , has            = __webpack_require__(24)
	  , Iterators      = __webpack_require__(52)
	  , $iterCreate    = __webpack_require__(56)
	  , setToStringTag = __webpack_require__(60)
	  , getPrototypeOf = __webpack_require__(43)
	  , ITERATOR       = __webpack_require__(61)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11);

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(57)
	  , descriptor     = __webpack_require__(20)
	  , setToStringTag = __webpack_require__(60)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(11)(IteratorPrototype, __webpack_require__(61)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(13)
	  , dPs         = __webpack_require__(58)
	  , enumBugKeys = __webpack_require__(36)
	  , IE_PROTO    = __webpack_require__(33)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(18)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(59).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(12)
	  , anObject = __webpack_require__(13)
	  , getKeys  = __webpack_require__(22);
	
	module.exports = __webpack_require__(16) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(7).document && document.documentElement;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(12).f
	  , has = __webpack_require__(24)
	  , TAG = __webpack_require__(61)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(34)('wks')
	  , uid        = __webpack_require__(35)
	  , Symbol     = __webpack_require__(7).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(63)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(53)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31)
	  , defined   = __webpack_require__(28);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(65)
	  , ITERATOR  = __webpack_require__(61)('iterator')
	  , Iterators = __webpack_require__(52);
	module.exports = __webpack_require__(8).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(27)
	  , TAG = __webpack_require__(61)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(67), __esModule: true };

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(62);
	module.exports = __webpack_require__(68);

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(13)
	  , get      = __webpack_require__(69);
	module.exports = __webpack_require__(8).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(65)
	  , ITERATOR  = __webpack_require__(61)('iterator')
	  , Iterators = __webpack_require__(52);
	module.exports = __webpack_require__(8).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 70 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(73), __esModule: true };

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(74);
	var $Object = __webpack_require__(8).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(16), 'Object', {defineProperty: __webpack_require__(12).f});

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(77);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(78), __esModule: true };

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(48);
	module.exports = __webpack_require__(79).f('iterator');

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(61);

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(81), __esModule: true };

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(82);
	__webpack_require__(91);
	__webpack_require__(92);
	__webpack_require__(93);
	module.exports = __webpack_require__(8).Symbol;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(7)
	  , has            = __webpack_require__(24)
	  , DESCRIPTORS    = __webpack_require__(16)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(55)
	  , META           = __webpack_require__(83).KEY
	  , $fails         = __webpack_require__(17)
	  , shared         = __webpack_require__(34)
	  , setToStringTag = __webpack_require__(60)
	  , uid            = __webpack_require__(35)
	  , wks            = __webpack_require__(61)
	  , wksExt         = __webpack_require__(79)
	  , wksDefine      = __webpack_require__(84)
	  , keyOf          = __webpack_require__(85)
	  , enumKeys       = __webpack_require__(86)
	  , isArray        = __webpack_require__(87)
	  , anObject       = __webpack_require__(13)
	  , toIObject      = __webpack_require__(25)
	  , toPrimitive    = __webpack_require__(19)
	  , createDesc     = __webpack_require__(20)
	  , _create        = __webpack_require__(57)
	  , gOPNExt        = __webpack_require__(88)
	  , $GOPD          = __webpack_require__(90)
	  , $DP            = __webpack_require__(12)
	  , $keys          = __webpack_require__(22)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(89).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(38).f  = $propertyIsEnumerable;
	  __webpack_require__(37).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(54)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(35)('meta')
	  , isObject = __webpack_require__(14)
	  , has      = __webpack_require__(24)
	  , setDesc  = __webpack_require__(12).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(17)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(7)
	  , core           = __webpack_require__(8)
	  , LIBRARY        = __webpack_require__(54)
	  , wksExt         = __webpack_require__(79)
	  , defineProperty = __webpack_require__(12).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(22)
	  , toIObject = __webpack_require__(25);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(22)
	  , gOPS    = __webpack_require__(37)
	  , pIE     = __webpack_require__(38);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(27);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(25)
	  , gOPN      = __webpack_require__(89).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(23)
	  , hiddenKeys = __webpack_require__(36).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(38)
	  , createDesc     = __webpack_require__(20)
	  , toIObject      = __webpack_require__(25)
	  , toPrimitive    = __webpack_require__(19)
	  , has            = __webpack_require__(24)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(16) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 91 */
/***/ function(module, exports) {



/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(84)('asyncIterator');

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(84)('observable');

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(95);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(99);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(96), __esModule: true };

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(97);
	module.exports = __webpack_require__(8).Object.setPrototypeOf;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(6);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(98).set});

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(14)
	  , anObject = __webpack_require__(13);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(9)(Function.call, __webpack_require__(90).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(100), __esModule: true };

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(101);
	var $Object = __webpack_require__(8).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(57)});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(103), __esModule: true };

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	__webpack_require__(62);
	__webpack_require__(48);
	__webpack_require__(104);
	__webpack_require__(116);
	module.exports = __webpack_require__(8).Set;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(105);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(112)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(12).f
	  , create      = __webpack_require__(57)
	  , hide        = __webpack_require__(11)
	  , redefineAll = __webpack_require__(106)
	  , ctx         = __webpack_require__(9)
	  , anInstance  = __webpack_require__(107)
	  , defined     = __webpack_require__(28)
	  , forOf       = __webpack_require__(108)
	  , $iterDefine = __webpack_require__(53)
	  , step        = __webpack_require__(51)
	  , setSpecies  = __webpack_require__(111)
	  , DESCRIPTORS = __webpack_require__(16)
	  , fastKey     = __webpack_require__(83).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(11);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(9)
	  , call        = __webpack_require__(109)
	  , isArrayIter = __webpack_require__(110)
	  , anObject    = __webpack_require__(13)
	  , toLength    = __webpack_require__(30)
	  , getIterFn   = __webpack_require__(69)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(13);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(52)
	  , ITERATOR   = __webpack_require__(61)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(7)
	  , core        = __webpack_require__(8)
	  , dP          = __webpack_require__(12)
	  , DESCRIPTORS = __webpack_require__(16)
	  , SPECIES     = __webpack_require__(61)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(7)
	  , $export        = __webpack_require__(6)
	  , meta           = __webpack_require__(83)
	  , fails          = __webpack_require__(17)
	  , hide           = __webpack_require__(11)
	  , redefineAll    = __webpack_require__(106)
	  , forOf          = __webpack_require__(108)
	  , anInstance     = __webpack_require__(107)
	  , isObject       = __webpack_require__(14)
	  , setToStringTag = __webpack_require__(60)
	  , dP             = __webpack_require__(12).f
	  , each           = __webpack_require__(113)(0)
	  , DESCRIPTORS    = __webpack_require__(16);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    C = wrapper(function(target, iterable){
	      anInstance(target, C, NAME, '_c');
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        anInstance(this, C, KEY);
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)dP(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(9)
	  , IObject  = __webpack_require__(26)
	  , toObject = __webpack_require__(39)
	  , toLength = __webpack_require__(30)
	  , asc      = __webpack_require__(114);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(115);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , isArray  = __webpack_require__(87)
	  , SPECIES  = __webpack_require__(61)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(6);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(117)('Set')});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(65)
	  , from    = __webpack_require__(118);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(108);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	exports.default = addModule;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function addModule(name, module) {
	  if (Object.prototype.hasOwnProperty.call(this, name)) {
	    throw new Error("module '" + name + "' already exists...");
	  }
	
	  (0, _defineProperty2.default)(this, name, {
	    get: function get() {
	      return module;
	    },
	
	    enumerable: true
	  });
	}

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(126), __webpack_require__(130), __webpack_require__(131));
		else if(typeof define === 'function' && define.amd)
			define([, , "pubnub"], factory);
		else if(typeof exports === 'object')
			exports["SDK"] = factory(require("es6-promise"), require("node-fetch"), require("pubnub"));
		else
			root["RingCentral"] = root["RingCentral"] || {}, root["RingCentral"]["SDK"] = factory(root[undefined], root[undefined], root[undefined]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "/build/";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(1);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	__webpack_require__(2);
	
	var _Utils = __webpack_require__(3);
	
	var Utils = _interopRequireWildcard(_Utils);
	
	var _Cache = __webpack_require__(8);
	
	var _Cache2 = _interopRequireDefault(_Cache);
	
	var _Externals = __webpack_require__(4);
	
	var Externals = _interopRequireWildcard(_Externals);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Client = __webpack_require__(10);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	var _ClientMock = __webpack_require__(12);
	
	var _ClientMock2 = _interopRequireDefault(_ClientMock);
	
	var _Mock = __webpack_require__(14);
	
	var _Mock2 = _interopRequireDefault(_Mock);
	
	var _Registry = __webpack_require__(13);
	
	var _Registry2 = _interopRequireDefault(_Registry);
	
	var _Platform = __webpack_require__(15);
	
	var _Platform2 = _interopRequireDefault(_Platform);
	
	var _Auth = __webpack_require__(16);
	
	var _Auth2 = _interopRequireDefault(_Auth);
	
	var _PubnubFactory = __webpack_require__(17);
	
	var _PubnubFactory2 = _interopRequireDefault(_PubnubFactory);
	
	var _Subscription = __webpack_require__(19);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _CachedSubscription = __webpack_require__(20);
	
	var _CachedSubscription2 = _interopRequireDefault(_CachedSubscription);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SDK = function () {
	
	    /**
	     * @namespace RingCentral
	     * @constructor
	     * @param {object} [options]
	     * @param {string} [options.server]
	     * @param {string} [options.cachePrefix]
	     * @param {string} [options.appSecret]
	     * @param {string} [options.appKey]
	     * @param {string} [options.appName]
	     * @param {string} [options.appVersion]
	     * @param {string} [options.pubnubFactory]
	     * @param {string} [options.client]
	     */
	
	    function SDK(options) {
	        _classCallCheck(this, SDK);
	
	        options = options || {};
	
	        if (!Externals.fetch) {
	            throw new Error('Native Fetch is missing, set RingCentral.SDK.core.Externals.fetch to your favorite alternative');
	        }
	
	        if (!Externals.Promise) {
	            throw new Error('Native Promise is missing, set RingCentral.SDK.core.Externals.Promise to your favorite alternative');
	        }
	
	        this._cache = new _Cache2.default(Externals.localStorage, options.cachePrefix);
	
	        this._client = options.client || new _Client2.default();
	
	        this._platform = new _Platform2.default(this._client, this._cache, options.server, options.appKey, options.appSecret, options.appName, options.appVersion, SDK.version);
	
	        this._pubnubFactory = options.pubnubFactory || Externals.PUBNUB;
	    }
	
	    /**
	     * @return {Platform}
	     */
	
	
	    SDK.prototype.platform = function platform() {
	        return this._platform;
	    };
	
	    /**
	     * @return {Subscription}
	     */
	
	
	    SDK.prototype.createSubscription = function createSubscription() {
	        return new _Subscription2.default(this._pubnubFactory, this._platform);
	    };
	
	    /**
	     * @return {CachedSubscription}
	     */
	
	
	    SDK.prototype.createCachedSubscription = function createCachedSubscription(cacheKey) {
	        return new _CachedSubscription2.default(this._pubnubFactory, this._platform, this._cache, cacheKey);
	    };
	
	    /**
	     * @return {Cache}
	     */
	
	
	    SDK.prototype.cache = function cache() {
	        return this._cache;
	    };
	
	    SDK.handleLoginRedirect = function handleLoginRedirect(origin) {
	        window.opener.postMessage({ RCAuthorizationCode: window.location.search }, origin || window.location.origin);
	    };
	
	    return SDK;
	}();
	
	SDK.version =  true ? ("3.0.0-rc1") : 'x.x.x';
	SDK.server = {
	    sandbox: 'https://platform.devtest.ringcentral.com',
	    production: 'https://platform.ringcentral.com'
	};
	SDK.core = {
	    Cache: _Cache2.default,
	    EventEmitter: _events2.default,
	    Utils: Utils,
	    Externals: Externals
	};
	SDK.http = {
	    Client: _Client2.default,
	    ApiResponse: _ApiResponse2.default
	};
	SDK.platform = {
	    Auth: _Auth2.default,
	    Platform: _Platform2.default
	};
	SDK.subscription = {
	    Subscription: _Subscription2.default
	};
	SDK.mocks = {
	    Client: _ClientMock2.default,
	    Registry: _Registry2.default,
	    Mock: _Mock2.default
	};
	SDK.pubnub = {
	    PubnubMockFactory: _PubnubFactory2.default
	};
	
	
	module.exports = SDK;
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var iteratorSymbol =
	    typeof Symbol === "function" && Symbol.iterator || "@@iterator";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    // This invoke function is written in a style that assumes some
	    // calling function (or Promise) will handle exceptions.
	    function invoke(method, arg) {
	      var result = generator[method](arg);
	      var value = result.value;
	      return value instanceof AwaitArgument
	        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
	        : Promise.resolve(value).then(function(unwrapped) {
	            // When a yielded Promise is resolved, its final value becomes
	            // the .value of the Promise<{value,done}> result for the
	            // current iteration. If the Promise is rejected, however, the
	            // result for this iteration will be rejected with the same
	            // reason. Note that rejections of yielded Promises are not
	            // thrown back into the generator function, as is the case
	            // when an awaited Promise is rejected. This difference in
	            // behavior between yield and await is important, because it
	            // allows the consumer to decide what to do with the yielded
	            // rejection (swallow it and continue, manually .throw it back
	            // into the generator, abandon iteration, whatever). With
	            // await, by contrast, there is no opportunity to examine the
	            // rejection reason outside the generator function, so the
	            // only option is to throw it from the await expression, and
	            // let the generator function handle the exception.
	            result.value = unwrapped;
	            return result;
	          });
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var invokeNext = invoke.bind(generator, "next");
	    var invokeThrow = invoke.bind(generator, "throw");
	    var invokeReturn = invoke.bind(generator, "return");
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return invoke(method, arg);
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : new Promise(function (resolve) {
	          resolve(callInvokeWithMethodAndArg());
	        });
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          context._sent = arg;
	
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            context.sent = undefined;
	          }
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.queryStringify = queryStringify;
	exports.parseQueryString = parseQueryString;
	exports.isFunction = isFunction;
	exports.isArray = isArray;
	exports.isObject = isObject;
	exports.isObjectObject = isObjectObject;
	exports.isPlainObject = isPlainObject;
	exports.isNodeJS = isNodeJS;
	exports.isBrowser = isBrowser;
	exports.delay = delay;
	
	var _Externals = __webpack_require__(4);
	
	/**
	 * TODO Replace with something better
	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js
	 * @param {object} parameters
	 * @returns {string}
	 */
	function queryStringify(parameters) {
	
	    var array = [];
	
	    parameters = parameters || {};
	
	    Object.keys(parameters).forEach(function (k) {
	
	        var v = parameters[k];
	
	        if (isArray(v)) {
	            v.forEach(function (vv) {
	                array.push(encodeURIComponent(k) + '=' + encodeURIComponent(vv));
	            });
	        } else {
	            array.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));
	        }
	    });
	
	    return array.join('&');
	}
	
	/**
	 * TODO Replace with something better
	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js
	 * @param {string} queryString
	 * @returns {object}
	 */
	function parseQueryString(queryString) {
	
	    var argsParsed = {};
	
	    queryString.split('&').forEach(function (arg) {
	
	        arg = decodeURIComponent(arg);
	
	        if (arg.indexOf('=') == -1) {
	
	            argsParsed[arg.trim()] = true;
	        } else {
	
	            var pair = arg.split('='),
	                key = pair[0].trim(),
	                value = pair[1].trim();
	
	            if (key in argsParsed) {
	                if (key in argsParsed && !isArray(argsParsed[key])) argsParsed[key] = [argsParsed[key]];
	                argsParsed[key].push(value);
	            } else {
	                argsParsed[key] = value;
	            }
	        }
	    });
	
	    return argsParsed;
	}
	
	/**
	 * @param obj
	 * @return {boolean}
	 */
	function isFunction(obj) {
	    return typeof obj === "function";
	}
	
	/**
	 * @param obj
	 * @return {boolean}
	 */
	function isArray(obj) {
	    return Array.isArray ? Array.isArray(obj) : typeof obj === "array";
	}
	
	function isObject(o) {
	    return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && !isArray(o);
	}
	
	function isObjectObject(o) {
	    return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';
	}
	
	function isPlainObject(o) {
	    var ctor, prot;
	
	    if (isObjectObject(o) === false) return false;
	
	    // If has modified constructor
	    ctor = o.constructor;
	    if (typeof ctor !== 'function') return false;
	
	    // If has modified prototype
	    prot = ctor.prototype;
	    if (isObjectObject(prot) === false) return false;
	
	    // If constructor does not have an Object-specific method
	    if (prot.hasOwnProperty('isPrototypeOf') === false) {
	        return false;
	    }
	
	    // Most likely a plain Object
	    return true;
	}
	
	function isNodeJS() {
	    return typeof process !== 'undefined';
	}
	
	function isBrowser() {
	    return typeof window !== 'undefined';
	}
	
	function delay(timeout) {
	    return new _Externals.Promise(function (resolve, reject) {
	        setTimeout(function () {
	            resolve(null);
	        }, timeout);
	    });
	}
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	exports.__esModule = true;
	exports.localStorage = exports.PUBNUB = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.Promise = undefined;
	
	var _es6Promise = __webpack_require__(5);
	
	var _es6Promise2 = _interopRequireDefault(_es6Promise);
	
	var _nodeFetch = __webpack_require__(6);
	
	var _nodeFetch2 = _interopRequireDefault(_nodeFetch);
	
	var _pubnub = __webpack_require__(7);
	
	var _pubnub2 = _interopRequireDefault(_pubnub);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var root = typeof window !== "undefined" && window || typeof global !== "undefined" && global || Function("return this;")();
	
	var Promise = _es6Promise2.default && _es6Promise2.default.Promise || root.Promise;
	
	var fetch = _nodeFetch2.default && typeof _nodeFetch2.default == 'function' ? _nodeFetch2.default : root.fetch;
	var Request = fetch.Request || root.Request;
	var Response = fetch.Response || root.Response;
	var Headers = fetch.Headers || root.Headers;
	
	var PUBNUB = _pubnub2.default || root.PUBNUB;
	
	var localStorage = typeof root.localStorage !== 'undefined' ? root.localStorage : {};
	
	exports.Promise = Promise;
	exports.fetch = fetch;
	exports.Request = Request;
	exports.Response = Response;
	exports.Headers = Headers;
	exports.PUBNUB = PUBNUB;
	exports.localStorage = localStorage;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_6__;
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_7__;
	
	/***/ },
	/* 8 */
	/***/ function(module, exports) {
	
	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Cache = function () {
	    function Cache(storage, prefix) {
	        _classCallCheck(this, Cache);
	
	        this.setPrefix(prefix);
	        this._storage = storage;
	    }
	
	    Cache.prototype.setPrefix = function setPrefix(prefix) {
	        this._prefix = prefix || Cache.defaultPrefix;
	        return this;
	    };
	
	    Cache.prototype.setItem = function setItem(key, data) {
	        this._storage[this._prefixKey(key)] = JSON.stringify(data);
	        return this;
	    };
	
	    Cache.prototype.removeItem = function removeItem(key) {
	        delete this._storage[this._prefixKey(key)];
	        return this;
	    };
	
	    Cache.prototype.getItem = function getItem(key) {
	        var item = this._storage[this._prefixKey(key)];
	        if (!item) return null;
	        return JSON.parse(item);
	    };
	
	    Cache.prototype.clean = function clean() {
	
	        for (var key in this._storage) {
	
	            if (!this._storage.hasOwnProperty(key)) continue;
	
	            if (key.indexOf(this._prefix) === 0) {
	                delete this._storage[key];
	            }
	        }
	
	        return this;
	    };
	
	    Cache.prototype._prefixKey = function _prefixKey(key) {
	        return this._prefix + key;
	    };
	
	    return Cache;
	}();
	
	Cache.defaultPrefix = 'rc-';
	exports.default = Cache;
	
	/***/ },
	/* 9 */
	/***/ function(module, exports) {
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	exports.findHeaderName = findHeaderName;
	
	var _Externals = __webpack_require__(4);
	
	var _Utils = __webpack_require__(3);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Client = function (_EventEmitter) {
	    _inherits(Client, _EventEmitter);
	
	    function Client() {
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Client);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _EventEmitter.call.apply(_EventEmitter, [this].concat(args))), _this), _this.events = {
	            beforeRequest: 'beforeRequest',
	            requestSuccess: 'requestSuccess',
	            requestError: 'requestError'
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    /**
	     * @param {Request} request
	     * @return {Promise<ApiResponse>}
	     */
	
	    Client.prototype.sendRequest = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            var apiResponse;
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            apiResponse = new _ApiResponse2.default(request);
	                            _context.prev = 1;
	
	
	                            //TODO Stop request if listeners return false
	                            this.emit(this.events.beforeRequest, apiResponse);
	
	                            _context.next = 5;
	                            return this._loadResponse(request);
	
	                        case 5:
	                            apiResponse._response = _context.sent;
	                            _context.next = 8;
	                            return apiResponse._init();
	
	                        case 8:
	                            if (apiResponse.ok()) {
	                                _context.next = 10;
	                                break;
	                            }
	
	                            throw new Error('Response has unsuccessful status');
	
	                        case 10:
	
	                            this.emit(this.events.requestSuccess, apiResponse);
	
	                            return _context.abrupt("return", apiResponse);
	
	                        case 14:
	                            _context.prev = 14;
	                            _context.t0 = _context["catch"](1);
	
	
	                            if (!_context.t0.apiResponse) _context.t0 = this.makeError(_context.t0, apiResponse);
	
	                            this.emit(this.events.requestError, _context.t0);
	
	                            throw _context.t0;
	
	                        case 19:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this, [[1, 14]]);
	        }));
	
	        function sendRequest(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return sendRequest;
	    }();
	
	    /**
	     * @param {Request} request
	     * @return {Promise<Response>}
	     * @private
	     */
	
	
	    Client.prototype._loadResponse = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(request) {
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.next = 2;
	                            return _Externals.fetch.call(null, request);
	
	                        case 2:
	                            return _context2.abrupt("return", _context2.sent);
	
	                        case 3:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this);
	        }));
	
	        function _loadResponse(_x2) {
	            return _ref2.apply(this, arguments);
	        }
	
	        return _loadResponse;
	    }();
	
	    /**
	     * Wraps the JS Error object with transaction information
	     * @param {Error|IApiError} e
	     * @param {ApiResponse} apiResponse
	     * @return {IApiError}
	     */
	
	
	    Client.prototype.makeError = function makeError(e, apiResponse) {
	
	        // Wrap only if regular error
	        if (!e.hasOwnProperty('apiResponse') && !e.hasOwnProperty('originalMessage')) {
	
	            e.apiResponse = apiResponse;
	            e.originalMessage = e.message;
	            e.message = apiResponse && apiResponse.error(true) || e.originalMessage;
	        }
	
	        return e;
	    };
	
	    /**
	     *
	     * @param {object} init
	     * @param {object} [init.url]
	     * @param {object} [init.body]
	     * @param {string} [init.method]
	     * @param {object} [init.query]
	     * @param {object} [init.headers]
	     * @return {Request}
	     */
	
	
	    Client.prototype.createRequest = function createRequest(init) {
	
	        init = init || {};
	        init.headers = init.headers || {};
	
	        // Sanity checks
	        if (!init.url) throw new Error('Url is not defined');
	        if (!init.method) init.method = 'GET';
	        if (init.method && Client._allowedMethods.indexOf(init.method.toUpperCase()) < 0) {
	            throw new Error('Method has wrong value: ' + init.method);
	        }
	
	        // Defaults
	        init.credentials = init.credentials || 'include';
	        init.mode = init.mode || 'cors';
	
	        // Append Query String
	        if (init.query) {
	            init.url = init.url + (init.url.indexOf('?') > -1 ? '&' : '?') + (0, _Utils.queryStringify)(init.query);
	        }
	
	        if (!findHeaderName('Accept', init.headers)) {
	            init.headers['Accept'] = _ApiResponse2.default._jsonContentType;
	        }
	
	        // Serialize body
	        if ((0, _Utils.isPlainObject)(init.body) || !init.body) {
	
	            var contentTypeHeaderName = findHeaderName(_ApiResponse2.default._contentType, init.headers);
	
	            if (!contentTypeHeaderName) {
	                contentTypeHeaderName = _ApiResponse2.default._contentType;
	                init.headers[contentTypeHeaderName] = _ApiResponse2.default._jsonContentType;
	            }
	
	            var contentType = init.headers[contentTypeHeaderName];
	
	            // Assign a new encoded body
	            if (contentType.indexOf(_ApiResponse2.default._jsonContentType) > -1) {
	                init.body = JSON.stringify(init.body);
	            } else if (contentType.indexOf(_ApiResponse2.default._urlencodedContentType) > -1) {
	                init.body = (0, _Utils.queryStringify)(init.body);
	            }
	        }
	
	        // Create a request with encoded body
	        var req = new _Externals.Request(init.url, init);
	
	        // Keep the original body accessible directly (for mocks)
	        req.originalBody = init.body;
	
	        return req;
	    };
	
	    return Client;
	}(_events2.default);
	
	Client._allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];
	exports.default = Client;
	function findHeaderName(name, headers) {
	    name = name.toLowerCase();
	    return Object.keys(headers).reduce(function (res, key) {
	        if (res) return res;
	        if (name == key.toLowerCase()) return key;
	        return res;
	    }, null);
	}
	
	/**
	 * @name IApiError
	 * @property {string} stack
	 * @property {string} originalMessage
	 * @property {ApiResponse} apiResponse
	 */
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ApiResponse = function () {
	
	    /**
	     * @param {Request} request
	     * @param {Response} response
	     * @param {string} responseText
	     */
	
	    function ApiResponse(request, response, responseText) {
	        _classCallCheck(this, ApiResponse);
	
	        /** @type {Request} */
	        this._request = request;
	
	        /** @type {Response} */
	        this._response = response;
	
	        this._text = responseText;
	        this._json = null;
	        this._multipart = [];
	    }
	
	    ApiResponse.prototype._init = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!(this._isMultipart() || this._isJson())) {
	                                _context.next = 4;
	                                break;
	                            }
	
	                            _context.next = 3;
	                            return this.response().text();
	
	                        case 3:
	                            this._text = _context.sent;
	
	                        case 4:
	                            return _context.abrupt('return', this);
	
	                        case 5:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function _init() {
	            return _ref.apply(this, arguments);
	        }
	
	        return _init;
	    }();
	
	    /**
	     * @return {Response}
	     */
	
	
	    ApiResponse.prototype.response = function response() {
	        return this._response;
	    };
	
	    /**
	     * @return {Request}
	     */
	
	
	    ApiResponse.prototype.request = function request() {
	        return this._request;
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    ApiResponse.prototype.ok = function ok() {
	        return this._response && this._response.ok;
	    };
	
	    /**
	     * @return {string}
	     */
	
	
	    ApiResponse.prototype.text = function text() {
	        if (!this._isJson() && !this._isMultipart()) throw new Error('Response is not text');
	        return this._text;
	    };
	
	    /**
	     * @return {object}
	     */
	
	
	    ApiResponse.prototype.json = function json() {
	        if (!this._isJson()) throw new Error('Response is not JSON');
	        if (!this._json) {
	            this._json = this._text ? JSON.parse(this._text) : null;
	        }
	        return this._json;
	    };
	
	    /**
	     * @param [skipOKCheck]
	     * @return {string}
	     */
	
	
	    ApiResponse.prototype.error = function error(skipOKCheck) {
	
	        if (this.ok() && !skipOKCheck) return null;
	
	        var message = (this._response && this._response.status ? this._response.status + ' ' : '') + (this._response && this._response.statusText ? this._response.statusText : '');
	
	        try {
	
	            if (this.json().message) message = this.json().message;
	            if (this.json().error_description) message = this.json().error_description;
	            if (this.json().description) message = this.json().description;
	        } catch (e) {}
	
	        return message;
	    };
	
	    /**
	     * @return {ApiResponse[]}
	     */
	
	
	    ApiResponse.prototype.multipart = function multipart() {
	
	        if (!this._isMultipart()) throw new Error('Response is not multipart');
	
	        if (!this._multipart.length) {
	
	            // Step 1. Split multipart response
	
	            var text = this.text();
	
	            if (!text) throw new Error('No response body');
	
	            var boundary = this._getContentType().match(/boundary=([^;]+)/i)[1];
	
	            if (!boundary) throw new Error('Cannot find boundary');
	
	            var parts = text.toString().split(ApiResponse._boundarySeparator + boundary);
	
	            if (parts[0].trim() === '') parts.shift();
	            if (parts[parts.length - 1].trim() == ApiResponse._boundarySeparator) parts.pop();
	
	            if (parts.length < 1) throw new Error('No parts in body');
	
	            // Step 2. Parse status info
	
	            var statusInfo = ApiResponse.create(parts.shift(), this._response.status, this._response.statusText).json();
	
	            // Step 3. Parse all other parts
	
	            this._multipart = parts.map(function (part, i) {
	
	                var status = statusInfo.response[i].status;
	
	                return ApiResponse.create(part, status);
	            });
	        }
	
	        return this._multipart;
	    };
	
	    ApiResponse.prototype._isContentType = function _isContentType(contentType) {
	        return this._getContentType().indexOf(contentType) > -1;
	    };
	
	    ApiResponse.prototype._getContentType = function _getContentType() {
	        return this._response.headers.get(ApiResponse._contentType) || '';
	    };
	
	    ApiResponse.prototype._isMultipart = function _isMultipart() {
	        return this._isContentType(ApiResponse._multipartContentType);
	    };
	
	    ApiResponse.prototype._isUrlEncoded = function _isUrlEncoded() {
	        return this._isContentType(ApiResponse._urlencodedContentType);
	    };
	
	    ApiResponse.prototype._isJson = function _isJson() {
	        return this._isContentType(ApiResponse._jsonContentType);
	    };
	
	    /**
	     * Method is used to create ApiResponse object from string parts of multipart/mixed response
	     * @param {string} [text]
	     * @param {number} [status]
	     * @param {string} [statusText]
	     * @return {ApiResponse}
	     */
	
	
	    ApiResponse.create = function create(text, status, statusText) {
	
	        text = text || '';
	        status = status || 200;
	        statusText = statusText || 'OK';
	
	        text = text.replace(/\r/g, '');
	
	        var headers = new _Externals.Headers(),
	            headersAndBody = text.split(ApiResponse._bodySeparator),
	            headersText = headersAndBody.length > 1 ? headersAndBody.shift() : '';
	
	        text = headersAndBody.length > 0 ? headersAndBody.join(ApiResponse._bodySeparator) : null;
	
	        (headersText || '').split('\n').forEach(function (header) {
	
	            var split = header.trim().split(ApiResponse._headerSeparator),
	                key = split.shift().trim(),
	                value = split.join(ApiResponse._headerSeparator).trim();
	
	            if (key) headers.append(key, value);
	        });
	
	        return new ApiResponse(null, new _Externals.Response(text ? text : undefined, {
	            headers: headers,
	            status: status,
	            statusText: statusText
	        }), text);
	    };
	
	    return ApiResponse;
	}();
	
	ApiResponse._contentType = 'Content-Type';
	ApiResponse._jsonContentType = 'application/json';
	ApiResponse._multipartContentType = 'multipart/mixed';
	ApiResponse._urlencodedContentType = 'application/x-www-form-urlencoded';
	ApiResponse._headerSeparator = ':';
	ApiResponse._bodySeparator = '\n\n';
	ApiResponse._boundarySeparator = '--';
	exports.default = ApiResponse;
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Registry = __webpack_require__(13);
	
	var _Registry2 = _interopRequireDefault(_Registry);
	
	var _Client = __webpack_require__(10);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Client = function (_HttpClient) {
	    _inherits(Client, _HttpClient);
	
	    function Client() {
	        _classCallCheck(this, Client);
	
	        var _this = _possibleConstructorReturn(this, _HttpClient.call(this));
	
	        _this._registry = new _Registry2.default();
	        return _this;
	    }
	
	    Client.prototype.registry = function registry() {
	        return this._registry;
	    };
	
	    Client.prototype._loadResponse = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            var mock;
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            mock = this._registry.find(request);
	                            _context.next = 3;
	                            return mock.getResponse(request);
	
	                        case 3:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 4:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function _loadResponse(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return _loadResponse;
	    }();
	
	    return Client;
	}(_Client2.default);
	
	exports.default = Client;
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Mock = __webpack_require__(14);
	
	var _Mock2 = _interopRequireDefault(_Mock);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Registry = function () {
	    function Registry() {
	        _classCallCheck(this, Registry);
	
	        this._mocks = [];
	    }
	
	    Registry.prototype.add = function add(mock) {
	        this._mocks.push(mock);
	        return this;
	    };
	
	    Registry.prototype.clear = function clear() {
	        this._mocks = [];
	        return this;
	    };
	
	    Registry.prototype.find = function find(request) {
	
	        //console.log('Registry is looking for', request);
	
	        var mock = this._mocks.shift();
	
	        if (!mock) throw new Error('No mock in registry for request ' + request.method + ' ' + request.url);
	
	        if (!mock.test(request)) throw new Error('Wrong request ' + request.method + ' ' + request.url + ' for expected mock ' + mock.method() + ' ' + mock.path());
	
	        return mock;
	    };
	
	    Registry.prototype.apiCall = function apiCall(method, path, response, status, statusText, delay) {
	
	        this.add(new _Mock2.default(method, path, response, status, statusText, delay));
	
	        return this;
	    };
	
	    Registry.prototype.authentication = function authentication() {
	
	        this.apiCall('POST', '/restapi/oauth/token', {
	            'access_token': 'ACCESS_TOKEN',
	            'token_type': 'bearer',
	            'expires_in': 3600,
	            'refresh_token': 'REFRESH_TOKEN',
	            'refresh_token_expires_in': 60480,
	            'scope': 'SMS RCM Foo Boo',
	            'expireTime': new Date().getTime() + 3600000
	        });
	
	        return this;
	    };
	
	    Registry.prototype.logout = function logout() {
	
	        this.apiCall('POST', '/restapi/oauth/revoke', {});
	
	        return this;
	    };
	
	    Registry.prototype.presenceLoad = function presenceLoad(id) {
	
	        this.apiCall('GET', '/restapi/v1.0/account/~/extension/' + id + '/presence', {
	            "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id + "/presence",
	            "extension": {
	                "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id,
	                "id": id,
	                "extensionNumber": "101"
	            },
	            "activeCalls": [],
	            "presenceStatus": "Available",
	            "telephonyStatus": "Ringing",
	            "userStatus": "Available",
	            "dndStatus": "TakeAllCalls",
	            "extensionId": id
	        });
	
	        return this;
	    };
	
	    Registry.prototype.subscribeGeneric = function subscribeGeneric(expiresIn) {
	
	        expiresIn = expiresIn || 15 * 60 * 60;
	
	        var date = new Date();
	
	        this.apiCall('POST', '/restapi/v1.0/subscription', {
	            'eventFilters': ['/restapi/v1.0/account/~/extension/~/presence'],
	            'expirationTime': new Date(date.getTime() + expiresIn * 1000).toISOString(),
	            'expiresIn': expiresIn,
	            'deliveryMode': {
	                'transportType': 'PubNub',
	                'encryption': false,
	                'address': '123_foo',
	                'subscriberKey': 'sub-c-foo',
	                'secretKey': 'sec-c-bar'
	            },
	            'id': 'foo-bar-baz',
	            'creationTime': date.toISOString(),
	            'status': 'Active',
	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
	        });
	
	        return this;
	    };
	
	    Registry.prototype.subscribeOnPresence = function subscribeOnPresence(id, detailed) {
	
	        id = id || '1';
	
	        var date = new Date();
	
	        this.apiCall('POST', '/restapi/v1.0/subscription', {
	            'eventFilters': ['/restapi/v1.0/account/~/extension/' + id + '/presence' + (detailed ? '?detailedTelephonyState=true' : '')],
	            'expirationTime': new Date(date.getTime() + 15 * 60 * 60 * 1000).toISOString(),
	            'deliveryMode': {
	                'transportType': 'PubNub',
	                'encryption': true,
	                'address': '123_foo',
	                'subscriberKey': 'sub-c-foo',
	                'secretKey': 'sec-c-bar',
	                'encryptionAlgorithm': 'AES',
	                'encryptionKey': 'VQwb6EVNcQPBhE/JgFZ2zw=='
	            },
	            'creationTime': date.toISOString(),
	            'id': 'foo-bar-baz',
	            'status': 'Active',
	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
	        });
	
	        return this;
	    };
	
	    Registry.prototype.tokenRefresh = function tokenRefresh(failure) {
	
	        if (!failure) {
	
	            this.apiCall('POST', '/restapi/oauth/token', {
	                'access_token': 'ACCESS_TOKEN_FROM_REFRESH',
	                'token_type': 'bearer',
	                'expires_in': 3600,
	                'refresh_token': 'REFRESH_TOKEN_FROM_REFRESH',
	                'refresh_token_expires_in': 60480,
	                'scope': 'SMS RCM Foo Boo'
	            });
	        } else {
	
	            this.apiCall('POST', '/restapi/oauth/token', {
	                'message': 'Wrong token',
	                'error_description': 'Wrong token',
	                'description': 'Wrong token'
	            }, 400);
	        }
	
	        return this;
	    };
	
	    return Registry;
	}();
	
	exports.default = Registry;
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	var _Utils = __webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Mock = function () {
	    function Mock(method, path, json, status, statusText, delay) {
	        _classCallCheck(this, Mock);
	
	        this._method = method.toUpperCase();
	        this._path = path;
	        this._json = json || {};
	        this._delay = delay || 10;
	        this._status = status || 200;
	        this._statusText = statusText || 'OK';
	    }
	
	    Mock.prototype.path = function path() {
	        return this._path;
	    };
	
	    Mock.prototype.method = function method() {
	        return this._method;
	    };
	
	    Mock.prototype.test = function test(request) {
	
	        return request.url.indexOf(this._path) > -1 && request.method.toUpperCase() == this._method;
	    };
	
	    Mock.prototype.getResponse = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return (0, _Utils.delay)(this._delay);
	
	                        case 2:
	                            return _context.abrupt('return', this.createResponse(this._json));
	
	                        case 3:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function getResponse(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return getResponse;
	    }();
	
	    Mock.prototype.createResponse = function createResponse(json, init) {
	
	        init = init || {};
	
	        init.status = init.status || this._status;
	        init.statusText = init.statusText || this._statusText;
	
	        var str = JSON.stringify(json),
	            res = new _Externals.Response(str, init);
	
	        res.headers.set(_ApiResponse2.default._contentType, _ApiResponse2.default._jsonContentType);
	
	        return res;
	    };
	
	    return Mock;
	}();
	
	exports.default = Mock;
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Auth = __webpack_require__(16);
	
	var _Auth2 = _interopRequireDefault(_Auth);
	
	var _Utils = __webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Platform = function (_EventEmitter) {
	    _inherits(Platform, _EventEmitter);
	
	    function Platform(client, cache, server, appKey, appSecret, appName, appVersion, sdkVersion) {
	        _classCallCheck(this, Platform);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.events = {
	            beforeLogin: 'beforeLogin',
	            loginSuccess: 'loginSuccess',
	            loginError: 'loginError',
	            beforeRefresh: 'beforeRefresh',
	            refreshSuccess: 'refreshSuccess',
	            refreshError: 'refreshError',
	            beforeLogout: 'beforeLogout',
	            logoutSuccess: 'logoutSuccess',
	            logoutError: 'logoutError'
	        };
	
	
	        _this._server = server;
	        _this._appKey = appKey;
	        _this._appSecret = appSecret;
	
	        /** @type {Cache} */
	        _this._cache = cache;
	
	        /** @type {Client} */
	        _this._client = client;
	
	        /** @type {Promise<ApiResponse>} */
	        _this._refreshPromise = null;
	
	        _this._auth = new _Auth2.default(_this._cache, Platform._cacheId);
	
	        _this._userAgent = (appName ? appName + (appVersion ? '/' + appVersion : '') + ' ' : '') + 'RCJSSDK/' + sdkVersion;
	
	        return _this;
	    }
	
	    /**
	     * @return {Auth}
	     */
	
	
	    Platform.prototype.auth = function auth() {
	        return this._auth;
	    };
	
	    /**
	     * @return {Client}
	     */
	
	
	    Platform.prototype.client = function client() {
	        return this._client;
	    };
	
	    /**
	     * @param {string} path
	     * @param {object} [options]
	     * @param {boolean} [options.addServer]
	     * @param {string} [options.addMethod]
	     * @param {boolean} [options.addToken]
	     * @return {string}
	     */
	
	
	    Platform.prototype.createUrl = function createUrl(path, options) {
	
	        path = path || '';
	        options = options || {};
	
	        var builtUrl = '',
	            hasHttp = path.indexOf('http://') != -1 || path.indexOf('https://') != -1;
	
	        if (options.addServer && !hasHttp) builtUrl += this._server;
	
	        if (path.indexOf(Platform._urlPrefix) == -1 && !hasHttp) builtUrl += Platform._urlPrefix + '/' + Platform._apiVersion;
	
	        builtUrl += path;
	
	        if (options.addMethod || options.addToken) builtUrl += path.indexOf('?') > -1 ? '&' : '?';
	
	        if (options.addMethod) builtUrl += '_method=' + options.addMethod;
	        if (options.addToken) builtUrl += (options.addMethod ? '&' : '') + 'access_token=' + this._auth.accessToken();
	
	        return builtUrl;
	    };
	
	    /**
	     * @param {string} options.redirectUri
	     * @param {string} options.state
	     * @param {string} options.brandId
	     * @param {string} options.display
	     * @param {string} options.prompt
	     * @param {object} [options]
	     * @return {string}
	     */
	
	
	    Platform.prototype.loginUrl = function loginUrl(options) {
	
	        options = options || {};
	
	        return this.createUrl(Platform._authorizeEndpoint + '?' + (0, _Utils.queryStringify)({
	            'response_type': 'code',
	            'redirect_uri': options.redirectUri || '',
	            'client_id': this._appKey,
	            'state': options.state || '',
	            'brand_id': options.brandId || '',
	            'display': options.display || '',
	            'prompt': options.prompt || ''
	        }), { addServer: true });
	    };
	
	    /**
	     * @param {string} url
	     * @return {Object}
	     */
	
	
	    Platform.prototype.parseLoginRedirectUrl = function parseLoginRedirectUrl(url) {
	
	        var qs = (0, _Utils.parseQueryString)(url.split('?').reverse()[0]),
	            error = qs.error_description || qs.error;
	
	        if (error) {
	            var e = new Error(error);
	            e.error = qs.error;
	            throw e;
	        }
	
	        return qs;
	    };
	
	    /**
	     * Convenience method to handle 3-legged OAuth
	     *
	     * Attention! This is an experimental method and it's signature and behavior may change without notice.
	     *
	     * @experimental
	     * @param {number} [options.width]
	     * @param {number} [options.height]
	     * @param {object} [options.login] additional options for login()
	     * @param {string} [options.origin]
	     * @param {string} [options.property] name of window.postMessage's event data property
	     * @param {string} [options.target] target for window.open()
	     * @param {string} options.url
	     * @return {Promise}
	     */
	
	
	    Platform.prototype.loginWindow = function loginWindow(options) {
	        var _this2 = this;
	
	        return new _Externals.Promise(function (resolve, reject) {
	
	            if (!(0, _Utils.isBrowser)()) throw new Error('This method can be used only in browser');
	
	            if (!options.url) throw new Error('Missing mandatory URL parameter');
	
	            options = options || {};
	            options.url = options.url || 400;
	            options.width = options.width || 400;
	            options.height = options.height || 600;
	            options.origin = options.origin || window.location.origin;
	            options.property = options.property || 'RCAuthorizationCode';
	            options.target = options.target || '_blank';
	
	            var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
	            var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;
	
	            var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
	            var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;
	
	            var left = width / 2 - options.width / 2 + dualScreenLeft;
	            var top = height / 2 - options.height / 2 + dualScreenTop;
	            var win = window.open(options.url, '_blank', options.target == '_blank' ? 'scrollbars=yes, status=yes, width=' + options.width + ', height=' + options.height + ', left=' + left + ', top=' + top : '');
	
	            if (window.focus) win.focus();
	
	            var eventMethod = window.addEventListener ? 'addEventListener' : 'attachEvent';
	            var eventRemoveMethod = eventMethod == 'addEventListener' ? 'removeEventListener' : 'detachEvent';
	            var messageEvent = eventMethod == 'addEventListener' ? 'message' : 'onmessage';
	
	            var eventListener = function eventListener(e) {
	
	                if (e.origin != options.origin) return;
	                if (!e.data || !e.data[options.property]) return; // keep waiting
	
	                win.close();
	                window[eventRemoveMethod](messageEvent, eventListener);
	
	                try {
	
	                    var loginOptions = _this2.parseLoginRedirectUrl(e.data[options.property]);
	
	                    if (!loginOptions.code) throw new Error('No authorization code');
	
	                    resolve(loginOptions);
	                } catch (e) {
	                    reject(e);
	                }
	            };
	
	            window[eventMethod](messageEvent, eventListener, false);
	        });
	    };
	
	    /**
	     * @return {Promise<boolean>}
	     */
	
	
	    Platform.prototype.loggedIn = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.prev = 0;
	                            _context.next = 3;
	                            return this.ensureLoggedIn();
	
	                        case 3:
	                            return _context.abrupt("return", true);
	
	                        case 6:
	                            _context.prev = 6;
	                            _context.t0 = _context["catch"](0);
	                            return _context.abrupt("return", false);
	
	                        case 9:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this, [[0, 6]]);
	        }));
	
	        function loggedIn() {
	            return _ref.apply(this, arguments);
	        }
	
	        return loggedIn;
	    }();
	
	    /**
	     * @param {string} options.username
	     * @param {string} options.password
	     * @param {string} options.extension
	     * @param {string} options.code
	     * @param {string} options.redirectUri
	     * @param {string} options.endpointId
	     * @param {string} options.remember
	     * @param {string} options.accessTokenTtl
	     * @param {string} options.refreshTokenTtl
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.login = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(options) {
	            var body, apiResponse, json;
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.prev = 0;
	
	
	                            options = options || {};
	
	                            this.emit(this.events.beforeLogin);
	
	                            body = {};
	
	
	                            if (!options.code) {
	
	                                body.grant_type = 'password';
	                                body.username = options.username;
	                                body.password = options.password;
	                                body.extension = options.extension || '';
	                            } else if (options.code) {
	
	                                body.grant_type = 'authorization_code';
	                                body.code = options.code;
	                                body.redirect_uri = options.redirectUri;
	                                //body.client_id = this.getCredentials().key; // not needed
	                            }
	
	                            if (options.endpointId) body.endpoint_id = options.endpointId;
	                            if (options.accessTokenTtl) body.accessTokenTtl = options.accessTokenTtl;
	                            if (options.refreshTokenTtl) body.refreshTokenTtl = options.refreshTokenTtl;
	
	                            _context2.next = 10;
	                            return this._tokenRequest(Platform._tokenEndpoint, body);
	
	                        case 10:
	                            apiResponse = _context2.sent;
	                            json = apiResponse.json();
	
	
	                            this._auth.setData(json);
	
	                            this.emit(this.events.loginSuccess, apiResponse);
	
	                            return _context2.abrupt("return", apiResponse);
	
	                        case 17:
	                            _context2.prev = 17;
	                            _context2.t0 = _context2["catch"](0);
	
	
	                            this._cache.clean();
	
	                            this.emit(this.events.loginError, _context2.t0);
	
	                            throw _context2.t0;
	
	                        case 22:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this, [[0, 17]]);
	        }));
	
	        function login(_x) {
	            return _ref2.apply(this, arguments);
	        }
	
	        return login;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     * @private
	     */
	
	
	    Platform.prototype._refresh = function () {
	        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	            var res, json;
	            return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.prev = 0;
	
	
	                            this.emit(this.events.beforeRefresh);
	
	                            _context3.next = 4;
	                            return (0, _Utils.delay)(Platform._refreshDelayMs);
	
	                        case 4:
	                            if (this._auth.refreshToken()) {
	                                _context3.next = 6;
	                                break;
	                            }
	
	                            throw new Error('Refresh token is missing');
	
	                        case 6:
	                            if (this._auth.refreshTokenValid()) {
	                                _context3.next = 8;
	                                break;
	                            }
	
	                            throw new Error('Refresh token has expired');
	
	                        case 8:
	                            _context3.next = 10;
	                            return this._tokenRequest(Platform._tokenEndpoint, {
	                                "grant_type": "refresh_token",
	                                "refresh_token": this._auth.refreshToken(),
	                                "access_token_ttl": this._auth.data().expires_in + 1,
	                                "refresh_token_ttl": this._auth.data().refresh_token_expires_in + 1
	                            });
	
	                        case 10:
	                            res = _context3.sent;
	                            json = res.json();
	
	                            if (json.access_token) {
	                                _context3.next = 14;
	                                break;
	                            }
	
	                            throw this._client.makeError(new Error('Malformed OAuth response'), res);
	
	                        case 14:
	
	                            this._auth.setData(json);
	
	                            this.emit(this.events.refreshSuccess, res);
	
	                            return _context3.abrupt("return", res);
	
	                        case 19:
	                            _context3.prev = 19;
	                            _context3.t0 = _context3["catch"](0);
	
	
	                            _context3.t0 = this._client.makeError(_context3.t0);
	
	                            if (Platform._clearCacheOnRefreshError) {
	                                this._cache.clean();
	                            }
	
	                            this.emit(this.events.refreshError, _context3.t0);
	
	                            throw _context3.t0;
	
	                        case 25:
	                        case "end":
	                            return _context3.stop();
	                    }
	                }
	            }, _callee3, this, [[0, 19]]);
	        }));
	
	        function _refresh() {
	            return _ref3.apply(this, arguments);
	        }
	
	        return _refresh;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.refresh = function () {
	        var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	            var _this3 = this;
	
	            return regeneratorRuntime.wrap(function _callee4$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            if (!this._refreshPromise) {
	                                _context4.next = 2;
	                                break;
	                            }
	
	                            return _context4.abrupt("return", this._refreshPromise);
	
	                        case 2:
	                            _context4.prev = 2;
	
	
	                            this._refreshPromise = this._refresh().then(function (res) {
	                                _this3._refreshPromise = null;
	                                return res;
	                            });
	
	                            return _context4.abrupt("return", this._refreshPromise);
	
	                        case 7:
	                            _context4.prev = 7;
	                            _context4.t0 = _context4["catch"](2);
	
	
	                            this._refreshPromise = null;
	                            throw _context4.t0;
	
	                        case 11:
	                        case "end":
	                            return _context4.stop();
	                    }
	                }
	            }, _callee4, this, [[2, 7]]);
	        }));
	
	        function refresh() {
	            return _ref4.apply(this, arguments);
	        }
	
	        return refresh;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.logout = function () {
	        var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
	            var res;
	            return regeneratorRuntime.wrap(function _callee5$(_context5) {
	                while (1) {
	                    switch (_context5.prev = _context5.next) {
	                        case 0:
	                            _context5.prev = 0;
	
	
	                            this.emit(this.events.beforeLogout);
	
	                            _context5.next = 4;
	                            return this._tokenRequest(Platform._revokeEndpoint, {
	                                token: this._auth.accessToken()
	                            });
	
	                        case 4:
	                            res = _context5.sent;
	
	
	                            this._cache.clean();
	
	                            this.emit(this.events.logoutSuccess, res);
	
	                            return _context5.abrupt("return", res);
	
	                        case 10:
	                            _context5.prev = 10;
	                            _context5.t0 = _context5["catch"](0);
	
	
	                            this.emit(this.events.logoutError, _context5.t0);
	
	                            throw _context5.t0;
	
	                        case 14:
	                        case "end":
	                            return _context5.stop();
	                    }
	                }
	            }, _callee5, this, [[0, 10]]);
	        }));
	
	        function logout() {
	            return _ref5.apply(this, arguments);
	        }
	
	        return logout;
	    }();
	
	    /**
	     * @param {Request} request
	     * @param {object} [options]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<Request>}
	     */
	
	
	    Platform.prototype.inflateRequest = function () {
	        var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(request, options) {
	            return regeneratorRuntime.wrap(function _callee6$(_context6) {
	                while (1) {
	                    switch (_context6.prev = _context6.next) {
	                        case 0:
	
	                            options = options || {};
	
	                            if (!options.skipAuthCheck) {
	                                _context6.next = 3;
	                                break;
	                            }
	
	                            return _context6.abrupt("return", request);
	
	                        case 3:
	                            _context6.next = 5;
	                            return this.ensureLoggedIn();
	
	                        case 5:
	
	                            request.headers.set('X-User-Agent', this._userAgent);
	                            request.headers.set('Client-Id', this._appKey);
	                            request.headers.set('Authorization', this._authHeader());
	                            //request.url = this.createUrl(request.url, {addServer: true}); //FIXME Spec prevents this...
	
	                            return _context6.abrupt("return", request);
	
	                        case 9:
	                        case "end":
	                            return _context6.stop();
	                    }
	                }
	            }, _callee6, this);
	        }));
	
	        function inflateRequest(_x2, _x3) {
	            return _ref6.apply(this, arguments);
	        }
	
	        return inflateRequest;
	    }();
	
	    /**
	     * @param {Request} request
	     * @param {object} [options]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.sendRequest = function () {
	        var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(request, options) {
	            return regeneratorRuntime.wrap(function _callee7$(_context7) {
	                while (1) {
	                    switch (_context7.prev = _context7.next) {
	                        case 0:
	                            _context7.prev = 0;
	                            _context7.next = 3;
	                            return this.inflateRequest(request, options);
	
	                        case 3:
	                            request = _context7.sent;
	                            _context7.next = 6;
	                            return this._client.sendRequest(request);
	
	                        case 6:
	                            return _context7.abrupt("return", _context7.sent);
	
	                        case 9:
	                            _context7.prev = 9;
	                            _context7.t0 = _context7["catch"](0);
	
	                            if (!(!_context7.t0.apiResponse || !_context7.t0.apiResponse.response() || _context7.t0.apiResponse.response().status != 401)) {
	                                _context7.next = 13;
	                                break;
	                            }
	
	                            throw _context7.t0;
	
	                        case 13:
	
	                            this._auth.cancelAccessToken();
	
	                            _context7.next = 16;
	                            return this.sendRequest(request, options);
	
	                        case 16:
	                            return _context7.abrupt("return", _context7.sent);
	
	                        case 17:
	                        case "end":
	                            return _context7.stop();
	                    }
	                }
	            }, _callee7, this, [[0, 9]]);
	        }));
	
	        function sendRequest(_x4, _x5) {
	            return _ref7.apply(this, arguments);
	        }
	
	        return sendRequest;
	    }();
	
	    /**
	     * General purpose function to send anything to server
	     * @param {string} options.url
	     * @param {object} [options.body]
	     * @param {string} [options.method]
	     * @param {object} [options.query]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.send = function () {
	        var _ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
	            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	            return regeneratorRuntime.wrap(function _callee8$(_context8) {
	                while (1) {
	                    switch (_context8.prev = _context8.next) {
	                        case 0:
	
	                            //FIXME https://github.com/bitinn/node-fetch/issues/43
	                            options.url = this.createUrl(options.url, { addServer: true });
	
	                            _context8.next = 3;
	                            return this.sendRequest(this._client.createRequest(options), options);
	
	                        case 3:
	                            return _context8.abrupt("return", _context8.sent);
	
	                        case 4:
	                        case "end":
	                            return _context8.stop();
	                    }
	                }
	            }, _callee8, this);
	        }));
	
	        function send(_x6) {
	            return _ref8.apply(this, arguments);
	        }
	
	        return send;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.get = function () {
	        var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(url, query, options) {
	            return regeneratorRuntime.wrap(function _callee9$(_context9) {
	                while (1) {
	                    switch (_context9.prev = _context9.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'GET';
	                            options.url = url;
	                            options.query = query;
	                            _context9.next = 6;
	                            return this.send(options);
	
	                        case 6:
	                            return _context9.abrupt("return", _context9.sent);
	
	                        case 7:
	                        case "end":
	                            return _context9.stop();
	                    }
	                }
	            }, _callee9, this);
	        }));
	
	        function get(_x8, _x9, _x10) {
	            return _ref9.apply(this, arguments);
	        }
	
	        return get;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} body
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.post = function () {
	        var _ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(url, body, query, options) {
	            return regeneratorRuntime.wrap(function _callee10$(_context10) {
	                while (1) {
	                    switch (_context10.prev = _context10.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'POST';
	                            options.url = url;
	                            options.query = query;
	                            options.body = body;
	                            _context10.next = 7;
	                            return this.send(options);
	
	                        case 7:
	                            return _context10.abrupt("return", _context10.sent);
	
	                        case 8:
	                        case "end":
	                            return _context10.stop();
	                    }
	                }
	            }, _callee10, this);
	        }));
	
	        function post(_x11, _x12, _x13, _x14) {
	            return _ref10.apply(this, arguments);
	        }
	
	        return post;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} [body]
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.put = function () {
	        var _ref11 = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(url, body, query, options) {
	            return regeneratorRuntime.wrap(function _callee11$(_context11) {
	                while (1) {
	                    switch (_context11.prev = _context11.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'PUT';
	                            options.url = url;
	                            options.query = query;
	                            options.body = body;
	                            _context11.next = 7;
	                            return this.send(options);
	
	                        case 7:
	                            return _context11.abrupt("return", _context11.sent);
	
	                        case 8:
	                        case "end":
	                            return _context11.stop();
	                    }
	                }
	            }, _callee11, this);
	        }));
	
	        function put(_x15, _x16, _x17, _x18) {
	            return _ref11.apply(this, arguments);
	        }
	
	        return put;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {string} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype['delete'] = function () {
	        var _ref12 = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(url, query, options) {
	            return regeneratorRuntime.wrap(function _callee12$(_context12) {
	                while (1) {
	                    switch (_context12.prev = _context12.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'DELETE';
	                            options.url = url;
	                            options.query = query;
	                            _context12.next = 6;
	                            return this.send(options);
	
	                        case 6:
	                            return _context12.abrupt("return", _context12.sent);
	
	                        case 7:
	                        case "end":
	                            return _context12.stop();
	                    }
	                }
	            }, _callee12, this);
	        }));
	
	        function _delete(_x19, _x20, _x21) {
	            return _ref12.apply(this, arguments);
	        }
	
	        return _delete;
	    }();
	
	    Platform.prototype._tokenRequest = function () {
	        var _ref13 = _asyncToGenerator(regeneratorRuntime.mark(function _callee13(path, body) {
	            return regeneratorRuntime.wrap(function _callee13$(_context13) {
	                while (1) {
	                    switch (_context13.prev = _context13.next) {
	                        case 0:
	                            _context13.next = 2;
	                            return this.send({
	                                url: path,
	                                skipAuthCheck: true,
	                                body: body,
	                                method: 'POST',
	                                headers: {
	                                    'Authorization': 'Basic ' + this._apiKey(),
	                                    'Content-Type': 'application/x-www-form-urlencoded'
	                                }
	                            });
	
	                        case 2:
	                            return _context13.abrupt("return", _context13.sent);
	
	                        case 3:
	                        case "end":
	                            return _context13.stop();
	                    }
	                }
	            }, _callee13, this);
	        }));
	
	        function _tokenRequest(_x22, _x23) {
	            return _ref13.apply(this, arguments);
	        }
	
	        return _tokenRequest;
	    }();
	
	    Platform.prototype.ensureLoggedIn = function () {
	        var _ref14 = _asyncToGenerator(regeneratorRuntime.mark(function _callee14() {
	            return regeneratorRuntime.wrap(function _callee14$(_context14) {
	                while (1) {
	                    switch (_context14.prev = _context14.next) {
	                        case 0:
	                            if (!this._isAccessTokenValid()) {
	                                _context14.next = 2;
	                                break;
	                            }
	
	                            return _context14.abrupt("return", null);
	
	                        case 2:
	                            _context14.next = 4;
	                            return this.refresh();
	
	                        case 4:
	                            return _context14.abrupt("return", _context14.sent);
	
	                        case 5:
	                        case "end":
	                            return _context14.stop();
	                    }
	                }
	            }, _callee14, this);
	        }));
	
	        function ensureLoggedIn() {
	            return _ref14.apply(this, arguments);
	        }
	
	        return ensureLoggedIn;
	    }();
	
	    Platform.prototype._isAccessTokenValid = function _isAccessTokenValid() {
	        return this._auth.accessTokenValid();
	    };
	
	    Platform.prototype._apiKey = function _apiKey() {
	        var apiKey = this._appKey + ':' + this._appSecret;
	        return typeof btoa == 'function' ? btoa(apiKey) : new Buffer(apiKey).toString('base64');
	    };
	
	    Platform.prototype._authHeader = function _authHeader() {
	        var token = this._auth.accessToken();
	        return this._auth.tokenType() + (token ? ' ' + token : '');
	    };
	
	    return Platform;
	}(_events2.default);
	
	Platform._urlPrefix = '/restapi';
	Platform._apiVersion = 'v1.0';
	Platform._tokenEndpoint = '/restapi/oauth/token';
	Platform._revokeEndpoint = '/restapi/oauth/revoke';
	Platform._authorizeEndpoint = '/restapi/oauth/authorize';
	Platform._refreshDelayMs = 100;
	Platform._cacheId = 'platform';
	Platform._clearCacheOnRefreshError = false;
	exports.default = Platform;
	
	/***/ },
	/* 16 */
	/***/ function(module, exports) {
	
	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Auth = function () {
	    function Auth(cache, cacheId) {
	        _classCallCheck(this, Auth);
	
	        /** @type {Cache} */
	        this._cache = cache;
	        this._cacheId = cacheId;
	    } // 1 minute
	
	
	    Auth.prototype.accessToken = function accessToken() {
	        return this.data().access_token;
	    };
	
	    Auth.prototype.refreshToken = function refreshToken() {
	        return this.data().refresh_token;
	    };
	
	    Auth.prototype.tokenType = function tokenType() {
	        return this.data().token_type;
	    };
	
	    /**
	     * @return {{token_type: string, access_token: string, expires_in: number, refresh_token: string, refresh_token_expires_in: number}}
	     */
	
	
	    Auth.prototype.data = function data() {
	
	        return this._cache.getItem(this._cacheId) || {
	            token_type: '',
	            access_token: '',
	            expires_in: 0,
	            refresh_token: '',
	            refresh_token_expires_in: 0
	        };
	    };
	
	    /**
	     * @param {object} newData
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.setData = function setData(newData) {
	
	        newData = newData || {};
	
	        var data = this.data();
	
	        Object.keys(newData).forEach(function (key) {
	            data[key] = newData[key];
	        });
	
	        data.expire_time = Date.now() + data.expires_in * 1000;
	        data.refresh_token_expire_time = Date.now() + data.refresh_token_expires_in * 1000;
	
	        this._cache.setItem(this._cacheId, data);
	
	        return this;
	    };
	
	    /**
	     * Check if there is a valid (not expired) access token
	     * @return {boolean}
	     */
	
	
	    Auth.prototype.accessTokenValid = function accessTokenValid() {
	
	        var authData = this.data();
	        return authData.token_type === Auth.forcedTokenType || authData.expire_time - Auth.refreshHandicapMs > Date.now();
	    };
	
	    /**
	     * Check if there is a valid (not expired) access token
	     * @return {boolean}
	     */
	
	
	    Auth.prototype.refreshTokenValid = function refreshTokenValid() {
	
	        return this.data().refresh_token_expire_time > Date.now();
	    };
	
	    /**
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.cancelAccessToken = function cancelAccessToken() {
	
	        return this.setData({
	            access_token: '',
	            expires_in: 0
	        });
	    };
	
	    /**
	     * This method sets a special authentication mode used in Service Web
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.forceAuthentication = function forceAuthentication() {
	
	        this.setData({
	            token_type: Auth.forcedTokenType,
	            access_token: '',
	            expires_in: 0,
	            refresh_token: '',
	            refresh_token_expires_in: 0
	        });
	
	        return this;
	    };
	
	    return Auth;
	}();
	
	//export interface IAuthData {
	//    remember?:boolean;
	//    token_type?:string;
	//    access_token?:string;
	//    expires_in?:number; // actually it's string
	//    expire_time?:number;
	//    refresh_token?:string;
	//    refresh_token_expires_in?:number; // actually it's string
	//    refresh_token_expire_time?:number;
	//    scope?:string;
	//}
	
	
	Auth.refreshHandicapMs = 60 * 1000;
	Auth.forcedTokenType = 'forced';
	exports.default = Auth;
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _PubnubMock = __webpack_require__(18);
	
	var _PubnubMock2 = _interopRequireDefault(_PubnubMock);
	
	var _Externals = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PubnubMockFactory = function () {
	    function PubnubMockFactory() {
	        _classCallCheck(this, PubnubMockFactory);
	
	        this.crypto_obj = _Externals.PUBNUB.crypto_obj;
	    }
	
	    PubnubMockFactory.prototype.init = function init(options) {
	        return new _PubnubMock2.default(options);
	    };
	
	    return PubnubMockFactory;
	}();
	
	exports.default = PubnubMockFactory;
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Externals = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PubnubMock = function (_EventEmitter) {
	    _inherits(PubnubMock, _EventEmitter);
	
	    function PubnubMock(options) {
	        _classCallCheck(this, PubnubMock);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.options = options;
	        _this.crypto_obj = _Externals.PUBNUB.crypto_obj;
	        return _this;
	    }
	
	    PubnubMock.prototype.init = function init(options) {
	        this.options = options;
	    };
	
	    PubnubMock.prototype.ready = function ready() {};
	
	    PubnubMock.prototype.subscribe = function subscribe(options) {
	        this.on('message-' + options.channel, options.message);
	    };
	
	    PubnubMock.prototype.unsubscribe = function unsubscribe(options) {
	        this.removeAllListeners('message-' + options.channel);
	    };
	
	    PubnubMock.prototype.receiveMessage = function receiveMessage(msg, channel) {
	        this.emit('message-' + channel, msg, 'env', channel);
	    };
	
	    return PubnubMock;
	}(_events2.default);
	
	exports.default = PubnubMock;
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Subscription = function (_EventEmitter) {
	    _inherits(Subscription, _EventEmitter);
	
	    function Subscription(pubnubFactory, platform) {
	        _classCallCheck(this, Subscription);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.events = {
	            notification: 'notification',
	            removeSuccess: 'removeSuccess',
	            removeError: 'removeError',
	            renewSuccess: 'renewSuccess',
	            renewError: 'renewError',
	            subscribeSuccess: 'subscribeSuccess',
	            subscribeError: 'subscribeError'
	        };
	
	
	        _this._pubnubFactory = pubnubFactory;
	        _this._platform = platform;
	        _this._pubnub = null;
	        _this._pubnubLastChannel = null;
	        _this._timeout = null;
	        _this._subscription = null;
	
	        return _this;
	    }
	
	    Subscription.prototype.subscribed = function subscribed() {
	
	        var subscription = this.subscription();
	
	        return !!(subscription.id && subscription.deliveryMode && subscription.deliveryMode.subscriberKey && subscription.deliveryMode.address);
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    Subscription.prototype.alive = function alive() {
	        return this.subscribed() && Date.now() < this.expirationTime();
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    Subscription.prototype.expired = function expired() {
	        if (!this.subscribed()) return true;
	        return !this.subscribed() || Date.now() > this.subscription().expirationTime;
	    };
	
	    Subscription.prototype.expirationTime = function expirationTime() {
	        return new Date(this.subscription().expirationTime || 0).getTime() - Subscription._renewHandicapMs;
	    };
	
	    Subscription.prototype.setSubscription = function setSubscription(subscription) {
	
	        subscription = subscription || {};
	
	        this._clearTimeout();
	        this._setSubscription(subscription);
	        this._subscribeAtPubnub();
	        this._setTimeout();
	
	        return this;
	    };
	
	    Subscription.prototype.subscription = function subscription() {
	        return this._subscription || {};
	    };
	
	    /**
	     * Creates or updates subscription if there is an active one
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.register = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!this.alive()) {
	                                _context.next = 6;
	                                break;
	                            }
	
	                            _context.next = 3;
	                            return this.renew();
	
	                        case 3:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 6:
	                            _context.next = 8;
	                            return this.subscribe();
	
	                        case 8:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 9:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function register() {
	            return _ref.apply(this, arguments);
	        }
	
	        return register;
	    }();
	
	    Subscription.prototype.eventFilters = function eventFilters() {
	        return this.subscription().eventFilters || [];
	    };
	
	    /**
	     * @param {string[]} events
	     * @return {Subscription}
	     */
	
	
	    Subscription.prototype.addEventFilters = function addEventFilters(events) {
	        this.setEventFilters(this.eventFilters().concat(events));
	        return this;
	    };
	
	    /**
	     * @param {string[]} events
	     * @return {Subscription}
	     */
	
	
	    Subscription.prototype.setEventFilters = function setEventFilters(events) {
	        var subscription = this.subscription();
	        subscription.eventFilters = events;
	        this._setSubscription(subscription);
	        return this;
	    };
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.subscribe = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	            var response, json;
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.prev = 0;
	
	
	                            this._clearTimeout();
	
	                            if (this.eventFilters().length) {
	                                _context2.next = 4;
	                                break;
	                            }
	
	                            throw new Error('Events are undefined');
	
	                        case 4:
	                            _context2.next = 6;
	                            return this._platform.post('/subscription', {
	                                eventFilters: this._getFullEventFilters(),
	                                deliveryMode: {
	                                    transportType: 'PubNub'
	                                }
	                            });
	
	                        case 6:
	                            response = _context2.sent;
	                            json = response.json();
	
	
	                            this.setSubscription(json).emit(this.events.subscribeSuccess, response);
	
	                            return _context2.abrupt('return', response);
	
	                        case 12:
	                            _context2.prev = 12;
	                            _context2.t0 = _context2['catch'](0);
	
	
	                            _context2.t0 = this._platform.client().makeError(_context2.t0);
	
	                            this.reset().emit(this.events.subscribeError, _context2.t0);
	
	                            throw _context2.t0;
	
	                        case 17:
	                        case 'end':
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this, [[0, 12]]);
	        }));
	
	        function subscribe() {
	            return _ref2.apply(this, arguments);
	        }
	
	        return subscribe;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.renew = function () {
	        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	            var response, json;
	            return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.prev = 0;
	
	
	                            this._clearTimeout();
	
	                            if (this.subscribed()) {
	                                _context3.next = 4;
	                                break;
	                            }
	
	                            throw new Error('No subscription');
	
	                        case 4:
	                            if (this.eventFilters().length) {
	                                _context3.next = 6;
	                                break;
	                            }
	
	                            throw new Error('Events are undefined');
	
	                        case 6:
	                            _context3.next = 8;
	                            return this._platform.put('/subscription/' + this.subscription().id, {
	                                eventFilters: this._getFullEventFilters()
	                            });
	
	                        case 8:
	                            response = _context3.sent;
	                            json = response.json();
	
	
	                            this.setSubscription(json).emit(this.events.renewSuccess, response);
	
	                            return _context3.abrupt('return', response);
	
	                        case 14:
	                            _context3.prev = 14;
	                            _context3.t0 = _context3['catch'](0);
	
	
	                            _context3.t0 = this._platform.client().makeError(_context3.t0);
	
	                            this.reset().emit(this.events.renewError, _context3.t0);
	
	                            throw _context3.t0;
	
	                        case 19:
	                        case 'end':
	                            return _context3.stop();
	                    }
	                }
	            }, _callee3, this, [[0, 14]]);
	        }));
	
	        function renew() {
	            return _ref3.apply(this, arguments);
	        }
	
	        return renew;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.remove = function () {
	        var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	            var response;
	            return regeneratorRuntime.wrap(function _callee4$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            _context4.prev = 0;
	
	                            if (this.subscribed()) {
	                                _context4.next = 3;
	                                break;
	                            }
	
	                            throw new Error('No subscription');
	
	                        case 3:
	                            _context4.next = 5;
	                            return this._platform.delete('/subscription/' + this.subscription().id);
	
	                        case 5:
	                            response = _context4.sent;
	
	
	                            this.reset().emit(this.events.removeSuccess, response);
	
	                            return _context4.abrupt('return', response);
	
	                        case 10:
	                            _context4.prev = 10;
	                            _context4.t0 = _context4['catch'](0);
	
	
	                            _context4.t0 = this._platform.client().makeError(_context4.t0);
	
	                            this.emit(this.events.removeError, _context4.t0);
	
	                            throw _context4.t0;
	
	                        case 15:
	                        case 'end':
	                            return _context4.stop();
	                    }
	                }
	            }, _callee4, this, [[0, 10]]);
	        }));
	
	        function remove() {
	            return _ref4.apply(this, arguments);
	        }
	
	        return remove;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.resubscribe = function resubscribe() {
	        var filters = this.eventFilters();
	        return this.reset().setEventFilters(filters).subscribe();
	    };
	
	    /**
	     * Remove subscription and disconnect from PUBNUB
	     * This method resets subscription at client side but backend is not notified
	     */
	
	
	    Subscription.prototype.reset = function reset() {
	        this._clearTimeout();
	        if (this.subscribed() && this._pubnub) this._pubnub.unsubscribe({ channel: this.subscription().deliveryMode.address });
	        this._setSubscription(null);
	        return this;
	    };
	
	    Subscription.prototype._setSubscription = function _setSubscription(subscription) {
	        this._subscription = subscription;
	    };
	
	    Subscription.prototype._getFullEventFilters = function _getFullEventFilters() {
	        var _this2 = this;
	
	        return this.eventFilters().map(function (event) {
	            return _this2._platform.createUrl(event);
	        });
	    };
	
	    Subscription.prototype._setTimeout = function _setTimeout() {
	        var _this3 = this;
	
	        this._clearTimeout();
	
	        if (!this.alive()) throw new Error('Subscription is not alive');
	
	        this._timeout = setInterval(function () {
	
	            if (_this3.alive()) return;
	
	            if (_this3.expired()) {
	                _this3.subscribe();
	            } else {
	                _this3.renew();
	            }
	        }, Subscription._pollInterval);
	
	        return this;
	    };
	
	    Subscription.prototype._clearTimeout = function _clearTimeout() {
	        clearInterval(this._timeout);
	        return this;
	    };
	
	    Subscription.prototype._decrypt = function _decrypt(message) {
	
	        if (!this.subscribed()) throw new Error('No subscription');
	
	        if (this.subscription().deliveryMode.encryptionKey) {
	
	            message = this._pubnubFactory.crypto_obj.decrypt(message, this.subscription().deliveryMode.encryptionKey, {
	                encryptKey: false,
	                keyEncoding: 'base64',
	                keyLength: 128,
	                mode: 'ecb'
	            });
	        }
	
	        return message;
	    };
	
	    Subscription.prototype._notify = function _notify(message) {
	        this.emit(this.events.notification, this._decrypt(message));
	        return this;
	    };
	
	    Subscription.prototype._subscribeAtPubnub = function _subscribeAtPubnub() {
	
	        if (!this.alive()) throw new Error('Subscription is not alive');
	
	        var deliveryMode = this.subscription().deliveryMode;
	
	        if (this._pubnub) {
	
	            if (this._pubnubLastChannel == deliveryMode.address) {
	                // Nothing to update, keep listening to same channel
	                return this;
	            } else if (this._pubnubLastChannel) {
	                // Need to subscribe to new channel
	                this._pubnub.unsubscribe({ channel: this._pubnubLastChannel });
	            }
	
	            // Re-init for new data
	            this._pubnub = this._pubnub.init({
	                ssl: true,
	                subscribe_key: deliveryMode.subscriberKey
	            });
	        } else {
	
	            // Init from scratch
	            this._pubnub = this._pubnubFactory.init({
	                ssl: true,
	                subscribe_key: deliveryMode.subscriberKey
	            });
	
	            this._pubnub.ready(); //TODO This may be not needed anymore
	        }
	
	        this._pubnubLastChannel = deliveryMode.address;
	
	        this._pubnub.subscribe({
	            channel: deliveryMode.address,
	            message: this._notify.bind(this),
	            connect: function connect() {}
	        });
	
	        return this;
	    };
	
	    return Subscription;
	}(_events2.default);
	
	//export interface ISubscription {
	//    id?:string;
	//    uri?: string;
	//    eventFilters?:string[];
	//    expirationTime?:string; // 2014-03-12T19:54:35.613Z
	//    expiresIn?:number;
	//    deliveryMode?: {
	//        transportType?:string;
	//        encryption?:boolean;
	//        address?:string;
	//        subscriberKey?:string;
	//        encryptionKey?:string;
	//        secretKey?:string;
	//    };
	//    creationTime?:string; // 2014-03-12T19:54:35.613Z
	//    status?:string; // Active
	//}
	
	
	Subscription._renewHandicapMs = 2 * 60 * 1000;
	Subscription._pollInterval = 10 * 1000;
	exports.default = Subscription;
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _Subscription2 = __webpack_require__(19);
	
	var _Subscription3 = _interopRequireDefault(_Subscription2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CachedSubscription = function (_Subscription) {
	    _inherits(CachedSubscription, _Subscription);
	
	    function CachedSubscription(pubnubFactory, platform, cache, cacheKey) {
	        _classCallCheck(this, CachedSubscription);
	
	        /** @type {Cache} */
	
	        var _this = _possibleConstructorReturn(this, _Subscription.call(this, pubnubFactory, platform));
	
	        _this._cache = cache;
	        _this._cacheKey = cacheKey;
	
	        return _this;
	    }
	
	    CachedSubscription.prototype.subscription = function subscription() {
	        return this._cache.getItem(this._cacheKey) || {};
	    };
	
	    CachedSubscription.prototype._setSubscription = function _setSubscription(subscription) {
	        return this._cache.setItem(this._cacheKey, subscription);
	    };
	
	    /**
	     * This function checks whether there are any pre-defined eventFilters in cache and if not -- uses provided as defaults
	     * @param {string[]} events
	     * @return {CachedSubscription}
	     */
	
	
	    CachedSubscription.prototype.restore = function restore(events) {
	
	        if (!this.eventFilters().length) {
	            this.setEventFilters(events);
	        }
	
	        return this;
	    };
	
	    return CachedSubscription;
	}(_Subscription3.default);
	
	exports.default = CachedSubscription;
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=ringcentral.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121), __webpack_require__(122).Buffer))

/***/ },
/* 121 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(123)
	var ieee754 = __webpack_require__(124)
	var isArray = __webpack_require__(125)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(122).Buffer, (function() { return this; }())))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 124 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 125 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.2.1
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(128);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	      var parent = this;
	
	      var child = new this.constructor(lib$es6$promise$$internal$$noop);
	
	      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
	        lib$es6$promise$$internal$$makePromise(child);
	      }
	
	      var state = parent._state;
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$es6$promise$asap$$asap(function(){
	          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
	        });
	      } else {
	        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$es6$promise$then$$default &&
	          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    var lib$es6$promise$$internal$$id = 0;
	    function lib$es6$promise$$internal$$nextId() {
	      return lib$es6$promise$$internal$$id++;
	    }
	
	    function lib$es6$promise$$internal$$makePromise(promise) {
	      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
	      promise._state = undefined;
	      promise._result = undefined;
	      promise._subscribers = [];
	    }
	
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        return new Constructor(function(resolve, reject) {
	          reject(new TypeError('You must pass an array to race.'));
	        });
	      } else {
	        return new Constructor(function(resolve, reject) {
	          var length = entries.length;
	          for (var i = 0; i < length; i++) {
	            Constructor.resolve(entries[i]).then(resolve, reject);
	          }
	        });
	      }
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
	      this._result = this._state = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$es6$promise$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
	        lib$es6$promise$$internal$$makePromise(this.promise);
	      }
	
	      if (lib$es6$promise$utils$$isArray(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._result = new Array(this.length);
	
	        if (this.length === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
	      }
	    }
	
	    function lib$es6$promise$enumerator$$validationError() {
	      return new Error('Array Methods must be provided an Array');
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length  = this.length;
	      var input   = this._input;
	
	      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$es6$promise$promise$resolve$$default) {
	        var then = lib$es6$promise$$internal$$getThen(entry);
	
	        if (then === lib$es6$promise$then$$default &&
	            entry._state !== lib$es6$promise$$internal$$PENDING) {
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = entry;
	        } else if (c === lib$es6$promise$promise$$default) {
	          var promise = new c(lib$es6$promise$$internal$$noop);
	          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        this._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = value;
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(129)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121), (function() { return this; }()), __webpack_require__(127)(module)))

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 128 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 130 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var list = this.map[name]
	    if (!list) {
	      list = []
	      this.map[name] = list
	    }
	    list.push(value)
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    var values = this.map[normalizeName(name)]
	    return values ? values[0] : null
	  }
	
	  Headers.prototype.getAll = function(name) {
	    return this.map[normalizeName(name)] || []
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = [normalizeValue(value)]
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    Object.getOwnPropertyNames(this.map).forEach(function(name) {
	      this.map[name].forEach(function(value) {
	        callback.call(thisArg, value, name, this)
	      }, this)
	    }, this)
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    reader.readAsArrayBuffer(blob)
	    return fileReaderReady(reader)
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    reader.readAsText(blob)
	    return fileReaderReady(reader)
	  }
	
	  var support = {
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (!body) {
	        this._bodyText = ''
	      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
	        // Only support ArrayBuffers for POST method.
	        // Receiving ArrayBuffers happens via Blobs, instead.
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        return this.blob().then(readBlobAsArrayBuffer)
	      }
	
	      this.text = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return readBlobAsText(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as text')
	        } else {
	          return Promise.resolve(this._bodyText)
	        }
	      }
	    } else {
	      this.text = function() {
	        var rejected = consumed(this)
	        return rejected ? rejected : Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	    if (Request.prototype.isPrototypeOf(input)) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = input
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this)
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function headers(xhr) {
	    var head = new Headers()
	    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
	    pairs.forEach(function(header) {
	      var split = header.trim().split(':')
	      var key = split.shift().trim()
	      var value = split.join(':').trim()
	      head.append(key, value)
	    })
	    return head
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = options.status
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = options.statusText
	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request
	      if (Request.prototype.isPrototypeOf(input) && !init) {
	        request = input
	      } else {
	        request = new Request(input, init)
	      }
	
	      var xhr = new XMLHttpRequest()
	
	      function responseURL() {
	        if ('responseURL' in xhr) {
	          return xhr.responseURL
	        }
	
	        // Avoid security warnings on getResponseHeader when not allowed by CORS
	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	          return xhr.getResponseHeader('X-Request-URL')
	        }
	
	        return
	      }
	
	      xhr.onload = function() {
	        var status = (xhr.status === 1223) ? 204 : xhr.status
	        if (status < 100 || status > 599) {
	          reject(new TypeError('Network request failed'))
	          return
	        }
	        var options = {
	          status: status,
	          statusText: xhr.statusText,
	          headers: headers(xhr),
	          url: responseURL()
	        }
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/*! 3.15.2 / modern */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["PUBNUB"] = factory();
		else
			root["PUBNUB"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* globals 'Modern' */
		/* eslint curly: 0, camelcase: 0, dot-notation: 0 */
	
		var packageJSON = __webpack_require__(1);
		var pubNubCore = __webpack_require__(2);
		var crypto_obj = __webpack_require__(5);
		var CryptoJS = __webpack_require__(6);
		var WS = __webpack_require__(7);
	
		/**
		 * UTIL LOCALS
		 */
		var PNSDK = 'PubNub-JS-' + 'Modern' + '/' + packageJSON.version;
	
		/**
		 * LOCAL STORAGE
		 */
		var db = (function () {
		  var ls = typeof localStorage !== 'undefined' && localStorage;
		  return {
		    get: function (key) {
		      try {
		        if (ls) return ls.getItem(key);
		        if (document.cookie.indexOf(key) === -1) return null;
		        return ((document.cookie || '').match(
		            RegExp(key + '=([^;]+)')
		          ) || [])[1] || null;
		      } catch (e) {
		        return;
		      }
		    },
		    set: function (key, value) {
		      try {
		        if (ls) return ls.setItem(key, value) && 0;
		        document.cookie = key + '=' + value +
		          '; expires=Thu, 1 Aug 2030 20:00:00 UTC; path=/';
		      } catch (e) {
		        return;
		      }
		    }
		  };
		})();
	
	
		/**
		 * CORS XHR Request
		 * ================
		 *  xdr({
		 *     url     : ['http://www.blah.com/url'],
		 *     success : function(response) {},
		 *     fail    : function() {}
		 *  });
		 */
		function xdr(setup) {
		  var xhr;
		  var timer;
		  var complete = 0;
		  var loaded = 0;
		  var async = true; /* do not allow sync operations in modern builds */
		  var xhrtme = setup.timeout || pubNubCore.DEF_TIMEOUT;
		  var data = setup.data || {};
		  var fail = setup.fail || function () {};
		  var success = setup.success || function () {};
	
		  var done = function (failed, response) {
		    if (complete) return;
		    complete = 1;
	
		    clearTimeout(timer);
	
		    if (xhr) {
		      xhr.onerror = xhr.onload = null;
		      if (xhr.abort) xhr.abort();
		      xhr = null;
		    }
	
		    if (failed) fail(response);
		  };
	
		  var finished = function () {
		    if (loaded) return;
		    var response;
		    loaded = 1;
	
		    clearTimeout(timer);
	
		    try {
		      response = JSON.parse(xhr.responseText);
		    } catch (r) {
		      return done(1);
		    }
	
		    success(response);
		  };
	
		  timer = pubNubCore.timeout(function () {
		    done(1);
		  }, xhrtme);
	
		  // Send
		  try {
		    xhr = typeof XDomainRequest !== 'undefined' &&
		      new XDomainRequest() ||
		      new XMLHttpRequest();
	
		    xhr.onerror = xhr.onabort = function () {
		      done(1, xhr.responseText || { error: 'Network Connection Error' });
		    };
		    xhr.onload = xhr.onloadend = finished;
	
		    data.pnsdk = PNSDK;
		    var url = pubNubCore.build_url(setup.url, data);
		    xhr.open('GET', url, async);
		    if (async) xhr.timeout = xhrtme;
		    xhr.send();
		  } catch (eee) {
		    done(1, { error: 'XHR Failed', stacktrace: eee });
		  }
	
		  // Return 'done'
		  return done;
		}
	
		/**
		 * BIND
		 * ====
		 * bind( 'keydown', search('a')[0], function(element) {
		 *     ...
		 * } );
		 */
		function bind(type, el, fun) {
		  pubNubCore.each(type.split(','), function (etype) {
		    var rapfun = function (e) {
		      if (!e) e = window.event;
		      if (!fun(e)) {
		        e.cancelBubble = true;
		        e.returnValue = false;
		        if (e.preventDefault) e.preventDefault();
		        if (e.stopPropagation) e.stopPropagation();
		      }
		    };
	
		    if (el.addEventListener) el.addEventListener(etype, rapfun, false);
		    else if (el.attachEvent) el.attachEvent('on' + etype, rapfun);
		    else el['on' + etype] = rapfun;
		  });
		}
	
		/**
		 * ERROR
		 * ===
		 * error('message');
		 */
		function error(message) {
		  console.error(message); // eslint-disable-line no-console
		}
	
		/**
		 * EVENTS
		 * ======
		 * PUBNUB.events.bind( 'you-stepped-on-flower', function(message) {
		 *     // Do Stuff with message
		 * } );
		 *
		 * PUBNUB.events.fire( 'you-stepped-on-flower', "message-data" );
		 * PUBNUB.events.fire( 'you-stepped-on-flower', {message:"data"} );
		 * PUBNUB.events.fire( 'you-stepped-on-flower', [1,2,3] );
		 *
		 */
		var events = {
		  list: {},
		  unbind: function (name) {
		    events.list[name] = [];
		  },
		  bind: function (name, fun) {
		    (events.list[name] = events.list[name] || []).push(fun);
		  },
		  fire: function (name, data) {
		    pubNubCore.each(
		      events.list[name] || [],
		      function (fun) {
		        fun(data);
		      }
		    );
		  }
		};
	
		/**
		 * ATTR
		 * ====
		 * var attribute = attr( node, 'attribute' );
		 */
		function attr(node, attribute, value) {
		  if (value) node.setAttribute(attribute, value);
		  else return node && node.getAttribute && node.getAttribute(attribute);
		}
	
		/**
		 * $
		 * =
		 * var div = $('divid');
		 */
		function $(id) {
		  return document.getElementById(id);
		}
	
	
		/**
		 * SEARCH
		 * ======
		 * var elements = search('a div span');
		 */
		function search(elements, start) {
		  var list = [];
		  pubNubCore.each(elements.split(/\s+/), function (el) {
		    pubNubCore.each((start || document).getElementsByTagName(el), function (node) {
		      list.push(node);
		    });
		  });
		  return list;
		}
	
		/**
		 * CSS
		 * ===
		 * var obj = create('div');
		 */
		function css(element, styles) {
		  for (var style in styles) if (styles.hasOwnProperty(style))
		    try {
		      element.style[style] = styles[style] + (
		          '|width|height|top|left|'.indexOf(style) > 0 &&
		          typeof styles[style] === 'number'
		            ? 'px' : ''
		        );
		    } catch (e) {
		      return;
		    }
		}
	
		/**
		 * CREATE
		 * ======
		 * var obj = create('div');
		 */
		function create(element) {
		  return document.createElement(element);
		}
	
	
		function get_hmac_SHA256(data, key) {
		  var hash = CryptoJS['HmacSHA256'](data, key);
		  return hash.toString(CryptoJS['enc']['Base64']);
		}
	
		/* =-====================================================================-= */
		/* =-====================================================================-= */
		/* =-=========================     PUBNUB     ===========================-= */
		/* =-====================================================================-= */
		/* =-====================================================================-= */
	
		function CREATE_PUBNUB(setup) {
		  setup.db = db;
		  setup.xdr = xdr;
		  setup.error = setup.error || error;
		  setup.hmac_SHA256 = get_hmac_SHA256;
		  setup.crypto_obj = crypto_obj();
		  setup.WS = WS;
		  setup.params = { pnsdk: PNSDK };
	
		  var SELF = function (setup) {
		    return CREATE_PUBNUB(setup);
		  };
	
		  var PN = pubNubCore.PN_API(setup);
		  for (var prop in PN) {
		    if (PN.hasOwnProperty(prop)) {
		      SELF[prop] = PN[prop];
		    }
		  }
	
		  SELF.init = SELF;
		  SELF.$ = $;
		  SELF.attr = attr;
		  SELF.search = search;
		  SELF.bind = bind;
		  SELF.css = css;
		  SELF.create = create;
		  SELF.crypto_obj = crypto_obj();
		  SELF.WS = WS;
		  SELF.PNmessage = pubNubCore.PNmessage;
		  SELF.supplant = pubNubCore.supplant;
	
		  if (typeof(window) !== 'undefined') {
		    bind('beforeunload', window, function () {
		      SELF['each-channel'](function (ch) {
		        SELF['LEAVE'](ch.name, 1);
		      });
		      return true;
		    });
		  }
	
		  SELF.ready();
	
		  // Return without Testing
		  if (setup.notest) return SELF;
	
		  if (typeof(window) !== 'undefined') {
		    bind('offline', window, SELF['offline']);
		  }
	
		  if (typeof(document) !== 'undefined') {
		    bind('offline', document, SELF['offline']);
		  }
	
		  return SELF;
		}
	
		CREATE_PUBNUB.init = CREATE_PUBNUB;
		CREATE_PUBNUB.secure = CREATE_PUBNUB;
		CREATE_PUBNUB.crypto_obj = crypto_obj();
		CREATE_PUBNUB.WS = WS;
		CREATE_PUBNUB.db = db;
		CREATE_PUBNUB.PNmessage = pubNubCore.PNmessage;
		CREATE_PUBNUB.uuid = pubNubCore.uuid;
	
		CREATE_PUBNUB.css = css;
		CREATE_PUBNUB.$ = $;
		CREATE_PUBNUB.create = $;
		CREATE_PUBNUB.bind = bind;
		CREATE_PUBNUB.search = search;
		CREATE_PUBNUB.attr = attr;
		CREATE_PUBNUB.events = events;
	
		CREATE_PUBNUB.map = pubNubCore.map;
		CREATE_PUBNUB.each = pubNubCore.each;
		CREATE_PUBNUB.grep = pubNubCore.grep;
		CREATE_PUBNUB.supplant = pubNubCore.supplant;
		CREATE_PUBNUB.now = pubNubCore.now;
		CREATE_PUBNUB.unique = pubNubCore.unique;
		CREATE_PUBNUB.updater = pubNubCore.updater;
	
		module.exports = CREATE_PUBNUB;
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
		module.exports = {
			"name": "pubnub",
			"preferGlobal": false,
			"version": "3.15.2",
			"author": "PubNub <support@pubnub.com>",
			"description": "Publish & Subscribe Real-time Messaging with PubNub",
			"contributors": [
				{
					"name": "Stephen Blum",
					"email": "stephen@pubnub.com"
				}
			],
			"bin": {},
			"scripts": {
				"test": "grunt test --force"
			},
			"main": "./node.js/pubnub.js",
			"browser": "./modern/dist/pubnub.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/pubnub/javascript.git"
			},
			"keywords": [
				"cloud",
				"publish",
				"subscribe",
				"websockets",
				"comet",
				"bosh",
				"xmpp",
				"real-time",
				"messaging"
			],
			"dependencies": {
				"agentkeepalive": "~0.2",
				"lodash": "^4.1.0"
			},
			"noAnalyze": false,
			"devDependencies": {
				"chai": "^3.5.0",
				"eslint": "2.4.0",
				"eslint-config-airbnb": "^6.0.2",
				"eslint-plugin-flowtype": "^2.1.0",
				"eslint-plugin-mocha": "^2.0.0",
				"eslint-plugin-react": "^4.1.0",
				"flow-bin": "^0.22.0",
				"grunt": "^0.4.5",
				"grunt-contrib-clean": "^1.0.0",
				"grunt-contrib-copy": "^0.8.2",
				"grunt-contrib-uglify": "^0.11.1",
				"grunt-env": "^0.4.4",
				"grunt-eslint": "^18.0.0",
				"grunt-flow": "^1.0.3",
				"grunt-karma": "^0.12.1",
				"grunt-mocha-istanbul": "^3.0.1",
				"grunt-text-replace": "^0.4.0",
				"grunt-webpack": "^1.0.11",
				"imports-loader": "^0.6.5",
				"isparta": "^4.0.0",
				"json-loader": "^0.5.4",
				"karma": "^0.13.21",
				"karma-chai": "^0.1.0",
				"karma-mocha": "^0.2.1",
				"karma-phantomjs-launcher": "^1.0.0",
				"karma-spec-reporter": "0.0.24",
				"load-grunt-tasks": "^3.4.0",
				"mocha": "^2.4.5",
				"nock": "^1.1.0",
				"node-uuid": "^1.4.7",
				"nodeunit": "^0.9.0",
				"phantomjs-prebuilt": "^2.1.4",
				"proxyquire": "^1.7.4",
				"sinon": "^1.17.2",
				"uglify-js": "^2.6.1",
				"underscore": "^1.7.0",
				"webpack": "^1.12.13",
				"webpack-dev-server": "^1.14.1"
			},
			"bundleDependencies": [],
			"license": "MIT",
			"engine": {
				"node": ">=0.8"
			},
			"files": [
				"core",
				"node.js",
				"modern",
				"CHANGELOG",
				"FUTURE.md",
				"LICENSE",
				"README.md"
			]
		};
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint camelcase: 0, no-use-before-define: 0, no-unused-expressions: 0  */
		/* eslint eqeqeq: 0, one-var: 0 */
		/* eslint no-redeclare: 0 */
		/* eslint guard-for-in: 0 */
		/* eslint block-scoped-var: 0 space-return-throw-case: 0, no-unused-vars: 0 */
	
		var packageJSON = __webpack_require__(1);
		var defaultConfiguration = __webpack_require__(3);
		var utils = __webpack_require__(4);
	
		var NOW = 1;
		var READY = false;
		var READY_BUFFER = [];
		var PRESENCE_SUFFIX = '-pnpres';
		var DEF_WINDOWING = 10; // MILLISECONDS.
		var DEF_TIMEOUT = 15000; // MILLISECONDS.
		var DEF_SUB_TIMEOUT = 310; // SECONDS.
		var DEF_KEEPALIVE = 60; // SECONDS (FOR TIMESYNC).
		var SECOND = 1000; // A THOUSAND MILLISECONDS.
		var PRESENCE_HB_THRESHOLD = 5;
		var PRESENCE_HB_DEFAULT = 30;
		var SDK_VER = packageJSON.version;
	
		/**
		 * UTILITIES
		 */
		function unique() {
		  return 'x' + ++NOW + '' + (+new Date);
		}
	
		/**
		 * NEXTORIGIN
		 * ==========
		 * var next_origin = nextorigin();
		 */
		var nextorigin = (function () {
		  var max = 20;
		  var ori = Math.floor(Math.random() * max);
		  return function (origin, failover) {
		    return origin.indexOf('pubsub.') > 0
		      && origin.replace(
		        'pubsub', 'ps' + (
		          failover ? utils.generateUUID().split('-')[0] :
		            (++ori < max ? ori : ori = 1)
		        )) || origin;
		  };
		})();
	
	
		/**
		 * Generate Subscription Channel List
		 * ==================================
		 * generate_channel_list(channels_object);
		 */
		function generate_channel_list(channels, nopresence) {
		  var list = [];
		  utils.each(channels, function (channel, status) {
		    if (nopresence) {
		      if (channel.search('-pnpres') < 0) {
		        if (status.subscribed) list.push(channel);
		      }
		    } else {
		      if (status.subscribed) list.push(channel);
		    }
		  });
		  return list.sort();
		}
	
		/**
		 * Generate Subscription Channel Groups List
		 * ==================================
		 * generate_channel_group_list(channels_groups object);
		 */
		function generate_channel_group_list(channel_groups, nopresence) {
		  var list = [];
		  utils.each(channel_groups, function (channel_group, status) {
		    if (nopresence) {
		      if (channel_group.search('-pnpres') < 0) {
		        if (status.subscribed) list.push(channel_group);
		      }
		    } else {
		      if (status.subscribed) list.push(channel_group);
		    }
		  });
		  return list.sort();
		}
	
		// PUBNUB READY TO CONNECT
		function ready() {
		  if (READY) return;
		  READY = 1;
		  utils.each(READY_BUFFER, function (connect) {
		    connect();
		  });
		}
	
		function PNmessage(args) {
		  var msg = args || { apns: {} };
	
		  msg['getPubnubMessage'] = function () {
		    var m = {};
	
		    if (Object.keys(msg['apns']).length) {
		      m['pn_apns'] = {
		        aps: {
		          alert: msg['apns']['alert'],
		          badge: msg['apns']['badge']
		        }
		      };
		      for (var k in msg['apns']) {
		        m['pn_apns'][k] = msg['apns'][k];
		      }
		      var exclude1 = ['badge', 'alert'];
		      for (var k in exclude1) {
		        delete m['pn_apns'][exclude1[k]];
		      }
		    }
	
		    if (msg['gcm']) {
		      m['pn_gcm'] = {
		        data: msg['gcm']
		      };
		    }
	
		    for (var k in msg) {
		      m[k] = msg[k];
		    }
		    var exclude = ['apns', 'gcm', 'publish', 'channel', 'callback', 'error'];
		    for (var k in exclude) {
		      delete m[exclude[k]];
		    }
	
		    return m;
		  };
		  msg['publish'] = function () {
		    var m = msg.getPubnubMessage();
	
		    if (msg['pubnub'] && msg['channel']) {
		      msg['pubnub'].publish({
		        message: m,
		        channel: msg['channel'],
		        callback: msg['callback'],
		        error: msg['error']
		      });
		    }
		  };
		  return msg;
		}
	
		function PN_API(setup) {
		  var SUB_WINDOWING = +setup['windowing'] || DEF_WINDOWING;
		  var SUB_TIMEOUT = (+setup['timeout'] || DEF_SUB_TIMEOUT) * SECOND;
		  var KEEPALIVE = (+setup['keepalive'] || DEF_KEEPALIVE) * SECOND;
		  var TIME_CHECK = setup['timecheck'] || 0;
		  var NOLEAVE = setup['noleave'] || 0;
		  var PUBLISH_KEY = setup['publish_key'];
		  var SUBSCRIBE_KEY = setup['subscribe_key'];
		  var AUTH_KEY = setup['auth_key'] || '';
		  var SECRET_KEY = setup['secret_key'] || '';
		  var hmac_SHA256 = setup['hmac_SHA256'];
		  var SSL = setup['ssl'] ? 's' : '';
		  var ORIGIN = 'http' + SSL + '://' + (setup['origin'] || 'pubsub.pubnub.com');
		  var STD_ORIGIN = nextorigin(ORIGIN);
		  var SUB_ORIGIN = nextorigin(ORIGIN);
		  var CONNECT = function () {
		  };
		  var PUB_QUEUE = [];
		  var CLOAK = true;
		  var TIME_DRIFT = 0;
		  var SUB_CALLBACK = 0;
		  var SUB_CHANNEL = 0;
		  var SUB_RECEIVER = 0;
		  var SUB_RESTORE = setup['restore'] || 0;
		  var SUB_BUFF_WAIT = 0;
		  var TIMETOKEN = 0;
		  var RESUMED = false;
		  var CHANNELS = {};
		  var CHANNEL_GROUPS = {};
		  var SUB_ERROR = function () {
		  };
		  var STATE = {};
		  var PRESENCE_HB_TIMEOUT = null;
		  var PRESENCE_HB = validate_presence_heartbeat(
		    setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']
		  );
		  var PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || (PRESENCE_HB / 2) - 1;
		  var PRESENCE_HB_RUNNING = false;
		  var NO_WAIT_FOR_PENDING = setup['no_wait_for_pending'];
		  var COMPATIBLE_35 = setup['compatible_3.5'] || false;
		  var xdr = setup['xdr'];
		  var params = setup['params'] || {};
		  var error = setup['error'] || function () {};
		  var _is_online = setup['_is_online'] || function () { return 1;};
		  var jsonp_cb = setup['jsonp_cb'] || function () { return 0; };
		  var db = setup['db'] || { get: function () {}, set: function () {} };
		  var CIPHER_KEY = setup['cipher_key'];
		  var UUID = setup['uuid'] || (!setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY + 'uuid') || '');
		  var USE_INSTANCEID = setup['instance_id'] || false;
		  var INSTANCEID = '';
		  var shutdown = setup['shutdown'];
		  var use_send_beacon = (typeof setup['use_send_beacon'] != 'undefined') ? setup['use_send_beacon'] : true;
		  var sendBeacon = (use_send_beacon) ? setup['sendBeacon'] : null;
		  var _poll_timer;
		  var _poll_timer2;
	
		  if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;
	
		  var crypto_obj = setup['crypto_obj'] || {
		    encrypt: function (a, key) {
		      return a;
		    },
		    decrypt: function (b, key) {
		      return b;
		    }
		  };
	
		  function _get_url_params(data) {
		    if (!data) data = {};
		    utils.each(params, function (key, value) {
		      if (!(key in data)) data[key] = value;
		    });
		    return data;
		  }
	
		  function _object_to_key_list(o) {
		    var l = [];
		    utils.each(o, function (key, value) {
		      l.push(key);
		    });
		    return l;
		  }
	
		  function _object_to_key_list_sorted(o) {
		    return _object_to_key_list(o).sort();
		  }
	
		  function _get_pam_sign_input_from_params(params) {
		    var si = '';
		    var l = _object_to_key_list_sorted(params);
	
		    for (var i in l) {
		      var k = l[i];
		      si += k + '=' + utils.pamEncode(params[k]);
		      if (i != l.length - 1) si += '&';
		    }
		    return si;
		  }
	
		  function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {
		    var err = false;
	
		    if (typeof heartbeat === 'undefined') {
		      return cur_heartbeat;
		    }
	
		    if (typeof heartbeat === 'number') {
		      if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0) {
		        err = false;
		      } else {
		        err = true;
		      }
		    } else if (typeof heartbeat === 'boolean') {
		      if (!heartbeat) {
		        return 0;
		      } else {
		        return PRESENCE_HB_DEFAULT;
		      }
		    } else {
		      err = true;
		    }
	
		    if (err) {
		      error && error('Presence Heartbeat value invalid. Valid range ( x > ' + PRESENCE_HB_THRESHOLD + ' or x = 0). Current Value : ' + (cur_heartbeat || PRESENCE_HB_THRESHOLD));
		      return cur_heartbeat || PRESENCE_HB_THRESHOLD;
		    } else return heartbeat;
		  }
	
		  function encrypt(input, key) {
		    return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;
		  }
	
		  function decrypt(input, key) {
		    return crypto_obj['decrypt'](input, key || CIPHER_KEY) ||
		      crypto_obj['decrypt'](input, CIPHER_KEY) ||
		      input;
		  }
	
		  function error_common(message, callback) {
		    callback && callback({ error: message || 'error occurred' });
		    error && error(message);
		  }
	
		  function _presence_heartbeat() {
		    clearTimeout(PRESENCE_HB_TIMEOUT);
	
		    if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 ||
		      PRESENCE_HB_INTERVAL < 1 ||
		      (!generate_channel_list(CHANNELS, true).length && !generate_channel_group_list(CHANNEL_GROUPS, true).length)) {
		      PRESENCE_HB_RUNNING = false;
		      return;
		    }
	
		    PRESENCE_HB_RUNNING = true;
		    SELF['presence_heartbeat']({
		      callback: function (r) {
		        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND);
		      },
		      error: function (e) {
		        error && error('Presence Heartbeat unable to reach Pubnub servers.' + JSON.stringify(e));
		        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND);
		      }
		    });
		  }
	
		  function start_presence_heartbeat() {
		    !PRESENCE_HB_RUNNING && _presence_heartbeat();
		  }
	
		  function publish(next) {
		    if (NO_WAIT_FOR_PENDING) {
		      if (!PUB_QUEUE.length) return;
		    } else {
		      if (next) PUB_QUEUE.sending = 0;
		      if (PUB_QUEUE.sending || !PUB_QUEUE.length) return;
		      PUB_QUEUE.sending = 1;
		    }
	
		    xdr(PUB_QUEUE.shift());
		  }
	
		  function each_channel_group(callback) {
		    var count = 0;
	
		    utils.each(generate_channel_group_list(CHANNEL_GROUPS), function (channel_group) {
		      var chang = CHANNEL_GROUPS[channel_group];
	
		      if (!chang) return;
	
		      count++;
		      (callback || function () {
		      })(chang);
		    });
	
		    return count;
		  }
	
		  function each_channel(callback) {
		    var count = 0;
	
		    utils.each(generate_channel_list(CHANNELS), function (channel) {
		      var chan = CHANNELS[channel];
	
		      if (!chan) return;
	
		      count++;
		      (callback || function () {
		      })(chan);
		    });
	
		    return count;
		  }
	
		  function _invoke_callback(response, callback, err) {
		    if (typeof response == 'object') {
		      if (response['error']) {
		        var callback_data = {};
	
		        if (response['message']) {
		          callback_data['message'] = response['message'];
		        }
	
		        if (response['payload']) {
		          callback_data['payload'] = response['payload'];
		        }
	
		        err && err(callback_data);
		        return;
		      }
		      if (response['payload']) {
		        if (response['next_page']) {
		          callback && callback(response['payload'], response['next_page']);
		        } else {
		          callback && callback(response['payload']);
		        }
		        return;
		      }
		    }
		    callback && callback(response);
		  }
	
		  function _invoke_error(response, err) {
		    if (typeof response == 'object' && response['error']) {
		      var callback_data = {};
	
		      if (response['message']) {
		        callback_data['message'] = response['message'];
		      }
	
		      if (response['payload']) {
		        callback_data['payload'] = response['payload'];
		      }
	
		      err && err(callback_data);
		      return;
		    } else {
		      err && err(response);
		    }
		  }
	
		  function CR(args, callback, url1, data) {
		    var callback = args['callback'] || callback;
		    var err = args['error'] || error;
		    var jsonp = jsonp_cb();
	
		    data = data || {};
	
		    if (!data['auth']) {
		      data['auth'] = args['auth_key'] || AUTH_KEY;
		    }
	
		    var url = [
		      STD_ORIGIN, 'v1', 'channel-registration',
		      'sub-key', SUBSCRIBE_KEY
		    ];
	
		    url.push.apply(url, url1);
	
		    if (jsonp) data['callback'] = jsonp;
	
		    xdr({
		      callback: jsonp,
		      data: _get_url_params(data),
		      success: function (response) {
		        _invoke_callback(response, callback, err);
		      },
		      fail: function (response) {
		        _invoke_error(response, err);
		      },
		      url: url
		    });
		  }
	
		  // Announce Leave Event
		  var SELF = {
		    LEAVE: function (channel, blocking, auth_key, callback, error) {
		      var data = { uuid: UUID, auth: auth_key || AUTH_KEY };
		      var origin = nextorigin(ORIGIN);
		      var callback = callback || function () {};
		      var err = error || function () {};
		      var url;
		      var params;
		      var jsonp = jsonp_cb();
	
		      // Prevent Leaving a Presence Channel
		      if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;
	
	
		      if (COMPATIBLE_35) {
		        if (!SSL) return false;
		        if (jsonp == '0') return false;
		      }
	
		      if (NOLEAVE) return false;
	
		      if (jsonp != '0') data['callback'] = jsonp;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      url = [
		        origin, 'v2', 'presence', 'sub_key',
		        SUBSCRIBE_KEY, 'channel', utils.encode(channel), 'leave'
		      ];
	
		      params = _get_url_params(data);
	
	
		      if (sendBeacon) {
		        var url_string = utils.buildURL(url, params);
		        if (sendBeacon(url_string)) {
		          callback && callback({ status: 200, action: 'leave', message: 'OK', service: 'Presence' });
		          return true;
		        }
		      }
	
	
		      xdr({
		        blocking: blocking || SSL,
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		      return true;
		    },
	
		    LEAVE_GROUP: function (channel_group, blocking, auth_key, callback, error) {
		      var data = { uuid: UUID, auth: auth_key || AUTH_KEY };
		      var origin = nextorigin(ORIGIN);
		      var url;
		      var params;
		      var callback = callback || function () {};
		      var err = error || function () {};
		      var jsonp = jsonp_cb();
	
		      // Prevent Leaving a Presence Channel Group
		      if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;
	
		      if (COMPATIBLE_35) {
		        if (!SSL) return false;
		        if (jsonp == '0') return false;
		      }
	
		      if (NOLEAVE) return false;
	
		      if (jsonp != '0') data['callback'] = jsonp;
	
		      if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      url = [
		        origin, 'v2', 'presence', 'sub_key',
		        SUBSCRIBE_KEY, 'channel', utils.encode(','), 'leave'
		      ];
	
		      params = _get_url_params(data);
	
		      if (sendBeacon) {
		        var url_string = utils.buildURL(url, params);
		        if (sendBeacon(url_string)) {
		          callback && callback({ status: 200, action: 'leave', message: 'OK', service: 'Presence' });
		          return true;
		        }
		      }
	
		      xdr({
		        blocking: blocking || SSL,
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		      return true;
		    },
	
		    set_resumed: function (resumed) {
		      RESUMED = resumed;
		    },
	
		    get_cipher_key: function () {
		      return CIPHER_KEY;
		    },
	
		    set_cipher_key: function (key) {
		      CIPHER_KEY = key;
		    },
	
		    raw_encrypt: function (input, key) {
		      return encrypt(input, key);
		    },
	
		    raw_decrypt: function (input, key) {
		      return decrypt(input, key);
		    },
	
		    get_heartbeat: function () {
		      return PRESENCE_HB;
		    },
	
		    set_heartbeat: function (heartbeat, heartbeat_interval) {
		      PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, error);
		      PRESENCE_HB_INTERVAL = heartbeat_interval || (PRESENCE_HB / 2) - 1;
		      if (PRESENCE_HB == 2) {
		        PRESENCE_HB_INTERVAL = 1;
		      }
		      CONNECT();
		      _presence_heartbeat();
		    },
	
		    get_heartbeat_interval: function () {
		      return PRESENCE_HB_INTERVAL;
		    },
	
		    set_heartbeat_interval: function (heartbeat_interval) {
		      PRESENCE_HB_INTERVAL = heartbeat_interval;
		      _presence_heartbeat();
		    },
	
		    get_version: function () {
		      return SDK_VER;
		    },
	
		    getGcmMessageObject: function (obj) {
		      return {
		        data: obj
		      };
		    },
	
		    getApnsMessageObject: function (obj) {
		      var x = {
		        aps: { badge: 1, alert: '' }
		      };
		      for (var k in obj) {
		        k[x] = obj[k];
		      }
		      return x;
		    },
	
		    _add_param: function (key, val) {
		      params[key] = val;
		    },
	
		    channel_group: function (args, callback) {
		      var ns_ch = args['channel_group'];
		      var callback = callback || args['callback'];
		      var channels = args['channels'] || args['channel'];
		      var cloak = args['cloak'];
		      var namespace;
		      var channel_group;
		      var url = [];
		      var data = {};
		      var mode = args['mode'] || 'add';
	
	
		      if (ns_ch) {
		        var ns_ch_a = ns_ch.split(':');
	
		        if (ns_ch_a.length > 1) {
		          namespace = (ns_ch_a[0] === '*') ? null : ns_ch_a[0];
	
		          channel_group = ns_ch_a[1];
		        } else {
		          channel_group = ns_ch_a[0];
		        }
		      }
	
		      namespace && url.push('namespace') && url.push(utils.encode(namespace));
	
		      url.push('channel-group');
	
		      if (channel_group && channel_group !== '*') {
		        url.push(channel_group);
		      }
	
		      if (channels) {
		        if (utils.isArray(channels)) {
		          channels = channels.join(',');
		        }
		        data[mode] = channels;
		        data['cloak'] = (CLOAK) ? 'true' : 'false';
		      } else {
		        if (mode === 'remove') url.push('remove');
		      }
	
		      if (typeof cloak != 'undefined') data['cloak'] = (cloak) ? 'true' : 'false';
	
		      CR(args, callback, url, data);
		    },
	
		    channel_group_list_groups: function (args, callback) {
		      var namespace;
	
		      namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;
		      if (namespace) {
		        args['channel_group'] = namespace + ':*';
		      }
	
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_list_channels: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_remove_channel: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (!args['channel'] && !args['channels']) return error('Missing Channel');
	
		      args['mode'] = 'remove';
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_remove_group: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (args['channel']) return error('Use channel_group_remove_channel if you want to remove a channel from a group.');
	
		      args['mode'] = 'remove';
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_add_channel: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (!args['channel'] && !args['channels']) return error('Missing Channel');
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_cloak: function (args, callback) {
		      if (typeof args['cloak'] == 'undefined') {
		        callback(CLOAK);
		        return;
		      }
		      CLOAK = args['cloak'];
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_list_namespaces: function (args, callback) {
		      var url = ['namespace'];
		      CR(args, callback, url);
		    },
	
		    channel_group_remove_namespace: function (args, callback) {
		      var url = ['namespace', args['namespace'], 'remove'];
		      CR(args, callback, url);
		    },
	
		    /*
		     PUBNUB.history({
		     channel  : 'my_chat_channel',
		     limit    : 100,
		     callback : function(history) { }
		     });
		     */
		    history: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var count = args['count'] || args['limit'] || 100;
		      var reverse = args['reverse'] || 'false';
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var cipher_key = args['cipher_key'];
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var start = args['start'];
		      var end = args['end'];
		      var include_token = args['include_token'];
		      var string_msg_token = args['string_message_token'] || false;
		      var params = {};
		      var jsonp = jsonp_cb();
	
		      // Make sure we have a Channel
		      if (!channel && !channel_group) return error('Missing Channel');
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      params['stringtoken'] = 'true';
		      params['count'] = count;
		      params['reverse'] = reverse;
		      params['auth'] = auth_key;
	
		      if (channel_group) {
		        params['channel-group'] = channel_group;
		        if (!channel) {
		          channel = ',';
		        }
		      }
		      if (jsonp) params['callback'] = jsonp;
		      if (start) params['start'] = start;
		      if (end) params['end'] = end;
		      if (include_token) params['include_token'] = 'true';
		      if (string_msg_token) params['string_message_token'] = 'true';
	
		      // Send Message
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(params),
		        success: function (response) {
		          if (typeof response == 'object' && response['error']) {
		            err({ message: response['message'], payload: response['payload'] });
		            return;
		          }
		          var messages = response[0];
		          var decrypted_messages = [];
		          for (var a = 0; a < messages.length; a++) {
		            if (include_token) {
		              var new_message = decrypt(messages[a]['message'], cipher_key);
		              var timetoken = messages[a]['timetoken'];
		              try {
		                decrypted_messages['push']({ message: JSON['parse'](new_message), timetoken: timetoken });
		              } catch (e) {
		                decrypted_messages['push'](({ message: new_message, timetoken: timetoken }));
		              }
		            } else {
		              var new_message = decrypt(messages[a], cipher_key);
		              try {
		                decrypted_messages['push'](JSON['parse'](new_message));
		              } catch (e) {
		                decrypted_messages['push']((new_message));
		              }
		            }
		          }
		          callback([decrypted_messages, response[1], response[2]]);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v2', 'history', 'sub-key',
		          SUBSCRIBE_KEY, 'channel', utils.encode(channel)
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.replay({
		     source      : 'my_channel',
		     destination : 'new_channel'
		     });
		     */
		    replay: function (args, callback) {
		      var callback = callback || args['callback'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var source = args['source'];
		      var destination = args['destination'];
		      var err = args['error'] || args['error'] || function () {};
		      var stop = args['stop'];
		      var start = args['start'];
		      var end = args['end'];
		      var reverse = args['reverse'];
		      var limit = args['limit'];
		      var jsonp = jsonp_cb();
		      var data = {};
		      var url;
	
		      // Check User Input
		      if (!source) return error('Missing Source Channel');
		      if (!destination) return error('Missing Destination Channel');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      // Setup URL Params
		      if (jsonp != '0') data['callback'] = jsonp;
		      if (stop) data['stop'] = 'all';
		      if (reverse) data['reverse'] = 'true';
		      if (start) data['start'] = start;
		      if (end) data['end'] = end;
		      if (limit) data['count'] = limit;
	
		      data['auth'] = auth_key;
	
		      // Compose URL Parts
		      url = [
		        STD_ORIGIN, 'v1', 'replay',
		        PUBLISH_KEY, SUBSCRIBE_KEY,
		        source, destination
		      ];
	
		      // Start (or Stop) Replay!
		      xdr({
		        callback: jsonp,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function () {
		          callback([0, 'Disconnected']);
		        },
		        url: url,
		        data: _get_url_params(data)
		      });
		    },
	
		    /*
		     PUBNUB.auth('AJFLKAJSDKLA');
		     */
		    auth: function (auth) {
		      AUTH_KEY = auth;
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.time(function(time){ });
		     */
		    time: function (callback) {
		      var jsonp = jsonp_cb();
	
		      var data = { uuid: UUID, auth: AUTH_KEY };
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        url: [STD_ORIGIN, 'time', jsonp],
		        success: function (response) {
		          callback(response[0]);
		        },
		        fail: function () {
		          callback(0);
		        }
		      });
		    },
	
		    /*
		     PUBNUB.publish({
		     channel : 'my_chat_channel',
		     message : 'hello!'
		     });
		     */
		    publish: function (args, callback) {
		      var msg = args['message'];
		      if (!msg) return error('Missing Message');
	
		      var callback = callback || args['callback'] || msg['callback'] || args['success'] || function () {};
		      var channel = args['channel'] || msg['channel'];
		      var meta = args['meta'] || args['metadata'];
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var cipher_key = args['cipher_key'];
		      var err = args['error'] || msg['error'] || function () {};
		      var post = args['post'] || false;
		      var store = ('store_in_history' in args) ? args['store_in_history'] : true;
		      var replicate = ('replicate' in args) ? args['replicate'] : true;
		      var jsonp = jsonp_cb();
		      var add_msg = 'push';
		      var params;
		      var url;
	
		      if (args['prepend']) add_msg = 'unshift';
	
		      if (!channel) return error('Missing Channel');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (msg['getPubnubMessage']) {
		        msg = msg['getPubnubMessage']();
		      }
	
		      // If trying to send Object
		      msg = JSON['stringify'](encrypt(msg, cipher_key));
	
		      // Create URL
		      url = [
		        STD_ORIGIN, 'publish',
		        PUBLISH_KEY, SUBSCRIBE_KEY,
		        0, utils.encode(channel),
		        jsonp, utils.encode(msg)
		      ];
	
		      params = { uuid: UUID, auth: auth_key };
	
		      if (meta && typeof meta === 'object') {
		        params['meta'] = JSON.stringify(meta);
		      }
	
		      if (!store) params['store'] = '0';
		      if (!replicate) params['norep'] = 'true';
	
		      if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;
	
		      // Queue Message Send
		      PUB_QUEUE[add_msg]({
		        callback: jsonp,
		        url: url,
		        data: _get_url_params(params),
		        fail: function (response) {
		          _invoke_error(response, err);
		          publish(1);
		        },
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		          publish(1);
		        },
		        mode: (post) ? 'POST' : 'GET'
		      });
	
		      // Send Message
		      publish();
		    },
	
		    fire: function (args, callback) {
		      args.store_in_history = false;
		      args.replicate = false;
		      SELF['publish'](args, callback);
		    },
	
		    /*
		     PUBNUB.unsubscribe({ channel : 'my_chat' });
		     */
		    unsubscribe: function (args, callback) {
		      var channelArg = args['channel'];
		      var channelGroupArg = args['channel_group'];
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var callback = callback || args['callback'] || function () {};
		      var err = args['error'] || function () {};
	
		      if (!channelArg && !channelGroupArg) return error('Missing Channel or Channel Group');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (channelArg) {
		        var channels = utils.isArray(channelArg) ? channelArg : ('' + channelArg).split(',');
		        var existingChannels = [];
		        var presenceChannels = [];
	
		        utils.each(channels, function (channel) {
		          if (CHANNELS[channel]) existingChannels.push(channel);
		        });
	
		        // if we do not have any channels to unsubscribe from, trigger a callback.
		        if (existingChannels.length == 0) {
		          callback({ action: 'leave' });
		          return;
		        }
	
		        // Prepare presence channels
		        utils.each(existingChannels, function (channel) {
		          presenceChannels.push(channel + PRESENCE_SUFFIX);
		        });
	
		        utils.each(existingChannels.concat(presenceChannels), function (channel) {
		          if (channel in CHANNELS) delete CHANNELS[channel];
		          if (channel in STATE) delete STATE[channel];
		        });
	
		        if (CHANNELS.length === 0 && CHANNEL_GROUPS.length === 0) {
		          TIMETOKEN = 0;
		        }
	
		        var CB_CALLED = true;
		        if (READY) {
		          CB_CALLED = SELF['LEAVE'](existingChannels.join(','), 0, auth_key, callback, err);
		        }
		        if (!CB_CALLED) callback({ action: 'leave' });
		      }
	
		      if (channelGroupArg) {
		        var channelGroups = utils.isArray(channelGroupArg) ? channelGroupArg : ('' + channelGroupArg).split(',');
		        var existingChannelGroups = [];
		        var presenceChannelGroups = [];
	
		        utils.each(channelGroups, function (channelGroup) {
		          if (CHANNEL_GROUPS[channelGroup]) existingChannelGroups.push(channelGroup);
		        });
	
		        // if we do not have any channel groups to unsubscribe from, trigger a callback.
		        if (existingChannelGroups.length == 0) {
		          callback({ action: 'leave' });
		          return;
		        }
	
		        // Prepare presence channels
		        utils.each(existingChannelGroups, function (channelGroup) {
		          presenceChannelGroups.push(channelGroup + PRESENCE_SUFFIX);
		        });
	
		        utils.each(existingChannelGroups.concat(presenceChannelGroups), function (channelGroup) {
		          if (channelGroup in CHANNEL_GROUPS) delete CHANNEL_GROUPS[channelGroup];
		          if (channelGroup in STATE) delete STATE[channelGroup];
		        });
	
		        if (CHANNELS.length === 0 && CHANNEL_GROUPS.length === 0) {
		          TIMETOKEN = 0;
		        }
	
		        var CB_CALLED = true;
		        if (READY) {
		          CB_CALLED = SELF['LEAVE_GROUP'](existingChannelGroups.join(','), 0, auth_key, callback, err);
		        }
		        if (!CB_CALLED) callback({ action: 'leave' });
		      }
	
		      // Reset Connection if Count Less
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.subscribe({
		     channel  : 'my_chat'
		     callback : function(message) { }
		     });
		     */
		    subscribe: function (args, callback) {
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var callback = callback || args['callback'];
		      var callback = callback || args['message'];
		      var connect = args['connect'] || function () {};
		      var reconnect = args['reconnect'] || function () {};
		      var disconnect = args['disconnect'] || function () {};
		      var SUB_ERROR = args['error'] || SUB_ERROR || function () {};
		      var idlecb = args['idle'] || function () {};
		      var presence = args['presence'] || 0;
		      var noheresync = args['noheresync'] || 0;
		      var backfill = args['backfill'] || 0;
		      var timetoken = args['timetoken'] || 0;
		      var sub_timeout = args['timeout'] || SUB_TIMEOUT;
		      var windowing = args['windowing'] || SUB_WINDOWING;
		      var state = args['state'];
		      var heartbeat = args['heartbeat'] || args['pnexpires'];
		      var heartbeat_interval = args['heartbeat_interval'];
		      var restore = args['restore'] || SUB_RESTORE;
	
		      AUTH_KEY = args['auth_key'] || AUTH_KEY;
	
		      // Restore Enabled?
		      SUB_RESTORE = restore;
	
		      // Always Reset the TT
		      TIMETOKEN = timetoken;
	
		      // Make sure we have a Channel
		      if (!channel && !channel_group) {
		        return error('Missing Channel');
		      }
	
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {
		        SELF['set_heartbeat'](heartbeat, heartbeat_interval);
		      }
	
		      // Setup Channel(s)
		      if (channel) {
		        utils.each((channel.join ? channel.join(',') : '' + channel).split(','),
		          function (channel) {
		            var settings = CHANNELS[channel] || {};
	
		            // Store Channel State
		            CHANNELS[SUB_CHANNEL = channel] = {
		              name: channel,
		              connected: settings.connected,
		              disconnected: settings.disconnected,
		              subscribed: 1,
		              callback: SUB_CALLBACK = callback,
		              cipher_key: args['cipher_key'],
		              connect: connect,
		              disconnect: disconnect,
		              reconnect: reconnect
		            };
	
		            if (state) {
		              if (channel in state) {
		                STATE[channel] = state[channel];
		              } else {
		                STATE[channel] = state;
		              }
		            }
	
		            // Presence Enabled?
		            if (!presence) return;
	
		            // Subscribe Presence Channel
		            SELF['subscribe']({
		              channel: channel + PRESENCE_SUFFIX,
		              callback: presence,
		              restore: restore
		            });
	
		            // Presence Subscribed?
		            if (settings.subscribed) return;
	
		            // See Who's Here Now?
		            if (noheresync) return;
		            SELF['here_now']({
		              channel: channel,
		              data: _get_url_params({ uuid: UUID, auth: AUTH_KEY }),
		              callback: function (here) {
		                utils.each('uuids' in here ? here['uuids'] : [], function (uid) {
		                  presence({
		                    action: 'join',
		                    uuid: uid,
		                    timestamp: Math.floor(utils.rnow() / 1000),
		                    occupancy: here['occupancy'] || 1
		                  }, here, channel);
		                });
		              }
		            });
		          });
		      }
	
		      // Setup Channel Groups
		      if (channel_group) {
		        utils.each((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','),
		          function (channel_group) {
		            var settings = CHANNEL_GROUPS[channel_group] || {};
	
		            CHANNEL_GROUPS[channel_group] = {
		              name: channel_group,
		              connected: settings.connected,
		              disconnected: settings.disconnected,
		              subscribed: 1,
		              callback: SUB_CALLBACK = callback,
		              cipher_key: args['cipher_key'],
		              connect: connect,
		              disconnect: disconnect,
		              reconnect: reconnect
		            };
	
		            // Presence Enabled?
		            if (!presence) return;
	
		            // Subscribe Presence Channel
		            SELF['subscribe']({
		              channel_group: channel_group + PRESENCE_SUFFIX,
		              callback: presence,
		              restore: restore,
		              auth_key: AUTH_KEY
		            });
	
		            // Presence Subscribed?
		            if (settings.subscribed) return;
	
		            // See Who's Here Now?
		            if (noheresync) return;
		            SELF['here_now']({
		              channel_group: channel_group,
		              data: _get_url_params({ uuid: UUID, auth: AUTH_KEY }),
		              callback: function (here) {
		                utils.each('uuids' in here ? here['uuids'] : [], function (uid) {
		                  presence({
		                    action: 'join',
		                    uuid: uid,
		                    timestamp: Math.floor(utils.rnow() / 1000),
		                    occupancy: here['occupancy'] || 1
		                  }, here, channel_group);
		                });
		              }
		            });
		          });
		      }
	
	
		      // Test Network Connection
		      function _test_connection(success) {
		        if (success) {
		          // Begin Next Socket Connection
		          utils.timeout(CONNECT, windowing);
		        } else {
		          // New Origin on Failed Connection
		          STD_ORIGIN = nextorigin(ORIGIN, 1);
		          SUB_ORIGIN = nextorigin(ORIGIN, 1);
	
		          // Re-test Connection
		          utils.timeout(function () {
		            SELF['time'](_test_connection);
		          }, SECOND);
		        }
	
		        // Disconnect & Reconnect
		        each_channel(function (channel) {
		          // Reconnect
		          if (success && channel.disconnected) {
		            channel.disconnected = 0;
		            return channel.reconnect(channel.name);
		          }
	
		          // Disconnect
		          if (!success && !channel.disconnected) {
		            channel.disconnected = 1;
		            channel.disconnect(channel.name);
		          }
		        });
	
		        // Disconnect & Reconnect for channel groups
		        each_channel_group(function (channel_group) {
		          // Reconnect
		          if (success && channel_group.disconnected) {
		            channel_group.disconnected = 0;
		            return channel_group.reconnect(channel_group.name);
		          }
	
		          // Disconnect
		          if (!success && !channel_group.disconnected) {
		            channel_group.disconnected = 1;
		            channel_group.disconnect(channel_group.name);
		          }
		        });
		      }
	
		      // Evented Subscribe
		      function _connect() {
		        var jsonp = jsonp_cb();
		        var channels = generate_channel_list(CHANNELS).join(',');
		        var channel_groups = generate_channel_group_list(CHANNEL_GROUPS).join(',');
	
		        // Stop Connection
		        if (!channels && !channel_groups) return;
	
		        if (!channels) channels = ',';
	
		        // Connect to PubNub Subscribe Servers
		        _reset_offline();
	
		        var data = _get_url_params({ uuid: UUID, auth: AUTH_KEY });
	
		        if (channel_groups) {
		          data['channel-group'] = channel_groups;
		        }
	
	
		        var st = JSON.stringify(STATE);
		        if (st.length > 2) data['state'] = JSON.stringify(STATE);
	
		        if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;
	
		        if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		        start_presence_heartbeat();
		        SUB_RECEIVER = xdr({
		          timeout: sub_timeout,
		          callback: jsonp,
		          fail: function (response) {
		            if (response && response['error'] && response['service']) {
		              _invoke_error(response, SUB_ERROR);
		              _test_connection(false);
		            } else {
		              SELF['time'](function (success) {
		                !success && (_invoke_error(response, SUB_ERROR));
		                _test_connection(success);
		              });
		            }
		          },
		          data: _get_url_params(data),
		          url: [
		            SUB_ORIGIN, 'subscribe',
		            SUBSCRIBE_KEY, utils.encode(channels),
		            jsonp, TIMETOKEN
		          ],
		          success: function (messages) {
		            // Check for Errors
		            if (!messages || (typeof messages == 'object' && 'error' in messages && messages['error'])) {
		              SUB_ERROR(messages);
		              return utils.timeout(CONNECT, SECOND);
		            }
	
		            // User Idle Callback
		            idlecb(messages[1]);
	
		            // Restore Previous Connection Point if Needed
		            TIMETOKEN = !TIMETOKEN && SUB_RESTORE && db['get'](SUBSCRIBE_KEY) || messages[1];
	
		            /*
		             // Connect
		             each_channel_registry(function(registry){
		             if (registry.connected) return;
		             registry.connected = 1;
		             registry.connect(channel.name);
		             });
		             */
	
		            // Connect
		            each_channel(function (channel) {
		              if (channel.connected) return;
		              channel.connected = 1;
		              channel.connect(channel.name);
		            });
	
		            // Connect for channel groups
		            each_channel_group(function (channel_group) {
		              if (channel_group.connected) return;
		              channel_group.connected = 1;
		              channel_group.connect(channel_group.name);
		            });
	
		            if (RESUMED && !SUB_RESTORE) {
		              TIMETOKEN = 0;
		              RESUMED = false;
		              // Update Saved Timetoken
		              db['set'](SUBSCRIBE_KEY, 0);
		              utils.timeout(_connect, windowing);
		              return;
		            }
	
		            // Invoke Memory Catchup and Receive Up to 100
		            // Previous Messages from the Queue.
		            if (backfill) {
		              TIMETOKEN = 10000;
		              backfill = 0;
		            }
	
		            // Update Saved Timetoken
		            db['set'](SUBSCRIBE_KEY, messages[1]);
	
		            // Route Channel <---> Callback for Message
		            var next_callback = (function () {
		              var channels = '';
		              var channels2 = '';
	
		              if (messages.length > 3) {
		                channels = messages[3];
		                channels2 = messages[2];
		              } else if (messages.length > 2) {
		                channels = messages[2];
		              } else {
		                channels = utils.map(
		                  generate_channel_list(CHANNELS), function (chan) {
		                    return utils.map(
		                      Array(messages[0].length)
		                        .join(',').split(','),
		                      function () {
		                        return chan;
		                      }
		                    );
		                  }).join(',');
		              }
	
		              var list = channels.split(',');
		              var list2 = (channels2) ? channels2.split(',') : [];
	
		              return function () {
		                var channel = list.shift() || SUB_CHANNEL;
		                var channel2 = list2.shift();
	
		                var chobj = {};
	
		                if (channel2) {
		                  if (channel && channel.indexOf('-pnpres') >= 0
		                    && channel2.indexOf('-pnpres') < 0) {
		                    channel2 += '-pnpres';
		                  }
		                  chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || { callback: function () {} };
		                } else {
		                  chobj = CHANNELS[channel];
		                }
	
		                var r = [
		                  chobj
		                    .callback || SUB_CALLBACK,
		                  channel.split(PRESENCE_SUFFIX)[0]
		                ];
		                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);
		                return r;
		              };
		            })();
	
		            var latency = detect_latency(+messages[1]);
		            utils.each(messages[0], function (msg) {
		              var next = next_callback();
		              var decrypted_msg = decrypt(msg,
		                (CHANNELS[next[1]]) ? CHANNELS[next[1]]['cipher_key'] : null);
		              next[0] && next[0](decrypted_msg, messages, next[2] || next[1], latency, next[1]);
		            });
	
		            utils.timeout(_connect, windowing);
		          }
		        });
		      }
	
		      CONNECT = function () {
		        _reset_offline();
		        utils.timeout(_connect, windowing);
		      };
	
		      // Reduce Status Flicker
		      if (!READY) return READY_BUFFER.push(CONNECT);
	
		      // Connect Now
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.here_now({ channel : 'my_chat', callback : fun });
		     */
		    here_now: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var debug = args['debug'];
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var jsonp = jsonp_cb();
		      var uuids = ('uuids' in args) ? args['uuids'] : true;
		      var state = args['state'];
		      var data = { uuid: UUID, auth: auth_key };
	
		      if (!uuids) data['disable_uuids'] = 1;
		      if (state) data['state'] = 1;
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      var url = [
		        STD_ORIGIN, 'v2', 'presence',
		        'sub_key', SUBSCRIBE_KEY
		      ];
	
		      channel && url.push('channel') && url.push(utils.encode(channel));
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (channel_group) {
		        data['channel-group'] = channel_group;
		        !channel && url.push('channel') && url.push(',');
		      }
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        debug: debug,
		        url: url
		      });
		    },
	
		    /*
		     PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });
		     */
		    where_now: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var jsonp = jsonp_cb();
		      var uuid = args['uuid'] || UUID;
		      var data = { auth: auth_key };
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub_key', SUBSCRIBE_KEY,
		          'uuid', utils.encode(uuid)
		        ]
		      });
		    },
	
		    state: function (args, callback) {
		      var callback = args['callback'] || callback || function (r) {};
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var jsonp = jsonp_cb();
		      var state = args['state'];
		      var uuid = args['uuid'] || UUID;
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var url;
		      var data = _get_url_params({ auth: auth_key });
	
		      // Make sure we have a Channel
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!uuid) return error('Missing UUID');
		      if (!channel && !channel_group) return error('Missing Channel');
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (typeof channel != 'undefined'
		        && CHANNELS[channel] && CHANNELS[channel].subscribed) {
		        if (state) STATE[channel] = state;
		      }
	
		      if (typeof channel_group != 'undefined'
		        && CHANNEL_GROUPS[channel_group]
		        && CHANNEL_GROUPS[channel_group].subscribed
		      ) {
		        if (state) STATE[channel_group] = state;
		        data['channel-group'] = channel_group;
	
		        if (!channel) {
		          channel = ',';
		        }
		      }
	
		      data['state'] = JSON.stringify(state);
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      if (state) {
		        url = [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channel,
		          'uuid', uuid, 'data'
		        ];
		      } else {
		        url = [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channel,
		          'uuid', utils.encode(uuid)
		        ];
		      }
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
	
		      });
		    },
	
		    /*
		     PUBNUB.grant({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     ttl      : 24 * 60, // Minutes
		     read     : true,
		     write    : true,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    grant: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var channel = args['channel'] || args['channels'];
		      var channel_group = args['channel_group'];
		      var jsonp = jsonp_cb();
		      var ttl = args['ttl'];
		      var r = (args['read']) ? '1' : '0';
		      var w = (args['write']) ? '1' : '0';
		      var m = (args['manage']) ? '1' : '0';
		      var auth_key = args['auth_key'] || args['auth_keys'];
	
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SECRET_KEY) return error('Missing Secret Key');
	
		      var timestamp = Math.floor(new Date().getTime() / 1000);
		      var sign_input = SUBSCRIBE_KEY + '\n' + PUBLISH_KEY + '\n' + 'grant' + '\n';
	
		      var data = { w: w, r: r, timestamp: timestamp };
	
		      if (args['manage']) {
		        data['m'] = m;
		      }
		      if (utils.isArray(channel)) {
		        channel = channel['join'](',');
		      }
		      if (utils.isArray(auth_key)) {
		        auth_key = auth_key['join'](',');
		      }
		      if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;
		      if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {
		        data['channel-group'] = channel_group;
		      }
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
		      if (ttl || ttl === 0) data['ttl'] = ttl;
	
		      if (auth_key) data['auth'] = auth_key;
	
		      data = _get_url_params(data);
	
		      if (!auth_key) delete data['auth'];
	
		      sign_input += _get_pam_sign_input_from_params(data);
	
		      var signature = hmac_SHA256(sign_input, SECRET_KEY);
	
		      signature = signature.replace(/\+/g, '-');
		      signature = signature.replace(/\//g, '_');
	
		      data['signature'] = signature;
	
		      xdr({
		        callback: jsonp,
		        data: data,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v1', 'auth', 'grant',
		          'sub-key', SUBSCRIBE_KEY
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.mobile_gw_provision ({
		     device_id: 'A655FBA9931AB',
		     op       : 'add' | 'remove',
		     gw_type  : 'apns' | 'gcm',
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     });
		     */
	
		    mobile_gw_provision: function (args) {
		      var callback = args['callback'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var err = args['error'] || function () {};
		      var jsonp = jsonp_cb();
		      var channel = args['channel'];
		      var op = args['op'];
		      var gw_type = args['gw_type'];
		      var device_id = args['device_id'];
		      var params;
		      var url;
	
		      if (!device_id) return error('Missing Device ID (device_id)');
		      if (!gw_type) return error('Missing GW Type (gw_type: gcm or apns)');
		      if (!op) return error('Missing GW Operation (op: add or remove)');
		      if (!channel) return error('Missing gw destination Channel (channel)');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      // Create URL
		      url = [
		        STD_ORIGIN, 'v1/push/sub-key',
		        SUBSCRIBE_KEY, 'devices', device_id
		      ];
	
		      params = { uuid: UUID, auth: auth_key, type: gw_type };
	
		      if (op == 'add') {
		        params['add'] = channel;
		      } else if (op == 'remove') {
		        params['remove'] = channel;
		      }
	
		      if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		    },
	
		    /*
		     PUBNUB.audit({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     read     : true,
		     write    : true,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    audit: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var auth_key = args['auth_key'];
		      var jsonp = jsonp_cb();
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SECRET_KEY) return error('Missing Secret Key');
	
		      var timestamp = Math.floor(new Date().getTime() / 1000);
		      var sign_input = SUBSCRIBE_KEY + '\n' + PUBLISH_KEY + '\n' + 'audit' + '\n';
	
		      var data = { timestamp: timestamp };
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
		      if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;
		      if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {
		        data['channel-group'] = channel_group;
		      }
		      if (auth_key) data['auth'] = auth_key;
	
		      data = _get_url_params(data);
	
		      if (!auth_key) delete data['auth'];
	
		      sign_input += _get_pam_sign_input_from_params(data);
	
		      var signature = hmac_SHA256(sign_input, SECRET_KEY);
	
		      signature = signature.replace(/\+/g, '-');
		      signature = signature.replace(/\//g, '_');
	
		      data['signature'] = signature;
		      xdr({
		        callback: jsonp,
		        data: data,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v1', 'auth', 'audit',
		          'sub-key', SUBSCRIBE_KEY
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.revoke({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    revoke: function (args, callback) {
		      args['read'] = false;
		      args['write'] = false;
		      SELF['grant'](args, callback);
		    },
	
		    set_uuid: function (uuid) {
		      UUID = uuid;
		      CONNECT();
		    },
	
		    get_uuid: function () {
		      return UUID;
		    },
	
		    isArray: function (arg) {
		      return utils.isArray(arg);
		    },
	
		    get_subscribed_channels: function () {
		      return generate_channel_list(CHANNELS, true);
		    },
	
		    presence_heartbeat: function (args) {
		      var callback = args['callback'] || function () {};
		      var err = args['error'] || function () {};
		      var jsonp = jsonp_cb();
		      var data = { uuid: UUID, auth: AUTH_KEY };
	
		      var st = JSON['stringify'](STATE);
		      if (st.length > 2) data['state'] = JSON['stringify'](STATE);
	
		      if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      var channels = utils.encode(generate_channel_list(CHANNELS, true)['join'](','));
		      var channel_groups = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');
	
		      if (!channels) channels = ',';
		      if (channel_groups) data['channel-group'] = channel_groups;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        url: [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channels,
		          'heartbeat'
		        ],
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        }
		      });
		    },
	
		    stop_timers: function () {
		      clearTimeout(_poll_timer);
		      clearTimeout(_poll_timer2);
		      clearTimeout(PRESENCE_HB_TIMEOUT);
		    },
	
		    shutdown: function () {
		      SELF['stop_timers']();
		      shutdown && shutdown();
		    },
	
		    // Expose PUBNUB Functions
		    xdr: xdr,
		    ready: ready,
		    db: db,
		    uuid: utils.generateUUID,
		    map: utils.map,
		    each: utils.each,
		    'each-channel': each_channel,
		    grep: utils.grep,
		    offline: function () {
		      _reset_offline(1, { message: 'Offline. Please check your network settings.' });
		    },
		    supplant: utils.supplant,
		    now: utils.rnow,
		    unique: unique,
		    updater: utils.updater
		  };
	
		  function _poll_online() {
		    _is_online() || _reset_offline(1, { error: 'Offline. Please check your network settings.' });
		    _poll_timer && clearTimeout(_poll_timer);
		    _poll_timer = utils.timeout(_poll_online, SECOND);
		  }
	
		  function _poll_online2() {
		    if (!TIME_CHECK) return;
		    SELF['time'](function (success) {
		      detect_time_detla(function () {
		      }, success);
		      success || _reset_offline(1, {
		        error: 'Heartbeat failed to connect to Pubnub Servers.' +
		        'Please check your network settings.'
		      });
		      _poll_timer2 && clearTimeout(_poll_timer2);
		      _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE);
		    });
		  }
	
		  function _reset_offline(err, msg) {
		    SUB_RECEIVER && SUB_RECEIVER(err, msg);
		    SUB_RECEIVER = null;
	
		    clearTimeout(_poll_timer);
		    clearTimeout(_poll_timer2);
		  }
	
		  if (!UUID) UUID = SELF['uuid']();
		  if (!INSTANCEID) INSTANCEID = SELF['uuid']();
		  db['set'](SUBSCRIBE_KEY + 'uuid', UUID);
	
		  _poll_timer = utils.timeout(_poll_online, SECOND);
		  _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE);
		  PRESENCE_HB_TIMEOUT = utils.timeout(
		    start_presence_heartbeat,
		    (PRESENCE_HB_INTERVAL - 3) * SECOND
		  );
	
		  // Detect Age of Message
		  function detect_latency(tt) {
		    var adjusted_time = utils.rnow() - TIME_DRIFT;
		    return adjusted_time - tt / 10000;
		  }
	
		  detect_time_detla();
		  function detect_time_detla(cb, time) {
		    var stime = utils.rnow();
	
		    time && calculate(time) || SELF['time'](calculate);
	
		    function calculate(time) {
		      if (!time) return;
		      var ptime = time / 10000;
		      var latency = (utils.rnow() - stime) / 2;
		      TIME_DRIFT = utils.rnow() - (ptime + latency);
		      cb && cb(TIME_DRIFT);
		    }
		  }
	
		  return SELF;
		}
	
		module.exports = {
		  PN_API: PN_API,
		  unique: unique,
		  PNmessage: PNmessage,
		  DEF_TIMEOUT: DEF_TIMEOUT,
		  timeout: utils.timeout,
		  build_url: utils.buildURL,
		  each: utils.each,
		  uuid: utils.generateUUID,
		  URLBIT: defaultConfiguration.URLBIT,
		  grep: utils.grep,
		  supplant: utils.supplant,
		  now: utils.rnow,
		  updater: utils.updater,
		  map: utils.map
		};
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		module.exports = {
			"PARAMSBIT": "&",
			"URLBIT": "/"
		};
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint no-unused-expressions: 0, block-scoped-var: 0, no-redeclare: 0, guard-for-in: 0 */
	
		var defaultConfiguration = __webpack_require__(3);
		var REPL = /{([\w\-]+)}/g;
	
		function rnow() {
		  return +new Date;
		}
	
		function isArray(arg) {
		  return !!arg && typeof arg !== 'string' && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === 'number');
		  // return !!arg && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === "number")
		}
	
		/**
		 * EACH
		 * ====
		 * each( [1,2,3], function(item) { } )
		 */
		function each(o, f) {
		  if (!o || !f) {
		    return;
		  }
	
		  if (isArray(o)) {
		    for (var i = 0, l = o.length; i < l;) {
		      f.call(o[i], o[i], i++);
		    }
		  } else {
		    for (var i in o) {
		      o.hasOwnProperty &&
		      o.hasOwnProperty(i) &&
		      f.call(o[i], i, o[i]);
		    }
		  }
		}
	
		/**
		 * ENCODE
		 * ======
		 * var encoded_data = encode('path');
		 */
		function encode(path) { return encodeURIComponent(path); }
	
		/**
		 * Build Url
		 * =======
		 *
		 */
		function buildURL(urlComponents, urlParams) {
		  var url = urlComponents.join(defaultConfiguration.URLBIT);
		  var params = [];
	
		  if (!urlParams) return url;
	
		  each(urlParams, function (key, value) {
		    var valueStr = (typeof value === 'object') ? JSON['stringify'](value) : value;
		    (typeof value !== 'undefined' &&
		      value !== null && encode(valueStr).length > 0
		    ) && params.push(key + '=' + encode(valueStr));
		  });
	
		  url += '?' + params.join(defaultConfiguration.PARAMSBIT);
		  return url;
		}
	
		/**
		 * UPDATER
		 * =======
		 * var timestamp = unique();
		 */
		function updater(fun, rate) {
		  var timeout;
		  var last = 0;
		  var runnit = function () {
		    if (last + rate > rnow()) {
		      clearTimeout(timeout);
		      timeout = setTimeout(runnit, rate);
		    } else {
		      last = rnow();
		      fun();
		    }
		  };
	
		  return runnit;
		}
	
		/**
		 * GREP
		 * ====
		 * var list = grep( [1,2,3], function(item) { return item % 2 } )
		 */
		function grep(list, fun) {
		  var fin = [];
		  each(list || [], function (l) {
		    fun(l) && fin.push(l);
		  });
		  return fin;
		}
	
		/**
		 * SUPPLANT
		 * ========
		 * var text = supplant( 'Hello {name}!', { name : 'John' } )
		 */
		function supplant(str, values) {
		  return str.replace(REPL, function (_, match) {
		    return values[match] || _;
		  });
		}
	
		/**
		 * timeout
		 * =======
		 * timeout( function(){}, 100 );
		 */
		function timeout(fun, wait) {
		  if (typeof setTimeout === 'undefined') {
		    return;
		  }
	
		  return setTimeout(fun, wait);
		}
	
		/**
		 * uuid
		 * ====
		 * var my_uuid = generateUUID();
		 */
		function generateUUID(callback) {
		  var u = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,
		    function (c) {
		      var r = Math.random() * 16 | 0;
		      var v = c === 'x' ? r : (r & 0x3 | 0x8);
		      return v.toString(16);
		    });
		  if (callback) callback(u);
		  return u;
		}
	
		/**
		 * MAP
		 * ===
		 * var list = map( [1,2,3], function(item) { return item + 1 } )
		 */
		function map(list, fun) {
		  var fin = [];
		  each(list || [], function (k, v) {
		    fin.push(fun(k, v));
		  });
		  return fin;
		}
	
	
		function pamEncode(str) {
		  return encodeURIComponent(str).replace(/[!'()*~]/g, function (c) {
		    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		  });
		}
	
	
		module.exports = {
		  buildURL: buildURL,
		  encode: encode,
		  each: each,
		  updater: updater,
		  rnow: rnow,
		  isArray: isArray,
		  map: map,
		  pamEncode: pamEncode,
		  generateUUID: generateUUID,
		  timeout: timeout,
		  supplant: supplant,
		  grep: grep
		};
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint camelcase: 0 eqeqeq: 0 */
	
		var CryptoJS = __webpack_require__(6);
	
		function crypto_obj() {
		  function SHA256(s) {
		    return CryptoJS['SHA256'](s)['toString'](CryptoJS['enc']['Hex']);
		  }
	
		  var iv = '0123456789012345';
	
		  var allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];
		  var allowedKeyLengths = [128, 256];
		  var allowedModes = ['ecb', 'cbc'];
	
		  var defaultOptions = {
		    encryptKey: true,
		    keyEncoding: 'utf8',
		    keyLength: 256,
		    mode: 'cbc'
		  };
	
		  function parse_options(options) {
		    // Defaults
		    options = options || {};
		    if (!options['hasOwnProperty']('encryptKey')) options['encryptKey'] = defaultOptions['encryptKey'];
		    if (!options['hasOwnProperty']('keyEncoding')) options['keyEncoding'] = defaultOptions['keyEncoding'];
		    if (!options['hasOwnProperty']('keyLength')) options['keyLength'] = defaultOptions['keyLength'];
		    if (!options['hasOwnProperty']('mode')) options['mode'] = defaultOptions['mode'];
	
		    // Validation
		    if (allowedKeyEncodings['indexOf'](options['keyEncoding']['toLowerCase']()) == -1) options['keyEncoding'] = defaultOptions['keyEncoding'];
		    if (allowedKeyLengths['indexOf'](parseInt(options['keyLength'], 10)) == -1) options['keyLength'] = defaultOptions['keyLength'];
		    if (allowedModes['indexOf'](options['mode']['toLowerCase']()) == -1) options['mode'] = defaultOptions['mode'];
	
		    return options;
		  }
	
		  function decode_key(key, options) {
		    if (options['keyEncoding'] === 'base64') {
		      return CryptoJS['enc']['Base64']['parse'](key);
		    } else if (options['keyEncoding'] === 'hex') {
		      return CryptoJS['enc']['Hex']['parse'](key);
		    } else {
		      return key;
		    }
		  }
	
		  function get_padded_key(key, options) {
		    key = decode_key(key, options);
		    if (options['encryptKey']) {
		      return CryptoJS['enc']['Utf8']['parse'](SHA256(key)['slice'](0, 32));
		    } else {
		      return key;
		    }
		  }
	
		  function get_mode(options) {
		    if (options['mode'] === 'ecb') {
		      return CryptoJS['mode']['ECB'];
		    } else {
		      return CryptoJS['mode']['CBC'];
		    }
		  }
	
		  function get_iv(options) {
		    return (options['mode'] === 'cbc') ? CryptoJS['enc']['Utf8']['parse'](iv) : null;
		  }
	
		  return {
		    encrypt: function (data, key, options) {
		      if (!key) return data;
		      options = parse_options(options);
		      var iv = get_iv(options);
		      var mode = get_mode(options);
		      var cipher_key = get_padded_key(key, options);
		      var hex_message = JSON['stringify'](data);
		      var encryptedHexArray = CryptoJS['AES']['encrypt'](hex_message, cipher_key, { iv: iv, mode: mode })['ciphertext'];
		      var base_64_encrypted = encryptedHexArray['toString'](CryptoJS['enc']['Base64']);
		      return base_64_encrypted || data;
		    },
	
		    decrypt: function (data, key, options) {
		      if (!key) return data;
		      options = parse_options(options);
		      var iv = get_iv(options);
		      var mode = get_mode(options);
		      var cipher_key = get_padded_key(key, options);
		      try {
		        var binary_enc = CryptoJS['enc']['Base64']['parse'](data);
		        var json_plain = CryptoJS['AES']['decrypt']({ ciphertext: binary_enc }, cipher_key, { iv: iv, mode: mode })['toString'](CryptoJS['enc']['Utf8']);
		        var plaintext = JSON['parse'](json_plain);
		        return plaintext;
		      } catch (e) {
		        return undefined;
		      }
		    }
		  };
		}
	
		module.exports = crypto_obj;
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
		/*
		 CryptoJS v3.1.2
		 code.google.com/p/crypto-js
		 (c) 2009-2013 by Jeff Mott. All rights reserved.
		 code.google.com/p/crypto-js/wiki/License
		 */
		var CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
		    r=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
		      32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
		        2),16)<<24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},
		    u=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);
		      a._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,
		    d)).finalize(c)}}});var t=f.algo={};return f}(Math);
	
		// SHA256
		(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64>n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t<=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64>p;p++){if(16>p)a[p]=
		  c[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+a[p-7]+((l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10)+a[p-16]}k=q+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&m^~h&n)+r[p]+a[p];l=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
		  d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);
	
		// HMAC SHA256
		(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;"string"==typeof g&&(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes>m&&(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j<h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=
		  this._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();
	
		// Base64
		(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<
		l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
	
		// BlockCipher
		(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
		  _doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
		    f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
		      m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
		      E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/
		    4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
		(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
		  l)}})();
	
		// Cipher
		CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
		  finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return("string"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return("string"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=
		  c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
		  e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
		  this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
		  1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
		  decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
		  b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
	
		// AES
		(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
		  16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>
		8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=
		  d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();
	
		// Mode ECB
		CryptoJS.mode.ECB = (function () {
		  var ECB = CryptoJS.lib.BlockCipherMode.extend();
	
		  ECB.Encryptor = ECB.extend({
		    processBlock: function (words, offset) {
		      this._cipher.encryptBlock(words, offset);
		    }
		  });
	
		  ECB.Decryptor = ECB.extend({
		    processBlock: function (words, offset) {
		      this._cipher.decryptBlock(words, offset);
		    }
		  });
	
		  return ECB;
		}());
	
		module.exports = CryptoJS;
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET INTERFACE
		// ---------------------------------------------------------------------------
		var WS = function( url, protocols ) {
		  if (!(this instanceof WS)) return new WS( url, protocols );
	
		  var self     = this
		    ,   url      = self.url      = url || ''
		    ,   protocol = self.protocol = protocols || 'Sec-WebSocket-Protocol'
		    ,   bits     = url.split('/')
		    ,   setup    = {
		    'ssl'           : bits[0] === 'wss:'
		    ,'origin'        : bits[2]
		    ,'publish_key'   : bits[3]
		    ,'subscribe_key' : bits[4]
		    ,'channel'       : bits[5]
		  };
	
		  // READY STATES
		  self['CONNECTING'] = 0; // The connection is not yet open.
		  self['OPEN']       = 1; // The connection is open and ready to communicate.
		  self['CLOSING']    = 2; // The connection is in the process of closing.
		  self['CLOSED']     = 3; // The connection is closed or couldn't be opened.
	
		  // CLOSE STATES
		  self['CLOSE_NORMAL']         = 1000; // Normal Intended Close; completed.
		  self['CLOSE_GOING_AWAY']     = 1001; // Closed Unexpecttedly.
		  self['CLOSE_PROTOCOL_ERROR'] = 1002; // Server: Not Supported.
		  self['CLOSE_UNSUPPORTED']    = 1003; // Server: Unsupported Protocol.
		  self['CLOSE_TOO_LARGE']      = 1004; // Server: Too Much Data.
		  self['CLOSE_NO_STATUS']      = 1005; // Server: No reason.
		  self['CLOSE_ABNORMAL']       = 1006; // Abnormal Disconnect.
	
		  // Events Default
		  self['onclose']   = self['onerror'] =
		    self['onmessage'] = self['onopen']  =
		      self['onsend']    =  function(){};
	
		  // Attributes
		  self['binaryType']     = '';
		  self['extensions']     = '';
		  self['bufferedAmount'] = 0;
		  self['trasnmitting']   = false;
		  self['buffer']         = [];
		  self['readyState']     = self['CONNECTING'];
	
		  // Close if no setup.
		  if (!url) {
		    self['readyState'] = self['CLOSED'];
		    self['onclose']({
		      'code'     : self['CLOSE_ABNORMAL'],
		      'reason'   : 'Missing URL',
		      'wasClean' : true
		    });
		    return self;
		  }
	
		  // PubNub WebSocket Emulation
		  self.pubnub       = PUBNUB['init'](setup);
		  self.pubnub.setup = setup;
		  self.setup        = setup;
	
		  self.pubnub['subscribe']({
		    'restore'    : false,
		    'channel'    : setup['channel'],
		    'disconnect' : self['onerror'],
		    'reconnect'  : self['onopen'],
		    'error'      : function() {
		      self['onclose']({
		        'code'     : self['CLOSE_ABNORMAL'],
		        'reason'   : 'Missing URL',
		        'wasClean' : false
		      });
		    },
		    'callback'   : function(message) {
		      self['onmessage']({ 'data' : message });
		    },
		    'connect'    : function() {
		      self['readyState'] = self['OPEN'];
		      self['onopen']();
		    }
		  });
		};
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET SEND
		// ---------------------------------------------------------------------------
		WS.prototype.send = function(data) {
		  var self = this;
		  self.pubnub['publish']({
		    'channel'  : self.pubnub.setup['channel'],
		    'message'  : data,
		    'callback' : function(response) {
		      self['onsend']({ 'data' : response });
		    }
		  });
		};
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET CLOSE
		// ---------------------------------------------------------------------------
		WS.prototype.close = function() {
		  var self = this;
		  self.pubnub['unsubscribe']({ 'channel' : self.pubnub.setup['channel'] });
		  self['readyState'] = self['CLOSED'];
		  self['onclose']({});
		};
	
		module.exports = WS;
	
	
	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["Client"] = factory();
		else
			root["RingCentral"] = root["RingCentral"] || {}, root["RingCentral"]["Client"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(1);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="./externals.d.ts" />
	"use strict";
	var accountClient = __webpack_require__(2);
	var callLogClient = __webpack_require__(40);
	var dictionaryClient = __webpack_require__(55);
	var extensionClient = __webpack_require__(70);
	var messagesClient = __webpack_require__(77);
	var notificationsClient = __webpack_require__(84);
	var presenceClient = __webpack_require__(87);
	var ringoutClient = __webpack_require__(93);
	var forwardingNumbersClient = __webpack_require__(96);
	var blockedNumbersClient = __webpack_require__(99);
	var Client = (function () {
	    function Client(sdk) {
	        this._sdk = sdk;
	        this._account = new accountClient.Account(sdk);
	        this._callLog = new callLogClient.CallLog(sdk);
	        this._dictionary = new dictionaryClient.Dictionary(sdk);
	        this._extension = new extensionClient.Extension(sdk);
	        this._messages = new messagesClient.Messages(sdk);
	        this._notifications = new notificationsClient.NotificationsSubscriptionAPI(sdk);
	        this._presence = new presenceClient.Presence(sdk);
	        this._ringout = new ringoutClient.RingOut(sdk);
	        this._forwardingNumbers = new forwardingNumbersClient.ForwardingNumbers(sdk);
	        this._blockedNumbers = new blockedNumbersClient.BlockedNumbers(sdk);
	    }
	    Client.prototype.account = function () { return this._account; };
	    Client.prototype.callLog = function () { return this._callLog; };
	    Client.prototype.dictionary = function () { return this._dictionary; };
	    Client.prototype.extension = function () { return this._extension; };
	    Client.prototype.messages = function () { return this._messages; };
	    Client.prototype.notifications = function () { return this._notifications; };
	    Client.prototype.presence = function () { return this._presence; };
	    Client.prototype.ringout = function () { return this._ringout; };
	    Client.prototype.forwardingNumbers = function () { return this._forwardingNumbers; };
	    Client.prototype.blockedNumbers = function () { return this._blockedNumbers; };
	    Client.version = '0.1.0';
	    return Client;
	}());
	module.exports = Client;
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var accountinfo = __webpack_require__(4);
	var accountbusinessaddress = __webpack_require__(28);
	var dialingplaninfo = __webpack_require__(30);
	var phonenumberinfo = __webpack_require__(34);
	var accountphonenumbers = __webpack_require__(36);
	var accountserviceinfo = __webpack_require__(37);
	var Account = (function (_super) {
	    __extends(Account, _super);
	    function Account() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Account
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Creates the account in Initial state.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>Accounts</td>
	     *             <td>Managing accounts: creating new accounts, viewing and updating account information, deleting existing accounts</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.createAccount = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account', options, exports.createAccountOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Get Account Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns basic information about a particular RingCentral customer account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccount = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}', options, exports.loadAccountOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Get Account Business Address
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccountBusinessAddress = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/business-address', options, exports.loadAccountBusinessAddressOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Update Account Business Address
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.updateAccountBusinessAddress = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/business-address', options, exports.updateAccountBusinessAddressOptions), accountbusinessaddress.AccountBusinessAddress);
	    };
	    /**
	     * Get Account Dialing Plan
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns list of countries which can be selected for a dialing plan (to call short numbers and special services).</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Account.prototype.listDialingPlans = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/dialing-plan', options, exports.listDialingPlansOptions), dialingplaninfo.DialingPlanInfo);
	    };
	    /**
	     * Provision Phone Numbers
	     *
	     * <p style='font-style:italic;'>Since 1.0.11 (Release 6.3)</p>
	     * <p>Provisions a phone number.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.provisionPhoneNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/phone-number', options, exports.provisionPhoneNumberOptions), phonenumberinfo.PhoneNumberInfo);
	    };
	    /**
	     * Get Account Phone Numbers
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers assigned to the RingCentral customer account. Both company-level and extension-level numbers are returned.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Account.prototype.listAccountPhoneNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/phone-number', options, exports.listAccountPhoneNumbersOptions), accountphonenumbers.AccountPhoneNumbers);
	    };
	    /**
	     * Get Phone Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccountPhoneNumber = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/phone-number/{phoneNumberId}', options, exports.loadAccountPhoneNumberOptions), phonenumberinfo.PhoneNumberInfo);
	    };
	    /**
	     * Get Account Service Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns the information about service plan, available features and limitations for a particular RingCentral customer account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadServiceInfo = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/service-info', options, exports.loadServiceInfoOptions), accountserviceinfo.AccountServiceInfo);
	    };
	    return Account;
	}(client.Client));
	exports.Account = Account;
	/**
	 * Definition of options for createAccount operation
	 */
	exports.createAccountOptions = [
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createaccountrequest.CreateAccountRequest"
	    }
	];
	/**
	 * Definition of options for loadAccount operation
	 */
	exports.loadAccountOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadAccountBusinessAddress operation
	 */
	exports.loadAccountBusinessAddressOptions = [];
	/**
	 * Definition of options for updateAccountBusinessAddress operation
	 */
	exports.updateAccountBusinessAddressOptions = [
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "modifyaccountbusinessaddressrequest.ModifyAccountBusinessAddressRequest"
	    }
	];
	/**
	 * Definition of options for listDialingPlans operation
	 */
	exports.listDialingPlansOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for provisionPhoneNumber operation
	 */
	exports.provisionPhoneNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "provisionphonenumbers.ProvisionPhoneNumbers"
	    }
	];
	/**
	 * Definition of options for listAccountPhoneNumbers operation
	 */
	exports.listAccountPhoneNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "usageType",
	        "type": "IListAccountPhoneNumbersUsageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "MainCompanyNumber",
	            "AdditionalCompanyNumber",
	            "CompanyNumber",
	            "DirectNumber",
	            "CompanyFaxNumber",
	            "ForwardedNumber"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountPhoneNumber operation
	 */
	exports.loadAccountPhoneNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "phoneNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for loadServiceInfo operation
	 */
	exports.loadServiceInfoOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	(function (IListAccountPhoneNumbersUsageType) {
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.IListAccountPhoneNumbersUsageType || (exports.IListAccountPhoneNumbersUsageType = {}));
	var IListAccountPhoneNumbersUsageType = exports.IListAccountPhoneNumbersUsageType;
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var Client = (function () {
	    function Client(sdk) {
	        this._sdk = sdk;
	    }
	    Client.prototype.parseOptions = function (method, url, options, operationParameters) {
	        options = options || {};
	        var request = {
	            url: url,
	            method: method,
	            query: {},
	            body: undefined
	        };
	        operationParameters.forEach(function (param) {
	            if (param.required && !param.default && !options.hasOwnProperty(param.name)) {
	                throw new Error('Required parameter "' + param.name + '" not found');
	            }
	            if (param.default && !options.hasOwnProperty(param.name)) {
	                options[param.name] = param.default;
	            }
	            if (param.in == 'path') {
	                request.url = request.url.replace('{' + param.name + '}', options[param.name]);
	            }
	            if (param.in == 'query' && options.hasOwnProperty(param.name)) {
	                request.query[param.name] = options[param.name];
	            }
	            if (param.in == 'body') {
	                request.body = options[param.name];
	            }
	        });
	        return request;
	    };
	    Client.prototype.send = function (apiOptions, Class) {
	        var _this = this;
	        return this._sdk.platform()
	            .send(apiOptions)
	            .then(function (res) {
	            //TODO Support multipart
	            //TODO Think how to pass headers&stuff to outside
	            if (Class && !res._isMultipart())
	                return new Class(_this._sdk, res.json());
	            return res;
	        });
	    };
	    return Client;
	}());
	exports.Client = Client;
	
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var serviceinfo = __webpack_require__(22);
	var accountstatusinfo = __webpack_require__(27);
	var AccountInfo = (function (_super) {
	    __extends(AccountInfo, _super);
	    function AccountInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'mainNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'operator', Class: extensioninfo.ExtensionInfo, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'serviceInfo', Class: serviceinfo.ServiceInfo, isArray: false, isRequired: false },
	            { property: 'setupWizardState', Class: AccountInfoSetupWizardState, isArray: false, isRequired: false },
	            { property: 'status', Class: AccountInfoStatus, isArray: false, isRequired: false },
	            { property: 'statusInfo', Class: accountstatusinfo.AccountStatusInfo, isArray: false, isRequired: false }
	        ];
	    };
	    AccountInfo.prototype.getClassName = function () {
	        return 'AccountInfo';
	    };
	    return AccountInfo;
	}(model.Model));
	exports.AccountInfo = AccountInfo;
	(function (AccountInfoSetupWizardState) {
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["NotStarted"] = 'NotStarted'] = "NotStarted";
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["Incomplete"] = 'Incomplete'] = "Incomplete";
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["Completed"] = 'Completed'] = "Completed";
	})(exports.AccountInfoSetupWizardState || (exports.AccountInfoSetupWizardState = {}));
	var AccountInfoSetupWizardState = exports.AccountInfoSetupWizardState;
	(function (AccountInfoStatus) {
	    AccountInfoStatus[AccountInfoStatus["Confirmed"] = 'Confirmed'] = "Confirmed";
	    AccountInfoStatus[AccountInfoStatus["Disabled"] = 'Disabled'] = "Disabled";
	})(exports.AccountInfoStatus || (exports.AccountInfoStatus = {}));
	var AccountInfoStatus = exports.AccountInfoStatus;
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var Model = (function () {
	    function Model(sdk, data) {
	        var _this = this;
	        this._sdk = sdk;
	        data = data || {};
	        this.getPropertyMappings().forEach(function (mapping) {
	            var Class = mapping.Class, prop = mapping.property;
	            if (!data.hasOwnProperty(prop)) {
	                if (mapping.isRequired)
	                    console.warn('Required property "' + prop + '" not defined');
	                return;
	            }
	            var processProperty = function (dataPart) {
	                if (!Class || typeof Class !== 'function') {
	                    return dataPart;
	                }
	                else {
	                    return new Class(_this._sdk, dataPart);
	                }
	            };
	            if (mapping.isArray) {
	                _this[prop] = data[prop].map(processProperty);
	            }
	            else {
	                _this[prop] = processProperty(data[prop]);
	            }
	        });
	    }
	    Model.prototype.getPropertyMappings = function () {
	        return [];
	    };
	    Model.prototype.getClassName = function () {
	        return 'Model';
	    };
	    Model.prototype.getId = function () {
	        return this['id'];
	    };
	    return Model;
	}());
	exports.Model = Model;
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var contactinfo = __webpack_require__(7);
	var departmentinfo = __webpack_require__(9);
	var extensionpermissions = __webpack_require__(10);
	var profileimageinfo = __webpack_require__(12);
	var referenceinfo = __webpack_require__(13);
	var regionalsettings = __webpack_require__(14);
	var extensionservicefeatureinfo = __webpack_require__(20);
	var extensionstatusinfo = __webpack_require__(21);
	var ExtensionInfo = (function (_super) {
	    __extends(ExtensionInfo, _super);
	    function ExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'contact', Class: contactinfo.ContactInfo, isArray: false, isRequired: false },
	            { property: 'departments', Class: departmentinfo.DepartmentInfo, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'permissions', Class: extensionpermissions.ExtensionPermissions, isArray: false, isRequired: false },
	            { property: 'profileImage', Class: profileimageinfo.ProfileImageInfo, isArray: false, isRequired: true },
	            { property: 'references', Class: referenceinfo.ReferenceInfo, isArray: true, isRequired: false },
	            { property: 'regionalSettings', Class: regionalsettings.RegionalSettings, isArray: false, isRequired: false },
	            { property: 'serviceFeatures', Class: extensionservicefeatureinfo.ExtensionServiceFeatureInfo, isArray: true, isRequired: false },
	            { property: 'setupWizardState', Class: ExtensionInfoSetupWizardState, isArray: false, isRequired: false },
	            { property: 'status', Class: ExtensionInfoStatus, isArray: false, isRequired: true },
	            { property: 'statusInfo', Class: extensionstatusinfo.ExtensionStatusInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionInfoType, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionInfo.prototype.getClassName = function () {
	        return 'ExtensionInfo';
	    };
	    return ExtensionInfo;
	}(model.Model));
	exports.ExtensionInfo = ExtensionInfo;
	(function (ExtensionInfoSetupWizardState) {
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["NotStarted"] = 'NotStarted'] = "NotStarted";
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["Incomplete"] = 'Incomplete'] = "Incomplete";
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["Completed"] = 'Completed'] = "Completed";
	})(exports.ExtensionInfoSetupWizardState || (exports.ExtensionInfoSetupWizardState = {}));
	var ExtensionInfoSetupWizardState = exports.ExtensionInfoSetupWizardState;
	(function (ExtensionInfoStatus) {
	    ExtensionInfoStatus[ExtensionInfoStatus["Enabled"] = 'Enabled'] = "Enabled";
	    ExtensionInfoStatus[ExtensionInfoStatus["Disabled"] = 'Disabled'] = "Disabled";
	    ExtensionInfoStatus[ExtensionInfoStatus["NotActivated"] = 'NotActivated'] = "NotActivated";
	    ExtensionInfoStatus[ExtensionInfoStatus["Unassigned"] = 'Unassigned'] = "Unassigned";
	})(exports.ExtensionInfoStatus || (exports.ExtensionInfoStatus = {}));
	var ExtensionInfoStatus = exports.ExtensionInfoStatus;
	(function (ExtensionInfoType) {
	    ExtensionInfoType[ExtensionInfoType["User"] = 'User'] = "User";
	    ExtensionInfoType[ExtensionInfoType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    ExtensionInfoType[ExtensionInfoType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    ExtensionInfoType[ExtensionInfoType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    ExtensionInfoType[ExtensionInfoType["Department"] = 'Department'] = "Department";
	    ExtensionInfoType[ExtensionInfoType["Announcement"] = 'Announcement'] = "Announcement";
	    ExtensionInfoType[ExtensionInfoType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionInfoType[ExtensionInfoType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    ExtensionInfoType[ExtensionInfoType["PagingOnlyGroup"] = 'PagingOnlyGroup'] = "PagingOnlyGroup";
	    ExtensionInfoType[ExtensionInfoType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    ExtensionInfoType[ExtensionInfoType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    ExtensionInfoType[ExtensionInfoType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.ExtensionInfoType || (exports.ExtensionInfoType = {}));
	var ExtensionInfoType = exports.ExtensionInfoType;
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var contactaddressinfo = __webpack_require__(8);
	var ContactInfo = (function (_super) {
	    __extends(ContactInfo, _super);
	    function ContactInfo() {
	        _super.apply(this, arguments);
	    }
	    ContactInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'firstName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'company', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'email', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessPhone', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessAddress', Class: contactaddressinfo.ContactAddressInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ContactInfo.prototype.getClassName = function () {
	        return 'ContactInfo';
	    };
	    return ContactInfo;
	}(model.Model));
	exports.ContactInfo = ContactInfo;
	
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ContactAddressInfo = (function (_super) {
	    __extends(ContactAddressInfo, _super);
	    function ContactAddressInfo() {
	        _super.apply(this, arguments);
	    }
	    ContactAddressInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'country', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'street', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'zip', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ContactAddressInfo.prototype.getClassName = function () {
	        return 'ContactAddressInfo';
	    };
	    return ContactAddressInfo;
	}(model.Model));
	exports.ContactAddressInfo = ContactAddressInfo;
	
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DepartmentInfo = (function (_super) {
	    __extends(DepartmentInfo, _super);
	    function DepartmentInfo() {
	        _super.apply(this, arguments);
	    }
	    DepartmentInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DepartmentInfo.prototype.getClassName = function () {
	        return 'DepartmentInfo';
	    };
	    return DepartmentInfo;
	}(model.Model));
	exports.DepartmentInfo = DepartmentInfo;
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var permissioninfo = __webpack_require__(11);
	var ExtensionPermissions = (function (_super) {
	    __extends(ExtensionPermissions, _super);
	    function ExtensionPermissions() {
	        _super.apply(this, arguments);
	    }
	    ExtensionPermissions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'admin', Class: permissioninfo.PermissionInfo, isArray: false, isRequired: false },
	            { property: 'internationalCalling', Class: permissioninfo.PermissionInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionPermissions.prototype.getClassName = function () {
	        return 'ExtensionPermissions';
	    };
	    return ExtensionPermissions;
	}(model.Model));
	exports.ExtensionPermissions = ExtensionPermissions;
	
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PermissionInfo = (function (_super) {
	    __extends(PermissionInfo, _super);
	    function PermissionInfo() {
	        _super.apply(this, arguments);
	    }
	    PermissionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'enabled', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    PermissionInfo.prototype.getClassName = function () {
	        return 'PermissionInfo';
	    };
	    return PermissionInfo;
	}(model.Model));
	exports.PermissionInfo = PermissionInfo;
	
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ProfileImageInfo = (function (_super) {
	    __extends(ProfileImageInfo, _super);
	    function ProfileImageInfo() {
	        _super.apply(this, arguments);
	    }
	    ProfileImageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'etag', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastModified', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'scales', Class: null /* string[] */, isArray: true, isRequired: false }
	        ];
	    };
	    ProfileImageInfo.prototype.getClassName = function () {
	        return 'ProfileImageInfo';
	    };
	    return ProfileImageInfo;
	}(model.Model));
	exports.ProfileImageInfo = ProfileImageInfo;
	
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ReferenceInfo = (function (_super) {
	    __extends(ReferenceInfo, _super);
	    function ReferenceInfo() {
	        _super.apply(this, arguments);
	    }
	    ReferenceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'ref', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: ReferenceInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    ReferenceInfo.prototype.getClassName = function () {
	        return 'ReferenceInfo';
	    };
	    return ReferenceInfo;
	}(model.Model));
	exports.ReferenceInfo = ReferenceInfo;
	(function (ReferenceInfoType) {
	    ReferenceInfoType[ReferenceInfoType["PartnerId"] = 'PartnerId'] = "PartnerId";
	    ReferenceInfoType[ReferenceInfoType["CustomerDirectoryId"] = 'CustomerDirectoryId'] = "CustomerDirectoryId";
	})(exports.ReferenceInfoType || (exports.ReferenceInfoType = {}));
	var ReferenceInfoType = exports.ReferenceInfoType;
	
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var timezoneinfo = __webpack_require__(16);
	var languageinfo = __webpack_require__(17);
	var greetinglanguageinfo = __webpack_require__(18);
	var formattinglocaleinfo = __webpack_require__(19);
	var RegionalSettings = (function (_super) {
	    __extends(RegionalSettings, _super);
	    function RegionalSettings() {
	        _super.apply(this, arguments);
	    }
	    RegionalSettings.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'homeCountry', Class: countryinfo.CountryInfo, isArray: false, isRequired: false },
	            { property: 'timezone', Class: timezoneinfo.TimezoneInfo, isArray: false, isRequired: false },
	            { property: 'language', Class: languageinfo.LanguageInfo, isArray: false, isRequired: false },
	            { property: 'greetingLanguage', Class: greetinglanguageinfo.GreetingLanguageInfo, isArray: false, isRequired: false },
	            { property: 'formattingLocale', Class: formattinglocaleinfo.FormattingLocaleInfo, isArray: false, isRequired: false }
	        ];
	    };
	    RegionalSettings.prototype.getClassName = function () {
	        return 'RegionalSettings';
	    };
	    return RegionalSettings;
	}(model.Model));
	exports.RegionalSettings = RegionalSettings;
	
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CountryInfo = (function (_super) {
	    __extends(CountryInfo, _super);
	    function CountryInfo() {
	        _super.apply(this, arguments);
	    }
	    CountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    CountryInfo.prototype.getClassName = function () {
	        return 'CountryInfo';
	    };
	    return CountryInfo;
	}(model.Model));
	exports.CountryInfo = CountryInfo;
	
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var TimezoneInfo = (function (_super) {
	    __extends(TimezoneInfo, _super);
	    function TimezoneInfo() {
	        _super.apply(this, arguments);
	    }
	    TimezoneInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'description', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    TimezoneInfo.prototype.getClassName = function () {
	        return 'TimezoneInfo';
	    };
	    return TimezoneInfo;
	}(model.Model));
	exports.TimezoneInfo = TimezoneInfo;
	
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var LanguageInfo = (function (_super) {
	    __extends(LanguageInfo, _super);
	    function LanguageInfo() {
	        _super.apply(this, arguments);
	    }
	    LanguageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'greeting', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'formattingLocale', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'ui', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    LanguageInfo.prototype.getClassName = function () {
	        return 'LanguageInfo';
	    };
	    return LanguageInfo;
	}(model.Model));
	exports.LanguageInfo = LanguageInfo;
	
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var GreetingLanguageInfo = (function (_super) {
	    __extends(GreetingLanguageInfo, _super);
	    function GreetingLanguageInfo() {
	        _super.apply(this, arguments);
	    }
	    GreetingLanguageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    GreetingLanguageInfo.prototype.getClassName = function () {
	        return 'GreetingLanguageInfo';
	    };
	    return GreetingLanguageInfo;
	}(model.Model));
	exports.GreetingLanguageInfo = GreetingLanguageInfo;
	
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var FormattingLocaleInfo = (function (_super) {
	    __extends(FormattingLocaleInfo, _super);
	    function FormattingLocaleInfo() {
	        _super.apply(this, arguments);
	    }
	    FormattingLocaleInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    FormattingLocaleInfo.prototype.getClassName = function () {
	        return 'FormattingLocaleInfo';
	    };
	    return FormattingLocaleInfo;
	}(model.Model));
	exports.FormattingLocaleInfo = FormattingLocaleInfo;
	
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionServiceFeatureInfo = (function (_super) {
	    __extends(ExtensionServiceFeatureInfo, _super);
	    function ExtensionServiceFeatureInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionServiceFeatureInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'enabled', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'featureName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionServiceFeatureInfo.prototype.getClassName = function () {
	        return 'ExtensionServiceFeatureInfo';
	    };
	    return ExtensionServiceFeatureInfo;
	}(model.Model));
	exports.ExtensionServiceFeatureInfo = ExtensionServiceFeatureInfo;
	
	
	/***/ },
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionStatusInfo = (function (_super) {
	    __extends(ExtensionStatusInfo, _super);
	    function ExtensionStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'comment', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: ExtensionStatusInfoReason, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionStatusInfo.prototype.getClassName = function () {
	        return 'ExtensionStatusInfo';
	    };
	    return ExtensionStatusInfo;
	}(model.Model));
	exports.ExtensionStatusInfo = ExtensionStatusInfo;
	(function (ExtensionStatusInfoReason) {
	    ExtensionStatusInfoReason[ExtensionStatusInfoReason["Voluntarily"] = 'Voluntarily'] = "Voluntarily";
	    ExtensionStatusInfoReason[ExtensionStatusInfoReason["Involuntarily"] = 'Involuntarily'] = "Involuntarily";
	})(exports.ExtensionStatusInfoReason || (exports.ExtensionStatusInfoReason = {}));
	var ExtensionStatusInfoReason = exports.ExtensionStatusInfoReason;
	
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var billingplaninfo = __webpack_require__(23);
	var brandinfo = __webpack_require__(24);
	var serviceplaninfo = __webpack_require__(25);
	var targetserviceplaninfo = __webpack_require__(26);
	var ServiceInfo = (function (_super) {
	    __extends(ServiceInfo, _super);
	    function ServiceInfo() {
	        _super.apply(this, arguments);
	    }
	    ServiceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'billingPlan', Class: billingplaninfo.BillingPlanInfo, isArray: false, isRequired: false },
	            { property: 'brand', Class: brandinfo.BrandInfo, isArray: false, isRequired: false },
	            { property: 'servicePlan', Class: serviceplaninfo.ServicePlanInfo, isArray: false, isRequired: false },
	            { property: 'targetServicePlan', Class: targetserviceplaninfo.TargetServicePlanInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ServiceInfo.prototype.getClassName = function () {
	        return 'ServiceInfo';
	    };
	    return ServiceInfo;
	}(model.Model));
	exports.ServiceInfo = ServiceInfo;
	
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BillingPlanInfo = (function (_super) {
	    __extends(BillingPlanInfo, _super);
	    function BillingPlanInfo() {
	        _super.apply(this, arguments);
	    }
	    BillingPlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'durationUnit', Class: BillingPlanInfoDurationUnit, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: BillingPlanInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    BillingPlanInfo.prototype.getClassName = function () {
	        return 'BillingPlanInfo';
	    };
	    return BillingPlanInfo;
	}(model.Model));
	exports.BillingPlanInfo = BillingPlanInfo;
	(function (BillingPlanInfoDurationUnit) {
	    BillingPlanInfoDurationUnit[BillingPlanInfoDurationUnit["Month"] = 'Month'] = "Month";
	    BillingPlanInfoDurationUnit[BillingPlanInfoDurationUnit["Day"] = 'Day'] = "Day";
	})(exports.BillingPlanInfoDurationUnit || (exports.BillingPlanInfoDurationUnit = {}));
	var BillingPlanInfoDurationUnit = exports.BillingPlanInfoDurationUnit;
	(function (BillingPlanInfoType) {
	    BillingPlanInfoType[BillingPlanInfoType["Initial"] = 'Initial'] = "Initial";
	    BillingPlanInfoType[BillingPlanInfoType["Regular"] = 'Regular'] = "Regular";
	    BillingPlanInfoType[BillingPlanInfoType["Suspended"] = 'Suspended'] = "Suspended";
	    BillingPlanInfoType[BillingPlanInfoType["Trial"] = 'Trial'] = "Trial";
	    BillingPlanInfoType[BillingPlanInfoType["TrialNoCC"] = 'TrialNoCC'] = "TrialNoCC";
	    BillingPlanInfoType[BillingPlanInfoType["Free"] = 'Free'] = "Free";
	})(exports.BillingPlanInfoType || (exports.BillingPlanInfoType = {}));
	var BillingPlanInfoType = exports.BillingPlanInfoType;
	
	
	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var BrandInfo = (function (_super) {
	    __extends(BrandInfo, _super);
	    function BrandInfo() {
	        _super.apply(this, arguments);
	    }
	    BrandInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'homeCountry', Class: countryinfo.CountryInfo, isArray: false, isRequired: false }
	        ];
	    };
	    BrandInfo.prototype.getClassName = function () {
	        return 'BrandInfo';
	    };
	    return BrandInfo;
	}(model.Model));
	exports.BrandInfo = BrandInfo;
	
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ServicePlanInfo = (function (_super) {
	    __extends(ServicePlanInfo, _super);
	    function ServicePlanInfo() {
	        _super.apply(this, arguments);
	    }
	    ServicePlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'edition', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ServicePlanInfo.prototype.getClassName = function () {
	        return 'ServicePlanInfo';
	    };
	    return ServicePlanInfo;
	}(model.Model));
	exports.ServicePlanInfo = ServicePlanInfo;
	
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var TargetServicePlanInfo = (function (_super) {
	    __extends(TargetServicePlanInfo, _super);
	    function TargetServicePlanInfo() {
	        _super.apply(this, arguments);
	    }
	    TargetServicePlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    TargetServicePlanInfo.prototype.getClassName = function () {
	        return 'TargetServicePlanInfo';
	    };
	    return TargetServicePlanInfo;
	}(model.Model));
	exports.TargetServicePlanInfo = TargetServicePlanInfo;
	
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var AccountStatusInfo = (function (_super) {
	    __extends(AccountStatusInfo, _super);
	    function AccountStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'comment', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: AccountStatusInfoReason, isArray: false, isRequired: false }
	        ];
	    };
	    AccountStatusInfo.prototype.getClassName = function () {
	        return 'AccountStatusInfo';
	    };
	    return AccountStatusInfo;
	}(model.Model));
	exports.AccountStatusInfo = AccountStatusInfo;
	(function (AccountStatusInfoReason) {
	    AccountStatusInfoReason[AccountStatusInfoReason["Voluntarily"] = 'Voluntarily'] = "Voluntarily";
	    AccountStatusInfoReason[AccountStatusInfoReason["Involuntarily"] = 'Involuntarily'] = "Involuntarily";
	})(exports.AccountStatusInfoReason || (exports.AccountStatusInfoReason = {}));
	var AccountStatusInfoReason = exports.AccountStatusInfoReason;
	
	
	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var businessaddressinfo = __webpack_require__(29);
	var AccountBusinessAddress = (function (_super) {
	    __extends(AccountBusinessAddress, _super);
	    function AccountBusinessAddress() {
	        _super.apply(this, arguments);
	    }
	    AccountBusinessAddress.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'company', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'email', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessAddress', Class: businessaddressinfo.BusinessAddressInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountBusinessAddress.prototype.getClassName = function () {
	        return 'AccountBusinessAddress';
	    };
	    return AccountBusinessAddress;
	}(model.Model));
	exports.AccountBusinessAddress = AccountBusinessAddress;
	
	
	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BusinessAddressInfo = (function (_super) {
	    __extends(BusinessAddressInfo, _super);
	    function BusinessAddressInfo() {
	        _super.apply(this, arguments);
	    }
	    BusinessAddressInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'country', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'street', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'zip', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    BusinessAddressInfo.prototype.getClassName = function () {
	        return 'BusinessAddressInfo';
	    };
	    return BusinessAddressInfo;
	}(model.Model));
	exports.BusinessAddressInfo = BusinessAddressInfo;
	
	
	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dialingplancountryinfo = __webpack_require__(31);
	var paginginfo = __webpack_require__(32);
	var navigationinfo = __webpack_require__(33);
	var DialingPlanInfo = (function (_super) {
	    __extends(DialingPlanInfo, _super);
	    function DialingPlanInfo() {
	        _super.apply(this, arguments);
	    }
	    DialingPlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dialingplancountryinfo.DialingPlanCountryInfo, isArray: true, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DialingPlanInfo.prototype.getClassName = function () {
	        return 'DialingPlanInfo';
	    };
	    return DialingPlanInfo;
	}(model.Model));
	exports.DialingPlanInfo = DialingPlanInfo;
	
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DialingPlanCountryInfo = (function (_super) {
	    __extends(DialingPlanCountryInfo, _super);
	    function DialingPlanCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    DialingPlanCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'callingCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DialingPlanCountryInfo.prototype.getClassName = function () {
	        return 'DialingPlanCountryInfo';
	    };
	    return DialingPlanCountryInfo;
	}(model.Model));
	exports.DialingPlanCountryInfo = DialingPlanCountryInfo;
	
	
	/***/ },
	/* 32 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PagingInfo = (function (_super) {
	    __extends(PagingInfo, _super);
	    function PagingInfo() {
	        _super.apply(this, arguments);
	    }
	    PagingInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'page', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'perPage', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'pageStart', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'pageEnd', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'totalPages', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'totalElements', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    PagingInfo.prototype.getClassName = function () {
	        return 'PagingInfo';
	    };
	    return PagingInfo;
	}(model.Model));
	exports.PagingInfo = PagingInfo;
	
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var NavigationInfo = (function (_super) {
	    __extends(NavigationInfo, _super);
	    function NavigationInfo() {
	        _super.apply(this, arguments);
	    }
	    NavigationInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'firstPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'nextPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'previousPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastPage', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    NavigationInfo.prototype.getClassName = function () {
	        return 'NavigationInfo';
	    };
	    return NavigationInfo;
	}(model.Model));
	exports.NavigationInfo = NavigationInfo;
	
	
	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var phonenumbersextensioninfo = __webpack_require__(35);
	var PhoneNumberInfo = (function (_super) {
	    __extends(PhoneNumberInfo, _super);
	    function PhoneNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    PhoneNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'country', Class: countryinfo.CountryInfo, isArray: false, isRequired: false },
	            { property: 'extension', Class: phonenumbersextensioninfo.PhoneNumbersExtensionInfo, isArray: false, isRequired: false },
	            { property: 'features', Class: null /* string[] */, isArray: true, isRequired: false },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'paymentType', Class: PhoneNumberInfoPaymentType, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'status', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: PhoneNumberInfoType, isArray: false, isRequired: false },
	            { property: 'usageType', Class: PhoneNumberInfoUsageType, isArray: false, isRequired: false }
	        ];
	    };
	    PhoneNumberInfo.prototype.getClassName = function () {
	        return 'PhoneNumberInfo';
	    };
	    return PhoneNumberInfo;
	}(model.Model));
	exports.PhoneNumberInfo = PhoneNumberInfo;
	(function (PhoneNumberInfoPaymentType) {
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["External"] = 'External'] = "External";
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["TollFree"] = 'TollFree'] = "TollFree";
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["Local"] = 'Local'] = "Local";
	})(exports.PhoneNumberInfoPaymentType || (exports.PhoneNumberInfoPaymentType = {}));
	var PhoneNumberInfoPaymentType = exports.PhoneNumberInfoPaymentType;
	(function (PhoneNumberInfoType) {
	    PhoneNumberInfoType[PhoneNumberInfoType["VoiceFax"] = 'VoiceFax'] = "VoiceFax";
	    PhoneNumberInfoType[PhoneNumberInfoType["FaxOnly"] = 'FaxOnly'] = "FaxOnly";
	    PhoneNumberInfoType[PhoneNumberInfoType["VoiceOnly"] = 'VoiceOnly'] = "VoiceOnly";
	})(exports.PhoneNumberInfoType || (exports.PhoneNumberInfoType = {}));
	var PhoneNumberInfoType = exports.PhoneNumberInfoType;
	(function (PhoneNumberInfoUsageType) {
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.PhoneNumberInfoUsageType || (exports.PhoneNumberInfoUsageType = {}));
	var PhoneNumberInfoUsageType = exports.PhoneNumberInfoUsageType;
	
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PhoneNumbersExtensionInfo = (function (_super) {
	    __extends(PhoneNumbersExtensionInfo, _super);
	    function PhoneNumbersExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    PhoneNumbersExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    PhoneNumbersExtensionInfo.prototype.getClassName = function () {
	        return 'PhoneNumbersExtensionInfo';
	    };
	    return PhoneNumbersExtensionInfo;
	}(model.Model));
	exports.PhoneNumbersExtensionInfo = PhoneNumbersExtensionInfo;
	
	
	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var phonenumberinfo = __webpack_require__(34);
	var paginginfo = __webpack_require__(32);
	var navigationinfo = __webpack_require__(33);
	var AccountPhoneNumbers = (function (_super) {
	    __extends(AccountPhoneNumbers, _super);
	    function AccountPhoneNumbers() {
	        _super.apply(this, arguments);
	    }
	    AccountPhoneNumbers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: phonenumberinfo.PhoneNumberInfo, isArray: true, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountPhoneNumbers.prototype.getClassName = function () {
	        return 'AccountPhoneNumbers';
	    };
	    return AccountPhoneNumbers;
	}(model.Model));
	exports.AccountPhoneNumbers = AccountPhoneNumbers;
	
	
	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var servicefeatureinfo = __webpack_require__(38);
	var accountlimits = __webpack_require__(39);
	var AccountServiceInfo = (function (_super) {
	    __extends(AccountServiceInfo, _super);
	    function AccountServiceInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountServiceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'servicePlanName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'serviceFeatures', Class: servicefeatureinfo.ServiceFeatureInfo, isArray: true, isRequired: false },
	            { property: 'limits', Class: accountlimits.AccountLimits, isArray: true, isRequired: false }
	        ];
	    };
	    AccountServiceInfo.prototype.getClassName = function () {
	        return 'AccountServiceInfo';
	    };
	    return AccountServiceInfo;
	}(model.Model));
	exports.AccountServiceInfo = AccountServiceInfo;
	
	
	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ServiceFeatureInfo = (function (_super) {
	    __extends(ServiceFeatureInfo, _super);
	    function ServiceFeatureInfo() {
	        _super.apply(this, arguments);
	    }
	    ServiceFeatureInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'featureName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'enabled', Class: ServiceFeatureInfoEnabled, isArray: false, isRequired: false }
	        ];
	    };
	    ServiceFeatureInfo.prototype.getClassName = function () {
	        return 'ServiceFeatureInfo';
	    };
	    return ServiceFeatureInfo;
	}(model.Model));
	exports.ServiceFeatureInfo = ServiceFeatureInfo;
	(function (ServiceFeatureInfoEnabled) {
	    ServiceFeatureInfoEnabled[ServiceFeatureInfoEnabled["True"] = 'True'] = "True";
	    ServiceFeatureInfoEnabled[ServiceFeatureInfoEnabled["False"] = 'False'] = "False";
	})(exports.ServiceFeatureInfoEnabled || (exports.ServiceFeatureInfoEnabled = {}));
	var ServiceFeatureInfoEnabled = exports.ServiceFeatureInfoEnabled;
	
	
	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var AccountLimits = (function (_super) {
	    __extends(AccountLimits, _super);
	    function AccountLimits() {
	        _super.apply(this, arguments);
	    }
	    AccountLimits.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'freeSoftPhoneLinesPerExtension', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'meetingSize', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'maxMonitoredExtensionsPerUser', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    AccountLimits.prototype.getClassName = function () {
	        return 'AccountLimits';
	    };
	    return AccountLimits;
	}(model.Model));
	exports.AccountLimits = AccountLimits;
	
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var accountactivecalls = __webpack_require__(41);
	var accountcalllog = __webpack_require__(47);
	var accountcalllogrecord = __webpack_require__(48);
	var extensionactivecalls = __webpack_require__(49);
	var extensioncalllog = __webpack_require__(50);
	var extensioncalllogrecord = __webpack_require__(51);
	var calllogsync = __webpack_require__(52);
	var callrecording = __webpack_require__(54);
	var CallLog = (function (_super) {
	    __extends(CallLog, _super);
	    function CallLog() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Account Active Calls
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns records of all calls that are in progress, ordered by start time in descending order.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.listAccountActiveCalls = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/active-calls', options, exports.listAccountActiveCallsOptions), accountactivecalls.AccountActiveCalls);
	    };
	    /**
	     * Get Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log records filtered by the specified parameters.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadAccountCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/call-log', options, exports.loadAccountCallLogOptions), accountcalllog.AccountCallLog);
	    };
	    /**
	     * Delete Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditCallLog</td>
	     *             <td>Viewing and updating user call logs</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.deleteAccountCallLog = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/call-log', options, exports.deleteAccountCallLogOptions), null);
	    };
	    /**
	     * Get Account Call Log Record(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns individual call log record(s) by ID(s). Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadAccountCallLogRecord = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/call-log/{callRecordId}', options, exports.loadAccountCallLogRecordOptions), accountcalllogrecord.AccountCallLogRecord);
	    };
	    /**
	     * Get Active Calls
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns records of all extension calls that are in progress, ordered by start time in descending order.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.listExtensionActiveCalls = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/active-calls', options, exports.listExtensionActiveCallsOptions), extensionactivecalls.ExtensionActiveCalls);
	    };
	    /**
	     * Get Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log records filtered by the specified parameters.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log', options, exports.loadExtensionCallLogOptions), extensioncalllog.ExtensionCallLog);
	    };
	    /**
	     * Delete Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditCallLog</td>
	     *             <td>Viewing and updating user call logs</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.deleteExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log', options, exports.deleteExtensionCallLogOptions), null);
	    };
	    /**
	     * Get Extension Call Log Record(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log record(s) by their ID(s). Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadExtensionCallLogRecord = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log/{callRecordId}', options, exports.loadExtensionCallLogRecordOptions), extensioncalllogrecord.ExtensionCallLogRecord);
	    };
	    /**
	     * Call Log Synchronization
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.syncExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log-sync', options, exports.syncExtensionCallLogOptions), calllogsync.CallLogSync);
	    };
	    /**
	     * Get Call Recording
	     *
	     * <p style='font-style:italic;'>Since 1.0.18</p>
	     * <p>Returns call recording metadata.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallRecording</td>
	     *             <td>Downloading call recording content</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadCallRecordingMetadata = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/recording/{recordingId}', options, exports.loadCallRecordingMetadataOptions), callrecording.CallRecording);
	    };
	    /**
	     * Get Call Recording Data
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallRecording</td>
	     *             <td>Downloading call recording content</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadCallRecordingContent = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/recording/{recordingId}/content', options, exports.loadCallRecordingContentOptions), null);
	    };
	    return CallLog;
	}(client.Client));
	exports.CallLog = CallLog;
	/**
	 * Definition of options for listAccountActiveCalls operation
	 */
	exports.listAccountActiveCallsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "direction",
	        "type": "IListAccountActiveCallsDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListAccountActiveCallsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountCallLog operation
	 */
	exports.loadAccountCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ILoadAccountCallLogDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "ILoadAccountCallLogType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "view",
	        "type": "ILoadAccountCallLogView",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Simple",
	            "Detailed"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withRecording",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for deleteAccountCallLog operation
	 */
	exports.deleteAccountCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountCallLogRecord operation
	 */
	exports.loadAccountCallLogRecordOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "callRecordId",
	        "type": "number",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listExtensionActiveCalls operation
	 */
	exports.listExtensionActiveCallsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "direction",
	        "type": "IListExtensionActiveCallsDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListExtensionActiveCallsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionCallLog operation
	 */
	exports.loadExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ILoadExtensionCallLogDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "ILoadExtensionCallLogType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "view",
	        "type": "ILoadExtensionCallLogView",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Simple",
	            "Detailed"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withRecording",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for deleteExtensionCallLog operation
	 */
	exports.deleteExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionCallLogRecord operation
	 */
	exports.loadExtensionCallLogRecordOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "callRecordId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for syncExtensionCallLog operation
	 */
	exports.syncExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "syncType",
	        "type": "ISyncExtensionCallLogSyncType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "FSync",
	            "ISync"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncToken",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "recordCount",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "statusGroup",
	        "type": "ISyncExtensionCallLogStatusGroup",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Missed",
	            "All"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadCallRecordingMetadata operation
	 */
	exports.loadCallRecordingMetadataOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "recordingId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for loadCallRecordingContent operation
	 */
	exports.loadCallRecordingContentOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "recordingId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	(function (IListAccountActiveCallsDirection) {
	    IListAccountActiveCallsDirection[IListAccountActiveCallsDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListAccountActiveCallsDirection[IListAccountActiveCallsDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListAccountActiveCallsDirection || (exports.IListAccountActiveCallsDirection = {}));
	var IListAccountActiveCallsDirection = exports.IListAccountActiveCallsDirection;
	(function (IListAccountActiveCallsType) {
	    IListAccountActiveCallsType[IListAccountActiveCallsType["Voice"] = 'Voice'] = "Voice";
	    IListAccountActiveCallsType[IListAccountActiveCallsType["Fax"] = 'Fax'] = "Fax";
	})(exports.IListAccountActiveCallsType || (exports.IListAccountActiveCallsType = {}));
	var IListAccountActiveCallsType = exports.IListAccountActiveCallsType;
	(function (ILoadAccountCallLogDirection) {
	    ILoadAccountCallLogDirection[ILoadAccountCallLogDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ILoadAccountCallLogDirection[ILoadAccountCallLogDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ILoadAccountCallLogDirection || (exports.ILoadAccountCallLogDirection = {}));
	var ILoadAccountCallLogDirection = exports.ILoadAccountCallLogDirection;
	(function (ILoadAccountCallLogType) {
	    ILoadAccountCallLogType[ILoadAccountCallLogType["Voice"] = 'Voice'] = "Voice";
	    ILoadAccountCallLogType[ILoadAccountCallLogType["Fax"] = 'Fax'] = "Fax";
	})(exports.ILoadAccountCallLogType || (exports.ILoadAccountCallLogType = {}));
	var ILoadAccountCallLogType = exports.ILoadAccountCallLogType;
	(function (ILoadAccountCallLogView) {
	    ILoadAccountCallLogView[ILoadAccountCallLogView["Simple"] = 'Simple'] = "Simple";
	    ILoadAccountCallLogView[ILoadAccountCallLogView["Detailed"] = 'Detailed'] = "Detailed";
	})(exports.ILoadAccountCallLogView || (exports.ILoadAccountCallLogView = {}));
	var ILoadAccountCallLogView = exports.ILoadAccountCallLogView;
	(function (IListExtensionActiveCallsDirection) {
	    IListExtensionActiveCallsDirection[IListExtensionActiveCallsDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListExtensionActiveCallsDirection[IListExtensionActiveCallsDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListExtensionActiveCallsDirection || (exports.IListExtensionActiveCallsDirection = {}));
	var IListExtensionActiveCallsDirection = exports.IListExtensionActiveCallsDirection;
	(function (IListExtensionActiveCallsType) {
	    IListExtensionActiveCallsType[IListExtensionActiveCallsType["Voice"] = 'Voice'] = "Voice";
	    IListExtensionActiveCallsType[IListExtensionActiveCallsType["Fax"] = 'Fax'] = "Fax";
	})(exports.IListExtensionActiveCallsType || (exports.IListExtensionActiveCallsType = {}));
	var IListExtensionActiveCallsType = exports.IListExtensionActiveCallsType;
	(function (ILoadExtensionCallLogDirection) {
	    ILoadExtensionCallLogDirection[ILoadExtensionCallLogDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ILoadExtensionCallLogDirection[ILoadExtensionCallLogDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ILoadExtensionCallLogDirection || (exports.ILoadExtensionCallLogDirection = {}));
	var ILoadExtensionCallLogDirection = exports.ILoadExtensionCallLogDirection;
	(function (ILoadExtensionCallLogType) {
	    ILoadExtensionCallLogType[ILoadExtensionCallLogType["Voice"] = 'Voice'] = "Voice";
	    ILoadExtensionCallLogType[ILoadExtensionCallLogType["Fax"] = 'Fax'] = "Fax";
	})(exports.ILoadExtensionCallLogType || (exports.ILoadExtensionCallLogType = {}));
	var ILoadExtensionCallLogType = exports.ILoadExtensionCallLogType;
	(function (ILoadExtensionCallLogView) {
	    ILoadExtensionCallLogView[ILoadExtensionCallLogView["Simple"] = 'Simple'] = "Simple";
	    ILoadExtensionCallLogView[ILoadExtensionCallLogView["Detailed"] = 'Detailed'] = "Detailed";
	})(exports.ILoadExtensionCallLogView || (exports.ILoadExtensionCallLogView = {}));
	var ILoadExtensionCallLogView = exports.ILoadExtensionCallLogView;
	(function (ISyncExtensionCallLogSyncType) {
	    ISyncExtensionCallLogSyncType[ISyncExtensionCallLogSyncType["FSync"] = 'FSync'] = "FSync";
	    ISyncExtensionCallLogSyncType[ISyncExtensionCallLogSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.ISyncExtensionCallLogSyncType || (exports.ISyncExtensionCallLogSyncType = {}));
	var ISyncExtensionCallLogSyncType = exports.ISyncExtensionCallLogSyncType;
	(function (ISyncExtensionCallLogStatusGroup) {
	    ISyncExtensionCallLogStatusGroup[ISyncExtensionCallLogStatusGroup["Missed"] = 'Missed'] = "Missed";
	    ISyncExtensionCallLogStatusGroup[ISyncExtensionCallLogStatusGroup["All"] = 'All'] = "All";
	})(exports.ISyncExtensionCallLogStatusGroup || (exports.ISyncExtensionCallLogStatusGroup = {}));
	var ISyncExtensionCallLogStatusGroup = exports.ISyncExtensionCallLogStatusGroup;
	
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var AccountActiveCalls = (function (_super) {
	    __extends(AccountActiveCalls, _super);
	    function AccountActiveCalls() {
	        _super.apply(this, arguments);
	    }
	    AccountActiveCalls.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountActiveCalls.prototype.getClassName = function () {
	        return 'AccountActiveCalls';
	    };
	    return AccountActiveCalls;
	}(model.Model));
	exports.AccountActiveCalls = AccountActiveCalls;
	
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var calllogrecordleginfo = __webpack_require__(45);
	var CallLogRecord = (function (_super) {
	    __extends(CallLogRecord, _super);
	    function CallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    CallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: CallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: CallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: CallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: CallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false },
	            { property: 'lastModifiedTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'transport', Class: CallLogRecordTransport, isArray: false, isRequired: false },
	            { property: 'legs', Class: calllogrecordleginfo.CallLogRecordLegInfo, isArray: true, isRequired: true }
	        ];
	    };
	    CallLogRecord.prototype.getClassName = function () {
	        return 'CallLogRecord';
	    };
	    return CallLogRecord;
	}(model.Model));
	exports.CallLogRecord = CallLogRecord;
	(function (CallLogRecordType) {
	    CallLogRecordType[CallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    CallLogRecordType[CallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.CallLogRecordType || (exports.CallLogRecordType = {}));
	var CallLogRecordType = exports.CallLogRecordType;
	(function (CallLogRecordDirection) {
	    CallLogRecordDirection[CallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    CallLogRecordDirection[CallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.CallLogRecordDirection || (exports.CallLogRecordDirection = {}));
	var CallLogRecordDirection = exports.CallLogRecordDirection;
	(function (CallLogRecordAction) {
	    CallLogRecordAction[CallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordAction[CallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    CallLogRecordAction[CallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    CallLogRecordAction[CallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    CallLogRecordAction[CallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    CallLogRecordAction[CallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    CallLogRecordAction[CallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    CallLogRecordAction[CallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    CallLogRecordAction[CallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    CallLogRecordAction[CallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    CallLogRecordAction[CallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    CallLogRecordAction[CallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    CallLogRecordAction[CallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    CallLogRecordAction[CallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    CallLogRecordAction[CallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    CallLogRecordAction[CallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    CallLogRecordAction[CallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    CallLogRecordAction[CallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    CallLogRecordAction[CallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    CallLogRecordAction[CallLogRecordAction["Support"] = 'Support'] = "Support";
	    CallLogRecordAction[CallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.CallLogRecordAction || (exports.CallLogRecordAction = {}));
	var CallLogRecordAction = exports.CallLogRecordAction;
	(function (CallLogRecordResult) {
	    CallLogRecordResult[CallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordResult[CallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    CallLogRecordResult[CallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    CallLogRecordResult[CallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    CallLogRecordResult[CallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    CallLogRecordResult[CallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    CallLogRecordResult[CallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    CallLogRecordResult[CallLogRecordResult["Received"] = 'Received'] = "Received";
	    CallLogRecordResult[CallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    CallLogRecordResult[CallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    CallLogRecordResult[CallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    CallLogRecordResult[CallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    CallLogRecordResult[CallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    CallLogRecordResult[CallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    CallLogRecordResult[CallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    CallLogRecordResult[CallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    CallLogRecordResult[CallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    CallLogRecordResult[CallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    CallLogRecordResult[CallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    CallLogRecordResult[CallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    CallLogRecordResult[CallLogRecordResult["Account"] = 'Account'] = "Account";
	    CallLogRecordResult[CallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    CallLogRecordResult[CallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    CallLogRecordResult[CallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    CallLogRecordResult[CallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    CallLogRecordResult[CallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    CallLogRecordResult[CallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    CallLogRecordResult[CallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    CallLogRecordResult[CallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    CallLogRecordResult[CallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    CallLogRecordResult[CallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    CallLogRecordResult[CallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    CallLogRecordResult[CallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    CallLogRecordResult[CallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    CallLogRecordResult[CallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    CallLogRecordResult[CallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    CallLogRecordResult[CallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.CallLogRecordResult || (exports.CallLogRecordResult = {}));
	var CallLogRecordResult = exports.CallLogRecordResult;
	(function (CallLogRecordTransport) {
	    CallLogRecordTransport[CallLogRecordTransport["PSTN"] = 'PSTN'] = "PSTN";
	    CallLogRecordTransport[CallLogRecordTransport["VoIP"] = 'VoIP'] = "VoIP";
	})(exports.CallLogRecordTransport || (exports.CallLogRecordTransport = {}));
	var CallLogRecordTransport = exports.CallLogRecordTransport;
	
	
	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CallLogCallerInfo = (function (_super) {
	    __extends(CallLogCallerInfo, _super);
	    function CallLogCallerInfo() {
	        _super.apply(this, arguments);
	    }
	    CallLogCallerInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogCallerInfo.prototype.getClassName = function () {
	        return 'CallLogCallerInfo';
	    };
	    return CallLogCallerInfo;
	}(model.Model));
	exports.CallLogCallerInfo = CallLogCallerInfo;
	
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var RecordingInfo = (function (_super) {
	    __extends(RecordingInfo, _super);
	    function RecordingInfo() {
	        _super.apply(this, arguments);
	    }
	    RecordingInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: RecordingInfoType, isArray: false, isRequired: false },
	            { property: 'contentUri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    RecordingInfo.prototype.getClassName = function () {
	        return 'RecordingInfo';
	    };
	    return RecordingInfo;
	}(model.Model));
	exports.RecordingInfo = RecordingInfo;
	(function (RecordingInfoType) {
	    RecordingInfoType[RecordingInfoType["Automatic"] = 'Automatic'] = "Automatic";
	    RecordingInfoType[RecordingInfoType["OnDemand"] = 'OnDemand'] = "OnDemand";
	})(exports.RecordingInfoType || (exports.RecordingInfoType = {}));
	var RecordingInfoType = exports.RecordingInfoType;
	
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfocalllog = __webpack_require__(46);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var CallLogRecordLegInfo = (function (_super) {
	    __extends(CallLogRecordLegInfo, _super);
	    function CallLogRecordLegInfo() {
	        _super.apply(this, arguments);
	    }
	    CallLogRecordLegInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'action', Class: CallLogRecordLegInfoAction, isArray: false, isRequired: false },
	            { property: 'direction', Class: CallLogRecordLegInfoDirection, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'extension', Class: extensioninfocalllog.ExtensionInfoCallLog, isArray: false, isRequired: false },
	            { property: 'legType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: CallLogRecordLegInfoType, isArray: false, isRequired: false },
	            { property: 'result', Class: CallLogRecordLegInfoResult, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'transport', Class: CallLogRecordLegInfoTransport, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogRecordLegInfo.prototype.getClassName = function () {
	        return 'CallLogRecordLegInfo';
	    };
	    return CallLogRecordLegInfo;
	}(model.Model));
	exports.CallLogRecordLegInfo = CallLogRecordLegInfo;
	(function (CallLogRecordLegInfoAction) {
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["FindMe"] = 'FindMe'] = "FindMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingMe"] = 'RingMe'] = "RingMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Transfer"] = 'Transfer'] = "Transfer";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction['411Info'] = '411 Info'] = '411Info';
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Emergency"] = 'Emergency'] = "Emergency";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Support"] = 'Support'] = "Support";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.CallLogRecordLegInfoAction || (exports.CallLogRecordLegInfoAction = {}));
	var CallLogRecordLegInfoAction = exports.CallLogRecordLegInfoAction;
	(function (CallLogRecordLegInfoDirection) {
	    CallLogRecordLegInfoDirection[CallLogRecordLegInfoDirection["Inbound"] = 'Inbound'] = "Inbound";
	    CallLogRecordLegInfoDirection[CallLogRecordLegInfoDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.CallLogRecordLegInfoDirection || (exports.CallLogRecordLegInfoDirection = {}));
	var CallLogRecordLegInfoDirection = exports.CallLogRecordLegInfoDirection;
	(function (CallLogRecordLegInfoType) {
	    CallLogRecordLegInfoType[CallLogRecordLegInfoType["Voice"] = 'Voice'] = "Voice";
	    CallLogRecordLegInfoType[CallLogRecordLegInfoType["Fax"] = 'Fax'] = "Fax";
	})(exports.CallLogRecordLegInfoType || (exports.CallLogRecordLegInfoType = {}));
	var CallLogRecordLegInfoType = exports.CallLogRecordLegInfoType;
	(function (CallLogRecordLegInfoResult) {
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Missed"] = 'Missed'] = "Missed";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Rejected"] = 'Rejected'] = "Rejected";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Reply"] = 'Reply'] = "Reply";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Received"] = 'Received'] = "Received";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Blocked"] = 'Blocked'] = "Blocked";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Busy"] = 'Busy'] = "Busy";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["SendError"] = 'Send Error'] = "SendError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Sent"] = 'Sent'] = "Sent";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Account"] = 'Account'] = "Account";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Suspended"] = 'Suspended'] = "Suspended";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternalError"] = 'Internal Error'] = "InternalError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Stopped"] = 'Stopped'] = "Stopped";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Hangup"] = 'Hang up'] = "Hangup";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Declined"] = 'Declined'] = "Declined";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.CallLogRecordLegInfoResult || (exports.CallLogRecordLegInfoResult = {}));
	var CallLogRecordLegInfoResult = exports.CallLogRecordLegInfoResult;
	(function (CallLogRecordLegInfoTransport) {
	    CallLogRecordLegInfoTransport[CallLogRecordLegInfoTransport["PSTN"] = 'PSTN'] = "PSTN";
	    CallLogRecordLegInfoTransport[CallLogRecordLegInfoTransport["VoIP"] = 'VoIP'] = "VoIP";
	})(exports.CallLogRecordLegInfoTransport || (exports.CallLogRecordLegInfoTransport = {}));
	var CallLogRecordLegInfoTransport = exports.CallLogRecordLegInfoTransport;
	
	
	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionInfoCallLog = (function (_super) {
	    __extends(ExtensionInfoCallLog, _super);
	    function ExtensionInfoCallLog() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfoCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionInfoCallLog.prototype.getClassName = function () {
	        return 'ExtensionInfoCallLog';
	    };
	    return ExtensionInfoCallLog;
	}(model.Model));
	exports.ExtensionInfoCallLog = ExtensionInfoCallLog;
	
	
	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var AccountCallLog = (function (_super) {
	    __extends(AccountCallLog, _super);
	    function AccountCallLog() {
	        _super.apply(this, arguments);
	    }
	    AccountCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountCallLog.prototype.getClassName = function () {
	        return 'AccountCallLog';
	    };
	    return AccountCallLog;
	}(model.Model));
	exports.AccountCallLog = AccountCallLog;
	
	
	/***/ },
	/* 48 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var AccountCallLogRecord = (function (_super) {
	    __extends(AccountCallLogRecord, _super);
	    function AccountCallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    AccountCallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: AccountCallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: AccountCallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: AccountCallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: AccountCallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    AccountCallLogRecord.prototype.getClassName = function () {
	        return 'AccountCallLogRecord';
	    };
	    return AccountCallLogRecord;
	}(model.Model));
	exports.AccountCallLogRecord = AccountCallLogRecord;
	(function (AccountCallLogRecordType) {
	    AccountCallLogRecordType[AccountCallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    AccountCallLogRecordType[AccountCallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.AccountCallLogRecordType || (exports.AccountCallLogRecordType = {}));
	var AccountCallLogRecordType = exports.AccountCallLogRecordType;
	(function (AccountCallLogRecordDirection) {
	    AccountCallLogRecordDirection[AccountCallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    AccountCallLogRecordDirection[AccountCallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.AccountCallLogRecordDirection || (exports.AccountCallLogRecordDirection = {}));
	var AccountCallLogRecordDirection = exports.AccountCallLogRecordDirection;
	(function (AccountCallLogRecordAction) {
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    AccountCallLogRecordAction[AccountCallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    AccountCallLogRecordAction[AccountCallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Support"] = 'Support'] = "Support";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.AccountCallLogRecordAction || (exports.AccountCallLogRecordAction = {}));
	var AccountCallLogRecordAction = exports.AccountCallLogRecordAction;
	(function (AccountCallLogRecordResult) {
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Received"] = 'Received'] = "Received";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Account"] = 'Account'] = "Account";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.AccountCallLogRecordResult || (exports.AccountCallLogRecordResult = {}));
	var AccountCallLogRecordResult = exports.AccountCallLogRecordResult;
	
	
	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionActiveCalls = (function (_super) {
	    __extends(ExtensionActiveCalls, _super);
	    function ExtensionActiveCalls() {
	        _super.apply(this, arguments);
	    }
	    ExtensionActiveCalls.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionActiveCalls.prototype.getClassName = function () {
	        return 'ExtensionActiveCalls';
	    };
	    return ExtensionActiveCalls;
	}(model.Model));
	exports.ExtensionActiveCalls = ExtensionActiveCalls;
	
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionCallLog = (function (_super) {
	    __extends(ExtensionCallLog, _super);
	    function ExtensionCallLog() {
	        _super.apply(this, arguments);
	    }
	    ExtensionCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionCallLog.prototype.getClassName = function () {
	        return 'ExtensionCallLog';
	    };
	    return ExtensionCallLog;
	}(model.Model));
	exports.ExtensionCallLog = ExtensionCallLog;
	
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var ExtensionCallLogRecord = (function (_super) {
	    __extends(ExtensionCallLogRecord, _super);
	    function ExtensionCallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    ExtensionCallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionCallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: ExtensionCallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: ExtensionCallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: ExtensionCallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionCallLogRecord.prototype.getClassName = function () {
	        return 'ExtensionCallLogRecord';
	    };
	    return ExtensionCallLogRecord;
	}(model.Model));
	exports.ExtensionCallLogRecord = ExtensionCallLogRecord;
	(function (ExtensionCallLogRecordType) {
	    ExtensionCallLogRecordType[ExtensionCallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    ExtensionCallLogRecordType[ExtensionCallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.ExtensionCallLogRecordType || (exports.ExtensionCallLogRecordType = {}));
	var ExtensionCallLogRecordType = exports.ExtensionCallLogRecordType;
	(function (ExtensionCallLogRecordDirection) {
	    ExtensionCallLogRecordDirection[ExtensionCallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ExtensionCallLogRecordDirection[ExtensionCallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ExtensionCallLogRecordDirection || (exports.ExtensionCallLogRecordDirection = {}));
	var ExtensionCallLogRecordDirection = exports.ExtensionCallLogRecordDirection;
	(function (ExtensionCallLogRecordAction) {
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Support"] = 'Support'] = "Support";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.ExtensionCallLogRecordAction || (exports.ExtensionCallLogRecordAction = {}));
	var ExtensionCallLogRecordAction = exports.ExtensionCallLogRecordAction;
	(function (ExtensionCallLogRecordResult) {
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Received"] = 'Received'] = "Received";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Account"] = 'Account'] = "Account";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.ExtensionCallLogRecordResult || (exports.ExtensionCallLogRecordResult = {}));
	var ExtensionCallLogRecordResult = exports.ExtensionCallLogRecordResult;
	
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var syncinfocalllog = __webpack_require__(53);
	var CallLogSync = (function (_super) {
	    __extends(CallLogSync, _super);
	    function CallLogSync() {
	        _super.apply(this, arguments);
	    }
	    CallLogSync.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'syncInfo', Class: syncinfocalllog.SyncInfoCallLog, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogSync.prototype.getClassName = function () {
	        return 'CallLogSync';
	    };
	    return CallLogSync;
	}(model.Model));
	exports.CallLogSync = CallLogSync;
	
	
	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var SyncInfoCallLog = (function (_super) {
	    __extends(SyncInfoCallLog, _super);
	    function SyncInfoCallLog() {
	        _super.apply(this, arguments);
	    }
	    SyncInfoCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'syncType', Class: SyncInfoCallLogSyncType, isArray: false, isRequired: false },
	            { property: 'syncToken', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'syncTime', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    SyncInfoCallLog.prototype.getClassName = function () {
	        return 'SyncInfoCallLog';
	    };
	    return SyncInfoCallLog;
	}(model.Model));
	exports.SyncInfoCallLog = SyncInfoCallLog;
	(function (SyncInfoCallLogSyncType) {
	    SyncInfoCallLogSyncType[SyncInfoCallLogSyncType["FSync"] = 'FSync'] = "FSync";
	    SyncInfoCallLogSyncType[SyncInfoCallLogSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.SyncInfoCallLogSyncType || (exports.SyncInfoCallLogSyncType = {}));
	var SyncInfoCallLogSyncType = exports.SyncInfoCallLogSyncType;
	
	
	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CallRecording = (function (_super) {
	    __extends(CallRecording, _super);
	    function CallRecording() {
	        _super.apply(this, arguments);
	    }
	    CallRecording.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentUri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    CallRecording.prototype.getClassName = function () {
	        return 'CallRecording';
	    };
	    return CallRecording;
	}(model.Model));
	exports.CallRecording = CallRecording;
	
	
	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var countrylist = __webpack_require__(56);
	var dictionarycountryinfo = __webpack_require__(57);
	var languagelist = __webpack_require__(58);
	var languageinfo = __webpack_require__(17);
	var dictionarylocationlist = __webpack_require__(59);
	var dictionarysecretquestionlist = __webpack_require__(61);
	var secretquestioninfo = __webpack_require__(62);
	var dictionaryshippingoptions = __webpack_require__(63);
	var dictionarystatelist = __webpack_require__(65);
	var dictionarystateinfo = __webpack_require__(66);
	var dictionarytimezonelist = __webpack_require__(68);
	var dictionarytimezoneinfo = __webpack_require__(69);
	var Dictionary = (function (_super) {
	    __extends(Dictionary, _super);
	    function Dictionary() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Country List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the countries available for calling.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listCountries = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/country', options, exports.listCountriesOptions), countrylist.CountryList);
	    };
	    /**
	     * Get Country
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on the required country.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadCountry = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/country/{countryId}', options, exports.loadCountryOptions), dictionarycountryinfo.DictionaryCountryInfo);
	    };
	    /**
	     * Get Language List
	     *
	     * <p style='font-style:italic;'>Since 1.0.14 (Release 6.6)</p>
	     * <p>Returns the information about supported languages.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listLanguages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/language', options, exports.listLanguagesOptions), languagelist.LanguageList);
	    };
	    /**
	     * Get Language
	     *
	     * <p style='font-style:italic;'>Since 1.0.14 (Release 6.6)</p>
	     * <p>Returns language by its respective ID.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadLanguage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/language/{languageId}', options, exports.loadLanguageOptions), languageinfo.LanguageInfo);
	    };
	    /**
	     * Get Location List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the available locations for the certain state.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listLocations = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/location', options, exports.listLocationsOptions), dictionarylocationlist.DictionaryLocationList);
	    };
	    /**
	     * Get Secret Question List
	     *
	     * <p style='font-style:italic;'>Since 1.0.20 (Release 7.4)</p>
	     * <p>Returns the list of secret questions for a specific language.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listSecretQuestions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/secret-question', options, exports.listSecretQuestionsOptions), dictionarysecretquestionlist.DictionarySecretQuestionList);
	    };
	    /**
	     * Get Secret Question
	     *
	     * <p style='font-style:italic;'>Since 1.0.20 (Release 7.4)</p>
	     * <p>Returns a particular secret question in specific language by question ID.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadSecretQuestion = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/secret-question/questionId', options, exports.loadSecretQuestionOptions), secretquestioninfo.SecretQuestionInfo);
	    };
	    /**
	     * Get Shipping Options
	     *
	     * <p style='font-style:italic;'>Since 1.0.16 (Release 7.1)</p>
	     * <p>Returns the list of device shipping options with their prices, according to brand, tier, number of ordered devices.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listShippingOptions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/shipping-options', options, exports.listShippingOptionsOptions), dictionaryshippingoptions.DictionaryShippingOptions);
	    };
	    /**
	     * Get State List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the states for a certain country.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadlistStates = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/state', options, exports.loadlistStatesOptions), dictionarystatelist.DictionaryStateList);
	    };
	    /**
	     * Get State
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on the required state.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadState = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/state/{stateId}', options, exports.loadStateOptions), dictionarystateinfo.DictionaryStateInfo);
	    };
	    /**
	     * Get Timezone List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all available timezones.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listTimezones = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/timezone', options, exports.listTimezonesOptions), dictionarytimezonelist.DictionaryTimezoneList);
	    };
	    /**
	     * Get Timezone
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on a certain timezone.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadTimezone = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/timezone/{timezoneId}', options, exports.loadTimezoneOptions), dictionarytimezoneinfo.DictionaryTimezoneInfo);
	    };
	    return Dictionary;
	}(client.Client));
	exports.Dictionary = Dictionary;
	/**
	 * Definition of options for listCountries operation
	 */
	exports.listCountriesOptions = [
	    {
	        "name": "loginAllowed",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "numberSelling",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadCountry operation
	 */
	exports.loadCountryOptions = [
	    {
	        "name": "countryId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listLanguages operation
	 */
	exports.listLanguagesOptions = [];
	/**
	 * Definition of options for loadLanguage operation
	 */
	exports.loadLanguageOptions = [
	    {
	        "name": "languageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listLocations operation
	 */
	exports.listLocationsOptions = [
	    {
	        "name": "orderBy",
	        "type": "IListLocationsOrderBy",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Npa",
	            "City"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "stateId",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withNxx",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for listSecretQuestions operation
	 */
	exports.listSecretQuestionsOptions = [];
	/**
	 * Definition of options for loadSecretQuestion operation
	 */
	exports.loadSecretQuestionOptions = [
	    {
	        "name": "questionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listShippingOptions operation
	 */
	exports.listShippingOptionsOptions = [];
	/**
	 * Definition of options for loadlistStates operation
	 */
	exports.loadlistStatesOptions = [
	    {
	        "name": "countryId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withPhoneNumbers",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadState operation
	 */
	exports.loadStateOptions = [
	    {
	        "name": "stateId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listTimezones operation
	 */
	exports.listTimezonesOptions = [
	    {
	        "name": "page",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadTimezone operation
	 */
	exports.loadTimezoneOptions = [
	    {
	        "name": "timezoneId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListLocationsOrderBy) {
	    IListLocationsOrderBy[IListLocationsOrderBy["Npa"] = 'Npa'] = "Npa";
	    IListLocationsOrderBy[IListLocationsOrderBy["City"] = 'City'] = "City";
	})(exports.IListLocationsOrderBy || (exports.IListLocationsOrderBy = {}));
	var IListLocationsOrderBy = exports.IListLocationsOrderBy;
	
	
	/***/ },
	/* 56 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarycountryinfo = __webpack_require__(57);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var CountryList = (function (_super) {
	    __extends(CountryList, _super);
	    function CountryList() {
	        _super.apply(this, arguments);
	    }
	    CountryList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarycountryinfo.DictionaryCountryInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    CountryList.prototype.getClassName = function () {
	        return 'CountryList';
	    };
	    return CountryList;
	}(model.Model));
	exports.CountryList = CountryList;
	
	
	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DictionaryCountryInfo = (function (_super) {
	    __extends(DictionaryCountryInfo, _super);
	    function DictionaryCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'callingCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'emergencyCalling', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'numberSelling', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'loginAllowed', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryCountryInfo.prototype.getClassName = function () {
	        return 'DictionaryCountryInfo';
	    };
	    return DictionaryCountryInfo;
	}(model.Model));
	exports.DictionaryCountryInfo = DictionaryCountryInfo;
	
	
	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var languageinfo = __webpack_require__(17);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var LanguageList = (function (_super) {
	    __extends(LanguageList, _super);
	    function LanguageList() {
	        _super.apply(this, arguments);
	    }
	    LanguageList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'records', Class: languageinfo.LanguageInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    LanguageList.prototype.getClassName = function () {
	        return 'LanguageList';
	    };
	    return LanguageList;
	}(model.Model));
	exports.LanguageList = LanguageList;
	
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var locationinfo = __webpack_require__(60);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryLocationList = (function (_super) {
	    __extends(DictionaryLocationList, _super);
	    function DictionaryLocationList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryLocationList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: locationinfo.LocationInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryLocationList.prototype.getClassName = function () {
	        return 'DictionaryLocationList';
	    };
	    return DictionaryLocationList;
	}(model.Model));
	exports.DictionaryLocationList = DictionaryLocationList;
	
	
	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var LocationInfo = (function (_super) {
	    __extends(LocationInfo, _super);
	    function LocationInfo() {
	        _super.apply(this, arguments);
	    }
	    LocationInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'areaCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'npa', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'nxx', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    LocationInfo.prototype.getClassName = function () {
	        return 'LocationInfo';
	    };
	    return LocationInfo;
	}(model.Model));
	exports.LocationInfo = LocationInfo;
	
	
	/***/ },
	/* 61 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var secretquestioninfo = __webpack_require__(62);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionarySecretQuestionList = (function (_super) {
	    __extends(DictionarySecretQuestionList, _super);
	    function DictionarySecretQuestionList() {
	        _super.apply(this, arguments);
	    }
	    DictionarySecretQuestionList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'records', Class: secretquestioninfo.SecretQuestionInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: false },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    DictionarySecretQuestionList.prototype.getClassName = function () {
	        return 'DictionarySecretQuestionList';
	    };
	    return DictionarySecretQuestionList;
	}(model.Model));
	exports.DictionarySecretQuestionList = DictionarySecretQuestionList;
	
	
	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var SecretQuestionInfo = (function (_super) {
	    __extends(SecretQuestionInfo, _super);
	    function SecretQuestionInfo() {
	        _super.apply(this, arguments);
	    }
	    SecretQuestionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'questionType', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'languageId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'questionText', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'showInSignUp', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    SecretQuestionInfo.prototype.getClassName = function () {
	        return 'SecretQuestionInfo';
	    };
	    return SecretQuestionInfo;
	}(model.Model));
	exports.SecretQuestionInfo = SecretQuestionInfo;
	
	
	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var shippingmethodinfo = __webpack_require__(64);
	var DictionaryShippingOptions = (function (_super) {
	    __extends(DictionaryShippingOptions, _super);
	    function DictionaryShippingOptions() {
	        _super.apply(this, arguments);
	    }
	    DictionaryShippingOptions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'quantity', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'price', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'method', Class: shippingmethodinfo.ShippingMethodInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryShippingOptions.prototype.getClassName = function () {
	        return 'DictionaryShippingOptions';
	    };
	    return DictionaryShippingOptions;
	}(model.Model));
	exports.DictionaryShippingOptions = DictionaryShippingOptions;
	
	
	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ShippingMethodInfo = (function (_super) {
	    __extends(ShippingMethodInfo, _super);
	    function ShippingMethodInfo() {
	        _super.apply(this, arguments);
	    }
	    ShippingMethodInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ShippingMethodInfo.prototype.getClassName = function () {
	        return 'ShippingMethodInfo';
	    };
	    return ShippingMethodInfo;
	}(model.Model));
	exports.ShippingMethodInfo = ShippingMethodInfo;
	
	
	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarystateinfo = __webpack_require__(66);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryStateList = (function (_super) {
	    __extends(DictionaryStateList, _super);
	    function DictionaryStateList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryStateList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarystateinfo.DictionaryStateInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryStateList.prototype.getClassName = function () {
	        return 'DictionaryStateList';
	    };
	    return DictionaryStateList;
	}(model.Model));
	exports.DictionaryStateList = DictionaryStateList;
	
	
	/***/ },
	/* 66 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var statecountryinfo = __webpack_require__(67);
	var DictionaryStateInfo = (function (_super) {
	    __extends(DictionaryStateInfo, _super);
	    function DictionaryStateInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryStateInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'country', Class: statecountryinfo.StateCountryInfo, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryStateInfo.prototype.getClassName = function () {
	        return 'DictionaryStateInfo';
	    };
	    return DictionaryStateInfo;
	}(model.Model));
	exports.DictionaryStateInfo = DictionaryStateInfo;
	
	
	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var StateCountryInfo = (function (_super) {
	    __extends(StateCountryInfo, _super);
	    function StateCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    StateCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    StateCountryInfo.prototype.getClassName = function () {
	        return 'StateCountryInfo';
	    };
	    return StateCountryInfo;
	}(model.Model));
	exports.StateCountryInfo = StateCountryInfo;
	
	
	/***/ },
	/* 68 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarytimezoneinfo = __webpack_require__(69);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryTimezoneList = (function (_super) {
	    __extends(DictionaryTimezoneList, _super);
	    function DictionaryTimezoneList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryTimezoneList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarytimezoneinfo.DictionaryTimezoneInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryTimezoneList.prototype.getClassName = function () {
	        return 'DictionaryTimezoneList';
	    };
	    return DictionaryTimezoneList;
	}(model.Model));
	exports.DictionaryTimezoneList = DictionaryTimezoneList;
	
	
	/***/ },
	/* 69 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DictionaryTimezoneInfo = (function (_super) {
	    __extends(DictionaryTimezoneInfo, _super);
	    function DictionaryTimezoneInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryTimezoneInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'description', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryTimezoneInfo.prototype.getClassName = function () {
	        return 'DictionaryTimezoneInfo';
	    };
	    return DictionaryTimezoneInfo;
	}(model.Model));
	exports.DictionaryTimezoneInfo = DictionaryTimezoneInfo;
	
	
	/***/ },
	/* 70 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var extensionlist = __webpack_require__(71);
	var extensioninfo = __webpack_require__(6);
	var extensionphonenumbers = __webpack_require__(72);
	var extensiongrantlist = __webpack_require__(73);
	var departmentmembers = __webpack_require__(76);
	var Extension = (function (_super) {
	    __extends(Extension, _super);
	    function Extension() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension List
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns the list of extensions created for a particular account. All types of extensions are included in this list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.listExtensions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension', options, exports.listExtensionsOptions), extensionlist.ExtensionList);
	    };
	    /**
	     * Get Extension Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns basic information about a particular extension of an account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.loadExtensionInfo = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}', options, exports.loadExtensionInfoOptions), extensioninfo.ExtensionInfo);
	    };
	    /**
	     * Get Extension Phone Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers that are used by a particular extension, and can be filtered by the phone number type. The returned list contains all numbers which are directly mapped to a given extension plus the features and also company-level numbers
	     *     which may be used when performing different operations on behalf of this extension.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listExtensionPhoneNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/phone-number', options, exports.listExtensionPhoneNumbersOptions), extensionphonenumbers.ExtensionPhoneNumbers);
	    };
	    /**
	     * Get Extension Grant List
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the list of extension grants.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listExtensionGrants = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/grant', options, exports.listExtensionGrantsOptions), extensiongrantlist.ExtensionGrantList);
	    };
	    /**
	     * Get Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.loadExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.loadExtensionProfileImageOptions), null);
	    };
	    /**
	     * Create Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>High</p>
	     */
	    Extension.prototype.createExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.createExtensionProfileImageOptions), null);
	    };
	    /**
	     * Update Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Updates the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>High</p>
	     */
	    Extension.prototype.updateExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.updateExtensionProfileImageOptions), null);
	    };
	    /**
	     * Get Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the scaled profile image of an extension.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.loadExtensionScaledProfileImage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image/{scaleSize}', options, exports.loadExtensionScaledProfileImageOptions), null);
	    };
	    /**
	     * Get Department Member List
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listDepartmentMembers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/department/{departmentId}/members', options, exports.listDepartmentMembersOptions), departmentmembers.DepartmentMembers);
	    };
	    return Extension;
	}(client.Client));
	exports.Extension = Extension;
	/**
	 * Definition of options for listExtensions operation
	 */
	exports.listExtensionsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "status",
	        "type": "IListExtensionsStatus",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Enabled",
	            "Disabled",
	            "NotActivated",
	            "Unassigned"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListExtensionsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "User",
	            "FaxUser",
	            "VirtualUser",
	            "DigitalUser",
	            "Department",
	            "Announcement",
	            "Voicemail",
	            "SharedLinesGroup",
	            "PagingOnlyGroup",
	            "IvrMenu",
	            "ApplicationExtension",
	            "ParkLocation"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionInfo operation
	 */
	exports.loadExtensionInfoOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listExtensionPhoneNumbers operation
	 */
	exports.listExtensionPhoneNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "usageType",
	        "type": "IListExtensionPhoneNumbersUsageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "MainCompanyNumber",
	            "AdditionalCompanyNumber",
	            "CompanyNumber",
	            "DirectNumber",
	            "CompanyFaxNumber",
	            "ForwardedNumber"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for listExtensionGrants operation
	 */
	exports.listExtensionGrantsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionProfileImage operation
	 */
	exports.loadExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for createExtensionProfileImage operation
	 */
	exports.createExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for updateExtensionProfileImage operation
	 */
	exports.updateExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadExtensionScaledProfileImage operation
	 */
	exports.loadExtensionScaledProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "scaleSize",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listDepartmentMembers operation
	 */
	exports.listDepartmentMembersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "departmentId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListExtensionsStatus) {
	    IListExtensionsStatus[IListExtensionsStatus["Enabled"] = 'Enabled'] = "Enabled";
	    IListExtensionsStatus[IListExtensionsStatus["Disabled"] = 'Disabled'] = "Disabled";
	    IListExtensionsStatus[IListExtensionsStatus["NotActivated"] = 'NotActivated'] = "NotActivated";
	    IListExtensionsStatus[IListExtensionsStatus["Unassigned"] = 'Unassigned'] = "Unassigned";
	})(exports.IListExtensionsStatus || (exports.IListExtensionsStatus = {}));
	var IListExtensionsStatus = exports.IListExtensionsStatus;
	(function (IListExtensionsType) {
	    IListExtensionsType[IListExtensionsType["User"] = 'User'] = "User";
	    IListExtensionsType[IListExtensionsType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    IListExtensionsType[IListExtensionsType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    IListExtensionsType[IListExtensionsType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    IListExtensionsType[IListExtensionsType["Department"] = 'Department'] = "Department";
	    IListExtensionsType[IListExtensionsType["Announcement"] = 'Announcement'] = "Announcement";
	    IListExtensionsType[IListExtensionsType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    IListExtensionsType[IListExtensionsType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    IListExtensionsType[IListExtensionsType["PagingOnlyGroup"] = 'PagingOnlyGroup'] = "PagingOnlyGroup";
	    IListExtensionsType[IListExtensionsType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    IListExtensionsType[IListExtensionsType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    IListExtensionsType[IListExtensionsType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.IListExtensionsType || (exports.IListExtensionsType = {}));
	var IListExtensionsType = exports.IListExtensionsType;
	(function (IListExtensionPhoneNumbersUsageType) {
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.IListExtensionPhoneNumbersUsageType || (exports.IListExtensionPhoneNumbersUsageType = {}));
	var IListExtensionPhoneNumbersUsageType = exports.IListExtensionPhoneNumbersUsageType;
	
	
	/***/ },
	/* 71 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionList = (function (_super) {
	    __extends(ExtensionList, _super);
	    function ExtensionList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: extensioninfo.ExtensionInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionList.prototype.getClassName = function () {
	        return 'ExtensionList';
	    };
	    return ExtensionList;
	}(model.Model));
	exports.ExtensionList = ExtensionList;
	
	
	/***/ },
	/* 72 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var phonenumberinfo = __webpack_require__(34);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionPhoneNumbers = (function (_super) {
	    __extends(ExtensionPhoneNumbers, _super);
	    function ExtensionPhoneNumbers() {
	        _super.apply(this, arguments);
	    }
	    ExtensionPhoneNumbers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: phonenumberinfo.PhoneNumberInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionPhoneNumbers.prototype.getClassName = function () {
	        return 'ExtensionPhoneNumbers';
	    };
	    return ExtensionPhoneNumbers;
	}(model.Model));
	exports.ExtensionPhoneNumbers = ExtensionPhoneNumbers;
	
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var grantinfo = __webpack_require__(74);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionGrantList = (function (_super) {
	    __extends(ExtensionGrantList, _super);
	    function ExtensionGrantList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionGrantList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: grantinfo.GrantInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionGrantList.prototype.getClassName = function () {
	        return 'ExtensionGrantList';
	    };
	    return ExtensionGrantList;
	}(model.Model));
	exports.ExtensionGrantList = ExtensionGrantList;
	
	
	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfogrants = __webpack_require__(75);
	var GrantInfo = (function (_super) {
	    __extends(GrantInfo, _super);
	    function GrantInfo() {
	        _super.apply(this, arguments);
	    }
	    GrantInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extension', Class: extensioninfogrants.ExtensionInfoGrants, isArray: false, isRequired: false },
	            { property: 'callPickup', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'callMonitoring', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    GrantInfo.prototype.getClassName = function () {
	        return 'GrantInfo';
	    };
	    return GrantInfo;
	}(model.Model));
	exports.GrantInfo = GrantInfo;
	
	
	/***/ },
	/* 75 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionInfoGrants = (function (_super) {
	    __extends(ExtensionInfoGrants, _super);
	    function ExtensionInfoGrants() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfoGrants.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionInfoGrantsType, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionInfoGrants.prototype.getClassName = function () {
	        return 'ExtensionInfoGrants';
	    };
	    return ExtensionInfoGrants;
	}(model.Model));
	exports.ExtensionInfoGrants = ExtensionInfoGrants;
	(function (ExtensionInfoGrantsType) {
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["User"] = 'User'] = "User";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["FaxUser"] = 'Fax User'] = "FaxUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Department"] = 'Department'] = "Department";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Announcement"] = 'Announcement'] = "Announcement";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["PagingOnly"] = 'PagingOnly'] = "PagingOnly";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["ParkLocation"] = 'Park Location'] = "ParkLocation";
	})(exports.ExtensionInfoGrantsType || (exports.ExtensionInfoGrantsType = {}));
	var ExtensionInfoGrantsType = exports.ExtensionInfoGrantsType;
	
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DepartmentMembers = (function (_super) {
	    __extends(DepartmentMembers, _super);
	    function DepartmentMembers() {
	        _super.apply(this, arguments);
	    }
	    DepartmentMembers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: extensioninfo.ExtensionInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DepartmentMembers.prototype.getClassName = function () {
	        return 'DepartmentMembers';
	    };
	    return DepartmentMembers;
	}(model.Model));
	exports.DepartmentMembers = DepartmentMembers;
	
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var messageinfo = __webpack_require__(78);
	var messagelist = __webpack_require__(81);
	var messagesync = __webpack_require__(82);
	var Messages = (function (_super) {
	    __extends(Messages, _super);
	    function Messages() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Pager Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends a pager message.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>InternalMessages</td>
	     *             <td>Sending and receiving intra-company text messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.sendInternalMessage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/company-pager', options, exports.sendInternalMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Create Fax Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends/resends new fax message. Resend can be done if sending failed.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>Faxes</td>
	     *             <td>Sending and receiving faxes</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Messages.prototype.sendFaxMessage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/fax', options, exports.sendFaxMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Create SMS Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends new SMS message. Sending SMS messages simultaneously to different recipients is limited up to 50 requests per minute; relevant for all client applications.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>SMS</td>
	     *             <td>Sending and receiving SMS (text) messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.sendSMS = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/sms', options, exports.sendSMSOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Get Message List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of messages from an extension mailbox.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.listMessages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store', options, exports.listMessagesOptions), messagelist.MessageList);
	    };
	    /**
	     * Get Message(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns individual message record(s) by the given message ID(s). The length of inbound messages is unlimited. Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.loadMessage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.loadMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Update Message(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Updates message(s) by ID(s). Batch request is supported, see Batch Requests for details. Currently, only the message read status updating is supported.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditMessages</td>
	     *             <td>Viewing and updating user messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.updateMessage = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.updateMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Delete Message(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Deletes message(s) by the given message ID(s). The first call of this method transfers the message to the 'Delete' status. The second call transfers the deleted message to the 'Purged' status. If it is required to make the message 'Purged' immediately
	     *     (from the first call), then set the query parameter purge to 'True'. Batch request is supported.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditMessages</td>
	     *             <td>Viewing and updating user messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.deleteMessage = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.deleteMessageOptions), null);
	    };
	    /**
	     * Get Message Attachment
	     *
	     * <p style='font-style:italic;'>Since 1.0.4 (Release 5.13)</p>
	     * <p>Returns particular message attachment data as a media stream.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.loadMessageAttachment = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}/content/{attachmentId}', options, exports.loadMessageAttachmentOptions), null);
	    };
	    /**
	     * Get Message Sync
	     *
	     * <p style='font-style:italic;'>Since 1.0.4 (Release 5.13)</p>
	     * <p>Provides facilities to synchronize mailbox content stored externally with server state.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.syncMessages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-sync', options, exports.syncMessagesOptions), messagesync.MessageSync);
	    };
	    return Messages;
	}(client.Client));
	exports.Messages = Messages;
	/**
	 * Definition of options for sendInternalMessage operation
	 */
	exports.sendInternalMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createpagermessagerequest.CreatePagerMessageRequest"
	    }
	];
	/**
	 * Definition of options for sendFaxMessage operation
	 */
	exports.sendFaxMessageOptions = [
	    {
	        "name": "accountId",
	        "in": "path",
	        "notes": "",
	        "paramType": "path",
	        "defaultValue": "~",
	        "required": true,
	        "allowMultiple": false,
	        "type": "string"
	    },
	    {
	        "name": "extensionId",
	        "in": "path",
	        "notes": "",
	        "paramType": "path",
	        "defaultValue": "~",
	        "required": true,
	        "allowMultiple": false,
	        "type": "string"
	    },
	    {
	        "name": "Content-Type",
	        "in": "header",
	        "default": "multipart/mixed; boundary=Boundary_1_14413901_1361871080888",
	        "type": "string"
	    },
	    {
	        "name": "Content-Length",
	        "in": "header",
	        "default": "",
	        "type": "string"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "consumes": [
	            "multipart/mixed; boundary=Boundary_1_14413901_1361871080888"
	        ],
	        "default": "--Boundary_1_14413901_1361871080888\nContent-Type: application/json\n\n{\n  \"to\":[{\"phoneNumber\":\"18005630003\"}],\n  \"faxResolution\":\"High\",\n  \"sendTime\":\"2013-02-26T09:31:20.882Z\"\n}\n\n--Boundary_1_14413901_1361871080888\nContent-Type: text/plain\n\nHello, World!\n\n--Boundary_1_14413901_1361871080888--",
	        "type": "string"
	    }
	];
	/**
	 * Definition of options for sendSMS operation
	 */
	exports.sendSMSOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createsmsmessage.CreateSMSMessage"
	    }
	];
	/**
	 * Definition of options for listMessages operation
	 */
	exports.listMessagesOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "availability",
	        "type": "IListMessagesAvailability",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Alive",
	            "Deleted",
	            "Purged"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "IListMessagesDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "distinctConversations",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "messageType",
	        "type": "IListMessagesMessageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Fax",
	            "SMS",
	            "VoiceMail",
	            "Pager",
	            "Text"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "readStatus",
	        "type": "IListMessagesReadStatus",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Read",
	            "Unread"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadMessage operation
	 */
	exports.loadMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "number",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for updateMessage operation
	 */
	exports.updateMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "updatemessagerequest.UpdateMessageRequest"
	    }
	];
	/**
	 * Definition of options for deleteMessage operation
	 */
	exports.deleteMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "purge",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadMessageAttachment operation
	 */
	exports.loadMessageAttachmentOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "attachmentId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for syncMessages operation
	 */
	exports.syncMessagesOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ISyncMessagesDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "distinctConversations",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "messageType",
	        "type": "ISyncMessagesMessageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Fax",
	            "SMS",
	            "VoiceMail",
	            "Pager",
	            "Text"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "recordCount",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncToken",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncType",
	        "type": "ISyncMessagesSyncType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "FSync",
	            "ISync"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListMessagesAvailability) {
	    IListMessagesAvailability[IListMessagesAvailability["Alive"] = 'Alive'] = "Alive";
	    IListMessagesAvailability[IListMessagesAvailability["Deleted"] = 'Deleted'] = "Deleted";
	    IListMessagesAvailability[IListMessagesAvailability["Purged"] = 'Purged'] = "Purged";
	})(exports.IListMessagesAvailability || (exports.IListMessagesAvailability = {}));
	var IListMessagesAvailability = exports.IListMessagesAvailability;
	(function (IListMessagesDirection) {
	    IListMessagesDirection[IListMessagesDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListMessagesDirection[IListMessagesDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListMessagesDirection || (exports.IListMessagesDirection = {}));
	var IListMessagesDirection = exports.IListMessagesDirection;
	(function (IListMessagesMessageType) {
	    IListMessagesMessageType[IListMessagesMessageType["Fax"] = 'Fax'] = "Fax";
	    IListMessagesMessageType[IListMessagesMessageType["SMS"] = 'SMS'] = "SMS";
	    IListMessagesMessageType[IListMessagesMessageType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    IListMessagesMessageType[IListMessagesMessageType["Pager"] = 'Pager'] = "Pager";
	    IListMessagesMessageType[IListMessagesMessageType["Text"] = 'Text'] = "Text";
	})(exports.IListMessagesMessageType || (exports.IListMessagesMessageType = {}));
	var IListMessagesMessageType = exports.IListMessagesMessageType;
	(function (IListMessagesReadStatus) {
	    IListMessagesReadStatus[IListMessagesReadStatus["Read"] = 'Read'] = "Read";
	    IListMessagesReadStatus[IListMessagesReadStatus["Unread"] = 'Unread'] = "Unread";
	})(exports.IListMessagesReadStatus || (exports.IListMessagesReadStatus = {}));
	var IListMessagesReadStatus = exports.IListMessagesReadStatus;
	(function (ISyncMessagesDirection) {
	    ISyncMessagesDirection[ISyncMessagesDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ISyncMessagesDirection[ISyncMessagesDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ISyncMessagesDirection || (exports.ISyncMessagesDirection = {}));
	var ISyncMessagesDirection = exports.ISyncMessagesDirection;
	(function (ISyncMessagesMessageType) {
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Fax"] = 'Fax'] = "Fax";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["SMS"] = 'SMS'] = "SMS";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Pager"] = 'Pager'] = "Pager";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Text"] = 'Text'] = "Text";
	})(exports.ISyncMessagesMessageType || (exports.ISyncMessagesMessageType = {}));
	var ISyncMessagesMessageType = exports.ISyncMessagesMessageType;
	(function (ISyncMessagesSyncType) {
	    ISyncMessagesSyncType[ISyncMessagesSyncType["FSync"] = 'FSync'] = "FSync";
	    ISyncMessagesSyncType[ISyncMessagesSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.ISyncMessagesSyncType || (exports.ISyncMessagesSyncType = {}));
	var ISyncMessagesSyncType = exports.ISyncMessagesSyncType;
	
	
	/***/ },
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageattachmentinfo = __webpack_require__(79);
	var messagestorecallerinfo = __webpack_require__(80);
	var MessageInfo = (function (_super) {
	    __extends(MessageInfo, _super);
	    function MessageInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'attachments', Class: messageattachmentinfo.MessageAttachmentInfo, isArray: true, isRequired: false },
	            { property: 'availability', Class: MessageInfoAvailability, isArray: false, isRequired: false },
	            { property: 'conversationId', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'creationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'deliveryErrorCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'direction', Class: MessageInfoDirection, isArray: false, isRequired: false },
	            { property: 'faxPageCount', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'faxResolution', Class: MessageInfoFaxResolution, isArray: false, isRequired: false },
	            { property: 'from', Class: messagestorecallerinfo.MessageStoreCallerInfo, isArray: false, isRequired: false },
	            { property: 'lastModifiedTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'messageStatus', Class: MessageInfoMessageStatus, isArray: false, isRequired: false },
	            { property: 'pgToDepartment', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'priority', Class: MessageInfoPriority, isArray: false, isRequired: false },
	            { property: 'readStatus', Class: MessageInfoReadStatus, isArray: false, isRequired: false },
	            { property: 'smsDeliveryTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'smsSendingAttemptsCount', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'subject', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'to', Class: messagestorecallerinfo.MessageStoreCallerInfo, isArray: true, isRequired: false },
	            { property: 'type', Class: MessageInfoType, isArray: false, isRequired: false },
	            { property: 'vmTranscriptionStatus', Class: MessageInfoVmTranscriptionStatus, isArray: false, isRequired: false }
	        ];
	    };
	    MessageInfo.prototype.getClassName = function () {
	        return 'MessageInfo';
	    };
	    return MessageInfo;
	}(model.Model));
	exports.MessageInfo = MessageInfo;
	(function (MessageInfoAvailability) {
	    MessageInfoAvailability[MessageInfoAvailability["Alive"] = 'Alive'] = "Alive";
	    MessageInfoAvailability[MessageInfoAvailability["Deleted"] = 'Deleted'] = "Deleted";
	    MessageInfoAvailability[MessageInfoAvailability["Purged"] = 'Purged'] = "Purged";
	})(exports.MessageInfoAvailability || (exports.MessageInfoAvailability = {}));
	var MessageInfoAvailability = exports.MessageInfoAvailability;
	(function (MessageInfoDirection) {
	    MessageInfoDirection[MessageInfoDirection["Inbound"] = 'Inbound'] = "Inbound";
	    MessageInfoDirection[MessageInfoDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.MessageInfoDirection || (exports.MessageInfoDirection = {}));
	var MessageInfoDirection = exports.MessageInfoDirection;
	(function (MessageInfoFaxResolution) {
	    MessageInfoFaxResolution[MessageInfoFaxResolution["High"] = 'High'] = "High";
	    MessageInfoFaxResolution[MessageInfoFaxResolution["Low"] = 'Low'] = "Low";
	})(exports.MessageInfoFaxResolution || (exports.MessageInfoFaxResolution = {}));
	var MessageInfoFaxResolution = exports.MessageInfoFaxResolution;
	(function (MessageInfoMessageStatus) {
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Queued"] = 'Queued'] = "Queued";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Sent"] = 'Sent'] = "Sent";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Delivered"] = 'Delivered'] = "Delivered";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["DeliveryFailed"] = 'DeliveryFailed'] = "DeliveryFailed";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["SendingFailed"] = 'SendingFailed'] = "SendingFailed";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Received"] = 'Received'] = "Received";
	})(exports.MessageInfoMessageStatus || (exports.MessageInfoMessageStatus = {}));
	var MessageInfoMessageStatus = exports.MessageInfoMessageStatus;
	(function (MessageInfoPriority) {
	    MessageInfoPriority[MessageInfoPriority["Normal"] = 'Normal'] = "Normal";
	    MessageInfoPriority[MessageInfoPriority["High"] = 'High'] = "High";
	})(exports.MessageInfoPriority || (exports.MessageInfoPriority = {}));
	var MessageInfoPriority = exports.MessageInfoPriority;
	(function (MessageInfoReadStatus) {
	    MessageInfoReadStatus[MessageInfoReadStatus["Read"] = 'Read'] = "Read";
	    MessageInfoReadStatus[MessageInfoReadStatus["Unread"] = 'Unread'] = "Unread";
	})(exports.MessageInfoReadStatus || (exports.MessageInfoReadStatus = {}));
	var MessageInfoReadStatus = exports.MessageInfoReadStatus;
	(function (MessageInfoType) {
	    MessageInfoType[MessageInfoType["Fax"] = 'Fax'] = "Fax";
	    MessageInfoType[MessageInfoType["SMS"] = 'SMS'] = "SMS";
	    MessageInfoType[MessageInfoType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    MessageInfoType[MessageInfoType["Pager"] = 'Pager'] = "Pager";
	    MessageInfoType[MessageInfoType["Text"] = 'Text'] = "Text";
	})(exports.MessageInfoType || (exports.MessageInfoType = {}));
	var MessageInfoType = exports.MessageInfoType;
	(function (MessageInfoVmTranscriptionStatus) {
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["NotAvailable"] = 'NotAvailable'] = "NotAvailable";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["InProgress"] = 'InProgress'] = "InProgress";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["TimedOut"] = 'TimedOut'] = "TimedOut";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["Completed"] = 'Completed'] = "Completed";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["CompletedPartially"] = 'CompletedPartially'] = "CompletedPartially";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["Failed"] = 'Failed'] = "Failed";
	})(exports.MessageInfoVmTranscriptionStatus || (exports.MessageInfoVmTranscriptionStatus = {}));
	var MessageInfoVmTranscriptionStatus = exports.MessageInfoVmTranscriptionStatus;
	
	
	/***/ },
	/* 79 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessageAttachmentInfo = (function (_super) {
	    __extends(MessageAttachmentInfo, _super);
	    function MessageAttachmentInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageAttachmentInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: MessageAttachmentInfoType, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'vmDuration', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    MessageAttachmentInfo.prototype.getClassName = function () {
	        return 'MessageAttachmentInfo';
	    };
	    return MessageAttachmentInfo;
	}(model.Model));
	exports.MessageAttachmentInfo = MessageAttachmentInfo;
	(function (MessageAttachmentInfoType) {
	    MessageAttachmentInfoType[MessageAttachmentInfoType["AudioRecording"] = 'AudioRecording'] = "AudioRecording";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["AudioTranscription"] = 'AudioTranscription'] = "AudioTranscription";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["Text"] = 'Text'] = "Text";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["SourceDocument"] = 'SourceDocument'] = "SourceDocument";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["RenderedDocument"] = 'RenderedDocument'] = "RenderedDocument";
	})(exports.MessageAttachmentInfoType || (exports.MessageAttachmentInfoType = {}));
	var MessageAttachmentInfoType = exports.MessageAttachmentInfoType;
	
	
	/***/ },
	/* 80 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessageStoreCallerInfo = (function (_super) {
	    __extends(MessageStoreCallerInfo, _super);
	    function MessageStoreCallerInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageStoreCallerInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'messageStatus', Class: MessageStoreCallerInfoMessageStatus, isArray: false, isRequired: false },
	            { property: 'faxErrorCode', Class: MessageStoreCallerInfoFaxErrorCode, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    MessageStoreCallerInfo.prototype.getClassName = function () {
	        return 'MessageStoreCallerInfo';
	    };
	    return MessageStoreCallerInfo;
	}(model.Model));
	exports.MessageStoreCallerInfo = MessageStoreCallerInfo;
	(function (MessageStoreCallerInfoMessageStatus) {
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Queued"] = 'Queued'] = "Queued";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Sent"] = 'Sent'] = "Sent";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Delivered"] = 'Delivered'] = "Delivered";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["DeliveryFailed"] = 'DeliveryFailed'] = "DeliveryFailed";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["SendingFailed"] = 'SendingFailed'] = "SendingFailed";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Received"] = 'Received'] = "Received";
	})(exports.MessageStoreCallerInfoMessageStatus || (exports.MessageStoreCallerInfoMessageStatus = {}));
	var MessageStoreCallerInfoMessageStatus = exports.MessageStoreCallerInfoMessageStatus;
	(function (MessageStoreCallerInfoFaxErrorCode) {
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["Undefined"] = 'Undefined'] = "Undefined";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoFaxSendPermission"] = 'NoFaxSendPermission'] = "NoFaxSendPermission";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoInternationalPermission"] = 'NoInternationalPermission'] = "NoInternationalPermission";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoFaxMachine"] = 'NoFaxMachine'] = "NoFaxMachine";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["OutgoingCallError"] = 'OutgoingCallError'] = "OutgoingCallError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["RenderingFailed"] = 'RenderingFailed'] = "RenderingFailed";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["TooManyPages"] = 'TooManyPages'] = "TooManyPages";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ReturnToDBQueue"] = 'ReturnToDBQueue'] = "ReturnToDBQueue";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoCallTime"] = 'NoCallTime'] = "NoCallTime";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["WrongNumber"] = 'WrongNumber'] = "WrongNumber";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ProhibitedNumber"] = 'ProhibitedNumber'] = "ProhibitedNumber";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["InternalError"] = 'InternalError'] = "InternalError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["FaxSendingProhibited"] = 'FaxSendingProhibited'] = "FaxSendingProhibited";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ThePhoneIsBlacklisted"] = 'ThePhoneIsBlacklisted'] = "ThePhoneIsBlacklisted";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["UserNotFound"] = 'UserNotFound'] = "UserNotFound";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ConvertError"] = 'ConvertError'] = "ConvertError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["DBGeneralError"] = 'DBGeneralError'] = "DBGeneralError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["SkypeBillingFailed"] = 'SkypeBillingFailed'] = "SkypeBillingFailed";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["AccountSuspended"] = 'AccountSuspended'] = "AccountSuspended";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ProhibitedDestination"] = 'ProhibitedDestination'] = "ProhibitedDestination";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	})(exports.MessageStoreCallerInfoFaxErrorCode || (exports.MessageStoreCallerInfoFaxErrorCode = {}));
	var MessageStoreCallerInfoFaxErrorCode = exports.MessageStoreCallerInfoFaxErrorCode;
	
	
	/***/ },
	/* 81 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageinfo = __webpack_require__(78);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var MessageList = (function (_super) {
	    __extends(MessageList, _super);
	    function MessageList() {
	        _super.apply(this, arguments);
	    }
	    MessageList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: messageinfo.MessageInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MessageList.prototype.getClassName = function () {
	        return 'MessageList';
	    };
	    return MessageList;
	}(model.Model));
	exports.MessageList = MessageList;
	
	
	/***/ },
	/* 82 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageinfo = __webpack_require__(78);
	var messagessyncinfo = __webpack_require__(83);
	var MessageSync = (function (_super) {
	    __extends(MessageSync, _super);
	    function MessageSync() {
	        _super.apply(this, arguments);
	    }
	    MessageSync.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: messageinfo.MessageInfo, isArray: true, isRequired: true },
	            { property: 'syncInfo', Class: messagessyncinfo.MessagesSyncInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MessageSync.prototype.getClassName = function () {
	        return 'MessageSync';
	    };
	    return MessageSync;
	}(model.Model));
	exports.MessageSync = MessageSync;
	
	
	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessagesSyncInfo = (function (_super) {
	    __extends(MessagesSyncInfo, _super);
	    function MessagesSyncInfo() {
	        _super.apply(this, arguments);
	    }
	    MessagesSyncInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'syncType', Class: MessagesSyncInfoSyncType, isArray: false, isRequired: false },
	            { property: 'syncToken', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'syncTime', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    MessagesSyncInfo.prototype.getClassName = function () {
	        return 'MessagesSyncInfo';
	    };
	    return MessagesSyncInfo;
	}(model.Model));
	exports.MessagesSyncInfo = MessagesSyncInfo;
	(function (MessagesSyncInfoSyncType) {
	    MessagesSyncInfoSyncType[MessagesSyncInfoSyncType["FSync"] = 'FSync'] = "FSync";
	    MessagesSyncInfoSyncType[MessagesSyncInfoSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.MessagesSyncInfoSyncType || (exports.MessagesSyncInfoSyncType = {}));
	var MessagesSyncInfoSyncType = exports.MessagesSyncInfoSyncType;
	
	
	/***/ },
	/* 84 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var getsubscriptioninforesponse = __webpack_require__(85);
	var NotificationsSubscriptionAPI = (function (_super) {
	    __extends(NotificationsSubscriptionAPI, _super);
	    function NotificationsSubscriptionAPI() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Subscription
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>Creates a new subscription. To call this method with APNS transport type you have to specify endpoint_id attribute in get token request at authorization.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.create = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/subscription', options, exports.createOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Get Subscription
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>Returns the requested subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Light</p>
	     */
	    NotificationsSubscriptionAPI.prototype.load = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.loadOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Renew Subscription / Modify Event Filters
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>With empty request body - renews the existent subscription. If event filters specified - modifies the event filters for the existing subscription. The client application can extend or narrow the events for which it receives notifications in the frame
	     *     of one subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.update = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.updateOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Cancel Subscription
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Cancels the existent subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.remove = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.removeOptions), null);
	    };
	    return NotificationsSubscriptionAPI;
	}(client.Client));
	exports.NotificationsSubscriptionAPI = NotificationsSubscriptionAPI;
	/**
	 * Definition of options for create operation
	 */
	exports.createOptions = [
	    {
	        "name": "body",
	        "type": "createsubscriptionrequest.CreateSubscriptionRequest",
	        "in": "body",
	        "required": true
	    }
	];
	/**
	 * Definition of options for load operation
	 */
	exports.loadOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for update operation
	 */
	exports.updateOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "type": "modifysubscriptionrequest.ModifySubscriptionRequest",
	        "in": "body",
	        "required": true
	    }
	];
	/**
	 * Definition of options for remove operation
	 */
	exports.removeOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var notificationdeliverymode = __webpack_require__(86);
	var GetSubscriptionInfoResponse = (function (_super) {
	    __extends(GetSubscriptionInfoResponse, _super);
	    function GetSubscriptionInfoResponse() {
	        _super.apply(this, arguments);
	    }
	    GetSubscriptionInfoResponse.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'eventFilters', Class: null /* string[] */, isArray: true, isRequired: false },
	            { property: 'expirationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'expiresIn', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'status', Class: GetSubscriptionInfoResponseStatus, isArray: false, isRequired: false },
	            { property: 'creationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'deliveryMode', Class: notificationdeliverymode.NotificationDeliveryMode, isArray: false, isRequired: true }
	        ];
	    };
	    GetSubscriptionInfoResponse.prototype.getClassName = function () {
	        return 'GetSubscriptionInfoResponse';
	    };
	    return GetSubscriptionInfoResponse;
	}(model.Model));
	exports.GetSubscriptionInfoResponse = GetSubscriptionInfoResponse;
	(function (GetSubscriptionInfoResponseStatus) {
	    GetSubscriptionInfoResponseStatus[GetSubscriptionInfoResponseStatus["Active"] = 'Active'] = "Active";
	    GetSubscriptionInfoResponseStatus[GetSubscriptionInfoResponseStatus["Suspended"] = 'Suspended'] = "Suspended";
	})(exports.GetSubscriptionInfoResponseStatus || (exports.GetSubscriptionInfoResponseStatus = {}));
	var GetSubscriptionInfoResponseStatus = exports.GetSubscriptionInfoResponseStatus;
	
	
	/***/ },
	/* 86 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var NotificationDeliveryMode = (function (_super) {
	    __extends(NotificationDeliveryMode, _super);
	    function NotificationDeliveryMode() {
	        _super.apply(this, arguments);
	    }
	    NotificationDeliveryMode.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'transportType', Class: NotificationDeliveryModeTransportType, isArray: false, isRequired: true },
	            { property: 'encryption', Class: null /* boolean */, isArray: false, isRequired: true },
	            { property: 'address', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'subscriberKey', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'encryptionAlgorithm', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'encryptionKey', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'registrationId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'certificateName', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    NotificationDeliveryMode.prototype.getClassName = function () {
	        return 'NotificationDeliveryMode';
	    };
	    return NotificationDeliveryMode;
	}(model.Model));
	exports.NotificationDeliveryMode = NotificationDeliveryMode;
	(function (NotificationDeliveryModeTransportType) {
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["PubNub"] = 'PubNub'] = "PubNub";
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["APNS"] = 'APNS'] = "APNS";
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType['PubNub/APNS/VoIP'] = 'PubNub/APNS/VoIP'] = 'PubNub/APNS/VoIP';
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["WebHook"] = 'WebHook'] = "WebHook";
	})(exports.NotificationDeliveryModeTransportType || (exports.NotificationDeliveryModeTransportType = {}));
	var NotificationDeliveryModeTransportType = exports.NotificationDeliveryModeTransportType;
	
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var presenceinfo = __webpack_require__(88);
	var monitoredextensions = __webpack_require__(90);
	var Presence = (function (_super) {
	    __extends(Presence, _super);
	    function Presence() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension(s) Presence Status by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns presence status of an extension or several extensions by their ID(s). Batch request is supported, see Batch Requests for details.The presenceStatus is returned as Offline (the parameters telephonyStatus, message, userStatus and dndStatus are not
	     *     returned at all) for the following extension types: Department/Announcement Only/Take Messages Only (Voicemail)/Fax User/Paging Only Group/Shared Lines Group/IVR Menu/Application Extension/Park Location.If the user requests his/her own presence status,
	     *     the response contains actual presence status even if the status publication is turned off.Batch request is supported. For batch requests the number of extensions in one request is limited to 30. If more extensions are included in the request, the
	     *     error code 400 Bad Request is returned with the logical error code InvalidMultipartRequest and the corresponding message 'Extension Presence Info multipart request is limited to 30 extensions'.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadPresence</td>
	     *             <td>Getting user presence information</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Presence.prototype.getPresenceStatus = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/presence', options, exports.getPresenceStatusOptions), presenceinfo.PresenceInfo);
	    };
	    /**
	     * Get Monitored Extensions
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns list of lines - extensions which presence status can be indicated and monitored on BLF-enabled (Busy Lamp Field) devices.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadPresence</td>
	     *             <td>Getting user presence information</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Presence.prototype.listMonitoredExtensions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/presence/line', options, exports.listMonitoredExtensionsOptions), monitoredextensions.MonitoredExtensions);
	    };
	    return Presence;
	}(client.Client));
	exports.Presence = Presence;
	/**
	 * Definition of options for getPresenceStatus operation
	 */
	exports.getPresenceStatusOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listMonitoredExtensions operation
	 */
	exports.listMonitoredExtensionsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	
	
	/***/ },
	/* 88 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var presenceextensioninfo = __webpack_require__(89);
	var PresenceInfo = (function (_super) {
	    __extends(PresenceInfo, _super);
	    function PresenceInfo() {
	        _super.apply(this, arguments);
	    }
	    PresenceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'allowSeeMyPresence', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'dndStatus', Class: PresenceInfoDndStatus, isArray: false, isRequired: false },
	            { property: 'extension', Class: presenceextensioninfo.PresenceExtensionInfo, isArray: false, isRequired: false },
	            { property: 'message', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'pickUpCallsOnHold', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'presenceStatus', Class: PresenceInfoPresenceStatus, isArray: false, isRequired: false },
	            { property: 'ringOnMonitoredCall', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'telephonyStatus', Class: PresenceInfoTelephonyStatus, isArray: false, isRequired: false },
	            { property: 'userStatus', Class: PresenceInfoUserStatus, isArray: false, isRequired: false }
	        ];
	    };
	    PresenceInfo.prototype.getClassName = function () {
	        return 'PresenceInfo';
	    };
	    return PresenceInfo;
	}(model.Model));
	exports.PresenceInfo = PresenceInfo;
	(function (PresenceInfoDndStatus) {
	    PresenceInfoDndStatus[PresenceInfoDndStatus["TakeAllCalls"] = 'TakeAllCalls'] = "TakeAllCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["DoNotAcceptAnyCalls"] = 'DoNotAcceptAnyCalls'] = "DoNotAcceptAnyCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["DoNotAcceptDepartmentCalls"] = 'DoNotAcceptDepartmentCalls'] = "DoNotAcceptDepartmentCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["TakeDepartmentCallsOnly"] = 'TakeDepartmentCallsOnly'] = "TakeDepartmentCallsOnly";
	})(exports.PresenceInfoDndStatus || (exports.PresenceInfoDndStatus = {}));
	var PresenceInfoDndStatus = exports.PresenceInfoDndStatus;
	(function (PresenceInfoPresenceStatus) {
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Offline"] = 'Offline'] = "Offline";
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Busy"] = 'Busy'] = "Busy";
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Available"] = 'Available'] = "Available";
	})(exports.PresenceInfoPresenceStatus || (exports.PresenceInfoPresenceStatus = {}));
	var PresenceInfoPresenceStatus = exports.PresenceInfoPresenceStatus;
	(function (PresenceInfoTelephonyStatus) {
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["NoCall"] = 'NoCall'] = "NoCall";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["CallConnected"] = 'CallConnected'] = "CallConnected";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["Ringing"] = 'Ringing'] = "Ringing";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["OnHold"] = 'OnHold'] = "OnHold";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["ParkedCall"] = 'ParkedCall'] = "ParkedCall";
	})(exports.PresenceInfoTelephonyStatus || (exports.PresenceInfoTelephonyStatus = {}));
	var PresenceInfoTelephonyStatus = exports.PresenceInfoTelephonyStatus;
	(function (PresenceInfoUserStatus) {
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Offline"] = 'Offline'] = "Offline";
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Busy"] = 'Busy'] = "Busy";
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Available"] = 'Available'] = "Available";
	})(exports.PresenceInfoUserStatus || (exports.PresenceInfoUserStatus = {}));
	var PresenceInfoUserStatus = exports.PresenceInfoUserStatus;
	
	
	/***/ },
	/* 89 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PresenceExtensionInfo = (function (_super) {
	    __extends(PresenceExtensionInfo, _super);
	    function PresenceExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    PresenceExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    PresenceExtensionInfo.prototype.getClassName = function () {
	        return 'PresenceExtensionInfo';
	    };
	    return PresenceExtensionInfo;
	}(model.Model));
	exports.PresenceExtensionInfo = PresenceExtensionInfo;
	
	
	/***/ },
	/* 90 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var lineinfo = __webpack_require__(91);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var MonitoredExtensions = (function (_super) {
	    __extends(MonitoredExtensions, _super);
	    function MonitoredExtensions() {
	        _super.apply(this, arguments);
	    }
	    MonitoredExtensions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'records', Class: lineinfo.LineInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MonitoredExtensions.prototype.getClassName = function () {
	        return 'MonitoredExtensions';
	    };
	    return MonitoredExtensions;
	}(model.Model));
	exports.MonitoredExtensions = MonitoredExtensions;
	
	
	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var monitoredlinesextensioninfo = __webpack_require__(92);
	var LineInfo = (function (_super) {
	    __extends(LineInfo, _super);
	    function LineInfo() {
	        _super.apply(this, arguments);
	    }
	    LineInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extension', Class: monitoredlinesextensioninfo.MonitoredLinesExtensionInfo, isArray: false, isRequired: false }
	        ];
	    };
	    LineInfo.prototype.getClassName = function () {
	        return 'LineInfo';
	    };
	    return LineInfo;
	}(model.Model));
	exports.LineInfo = LineInfo;
	
	
	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MonitoredLinesExtensionInfo = (function (_super) {
	    __extends(MonitoredLinesExtensionInfo, _super);
	    function MonitoredLinesExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    MonitoredLinesExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: MonitoredLinesExtensionInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    MonitoredLinesExtensionInfo.prototype.getClassName = function () {
	        return 'MonitoredLinesExtensionInfo';
	    };
	    return MonitoredLinesExtensionInfo;
	}(model.Model));
	exports.MonitoredLinesExtensionInfo = MonitoredLinesExtensionInfo;
	(function (MonitoredLinesExtensionInfoType) {
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["User"] = 'User'] = "User";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["Department"] = 'Department'] = "Department";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.MonitoredLinesExtensionInfoType || (exports.MonitoredLinesExtensionInfoType = {}));
	var MonitoredLinesExtensionInfoType = exports.MonitoredLinesExtensionInfoType;
	
	
	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var ringoutstatus = __webpack_require__(94);
	var RingOut = (function (_super) {
	    __extends(RingOut, _super);
	    function RingOut() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Make RingOut Call
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Makes a 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    RingOut.prototype.makeRingOutCall = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout', options, exports.makeRingOutCallOptions), ringoutstatus.RingOutStatus);
	    };
	    /**
	     * Get Status of RingOut Call
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Returns the status of a 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    RingOut.prototype.getRingOutCallStatus = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout/{ringoutId}', options, exports.getRingOutCallStatusOptions), ringoutstatus.RingOutStatus);
	    };
	    /**
	     * Cancel RingOut Call
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Cancels the 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    RingOut.prototype.cancelRingOutCall = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout/{ringoutId}', options, exports.cancelRingOutCallOptions), null);
	    };
	    return RingOut;
	}(client.Client));
	exports.RingOut = RingOut;
	/**
	 * Definition of options for makeRingOutCall operation
	 */
	exports.makeRingOutCallOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "makeringoutrequest.MakeRingOutRequest"
	    }
	];
	/**
	 * Definition of options for getRingOutCallStatus operation
	 */
	exports.getRingOutCallStatusOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "ringoutId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for cancelRingOutCall operation
	 */
	exports.cancelRingOutCallOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "ringoutId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 94 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ringoutstatusinfo = __webpack_require__(95);
	var RingOutStatus = (function (_super) {
	    __extends(RingOutStatus, _super);
	    function RingOutStatus() {
	        _super.apply(this, arguments);
	    }
	    RingOutStatus.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'status', Class: ringoutstatusinfo.RingOutStatusInfo, isArray: false, isRequired: false }
	        ];
	    };
	    RingOutStatus.prototype.getClassName = function () {
	        return 'RingOutStatus';
	    };
	    return RingOutStatus;
	}(model.Model));
	exports.RingOutStatus = RingOutStatus;
	
	
	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var RingOutStatusInfo = (function (_super) {
	    __extends(RingOutStatusInfo, _super);
	    function RingOutStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    RingOutStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'callStatus', Class: RingOutStatusInfoCallStatus, isArray: false, isRequired: false },
	            { property: 'callerStatus', Class: RingOutStatusInfoCallerStatus, isArray: false, isRequired: false },
	            { property: 'calleeStatus', Class: RingOutStatusInfoCalleeStatus, isArray: false, isRequired: false }
	        ];
	    };
	    RingOutStatusInfo.prototype.getClassName = function () {
	        return 'RingOutStatusInfo';
	    };
	    return RingOutStatusInfo;
	}(model.Model));
	exports.RingOutStatusInfo = RingOutStatusInfo;
	(function (RingOutStatusInfoCallStatus) {
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCallStatus || (exports.RingOutStatusInfoCallStatus = {}));
	var RingOutStatusInfoCallStatus = exports.RingOutStatusInfoCallStatus;
	(function (RingOutStatusInfoCallerStatus) {
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCallerStatus || (exports.RingOutStatusInfoCallerStatus = {}));
	var RingOutStatusInfoCallerStatus = exports.RingOutStatusInfoCallerStatus;
	(function (RingOutStatusInfoCalleeStatus) {
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCalleeStatus || (exports.RingOutStatusInfoCalleeStatus = {}));
	var RingOutStatusInfoCalleeStatus = exports.RingOutStatusInfoCalleeStatus;
	
	
	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var extensionforwardingnumberlist = __webpack_require__(97);
	var forwardingnumberinfo = __webpack_require__(98);
	var ForwardingNumbers = (function (_super) {
	    __extends(ForwardingNumbers, _super);
	    function ForwardingNumbers() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension Forwarding Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Returns the list of extension phone numbers used for call forwarding and call flip. The returned list contains all the extension phone numbers that are used for call forwarding and call flip.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    ForwardingNumbers.prototype.listExtensionForwardingNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number', options, exports.listExtensionForwardingNumbersOptions), extensionforwardingnumberlist.ExtensionForwardingNumberList);
	    };
	    /**
	     * Create Forwarding Number
	     *
	     * <p style='font-style:italic;'>Since 1.0.12 (Release 6.4)</p>
	     * <p>Adds a new forwarding number to the forwarding number list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.createExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number', options, exports.createExtensionForwardingNumberOptions), forwardingnumberinfo.ForwardingNumberInfo);
	    };
	    /**
	     * Update Forwarding Number by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.24 (Release 8.0)</p>
	     * <p>Updates an existent forwarding number from the forwarding number list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.updateExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number/{forwardingNumberId}', options, exports.updateExtensionForwardingNumberOptions), forwardingnumberinfo.ForwardingNumberInfo);
	    };
	    /**
	     * Delete Forwarding Number by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.24 (Release 8.0)</p>
	     * <p>Deletes a forwarding number from the forwarding number list by its ID.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.deleteExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number/{forwardingNumberId}', options, exports.deleteExtensionForwardingNumberOptions), null);
	    };
	    return ForwardingNumbers;
	}(client.Client));
	exports.ForwardingNumbers = ForwardingNumbers;
	/**
	 * Definition of options for listExtensionForwardingNumbers operation
	 */
	exports.listExtensionForwardingNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for createExtensionForwardingNumber operation
	 */
	exports.createExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createforwardingnumberrequest.CreateForwardingNumberRequest"
	    }
	];
	/**
	 * Definition of options for updateExtensionForwardingNumber operation
	 */
	exports.updateExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "forwardingNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "updateforwardingnumberrequest.UpdateForwardingNumberRequest"
	    }
	];
	/**
	 * Definition of options for deleteExtensionForwardingNumber operation
	 */
	exports.deleteExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "forwardingNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 97 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var forwardingnumberinfo = __webpack_require__(98);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionForwardingNumberList = (function (_super) {
	    __extends(ExtensionForwardingNumberList, _super);
	    function ExtensionForwardingNumberList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionForwardingNumberList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: forwardingnumberinfo.ForwardingNumberInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: false },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionForwardingNumberList.prototype.getClassName = function () {
	        return 'ExtensionForwardingNumberList';
	    };
	    return ExtensionForwardingNumberList;
	}(model.Model));
	exports.ExtensionForwardingNumberList = ExtensionForwardingNumberList;
	
	
	/***/ },
	/* 98 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ForwardingNumberInfo = (function (_super) {
	    __extends(ForwardingNumberInfo, _super);
	    function ForwardingNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    ForwardingNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'label', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'features', Class: ForwardingNumberInfoFeatures, isArray: false, isRequired: false },
	            { property: 'flipNumber', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    ForwardingNumberInfo.prototype.getClassName = function () {
	        return 'ForwardingNumberInfo';
	    };
	    return ForwardingNumberInfo;
	}(model.Model));
	exports.ForwardingNumberInfo = ForwardingNumberInfo;
	(function (ForwardingNumberInfoFeatures) {
	    ForwardingNumberInfoFeatures[ForwardingNumberInfoFeatures["CallFlip"] = 'CallFlip'] = "CallFlip";
	    ForwardingNumberInfoFeatures[ForwardingNumberInfoFeatures["CallForwarding"] = 'CallForwarding'] = "CallForwarding";
	})(exports.ForwardingNumberInfoFeatures || (exports.ForwardingNumberInfoFeatures = {}));
	var ForwardingNumberInfoFeatures = exports.ForwardingNumberInfoFeatures;
	
	
	/***/ },
	/* 99 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var blockednumberinfo = __webpack_require__(100);
	var blockednumberslist = __webpack_require__(101);
	var BlockedNumbers = (function (_super) {
	    __extends(BlockedNumbers, _super);
	    function BlockedNumbers() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Add Blocked Number
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.blockNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number', options, exports.blockNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Get Blocked Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers which are specified by the user to block inbound calls and SMS messages.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    BlockedNumbers.prototype.listBlockedNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number', options, exports.listBlockedNumbersOptions), blockednumberslist.BlockedNumbersList);
	    };
	    /**
	     * Get Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    BlockedNumbers.prototype.loadBlockedNumber = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.loadBlockedNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Update Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.updateBlockedNumber = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.updateBlockedNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Delete Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.unblockNumber = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.unblockNumberOptions), null);
	    };
	    return BlockedNumbers;
	}(client.Client));
	exports.BlockedNumbers = BlockedNumbers;
	/**
	 * Definition of options for blockNumber operation
	 */
	exports.blockNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listBlockedNumbers operation
	 */
	exports.listBlockedNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadBlockedNumber operation
	 */
	exports.loadBlockedNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for updateBlockedNumber operation
	 */
	exports.updateBlockedNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for unblockNumber operation
	 */
	exports.unblockNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 100 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BlockedNumberInfo = (function (_super) {
	    __extends(BlockedNumberInfo, _super);
	    function BlockedNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    BlockedNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    BlockedNumberInfo.prototype.getClassName = function () {
	        return 'BlockedNumberInfo';
	    };
	    return BlockedNumberInfo;
	}(model.Model));
	exports.BlockedNumberInfo = BlockedNumberInfo;
	
	
	/***/ },
	/* 101 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var blockednumberinfo = __webpack_require__(100);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var BlockedNumbersList = (function (_super) {
	    __extends(BlockedNumbersList, _super);
	    function BlockedNumbersList() {
	        _super.apply(this, arguments);
	    }
	    BlockedNumbersList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: blockednumberinfo.BlockedNumberInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    BlockedNumbersList.prototype.getClassName = function () {
	        return 'BlockedNumbersList';
	    };
	    return BlockedNumbersList;
	}(model.Model));
	exports.BlockedNumbersList = BlockedNumbersList;
	
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=ringcentral-client.js.map

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _reduxHelper = __webpack_require__(136);
	
	var _eventEmitter = __webpack_require__(137);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['store', 'mapper', 'prefix', 'actions', 'emitter']);
	
	/**
	 * @function
	 * @param {Object} state
	 * @return {Object}
	 * @description Default reducer if module does not has its own reducer.
	 */
	function defaultReducer(state) {
	  if (typeof state === 'undefined') return {};
	  return state;
	}
	/**
	 * @function
	 * @param {Object} state
	 * @return {Object}
	 * @description Default parent state to module state mapper.
	 */
	function defaultMapper(state) {
	  return state;
	}
	
	/**
	 * @class
	 * @default
	 * @description Base module class.
	 */
	
	var RcModule = function () {
	  /**
	   * @constructor
	   */
	
	  function RcModule(_ref) {
	    var _this = this;
	
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var _ref$stateMapper = _ref.stateMapper;
	    var stateMapper = _ref$stateMapper === undefined ? defaultMapper : _ref$stateMapper;
	    var prefix = _ref.prefix;
	    var actions = _ref.actions;
	    (0, _classCallCheck3.default)(this, RcModule);
	
	    // Extending EventEmitter breaks some mechanic, so we wire emitter up like this instead.
	    this[symbols.emitter] = new _eventEmitter2.default();
	    this[symbols.mapper] = stateMapper;
	    this[symbols.prefix] = prefix;
	    this[symbols.actions] = actions && (0, _reduxHelper.prefixActions)(actions, prefix);
	    registerStoreHandler(function (store) {
	      _this[symbols.store] = store;
	    });
	  }
	
	  /**
	   * @function
	   * @param {String} event
	   * @param {Function} handler
	   * @return {Function} Unregister function.
	   */
	
	
	  (0, _createClass3.default)(RcModule, [{
	    key: 'on',
	    value: function on(event, handler) {
	      var _this2 = this;
	
	      this[symbols.emitter].on(event, handler);
	      return function () {
	        _this2[symbols.emitter].off(event, handler);
	      };
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {Function)} handler
	     * @return {Function} Unregister function.
	     */
	
	  }, {
	    key: 'once',
	    value: function once(event, handler) {
	      var _this3 = this;
	
	      this[symbols.emitter].once(event, handler);
	      return function () {
	        _this3[symbols.emitter].off(event, handler);
	      };
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {...args} args
	     */
	
	  }, {
	    key: 'emit',
	    value: function emit(event) {
	      var _symbols$emitter;
	
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      (_symbols$emitter = this[symbols.emitter]).emit.apply(_symbols$emitter, [event].concat(args));
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {Function} handler
	     */
	
	  }, {
	    key: 'off',
	    value: function off(event, handler) {
	      this[symbols.emitter].off(event, handler);
	    }
	  }, {
	    key: 'state',
	    get: function get() {
	      return this[symbols.mapper](this[symbols.store].getState());
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return defaultReducer;
	    }
	  }, {
	    key: 'store',
	    get: function get() {
	      return this[symbols.store];
	    }
	  }, {
	    key: 'prefix',
	    get: function get() {
	      return this[symbols.prefix];
	    }
	  }, {
	    key: 'actions',
	    get: function get() {
	      return this[symbols.actions];
	    }
	  }]);
	  return RcModule;
	}();
	
	exports.default = RcModule;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class
	 * @description Helper class for creating a symbol mapping
	 */
	
	var SymbolMap = function (_Enum) {
	  (0, _inherits3.default)(SymbolMap, _Enum);
	
	  /**
	   * @constructor
	   * @param {String[]} keys
	   */
	
	  function SymbolMap(keys) {
	    (0, _classCallCheck3.default)(this, SymbolMap);
	
	    var definition = {};
	    keys.forEach(function (key) {
	      definition[key] = (0, _symbol2.default)();
	    });
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(SymbolMap).call(this, definition));
	  }
	
	  return SymbolMap;
	}(_enum2.default);
	
	exports.default = SymbolMap;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasOwnProperty = {}.hasOwnProperty;
	var DEFINITION = (0, _symbol2.default)();
	var VALUES = (0, _symbol2.default)();
	
	var Enum = function () {
	  function Enum(definition) {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, Enum);
	
	    this[DEFINITION] = (0, _assign2.default)({}, definition);
	    this[VALUES] = new _set2.default();
	
	    var _loop = function _loop(key) {
	      if (hasOwnProperty.call(definition, key)) {
	        (0, _defineProperty2.default)(_this, key, {
	          get: function get() {
	            return this[DEFINITION][key];
	          },
	
	          enumerable: true
	        });
	        _this[VALUES].add(_this[DEFINITION][key]);
	      }
	    };
	
	    for (var key in definition) {
	      _loop(key);
	    }
	  }
	
	  (0, _createClass3.default)(Enum, null, [{
	    key: "hasValue",
	    value: function hasValue(value) {
	      return this[VALUES].has(value);
	    }
	  }]);
	  return Enum;
	}();
	
	/*
	 * //with Proxy support
	 *const enumHandler = {
	 *  get(target, key) {
	 *    return target[key];
	 *  },
	 *  set() {
	 *    return;
	 *  }
	 *};
	 *Enum = class Enum extends Proxy {
	 *  constructor(definition) {
	 *    super(Object.assign({}, definition), enumHandler);
	 *  }
	 *}
	 */
	
	
	exports.default = Enum;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ActionMap = undefined;
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	exports.prefixActions = prefixActions;
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * @class
	 * @description helper class for creating redux action definition maps
	 */
	
	var ActionMap = exports.ActionMap = function (_Enum) {
	  (0, _inherits3.default)(ActionMap, _Enum);
	
	  /**
	   * @constructor
	   * @param {String[]} actions - list of action strings
	   * @extends Enum
	   */
	
	  function ActionMap() {
	    var actions = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
	    (0, _classCallCheck3.default)(this, ActionMap);
	
	    var definition = {};
	    actions.forEach(function (action) {
	      definition[action] = prefix !== '' ? prefix + '-' + action : action;
	    });
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ActionMap).call(this, definition));
	  }
	
	  return ActionMap;
	}(_enum2.default);
	
	/**
	 * @function
	 * @description helper function to return a prefixed action definition maps
	 */
	
	
	function prefixActions(actions, prefix) {
	  if (!prefix || prefix === '') return actions;
	  var definition = {};
	  for (var action in actions) {
	    if (hasOwnProperty.call(actions, action)) {
	      definition[action] = prefix + '-' + action;
	    }
	  }
	  return new _enum2.default(definition);
	}

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var d        = __webpack_require__(138)
	  , callable = __webpack_require__(151)
	
	  , apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }
	
	  , on, once, off, emit, methods, descriptors, base;
	
	on = function (type, listener) {
		var data;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];
	
		return this;
	};
	
	once = function (type, listener) {
		var once, self;
	
		callable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});
	
		once.__eeOnceListener__ = listener;
		return this;
	};
	
	off = function (type, listener) {
		var data, listeners, candidate, i;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];
	
		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}
	
		return this;
	};
	
	emit = function (type) {
		var i, l, listener, listeners, args;
	
		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;
	
		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];
	
			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};
	
	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};
	
	descriptors = {
		on: d(on),
		once: d(once),
		off: d(off),
		emit: d(emit)
	};
	
	base = defineProperties({}, descriptors);
	
	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign        = __webpack_require__(139)
	  , normalizeOpts = __webpack_require__(146)
	  , isCallable    = __webpack_require__(147)
	  , contains      = __webpack_require__(148)
	
	  , d;
	
	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}
	
		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};
	
	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}
	
		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(140)()
		? Object.assign
		: __webpack_require__(141);


/***/ },
/* 140 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== 'function') return false;
		obj = { foo: 'raz' };
		assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
		return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var keys  = __webpack_require__(142)
	  , value = __webpack_require__(145)
	
	  , max = Math.max;
	
	module.exports = function (dest, src/*, …srcn*/) {
		var error, i, l = max(arguments.length, 2), assign;
		dest = Object(value(dest));
		assign = function (key) {
			try { dest[key] = src[key]; } catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < l; ++i) {
			src = arguments[i];
			keys(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(143)()
		? Object.keys
		: __webpack_require__(144);


/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		try {
			Object.keys('primitive');
			return true;
		} catch (e) { return false; }
	};


/***/ },
/* 144 */
/***/ function(module, exports) {

	'use strict';
	
	var keys = Object.keys;
	
	module.exports = function (object) {
		return keys(object == null ? object : Object(object));
	};


/***/ },
/* 145 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (value) {
		if (value == null) throw new TypeError("Cannot use null or undefined");
		return value;
	};


/***/ },
/* 146 */
/***/ function(module, exports) {

	'use strict';
	
	var forEach = Array.prototype.forEach, create = Object.create;
	
	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};
	
	module.exports = function (options/*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (options == null) return;
			process(Object(options), result);
		});
		return result;
	};


/***/ },
/* 147 */
/***/ function(module, exports) {

	// Deprecated
	
	'use strict';
	
	module.exports = function (obj) { return typeof obj === 'function'; };


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(149)()
		? String.prototype.contains
		: __webpack_require__(150);


/***/ },
/* 149 */
/***/ function(module, exports) {

	'use strict';
	
	var str = 'razdwatrzy';
	
	module.exports = function () {
		if (typeof str.contains !== 'function') return false;
		return ((str.contains('dwa') === true) && (str.contains('foo') === false));
	};


/***/ },
/* 150 */
/***/ function(module, exports) {

	'use strict';
	
	var indexOf = String.prototype.indexOf;
	
	module.exports = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};


/***/ },
/* 151 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (fn) {
		if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
		return fn;
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _reduxHelper = __webpack_require__(136);
	
	var _redux = __webpack_require__(153);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['reducer']);
	
	function getSettingsReducer(prefix) {
	  return function (state, action) {
	    if (typeof state === 'undefined') return {};
	
	    return state;
	  };
	}
	
	var Settings = function (_RcModule) {
	  (0, _inherits3.default)(Settings, _RcModule);
	
	  function Settings(options) {
	    (0, _classCallCheck3.default)(this, Settings);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Settings).call(this, (0, _extends3.default)({}, options)));
	
	    _this[symbols.reducer] = {
	      base: getSettingsReducer(_this.prefix)
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(Settings, [{
	    key: 'registerReducer',
	    value: function registerReducer(name, reducer) {
	      this[symbols.reducer][name] = reducer;
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _redux.combineReducers)(this[symbols.reducer]);
	    }
	  }]);
	  return Settings;
	}(_rcModule2.default);
	
	exports.default = Settings;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(154);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(161);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(163);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(164);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(165);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(162);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(155);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(159);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var getPrototype = __webpack_require__(156),
	    isHostObject = __webpack_require__(157),
	    isObjectLike = __webpack_require__(158);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object,
	 *  else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ },
/* 156 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetPrototype = Object.getPrototypeOf;
	
	/**
	 * Gets the `[[Prototype]]` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {null|Object} Returns the `[[Prototype]]`.
	 */
	function getPrototype(value) {
	  return nativeGetPrototype(Object(value));
	}
	
	module.exports = getPrototype;


/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 158 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(160)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 160 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(154);
	
	var _isPlainObject = __webpack_require__(155);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(162);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ },
/* 162 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(165);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 165 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _brandActions = __webpack_require__(167);
	
	var _brandActions2 = _interopRequireDefault(_brandActions);
	
	var _brandReducer = __webpack_require__(168);
	
	var _brandReducer2 = _interopRequireDefault(_brandReducer);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['initialState']);
	
	var Brand = function (_RcModule) {
	  (0, _inherits3.default)(Brand, _RcModule);
	
	  function Brand(_ref) {
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var _ref$stateMapper = _ref.stateMapper;
	    var stateMapper = _ref$stateMapper === undefined ? function (state) {
	      return state.brand;
	    } : _ref$stateMapper;
	    var prefix = _ref.prefix;
	    var id = _ref.id;
	    var name = _ref.name;
	    (0, _classCallCheck3.default)(this, Brand);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Brand).call(this, {
	      registerStoreHandler: registerStoreHandler,
	      stateMapper: stateMapper,
	      prefix: prefix,
	      actions: _brandActions2.default
	    }));
	
	    _this[symbols.initialState] = {
	      id: id,
	      name: name
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(Brand, [{
	    key: 'reducer',
	    get: function get() {
	      return (0, _brandReducer2.default)(this[symbols.initialState], this.prefix);
	    }
	  }, {
	    key: 'id',
	    get: function get() {
	      return this.state.id;
	    }
	  }, {
	    key: 'name',
	    get: function get() {
	      return this.state.name;
	    }
	  }]);
	  return Brand;
	}(_rcModule2.default);
	
	exports.default = Brand;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['setBrand']);

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getReducer;
	
	var _brandActions = __webpack_require__(167);
	
	var _brandActions2 = _interopRequireDefault(_brandActions);
	
	var _reduxHelper = __webpack_require__(136);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getReducer(initialState, prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_brandActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	
	    if (!action) return state;
	    switch (action.type) {
	      case actions.setBrand:
	        return (0, _assign2.default)({}, state, {
	          name: action.payload.name,
	          id: action.payload.id
	        });
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getIterator2 = __webpack_require__(66);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _toConsumableArray2 = __webpack_require__(170);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	var _authActions = __webpack_require__(188);
	
	var _authActions2 = _interopRequireDefault(_authActions);
	
	var _authReducer = __webpack_require__(189);
	
	var _authReducer2 = _interopRequireDefault(_authReducer);
	
	var _authEvents = __webpack_require__(190);
	
	var _utils = __webpack_require__(191);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['platform', 'emitter', 'beforeLogoutHandlers']);
	
	var ENUMS = new _enum2.default({
	  loginStatus: _loginStatus2.default
	});
	
	/**
	 * @class
	 * @description Authentication module
	 */
	
	var Auth = function (_RcModule) {
	  (0, _inherits3.default)(Auth, _RcModule);
	
	  /**
	   * @function
	   */
	
	  function Auth(options) {
	    var _this2 = this;
	
	    (0, _classCallCheck3.default)(this, Auth);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Auth).call(this, (0, _extends3.default)({}, options, {
	      actions: _authActions2.default
	    })));
	
	    var platform = options.platform;
	
	
	    _this[symbols.platform] = platform;
	    _this[symbols.beforeLogoutHandlers] = new _set2.default();
	
	    // load info on login
	    platform.on(platform.events.loginSuccess, function () {
	      _this.store.dispatch({
	        type: _this.actions.loginSuccess
	      });
	      _utils.emit.call(_this, _authEvents.authEventTypes.loginStatusChanged, _this.state.status);
	    });
	    // loginError
	    platform.on(platform.events.loginError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.loginError,
	        error: error
	      });
	    });
	    // unload info on logout
	    platform.on(platform.events.logoutSuccess, function () {
	      _this.store.dispatch({
	        type: _this.actions.logoutSuccess
	      });
	      // this.emit(authEvents.userInfoCleared);
	    });
	
	    platform.on(platform.events.logoutError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.logoutError,
	        error: error
	      });
	    });
	
	    platform.on(platform.events.refreshError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.refreshError,
	        error: error
	      });
	    });
	
	    // load info if already logged in
	    (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	      var loggedIn;
	      return _regenerator2.default.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return platform.loggedIn();
	
	            case 2:
	              loggedIn = _context.sent;
	
	              _this.store.dispatch({
	                type: _this.actions.init,
	                status: loggedIn ? _loginStatus2.default.loggedIn : _loginStatus2.default.notLoggedIn
	              });
	              _this.emit(_authEvents.authEventTypes.authEventTypes, _this.state.status);
	
	            case 5:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this2);
	    }))();
	    return _this;
	  }
	
	  (0, _createClass3.default)(Auth, [{
	    key: 'login',
	
	    /**
	     * @function
	     * @async
	     * @description Login function using username and password
	     */
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(_ref) {
	        var username = _ref.username;
	        var password = _ref.password;
	        var extension = _ref.extension;
	        var remember = _ref.remember;
	        return _regenerator2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                this.store.dispatch({
	                  type: this.actions.login,
	                  payload: {
	                    username: username,
	                    password: password,
	                    extension: extension,
	                    remember: remember
	                  }
	                });
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingIn);
	                _context2.next = 4;
	                return this[symbols.platform].login({
	                  username: username,
	                  password: password,
	                  extension: extension,
	                  remember: remember
	                });
	
	              case 4:
	                return _context2.abrupt('return', _context2.sent);
	
	              case 5:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));
	
	      function login(_x) {
	        return ref.apply(this, arguments);
	      }
	
	      return login;
	    }()
	
	    /**
	     * @function
	     * @async
	     * @description Authorize using OAauth code
	     */
	
	  }, {
	    key: 'authorize',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(_ref2) {
	        var code = _ref2.code;
	        var redirectUri = _ref2.redirectUri;
	        return _regenerator2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                this.store.dispatch({
	                  type: this.actions.login,
	                  payload: {
	                    code: code,
	                    redirectUri: redirectUri
	                  }
	                });
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingIn);
	                _context3.next = 4;
	                return this[symbols.platform].login({
	                  code: code,
	                  redirectUri: redirectUri
	                });
	
	              case 4:
	                return _context3.abrupt('return', _context3.sent);
	
	              case 5:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));
	
	      function authorize(_x2) {
	        return ref.apply(this, arguments);
	      }
	
	      return authorize;
	    }()
	
	    /**
	     * @function
	     * @async
	     * @description Log the user out
	     */
	
	  }, {
	    key: 'logout',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	        var _this3 = this;
	
	        var handlers, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;
	
	        return _regenerator2.default.wrap(function _callee5$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                // deal with removing subscriptions
	
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingOut);
	                handlers = [].concat((0, _toConsumableArray3.default)(this[symbols.beforeLogoutHandlers]));
	                _iteratorNormalCompletion = true;
	                _didIteratorError = false;
	                _iteratorError = undefined;
	                _context6.prev = 5;
	                _loop = _regenerator2.default.mark(function _loop() {
	                  var handler;
	                  return _regenerator2.default.wrap(function _loop$(_context5) {
	                    while (1) {
	                      switch (_context5.prev = _context5.next) {
	                        case 0:
	                          handler = _step.value;
	                          _context5.prev = 1;
	                          _context5.next = 4;
	                          return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	                            return _regenerator2.default.wrap(function _callee4$(_context4) {
	                              while (1) {
	                                switch (_context4.prev = _context4.next) {
	                                  case 0:
	                                    return _context4.abrupt('return', handler());
	
	                                  case 1:
	                                  case 'end':
	                                    return _context4.stop();
	                                }
	                              }
	                            }, _callee4, _this3);
	                          }))();
	
	                        case 4:
	                          _context5.next = 8;
	                          break;
	
	                        case 6:
	                          _context5.prev = 6;
	                          _context5.t0 = _context5['catch'](1);
	
	                        case 8:
	                        case 'end':
	                          return _context5.stop();
	                      }
	                    }
	                  }, _loop, _this3, [[1, 6]]);
	                });
	                _iterator = (0, _getIterator3.default)(handlers);
	
	              case 8:
	                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
	                  _context6.next = 13;
	                  break;
	                }
	
	                return _context6.delegateYield(_loop(), 't0', 10);
	
	              case 10:
	                _iteratorNormalCompletion = true;
	                _context6.next = 8;
	                break;
	
	              case 13:
	                _context6.next = 19;
	                break;
	
	              case 15:
	                _context6.prev = 15;
	                _context6.t1 = _context6['catch'](5);
	                _didIteratorError = true;
	                _iteratorError = _context6.t1;
	
	              case 19:
	                _context6.prev = 19;
	                _context6.prev = 20;
	
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                  _iterator.return();
	                }
	
	              case 22:
	                _context6.prev = 22;
	
	                if (!_didIteratorError) {
	                  _context6.next = 25;
	                  break;
	                }
	
	                throw _iteratorError;
	
	              case 25:
	                return _context6.finish(22);
	
	              case 26:
	                return _context6.finish(19);
	
	              case 27:
	                _context6.next = 29;
	                return this[symbols.platform].logout();
	
	              case 29:
	                return _context6.abrupt('return', _context6.sent);
	
	              case 30:
	              case 'end':
	                return _context6.stop();
	            }
	          }
	        }, _callee5, this, [[5, 15, 19, 27], [20,, 22, 26]]);
	      }));
	
	      function logout() {
	        return ref.apply(this, arguments);
	      }
	
	      return logout;
	    }()
	    /**
	     * @function
	     * @param {Function} handler
	     * @returns {Function}
	     */
	
	  }, {
	    key: 'addBeforeLogoutHandler',
	    value: function addBeforeLogoutHandler(handler) {
	      var _this4 = this;
	
	      this[symbols.beforeLogoutHandlers].add(handler);
	      return function () {
	        _this4[symbols.beforeLogoutHandlers].remove(handler);
	      };
	    }
	    /**
	     * @function
	     * @param {Function} handler
	     */
	
	  }, {
	    key: 'removeBeforeLogoutHandler',
	    value: function removeBeforeLogoutHandler(handler) {
	      this[symbols.beforeLogoutHandlers].remove(handler);
	    }
	  }, {
	    key: 'isLoggedIn',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
	        return _regenerator2.default.wrap(function _callee6$(_context7) {
	          while (1) {
	            switch (_context7.prev = _context7.next) {
	              case 0:
	                _context7.next = 2;
	                return this[symbols.platform].loggedIn();
	
	              case 2:
	                return _context7.abrupt('return', _context7.sent);
	
	              case 3:
	              case 'end':
	                return _context7.stop();
	            }
	          }
	        }, _callee6, this);
	      }));
	
	      function isLoggedIn() {
	        return ref.apply(this, arguments);
	      }
	
	      return isLoggedIn;
	    }()
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _authReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'status',
	    get: function get() {
	      return this.state.status;
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _authEvents.authEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _authEvents.authEventTypes;
	    }
	  }, {
	    key: 'enums',
	    get: function get() {
	      return ENUMS;
	    }
	  }]);
	  return Auth;
	}(_rcModule2.default);
	
	exports.default = Auth;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(171);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(172), __esModule: true };

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(173);
	module.exports = __webpack_require__(8).Array.from;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(9)
	  , $export        = __webpack_require__(6)
	  , toObject       = __webpack_require__(39)
	  , call           = __webpack_require__(109)
	  , isArrayIter    = __webpack_require__(110)
	  , toLength       = __webpack_require__(30)
	  , createProperty = __webpack_require__(174)
	  , getIterFn      = __webpack_require__(69);
	
	$export($export.S + $export.F * !__webpack_require__(175)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(12)
	  , createDesc      = __webpack_require__(20);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(61)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(177);


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(178);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(121)))

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (fn) {
	  return function () {
	    var gen = fn.apply(this, arguments);
	    return new _promise2.default(function (resolve, reject) {
	      function step(key, arg) {
	        try {
	          var info = gen[key](arg);
	          var value = info.value;
	        } catch (error) {
	          reject(error);
	          return;
	        }
	
	        if (info.done) {
	          resolve(value);
	        } else {
	          return _promise2.default.resolve(value).then(function (value) {
	            return step("next", value);
	          }, function (err) {
	            return step("throw", err);
	          });
	        }
	      }
	
	      return step("next");
	    });
	  };
	};

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(181), __esModule: true };

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	__webpack_require__(62);
	__webpack_require__(48);
	__webpack_require__(182);
	module.exports = __webpack_require__(8).Promise;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(54)
	  , global             = __webpack_require__(7)
	  , ctx                = __webpack_require__(9)
	  , classof            = __webpack_require__(65)
	  , $export            = __webpack_require__(6)
	  , isObject           = __webpack_require__(14)
	  , anObject           = __webpack_require__(13)
	  , aFunction          = __webpack_require__(10)
	  , anInstance         = __webpack_require__(107)
	  , forOf              = __webpack_require__(108)
	  , setProto           = __webpack_require__(98).set
	  , speciesConstructor = __webpack_require__(183)
	  , task               = __webpack_require__(184).set
	  , microtask          = __webpack_require__(186)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(61)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(106)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(60)($Promise, PROMISE);
	__webpack_require__(111)(PROMISE);
	Wrapper = __webpack_require__(8)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(175)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(13)
	  , aFunction = __webpack_require__(10)
	  , SPECIES   = __webpack_require__(61)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(9)
	  , invoke             = __webpack_require__(185)
	  , html               = __webpack_require__(59)
	  , cel                = __webpack_require__(18)
	  , global             = __webpack_require__(7)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(27)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 185 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(7)
	  , macrotask = __webpack_require__(184).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(27)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  pending: 'PENDING', // after init, before status from platform is determined
	  notLoggedIn: 'NOT_LOGGED_IN',
	  loggingIn: 'LOGGING_IN',
	  loggedIn: 'LOGGED_IN',
	  loggingOut: 'LOGGING_OUT'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['login', 'loginSuccess', 'loginError', 'logout', 'logoutSuccess', 'logoutError', 'refresh', 'refreshSuccess', 'refreshError', 'init'], 'auth');

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getAuthReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _authActions = __webpack_require__(188);
	
	var _authActions2 = _interopRequireDefault(_authActions);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  status: _loginStatus2.default.pending,
	  authError: null
	};
	
	function getAuthReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_authActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      case actions.init:
	        return (0, _assign2.default)({}, state, { status: action.status });
	
	      case actions.login:
	        return {
	          status: _loginStatus2.default.loggingIn,
	          authError: null
	        };
	
	      case actions.loginSuccess:
	        return {
	          status: _loginStatus2.default.loggedIn,
	          authError: null
	        };
	
	      case actions.logoutSuccess:
	        return {
	          status: _loginStatus2.default.notLoggedIn,
	          authError: null
	        };
	
	      case actions.loginError:
	        return {
	          state: _loginStatus2.default.notLoggedIn,
	          authError: action.error
	        };
	
	      case actions.logoutError:
	        return {
	          status: _loginStatus2.default.loggedIn,
	          authError: action.error
	        };
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.authEventTypes = exports.authEvents = undefined;
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinitions = (0, _extends3.default)({}, _loginStatus2.default);
	
	var authEvents = exports.authEvents = new _enum2.default(eventDefinitions);
	
	var eventTypeDefinitions = {
	  loginStatusChanged: 'LOGIN_STATUS_CHANGED'
	};
	
	var authEventTypes = exports.authEventTypes = new _enum2.default(eventTypeDefinitions);

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.sleep = exports.fetchList = undefined;
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var fetchList = exports.fetchList = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(fn) {
	    var fetchedPages, totalPages, list, data;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            fetchedPages = 0;
	            totalPages = 1;
	            list = [];
	
	          case 3:
	            if (!(fetchedPages < totalPages)) {
	              _context.next = 12;
	              break;
	            }
	
	            fetchedPages++;
	            _context.next = 7;
	            return fn({
	              page: fetchedPages
	            });
	
	          case 7:
	            data = _context.sent;
	
	            totalPages = data.paging.totalPages;
	            list = list.concat(data.records);
	            _context.next = 3;
	            break;
	
	          case 12:
	            return _context.abrupt('return', list);
	
	          case 13:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	  return function fetchList(_x) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @param {String} eventType
	 * @param {String} event
	 * @description Helper function to emit eventTyped events and the event itself
	 */
	
	
	/**
	 * @function
	 * @param {Number} t
	 */
	
	var sleep = exports.sleep = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(t) {
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            return _context2.abrupt('return', new _promise2.default(function (resolve) {
	              setTimeout(resolve, t);
	            }));
	
	          case 1:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function sleep(_x2) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	exports.extractData = extractData;
	exports.emit = emit;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function extractData(model) {
	  if (Array.isArray(model)) {
	    return model.map(function (item) {
	      return extractData(item);
	    });
	  } else if ((typeof model === 'undefined' ? 'undefined' : (0, _typeof3.default)(model)) === 'object') {
	    var data = {};
	    for (var key in model) {
	      if (key[0] !== '_' && model.hasOwnProperty(key)) {
	        data[key] = extractData(model[key]);
	      }
	    }
	    return data;
	  }
	  return model;
	}
	
	function emit(eventType, event) {
	  for (var _len = arguments.length, payloads = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    payloads[_key - 2] = arguments[_key];
	  }
	
	  this.emit.apply(this, [event].concat(payloads));
	  this.emit.apply(this, [eventType, event].concat(payloads));
	}

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _stringify = __webpack_require__(193);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _subscriptionActions = __webpack_require__(195);
	
	var _subscriptionActions2 = _interopRequireDefault(_subscriptionActions);
	
	var _subscriptionReducer = __webpack_require__(196);
	
	var _subscriptionReducer2 = _interopRequireDefault(_subscriptionReducer);
	
	var _subscriptionEvents = __webpack_require__(197);
	
	var _subscriptionStatus = __webpack_require__(198);
	
	var _subscriptionStatus2 = _interopRequireDefault(_subscriptionStatus);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _utils = __webpack_require__(191);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['auth', 'sdk', 'platform', 'subscription', 'filterCache']);
	
	var filterRegex = {
	  message: /message-store$/,
	  presence: /presence(\?detailedTelephonyState=true)?$/,
	  telephony: /presence\?detailedTelephonyState=true$/,
	  line: /presence\/line$/,
	  linePresence: /presence\/line\/presence(\?detailedTelephonyState=true)?$/,
	  lineTelephony: /presence\/line\/presence\?detailedTelephonyState=true$/
	};
	
	/**
	 * @function
	 * @param {Object} message
	 * @description Handles messages delivered by the subscripton
	 */
	function messageHandler(message) {
	  var _this = this;
	
	  // determine which events the message falls under
	  var events = [];
	  if (filterRegex.message.test(message.event)) {
	    events.push('message');
	  } else if (filterRegex.line.test(message.event)) {
	    events.push('line');
	  } else if (filterRegex.linePresence.test(message.event)) {
	    events.push('linePresence');
	    if (filterRegex.lineTelephony.test(message.event)) events.push('lineTelephony');
	  } else if (filterRegex.presence.test(message.event)) {
	    events.push('presence');
	    if (filterRegex.telephony.test(message.event)) events.push('telephony');
	  }
	  // dispatch the message in redux manner
	  this.store.dispatch({
	    type: this.actions.notification,
	    eventTypes: events,
	    payload: message
	  });
	  // emit the messages as events
	  events.forEach(function (event) {
	    _utils.emit.call(_this, _subscriptionEvents.subscriptionEventTypes.notification, _subscriptionEvents.subscriptionEvents[event], message);
	  });
	}
	function init() {
	  var _this2 = this;
	
	  var platform = this[symbols.platform];
	  this[symbols.subscription] = this[symbols.sdk].createSubscription();
	  var ownerId = platform.auth().data().owner_id;
	  var cacheKey = null;
	  if (typeof localStorage !== 'undefined') {
	    cacheKey = this.prefix + '-sub-' + ownerId;
	    var cachedSubscription = localStorage.getItem(cacheKey);
	    if (cachedSubscription) {
	      try {
	        this.base.setSubscription(JSON.parse(cachedSubscription));
	      } catch (e) {
	        /* do nothing */
	      }
	    }
	  }
	
	  this.base.setEventFilters(this.filters);
	
	  this.base.on(this.base.events.notification, function (message) {
	    messageHandler.call(_this2, message);
	  });
	  this.base.on(this.base.events.removeSuccess, function () {
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.notSubscribed,
	      subscription: null
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	  });
	  this.base.on(this.base.events.removeError, function () {
	    // TODO
	  });
	  this.base.on(this.base.events.renewSuccess, function () {
	    if (cacheKey) {
	      localStorage.setItem(cacheKey, (0, _stringify2.default)(_this2.base.subscription()));
	    }
	    var oldStatus = _this2.status;
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.subscribed,
	      subscription: _this2.base.subscription()
	    });
	    if (oldStatus !== _this2.status) {
	      _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	    }
	  });
	  this.base.on(this.base.events.renewError, function (error) {
	    // TODO handle 429
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.notSubscribed,
	      subscription: null
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	    _this2.base.reset().setEventFilters(_this2.filters).register().catch(function (e) {});
	  });
	  this.base.on(this.base.events.subscribeSuccess, function () {
	    if (cacheKey) {
	      localStorage.setItem(cacheKey, (0, _stringify2.default)(_this2.base.subscription()));
	    }
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.subscribed,
	      subscription: _this2.base.subscription()
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	  });
	  this.base.on(this.base.events.subscribeError, function (error) {
	    // TODO
	    // handle 429
	    // handle subscription limit
	  });
	
	  if (this.filters.length) {
	    this.base.register().catch(function () {/* do nothing */});
	  }
	}
	
	var Subscription = function (_RcModule) {
	  (0, _inherits3.default)(Subscription, _RcModule);
	
	  function Subscription(options) {
	    var _this4 = this;
	
	    (0, _classCallCheck3.default)(this, Subscription);
	
	    var _this3 = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Subscription).call(this, (0, _extends3.default)({}, options, {
	      registerStoreHandler: function registerStoreHandler(handler) {
	        options.registerStoreHandler(function (store) {
	          // set store to self first
	          handler(store);
	
	          // update store with cachedFilters
	          _this3.store.dispatch({
	            type: _this3.actions.updateFilters,
	            filters: _this3.filters
	          });
	
	          _this3[symbols.filterCache] = null;
	        });
	      },
	      actions: _subscriptionActions2.default
	    })));
	
	    var auth = options.auth;
	    var platform = options.platform;
	    var sdk = options.sdk;
	
	    _this3[symbols.auth] = auth;
	    _this3[symbols.platform] = platform;
	    _this3[symbols.sdk] = sdk;
	    _this3[symbols.subscription] = null;
	
	    // caches filters before redux store is created
	    _this3[symbols.filterCache] = [];
	
	    auth.on(auth.events.loggedIn, function () {
	      init.call(_this3);
	    });
	
	    auth.on(auth.events.loggedOut, function () {
	      if (_this3.base) {
	        _this3.reset();
	      }
	    });
	
	    // platform.on(platform.events.loginSuccess, () => {
	    //   this::init();
	    // });
	    // platform.on(platform.events.logoutSuccess, async () => {
	    //   if (this.base) {
	    //     await this.reset();
	    //   }
	    //   this[symbols.subscription] = null;
	    // });
	
	    auth.addBeforeLogoutHandler((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	      return _regenerator2.default.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return _this3.reset();
	
	            case 2:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this4);
	    })));
	
	    // (async () => {
	    //   if (await platform.loggedIn()) {
	    //     this::init();
	    //   }
	    // })();
	    return _this3;
	  }
	
	  (0, _createClass3.default)(Subscription, [{
	    key: 'subscribe',
	    value: function subscribe(event) {
	      // TODO normalized error
	      if (!_enum2.default.hasValue.call(_subscriptionEvents.subscriptionEvents, event)) {
	        throw new Error('event is not recognized');
	      }
	
	      if (this.filters.indexOf(event) === -1) {
	        var newFilters = this.filters.slice();
	        newFilters.push(event);
	        if (this.base) {
	          this.base.setEventFilters(newFilters);
	          this.store.dispatch({
	            type: this.actions.updateFilters,
	            filters: newFilters
	          });
	          this.base.register().catch(function () {/* do nothing */});
	        } else {
	          this[symbols.filterCache] = newFilters;
	        }
	      }
	    }
	  }, {
	    key: 'unsubscribe',
	    value: function unsubscribe(event) {
	      // TODO normalized error
	      if (!_enum2.default.hasValue.call(_subscriptionEvents.subscriptionEvents, event)) {
	        throw new Error('event is not recognized');
	      }
	      var idx = this.filters.indexOf(event);
	      if (this.filters.indexOf(event) > -1) {
	        var newFilters = this.filters.slice();
	        newFilters.splice(idx, 1);
	        if (this.base) {
	          this.base.setEventFilters(newFilters);
	          this.store.dispatch({
	            type: this.actions.updateFilters,
	            filters: newFilters
	          });
	          if (newFilters.length) {
	            this.base.register().catch(function () {/* do nothing */});
	          } else {
	            this.base.remove();
	          }
	        } else {
	          this[symbols.filterCache] = newFilters;
	        }
	      }
	    }
	  }, {
	    key: 'reset',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	        var oldStatus;
	        return _regenerator2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.prev = 0;
	
	                if (!this.base) {
	                  _context2.next = 9;
	                  break;
	                }
	
	                if (!(this.status === _subscriptionStatus2.default.subscribed)) {
	                  _context2.next = 7;
	                  break;
	                }
	
	                _context2.next = 5;
	                return this.base.remove();
	
	              case 5:
	                _context2.next = 9;
	                break;
	
	              case 7:
	                _context2.next = 9;
	                return this.base.reset();
	
	              case 9:
	                _context2.next = 13;
	                break;
	
	              case 11:
	                _context2.prev = 11;
	                _context2.t0 = _context2['catch'](0);
	
	              case 13:
	                this[symbols.subscription] = null;
	                oldStatus = this.status;
	
	                this.store.dispatch({
	                  type: this.actions.updateStatus,
	                  status: _subscriptionStatus2.default.notSubscribed,
	                  subscription: null
	                });
	                if (oldStatus !== this.status) {
	                  _utils.emit.call(this, _subscriptionEvents.subscriptionEventTypes.statusChanged, this.status);
	                }
	
	              case 17:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this, [[0, 11]]);
	      }));
	
	      function reset() {
	        return ref.apply(this, arguments);
	      }
	
	      return reset;
	    }()
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _subscriptionReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'status',
	    get: function get() {
	      return this.state.status;
	    }
	  }, {
	    key: 'filters',
	    get: function get() {
	      return this[symbols.filterCache] || this.state.filters;
	    }
	  }, {
	    key: 'base',
	    get: function get() {
	      return this[symbols.subscription];
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _subscriptionEvents.subscriptionEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _subscriptionEvents.subscriptionEventTypes;
	    }
	  }]);
	  return Subscription;
	}(_rcModule2.default);
	
	exports.default = Subscription;

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(194), __esModule: true };

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(8)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['updateFilters', 'notification', 'updateStatus'], 'subscription');

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getSubscriptionReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _subscriptionActions = __webpack_require__(195);
	
	var _subscriptionActions2 = _interopRequireDefault(_subscriptionActions);
	
	var _subscriptionEvents = __webpack_require__(197);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  cacheKey: null,
	  filters: [],
	  status: _subscriptionEvents.subscriptionEvents.pending
	};
	
	function getSubscriptionReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_subscriptionActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	      case actions.updateStatus:
	        return (0, _assign2.default)({}, state, {
	          status: action.status,
	          subscription: actions.subscription
	        });
	
	      case actions.updateFilters:
	        return (0, _assign2.default)({}, state, {
	          filters: action.filters.slice()
	        });
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.subscriptionEventTypes = exports.subscriptionEvents = undefined;
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _subscriptionStatus = __webpack_require__(198);
	
	var _subscriptionStatus2 = _interopRequireDefault(_subscriptionStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinition = (0, _extends3.default)({
	  message: '/restapi/v1.0/account/~/extension/~/message-store',
	  presence: '/restapi/v1.0/account/~/extension/~/presence',
	  telephony: '/restapi/v1.0/account/~/extension/~/presence?detailedTelephonyState=true',
	  line: '/restapi/v1.0/account/~/extension/~/presence/line',
	  linePresence: '/restapi/v1.0/account/~/extension/~/presence/line/presence',
	  lineTelephony: '/restapi/v1.0/account/~/extension/~/presence/line/presence?detailedTelephonyState=true'
	}, _subscriptionStatus2.default);
	
	var subscriptionEvents = exports.subscriptionEvents = new _enum2.default(eventDefinition);
	
	var eventTypeDefinition = {
	  notification: 'NOTIFICATION',
	  statusChanged: 'STATUS_CHANGED'
	};
	
	var subscriptionEventTypes = exports.subscriptionEventTypes = new _enum2.default(eventTypeDefinition);

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  pending: 'PENDING',
	  subscribed: 'SUBSCRIBED',
	  notSubscribed: 'NOT_SUBSCRIBED'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	// const initialState = {
	//   test: true,
	// };
	
	// function getUserSettingsReducer(prefix) {
	//   return (state, action) => {
	//     if (typeof state === 'undefined') return Object.assign({}, initialState);
	//     if (!action) return state;
	//     switch (action.type) {
	//       default:
	//         return state;
	//     }
	//   };
	// }
	
	/**
	 * @function
	 * @param {String} dataType
	 * @param {function} loadFunction - async loader function returning a promise
	 * @return {Promise}
	 * @description Generic data loading logic with events
	 */
	
	var loadData = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(dataType, loadFunction) {
	    var payload;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            this.store.dispatch({
	              type: this.actions['load' + dataType]
	            });
	            this.emit(_userEvents.userEvents['load' + dataType]);
	            _context.prev = 2;
	            _context.next = 5;
	            return loadFunction.call(this);
	
	          case 5:
	            payload = _context.sent;
	
	            this.store.dispatch({
	              type: this.actions['load' + dataType + 'Success'],
	              payload: payload
	            });
	            _utils.emit.call(this, _userEvents.userEventTypes.userInfoChanged, _userEvents.userEvents['load' + dataType + 'Success']);
	            _context.next = 15;
	            break;
	
	          case 10:
	            _context.prev = 10;
	            _context.t0 = _context['catch'](2);
	
	            this.store.dispatch({
	              type: this.actions['load' + dataType + 'Failed']
	            });
	            this.emit(_userEvents.userEvents['load' + dataType + 'Failed']);
	            throw _context.t0;
	
	          case 15:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this, [[2, 10]]);
	  }));
	  return function loadData(_x, _x2) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @return {Promise<Object>}
	 * @description Fetch account info and extract the data
	 */
	
	
	var extractAccountInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return this[symbols.api].account().loadAccount();
	
	          case 2:
	            _context2.t0 = _context2.sent;
	            return _context2.abrupt('return', (0, _utils.extractData)(_context2.t0));
	
	          case 4:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function extractAccountInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadAccountInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	    return _regenerator2.default.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.next = 2;
	            return loadData.call(this, 'AccountInfo', extractAccountInfo);
	
	          case 2:
	            return _context3.abrupt('return', _context3.sent);
	
	          case 3:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	  return function loadAccountInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractExtensionInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	    return _regenerator2.default.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.next = 2;
	            return this[symbols.api].extension().loadExtensionInfo();
	
	          case 2:
	            _context4.t0 = _context4.sent;
	            return _context4.abrupt('return', (0, _utils.extractData)(_context4.t0));
	
	          case 4:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this);
	  }));
	  return function extractExtensionInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadExtensionInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	    return _regenerator2.default.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return loadData.call(this, 'ExtensionInfo', extractExtensionInfo);
	
	          case 2:
	            return _context5.abrupt('return', _context5.sent);
	
	          case 3:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this);
	  }));
	  return function loadExtensionInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractDialingPlans = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
	    var _this = this;
	
	    return _regenerator2.default.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            _context6.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this[symbols.api].account().listDialingPlans(options);
	            });
	
	          case 2:
	            _context6.t0 = _context6.sent;
	            return _context6.abrupt('return', (0, _utils.extractData)(_context6.t0));
	
	          case 4:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this);
	  }));
	  return function extractDialingPlans() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadDialingPlans = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7() {
	    return _regenerator2.default.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            _context7.next = 2;
	            return loadData.call(this, 'DialingPlans', extractDialingPlans);
	
	          case 2:
	            return _context7.abrupt('return', _context7.sent);
	
	          case 3:
	          case 'end':
	            return _context7.stop();
	        }
	      }
	    }, _callee7, this);
	  }));
	  return function loadDialingPlans() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractPhoneNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8() {
	    var _this2 = this;
	
	    return _regenerator2.default.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            _context8.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this2[symbols.api].extension().listExtensionPhoneNumbers(options);
	            });
	
	          case 2:
	            _context8.t0 = _context8.sent;
	            return _context8.abrupt('return', (0, _utils.extractData)(_context8.t0));
	
	          case 4:
	          case 'end':
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this);
	  }));
	  return function extractPhoneNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadPhoneNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9() {
	    return _regenerator2.default.wrap(function _callee9$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            _context9.next = 2;
	            return loadData.call(this, 'PhoneNumbers', extractPhoneNumbers);
	
	          case 2:
	            return _context9.abrupt('return', _context9.sent);
	
	          case 3:
	          case 'end':
	            return _context9.stop();
	        }
	      }
	    }, _callee9, this);
	  }));
	  return function loadPhoneNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractForwardingNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
	    var _this3 = this;
	
	    return _regenerator2.default.wrap(function _callee10$(_context10) {
	      while (1) {
	        switch (_context10.prev = _context10.next) {
	          case 0:
	            _context10.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this3[symbols.api].forwardingNumbers().listExtensionForwardingNumbers(options);
	            });
	
	          case 2:
	            _context10.t0 = _context10.sent;
	            return _context10.abrupt('return', (0, _utils.extractData)(_context10.t0));
	
	          case 4:
	          case 'end':
	            return _context10.stop();
	        }
	      }
	    }, _callee10, this);
	  }));
	  return function extractForwardingNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadForwardingNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11() {
	    return _regenerator2.default.wrap(function _callee11$(_context11) {
	      while (1) {
	        switch (_context11.prev = _context11.next) {
	          case 0:
	            _context11.next = 2;
	            return loadData.call(this, 'ForwardingNumbers', extractForwardingNumbers);
	
	          case 2:
	            return _context11.abrupt('return', _context11.sent);
	
	          case 3:
	          case 'end':
	            return _context11.stop();
	        }
	      }
	    }, _callee11, this);
	  }));
	  return function loadForwardingNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractBlockedNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12() {
	    var _this4 = this;
	
	    return _regenerator2.default.wrap(function _callee12$(_context12) {
	      while (1) {
	        switch (_context12.prev = _context12.next) {
	          case 0:
	            _context12.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this4[symbols.api].blockedNumbers().listBlockedNumbers(options);
	            });
	
	          case 2:
	            _context12.t0 = _context12.sent;
	            return _context12.abrupt('return', (0, _utils.extractData)(_context12.t0));
	
	          case 4:
	          case 'end':
	            return _context12.stop();
	        }
	      }
	    }, _callee12, this);
	  }));
	  return function extractBlockedNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadBlockedNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
	    return _regenerator2.default.wrap(function _callee13$(_context13) {
	      while (1) {
	        switch (_context13.prev = _context13.next) {
	          case 0:
	            _context13.next = 2;
	            return loadData.call(this, 'BlockedNumbers', extractBlockedNumbers);
	
	          case 2:
	            return _context13.abrupt('return', _context13.sent);
	
	          case 3:
	          case 'end':
	            return _context13.stop();
	        }
	      }
	    }, _callee13, this);
	  }));
	  return function loadBlockedNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @return {Promise}
	 */
	
	
	var loadInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14() {
	    return _regenerator2.default.wrap(function _callee14$(_context14) {
	      while (1) {
	        switch (_context14.prev = _context14.next) {
	          case 0:
	            _context14.prev = 0;
	            _context14.next = 3;
	            return _promise2.default.all([loadAccountInfo.call(this), loadExtensionInfo.call(this), loadDialingPlans.call(this), loadPhoneNumbers.call(this), loadForwardingNumbers.call(this), loadBlockedNumbers.call(this)]);
	
	          case 3:
	            _context14.next = 8;
	            break;
	
	          case 5:
	            _context14.prev = 5;
	            _context14.t0 = _context14['catch'](0);
	
	            // TODO send error out
	            console.log(_context14.t0);
	
	          case 8:
	          case 'end':
	            return _context14.stop();
	        }
	      }
	    }, _callee14, this, [[0, 5]]);
	  }));
	  return function loadInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @class User
	 * @extends RcModule
	 * @default
	 * @export
	 */
	
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _utils = __webpack_require__(191);
	
	var _userActions = __webpack_require__(200);
	
	var _userActions2 = _interopRequireDefault(_userActions);
	
	var _userReducer = __webpack_require__(201);
	
	var _userReducer2 = _interopRequireDefault(_userReducer);
	
	var _userEvents = __webpack_require__(202);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['api', 'platform', 'settings']);
	var User = function (_RcModule) {
	  (0, _inherits3.default)(User, _RcModule);
	
	  /**
	   * @function
	   * @param {Object} options
	   */
	
	  function User(options) {
	    var _this6 = this;
	
	    (0, _classCallCheck3.default)(this, User);
	
	    var _this5 = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(User).call(this, (0, _extends3.default)({}, options, {
	      actions: _userActions2.default
	    })));
	
	    var api = options.api;
	    var platform = options.platform;
	    var settings = options.settings;
	
	    _this5[symbols.api] = api;
	    _this5[symbols.platform] = platform;
	    _this5[symbols.settings] = settings;
	
	    // settings.registerReducer('user', getUserSettingsReducer());
	
	    // load info on login
	    platform.on(platform.events.loginSuccess, function () {
	      loadInfo.call(_this5);
	    });
	    // unload info on logout
	    platform.on(platform.events.logoutSuccess, function () {
	      _this5.store.dispatch({
	        type: _this5.actions.clearUserInfo
	      });
	      // this.emit(userEvents.userInfoCleared);
	    });
	
	    // load info if already logged in
	    (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15() {
	      return _regenerator2.default.wrap(function _callee15$(_context15) {
	        while (1) {
	          switch (_context15.prev = _context15.next) {
	            case 0:
	              _context15.next = 2;
	              return platform.loggedIn();
	
	            case 2:
	              if (!_context15.sent) {
	                _context15.next = 5;
	                break;
	              }
	
	              _context15.next = 5;
	              return loadInfo.call(_this5);
	
	            case 5:
	            case 'end':
	              return _context15.stop();
	          }
	        }
	      }, _callee15, _this6);
	    }))();
	
	    /**
	     * TODO:
	     *   1. Dialing Plan Checking
	     */
	    return _this5;
	  }
	
	  (0, _createClass3.default)(User, [{
	    key: 'reducer',
	    get: function get() {
	      return (0, _userReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _userEvents.userEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _userEvents.userEventTypes;
	    }
	  }, {
	    key: 'directNumbers',
	    get: function get() {
	      return this.state.phoneNumbers.filter(function (n) {
	        return n.usageType === 'DirectNumber';
	      });
	    }
	  }, {
	    key: 'mainCompanyNumber',
	    get: function get() {
	      return this.state.phoneNumbers.find(function (n) {
	        return n.usageType === 'MainCompanyNumber';
	      });
	    }
	  }, {
	    key: 'dialingPlans',
	    get: function get() {
	      return this.state.dialingPlans;
	    }
	  }, {
	    key: 'extensionNumber',
	    get: function get() {
	      return this.state.extensionInfo.extensionNumber;
	    }
	  }, {
	    key: 'smsNumbers',
	    get: function get() {
	      return this.state.phoneNumbers.filter(function (n) {
	        return n.features.indexOf('SmsSender') > -1;
	      });
	    }
	  }]);
	  return User;
	}(_rcModule2.default);
	
	exports.default = User;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['clearUserInfo', 'loadAccountInfo', 'loadAccountInfoSuccess', 'loadAccountInfoFailed', 'loadExtensionInfo', 'loadExtensionInfoSuccess', 'loadExtensionInfoFailed', 'loadDialingPlans', 'loadDialingPlansSuccess', 'loadDialingPlansFailed', 'loadPhoneNumbers', 'loadPhoneNumbersSuccess', 'loadPhoneNumbersFailed', 'loadForwardingNumbers', 'loadForwardingNumbersSuccess', 'loadForwardingNumbersFailed', 'loadBlockedNumbers', 'loadBlockedNumbersSuccess', 'loadBlockedNumbersFailed'], 'user');

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getUserReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _userActions = __webpack_require__(200);
	
	var _userActions2 = _interopRequireDefault(_userActions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  accountInfo: null,
	  accountInfoLoading: false,
	  accountInfoError: null,
	
	  extensionInfo: null,
	  extensionInfoLoading: false,
	  extensionInfoError: null,
	
	  dialingPlans: [],
	  dialingPlansLoading: false,
	  dialingPlansError: null,
	
	  phoneNumbers: [],
	  phoneNumbersLoading: false,
	  phoneNumbersError: null,
	
	  forwardingNumbers: [],
	  forwardingNumbersLoading: false,
	  forwardingNumbersError: null,
	
	  blockedNumbers: [],
	  blockedNumbersLoading: false,
	  blockedNumbersError: null
	};
	
	function getUserReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_userActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      // account info
	      case actions.loadAccountInfo:
	        return (0, _assign2.default)({}, state, {
	          accountInfoLoading: true
	        });
	      case actions.loadAccountInfoSuccess:
	        return (0, _assign2.default)({}, state, {
	          accountInfo: action.payload,
	          accountInfoLoading: false,
	          accountInfoError: null
	        });
	      case actions.loadAccountInfoFailed:
	        return (0, _assign2.default)({}, state, {
	          accountInfoLoading: false,
	          accountInfoError: action.error
	        });
	
	      // extension info
	      case actions.loadExtensionInfo:
	        return (0, _assign2.default)({}, state, {
	          extensionInfoLoading: true
	        });
	      case actions.loadExtensionInfoSuccess:
	        return (0, _assign2.default)({}, state, {
	          extensionInfo: action.payload,
	          extensionInfoLoading: false,
	          extensionInfoError: null
	        });
	      case actions.loadExtensionInfoFailed:
	        return (0, _assign2.default)({}, state, {
	          extensionInfoLoading: false,
	          extensionInfoError: action.error
	        });
	
	      // dialing plans
	      case actions.loadDialingPlans:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: true
	        });
	      case actions.loadDialingPlansSuccess:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: false,
	          dialingPlans: action.payload
	        });
	      case action.loadDialingPlansFailed:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: false,
	          dialingPlansError: action.error
	        });
	
	      // phone numbers
	      case actions.loadPhoneNumbers:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: true
	        });
	      case actions.loadPhoneNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: false,
	          phoneNumbers: action.payload
	        });
	      case action.loadPhoneNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: false,
	          phoneNumbersError: action.error
	        });
	
	      // forwarding numbers
	      case actions.loadForwardingNumbers:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: true
	        });
	      case actions.loadForwardingNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: false,
	          forwardingNumbers: action.payload
	        });
	      case action.loadForwardingNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: false,
	          forwardingNumbersError: action.error
	        });
	
	      // blocked numbers
	      case actions.loadBlockedNumbers:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: true
	        });
	      case actions.loadBlockedNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: false,
	          blockedNumbers: action.payload
	        });
	      case action.loadBlockedNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: false,
	          blockedNumbersError: action.error
	        });
	
	      case action.clearUserInfo:
	        return (0, _assign2.default)({}, initialState);
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.userEventTypes = exports.userEvents = undefined;
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinitions = {
	  userInfoLoaded: 'USER_INFO_LOADED',
	  userInfoCleared: 'USER_INFO_CLEARED',
	
	  loadAccountInfo: 'LOAD_ACCOUNT_INFO',
	  loadAccountInfoSuccess: 'LOAD_ACCOUNT_INFO_SUCCESS',
	  loadAccountInfoFailed: 'LOAD_ACCOUNT_INFO_FAILED',
	
	  loadExtensionInfo: 'LOAD_EXTENSION_INFO',
	  loadExtensionInfoSuccess: 'LOAD_EXTENSION_INFO_SUCCESS',
	  loadExtensionInfoFailed: 'LOAD_EXTENSION_INFO_FAILED',
	
	  loadDialingPlans: 'LOAD_DIALING_PLANS',
	  loadDialingPlansSuccess: 'LOAD_DIALING_PLANS_SUCCESS',
	  loadDialingPlansFailed: 'LOAD_DIALING_PLANS_FAILED',
	
	  loadPhoneNumbers: 'LOAD_PHONE_NUMBERS',
	  loadPhoneNumbersSuccess: 'LOAD_PHONE_NUMBERS_SUCCESS',
	  loadPhoneNumbersFailed: 'LOAD_PHONE_NUMBERS_FAILED',
	
	  loadForwardingNumbers: 'LOAD_FORWARDING_NUMBERS',
	  loadForwardingNumbersSuccess: 'LOAD_FORWARDING_NUMBERS_SUCCESS',
	  loadForwardingNumbersFailed: 'LOAD_FORWARDING_NUMBERS_FAILED',
	
	  loadBlockedNumbers: 'LOAD_BLOCKED_NUMBERS',
	  loadBlockedNumbersSuccess: 'LOAD_BLOCKED_NUMBERS_SUCCESS',
	  loadBlockedNumbersFailed: 'LOAD_BLOCKED_NUMBERS_FAILED'
	};
	
	var userEvents = exports.userEvents = new _enum2.default(eventDefinitions);
	
	var eventTypeDefinitions = {
	  userInfoChanged: 'USER_INFO_CHANGED'
	};
	
	var userEventTypes = exports.userEventTypes = new _enum2.default(eventTypeDefinitions);

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var initPhoneInstance = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	    var info;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return this[symbols.platform].post('/client-info/sip-provision', {
	              sipInfo: [{ transport: 'WSS' }]
	            }).then(function (res) {
	              return res.json();
	            });
	
	          case 2:
	            info = _context.sent;
	            return _context.abrupt('return', new _ringcentralWebPhone2.default(info, {
	              logLevel: 0,
	              audioHelper: {
	                enabled: false
	              }
	            }));
	
	          case 4:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	  return function initPhoneInstance() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var record = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            if (flag) {
	              _context2.next = 6;
	              break;
	            }
	
	            _context2.next = 3;
	            return this.currentSession.stopRecord();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.stopRecord
	              }
	            });
	            _context2.next = 9;
	            break;
	
	          case 6:
	            _context2.next = 8;
	            return this.currentSession.startRecord();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.record
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function record(_x) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var mute = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            if (flag) {
	              _context3.next = 6;
	              break;
	            }
	
	            _context3.next = 3;
	            return this.currentSession.unmute();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.unmute
	              }
	            });
	            _context3.next = 9;
	            break;
	
	          case 6:
	            _context3.next = 8;
	            return this.currentSession.mute();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.mute
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	  return function mute(_x3) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var hold = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            if (flag) {
	              _context4.next = 6;
	              break;
	            }
	
	            _context4.next = 3;
	            return this.currentSession.unhold();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.unhold
	              }
	            });
	            _context4.next = 9;
	            break;
	
	          case 6:
	            _context4.next = 8;
	            return this.currentSession.hold();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.hold
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this);
	  }));
	  return function hold(_x5) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var park = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	    return _regenerator2.default.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return this.currentSession.park();
	
	          case 2:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.park
	              }
	            });
	
	          case 3:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this);
	  }));
	  return function park() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var transfer = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(number) {
	    return _regenerator2.default.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            this.checkSession();
	            _context6.next = 3;
	            return this.currentSession.transfer(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.transfer,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this);
	  }));
	  return function transfer(_x7) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var flip = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(number) {
	    return _regenerator2.default.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            this.checkSession();
	            _context7.next = 3;
	            return this.currentSession.flip(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.flip,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context7.stop();
	        }
	      }
	    }, _callee7, this);
	  }));
	  return function flip(_x8) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var dtmf = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(number) {
	    return _regenerator2.default.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            this.checkSession();
	            _context8.next = 3;
	            return this.currentSession.dtmf(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.dtmf,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this);
	  }));
	  return function dtmf(_x9) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var operations = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(name) {
	    var actions,
	        _actions$name,
	        _len,
	        args,
	        _key,
	        _args9 = arguments;
	
	    return _regenerator2.default.wrap(function _callee9$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            actions = { record: record, mute: mute, hold: hold, park: park, transfer: transfer, flip: flip, dtmf: dtmf };
	
	            this.checkSession();
	            _context9.prev = 2;
	
	            for (_len = _args9.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	              args[_key - 1] = _args9[_key];
	            }
	
	            _context9.next = 6;
	            return (_actions$name = actions[name]).call.apply(_actions$name, [this].concat(args));
	
	          case 6:
	            _context9.next = 12;
	            break;
	
	          case 8:
	            _context9.prev = 8;
	            _context9.t0 = _context9['catch'](2);
	
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.error,
	                error: _context9.t0
	              }
	            });
	            // TODO: needed?
	            throw _context9.t0;
	
	          case 12:
	          case 'end':
	            return _context9.stop();
	        }
	      }
	    }, _callee9, this, [[2, 8]]);
	  }));
	  return function operations(_x10, _x11) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _webphoneActions = __webpack_require__(204);
	
	var _webphoneActions2 = _interopRequireDefault(_webphoneActions);
	
	var _callActions = __webpack_require__(205);
	
	var _callActions2 = _interopRequireDefault(_callActions);
	
	var _webphoneReducer = __webpack_require__(206);
	
	var _webphoneReducer2 = _interopRequireDefault(_webphoneReducer);
	
	var _eventEmitter = __webpack_require__(137);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _ringcentralWebPhone = __webpack_require__(210);
	
	var _ringcentralWebPhone2 = _interopRequireDefault(_ringcentralWebPhone);
	
	var _webphoneStatus = __webpack_require__(207);
	
	var _webphoneStatus2 = _interopRequireDefault(_webphoneStatus);
	
	var _callStatus = __webpack_require__(209);
	
	var _callStatus2 = _interopRequireDefault(_callStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['api', 'platform', 'emitter', 'settings', 'phoneInstance']);
	
	var ENUMS = new _enum2.default({
	  webphoneStatus: _webphoneStatus2.default,
	  callStatus: _callStatus2.default
	});
	
	var Webphone = function (_RcModule) {
	  (0, _inherits3.default)(Webphone, _RcModule);
	
	  function Webphone(options) {
	    var _this2 = this;
	
	    (0, _classCallCheck3.default)(this, Webphone);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Webphone).call(this, (0, _extends3.default)({}, options, {
	      actions: _webphoneActions2.default
	    })));
	
	    var api = options.api;
	    var platform = options.platform;
	    var settings = options.settings;
	
	    _this[symbols.api] = api;
	    _this[symbols.platform] = platform;
	    _this[symbols.emitter] = new _eventEmitter2.default();
	    _this[symbols.settings] = settings;
	
	    _this.currentSession = null;
	    _this.isRegistered = false;
	
	    // TODO: commented out until setting module completed
	    // settings.registerReducer('webphone', getWebphoneReducer())
	
	    platform.on(platform.events.loginSuccess, (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
	      return _regenerator2.default.wrap(function _callee10$(_context10) {
	        while (1) {
	          switch (_context10.prev = _context10.next) {
	            case 0:
	              _context10.next = 2;
	              return initPhoneInstance.call(_this);
	
	            case 2:
	              _this[symbols.phoneInstance] = _context10.sent;
	
	              _this[symbols.phoneInstance].userAgent.on('registered', function () {
	                // sip will fire multiple registered events, only dispatch one register action to state.
	                // TODO: is this isRegistered state needed to be store as instance variable
	                //       or just check store state
	                if (!_this.isRegistered) {
	                  _this.store.dispatch({
	                    type: _this.actions.registerSuccess
	                  });
	                }
	                _this.isRegistered = _this[symbols.phoneInstance].userAgent.isRegistered();
	              });
	              _this[symbols.phoneInstance].userAgent.on('unregistered', function () {
	                _this.isRegistered = _this[symbols.phoneInstance].userAgent.isRegistered();
	                _this.store.dispatch({
	                  type: _this.actions.unregister,
	                  operation: {
	                    type: _callActions2.default.clear
	                  }
	                });
	              });
	              _this[symbols.phoneInstance].userAgent.on('registrationFailed', function (error) {
	                _this.store.dispatch({
	                  type: _this.actions.registerError,
	                  error: error
	                });
	              });
	              _this[symbols.phoneInstance].userAgent.on('invite', function (session) {
	                _this.currentSession = session;
	                _this.listenSessionEvents();
	                console.log(session);
	                _this.store.dispatch({
	                  type: _this.actions.callIncoming,
	                  payload: {
	                    remoteIdentity: session.remoteIdentity,
	                    localIdentity: session.localIdentity
	                  }
	                });
	              });
	
	            case 7:
	            case 'end':
	              return _context10.stop();
	          }
	        }
	      }, _callee10, _this2);
	    })));
	    return _this;
	  }
	
	  (0, _createClass3.default)(Webphone, [{
	    key: 'call',
	
	
	    /**
	     * Make a phone call, this method should be called in registerSuccess state
	     * @param {string} toNumber
	     * @param {string} [fromNumber]
	     * @return {Session}
	     */
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11(_ref) {
	        var toNumber = _ref.toNumber;
	        var fromNumber = _ref.fromNumber;
	        var media = _ref.media;
	        return _regenerator2.default.wrap(function _callee11$(_context11) {
	          while (1) {
	            switch (_context11.prev = _context11.next) {
	              case 0:
	                this.store.dispatch({
	                  type: this.actions.call,
	                  payload: {
	                    toNumber: toNumber,
	                    fromNumber: fromNumber
	                  }
	                });
	                this.currentSession = this[symbols.phoneInstance].userAgent.invite(toNumber, {
	                  media: {
	                    render: media
	                  }
	                });
	                this.listenSessionEvents();
	                _context11.prev = 3;
	                _context11.next = 6;
	                return this.currentSession;
	
	              case 6:
	                _context11.next = 11;
	                break;
	
	              case 8:
	                _context11.prev = 8;
	                _context11.t0 = _context11['catch'](3);
	
	                this.store.dispatch({
	                  type: this.actions.callError,
	                  error: _context11.t0
	                });
	
	              case 11:
	                return _context11.abrupt('return', this.currentSession);
	
	              case 12:
	              case 'end':
	                return _context11.stop();
	            }
	          }
	        }, _callee11, this, [[3, 8]]);
	      }));
	
	      function call(_x12) {
	        return ref.apply(this, arguments);
	      }
	
	      return call;
	    }()
	
	    /**
	     * Accept a phone call, this method should be called when call is incoming
	     * @param {Object} media, see https://github.com/ringcentral/ringcentral-web-phone#accepting-incoming-call
	     * @return {Promise}
	     */
	
	  }, {
	    key: 'accept',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12(media) {
	        return _regenerator2.default.wrap(function _callee12$(_context12) {
	          while (1) {
	            switch (_context12.prev = _context12.next) {
	              case 0:
	                this.checkSession();
	                _context12.next = 3;
	                return this.currentSession.accept(media);
	
	              case 3:
	                return _context12.abrupt('return', _context12.sent);
	
	              case 4:
	              case 'end':
	                return _context12.stop();
	            }
	          }
	        }, _callee12, this);
	      }));
	
	      function accept(_x13) {
	        return ref.apply(this, arguments);
	      }
	
	      return accept;
	    }()
	  }, {
	    key: 'bye',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
	        return _regenerator2.default.wrap(function _callee13$(_context13) {
	          while (1) {
	            switch (_context13.prev = _context13.next) {
	              case 0:
	                this.checkSession();
	                _context13.next = 3;
	                return this.currentSession.terminate();
	
	              case 3:
	                return _context13.abrupt('return', _context13.sent);
	
	              case 4:
	              case 'end':
	                return _context13.stop();
	            }
	          }
	        }, _callee13, this);
	      }));
	
	      function bye() {
	        return ref.apply(this, arguments);
	      }
	
	      return bye;
	    }()
	  }, {
	    key: 'record',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14(flag) {
	        return _regenerator2.default.wrap(function _callee14$(_context14) {
	          while (1) {
	            switch (_context14.prev = _context14.next) {
	              case 0:
	                operations.call(this, 'record', flag);
	
	              case 1:
	              case 'end':
	                return _context14.stop();
	            }
	          }
	        }, _callee14, this);
	      }));
	
	      function record(_x14) {
	        return ref.apply(this, arguments);
	      }
	
	      return record;
	    }()
	  }, {
	    key: 'mute',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15(flag) {
	        return _regenerator2.default.wrap(function _callee15$(_context15) {
	          while (1) {
	            switch (_context15.prev = _context15.next) {
	              case 0:
	                operations.call(this, 'mute', flag);
	
	              case 1:
	              case 'end':
	                return _context15.stop();
	            }
	          }
	        }, _callee15, this);
	      }));
	
	      function mute(_x15) {
	        return ref.apply(this, arguments);
	      }
	
	      return mute;
	    }()
	  }, {
	    key: 'hold',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee16(flag) {
	        return _regenerator2.default.wrap(function _callee16$(_context16) {
	          while (1) {
	            switch (_context16.prev = _context16.next) {
	              case 0:
	                operations.call(this, 'hold', flag);
	
	              case 1:
	              case 'end':
	                return _context16.stop();
	            }
	          }
	        }, _callee16, this);
	      }));
	
	      function hold(_x16) {
	        return ref.apply(this, arguments);
	      }
	
	      return hold;
	    }()
	  }, {
	    key: 'park',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee17(flag) {
	        return _regenerator2.default.wrap(function _callee17$(_context17) {
	          while (1) {
	            switch (_context17.prev = _context17.next) {
	              case 0:
	                operations.call(this, 'park', flag);
	
	              case 1:
	              case 'end':
	                return _context17.stop();
	            }
	          }
	        }, _callee17, this);
	      }));
	
	      function park(_x17) {
	        return ref.apply(this, arguments);
	      }
	
	      return park;
	    }()
	  }, {
	    key: 'transfer',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee18(number) {
	        return _regenerator2.default.wrap(function _callee18$(_context18) {
	          while (1) {
	            switch (_context18.prev = _context18.next) {
	              case 0:
	                operations.call(this, 'transfer', number);
	
	              case 1:
	              case 'end':
	                return _context18.stop();
	            }
	          }
	        }, _callee18, this);
	      }));
	
	      function transfer(_x18) {
	        return ref.apply(this, arguments);
	      }
	
	      return transfer;
	    }()
	  }, {
	    key: 'flip',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee19(number) {
	        return _regenerator2.default.wrap(function _callee19$(_context19) {
	          while (1) {
	            switch (_context19.prev = _context19.next) {
	              case 0:
	                operations.call(this, 'flip', number);
	
	              case 1:
	              case 'end':
	                return _context19.stop();
	            }
	          }
	        }, _callee19, this);
	      }));
	
	      function flip(_x19) {
	        return ref.apply(this, arguments);
	      }
	
	      return flip;
	    }()
	  }, {
	    key: 'dtmf',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee20(number) {
	        return _regenerator2.default.wrap(function _callee20$(_context20) {
	          while (1) {
	            switch (_context20.prev = _context20.next) {
	              case 0:
	                operations.call(this, 'dtmf', number);
	
	              case 1:
	              case 'end':
	                return _context20.stop();
	            }
	          }
	        }, _callee20, this);
	      }));
	
	      function dtmf(_x20) {
	        return ref.apply(this, arguments);
	      }
	
	      return dtmf;
	    }()
	  }, {
	    key: 'checkSession',
	    value: function checkSession() {
	      if (!this.currentSession) {
	        this.store.dispatch({
	          // TODO
	          type: this.actions.sessionError
	        });
	        throw Error('No active session');
	      }
	    }
	
	    /**
	     * Internal method for listen session events
	     */
	
	  }, {
	    key: 'listenSessionEvents',
	    value: function listenSessionEvents() {
	      var _this3 = this;
	
	      this.currentSession.on('accepted', function (response, cause) {
	        console.log(response);
	        // accepted event for outbound call will returne a incomingResponse
	        if (response.data) {
	          _this3.store.dispatch({
	            type: _this3.actions.callConnect,
	            payload: {
	              remoteIdentity: response.to,
	              localIdentity: response.from
	            }
	          });
	          // accepted event for inbound call will only contain a row sip data
	        } else {
	          _this3.store.dispatch({
	            type: _this3.actions.callAccept
	          });
	        }
	      });
	      this.currentSession.on('rejected', function (response, cause) {
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd
	        });
	        _this3.currentSession = null;
	      });
	      this.currentSession.on('terminated', function (response, cause) {
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd,
	          error: cause
	        });
	        _this3.currentSession = null;
	      });
	      this.currentSession.on('bye', function (request) {
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd
	        });
	        _this3.currentSession = null;
	      });
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _webphoneReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'enums',
	    get: function get() {
	      return ENUMS;
	    }
	  }]);
	  return Webphone;
	}(_rcModule2.default);
	
	exports.default = Webphone;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['register', 'registerSuccess', 'registerError', 'unregister',
	
	// outbound call
	'call', 'callConnect',
	// inbound call
	'callAccept', 'callIncoming', 'callEnd', 'callError', 'callOperation',
	// no active session
	'sessionError']);

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap([
	// operational error
	'error',
	// unregister, clear operational state
	'clear',
	// operation
	'flip', 'record', 'stopRecord', 'hold', 'unhold', 'mute', 'unmute', 'park', 'transfer', 'forward', 'dtmf']);

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _webphoneActions = __webpack_require__(204);
	
	var _webphoneActions2 = _interopRequireDefault(_webphoneActions);
	
	var _webphoneStatus = __webpack_require__(207);
	
	var _webphoneStatus2 = _interopRequireDefault(_webphoneStatus);
	
	var _callReducer = __webpack_require__(208);
	
	var _callReducer2 = _interopRequireDefault(_callReducer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  status: _webphoneStatus2.default.preRegister,
	  // assign from UI
	  toNumber: '',
	  fromNumber: '',
	  // sip info return from sip server
	  remoteIdentity: null,
	  localIdentity: null,
	  operation: (0, _callReducer2.default)(),
	  error: null
	};
	
	function getReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_webphoneActions2.default, prefix);
	
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      case actions.registerSuccess:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.registerSuccessed
	        });
	      case actions.registerError:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.registerFailed,
	          error: action.error
	        });
	      case actions.unregister:
	        return initialState;
	      case actions.call:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnecting,
	          toNumber: action.payload.toNumber,
	          fromNumber: action.payload.fromNumber
	        });
	      case actions.callIncoming:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callIncoming,
	          remoteIdentity: action.payload.remoteIdentity,
	          localIdentity: action.payload.localIdentity
	        });
	      // TODO: update fromNumber, toNumber
	      case actions.callConnect:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnected,
	          remoteIdentity: action.payload.remoteIdentity,
	          localIdentity: action.payload.localIdentity
	        });
	      case actions.callAccept:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnected
	        });
	      case actions.callEnd:
	        return (0, _assign2.default)({}, initialState, {
	          status: _webphoneStatus2.default.registerSuccessed,
	          operation: (0, _callReducer2.default)()
	        });
	      case actions.callError:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callFailed,
	          error: action.error
	        });
	      case actions.callOperation:
	        return (0, _assign2.default)({}, state, {
	          operation: (0, _callReducer2.default)(state.operation, action.operation)
	        });
	      case actions.sessionError:
	        return (0, _assign2.default)({}, state, {
	          error: action.error
	        });
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  // For registering
	  preRegister: 'PRE_REGISTER',
	  registerSuccessed: 'REGISTER_SUCCESSED',
	  registerFailed: 'REGISTER_FAILED',
	  // For callout and active call
	  callConnecting: 'CALL_CONNECTING',
	  callConnected: 'CALL_CONNECTED',
	  callFailed: 'CALL_FAILED',
	  // For incoming call
	  callIncoming: 'CALL_INCOMING'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = function (state, action) {
	  if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	  if (!action) return state;
	  switch (action.type) {
	
	    case _callActions2.default.error:
	      return (0, _assign2.default)({}, state, {
	        error: action.error
	      });
	    case _callActions2.default.clear:
	      return (0, _assign2.default)({}, initialState);
	    case _callActions2.default.record:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.recording) ? state.status : state.status.concat(_callStatus2.default.recording)
	      });
	    case _callActions2.default.stopRecord:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.recording)
	      });
	    case _callActions2.default.mute:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.muted) ? state.status : state.status.concat(_callStatus2.default.muted)
	      });
	    case _callActions2.default.unmute:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.muted)
	      });
	    case _callActions2.default.hold:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.holding) ? state.status : state.status.concat(_callStatus2.default.holding),
	        disabled: ['park', 'record']
	      });
	    case _callActions2.default.unhold:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.holding),
	        disabled: []
	      });
	    case _callActions2.default.park:
	      // https://en.wikipedia.org/wiki/Call_parking
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.parker) ? state.status : state.status.concat(_callStatus2.default.parker)
	      });
	    case _callActions2.default.transfer:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.transfered) ? state.status : state.status.concat(_callStatus2.default.transfered),
	        transferTaget: action.payload.number
	      });
	    case _callActions2.default.flip:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.flip) ? state.status : state.status.concat(_callStatus2.default.flip),
	        flipTarget: action.payload.number
	      });
	    case _callActions2.default.dtmf:
	      // TODO: clarify park action
	      return (0, _assign2.default)({}, state, {
	        status: state.status.concat(_callStatus2.default.parked),
	        dtmfNumber: action.payload.number
	      });
	
	    default:
	      return state;
	  }
	};
	
	var _callActions = __webpack_require__(205);
	
	var _callActions2 = _interopRequireDefault(_callActions);
	
	var _callStatus = __webpack_require__(209);
	
	var _callStatus2 = _interopRequireDefault(_callStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function contain(arr, ele) {
	  return arr.indexOf(ele) > -1;
	}
	
	function remove(arr, ele) {
	  if (contain(arr, ele)) {
	    arr.splice(arr.indexOf(ele), 1);
	  }
	  return arr;
	}
	
	var initialState = {
	  // operations which is enable
	  status: [],
	  // some operations will disable another, such as 'hold'
	  disabled: [],
	  // some operations have infomation need to be stored
	  transferTaget: null,
	  flipTarget: null,
	  dtmfNumber: null,
	  // operation error
	  error: null
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  flip: 'FLIPED',
	  recording: 'RECORDING',
	  holding: 'HOLDING',
	  muted: 'MUTED',
	  parked: 'PARKED',
	  transfered: 'TRANSFERED',
	  forwarded: 'FOWARDED'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(211)], __WEBPACK_AMD_DEFINE_RESULT__ = function(SIP) {
	            return factory(SIP);
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === 'object') {
	        module.exports = factory(require('sip.js'));
	        module.exports.default = module.exports; //ES6
	    } else {
	        root.RingCentral = root.RingCentral || {};
	        root.RingCentral.WebPhone = factory(root.SIP);
	    }
	}(this, function(SIP) {
	
	    var messages = {
	        park: {reqid: 1, command: 'callpark'},
	        startRecord: {reqid: 2, command: 'startcallrecord'},
	        stopRecord: {reqid: 3, command: 'stopcallrecord'},
	        flip: {reqid: 3, command: 'callflip', target: ''},
	        monitor: {reqid: 4, command: 'monitor'},
	        barge: {reqid: 5, command: 'barge'},
	        whisper: {reqid: 6, command: 'whisper'},
	        takeover: {reqid: 7, command: 'takeover'}
	    };
	
	    var responseTimeout = 10000;
	
	    function uuid() {
	        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
	            return v.toString(16);
	        });
	    }
	
	    function delay(ms) {
	        return new Promise(function(resolve, reject) {
	            setTimeout(resolve, ms);
	        });
	    }
	
	    function extend(dst, src) {
	        src = src || {};
	        dst = dst || {};
	        Object.keys(src).forEach(function(k) {
	            dst[k] = src[k];
	        });
	        return dst;
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @param options
	     * @constructor
	     */
	    function AudioHelper(options) {
	
	        options = options || {};
	
	        this._enabled = !!options.enabled;
	        this._incoming = options.incoming || '../audio/incoming.ogg';
	        this._outgoing = options.outgoing || '../audio/outgoing.ogg';
	        this._audio = {};
	
	    }
	
	    AudioHelper.prototype._playSound = function(url, val, volume) {
	
	        if (!this._enabled) return this;
	
	        if (!this._audio[url]) {
	            if (val) {
	                this._audio[url] = new Audio();
	                this._audio[url].src = url;
	                this._audio[url].loop = true;
	                this._audio[url].volume = volume;
	                this._audio[url].play();
	            }
	        } else {
	            if (val) {
	                this._audio[url].currentTime = 0;
	                this._audio[url].play();
	            } else {
	                this._audio[url].pause();
	            }
	        }
	
	        return this;
	
	    };
	
	    AudioHelper.prototype.playIncoming = function(val) {
	        return this._playSound(this._incoming, val, 0.5);
	    };
	
	    AudioHelper.prototype.playOutgoing = function(val) {
	        return this._playSound(this._outgoing, val, 1);
	    };
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @param {object} regData
	     * @param {object} [options]
	     * @param {string} [options.uuid]
	     * @param {string} [options.appKey]
	     * @param {string} [options.appName]
	     * @param {string} [options.appVersion]
	     * @param {string} [options.audioHelper]
	     * @param {string} [options.onSession] fired each time UserAgent starts working with session
	     * @constructor
	     */
	    function WebPhone(regData, options) {
	
	        regData = regData || {};
	        options = options || {};
	
	        this.sipInfo = regData.sipInfo[0] || regData.sipInfo;
	        this.sipFlags = regData.sipFlags;
	
	        var id = options.uuid || localStorage.getItem('rc-webPhone-uuid') || uuid(); //TODO Make configurable
	        localStorage.setItem('rc-webPhone-uuid', id);
	
	        this.endpointHeader = 'P-rc-endpoint-id: ' + id;
	
	        var configuration = {
	            uri: 'sip:' + this.sipInfo.username + '@' + this.sipInfo.domain,
	            wsServers: this.sipInfo.outboundProxy && this.sipInfo.transport
	                ? this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxy
	                : this.sipInfo.wsServers,
	            authorizationUser: this.sipInfo.authorizationId,
	            password: this.sipInfo.password,
	            traceSip: true,
	            stunServers: this.sipInfo.stunServers || ['stun:74.125.194.127:19302'], //FIXME Hardcoded?
	            turnServers: [],
	            log: {
	                level: options.logLevel || 1 //FIXME LOG LEVEL 3
	            },
	            domain: this.sipInfo.domain,
	            autostart: true,
	            register: true,
	            iceGatheringTimeout: this.sipInfo.iceGatheringTimeout || 3000
	        };
	
	        this.appKey = options.appKey;
	        this.appName = options.appName;
	        this.appVersion = options.appVersion;
	        this.userAgentHeader = 'RC-User-Agent: ' +
	                               (options.appName ? (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' : '') +
	                               'RCWEBPHONE/' + WebPhone.version;
	
	        this.clientIdHeader = 'Client-id:' + options.appKey;
	
	        this.userAgent = new SIP.UA(configuration).register({
	            extraHeaders: [
	                this.endpointHeader,
	                this.userAgentHeader,
	                this.clientIdHeader
	            ]
	        });
	
	        this.userAgent.endpointHeader = this.endpointHeader;
	        this.userAgent.userAgentHeader = this.userAgentHeader;
	        this.userAgent.clientIdHeader = this.clientIdHeader;
	        this.userAgent.sipInfo = this.sipInfo;
	
	        this.userAgent.__invite = this.userAgent.invite;
	        this.userAgent.invite = invite;
	
	        this.userAgent.on('invite', function(session) {
	            this.userAgent.audioHelper.playIncoming(true);
	            patchSession(session);
	        }.bind(this));
	
	        this.userAgent.audioHelper = new AudioHelper(options.audioHelper);
	
	        this.userAgent.onSession = options.onSession || null;
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    WebPhone.version = '0.3.1';
	    WebPhone.uuid = uuid;
	    WebPhone.delay = delay;
	    WebPhone.extend = extend;
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    function patchSession(session) {
	
	        if (session.__patched) return session;
	
	        session.__patched = true;
	
	        session.__sendRequest = session.sendRequest;
	        session.__receiveRequest = session.receiveRequest;
	        session.__receiveInviteResponse = session.receiveInviteResponse;
	        session.__receiveResponse = session.receiveResponse;
	        session.__accept = session.accept;
	        session.__hold = session.hold;
	        session.__unhold = session.unhold;
	        session.__dtmf = session.dtmf;
	
	        session.sendRequest = sendRequest;
	        session.receiveRequest = receiveRequest;
	        session.receiveInviteResponse = receiveInviteResponse;
	        session.receiveResponse = receiveResponse;
	        session.accept = accept;
	        session.hold = hold;
	        session.unhold = unhold;
	        session.dtmf = dtmf;
	
	        session.blindTransfer = blindTransfer;
	        session.transfer = transfer;
	        session.park = park;
	        session.forward = forward;
	        session.startRecord = startRecord;
	        session.stopRecord = stopRecord;
	        session.flip = flip;
	
	        session.on('replaced', patchSession);
	        // session.on('connecting', onConnecting);
	
	        // Audio
	        session.on('accepted', stopPlaying);
	        session.on('rejected', stopPlaying);
	        session.on('bye', stopPlaying);
	        session.on('terminated', stopPlaying);
	        session.on('cancel', stopPlaying);
	        session.on('failed', stopPlaying);
	        session.on('replaced', stopPlaying);
	        session.mediaHandler.on('iceConnectionCompleted', stopPlaying);
	        session.mediaHandler.on('iceConnectionFailed', stopPlaying);
	
	        function stopPlaying() {
	            session.ua.audioHelper.playOutgoing(false);
	            session.ua.audioHelper.playIncoming(false);
	            session.removeListener('accepted', stopPlaying);
	            session.removeListener('rejected', stopPlaying);
	            session.removeListener('bye', stopPlaying);
	            session.removeListener('terminated', stopPlaying);
	            session.removeListener('cancel', stopPlaying);
	            session.removeListener('failed', stopPlaying);
	            session.removeListener('replaced', stopPlaying);
	            session.mediaHandler.removeListener('iceConnectionCompleted', stopPlaying);
	            session.mediaHandler.removeListener('iceConnectionFailed', stopPlaying);
	        }
	
	        if (session.ua.onSession) session.ua.onSession(session);
	
	        return session;
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {object} command
	     * @param {object} [options]
	     * @return {Promise}
	     */
	    function sendReceive(session, command, options) {
	
	        options = options || {};
	
	        extend(command, options);
	
	        var cseq = null;
	
	        return new Promise(function(resolve, reject) {
	
	            session.sendRequest(SIP.C.INFO, {
	                body: JSON.stringify({
	                    request: command
	                }),
	                extraHeaders: [
	                    "Content-Type: application/json;charset=utf-8",
	                    session.ua.userAgentHeader,
	                    session.ua.endpointHeader,
	                    session.ua.clientIdHeader
	                ],
	                receiveResponse: function(response) {
	                    var timeout = null;
	                    if (response.status_code === 200) {
	                        cseq = response.cseq;
	                        var onInfo = function(request) {
	                            if (response.cseq === cseq) {
	
	                                var body = request && request.body || '{}';
	                                var obj;
	
	                                try {
	                                    obj = JSON.parse(body);
	                                } catch (e) {
	                                    obj = {};
	                                }
	
	                                if (obj.response && obj.response.command === command.command) {
	                                    if (obj.response.result) {
	                                        if (obj.response.result.code == 0) {
	                                            return resolve(obj.response.result);
	                                        } else {
	                                            return reject(obj.response.result);
	                                        }
	                                    }
	                                }
	                                timeout && clearTimeout(timeout);
	                                session.removeListener('RC_SIP_INFO', onInfo);
	                                resolve(null); //FIXME What to resolve
	                            }
	                        };
	
	                        timeout = setTimeout(function() {
	                            reject(new Error('Timeout: no reply'));
	                            session.removeListener('RC_SIP_INFO', onInfo);
	                        }, responseTimeout);
	                        session.on('RC_SIP_INFO', onInfo);
	                    }
	                    else {
	                        reject(new Error('The INFO response status code is: ' + response.status_code + ' (waiting for 200)'));
	                    }
	                }
	            });
	
	        });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    function sendRequest(type, config) {
	        if (type == SIP.C.PRACK) {
	            type = SIP.C.ACK;
	        }
	        return this.__sendRequest(type, config);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * Fired each time a provisional (100-199) response is received.
	     * Early media is supported by SIP.js library
	     * But in case it is sent without 100rel support we play it manually
	     * STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported
	     *
	     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1072388
	     * @param {SIP.Session} session
	     * @param response
	     * @param {funciton} cb
	     */
	    function patch100rel(session, response, cb) {
	
	        //Early media is supported by SIP.js library
	        //But in case it is sent without 100rel support we play it manually
	        //STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported
	        if (session.status !== SIP.Session.C.STATUS_EARLY_MEDIA && response.status_code === 183 && typeof(response.body) === 'string' && response.body.indexOf('\n') !== -1) {
	            if (!response.hasHeader('require')) response.setHeader('require', '100rel');
	        }
	
	        return cb.call(session, response);
	
	    }
	
	    /**
	     * @this {SIP.Session}
	     * @param response
	     * @return {*}
	     */
	    function receiveInviteResponse(response) {
	        return patch100rel(this, response, this.__receiveInviteResponse);
	    }
	
	    /**
	     * @this {SIP.Session}
	     * @param response
	     * @return {*}
	     */
	    function receiveResponse(response) {
	        return patch100rel(this, response, this.__receiveResponse);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {boolean} flag
	     * @return {Promise}
	     */
	    function setRecord(session, flag) {
	
	        var message = !!flag
	            ? messages.startRecord
	            : messages.stopRecord;
	
	        if ((session.__onRecord && !flag) || (!session.__onRecord && flag)) {
	            return sendReceive(session, message)
	                .then(function(data) {
	                    session.__onRecord = !!flag;
	                    return data;
	                });
	        }
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {boolean} flag
	     * @return {Promise}
	     */
	    function setHold(session, flag) {
	        return new Promise(function(resolve, reject) {
	
	            var options = {
	                eventHandlers: {
	                    succeeded: resolve,
	                    failed: reject
	                }
	            };
	
	            if (flag) {
	                session.__hold(options);
	            } else {
	                session.__unhold(options);
	            }
	
	        });
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.UA}
	     * @param number
	     * @param options
	     * @return {SIP.Session}
	     */
	    function invite(number, options) {
	
	        var ua = this;
	
	        options = options || {};
	        options.extraHeaders = options.extraHeaders || [];
	
	        options.extraHeaders.push(ua.userAgentHeader);
	        options.extraHeaders.push(ua.endpointHeader);
	        options.extraHeaders.push(ua.clientIdHeader);
	
	        options.extraHeaders.push('P-Asserted-Identity: sip:' + (options.fromNumber || ua.sipInfo.username) + '@' + ua.sipInfo.domain); //FIXME Phone Number
	
	        //FIXME Backend should know it already
	        if (options.homeCountryId) { options.extraHeaders.push('P-rc-country-id: ' + options.homeCountryId); }
	
	        options.media = options.media || {};
	        options.media.constraints = options.media.constraints || {audio: true, video: false};
	
	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};
	
	        ua.audioHelper.playOutgoing(true);
	
	        return patchSession(ua.__invite(number, options));
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param request
	     * @return {*}
	     */
	    function receiveRequest(request) {
	        var session = this;
	        switch (request.method) {
	            case SIP.C.INFO:
	                session.emit('RC_SIP_INFO', request);
	                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case
	                if (session.status === SIP.Session.C.STATUS_CONFIRMED || session.status === SIP.Session.C.STATUS_WAITING_FOR_ACK) {
	                    var contentType = request.getHeader('content-type');
	                    if (contentType.match(/^application\/json/i)) {
	                        request.reply(200);
	                        return session;
	                    }
	                }
	                break;
	            //Refresh invite should not be rejected with 488
	            case SIP.C.INVITE:
	                if (session.status === SIP.Session.C.STATUS_CONFIRMED) {
	                    if (request.call_id && session.dialog && session.dialog.id && request.call_id == session.dialog.id.call_id) {
	                        //TODO: check that SDP did not change
	                        session.logger.log('re-INVITE received');
	                        var localSDP = session.mediaHandler.peerConnection.localDescription.sdp;
	                        request.reply(200, null, ['Contact: ' + session.contact], localSDP, function() {
	                            session.status = SIP.Session.C.STATUS_WAITING_FOR_ACK;
	                            session.setInvite2xxTimer(request, localSDP);
	                            session.setACKTimer();
	                        });
	                        return session;
	                    }
	                    //else will be rejected with 488 by SIP.js
	                }
	                break;
	            //We need to analize NOTIFY messages sometimes, so we fire an event
	            case SIP.C.NOTIFY:
	                session.emit('RC_SIP_NOTIFY', request);
	                break;
	        }
	        return session.__receiveRequest.apply(session, arguments);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {object} options
	     * @return {Promise}
	     */
	    function accept(options) {
	
	        var session = this;
	
	        options = options || {};
	        options.extraHeaders = options.extraHeaders || [];
	
	        options.extraHeaders.push(session.ua.userAgentHeader);
	        options.extraHeaders.push(session.ua.endpointHeader);
	        options.extraHeaders.push(session.ua.clientIdHeader);
	
	        options.media = options.media || {};
	        options.media.constraints = options.media.constraints || {audio: true, video: false};
	
	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};
	
	        return new Promise(function(resolve, reject) {
	
	            function onAnswered() {
	                resolve(session);
	                session.removeListener('failed', onFail);
	            }
	
	            function onFail(e) {
	                reject(e);
	                session.removeListener('accepted', onAnswered);
	            }
	
	            //TODO More events?
	            session.once('accepted', onAnswered);
	            session.once('failed', onFail);
	
	            session.__accept(options);
	
	        });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @param {string} dtmf
	     * @param {number} duration
	     * @return {Promise}
	     */
	    function dtmf(dtmf, duration) {
	        var session = this;
	        duration = parseInt(duration) || 1000;
	        var peer = session.mediaHandler.peerConnection;
	        var stream = session.getLocalStreams()[0];
	        var dtmfSender = peer.createDTMFSender(stream.getAudioTracks()[0]);
	        if (dtmfSender !== undefined && dtmfSender.canInsertDTMF) {
	            return dtmfSender.insertDTMF(dtmf, duration);
	        }
	        throw new Error('Send DTMF failed: ' + (!dtmfSender ? 'no sender' : (!dtmfSender.canInsertDTMF ? 'can\'t insert DTMF' : 'Unknown')));
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @return {Promise}
	     */
	    function hold() {
	        return setHold(this, true);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @return {Promise}
	     */
	    function unhold() {
	        return setHold(this, false);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @param {string} target
	     * @param {object} options
	     * @return {Promise}
	     */
	    function blindTransfer(target, options) {
	
	        options = options || {};
	
	        var session = this;
	        var extraHeaders = options.extraHeaders || [];
	        var originalTarget = target;
	
	        return new Promise(function(resolve, reject) {
	            //Blind Transfer is taken from SIP.js source
	
	            // Check Session Status
	            if (session.status !== SIP.Session.C.STATUS_CONFIRMED) {
	                throw new SIP.Exceptions.InvalidStateError(session.status);
	            }
	
	            // normalizeTarget allows instances of SIP.URI to pass through unaltered,
	            // so try to make one ahead of time
	            try {
	                target = SIP.Grammar.parse(target, 'Refer_To').uri || target;
	            } catch (e) {
	                session.logger.debug(".refer() cannot parse Refer_To from", target);
	                session.logger.debug("...falling through to normalizeTarget()");
	            }
	
	            // Check target validity
	            target = session.ua.normalizeTarget(target);
	            if (!target) {
	                throw new TypeError('Invalid target: ' + originalTarget);
	            }
	
	            extraHeaders.push('Contact: ' + session.contact);
	            extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	            extraHeaders.push('Refer-To: ' + target);
	            extraHeaders.push(session.ua.userAgentHeader);
	            extraHeaders.push(session.ua.endpointHeader);
	            extraHeaders.push(session.ua.clientIdHeader);
	
	            // Send the request
	            session.sendRequest(SIP.C.REFER, {
	                extraHeaders: extraHeaders,
	                body: options.body,
	                receiveResponse: function(response) {
	                    var timeout = null;
	                    if (response.status_code === 202) {
	                        var callId = response.call_id;
	
	                        var onNotify = function(request) {
	                            if (request.call_id === callId) {
	                                var body = request && request.body || '';
	                                switch (true) {
	                                    case /1[0-9]{2}/.test(body):
	                                        request.reply(200);
	                                        break;
	                                    case /2[0-9]{2}/.test(body):
	                                        session.terminate();
	                                        clearTimeout(timeout);
	                                        session.removeListener('RC_SIP_NOTIFY', onNotify);
	                                        resolve();
	                                        break;
	                                    default:
	                                        reject(body);
	                                        break;
	                                }
	                            }
	                        };
	
	                        timeout = setTimeout(function() {
	                            reject(new Error('Timeout: no reply'));
	                            session.removeListener('RC_SIP_NOTIFY', onNotify);
	                        }, responseTimeout);
	                        session.on('RC_SIP_NOTIFY', onNotify);
	                    }
	                    else {
	                        reject(new Error('The response status code is: ' + response.status_code + ' (waiting for 202)'));
	                    }
	                }
	            });
	
	        });
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {string} target
	     * @param {object} options
	     * @return {Promise}
	     */
	    function transfer(target, options) {
	
	        var session = this;
	
	        return (session.isOnHold() ? Promise.resolve(null) : session.hold())
	            .then(function() { return delay(300); })
	            .then(function() {
	                return session.blindTransfer(target, options);
	            });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {string} target
	     * @param {object} acceptOptions
	     * @param {object} [transferOptions]
	     * @return {Promise}
	     */
	    function forward(target, acceptOptions, transferOptions) {
	
	        var interval = null,
	            session = this;
	
	        return session.accept(acceptOptions)
	            .then(function() {
	
	                return new Promise(function(resolve, reject) {
	                    interval = setInterval(function() {
	                        if (session.status === 12) {
	                            clearInterval(interval);
	                            session.mute();
	                            setTimeout(function() {
	                                resolve(session.transfer(target, transferOptions));
	                            }, 700);
	                        }
	                    }, 50);
	                });
	
	            });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function startRecord() {
	        return setRecord(this, true);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function stopRecord() {
	        return setRecord(this, false);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param target
	     * @return {Promise}
	     */
	    function flip(target) {
	        return sendReceive(this, messages.flip, {target: target});
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function park() {
	        return sendReceive(this, messages.park);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    return WebPhone;
	
	}));

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = __webpack_require__(212)(__webpack_require__(245));


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name SIP
	 * @namespace
	 */
	"use strict";
	
	module.exports = function (environment) {
	
	var pkg = __webpack_require__(213);
	
	var SIP = Object.defineProperties({}, {
	  version: {
	    get: function(){ return pkg.version; }
	  },
	  name: {
	    get: function(){ return pkg.title; }
	  }
	});
	
	__webpack_require__(214)(SIP, environment);
	SIP.LoggerFactory = __webpack_require__(215)(environment.console);
	SIP.EventEmitter = __webpack_require__(216)(environment.console);
	SIP.C = __webpack_require__(218)(SIP.name, SIP.version);
	SIP.Exceptions = __webpack_require__(219);
	SIP.Timers = __webpack_require__(220)(environment.timers);
	SIP.Transport = environment.Transport(SIP, environment.WebSocket);
	__webpack_require__(221)(SIP);
	__webpack_require__(222)(SIP);
	__webpack_require__(223)(SIP);
	__webpack_require__(224)(SIP);
	__webpack_require__(225)(SIP);
	__webpack_require__(226)(SIP);
	__webpack_require__(228)(SIP);
	__webpack_require__(229)(SIP);
	SIP.MediaHandler = __webpack_require__(230)(SIP.EventEmitter);
	__webpack_require__(231)(SIP);
	__webpack_require__(232)(SIP);
	__webpack_require__(233)(SIP, environment);
	__webpack_require__(235)(SIP);
	SIP.WebRTC = __webpack_require__(236)(SIP, environment);
	__webpack_require__(239)(SIP, environment);
	SIP.Hacks = __webpack_require__(240)(SIP);
	__webpack_require__(241)(SIP);
	SIP.DigestAuthentication = __webpack_require__(242)(SIP.Utils);
	SIP.Grammar = __webpack_require__(243)(SIP);
	
	return SIP;
	};


/***/ },
/* 213 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				"sip.js@0.7.5",
				"/Users/howard.zhang/Sites/ringcentral-js-integration-commons/node_modules/ringcentral-web-phone"
			]
		],
		"_from": "sip.js@0.7.5",
		"_id": "sip.js@0.7.5",
		"_inCache": true,
		"_installable": true,
		"_location": "/sip.js",
		"_nodeVersion": "4.4.3",
		"_npmOperationalInternal": {
			"host": "packages-12-west.internal.npmjs.com",
			"tmp": "tmp/sip.js-0.7.5.tgz_1461594418690_0.5839933124370873"
		},
		"_npmUser": {
			"email": "1212jtraceur@gmail.com",
			"name": "josephfrazier"
		},
		"_npmVersion": "2.15.1",
		"_phantomChildren": {},
		"_requested": {
			"name": "sip.js",
			"raw": "sip.js@0.7.5",
			"rawSpec": "0.7.5",
			"scope": null,
			"spec": "0.7.5",
			"type": "version"
		},
		"_requiredBy": [
			"/ringcentral-web-phone"
		],
		"_resolved": "https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz",
		"_shasum": "86ace7051594f91b4551bdb8120a16c44962d3a2",
		"_shrinkwrap": null,
		"_spec": "sip.js@0.7.5",
		"_where": "/Users/howard.zhang/Sites/ringcentral-js-integration-commons/node_modules/ringcentral-web-phone",
		"author": {
			"email": "developer@onsip.com",
			"name": "OnSIP",
			"url": "http://sipjs.com/authors/"
		},
		"browser": {
			"./src/environment.js": "./src/environment_browser.js"
		},
		"bugs": {
			"url": "https://github.com/onsip/SIP.js/issues"
		},
		"contributors": [
			{
				"url": "https://github.com/onsip/SIP.js/blob/master/THANKS.md"
			}
		],
		"dependencies": {
			"promiscuous": "^0.6.0",
			"ws": "^0.6.4"
		},
		"description": "A simple, intuitive, and powerful JavaScript signaling library",
		"devDependencies": {
			"beefy": "^2.1.5",
			"browserify": "^4.1.8",
			"grunt": "~0.4.0",
			"grunt-browserify": "^4.0.1",
			"grunt-cli": "~0.1.6",
			"grunt-contrib-copy": "^0.5.0",
			"grunt-contrib-jasmine": "^0.9.2",
			"grunt-contrib-jshint": ">0.5.0",
			"grunt-contrib-uglify": "~0.2.0",
			"grunt-peg": "~1.3.1",
			"grunt-trimtrailingspaces": "^0.4.0",
			"pegjs": "^0.8.0"
		},
		"directories": {},
		"dist": {
			"shasum": "86ace7051594f91b4551bdb8120a16c44962d3a2",
			"tarball": "https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz"
		},
		"engines": {
			"node": ">=0.8"
		},
		"gitHead": "bae44bd0359f4d70ded309a32361f04a04e78d6e",
		"homepage": "http://sipjs.com",
		"keywords": [
			"sip",
			"websocket",
			"webrtc",
			"library",
			"javascript"
		],
		"license": "MIT",
		"main": "src/index.js",
		"maintainers": [
			{
				"email": "eric.green@onsip.com",
				"name": "egreen_onsip"
			},
			{
				"email": "james@onsip.com",
				"name": "james-criscuolo"
			},
			{
				"email": "1212jtraceur@gmail.com",
				"name": "josephfrazier"
			}
		],
		"name": "sip.js",
		"optionalDependencies": {
			"promiscuous": "^0.6.0"
		},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/onsip/SIP.js.git"
		},
		"scripts": {
			"build": "grunt build",
			"prepublish": "cd src/Grammar && mkdir -p dist && pegjs --extra-options-file peg.json src/Grammar.pegjs dist/Grammar.js",
			"repl": "beefy test/repl.js --open",
			"test": "grunt travis --verbose"
		},
		"title": "SIP.js",
		"version": "0.7.5"
	};

/***/ },
/* 214 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Utils
	 */
	
	module.exports = function (SIP, environment) {
	var Utils;
	
	Utils= {
	
	  Promise: environment.Promise,
	
	  defer: function defer () {
	    var deferred = {};
	    deferred.promise = new Utils.Promise(function (resolve, reject) {
	      deferred.resolve = resolve;
	      deferred.reject = reject;
	    });
	    return deferred;
	  },
	
	  promisify: function promisify (object, methodName, callbacksFirst) {
	    var oldMethod = object[methodName];
	    return function promisifiedMethod (arg, onSuccess, onFailure) {
	      return new Utils.Promise(function (resolve, reject) {
	        var oldArgs = [arg, resolve, reject];
	        if (callbacksFirst) {
	          oldArgs = [resolve, reject, arg];
	        }
	        oldMethod.apply(object, oldArgs);
	      }).then(onSuccess, onFailure);
	    };
	  },
	
	  augment: function (object, constructor, args, override) {
	    var idx, proto;
	
	    // Add public properties from constructor's prototype onto object
	    proto = constructor.prototype;
	    for (idx in proto) {
	      if (override || object[idx] === undefined) {
	        object[idx] = proto[idx];
	      }
	    }
	
	    // Construct the object as though it were just created by constructor
	    constructor.apply(object, args);
	  },
	
	  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {
	    if (isDeprecated && options[loser]) {
	      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');
	    }
	
	    if (options[winner] && options[loser]) {
	      logger.warn(winner + ' overriding ' + loser);
	    }
	
	    options[winner] = options[winner] || options[loser] || defaultValue;
	  },
	
	  str_utf8_length: function(string) {
	    return encodeURIComponent(string).replace(/%[A-F\d]{2}/g, 'U').length;
	  },
	
	  generateFakeSDP: function(body) {
	    if (!body) {
	      return;
	    }
	
	    var start = body.indexOf('o=');
	    var end = body.indexOf('\r\n', start);
	
	    return 'v=0\r\n' + body.slice(start, end) + '\r\ns=-\r\nt=0 0\r\nc=IN IP4 0.0.0.0';
	  },
	
	  isFunction: function(fn) {
	    if (fn !== undefined) {
	      return Object.prototype.toString.call(fn) === '[object Function]';
	    } else {
	      return false;
	    }
	  },
	
	  isDecimal: function (num) {
	    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));
	  },
	
	  createRandomToken: function(size, base) {
	    var i, r,
	      token = '';
	
	    base = base || 32;
	
	    for( i=0; i < size; i++ ) {
	      r = Math.random() * base|0;
	      token += r.toString(base);
	    }
	
	    return token;
	  },
	
	  newTag: function() {
	    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);
	  },
	
	  // http://stackoverflow.com/users/109538/broofa
	  newUUID: function() {
	    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
	      return v.toString(16);
	    });
	
	    return UUID;
	  },
	
	  hostType: function(host) {
	    if (!host) {
	      return;
	    } else {
	      host = SIP.Grammar.parse(host,'host');
	      if (host !== -1) {
	        return host.host_type;
	      }
	    }
	  },
	
	  /**
	  * Normalize SIP URI.
	  * NOTE: It does not allow a SIP URI without username.
	  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
	  * Detects the domain part (if given) and properly hex-escapes the user portion.
	  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
	  * @private
	  * @param {String} target
	  * @param {String} [domain]
	  */
	  normalizeTarget: function(target, domain) {
	    var uri, target_array, target_user, target_domain;
	
	    // If no target is given then raise an error.
	    if (!target) {
	      return;
	    // If a SIP.URI instance is given then return it.
	    } else if (target instanceof SIP.URI) {
	      return target;
	
	    // If a string is given split it by '@':
	    // - Last fragment is the desired domain.
	    // - Otherwise append the given domain argument.
	    } else if (typeof target === 'string') {
	      target_array = target.split('@');
	
	      switch(target_array.length) {
	        case 1:
	          if (!domain) {
	            return;
	          }
	          target_user = target;
	          target_domain = domain;
	          break;
	        case 2:
	          target_user = target_array[0];
	          target_domain = target_array[1];
	          break;
	        default:
	          target_user = target_array.slice(0, target_array.length-1).join('@');
	          target_domain = target_array[target_array.length-1];
	      }
	
	      // Remove the URI scheme (if present).
	      target_user = target_user.replace(/^(sips?|tel):/i, '');
	
	      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
	      if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(target_user)) {
	        target_user = target_user.replace(/[\-\.\(\)]/g, '');
	      }
	
	      // Build the complete SIP URI.
	      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;
	
	      // Finally parse the resulting URI.
	      if (uri = SIP.URI.parse(target)) {
	        return uri;
	      } else {
	        return;
	      }
	    } else {
	      return;
	    }
	  },
	
	  /**
	  * Hex-escape a SIP URI user.
	  * @private
	  * @param {String} user
	  */
	  escapeUser: function(user) {
	    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
	    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');
	  },
	
	  headerize: function(string) {
	    var exceptions = {
	      'Call-Id': 'Call-ID',
	      'Cseq': 'CSeq',
	      'Min-Se': 'Min-SE',
	      'Rack': 'RAck',
	      'Rseq': 'RSeq',
	      'Www-Authenticate': 'WWW-Authenticate'
	      },
	      name = string.toLowerCase().replace(/_/g,'-').split('-'),
	      hname = '',
	      parts = name.length, part;
	
	    for (part = 0; part < parts; part++) {
	      if (part !== 0) {
	        hname +='-';
	      }
	      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);
	    }
	    if (exceptions[hname]) {
	      hname = exceptions[hname];
	    }
	    return hname;
	  },
	
	  sipErrorCause: function(status_code) {
	    var cause;
	
	    for (cause in SIP.C.SIP_ERROR_CAUSES) {
	      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {
	        return SIP.C.causes[cause];
	      }
	    }
	
	    return SIP.C.causes.SIP_FAILURE_CODE;
	  },
	
	  getReasonPhrase: function getReasonPhrase (code, specific) {
	    return specific || SIP.C.REASON_PHRASE[code] || '';
	  },
	
	  getReasonHeaderValue: function getReasonHeaderValue (code, reason) {
	    reason = SIP.Utils.getReasonPhrase(code, reason);
	    return 'SIP ;cause=' + code + ' ;text="' + reason + '"';
	  },
	
	  getCancelReason: function getCancelReason (code, reason) {
	    if (code && code < 200 || code > 699) {
	      throw new TypeError('Invalid status_code: ' + code);
	    } else if (code) {
	      return SIP.Utils.getReasonHeaderValue(code, reason);
	    }
	  },
	
	  buildStatusLine: function buildStatusLine (code, reason) {
	    code = code || null;
	    reason = reason || null;
	
	    // Validate code and reason values
	    if (!code || (code < 100 || code > 699)) {
	      throw new TypeError('Invalid status_code: '+ code);
	    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
	      throw new TypeError('Invalid reason_phrase: '+ reason);
	    }
	
	    reason = Utils.getReasonPhrase(code, reason);
	
	    return 'SIP/2.0 ' + code + ' ' + reason + '\r\n';
	  },
	
	  /**
	  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)
	  * @private
	  */
	  getRandomTestNetIP: function() {
	    function getOctet(from,to) {
	      return Math.floor(Math.random()*(to-from+1)+from);
	    }
	    return '192.0.2.' + getOctet(1, 254);
	  },
	
	  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info
	  calculateMD5: function(string) {
	    function RotateLeft(lValue, iShiftBits) {
	      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
	    }
	
	    function AddUnsigned(lX,lY) {
	      var lX4,lY4,lX8,lY8,lResult;
	      lX8 = (lX & 0x80000000);
	      lY8 = (lY & 0x80000000);
	      lX4 = (lX & 0x40000000);
	      lY4 = (lY & 0x40000000);
	      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
	      if (lX4 & lY4) {
	        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
	      }
	      if (lX4 | lY4) {
	        if (lResult & 0x40000000) {
	          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
	        } else {
	          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
	        }
	      } else {
	        return (lResult ^ lX8 ^ lY8);
	      }
	    }
	
	    function F(x,y,z) {
	      return (x & y) | ((~x) & z);
	    }
	
	    function G(x,y,z) {
	      return (x & z) | (y & (~z));
	    }
	
	    function H(x,y,z) {
	      return (x ^ y ^ z);
	    }
	
	    function I(x,y,z) {
	      return (y ^ (x | (~z)));
	    }
	
	    function FF(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function GG(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function HH(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function II(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function ConvertToWordArray(string) {
	      var lWordCount;
	      var lMessageLength = string.length;
	      var lNumberOfWords_temp1=lMessageLength + 8;
	      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
	      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
	      var lWordArray=Array(lNumberOfWords-1);
	      var lBytePosition = 0;
	      var lByteCount = 0;
	      while ( lByteCount < lMessageLength ) {
	        lWordCount = (lByteCount-(lByteCount % 4))/4;
	        lBytePosition = (lByteCount % 4)*8;
	        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
	        lByteCount++;
	      }
	      lWordCount = (lByteCount-(lByteCount % 4))/4;
	      lBytePosition = (lByteCount % 4)*8;
	      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
	      lWordArray[lNumberOfWords-2] = lMessageLength<<3;
	      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
	      return lWordArray;
	    }
	
	    function WordToHex(lValue) {
	      var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
	      for (lCount = 0;lCount<=3;lCount++) {
	        lByte = (lValue>>>(lCount*8)) & 255;
	        WordToHexValue_temp = "0" + lByte.toString(16);
	        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
	      }
	      return WordToHexValue;
	    }
	
	    function Utf8Encode(string) {
	      string = string.replace(/\r\n/g,"\n");
	      var utftext = "";
	
	      for (var n = 0; n < string.length; n++) {
	        var c = string.charCodeAt(n);
	
	        if (c < 128) {
	          utftext += String.fromCharCode(c);
	        }
	        else if((c > 127) && (c < 2048)) {
	          utftext += String.fromCharCode((c >> 6) | 192);
	          utftext += String.fromCharCode((c & 63) | 128);
	        }
	        else {
	          utftext += String.fromCharCode((c >> 12) | 224);
	          utftext += String.fromCharCode(((c >> 6) & 63) | 128);
	          utftext += String.fromCharCode((c & 63) | 128);
	        }
	      }
	      return utftext;
	    }
	
	    var x=[];
	    var k,AA,BB,CC,DD,a,b,c,d;
	    var S11=7, S12=12, S13=17, S14=22;
	    var S21=5, S22=9 , S23=14, S24=20;
	    var S31=4, S32=11, S33=16, S34=23;
	    var S41=6, S42=10, S43=15, S44=21;
	
	    string = Utf8Encode(string);
	
	    x = ConvertToWordArray(string);
	
	    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;
	
	    for (k=0;k<x.length;k+=16) {
	      AA=a; BB=b; CC=c; DD=d;
	      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);
	      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
	      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
	      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
	      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
	      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
	      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
	      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
	      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
	      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
	      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
	      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
	      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
	      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
	      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
	      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
	      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
	      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
	      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
	      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);
	      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
	      d=GG(d,a,b,c,x[k+10],S22,0x2441453);
	      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
	      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
	      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
	      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
	      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
	      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
	      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
	      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
	      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
	      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
	      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
	      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
	      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
	      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
	      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
	      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
	      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
	      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
	      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
	      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);
	      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
	      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
	      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
	      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
	      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
	      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
	      a=II(a,b,c,d,x[k+0], S41,0xF4292244);
	      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
	      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
	      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
	      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
	      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
	      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
	      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
	      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
	      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
	      c=II(c,d,a,b,x[k+6], S43,0xA3014314);
	      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
	      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
	      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
	      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
	      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
	      a=AddUnsigned(a,AA);
	      b=AddUnsigned(b,BB);
	      c=AddUnsigned(c,CC);
	      d=AddUnsigned(d,DD);
	    }
	
	    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);
	
	    return temp.toLowerCase();
	  }
	};
	
	SIP.Utils = Utils;
	};


/***/ },
/* 215 */
/***/ function(module, exports) {

	"use strict";
	var levels = {
	  'error': 0,
	  'warn': 1,
	  'log': 2,
	  'debug': 3
	};
	
	module.exports = function (console) {
	
	var LoggerFactory = function () {
	  var logger,
	    level = 2,
	    builtinEnabled = true,
	    connector = null;
	
	    this.loggers = {};
	
	    logger = this.getLogger('sip.loggerfactory');
	
	
	  Object.defineProperties(this, {
	    builtinEnabled: {
	      get: function(){ return builtinEnabled; },
	      set: function(value){
	        if (typeof value === 'boolean') {
	          builtinEnabled = value;
	        } else {
	          logger.error('invalid "builtinEnabled" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    },
	
	    level: {
	      get: function() {return level; },
	      set: function(value) {
	        if (value >= 0 && value <=3) {
	          level = value;
	        } else if (value > 3) {
	          level = 3;
	        } else if (levels.hasOwnProperty(value)) {
	          level = levels[value];
	        } else {
	          logger.error('invalid "level" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    },
	
	    connector: {
	      get: function() {return connector; },
	      set: function(value){
	        if(value === null || value === "" || value === undefined) {
	          connector = null;
	        } else if (typeof value === 'function') {
	          connector = value;
	        } else {
	          logger.error('invalid "connector" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    }
	  });
	};
	
	LoggerFactory.prototype.print = function(target, category, label, content) {
	  if (typeof content === 'string') {
	    var prefix = [new Date(), category];
	    if (label) {
	      prefix.push(label);
	    }
	    content = prefix.concat(content).join(' | ');
	  }
	  target.call(console, content);
	};
	
	function Logger (logger, category, label) {
	  this.logger = logger;
	  this.category = category;
	  this.label = label;
	}
	
	Object.keys(levels).forEach(function (targetName) {
	  Logger.prototype[targetName] = function (content) {
	    this.logger[targetName](this.category, this.label, content);
	  };
	
	  LoggerFactory.prototype[targetName] = function (category, label, content) {
	    if (this.level >= levels[targetName]) {
	      if (this.builtinEnabled) {
	        this.print(console[targetName], category, label, content);
	      }
	
	      if (this.connector) {
	        this.connector(targetName, category, label, content);
	      }
	    }
	  };
	});
	
	LoggerFactory.prototype.getLogger = function(category, label) {
	  var logger;
	
	  if (label && this.level === 3) {
	    return new Logger(this, category, label);
	  } else if (this.loggers[category]) {
	    return this.loggers[category];
	  } else {
	    logger = new Logger(this, category);
	    this.loggers[category] = logger;
	    return logger;
	  }
	};
	
	return LoggerFactory;
	};


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var NodeEventEmitter = __webpack_require__(217).EventEmitter;
	
	module.exports = function (console) {
	
	// Don't use `new SIP.EventEmitter()` for inheriting.
	// Use Object.create(SIP.EventEmitter.prototoype);
	function EventEmitter () {
	  NodeEventEmitter.call(this);
	}
	
	EventEmitter.prototype = Object.create(NodeEventEmitter.prototype, {
	  constructor: {
	    value: EventEmitter,
	    enumerable: false,
	    writable: true,
	    configurable: true
	  }
	});
	
	EventEmitter.prototype.off = function off (eventName, listener) {
	  var warning = '';
	  warning += 'SIP.EventEmitter#off is deprecated and may be removed in future SIP.js versions.\n';
	  warning += 'Please use removeListener or removeAllListeners instead.\n';
	  warning += 'See here for more details:\n';
	  warning += 'http://nodejs.org/api/events.html#events_emitter_removelistener_event_listener';
	  console.warn(warning);
	
	  if (arguments.length < 2) {
	    return this.removeAllListeners.apply(this, arguments);
	  } else {
	    return this.removeListener(eventName, listener);
	  }
	};
	
	return EventEmitter;
	
	};


/***/ },
/* 217 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 218 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Constants
	 */
	
	/**
	 * SIP Constants.
	 * @augments SIP
	 */
	
	module.exports = function (name, version) {
	return {
	  USER_AGENT: name +'/'+ version,
	
	  // SIP scheme
	  SIP:  'sip',
	  SIPS: 'sips',
	
	  // End and Failure causes
	  causes: {
	    // Generic error causes
	    CONNECTION_ERROR:         'Connection Error',
	    REQUEST_TIMEOUT:          'Request Timeout',
	    SIP_FAILURE_CODE:         'SIP Failure Code',
	    INTERNAL_ERROR:           'Internal Error',
	
	    // SIP error causes
	    BUSY:                     'Busy',
	    REJECTED:                 'Rejected',
	    REDIRECTED:               'Redirected',
	    UNAVAILABLE:              'Unavailable',
	    NOT_FOUND:                'Not Found',
	    ADDRESS_INCOMPLETE:       'Address Incomplete',
	    INCOMPATIBLE_SDP:         'Incompatible SDP',
	    AUTHENTICATION_ERROR:     'Authentication Error',
	    DIALOG_ERROR:             'Dialog Error',
	
	    // Session error causes
	    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',
	    WEBRTC_ERROR:             'WebRTC Error',
	    CANCELED:                 'Canceled',
	    NO_ANSWER:                'No Answer',
	    EXPIRES:                  'Expires',
	    NO_ACK:                   'No ACK',
	    NO_PRACK:                 'No PRACK',
	    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
	    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',
	    RTP_TIMEOUT:              'RTP Timeout'
	  },
	
	  supported: {
	    UNSUPPORTED:        'none',
	    SUPPORTED:          'supported',
	    REQUIRED:           'required'
	  },
	
	  SIP_ERROR_CAUSES: {
	    REDIRECTED: [300,301,302,305,380],
	    BUSY: [486,600],
	    REJECTED: [403,603],
	    NOT_FOUND: [404,604],
	    UNAVAILABLE: [480,410,408,430],
	    ADDRESS_INCOMPLETE: [484],
	    INCOMPATIBLE_SDP: [488,606],
	    AUTHENTICATION_ERROR:[401,407]
	  },
	
	  // SIP Methods
	  ACK:        'ACK',
	  BYE:        'BYE',
	  CANCEL:     'CANCEL',
	  INFO:       'INFO',
	  INVITE:     'INVITE',
	  MESSAGE:    'MESSAGE',
	  NOTIFY:     'NOTIFY',
	  OPTIONS:    'OPTIONS',
	  REGISTER:   'REGISTER',
	  UPDATE:     'UPDATE',
	  SUBSCRIBE:  'SUBSCRIBE',
	  REFER:      'REFER',
	  PRACK:      'PRACK',
	
	  /* SIP Response Reasons
	   * DOC: http://www.iana.org/assignments/sip-parameters
	   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
	   */
	  REASON_PHRASE: {
	    100: 'Trying',
	    180: 'Ringing',
	    181: 'Call Is Being Forwarded',
	    182: 'Queued',
	    183: 'Session Progress',
	    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199
	    200: 'OK',
	    202: 'Accepted',  // RFC 3265
	    204: 'No Notification',  //RFC 5839
	    300: 'Multiple Choices',
	    301: 'Moved Permanently',
	    302: 'Moved Temporarily',
	    305: 'Use Proxy',
	    380: 'Alternative Service',
	    400: 'Bad Request',
	    401: 'Unauthorized',
	    402: 'Payment Required',
	    403: 'Forbidden',
	    404: 'Not Found',
	    405: 'Method Not Allowed',
	    406: 'Not Acceptable',
	    407: 'Proxy Authentication Required',
	    408: 'Request Timeout',
	    410: 'Gone',
	    412: 'Conditional Request Failed',  // RFC 3903
	    413: 'Request Entity Too Large',
	    414: 'Request-URI Too Long',
	    415: 'Unsupported Media Type',
	    416: 'Unsupported URI Scheme',
	    417: 'Unknown Resource-Priority',  // RFC 4412
	    420: 'Bad Extension',
	    421: 'Extension Required',
	    422: 'Session Interval Too Small',  // RFC 4028
	    423: 'Interval Too Brief',
	    428: 'Use Identity Header',  // RFC 4474
	    429: 'Provide Referrer Identity',  // RFC 3892
	    430: 'Flow Failed',  // RFC 5626
	    433: 'Anonymity Disallowed',  // RFC 5079
	    436: 'Bad Identity-Info',  // RFC 4474
	    437: 'Unsupported Certificate',  // RFC 4744
	    438: 'Invalid Identity Header',  // RFC 4744
	    439: 'First Hop Lacks Outbound Support',  // RFC 5626
	    440: 'Max-Breadth Exceeded',  // RFC 5393
	    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events
	    470: 'Consent Needed',  // RFC 5360
	    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.
	    480: 'Temporarily Unavailable',
	    481: 'Call/Transaction Does Not Exist',
	    482: 'Loop Detected',
	    483: 'Too Many Hops',
	    484: 'Address Incomplete',
	    485: 'Ambiguous',
	    486: 'Busy Here',
	    487: 'Request Terminated',
	    488: 'Not Acceptable Here',
	    489: 'Bad Event',  // RFC 3265
	    491: 'Request Pending',
	    493: 'Undecipherable',
	    494: 'Security Agreement Required',  // RFC 3329
	    500: 'Internal Server Error',
	    501: 'Not Implemented',
	    502: 'Bad Gateway',
	    503: 'Service Unavailable',
	    504: 'Server Time-out',
	    505: 'Version Not Supported',
	    513: 'Message Too Large',
	    580: 'Precondition Failure',  // RFC 3312
	    600: 'Busy Everywhere',
	    603: 'Decline',
	    604: 'Does Not Exist Anywhere',
	    606: 'Not Acceptable'
	  },
	
	  /* SIP Option Tags
	   * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4
	   */
	  OPTION_TAGS: {
	    '100rel':                   true,  // RFC 3262
	    199:                        true,  // RFC 6228
	    answermode:                 true,  // RFC 5373
	    'early-session':            true,  // RFC 3959
	    eventlist:                  true,  // RFC 4662
	    explicitsub:                true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
	    'from-change':              true,  // RFC 4916
	    'geolocation-http':         true,  // RFC 6442
	    'geolocation-sip':          true,  // RFC 6442
	    gin:                        true,  // RFC 6140
	    gruu:                       true,  // RFC 5627
	    histinfo:                   true,  // RFC 7044
	    ice:                        true,  // RFC 5768
	    join:                       true,  // RFC 3911
	    'multiple-refer':           true,  // RFC 5368
	    norefersub:                 true,  // RFC 4488
	    nosub:                      true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
	    outbound:                   true,  // RFC 5626
	    path:                       true,  // RFC 3327
	    policy:                     true,  // RFC 6794
	    precondition:               true,  // RFC 3312
	    pref:                       true,  // RFC 3840
	    privacy:                    true,  // RFC 3323
	    'recipient-list-invite':    true,  // RFC 5366
	    'recipient-list-message':   true,  // RFC 5365
	    'recipient-list-subscribe': true,  // RFC 5367
	    replaces:                   true,  // RFC 3891
	    'resource-priority':        true,  // RFC 4412
	    'sdp-anat':                 true,  // RFC 4092
	    'sec-agree':                true,  // RFC 3329
	    tdialog:                    true,  // RFC 4538
	    timer:                      true,  // RFC 4028
	    uui:                        true   // RFC 7433
	  }
	};
	};


/***/ },
/* 219 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Exceptions
	 */
	
	/**
	 * SIP Exceptions.
	 * @augments SIP
	 */
	module.exports = {
	  ConfigurationError: (function(){
	    var exception = function(parameter, value) {
	      this.code = 1;
	      this.name = 'CONFIGURATION_ERROR';
	      this.parameter = parameter;
	      this.value = value;
	      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter "'+ this.parameter +'"';
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  InvalidStateError: (function(){
	    var exception = function(status) {
	      this.code = 2;
	      this.name = 'INVALID_STATE_ERROR';
	      this.status = status;
	      this.message = 'Invalid status: ' + status;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  NotSupportedError: (function(){
	    var exception = function(message) {
	      this.code = 3;
	      this.name = 'NOT_SUPPORTED_ERROR';
	      this.message = message;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  GetDescriptionError: (function(){
	    var exception = function(message) {
	      this.code = 4;
	      this.name = 'GET_DESCRIPTION_ERROR';
	      this.message = message;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }())
	};


/***/ },
/* 220 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP TIMERS
	 */
	
	/**
	 * @augments SIP
	 */
	var
	  T1 = 500,
	  T2 = 4000,
	  T4 = 5000;
	module.exports = function (timers) {
	  var Timers = {
	    T1: T1,
	    T2: T2,
	    T4: T4,
	    TIMER_B: 64 * T1,
	    TIMER_D: 0  * T1,
	    TIMER_F: 64 * T1,
	    TIMER_H: 64 * T1,
	    TIMER_I: 0  * T1,
	    TIMER_J: 0  * T1,
	    TIMER_K: 0  * T4,
	    TIMER_L: 64 * T1,
	    TIMER_M: 64 * T1,
	    TIMER_N: 64 * T1,
	    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1
	  };
	
	  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']
	  .forEach(function (name) {
	    // can't just use timers[name].bind(timers) since it bypasses jasmine's
	    // clock-mocking
	    Timers[name] = function () {
	      return timers[name].apply(timers, arguments);
	    };
	  });
	
	  return Timers;
	};


/***/ },
/* 221 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Message Parser
	 */
	
	/**
	 * Extract and parse every header of a SIP message.
	 * @augments SIP
	 * @namespace
	 */
	module.exports = function (SIP) {
	var Parser;
	
	function getHeader(data, headerStart) {
	  var
	    // 'start' position of the header.
	    start = headerStart,
	    // 'end' position of the header.
	    end = 0,
	    // 'partial end' position of the header.
	    partialEnd = 0;
	
	  //End of message.
	  if (data.substring(start, start + 2).match(/(^\r\n)/)) {
	    return -2;
	  }
	
	  while(end === 0) {
	    // Partial End of Header.
	    partialEnd = data.indexOf('\r\n', start);
	
	    // 'indexOf' returns -1 if the value to be found never occurs.
	    if (partialEnd === -1) {
	      return partialEnd;
	    }
	
	    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
	      // Not the end of the message. Continue from the next position.
	      start = partialEnd + 2;
	    } else {
	      end = partialEnd;
	    }
	  }
	
	  return end;
	}
	
	function parseHeader(message, data, headerStart, headerEnd) {
	  var header, idx, length, parsed,
	    hcolonIndex = data.indexOf(':', headerStart),
	    headerName = data.substring(headerStart, hcolonIndex).trim(),
	    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
	
	  // If header-field is well-known, parse it.
	  switch(headerName.toLowerCase()) {
	    case 'via':
	    case 'v':
	      message.addHeader('via', headerValue);
	      if(message.getHeaders('via').length === 1) {
	        parsed = message.parseHeader('Via');
	        if(parsed) {
	          message.via = parsed;
	          message.via_branch = parsed.branch;
	        }
	      } else {
	        parsed = 0;
	      }
	      break;
	    case 'from':
	    case 'f':
	      message.setHeader('from', headerValue);
	      parsed = message.parseHeader('from');
	      if(parsed) {
	        message.from = parsed;
	        message.from_tag = parsed.getParam('tag');
	      }
	      break;
	    case 'to':
	    case 't':
	      message.setHeader('to', headerValue);
	      parsed = message.parseHeader('to');
	      if(parsed) {
	        message.to = parsed;
	        message.to_tag = parsed.getParam('tag');
	      }
	      break;
	    case 'record-route':
	      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');
	
	      if (parsed === -1) {
	        parsed = undefined;
	        break;
	      }
	
	      length = parsed.length;
	      for (idx = 0; idx < length; idx++) {
	        header = parsed[idx];
	        message.addHeader('record-route', headerValue.substring(header.position, header.offset));
	        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;
	      }
	      break;
	    case 'call-id':
	    case 'i':
	      message.setHeader('call-id', headerValue);
	      parsed = message.parseHeader('call-id');
	      if(parsed) {
	        message.call_id = headerValue;
	      }
	      break;
	    case 'contact':
	    case 'm':
	      parsed = SIP.Grammar.parse(headerValue, 'Contact');
	
	      if (parsed === -1) {
	        parsed = undefined;
	        break;
	      }
	
	      length = parsed.length;
	      for (idx = 0; idx < length; idx++) {
	        header = parsed[idx];
	        message.addHeader('contact', headerValue.substring(header.position, header.offset));
	        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;
	      }
	      break;
	    case 'content-length':
	    case 'l':
	      message.setHeader('content-length', headerValue);
	      parsed = message.parseHeader('content-length');
	      break;
	    case 'content-type':
	    case 'c':
	      message.setHeader('content-type', headerValue);
	      parsed = message.parseHeader('content-type');
	      break;
	    case 'cseq':
	      message.setHeader('cseq', headerValue);
	      parsed = message.parseHeader('cseq');
	      if(parsed) {
	        message.cseq = parsed.value;
	      }
	      if(message instanceof SIP.IncomingResponse) {
	        message.method = parsed.method;
	      }
	      break;
	    case 'max-forwards':
	      message.setHeader('max-forwards', headerValue);
	      parsed = message.parseHeader('max-forwards');
	      break;
	    case 'www-authenticate':
	      message.setHeader('www-authenticate', headerValue);
	      parsed = message.parseHeader('www-authenticate');
	      break;
	    case 'proxy-authenticate':
	      message.setHeader('proxy-authenticate', headerValue);
	      parsed = message.parseHeader('proxy-authenticate');
	      break;
	    case 'refer-to':
	    case 'r':
	      message.setHeader('refer-to', headerValue);
	      parsed = message.parseHeader('refer-to');
	      if (parsed) {
	        message.refer_to = parsed;
	      }
	      break;
	    default:
	      // Do not parse this header.
	      message.setHeader(headerName, headerValue);
	      parsed = 0;
	  }
	
	  if (parsed === undefined) {
	    return {
	      error: 'error parsing header "'+ headerName +'"'
	    };
	  } else {
	    return true;
	  }
	}
	
	/** Parse SIP Message
	 * @function
	 * @param {String} message SIP message.
	 * @param {Object} logger object.
	 * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}
	 */
	Parser = {};
	Parser.parseMessage = function(data, ua) {
	  var message, firstLine, contentLength, bodyStart, parsed,
	    headerStart = 0,
	    headerEnd = data.indexOf('\r\n'),
	    logger = ua.getLogger('sip.parser');
	
	  if(headerEnd === -1) {
	    logger.warn('no CRLF found, not a SIP message, discarded');
	    return;
	  }
	
	  // Parse first line. Check if it is a Request or a Reply.
	  firstLine = data.substring(0, headerEnd);
	  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');
	
	  if(parsed === -1) {
	    logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
	    return;
	  } else if(!parsed.status_code) {
	    message = new SIP.IncomingRequest(ua);
	    message.method = parsed.method;
	    message.ruri = parsed.uri;
	  } else {
	    message = new SIP.IncomingResponse(ua);
	    message.status_code = parsed.status_code;
	    message.reason_phrase = parsed.reason_phrase;
	  }
	
	  message.data = data;
	  headerStart = headerEnd + 2;
	
	  /* Loop over every line in data. Detect the end of each header and parse
	  * it or simply add to the headers collection.
	  */
	  while(true) {
	    headerEnd = getHeader(data, headerStart);
	
	    // The SIP message has normally finished.
	    if(headerEnd === -2) {
	      bodyStart = headerStart + 2;
	      break;
	    }
	    // data.indexOf returned -1 due to a malformed message.
	    else if(headerEnd === -1) {
	      logger.error('malformed message');
	      return;
	    }
	
	    parsed = parseHeader(message, data, headerStart, headerEnd);
	
	    if(parsed !== true) {
	      logger.error(parsed.error);
	      return;
	    }
	
	    headerStart = headerEnd + 2;
	  }
	
	  /* RFC3261 18.3.
	   * If there are additional bytes in the transport packet
	   * beyond the end of the body, they MUST be discarded.
	   */
	  if(message.hasHeader('content-length')) {
	    contentLength = message.getHeader('content-length');
	    message.body = data.substr(bodyStart, contentLength);
	  } else {
	    message.body = data.substring(bodyStart);
	  }
	
	  return message;
	};
	
	SIP.Parser = Parser;
	};


/***/ },
/* 222 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Message
	 */
	
	module.exports = function (SIP) {
	var
	  OutgoingRequest,
	  IncomingMessage,
	  IncomingRequest,
	  IncomingResponse;
	
	function getSupportedHeader (request) {
	  var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags;
	  var optionTags = [];
	  var optionTagSet = {};
	
	  if (request.method === SIP.C.REGISTER) {
	    optionTags.push('path', 'gruu');
	  } else if (request.method === SIP.C.INVITE &&
	             (request.ua.contact.pub_gruu || request.ua.contact.temp_gruu)) {
	    optionTags.push('gruu');
	  }
	
	  if (request.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {
	    optionTags.push('100rel');
	  }
	  if (request.ua.configuration.replaces === SIP.C.supported.SUPPORTED) {
	    optionTags.push('replaces');
	  }
	
	  optionTags.push('outbound');
	
	  optionTags = optionTags.concat(request.ua.configuration.extraSupported);
	
	  optionTags = optionTags.filter(function(optionTag) {
	    var registered = SIP.C.OPTION_TAGS[optionTag];
	    var unique = !optionTagSet[optionTag];
	    optionTagSet[optionTag] = true;
	    return (registered || allowUnregistered) && unique;
	  });
	
	  return 'Supported: ' + optionTags.join(', ') + '\r\n';
	}
	
	/**
	 * @augments SIP
	 * @class Class for outgoing SIP request.
	 * @param {String} method request method
	 * @param {String} ruri request uri
	 * @param {SIP.UA} ua
	 * @param {Object} params parameters that will have priority over ua.configuration parameters:
	 * <br>
	 *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set
	 * @param {Object} [headers] extra headers
	 * @param {String} [body]
	 */
	OutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {
	  var
	    to,
	    from,
	    call_id,
	    cseq,
	    to_uri,
	    from_uri;
	
	  params = params || {};
	
	  // Mandatory parameters check
	  if(!method || !ruri || !ua) {
	    return null;
	  }
	
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.ua = ua;
	  this.headers = {};
	  this.method = method;
	  this.ruri = ruri;
	  this.body = body;
	  this.extraHeaders = (extraHeaders || []).slice();
	  this.statusCode = params.status_code;
	  this.reasonPhrase = params.reason_phrase;
	
	  // Fill the Common SIP Request Headers
	
	  // Route
	  if (params.route_set) {
	    this.setHeader('route', params.route_set);
	  } else if (ua.configuration.usePreloadedRoute){
	    this.setHeader('route', ua.transport.server.sip_uri);
	  }
	
	  // Via
	  // Empty Via header. Will be filled by the client transaction.
	  this.setHeader('via', '');
	
	  // Max-Forwards
	  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);
	
	  // To
	  to_uri = params.to_uri || ruri;
	  to = (params.to_displayName || params.to_displayName === 0) ? '"' + params.to_displayName + '" ' : '';
	  to += '<' + (to_uri && to_uri.toRaw ? to_uri.toRaw() : to_uri) + '>';
	  to += params.to_tag ? ';tag=' + params.to_tag : '';
	  this.to = new SIP.NameAddrHeader.parse(to);
	  this.setHeader('to', to);
	
	  // From
	  from_uri = params.from_uri || ua.configuration.uri;
	  if (params.from_displayName || params.from_displayName === 0) {
	    from = '"' + params.from_displayName + '" ';
	  } else if (ua.configuration.displayName) {
	    from = '"' + ua.configuration.displayName + '" ';
	  } else {
	    from = '';
	  }
	  from += '<' + (from_uri && from_uri.toRaw ? from_uri.toRaw() : from_uri) + '>;tag=';
	  from += params.from_tag || SIP.Utils.newTag();
	  this.from = new SIP.NameAddrHeader.parse(from);
	  this.setHeader('from', from);
	
	  // Call-ID
	  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));
	  this.call_id = call_id;
	  this.setHeader('call-id', call_id);
	
	  // CSeq
	  cseq = params.cseq || Math.floor(Math.random() * 10000);
	  this.cseq = cseq;
	  this.setHeader('cseq', cseq + ' ' + method);
	};
	
	OutgoingRequest.prototype = {
	  /**
	   * Replace the the given header by the given value.
	   * @param {String} name header name
	   * @param {String | Array} value header value
	   */
	  setHeader: function(name, value) {
	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
	  },
	
	  /**
	   * Get the value of the given header name at the given position.
	   * @param {String} name header name
	   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.
	   */
	  getHeader: function(name) {
	    var regexp, idx,
	      length = this.extraHeaders.length,
	      header = this.headers[SIP.Utils.headerize(name)];
	
	    if(header) {
	      if(header[0]) {
	        return header[0];
	      }
	    } else {
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        header = this.extraHeaders[idx];
	        if (regexp.test(header)) {
	          return header.substring(header.indexOf(':')+1).trim();
	        }
	      }
	    }
	
	    return;
	  },
	
	  /**
	   * Get the header/s of the given name.
	   * @param {String} name header name
	   * @returns {Array} Array with all the headers of the specified name.
	   */
	  getHeaders: function(name) {
	    var idx, length, regexp,
	      header = this.headers[SIP.Utils.headerize(name)],
	      result = [];
	
	    if(header) {
	      length = header.length;
	      for (idx = 0; idx < length; idx++) {
	        result.push(header[idx]);
	      }
	      return result;
	    } else {
	      length = this.extraHeaders.length;
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        header = this.extraHeaders[idx];
	        if (regexp.test(header)) {
	          result.push(header.substring(header.indexOf(':')+1).trim());
	        }
	      }
	      return result;
	    }
	  },
	
	  /**
	   * Verify the existence of the given header.
	   * @param {String} name header name
	   * @returns {boolean} true if header with given name exists, false otherwise
	   */
	  hasHeader: function(name) {
	    var regexp, idx,
	      length = this.extraHeaders.length;
	
	    if (this.headers[SIP.Utils.headerize(name)]) {
	      return true;
	    } else {
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        if (regexp.test(this.extraHeaders[idx])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  },
	
	  toString: function() {
	    var msg = '', header, length, idx;
	
	    msg += this.method + ' ' + (this.ruri.toRaw ? this.ruri.toRaw() : this.ruri) + ' SIP/2.0\r\n';
	
	    for (header in this.headers) {
	      length = this.headers[header].length;
	      for (idx = 0; idx < length; idx++) {
	        msg += header + ': ' + this.headers[header][idx] + '\r\n';
	      }
	    }
	
	    length = this.extraHeaders.length;
	    for (idx = 0; idx < length; idx++) {
	      msg += this.extraHeaders[idx].trim() +'\r\n';
	    }
	
	    msg += getSupportedHeader(this);
	    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	
	    if(this.body) {
	      length = SIP.Utils.str_utf8_length(this.body);
	      msg += 'Content-Length: ' + length + '\r\n\r\n';
	      msg += this.body;
	    } else {
	      msg += 'Content-Length: 0\r\n\r\n';
	    }
	
	    return msg;
	  }
	};
	
	/**
	 * @augments SIP
	 * @class Class for incoming SIP message.
	 */
	IncomingMessage = function(){
	  this.data = null;
	  this.headers = null;
	  this.method =  null;
	  this.via = null;
	  this.via_branch = null;
	  this.call_id = null;
	  this.cseq = null;
	  this.from = null;
	  this.from_tag = null;
	  this.to = null;
	  this.to_tag = null;
	  this.body = null;
	};
	
	IncomingMessage.prototype = {
	  /**
	  * Insert a header of the given name and value into the last position of the
	  * header array.
	  * @param {String} name header name
	  * @param {String} value header value
	  */
	  addHeader: function(name, value) {
	    var header = { raw: value };
	
	    name = SIP.Utils.headerize(name);
	
	    if(this.headers[name]) {
	      this.headers[name].push(header);
	    } else {
	      this.headers[name] = [header];
	    }
	  },
	
	  /**
	   * Get the value of the given header name at the given position.
	   * @param {String} name header name
	   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.
	   */
	  getHeader: function(name) {
	    var header = this.headers[SIP.Utils.headerize(name)];
	
	    if(header) {
	      if(header[0]) {
	        return header[0].raw;
	      }
	    } else {
	      return;
	    }
	  },
	
	  /**
	   * Get the header/s of the given name.
	   * @param {String} name header name
	   * @returns {Array} Array with all the headers of the specified name.
	   */
	  getHeaders: function(name) {
	    var idx, length,
	      header = this.headers[SIP.Utils.headerize(name)],
	      result = [];
	
	    if(!header) {
	      return [];
	    }
	
	    length = header.length;
	    for (idx = 0; idx < length; idx++) {
	      result.push(header[idx].raw);
	    }
	
	    return result;
	  },
	
	  /**
	   * Verify the existence of the given header.
	   * @param {String} name header name
	   * @returns {boolean} true if header with given name exists, false otherwise
	   */
	  hasHeader: function(name) {
	    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;
	  },
	
	  /**
	  * Parse the given header on the given index.
	  * @param {String} name header name
	  * @param {Number} [idx=0] header index
	  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
	  */
	  parseHeader: function(name, idx) {
	    var header, value, parsed;
	
	    name = SIP.Utils.headerize(name);
	
	    idx = idx || 0;
	
	    if(!this.headers[name]) {
	      this.logger.log('header "' + name + '" not present');
	      return;
	    } else if(idx >= this.headers[name].length) {
	      this.logger.log('not so many "' + name + '" headers present');
	      return;
	    }
	
	    header = this.headers[name][idx];
	    value = header.raw;
	
	    if(header.parsed) {
	      return header.parsed;
	    }
	
	    //substitute '-' by '_' for grammar rule matching.
	    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));
	
	    if(parsed === -1) {
	      this.headers[name].splice(idx, 1); //delete from headers
	      this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
	      return;
	    } else {
	      header.parsed = parsed;
	      return parsed;
	    }
	  },
	
	  /**
	   * Message Header attribute selector. Alias of parseHeader.
	   * @param {String} name header name
	   * @param {Number} [idx=0] header index
	   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
	   *
	   * @example
	   * message.s('via',3).port
	   */
	  s: function(name, idx) {
	    return this.parseHeader(name, idx);
	  },
	
	  /**
	  * Replace the value of the given header by the value.
	  * @param {String} name header name
	  * @param {String} value header value
	  */
	  setHeader: function(name, value) {
	    var header = { raw: value };
	    this.headers[SIP.Utils.headerize(name)] = [header];
	  },
	
	  toString: function() {
	    return this.data;
	  }
	};
	
	/**
	 * @augments IncomingMessage
	 * @class Class for incoming SIP request.
	 */
	IncomingRequest = function(ua) {
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.ua = ua;
	  this.headers = {};
	  this.ruri = null;
	  this.transport = null;
	  this.server_transaction = null;
	};
	IncomingRequest.prototype = new IncomingMessage();
	
	/**
	* Stateful reply.
	* @param {Number} code status code
	* @param {String} reason reason phrase
	* @param {Object} headers extra headers
	* @param {String} body body
	* @param {Function} [onSuccess] onSuccess callback
	* @param {Function} [onFailure] onFailure callback
	*/
	IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {
	  var rr, vias, length, idx, response,
	    to = this.getHeader('To'),
	    r = 0,
	    v = 0;
	
	  response = SIP.Utils.buildStatusLine(code, reason);
	  extraHeaders = (extraHeaders || []).slice();
	
	  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {
	    rr = this.getHeaders('record-route');
	    length = rr.length;
	
	    for(r; r < length; r++) {
	      response += 'Record-Route: ' + rr[r] + '\r\n';
	    }
	  }
	
	  vias = this.getHeaders('via');
	  length = vias.length;
	
	  for(v; v < length; v++) {
	    response += 'Via: ' + vias[v] + '\r\n';
	  }
	
	  if(!this.to_tag && code > 100) {
	    to += ';tag=' + SIP.Utils.newTag();
	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
	    to += ';tag=' + this.to_tag;
	  }
	
	  response += 'To: ' + to + '\r\n';
	  response += 'From: ' + this.getHeader('From') + '\r\n';
	  response += 'Call-ID: ' + this.call_id + '\r\n';
	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
	
	  length = extraHeaders.length;
	  for (idx = 0; idx < length; idx++) {
	    response += extraHeaders[idx].trim() +'\r\n';
	  }
	
	  response += getSupportedHeader(this);
	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	
	  if(body) {
	    length = SIP.Utils.str_utf8_length(body);
	    response += 'Content-Type: application/sdp\r\n';
	    response += 'Content-Length: ' + length + '\r\n\r\n';
	    response += body;
	  } else {
	    response += 'Content-Length: ' + 0 + '\r\n\r\n';
	  }
	
	  this.server_transaction.receiveResponse(code, response).then(onSuccess, onFailure);
	
	  return response;
	};
	
	/**
	* Stateless reply.
	* @param {Number} code status code
	* @param {String} reason reason phrase
	*/
	IncomingRequest.prototype.reply_sl = function(code, reason) {
	  var to, response,
	    v = 0,
	    vias = this.getHeaders('via'),
	    length = vias.length;
	
	  response = SIP.Utils.buildStatusLine(code, reason);
	
	  for(v; v < length; v++) {
	    response += 'Via: ' + vias[v] + '\r\n';
	  }
	
	  to = this.getHeader('To');
	
	  if(!this.to_tag && code > 100) {
	    to += ';tag=' + SIP.Utils.newTag();
	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
	    to += ';tag=' + this.to_tag;
	  }
	
	  response += 'To: ' + to + '\r\n';
	  response += 'From: ' + this.getHeader('From') + '\r\n';
	  response += 'Call-ID: ' + this.call_id + '\r\n';
	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	  response += 'Content-Length: ' + 0 + '\r\n\r\n';
	
	  this.transport.send(response);
	};
	
	
	/**
	 * @augments IncomingMessage
	 * @class Class for incoming SIP response.
	 */
	IncomingResponse = function(ua) {
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.headers = {};
	  this.status_code = null;
	  this.reason_phrase = null;
	};
	IncomingResponse.prototype = new IncomingMessage();
	
	SIP.OutgoingRequest = OutgoingRequest;
	SIP.IncomingRequest = IncomingRequest;
	SIP.IncomingResponse = IncomingResponse;
	};


/***/ },
/* 223 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP URI
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP URI.
	 *
	 * @param {String} [scheme]
	 * @param {String} [user]
	 * @param {String} host
	 * @param {String} [port]
	 * @param {Object} [parameters]
	 * @param {Object} [headers]
	 *
	 */
	module.exports = function (SIP) {
	var URI;
	
	URI = function(scheme, user, host, port, parameters, headers) {
	  var param, header, raw, normal;
	
	  // Checks
	  if(!host) {
	    throw new TypeError('missing or invalid "host" parameter');
	  }
	
	  // Initialize parameters
	  scheme = scheme || SIP.C.SIP;
	  this.parameters = {};
	  this.headers = {};
	
	  for (param in parameters) {
	    this.setParam(param, parameters[param]);
	  }
	
	  for (header in headers) {
	    this.setHeader(header, headers[header]);
	  }
	
	  // Raw URI
	  raw = {
	    scheme: scheme,
	    user: user,
	    host: host,
	    port: port
	  };
	
	  // Normalized URI
	  normal = {
	    scheme: scheme.toLowerCase(),
	    user: user,
	    host: host.toLowerCase(),
	    port: port
	  };
	
	  Object.defineProperties(this, {
	    _normal: {
	      get: function() { return normal; }
	    },
	
	    _raw: {
	      get: function() { return raw; }
	    },
	
	    scheme: {
	      get: function() { return normal.scheme; },
	      set: function(value) {
	        raw.scheme = value;
	        normal.scheme = value.toLowerCase();
	      }
	    },
	
	    user: {
	      get: function() { return normal.user; },
	      set: function(value) {
	        normal.user = raw.user = value;
	      }
	    },
	
	    host: {
	      get: function() { return normal.host; },
	      set: function(value) {
	        raw.host = value;
	        normal.host = value.toLowerCase();
	      }
	    },
	
	    aor: {
	      get: function() { return normal.user + '@' + normal.host; }
	    },
	
	    port: {
	      get: function() { return normal.port; },
	      set: function(value) {
	        normal.port = raw.port = value === 0 ? value : (parseInt(value,10) || null);
	      }
	    }
	  });
	};
	
	URI.prototype = {
	  setParam: function(key, value) {
	    if(key) {
	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();
	    }
	  },
	
	  getParam: function(key) {
	    if(key) {
	      return this.parameters[key.toLowerCase()];
	    }
	  },
	
	  hasParam: function(key) {
	    if(key) {
	      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
	    }
	  },
	
	  deleteParam: function(parameter) {
	    var value;
	    parameter = parameter.toLowerCase();
	    if (this.parameters.hasOwnProperty(parameter)) {
	      value = this.parameters[parameter];
	      delete this.parameters[parameter];
	      return value;
	    }
	  },
	
	  clearParams: function() {
	    this.parameters = {};
	  },
	
	  setHeader: function(name, value) {
	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
	  },
	
	  getHeader: function(name) {
	    if(name) {
	      return this.headers[SIP.Utils.headerize(name)];
	    }
	  },
	
	  hasHeader: function(name) {
	    if(name) {
	      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;
	    }
	  },
	
	  deleteHeader: function(header) {
	    var value;
	    header = SIP.Utils.headerize(header);
	    if(this.headers.hasOwnProperty(header)) {
	      value = this.headers[header];
	      delete this.headers[header];
	      return value;
	    }
	  },
	
	  clearHeaders: function() {
	    this.headers = {};
	  },
	
	  clone: function() {
	    return new URI(
	      this._raw.scheme,
	      this._raw.user,
	      this._raw.host,
	      this._raw.port,
	      JSON.parse(JSON.stringify(this.parameters)),
	      JSON.parse(JSON.stringify(this.headers)));
	  },
	
	  toRaw: function() {
	    return this._toString(this._raw);
	  },
	
	  toString: function() {
	    return this._toString(this._normal);
	  },
	
	  _toString: function(uri) {
	    var header, parameter, idx, uriString, headers = [];
	
	    uriString  = uri.scheme + ':';
	    // add slashes if it's not a sip(s) URI
	    if (!uri.scheme.toLowerCase().match("^sips?$")) {
	      uriString += "//";
	    }
	    if (uri.user) {
	      uriString += SIP.Utils.escapeUser(uri.user) + '@';
	    }
	    uriString += uri.host;
	    if (uri.port || uri.port === 0) {
	      uriString += ':' + uri.port;
	    }
	
	    for (parameter in this.parameters) {
	      uriString += ';' + parameter;
	
	      if (this.parameters[parameter] !== null) {
	        uriString += '='+ this.parameters[parameter];
	      }
	    }
	
	    for(header in this.headers) {
	      for(idx in this.headers[header]) {
	        headers.push(header + '=' + this.headers[header][idx]);
	      }
	    }
	
	    if (headers.length > 0) {
	      uriString += '?' + headers.join('&');
	    }
	
	    return uriString;
	  }
	};
	
	
	/**
	  * Parse the given string and returns a SIP.URI instance or undefined if
	  * it is an invalid URI.
	  * @public
	  * @param {String} uri
	  */
	URI.parse = function(uri) {
	  uri = SIP.Grammar.parse(uri,'SIP_URI');
	
	  if (uri !== -1) {
	    return uri;
	  } else {
	    return undefined;
	  }
	};
	
	SIP.URI = URI;
	};


/***/ },
/* 224 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP NameAddrHeader
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a Name Address SIP header.
	 *
	 * @param {SIP.URI} uri
	 * @param {String} [displayName]
	 * @param {Object} [parameters]
	 *
	 */
	module.exports = function (SIP) {
	var NameAddrHeader;
	
	NameAddrHeader = function(uri, displayName, parameters) {
	  var param;
	
	  // Checks
	  if(!uri || !(uri instanceof SIP.URI)) {
	    throw new TypeError('missing or invalid "uri" parameter');
	  }
	
	  // Initialize parameters
	  this.uri = uri;
	  this.parameters = {};
	
	  for (param in parameters) {
	    this.setParam(param, parameters[param]);
	  }
	
	  Object.defineProperties(this, {
	    friendlyName: {
	      get: function() { return this.displayName || uri.aor; }
	    },
	
	    displayName: {
	      get: function() { return displayName; },
	      set: function(value) {
	        displayName = (value === 0) ? '0' : value;
	      }
	    }
	  });
	};
	NameAddrHeader.prototype = {
	  setParam: function (key, value) {
	    if(key) {
	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();
	    }
	  },
	  getParam: SIP.URI.prototype.getParam,
	  hasParam: SIP.URI.prototype.hasParam,
	  deleteParam: SIP.URI.prototype.deleteParam,
	  clearParams: SIP.URI.prototype.clearParams,
	
	  clone: function() {
	    return new NameAddrHeader(
	      this.uri.clone(),
	      this.displayName,
	      JSON.parse(JSON.stringify(this.parameters)));
	  },
	
	  toString: function() {
	    var body, parameter;
	
	    body  = (this.displayName || this.displayName === 0) ? '"' + this.displayName + '" ' : '';
	    body += '<' + this.uri.toString() + '>';
	
	    for (parameter in this.parameters) {
	      body += ';' + parameter;
	
	      if (this.parameters[parameter] !== null) {
	        body += '='+ this.parameters[parameter];
	      }
	    }
	
	    return body;
	  }
	};
	
	
	/**
	  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if
	  * it is an invalid NameAddrHeader.
	  * @public
	  * @param {String} name_addr_header
	  */
	NameAddrHeader.parse = function(name_addr_header) {
	  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');
	
	  if (name_addr_header !== -1) {
	    return name_addr_header;
	  } else {
	    return undefined;
	  }
	};
	
	SIP.NameAddrHeader = NameAddrHeader;
	};


/***/ },
/* 225 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Transactions
	 */
	
	/**
	 * SIP Transactions module.
	 * @augments SIP
	 */
	module.exports = function (SIP) {
	var
	  C = {
	    // Transaction states
	    STATUS_TRYING:     1,
	    STATUS_PROCEEDING: 2,
	    STATUS_CALLING:    3,
	    STATUS_ACCEPTED:   4,
	    STATUS_COMPLETED:  5,
	    STATUS_TERMINATED: 6,
	    STATUS_CONFIRMED:  7,
	
	    // Transaction types
	    NON_INVITE_CLIENT: 'nict',
	    NON_INVITE_SERVER: 'nist',
	    INVITE_CLIENT: 'ict',
	    INVITE_SERVER: 'ist'
	  };
	
	function buildViaHeader (request_sender, transport, id) {
	  var via;
	  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);
	  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;
	  if (request_sender.ua.configuration.forceRport) {
	    via += ';rport';
	  }
	  return via;
	}
	
	/**
	* @augments SIP.Transactions
	* @class Non Invite Client Transaction
	* @param {SIP.RequestSender} request_sender
	* @param {SIP.OutgoingRequest} request
	* @param {SIP.Transport} transport
	*/
	var NonInviteClientTransaction = function(request_sender, request, transport) {
	  var via;
	
	  this.type = C.NON_INVITE_CLIENT;
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	
	  this.request_sender.ua.newTransaction(this);
	};
	NonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	NonInviteClientTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	NonInviteClientTransaction.prototype.send = function() {
	  var tr = this;
	
	  this.stateChanged(C.STATUS_TRYING);
	  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);
	
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	NonInviteClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.F);
	  SIP.Timers.clearTimeout(this.K);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	  this.request_sender.onTransportError();
	};
	
	NonInviteClientTransaction.prototype.timer_F = function() {
	  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	  this.request_sender.onRequestTimeout();
	};
	
	NonInviteClientTransaction.prototype.timer_K = function() {
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	};
	
	NonInviteClientTransaction.prototype.receiveResponse = function(response) {
	  var
	    tr = this,
	    status_code = response.status_code;
	
	  if(status_code < 200) {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        SIP.Timers.clearTimeout(this.F);
	
	        if(status_code === 408) {
	          this.request_sender.onRequestTimeout();
	        } else {
	          this.request_sender.receiveResponse(response);
	        }
	
	        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);
	        break;
	      case C.STATUS_COMPLETED:
	        break;
	    }
	  }
	};
	
	
	
	/**
	* @augments SIP.Transactions
	* @class Invite Client Transaction
	* @param {SIP.RequestSender} request_sender
	* @param {SIP.OutgoingRequest} request
	* @param {SIP.Transport} transport
	*/
	var InviteClientTransaction = function(request_sender, request, transport) {
	  var via,
	    tr = this;
	
	  this.type = C.INVITE_CLIENT;
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	
	  this.request_sender.ua.newTransaction(this);
	
	  // Add the cancel property to the request.
	  //Will be called from the request instance, not the transaction itself.
	  this.request.cancel = function(reason) {
	    tr.cancel_request(tr, reason);
	  };
	};
	InviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	InviteClientTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	InviteClientTransaction.prototype.send = function() {
	  var tr = this;
	  this.stateChanged(C.STATUS_CALLING);
	  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);
	
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	InviteClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.B);
	  SIP.Timers.clearTimeout(this.D);
	  SIP.Timers.clearTimeout(this.M);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	
	  if (this.state !== C.STATUS_ACCEPTED) {
	    this.request_sender.onTransportError();
	  }
	};
	
	// RFC 6026 7.2
	InviteClientTransaction.prototype.timer_M = function() {
	  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);
	
	  if(this.state === C.STATUS_ACCEPTED) {
	    SIP.Timers.clearTimeout(this.B);
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.request_sender.ua.destroyTransaction(this);
	  }
	};
	
	// RFC 3261 17.1.1
	InviteClientTransaction.prototype.timer_B = function() {
	  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);
	  if(this.state === C.STATUS_CALLING) {
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.request_sender.ua.destroyTransaction(this);
	    this.request_sender.onRequestTimeout();
	  }
	};
	
	InviteClientTransaction.prototype.timer_D = function() {
	  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.B);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	};
	
	InviteClientTransaction.prototype.sendACK = function(response) {
	  var tr = this;
	
	  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\r\n';
	  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\r\n';
	
	  if(this.request.headers['Route']) {
	    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\r\n';
	  }
	
	  this.ack += 'To: ' + response.getHeader('to') + '\r\n';
	  this.ack += 'From: ' + this.request.headers['From'].toString() + '\r\n';
	  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\r\n';
	  this.ack += 'Content-Length: 0\r\n';
	  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];
	  this.ack += ' ACK\r\n\r\n';
	
	  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);
	
	  this.transport.send(this.ack);
	};
	
	InviteClientTransaction.prototype.cancel_request = function(tr, reason) {
	  var request = tr.request;
	
	  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\r\n';
	  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\r\n';
	
	  if(this.request.headers['Route']) {
	    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\r\n';
	  }
	
	  this.cancel += 'To: ' + request.headers['To'].toString() + '\r\n';
	  this.cancel += 'From: ' + request.headers['From'].toString() + '\r\n';
	  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\r\n';
	  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +
	  ' CANCEL\r\n';
	
	  if(reason) {
	    this.cancel += 'Reason: ' + reason + '\r\n';
	  }
	
	  this.cancel += 'Content-Length: 0\r\n\r\n';
	
	  // Send only if a provisional response (>100) has been received.
	  if(this.state === C.STATUS_PROCEEDING) {
	    this.transport.send(this.cancel);
	  }
	};
	
	InviteClientTransaction.prototype.receiveResponse = function(response) {
	  var
	  tr = this,
	  status_code = response.status_code;
	
	  if(status_code >= 100 && status_code <= 199) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        this.request_sender.receiveResponse(response);
	        if(this.cancel) {
	          this.transport.send(this.cancel);
	        }
	        break;
	      case C.STATUS_PROCEEDING:
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else if(status_code >= 200 && status_code <= 299) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_ACCEPTED);
	        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);
	        this.request_sender.receiveResponse(response);
	        break;
	      case C.STATUS_ACCEPTED:
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else if(status_code >= 300 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        this.sendACK(response);
	        this.request_sender.receiveResponse(response);
	        break;
	      case C.STATUS_COMPLETED:
	        this.sendACK(response);
	        break;
	    }
	  }
	};
	
	
	/**
	 * @augments SIP.Transactions
	 * @class ACK Client Transaction
	 * @param {SIP.RequestSender} request_sender
	 * @param {SIP.OutgoingRequest} request
	 * @param {SIP.Transport} transport
	 */
	var AckClientTransaction = function(request_sender, request, transport) {
	  var via;
	
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	};
	AckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	AckClientTransaction.prototype.send = function() {
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	AckClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);
	  this.request_sender.onTransportError();
	};
	
	
	/**
	* @augments SIP.Transactions
	* @class Non Invite Server Transaction
	* @param {SIP.IncomingRequest} request
	* @param {SIP.UA} ua
	*/
	var NonInviteServerTransaction = function(request, ua) {
	  this.type = C.NON_INVITE_SERVER;
	  this.id = request.via_branch;
	  this.request = request;
	  this.transport = request.transport;
	  this.ua = ua;
	  this.last_response = '';
	  request.server_transaction = this;
	
	  this.logger = ua.getLogger('sip.transaction.nist', this.id);
	
	  this.state = C.STATUS_TRYING;
	
	  ua.newTransaction(this);
	};
	NonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	NonInviteServerTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	NonInviteServerTransaction.prototype.timer_J = function() {
	  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	NonInviteServerTransaction.prototype.onTransportError = function() {
	  if (!this.transportError) {
	    this.transportError = true;
	
	    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);
	
	    SIP.Timers.clearTimeout(this.J);
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	NonInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
	  var tr = this;
	  var deferred = SIP.Utils.defer();
	
	  if(status_code === 100) {
	    /* RFC 4320 4.1
	     * 'A SIP element MUST NOT
	     * send any provisional response with a
	     * Status-Code other than 100 to a non-INVITE request.'
	     */
	    switch(this.state) {
	      case C.STATUS_TRYING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        if(!this.transport.send(response))  {
	          this.onTransportError();
	        }
	        break;
	      case C.STATUS_PROCEEDING:
	        this.last_response = response;
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          deferred.resolve();
	        }
	        break;
	    }
	  } else if(status_code >= 200 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        this.last_response = response;
	        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          deferred.resolve();
	        }
	        break;
	      case C.STATUS_COMPLETED:
	        break;
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	* @augments SIP.Transactions
	* @class Invite Server Transaction
	* @param {SIP.IncomingRequest} request
	* @param {SIP.UA} ua
	*/
	var InviteServerTransaction = function(request, ua) {
	  this.type = C.INVITE_SERVER;
	  this.id = request.via_branch;
	  this.request = request;
	  this.transport = request.transport;
	  this.ua = ua;
	  this.last_response = '';
	  request.server_transaction = this;
	
	  this.logger = ua.getLogger('sip.transaction.ist', this.id);
	
	  this.state = C.STATUS_PROCEEDING;
	
	  ua.newTransaction(this);
	
	  this.resendProvisionalTimer = null;
	
	  request.reply(100);
	};
	InviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	InviteServerTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	InviteServerTransaction.prototype.timer_H = function() {
	  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);
	
	  if(this.state === C.STATUS_COMPLETED) {
	    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');
	  }
	
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	InviteServerTransaction.prototype.timer_I = function() {
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	// RFC 6026 7.1
	InviteServerTransaction.prototype.timer_L = function() {
	  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);
	
	  if(this.state === C.STATUS_ACCEPTED) {
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	InviteServerTransaction.prototype.onTransportError = function() {
	  if (!this.transportError) {
	    this.transportError = true;
	
	    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);
	
	    if (this.resendProvisionalTimer !== null) {
	      SIP.Timers.clearInterval(this.resendProvisionalTimer);
	      this.resendProvisionalTimer = null;
	    }
	
	    SIP.Timers.clearTimeout(this.L);
	    SIP.Timers.clearTimeout(this.H);
	    SIP.Timers.clearTimeout(this.I);
	
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	InviteServerTransaction.prototype.resend_provisional = function() {
	  if(!this.transport.send(this.last_response)) {
	    this.onTransportError();
	  }
	};
	
	// INVITE Server Transaction RFC 3261 17.2.1
	InviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
	  var tr = this;
	  var deferred = SIP.Utils.defer();
	
	  if(status_code >= 100 && status_code <= 199) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	        }
	        this.last_response = response;
	        break;
	    }
	  }
	
	  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {
	    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.
	    if(this.resendProvisionalTimer === null) {
	      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),
	        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);
	    }
	  } else if(status_code >= 200 && status_code <= 299) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_ACCEPTED);
	        this.last_response = response;
	        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);
	
	        if (this.resendProvisionalTimer !== null) {
	          SIP.Timers.clearInterval(this.resendProvisionalTimer);
	          this.resendProvisionalTimer = null;
	        }
	        /* falls through */
	        case C.STATUS_ACCEPTED:
	          // Note that this point will be reached for proceeding tr.state also.
	          if(!this.transport.send(response)) {
	            this.onTransportError();
	            deferred.reject();
	          } else {
	            deferred.resolve();
	          }
	          break;
	    }
	  } else if(status_code >= 300 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        if (this.resendProvisionalTimer !== null) {
	          SIP.Timers.clearInterval(this.resendProvisionalTimer);
	          this.resendProvisionalTimer = null;
	        }
	
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          this.stateChanged(C.STATUS_COMPLETED);
	          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);
	          deferred.resolve();
	        }
	        break;
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	 * @function
	 * @param {SIP.UA} ua
	 * @param {SIP.IncomingRequest} request
	 *
	 * @return {boolean}
	 * INVITE:
	 *  _true_ if retransmission
	 *  _false_ new request
	 *
	 * ACK:
	 *  _true_  ACK to non2xx response
	 *  _false_ ACK must be passed to TU (accepted state)
	 *          ACK to 2xx response
	 *
	 * CANCEL:
	 *  _true_  no matching invite transaction
	 *  _false_ matching invite transaction and no final response sent
	 *
	 * OTHER:
	 *  _true_  retransmission
	 *  _false_ new request
	 */
	var checkTransaction = function(ua, request) {
	  var tr;
	
	  switch(request.method) {
	    case SIP.C.INVITE:
	      tr = ua.transactions.ist[request.via_branch];
	      if(tr) {
	        switch(tr.state) {
	          case C.STATUS_PROCEEDING:
	            tr.transport.send(tr.last_response);
	            break;
	
	            // RFC 6026 7.1 Invite retransmission
	            //received while in C.STATUS_ACCEPTED state. Absorb it.
	          case C.STATUS_ACCEPTED:
	            break;
	        }
	        return true;
	      }
	      break;
	    case SIP.C.ACK:
	      tr = ua.transactions.ist[request.via_branch];
	
	      // RFC 6026 7.1
	      if(tr) {
	        if(tr.state === C.STATUS_ACCEPTED) {
	          return false;
	        } else if(tr.state === C.STATUS_COMPLETED) {
	          tr.state = C.STATUS_CONFIRMED;
	          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);
	          return true;
	        }
	      }
	
	      // ACK to 2XX Response.
	      else {
	        return false;
	      }
	      break;
	    case SIP.C.CANCEL:
	      tr = ua.transactions.ist[request.via_branch];
	      if(tr) {
	        request.reply_sl(200);
	        if(tr.state === C.STATUS_PROCEEDING) {
	          return false;
	        } else {
	          return true;
	        }
	      } else {
	        request.reply_sl(481);
	        return true;
	      }
	      break;
	    default:
	
	      // Non-INVITE Server Transaction RFC 3261 17.2.2
	      tr = ua.transactions.nist[request.via_branch];
	      if(tr) {
	        switch(tr.state) {
	          case C.STATUS_TRYING:
	            break;
	          case C.STATUS_PROCEEDING:
	          case C.STATUS_COMPLETED:
	            tr.transport.send(tr.last_response);
	            break;
	        }
	        return true;
	      }
	      break;
	  }
	};
	
	SIP.Transactions = {
	  C: C,
	  checkTransaction: checkTransaction,
	  NonInviteClientTransaction: NonInviteClientTransaction,
	  InviteClientTransaction: InviteClientTransaction,
	  AckClientTransaction: AckClientTransaction,
	  NonInviteServerTransaction: NonInviteServerTransaction,
	  InviteServerTransaction: InviteServerTransaction
	};
	
	};


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileoverview SIP Dialog
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP dialog.
	 * @param {SIP.RTCSession} owner
	 * @param {SIP.IncomingRequest|SIP.IncomingResponse} message
	 * @param {Enum} type UAC / UAS
	 * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED
	 */
	module.exports = function (SIP) {
	
	var RequestSender = __webpack_require__(227)(SIP);
	
	var Dialog,
	  C = {
	    // Dialog states
	    STATUS_EARLY:       1,
	    STATUS_CONFIRMED:   2
	  };
	
	// RFC 3261 12.1
	Dialog = function(owner, message, type, state) {
	  var contact;
	
	  this.uac_pending_reply = false;
	  this.uas_pending_reply = false;
	
	  if(!message.hasHeader('contact')) {
	    return {
	      error: 'unable to create a Dialog without Contact header field'
	    };
	  }
	
	  if(message instanceof SIP.IncomingResponse) {
	    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;
	  } else {
	    // Create confirmed dialog if state is not defined
	    state = state || C.STATUS_CONFIRMED;
	  }
	
	  contact = message.parseHeader('contact');
	
	  // RFC 3261 12.1.1
	  if(type === 'UAS') {
	    this.id = {
	      call_id: message.call_id,
	      local_tag: message.to_tag,
	      remote_tag: message.from_tag,
	      toString: function() {
	        return this.call_id + this.local_tag + this.remote_tag;
	      }
	    };
	    this.state = state;
	    this.remote_seqnum = message.cseq;
	    this.local_uri = message.parseHeader('to').uri;
	    this.remote_uri = message.parseHeader('from').uri;
	    this.remote_target = contact.uri;
	    this.route_set = message.getHeaders('record-route');
	    this.invite_seqnum = message.cseq;
	    this.local_seqnum = message.cseq;
	  }
	  // RFC 3261 12.1.2
	  else if(type === 'UAC') {
	    this.id = {
	      call_id: message.call_id,
	      local_tag: message.from_tag,
	      remote_tag: message.to_tag,
	      toString: function() {
	        return this.call_id + this.local_tag + this.remote_tag;
	      }
	    };
	    this.state = state;
	    this.invite_seqnum = message.cseq;
	    this.local_seqnum = message.cseq;
	    this.local_uri = message.parseHeader('from').uri;
	    this.pracked = [];
	    this.remote_uri = message.parseHeader('to').uri;
	    this.remote_target = contact.uri;
	    this.route_set = message.getHeaders('record-route').reverse();
	
	    //RENDERBODY
	    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {
	      this.mediaHandler = owner.mediaHandlerFactory(owner);
	    }
	  }
	
	  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());
	  this.owner = owner;
	  owner.ua.dialogs[this.id.toString()] = this;
	  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));
	  owner.emit('dialog', this);
	};
	
	Dialog.prototype = {
	  /**
	   * @param {SIP.IncomingMessage} message
	   * @param {Enum} UAC/UAS
	   */
	  update: function(message, type) {
	    this.state = C.STATUS_CONFIRMED;
	
	    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');
	
	    if(type === 'UAC') {
	      // RFC 3261 13.2.2.4
	      this.route_set = message.getHeaders('record-route').reverse();
	    }
	  },
	
	  terminate: function() {
	    this.logger.log('dialog ' + this.id.toString() + ' deleted');
	    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {
	      this.mediaHandler.peerConnection.close();
	    }
	    delete this.owner.ua.dialogs[this.id.toString()];
	  },
	
	  /**
	  * @param {String} method request method
	  * @param {Object} extraHeaders extra headers
	  * @returns {SIP.OutgoingRequest}
	  */
	
	  // RFC 3261 12.2.1.1
	  createRequest: function(method, extraHeaders, body) {
	    var cseq, request;
	    extraHeaders = (extraHeaders || []).slice();
	
	    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }
	
	    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;
	
	    request = new SIP.OutgoingRequest(
	      method,
	      this.remote_target,
	      this.owner.ua, {
	        'cseq': cseq,
	        'call_id': this.id.call_id,
	        'from_uri': this.local_uri,
	        'from_tag': this.id.local_tag,
	        'to_uri': this.remote_uri,
	        'to_tag': this.id.remote_tag,
	        'route_set': this.route_set
	      }, extraHeaders, body);
	
	    request.dialog = this;
	
	    return request;
	  },
	
	  /**
	  * @param {SIP.IncomingRequest} request
	  * @returns {Boolean}
	  */
	
	  // RFC 3261 12.2.2
	  checkInDialogRequest: function(request) {
	    var self = this;
	
	    if(!this.remote_seqnum) {
	      this.remote_seqnum = request.cseq;
	    } else if(request.cseq < this.remote_seqnum) {
	        //Do not try to reply to an ACK request.
	        if (request.method !== SIP.C.ACK) {
	          request.reply(500);
	        }
	        if (request.cseq === this.invite_seqnum) {
	          return true;
	        }
	        return false;
	    } else if(request.cseq > this.remote_seqnum) {
	      this.remote_seqnum = request.cseq;
	    }
	
	    switch(request.method) {
	      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-
	      case SIP.C.INVITE:
	        if (this.uac_pending_reply === true) {
	          request.reply(491);
	        } else if (this.uas_pending_reply === true) {
	          var retryAfter = (Math.random() * 10 | 0) + 1;
	          request.reply(500, null, ['Retry-After:' + retryAfter]);
	          return false;
	        } else {
	          this.uas_pending_reply = true;
	          request.server_transaction.on('stateChanged', function stateChanged(){
	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
	                this.state === SIP.Transactions.C.STATUS_COMPLETED ||
	                this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	
	              this.removeListener('stateChanged', stateChanged);
	              self.uas_pending_reply = false;
	
	              if (self.uac_pending_reply === false) {
	                self.owner.onReadyToReinvite();
	              }
	            }
	          });
	        }
	
	        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted
	        if(request.hasHeader('contact')) {
	          request.server_transaction.on('stateChanged', function(){
	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {
	              self.remote_target = request.parseHeader('contact').uri;
	            }
	          });
	        }
	        break;
	      case SIP.C.NOTIFY:
	        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted
	        if(request.hasHeader('contact')) {
	          request.server_transaction.on('stateChanged', function(){
	            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {
	              self.remote_target = request.parseHeader('contact').uri;
	            }
	          });
	        }
	        break;
	    }
	
	    return true;
	  },
	
	  sendRequest: function(applicant, method, options) {
	    options = options || {};
	
	    var
	      extraHeaders = (options.extraHeaders || []).slice(),
	      body = options.body || null,
	      request = this.createRequest(method, extraHeaders, body),
	      request_sender = new RequestSender(this, applicant, request);
	
	    request_sender.send();
	
	    return request;
	  },
	
	  /**
	  * @param {SIP.IncomingRequest} request
	  */
	  receiveRequest: function(request) {
	    //Check in-dialog request
	    if(!this.checkInDialogRequest(request)) {
	      return;
	    }
	
	    this.owner.receiveRequest(request);
	  }
	};
	
	Dialog.C = C;
	SIP.Dialog = Dialog;
	};


/***/ },
/* 227 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview In-Dialog Request Sender
	 */
	
	/**
	 * @augments SIP.Dialog
	 * @class Class creating an In-dialog request sender.
	 * @param {SIP.Dialog} dialog
	 * @param {Object} applicant
	 * @param {SIP.OutgoingRequest} request
	 */
	/**
	 * @fileoverview in-Dialog Request Sender
	 */
	
	module.exports = function (SIP) {
	var RequestSender;
	
	RequestSender = function(dialog, applicant, request) {
	
	  this.dialog = dialog;
	  this.applicant = applicant;
	  this.request = request;
	
	  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.
	  this.reattempt = false;
	  this.reattemptTimer = null;
	};
	
	RequestSender.prototype = {
	  send: function() {
	    var self = this,
	      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);
	
	      request_sender.send();
	
	    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-
	    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
	      this.dialog.uac_pending_reply = true;
	      request_sender.clientTransaction.on('stateChanged', function stateChanged(){
	        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
	            this.state === SIP.Transactions.C.STATUS_COMPLETED ||
	            this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	
	          this.removeListener('stateChanged', stateChanged);
	          self.dialog.uac_pending_reply = false;
	
	          if (self.dialog.uas_pending_reply === false) {
	            self.dialog.owner.onReadyToReinvite();
	          }
	        }
	      });
	    }
	  },
	
	  onRequestTimeout: function() {
	    this.applicant.onRequestTimeout();
	  },
	
	  onTransportError: function() {
	    this.applicant.onTransportError();
	  },
	
	  receiveResponse: function(response) {
	    var self = this;
	
	    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.
	    if (response.status_code === 408 || response.status_code === 481) {
	      this.applicant.onDialogError(response);
	    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {
	      if (this.reattempt) {
	        this.applicant.receiveResponse(response);
	      } else {
	        this.request.cseq.value = this.dialog.local_seqnum += 1;
	        this.reattemptTimer = SIP.Timers.setTimeout(
	          function() {
	            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {
	              self.reattempt = true;
	              self.request_sender.send();
	            }
	          },
	          this.getReattemptTimeout()
	        );
	      }
	    } else {
	      this.applicant.receiveResponse(response);
	    }
	  }
	};
	
	return RequestSender;
	};


/***/ },
/* 228 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview Request Sender
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a request sender.
	 * @param {Object} applicant
	 * @param {SIP.UA} ua
	 */
	module.exports = function (SIP) {
	var RequestSender;
	
	RequestSender = function(applicant, ua) {
	  this.logger = ua.getLogger('sip.requestsender');
	  this.ua = ua;
	  this.applicant = applicant;
	  this.method = applicant.request.method;
	  this.request = applicant.request;
	  this.credentials = null;
	  this.challenged = false;
	  this.staled = false;
	
	  // If ua is in closing process or even closed just allow sending Bye and ACK
	  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {
	    this.onTransportError();
	  }
	};
	
	/**
	* Create the client transaction and send the message.
	*/
	RequestSender.prototype = {
	  send: function() {
	    switch(this.method) {
	      case "INVITE":
	        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);
	        break;
	      case "ACK":
	        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);
	        break;
	      default:
	        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);
	    }
	    this.clientTransaction.send();
	
	    return this.clientTransaction;
	  },
	
	  /**
	  * Callback fired when receiving a request timeout error from the client transaction.
	  * To be re-defined by the applicant.
	  * @event
	  */
	  onRequestTimeout: function() {
	    this.applicant.onRequestTimeout();
	  },
	
	  /**
	  * Callback fired when receiving a transport error from the client transaction.
	  * To be re-defined by the applicant.
	  * @event
	  */
	  onTransportError: function() {
	    this.applicant.onTransportError();
	  },
	
	  /**
	  * Called from client transaction when receiving a correct response to the request.
	  * Authenticate request if needed or pass the response back to the applicant.
	  * @param {SIP.IncomingResponse} response
	  */
	  receiveResponse: function(response) {
	    var cseq, challenge, authorization_header_name,
	      status_code = response.status_code;
	
	    /*
	    * Authentication
	    * Authenticate once. _challenged_ flag used to avoid infinite authentications.
	    */
	    if (status_code === 401 || status_code === 407) {
	
	      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
	      if (response.status_code === 401) {
	        challenge = response.parseHeader('www-authenticate');
	        authorization_header_name = 'authorization';
	      } else {
	        challenge = response.parseHeader('proxy-authenticate');
	        authorization_header_name = 'proxy-authorization';
	      }
	
	      // Verify it seems a valid challenge.
	      if (! challenge) {
	        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');
	        this.applicant.receiveResponse(response);
	        return;
	      }
	
	      if (!this.challenged || (!this.staled && challenge.stale === true)) {
	        if (!this.credentials) {
	          this.credentials = this.ua.configuration.authenticationFactory(this.ua);
	        }
	
	        // Verify that the challenge is really valid.
	        if (!this.credentials.authenticate(this.request, challenge)) {
	          this.applicant.receiveResponse(response);
	          return;
	        }
	        this.challenged = true;
	
	        if (challenge.stale) {
	          this.staled = true;
	        }
	
	        if (response.method === SIP.C.REGISTER) {
	          cseq = this.applicant.cseq += 1;
	        } else if (this.request.dialog){
	          cseq = this.request.dialog.local_seqnum += 1;
	        } else {
	          cseq = this.request.cseq + 1;
	          this.request.cseq = cseq;
	        }
	        this.request.setHeader('cseq', cseq +' '+ this.method);
	
	        this.request.setHeader(authorization_header_name, this.credentials.toString());
	        this.send();
	      } else {
	        this.applicant.receiveResponse(response);
	      }
	    } else {
	      this.applicant.receiveResponse(response);
	    }
	  }
	};
	
	SIP.RequestSender = RequestSender;
	};


/***/ },
/* 229 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	
	var RegisterContext;
	
	RegisterContext = function (ua) {
	  var params = {},
	      regId = 1;
	
	  this.registrar = ua.configuration.registrarServer;
	  this.expires = ua.configuration.registerExpires;
	
	
	  // Contact header
	  this.contact = ua.contact.toString();
	
	  if(regId) {
	    this.contact += ';reg-id='+ regId;
	    this.contact += ';+sip.instance="<urn:uuid:'+ ua.configuration.instanceId+'>"';
	  }
	
	  // Call-ID and CSeq values RFC3261 10.2
	  this.call_id = SIP.Utils.createRandomToken(22);
	  this.cseq = 80;
	
	  this.to_uri = ua.configuration.uri;
	
	  params.to_uri = this.to_uri;
	  params.to_displayName = ua.configuration.displayName;
	  params.call_id = this.call_id;
	  params.cseq = this.cseq;
	
	  // Extends ClientContext
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);
	
	  this.registrationTimer = null;
	  this.registrationExpiredTimer = null;
	
	  // Set status
	  this.registered = false;
	
	  this.logger = ua.getLogger('sip.registercontext');
	};
	
	RegisterContext.prototype = {
	  register: function (options) {
	    var self = this, extraHeaders;
	
	    // Handle Options
	    this.options = options || {};
	    extraHeaders = (this.options.extraHeaders || []).slice();
	    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);
	    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	
	    // Save original extraHeaders to be used in .close
	    this.closeHeaders = this.options.closeWithHeaders ?
	      (this.options.extraHeaders || []).slice() : [];
	
	    this.receiveResponse = function(response) {
	      var contact, expires,
	        contacts = response.getHeaders('contact').length,
	        cause;
	
	      // Discard responses to older REGISTER/un-REGISTER requests.
	      if(response.cseq !== this.cseq) {
	        return;
	      }
	
	      // Clear registration timer
	      if (this.registrationTimer !== null) {
	        SIP.Timers.clearTimeout(this.registrationTimer);
	        this.registrationTimer = null;
	      }
	
	      switch(true) {
	        case /^1[0-9]{2}$/.test(response.status_code):
	          this.emit('progress', response);
	          break;
	        case /^2[0-9]{2}$/.test(response.status_code):
	          this.emit('accepted', response);
	
	          if(response.hasHeader('expires')) {
	            expires = response.getHeader('expires');
	          }
	
	          if (this.registrationExpiredTimer !== null) {
	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	            this.registrationExpiredTimer = null;
	          }
	
	          // Search the Contact pointing to us and update the expires value accordingly.
	          if (!contacts) {
	            this.logger.warn('no Contact header in response to REGISTER, response ignored');
	            break;
	          }
	
	          while(contacts--) {
	            contact = response.parseHeader('contact', contacts);
	            if(contact.uri.user === this.ua.contact.uri.user) {
	              expires = contact.getParam('expires');
	              break;
	            } else {
	              contact = null;
	            }
	          }
	
	          if (!contact) {
	            this.logger.warn('no Contact header pointing to us, response ignored');
	            break;
	          }
	
	          if(!expires) {
	            expires = this.expires;
	          }
	
	          // Re-Register before the expiration interval has elapsed.
	          // For that, decrease the expires value. ie: 3 seconds
	          this.registrationTimer = SIP.Timers.setTimeout(function() {
	            self.registrationTimer = null;
	            self.register(self.options);
	          }, (expires * 1000) - 3000);
	          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {
	            self.logger.warn('registration expired');
	            if (self.registered) {
	              self.unregistered(null, SIP.C.causes.EXPIRES);
	            }
	          }, expires * 1000);
	
	          //Save gruu values
	          if (contact.hasParam('temp-gruu')) {
	            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/"/g,''));
	          }
	          if (contact.hasParam('pub-gruu')) {
	            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/"/g,''));
	          }
	
	          this.registered = true;
	          this.emit('registered', response || null);
	          break;
	        // Interval too brief RFC3261 10.2.8
	        case /^423$/.test(response.status_code):
	          if(response.hasHeader('min-expires')) {
	            // Increase our registration interval to the suggested minimum
	            this.expires = response.getHeader('min-expires');
	            // Attempt the registration again immediately
	            this.register(this.options);
	          } else { //This response MUST contain a Min-Expires header field
	            this.logger.warn('423 response received for REGISTER without Min-Expires');
	            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);
	          }
	          break;
	        default:
	          cause = SIP.Utils.sipErrorCause(response.status_code);
	          this.registrationFailure(response, cause);
	      }
	    };
	
	    this.onRequestTimeout = function() {
	      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);
	    };
	
	    this.onTransportError = function() {
	      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);
	    };
	
	    this.cseq++;
	    this.request.cseq = this.cseq;
	    this.request.setHeader('cseq', this.cseq + ' REGISTER');
	    this.request.extraHeaders = extraHeaders;
	    this.send();
	  },
	
	  registrationFailure: function (response, cause) {
	    this.emit('failed', response || null, cause || null);
	  },
	
	  onTransportClosed: function() {
	    this.registered_before = this.registered;
	    if (this.registrationTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationTimer);
	      this.registrationTimer = null;
	    }
	
	    if (this.registrationExpiredTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	      this.registrationExpiredTimer = null;
	    }
	
	    if(this.registered) {
	      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onTransportConnected: function() {
	    this.register(this.options);
	  },
	
	  close: function() {
	    var options = {
	      all: false,
	      extraHeaders: this.closeHeaders
	    };
	
	    this.registered_before = this.registered;
	    this.unregister(options);
	  },
	
	  unregister: function(options) {
	    var extraHeaders;
	
	    options = options || {};
	
	    if(!this.registered && !options.all) {
	      this.logger.warn('already unregistered');
	      return;
	    }
	
	    extraHeaders = (options.extraHeaders || []).slice();
	
	    this.registered = false;
	
	    // Clear the registration timer.
	    if (this.registrationTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationTimer);
	      this.registrationTimer = null;
	    }
	
	    if(options.all) {
	      extraHeaders.push('Contact: *');
	      extraHeaders.push('Expires: 0');
	    } else {
	      extraHeaders.push('Contact: '+ this.contact + ';expires=0');
	    }
	
	
	    this.receiveResponse = function(response) {
	      var cause;
	
	      switch(true) {
	        case /^1[0-9]{2}$/.test(response.status_code):
	          this.emit('progress', response);
	          break;
	        case /^2[0-9]{2}$/.test(response.status_code):
	          this.emit('accepted', response);
	          if (this.registrationExpiredTimer !== null) {
	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	            this.registrationExpiredTimer = null;
	          }
	          this.unregistered(response);
	          break;
	        default:
	          cause = SIP.Utils.sipErrorCause(response.status_code);
	          this.unregistered(response,cause);
	      }
	    };
	
	    this.onRequestTimeout = function() {
	      // Not actually unregistered...
	      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);
	    };
	
	    this.onTransportError = function() {
	      // Not actually unregistered...
	      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
	    };
	
	    this.cseq++;
	    this.request.cseq = this.cseq;
	    this.request.setHeader('cseq', this.cseq + ' REGISTER');
	    this.request.extraHeaders = extraHeaders;
	
	    this.send();
	  },
	
	  unregistered: function(response, cause) {
	    this.registered = false;
	    this.emit('unregistered', response || null, cause || null);
	  }
	
	};
	
	
	SIP.RegisterContext = RegisterContext;
	};


/***/ },
/* 230 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaHandler
	 */
	
	/* MediaHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 */
	module.exports = function (EventEmitter) {
	var MediaHandler = function(session, options) {
	  // keep jshint happy
	  session = session;
	  options = options;
	};
	
	MediaHandler.prototype = Object.create(EventEmitter.prototype, {
	  isReady: {value: function isReady () {}},
	
	  close: {value: function close () {}},
	
	  /**
	   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.
	   */
	  getDescription: {value: function getDescription (mediaHint) {
	    // keep jshint happy
	    mediaHint = mediaHint;
	  }},
	
	  /**
	  * Message reception.
	  * @param {String} type
	  * @param {String} description
	  */
	  setDescription: {value: function setDescription (description) {
	    // keep jshint happy
	    description = description;
	  }}
	});
	
	return MediaHandler;
	};


/***/ },
/* 231 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	var ClientContext;
	
	ClientContext = function (ua, method, target, options) {
	  var originalTarget = target;
	
	  // Validate arguments
	  if (target === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  this.ua = ua;
	  this.logger = ua.getLogger('sip.clientcontext');
	  this.method = method;
	  target = ua.normalizeTarget(target);
	  if (!target) {
	    throw new TypeError('Invalid target: ' + originalTarget);
	  }
	
	  /* Options
	   * - extraHeaders
	   * - params
	   * - contentType
	   * - body
	   */
	  options = Object.create(options || Object.prototype);
	  options.extraHeaders = (options.extraHeaders || []).slice();
	
	  if (options.contentType) {
	    this.contentType = options.contentType;
	    options.extraHeaders.push('Content-Type: ' + this.contentType);
	  }
	
	  // Build the request
	  this.request = new SIP.OutgoingRequest(this.method,
	                                         target,
	                                         this.ua,
	                                         options.params,
	                                         options.extraHeaders);
	  if (options.body) {
	    this.body = options.body;
	    this.request.body = this.body;
	  }
	
	  /* Set other properties from the request */
	  this.localIdentity = this.request.from;
	  this.remoteIdentity = this.request.to;
	
	  this.data = {};
	};
	ClientContext.prototype = Object.create(SIP.EventEmitter.prototype);
	
	ClientContext.prototype.send = function () {
	  (new SIP.RequestSender(this, this.ua)).send();
	  return this;
	};
	
	ClientContext.prototype.cancel = function (options) {
	  options = options || {};
	
	  var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
	  this.request.cancel(cancel_reason);
	
	  this.emit('cancel');
	};
	
	ClientContext.prototype.receiveResponse = function (response) {
	  var cause = SIP.Utils.getReasonPhrase(response.status_code);
	
	  switch(true) {
	    case /^1[0-9]{2}$/.test(response.status_code):
	      this.emit('progress', response, cause);
	      break;
	
	    case /^2[0-9]{2}$/.test(response.status_code):
	      if(this.ua.applicants[this]) {
	        delete this.ua.applicants[this];
	      }
	      this.emit('accepted', response, cause);
	      break;
	
	    default:
	      if(this.ua.applicants[this]) {
	        delete this.ua.applicants[this];
	      }
	      this.emit('rejected', response, cause);
	      this.emit('failed', response, cause);
	      break;
	  }
	
	};
	
	ClientContext.prototype.onRequestTimeout = function () {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	};
	
	ClientContext.prototype.onTransportError = function () {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	};
	
	SIP.ClientContext = ClientContext;
	};


/***/ },
/* 232 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	var ServerContext;
	
	ServerContext = function (ua, request) {
	  this.ua = ua;
	  this.logger = ua.getLogger('sip.servercontext');
	  this.request = request;
	  if (request.method === SIP.C.INVITE) {
	    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);
	  } else {
	    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);
	  }
	
	  if (request.body) {
	    this.body = request.body;
	  }
	  if (request.hasHeader('Content-Type')) {
	    this.contentType = request.getHeader('Content-Type');
	  }
	  this.method = request.method;
	
	  this.data = {};
	
	  this.localIdentity = request.to;
	  this.remoteIdentity = request.from;
	};
	
	ServerContext.prototype = Object.create(SIP.EventEmitter.prototype);
	
	ServerContext.prototype.progress = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 180);
	  options.minCode = 100;
	  options.maxCode = 199;
	  options.events = ['progress'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.accept = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 200);
	  options.minCode = 200;
	  options.maxCode = 299;
	  options.events = ['accepted'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.reject = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 480);
	  options.minCode = 300;
	  options.maxCode = 699;
	  options.events = ['rejected', 'failed'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.reply = function (options) {
	  options = options || {}; // This is okay, so long as we treat options as read-only in this method
	  var
	    statusCode = options.statusCode || 100,
	    minCode = options.minCode || 100,
	    maxCode = options.maxCode || 699,
	    reasonPhrase = SIP.Utils.getReasonPhrase(statusCode, options.reasonPhrase),
	    extraHeaders = options.extraHeaders || [],
	    body = options.body,
	    events = options.events || [],
	    response;
	
	  if (statusCode < minCode || statusCode > maxCode) {
	    throw new TypeError('Invalid statusCode: ' + statusCode);
	  }
	  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	  events.forEach(function (event) {
	    this.emit(event, response, reasonPhrase);
	  }, this);
	
	  return this;
	};
	
	ServerContext.prototype.onRequestTimeout = function () {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	};
	
	ServerContext.prototype.onTransportError = function () {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	};
	
	SIP.ServerContext = ServerContext;
	};


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function (SIP, environment) {
	
	var DTMF = __webpack_require__(234)(SIP);
	
	var Session, InviteServerContext, InviteClientContext,
	 C = {
	    //Session states
	    STATUS_NULL:                        0,
	    STATUS_INVITE_SENT:                 1,
	    STATUS_1XX_RECEIVED:                2,
	    STATUS_INVITE_RECEIVED:             3,
	    STATUS_WAITING_FOR_ANSWER:          4,
	    STATUS_ANSWERED:                    5,
	    STATUS_WAITING_FOR_PRACK:           6,
	    STATUS_WAITING_FOR_ACK:             7,
	    STATUS_CANCELED:                    8,
	    STATUS_TERMINATED:                  9,
	    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,
	    STATUS_EARLY_MEDIA:                11,
	    STATUS_CONFIRMED:                  12
	  };
	
	/*
	 * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]
	 *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)
	 */
	Session = function (mediaHandlerFactory) {
	  this.status = C.STATUS_NULL;
	  this.dialog = null;
	  this.earlyDialogs = {};
	  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;
	  // this.mediaHandler gets set by ICC/ISC constructors
	  this.hasOffer = false;
	  this.hasAnswer = false;
	
	  // Session Timers
	  this.timers = {
	    ackTimer: null,
	    expiresTimer: null,
	    invite2xxTimer: null,
	    userNoAnswerTimer: null,
	    rel1xxTimer: null,
	    prackTimer: null
	  };
	
	  // Session info
	  this.startTime = null;
	  this.endTime = null;
	  this.tones = null;
	
	  // Mute/Hold state
	  this.local_hold = false;
	  this.remote_hold = false;
	
	  this.pending_actions = {
	    actions: [],
	
	    length: function() {
	      return this.actions.length;
	    },
	
	    isPending: function(name){
	      var
	      idx = 0,
	      length = this.actions.length;
	
	      for (idx; idx<length; idx++) {
	        if (this.actions[idx].name === name) {
	          return true;
	        }
	      }
	      return false;
	    },
	
	    shift: function() {
	      return this.actions.shift();
	    },
	
	    push: function(name) {
	      this.actions.push({
	        name: name
	      });
	    },
	
	    pop: function(name) {
	      var
	      idx = 0,
	      length = this.actions.length;
	
	      for (idx; idx<length; idx++) {
	        if (this.actions[idx].name === name) {
	          this.actions.splice(idx,1);
	          length --;
	          idx--;
	        }
	      }
	    }
	   };
	
	  this.early_sdp = null;
	  this.rel100 = SIP.C.supported.UNSUPPORTED;
	};
	
	Session.prototype = {
	  dtmf: function(tones, options) {
	    var tone, dtmfs = [],
	        self = this;
	
	    options = options || {};
	
	    if (tones === undefined) {
	      throw new TypeError('Not enough arguments');
	    }
	
	    // Check Session Status
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    // Check tones
	    if ((typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {
	      throw new TypeError('Invalid tones: '+ tones);
	    }
	
	    tones = tones.toString().split('');
	
	    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }
	
	    if (this.tones) {
	      // Tones are already queued, just add to the queue
	      this.tones =  this.tones.concat(dtmfs);
	      return this;
	    }
	
	    var sendDTMF = function () {
	      var dtmf, timeout;
	
	      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {
	        // Stop sending DTMF
	        self.tones = null;
	        return this;
	      }
	
	      dtmf = self.tones.shift();
	
	      if (tone === ',') {
	        timeout = 2000;
	      } else {
	        dtmf.on('failed', function(){self.tones = null;});
	        dtmf.send(options);
	        timeout = dtmf.duration + dtmf.interToneGap;
	      }
	
	      // Set timeout for the next tone
	      SIP.Timers.setTimeout(sendDTMF, timeout);
	    };
	
	    this.tones = dtmfs;
	    sendDTMF();
	    return this;
	  },
	
	  bye: function(options) {
	    options = Object.create(options || Object.prototype);
	    var statusCode = options.statusCode;
	
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED) {
	      this.logger.error('Error: Attempted to send BYE in a terminated session.');
	      return this;
	    }
	
	    this.logger.log('terminating Session');
	
	    if (statusCode && (statusCode < 200 || statusCode >= 700)) {
	      throw new TypeError('Invalid statusCode: '+ statusCode);
	    }
	
	    options.receiveResponse = function () {};
	
	    return this.
	      sendRequest(SIP.C.BYE, options).
	      terminated();
	  },
	
	  refer: function(target, options) {
	    options = options || {};
	    var extraHeaders = (options.extraHeaders || []).slice(),
	        withReplaces =
	          target instanceof SIP.InviteServerContext ||
	          target instanceof SIP.InviteClientContext,
	        originalTarget = target;
	
	    if (target === undefined) {
	      throw new TypeError('Not enough arguments');
	    }
	
	    // Check Session Status
	    if (this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    // transform `target` so that it can be a Refer-To header value
	    if (withReplaces) {
	      //Attended Transfer
	      // B.transfer(C)
	      target = '"' + target.remoteIdentity.friendlyName + '" ' +
	        '<' + target.dialog.remote_target.toString() +
	        '?Replaces=' + target.dialog.id.call_id +
	        '%3Bto-tag%3D' + target.dialog.id.remote_tag +
	        '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';
	    } else {
	      //Blind Transfer
	      // normalizeTarget allows instances of SIP.URI to pass through unaltered,
	      // so try to make one ahead of time
	      try {
	        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;
	      } catch (e) {
	        this.logger.debug(".refer() cannot parse Refer_To from", target);
	        this.logger.debug("...falling through to normalizeTarget()");
	      }
	
	      // Check target validity
	      target = this.ua.normalizeTarget(target);
	      if (!target) {
	        throw new TypeError('Invalid target: ' + originalTarget);
	      }
	    }
	
	    extraHeaders.push('Contact: '+ this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	    extraHeaders.push('Refer-To: '+ target);
	
	    // Send the request
	    this.sendRequest(SIP.C.REFER, {
	      extraHeaders: extraHeaders,
	      body: options.body,
	      receiveResponse: function (response) {
	        if ( ! /^2[0-9]{2}$/.test(response.status_code) ) {
	          return;
	        }
	        // hang up only if we transferred to a SIP address
	        if (withReplaces || (target.scheme && target.scheme.match("^sips?$"))) {
	          this.terminate();
	        }
	      }.bind(this)
	    });
	    return this;
	  },
	
	  followRefer: function followRefer (callback) {
	    return function referListener (callback, request) {
	      // open non-SIP URIs if possible and keep session open
	      var referTo = request.parseHeader('refer-to');
	      var target = referTo.uri;
	      if (!target.scheme.match("^sips?$")) {
	        var targetString = target.toString();
	        if (typeof environment.open === "function") {
	          environment.open(targetString);
	        } else {
	          this.logger.warn("referred to non-SIP URI but `open` isn't in the environment: " + targetString);
	        }
	        return;
	      }
	
	      var extraHeaders = [];
	
	      /* Copy the Replaces query into a Replaces header */
	      /* TODO - make sure we don't copy a poorly formatted header? */
	      var replaces = target.getHeader('Replaces');
	      if (replaces !== undefined) {
	        extraHeaders.push('Replaces: ' + decodeURIComponent(replaces));
	      }
	
	      // don't embed headers into Request-URI of INVITE
	      target.clearHeaders();
	
	      /*
	        Harmless race condition.  Both sides of REFER
	        may send a BYE, but in the end the dialogs are destroyed.
	      */
	      var getReferMedia = this.mediaHandler.getReferMedia;
	      var mediaHint = getReferMedia ? getReferMedia.call(this.mediaHandler) : this.mediaHint;
	
	      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);
	
	      var referSession = this.ua.invite(target, {
	        media: mediaHint,
	        params: {
	          to_displayName: referTo.friendlyName
	        },
	        extraHeaders: extraHeaders
	      });
	
	      callback.call(this, request, referSession);
	
	      this.terminate();
	    }.bind(this, callback);
	  },
	
	  sendRequest: function(method,options) {
	    options = options || {};
	    var self = this;
	
	    var request = new SIP.OutgoingRequest(
	      method,
	      this.dialog.remote_target,
	      this.ua,
	      {
	        cseq: options.cseq || (this.dialog.local_seqnum += 1),
	        call_id: this.dialog.id.call_id,
	        from_uri: this.dialog.local_uri,
	        from_tag: this.dialog.id.local_tag,
	        to_uri: this.dialog.remote_uri,
	        to_tag: this.dialog.id.remote_tag,
	        route_set: this.dialog.route_set,
	        statusCode: options.statusCode,
	        reasonPhrase: options.reasonPhrase
	      },
	      options.extraHeaders || [],
	      options.body
	    );
	
	    new SIP.RequestSender({
	      request: request,
	      onRequestTimeout: function() {
	        self.onRequestTimeout();
	      },
	      onTransportError: function() {
	        self.onTransportError();
	      },
	      receiveResponse: options.receiveResponse || function(response) {
	        self.receiveNonInviteResponse(response);
	      }
	    }, this.ua).send();
	
	    // Emit the request event
	    this.emit(method.toLowerCase(), request);
	
	    return this;
	  },
	
	  close: function() {
	    var idx;
	
	    if(this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    this.logger.log('closing INVITE session ' + this.id);
	
	    // 1st Step. Terminate media.
	    if (this.mediaHandler){
	      this.mediaHandler.close();
	    }
	
	    // 2nd Step. Terminate signaling.
	
	    // Clear session timers
	    for(idx in this.timers) {
	      SIP.Timers.clearTimeout(this.timers[idx]);
	    }
	
	    // Terminate dialogs
	
	    // Terminate confirmed dialog
	    if(this.dialog) {
	      this.dialog.terminate();
	      delete this.dialog;
	    }
	
	    // Terminate early dialogs
	    for(idx in this.earlyDialogs) {
	      this.earlyDialogs[idx].terminate();
	      delete this.earlyDialogs[idx];
	    }
	
	    this.status = C.STATUS_TERMINATED;
	
	    delete this.ua.sessions[this.id];
	    return this;
	  },
	
	  createDialog: function(message, type, early) {
	    var dialog, early_dialog,
	      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],
	      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],
	      id = message.call_id + local_tag + remote_tag;
	
	    early_dialog = this.earlyDialogs[id];
	
	    // Early Dialog
	    if (early) {
	      if (early_dialog) {
	        return true;
	      } else {
	        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);
	
	        // Dialog has been successfully created.
	        if(early_dialog.error) {
	          this.logger.error(early_dialog.error);
	          this.failed(message, SIP.C.causes.INTERNAL_ERROR);
	          return false;
	        } else {
	          this.earlyDialogs[id] = early_dialog;
	          return true;
	        }
	      }
	    }
	    // Confirmed Dialog
	    else {
	      // In case the dialog is in _early_ state, update it
	      if (early_dialog) {
	        early_dialog.update(message, type);
	        this.dialog = early_dialog;
	        delete this.earlyDialogs[id];
	        for (var dia in this.earlyDialogs) {
	          this.earlyDialogs[dia].terminate();
	          delete this.earlyDialogs[dia];
	        }
	        return true;
	      }
	
	      // Otherwise, create a _confirmed_ dialog
	      dialog = new SIP.Dialog(this, message, type);
	
	      if(dialog.error) {
	        this.logger.error(dialog.error);
	        this.failed(message, SIP.C.causes.INTERNAL_ERROR);
	        return false;
	      } else {
	        this.to_tag = message.to_tag;
	        this.dialog = dialog;
	        return true;
	      }
	    }
	  },
	
	  /**
	  * Check if Session is ready for a re-INVITE
	  *
	  * @returns {Boolean}
	  */
	  isReadyToReinvite: function() {
	    return this.mediaHandler.isReady() &&
	      !this.dialog.uac_pending_reply &&
	      !this.dialog.uas_pending_reply;
	  },
	
	  /**
	   * Mute
	   */
	  mute: function(options) {
	    var ret = this.mediaHandler.mute(options);
	    if (ret) {
	      this.onmute(ret);
	    }
	  },
	
	  /**
	   * Unmute
	   */
	  unmute: function(options) {
	    var ret = this.mediaHandler.unmute(options);
	    if (ret) {
	      this.onunmute(ret);
	    }
	  },
	
	  /**
	   * Hold
	   */
	  hold: function(options) {
	
	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.mediaHandler.hold();
	
	    // Check if RTCSession is ready to send a reINVITE
	    if (!this.isReadyToReinvite()) {
	      /* If there is a pending 'unhold' action, cancel it and don't queue this one
	       * Else, if there isn't any 'hold' action, add this one to the queue
	       * Else, if there is already a 'hold' action, skip
	       */
	      if (this.pending_actions.isPending('unhold')) {
	        this.pending_actions.pop('unhold');
	      } else if (!this.pending_actions.isPending('hold')) {
	        this.pending_actions.push('hold');
	      }
	      return;
	    } else if (this.local_hold === true) {
	        return;
	    }
	
	    this.onhold('local');
	
	    options = options || {};
	    options.mangle = function(body){
	
	      // Don't receive media
	      // TODO - This will break for media streams with different directions.
	      if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(body)) {
	        body = body.replace(/(m=[^\r]*\r\n)/g, '$1a=sendonly\r\n');
	      } else {
	        body = body.replace(/a=sendrecv\r\n/g, 'a=sendonly\r\n');
	        body = body.replace(/a=recvonly\r\n/g, 'a=inactive\r\n');
	      }
	
	      return body;
	    };
	
	    this.sendReinvite(options);
	  },
	
	  /**
	   * Unhold
	   */
	  unhold: function(options) {
	
	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.mediaHandler.unhold();
	
	    if (!this.isReadyToReinvite()) {
	      /* If there is a pending 'hold' action, cancel it and don't queue this one
	       * Else, if there isn't any 'unhold' action, add this one to the queue
	       * Else, if there is already a 'unhold' action, skip
	       */
	      if (this.pending_actions.isPending('hold')) {
	        this.pending_actions.pop('hold');
	      } else if (!this.pending_actions.isPending('unhold')) {
	        this.pending_actions.push('unhold');
	      }
	      return;
	    } else if (this.local_hold === false) {
	      return;
	    }
	
	    this.onunhold('local');
	
	    this.sendReinvite(options);
	  },
	
	  /**
	   * isOnHold
	   */
	  isOnHold: function() {
	    return {
	      local: this.local_hold,
	      remote: this.remote_hold
	    };
	  },
	
	  /**
	   * In dialog INVITE Reception
	   * @private
	   */
	  receiveReinvite: function(request) {
	    var self = this;
	
	    if (!request.body) {
	      return;
	    }
	
	    if (request.getHeader('Content-Type') !== 'application/sdp') {
	      this.logger.warn('invalid Content-Type');
	      request.reply(415);
	      return;
	    }
	
	    this.mediaHandler.setDescription(request.body)
	    .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
	    .then(function(body) {
	      request.reply(200, null, ['Contact: ' + self.contact], body,
	        function() {
	          self.status = C.STATUS_WAITING_FOR_ACK;
	          self.setInvite2xxTimer(request, body);
	          self.setACKTimer();
	
	          // Are we holding?
	          var hold = (/a=(sendonly|inactive)/).test(request.body);
	
	          if (self.remote_hold && !hold) {
	            self.onunhold('remote');
	          } else if (!self.remote_hold && hold) {
	            self.onhold('remote');
	          }
	        });
	    })
	    .catch(function onFailure (e) {
	      var statusCode;
	      if (e instanceof SIP.Exceptions.GetDescriptionError) {
	        statusCode = 500;
	      } else {
	        self.logger.error(e);
	        statusCode = 488;
	      }
	      request.reply(statusCode);
	    });
	  },
	
	  sendReinvite: function(options) {
	    options = options || {};
	
	    var
	      self = this,
	      extraHeaders = (options.extraHeaders || []).slice(),
	      eventHandlers = options.eventHandlers || {},
	      mangle = options.mangle || null,
	      succeeded;
	
	    if (eventHandlers.succeeded) {
	      succeeded = eventHandlers.succeeded;
	    }
	    this.reinviteSucceeded = function(){
	      SIP.Timers.clearTimeout(self.timers.ackTimer);
	      SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
	      self.status = C.STATUS_CONFIRMED;
	      succeeded && succeeded.apply(this, arguments);
	    };
	    if (eventHandlers.failed) {
	      this.reinviteFailed = eventHandlers.failed;
	    } else {
	      this.reinviteFailed = function(){};
	    }
	
	    extraHeaders.push('Contact: ' + this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	    extraHeaders.push('Content-Type: application/sdp');
	
	    this.receiveResponse = this.receiveReinviteResponse;
	    //REVISIT
	    this.mediaHandler.getDescription(self.mediaHint)
	    .then(mangle)
	    .then(
	      function(body){
	        self.dialog.sendRequest(self, SIP.C.INVITE, {
	          extraHeaders: extraHeaders,
	          body: body
	        });
	      },
	      function() {
	        if (self.isReadyToReinvite()) {
	          self.onReadyToReinvite();
	        }
	        self.reinviteFailed();
	      }
	    );
	  },
	
	  receiveRequest: function (request) {
	    switch (request.method) {
	      case SIP.C.BYE:
	        request.reply(200);
	        if(this.status === C.STATUS_CONFIRMED) {
	          this.emit('bye', request);
	          this.terminated(request, SIP.C.causes.BYE);
	        }
	        break;
	      case SIP.C.INVITE:
	        if(this.status === C.STATUS_CONFIRMED) {
	          this.logger.log('re-INVITE received');
	          this.receiveReinvite(request);
	        }
	        break;
	      case SIP.C.INFO:
	        if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {
	          var body, tone, duration,
	              contentType = request.getHeader('content-type'),
	              reg_tone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/,
	              reg_duration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
	
	          if (contentType) {
	            if (contentType.match(/^application\/dtmf-relay/i)) {
	              if (request.body) {
	                body = request.body.split('\r\n', 2);
	                if (body.length === 2) {
	                  if (reg_tone.test(body[0])) {
	                    tone = body[0].replace(reg_tone,"$2");
	                  }
	                  if (reg_duration.test(body[1])) {
	                    duration = parseInt(body[1].replace(reg_duration,"$2"), 10);
	                  }
	                }
	              }
	
	              new DTMF(this, tone, {duration: duration}).init_incoming(request);
	            } else {
	              request.reply(415, null, ["Accept: application/dtmf-relay"]);
	            }
	          }
	        }
	        break;
	      case SIP.C.REFER:
	        if(this.status ===  C.STATUS_CONFIRMED) {
	          this.logger.log('REFER received');
	          var hasReferListener = this.listeners('refer').length,
	              notifyBody;
	
	          if (hasReferListener) {
	            request.reply(202, 'Accepted');
	            notifyBody = 'SIP/2.0 100 Trying';
	
	            this.sendRequest(SIP.C.NOTIFY, {
	              extraHeaders:[
	                'Event: refer',
	                'Subscription-State: terminated',
	                'Content-Type: message/sipfrag'
	              ],
	              body: notifyBody,
	              receiveResponse: function() {}
	            });
	
	            this.emit('refer', request);
	          } else {
	            // RFC 3515.2.4.2: 'the UA MAY decline the request.'
	            request.reply(603, 'Declined');
	          }
	        }
	        break;
	      case SIP.C.NOTIFY:
	        request.reply(200, 'OK');
	        this.emit('notify', request);
	        break;
	    }
	  },
	
	  /**
	   * Reception of Response for in-dialog INVITE
	   * @private
	   */
	  receiveReinviteResponse: function(response) {
	    var self = this,
	        contentType = response.getHeader('Content-Type');
	
	    if (this.status === C.STATUS_TERMINATED) {
	      return;
	    }
	
	    switch(true) {
	      case /^1[0-9]{2}$/.test(response.status_code):
	        break;
	      case /^2[0-9]{2}$/.test(response.status_code):
	        this.status = C.STATUS_CONFIRMED;
	
	        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});
	
	        if(!response.body) {
	          this.reinviteFailed();
	          break;
	        } else if (contentType !== 'application/sdp') {
	          this.reinviteFailed();
	          break;
	        }
	
	        //REVISIT
	        this.mediaHandler.setDescription(response.body)
	        .then(
	          function onSuccess () {
	            self.reinviteSucceeded();
	          },
	          function onFailure () {
	            self.reinviteFailed();
	          }
	        );
	        break;
	      default:
	        this.reinviteFailed();
	    }
	  },
	
	  acceptAndTerminate: function(response, status_code, reason_phrase) {
	    var extraHeaders = [];
	
	    if (status_code) {
	      extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));
	    }
	
	    // An error on dialog creation will fire 'failed' event
	    if (this.dialog || this.createDialog(response, 'UAC')) {
	      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
	      this.sendRequest(SIP.C.BYE, {
	        extraHeaders: extraHeaders
	      });
	    }
	
	    return this;
	  },
	
	  /**
	   * RFC3261 13.3.1.4
	   * Response retransmissions cannot be accomplished by transaction layer
	   *  since it is destroyed when receiving the first 2xx answer
	   */
	  setInvite2xxTimer: function(request, body) {
	    var self = this,
	        timeout = SIP.Timers.T1;
	
	    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {
	      if (self.status !== C.STATUS_WAITING_FOR_ACK) {
	        return;
	      }
	
	      self.logger.log('no ACK received, attempting to retransmit OK');
	
	      request.reply(200, null, ['Contact: ' + self.contact], body);
	
	      timeout = Math.min(timeout * 2, SIP.Timers.T2);
	
	      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);
	    }, timeout);
	  },
	
	  /**
	   * RFC3261 14.2
	   * If a UAS generates a 2xx response and never receives an ACK,
	   *  it SHOULD generate a BYE to terminate the dialog.
	   */
	  setACKTimer: function() {
	    var self = this;
	
	    this.timers.ackTimer = SIP.Timers.setTimeout(function() {
	      if(self.status === C.STATUS_WAITING_FOR_ACK) {
	        self.logger.log('no ACK received for an extended period of time, terminating the call');
	        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
	        self.sendRequest(SIP.C.BYE);
	        self.terminated(null, SIP.C.causes.NO_ACK);
	      }
	    }, SIP.Timers.TIMER_H);
	  },
	
	  /*
	   * @private
	   */
	  onReadyToReinvite: function() {
	    var action = this.pending_actions.shift();
	
	    if (!action || !this[action.name]) {
	      return;
	    }
	
	    this[action.name]();
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  },
	
	  onDialogError: function(response) {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(response, SIP.C.causes.DIALOG_ERROR);
	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
	    }
	  },
	
	  /**
	   * @private
	   */
	  onhold: function(originator) {
	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;
	    this.emit('hold', { originator: originator });
	  },
	
	  /**
	   * @private
	   */
	  onunhold: function(originator) {
	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;
	    this.emit('unhold', { originator: originator });
	  },
	
	  /*
	   * @private
	   */
	  onmute: function(options) {
	    this.emit('muted', {
	      audio: options.audio,
	      video: options.video
	    });
	  },
	
	  /*
	   * @private
	   */
	  onunmute: function(options) {
	    this.emit('unmuted', {
	      audio: options.audio,
	      video: options.video
	    });
	  },
	
	  failed: function(response, cause) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	    this.emit('failed', response || null, cause || null);
	    return this;
	  },
	
	  rejected: function(response, cause) {
	    this.emit('rejected',
	      response || null,
	      cause || null
	    );
	    return this;
	  },
	
	  canceled: function() {
	    this.emit('cancel');
	    return this;
	  },
	
	  accepted: function(response, cause) {
	    cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);
	
	    this.startTime = new Date();
	
	    if (this.replacee) {
	      this.replacee.emit('replaced', this);
	      this.replacee.terminate();
	    }
	    this.emit('accepted', response, cause);
	    return this;
	  },
	
	  terminated: function(message, cause) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    this.endTime = new Date();
	
	    this.close();
	    this.emit('terminated',
	      message || null,
	      cause || null
	    );
	    return this;
	  },
	
	  connecting: function(request) {
	    this.emit('connecting', { request: request });
	    return this;
	  }
	};
	
	Session.desugar = function desugar(options) {
	  if (environment.HTMLMediaElement && options instanceof environment.HTMLMediaElement) {
	    options = {
	      media: {
	        constraints: {
	          audio: true,
	          video: options.tagName === 'VIDEO'
	        },
	        render: {
	          remote: options
	        }
	      }
	    };
	  }
	  return options || {};
	};
	
	
	Session.C = C;
	SIP.Session = Session;
	
	
	InviteServerContext = function(ua, request) {
	  var expires,
	    self = this,
	    contentType = request.getHeader('Content-Type'),
	    contentDisp = request.parseHeader('Content-Disposition');
	
	  // Check body and content type
	  if ((!contentDisp && contentType !== 'application/sdp') || (contentDisp && contentDisp.type === 'render')) {
	    this.renderbody = request.body;
	    this.rendertype = contentType;
	  } else if (contentType !== 'application/sdp' && (contentDisp && contentDisp.type === 'session')) {
	    request.reply(415);
	    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it
	    return;
	  }
	
	  //TODO: move this into media handler
	  SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);
	  SIP.Hacks.AllBrowsers.maskDtls(request);
	
	  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);
	  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);
	
	  this.status = C.STATUS_INVITE_RECEIVED;
	  this.from_tag = request.from_tag;
	  this.id = request.call_id + this.from_tag;
	  this.request = request;
	  this.contact = this.ua.contact.toString();
	
	  this.receiveNonInviteResponse = function () {}; // intentional no-op
	
	  this.logger = ua.getLogger('sip.inviteservercontext', this.id);
	
	  //Save the session into the ua sessions collection.
	  this.ua.sessions[this.id] = this;
	
	  //Get the Expires header value if exists
	  if(request.hasHeader('expires')) {
	    expires = request.getHeader('expires') * 1000;
	  }
	
	  //Set 100rel if necessary
	  function set100rel(h,c) {
	    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {
	      self.rel100 = c;
	    }
	  }
	  set100rel('require', SIP.C.supported.REQUIRED);
	  set100rel('supported', SIP.C.supported.SUPPORTED);
	
	  /* Set the to_tag before
	   * replying a response code that will create a dialog.
	   */
	  request.to_tag = SIP.Utils.newTag();
	
	  // An error on dialog creation will fire 'failed' event
	  if(!this.createDialog(request, 'UAS', true)) {
	    request.reply(500, 'Missing Contact header field');
	    return;
	  }
	
	  //Initialize Media Session
	  this.mediaHandler = this.mediaHandlerFactory(this, {
	    RTCConstraints: {"optional": [{'DtlsSrtpKeyAgreement': 'true'}]}
	  });
	
	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
	  }
	
	  function fireNewSession() {
	    var options = {extraHeaders: ['Contact: ' + self.contact]};
	
	    if (self.rel100 !== SIP.C.supported.REQUIRED) {
	      self.progress(options);
	    }
	    self.status = C.STATUS_WAITING_FOR_ANSWER;
	
	    // Set userNoAnswerTimer
	    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {
	      request.reply(408);
	      self.failed(request, SIP.C.causes.NO_ANSWER);
	      self.terminated(request, SIP.C.causes.NO_ANSWER);
	    }, self.ua.configuration.noAnswerTimeout);
	
	    /* Set expiresTimer
	     * RFC3261 13.3.1
	     */
	    if (expires) {
	      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {
	        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {
	          request.reply(487);
	          self.failed(request, SIP.C.causes.EXPIRES);
	          self.terminated(request, SIP.C.causes.EXPIRES);
	        }
	      }, expires);
	    }
	
	    self.emit('invite',request);
	  }
	
	  if (!request.body || this.renderbody) {
	    SIP.Timers.setTimeout(fireNewSession, 0);
	  } else {
	    this.hasOffer = true;
	    this.mediaHandler.setDescription(request.body)
	    .then(
	      fireNewSession,
	      function onFailure (e) {
	        self.logger.warn('invalid SDP');
	        self.logger.warn(e);
	        request.reply(488);
	      }
	    );
	  }
	};
	
	InviteServerContext.prototype = {
	  reject: function(options) {
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.logger.log('rejecting RTCSession');
	
	    SIP.ServerContext.prototype.reject.call(this, options);
	    return this.terminated();
	  },
	
	  terminate: function(options) {
	    options = options || {};
	
	    var
	    extraHeaders = (options.extraHeaders || []).slice(),
	    body = options.body,
	    dialog,
	    self = this;
	
	    if (this.status === C.STATUS_WAITING_FOR_ACK &&
	       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
	      dialog = this.dialog;
	
	      this.receiveRequest = function(request) {
	        if (request.method === SIP.C.ACK) {
	          this.request(SIP.C.BYE, {
	            extraHeaders: extraHeaders,
	            body: body
	          });
	          dialog.terminate();
	        }
	      };
	
	      this.request.server_transaction.on('stateChanged', function(){
	        if (this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	          this.request = new SIP.OutgoingRequest(
	            SIP.C.BYE,
	            this.dialog.remote_target,
	            this.ua,
	            {
	              'cseq': this.dialog.local_seqnum+=1,
	              'call_id': this.dialog.id.call_id,
	              'from_uri': this.dialog.local_uri,
	              'from_tag': this.dialog.id.local_tag,
	              'to_uri': this.dialog.remote_uri,
	              'to_tag': this.dialog.id.remote_tag,
	              'route_set': this.dialog.route_set
	            },
	            extraHeaders,
	            body
	          );
	
	          new SIP.RequestSender(
	            {
	              request: this.request,
	              onRequestTimeout: function() {
	                self.onRequestTimeout();
	              },
	              onTransportError: function() {
	                self.onTransportError();
	              },
	              receiveResponse: function() {
	                return;
	              }
	            },
	            this.ua
	          ).send();
	          dialog.terminate();
	        }
	      });
	
	      this.emit('bye', this.request);
	      this.terminated();
	
	      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)
	      this.dialog = dialog;
	
	      // Restore the dialog into 'ua' so the ACK can reach 'this' session
	      this.ua.dialogs[dialog.id.toString()] = dialog;
	
	    } else if (this.status === C.STATUS_CONFIRMED) {
	      this.bye(options);
	    } else {
	      this.reject(options);
	    }
	
	    return this;
	  },
	
	  /*
	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	   */
	  progress: function (options) {
	    options = options || {};
	    var
	      statusCode = options.statusCode || 180,
	      reasonPhrase = options.reasonPhrase,
	      extraHeaders = (options.extraHeaders || []).slice(),
	      iceServers,
	      stunServers = options.stunServers || null,
	      turnServers = options.turnServers || null,
	      body = options.body,
	      response;
	
	    if (statusCode < 100 || statusCode > 199) {
	      throw new TypeError('Invalid statusCode: ' + statusCode);
	    }
	
	    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    if (stunServers || turnServers) {
	      if (stunServers) {
	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid stunServers: '+ stunServers);
	        } else {
	          this.stunServers = iceServers;
	        }
	      }
	
	      if (turnServers) {
	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid turnServers: '+ turnServers);
	        } else {
	          this.turnServers = iceServers;
	        }
	      }
	
	      this.mediaHandler.updateIceServers({
	        stunServers: this.stunServers,
	        turnServers: this.turnServers
	      });
	    }
	
	    function do100rel() {
	      /* jshint validthis: true */
	      statusCode = options.statusCode || 183;
	
	      // Set status and add extra headers
	      this.status = C.STATUS_WAITING_FOR_PRACK;
	      extraHeaders.push('Contact: '+ this.contact);
	      extraHeaders.push('Require: 100rel');
	      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));
	
	      // Save media hint for later (referred sessions)
	      this.mediaHint = options.media;
	
	      // Get the session description to add to preaccept with
	      this.mediaHandler.getDescription(options.media)
	      .then(
	        function onSuccess (body) {
	          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
	            return;
	          }
	
	          this.early_sdp = body;
	          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;
	
	          // Retransmit until we get a response or we time out (see prackTimer below)
	          var timeout = SIP.Timers.T1;
	          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {
	            this.request.reply(statusCode, null, extraHeaders, body);
	            timeout *= 2;
	            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);
	          }.bind(this), timeout);
	
	          // Timeout and reject INVITE if no response
	          this.timers.prackTimer = SIP.Timers.setTimeout(function () {
	            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {
	              return;
	            }
	
	            this.logger.log('no PRACK received, rejecting the call');
	            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	            this.request.reply(504);
	            this.terminated(null, SIP.C.causes.NO_PRACK);
	          }.bind(this), SIP.Timers.T1 * 64);
	
	          // Send the initial response
	          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	          this.emit('progress', response, reasonPhrase);
	        }.bind(this),
	
	        function onFailure () {
	          this.request.reply(480);
	          this.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          this.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	        }.bind(this)
	      );
	    } // end do100rel
	
	    function normalReply() {
	      /* jshint validthis:true */
	      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	      this.emit('progress', response, reasonPhrase);
	    }
	
	    if (options.statusCode !== 100 &&
	        (this.rel100 === SIP.C.supported.REQUIRED ||
	         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||
	         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {
	      do100rel.apply(this);
	    } else {
	      normalReply.apply(this);
	    }
	    return this;
	  },
	
	  /*
	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	   */
	  accept: function(options) {
	    options = Object.create(Session.desugar(options));
	    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
	    this.mediaHint = options.media;
	
	    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21
	    var
	      //idx, length, hasAudio, hasVideo,
	      self = this,
	      request = this.request,
	      extraHeaders = (options.extraHeaders || []).slice(),
	    //mediaStream = options.mediaStream || null,
	      iceServers,
	      stunServers = options.stunServers || null,
	      turnServers = options.turnServers || null,
	      sdpCreationSucceeded = function(body) {
	        var
	          response,
	          // run for reply success callback
	          replySucceeded = function() {
	            self.status = C.STATUS_WAITING_FOR_ACK;
	
	            self.setInvite2xxTimer(request, body);
	            self.setACKTimer();
	          },
	
	          // run for reply failure callback
	          replyFailed = function() {
	            self.failed(null, SIP.C.causes.CONNECTION_ERROR);
	            self.terminated(null, SIP.C.causes.CONNECTION_ERROR);
	          };
	
	        // Chrome might call onaddstream before accept() is called, which means
	        // mediaHandler.render() was called without a renderHint, so we need to
	        // re-render now that mediaHint.render has been set.
	        //
	        // Chrome seems to be in the right regarding this, see
	        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream
	        self.mediaHandler.render();
	
	        extraHeaders.push('Contact: ' + self.contact);
	        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	
	        if(!self.hasOffer) {
	          self.hasOffer = true;
	        } else {
	          self.hasAnswer = true;
	        }
	        response = request.reply(200, null, extraHeaders,
	                      body,
	                      replySucceeded,
	                      replyFailed
	                     );
	        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail
	          self.accepted(response, SIP.Utils.getReasonPhrase(200));
	        }
	      },
	
	      sdpCreationFailed = function() {
	        if (self.status === C.STATUS_TERMINATED) {
	          return;
	        }
	        // TODO - fail out on error
	        self.request.reply(480);
	        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
	        self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	        self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	      };
	
	    // Check Session Status
	    if (this.status === C.STATUS_WAITING_FOR_PRACK) {
	      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;
	      return this;
	    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {
	      this.status = C.STATUS_ANSWERED;
	    } else if (this.status !== C.STATUS_EARLY_MEDIA) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    if ((stunServers || turnServers) &&
	        (this.status !== C.STATUS_EARLY_MEDIA && this.status !== C.STATUS_ANSWERED_WAITING_FOR_PRACK)) {
	      if (stunServers) {
	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid stunServers: '+ stunServers);
	        } else {
	          this.stunServers = iceServers;
	        }
	      }
	
	      if (turnServers) {
	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid turnServers: '+ turnServers);
	        } else {
	          this.turnServers = iceServers;
	        }
	      }
	
	      this.mediaHandler.updateIceServers({
	        stunServers: this.stunServers,
	        turnServers: this.turnServers
	      });
	    }
	
	    // An error on dialog creation will fire 'failed' event
	    if(!this.createDialog(request, 'UAS')) {
	      request.reply(500, 'Missing Contact header field');
	      return this;
	    }
	
	    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);
	
	    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21
	    /*
	    length = this.getRemoteStreams().length;
	
	    for (idx = 0; idx < length; idx++) {
	      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {
	        hasVideo = true;
	      }
	      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {
	        hasAudio = true;
	      }
	    }
	
	    if (!hasAudio && this.mediaConstraints.audio === true) {
	      this.mediaConstraints.audio = false;
	      if (mediaStream) {
	        length = mediaStream.getAudioTracks().length;
	        for (idx = 0; idx < length; idx++) {
	          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);
	        }
	      }
	    }
	
	    if (!hasVideo && this.mediaConstraints.video === true) {
	      this.mediaConstraints.video = false;
	      if (mediaStream) {
	        length = mediaStream.getVideoTracks().length;
	        for (idx = 0; idx < length; idx++) {
	          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);
	        }
	      }
	    }
	    */
	
	    if (this.status === C.STATUS_EARLY_MEDIA) {
	      sdpCreationSucceeded();
	    } else {
	      this.mediaHandler.getDescription(self.mediaHint)
	      .then(
	        sdpCreationSucceeded,
	        sdpCreationFailed
	      );
	    }
	
	    return this;
	  },
	
	  receiveRequest: function(request) {
	
	    // ISC RECEIVE REQUEST
	
	    function confirmSession() {
	      /* jshint validthis:true */
	      var contentType;
	
	      SIP.Timers.clearTimeout(this.timers.ackTimer);
	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
	      this.status = C.STATUS_CONFIRMED;
	      this.unmute();
	
	      // TODO - this logic assumes Content-Disposition defaults
	      contentType = request.getHeader('Content-Type');
	      if (contentType !== 'application/sdp') {
	        this.renderbody = request.body;
	        this.rendertype = contentType;
	      }
	    }
	
	    switch(request.method) {
	    case SIP.C.CANCEL:
	      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
	       * was in progress and that the UAC MAY continue with the session established by
	       * any 2xx response, or MAY terminate with BYE. SIP does continue with the
	       * established session. So the CANCEL is processed only if the session is not yet
	       * established.
	       */
	
	      /*
	       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the
	       *request opening the session.
	       */
	      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||
	         this.status === C.STATUS_WAITING_FOR_PRACK ||
	         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||
	         this.status === C.STATUS_EARLY_MEDIA ||
	         this.status === C.STATUS_ANSWERED) {
	
	        this.status = C.STATUS_CANCELED;
	        this.request.reply(487);
	        this.canceled(request);
	        this.rejected(request, SIP.C.causes.CANCELED);
	        this.failed(request, SIP.C.causes.CANCELED);
	        this.terminated(request, SIP.C.causes.CANCELED);
	      }
	      break;
	    case SIP.C.ACK:
	      if(this.status === C.STATUS_WAITING_FOR_ACK) {
	        if (!this.hasAnswer) {
	          if(request.body && request.getHeader('content-type') === 'application/sdp') {
	            // ACK contains answer to an INVITE w/o SDP negotiation
	            SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);
	            SIP.Hacks.AllBrowsers.maskDtls(request);
	
	            this.hasAnswer = true;
	            this.mediaHandler.setDescription(request.body)
	            .then(
	              confirmSession.bind(this),
	              function onFailure (e) {
	                this.logger.warn(e);
	                this.terminate({
	                  statusCode: '488',
	                  reasonPhrase: 'Bad Media Description'
	                });
	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }.bind(this)
	            );
	          } else if (this.early_sdp) {
	            confirmSession.apply(this);
	          } else {
	            //TODO: Pass to mediahandler
	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	          }
	        } else {
	          confirmSession.apply(this);
	        }
	      }
	      break;
	    case SIP.C.PRACK:
	      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	        //localMedia = session.mediaHandler.localMedia;
	        if(!this.hasAnswer) {
	          if(request.body && request.getHeader('content-type') === 'application/sdp') {
	            this.hasAnswer = true;
	            this.mediaHandler.setDescription(request.body)
	            .then(
	              function onSuccess () {
	                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	                SIP.Timers.clearTimeout(this.timers.prackTimer);
	                request.reply(200);
	                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	                  this.status = C.STATUS_EARLY_MEDIA;
	                  this.accept();
	                }
	                this.status = C.STATUS_EARLY_MEDIA;
	                //REVISIT
	                this.mute();
	              }.bind(this),
	              function onFailure (e) {
	                //TODO: Send to media handler
	                this.logger.warn(e);
	                this.terminate({
	                  statusCode: '488',
	                  reasonPhrase: 'Bad Media Description'
	                });
	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }.bind(this)
	            );
	          } else {
	            this.terminate({
	              statusCode: '488',
	              reasonPhrase: 'Bad Media Description'
	            });
	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	          }
	        } else {
	          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	          SIP.Timers.clearTimeout(this.timers.prackTimer);
	          request.reply(200);
	
	          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	            this.status = C.STATUS_EARLY_MEDIA;
	            this.accept();
	          }
	          this.status = C.STATUS_EARLY_MEDIA;
	          //REVISIT
	          this.mute();
	        }
	      } else if(this.status === C.STATUS_EARLY_MEDIA) {
	        request.reply(200);
	      }
	      break;
	    default:
	      Session.prototype.receiveRequest.apply(this, [request]);
	      break;
	    }
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  }
	
	};
	
	SIP.InviteServerContext = InviteServerContext;
	
	InviteClientContext = function(ua, target, options) {
	  options = Object.create(Session.desugar(options));
	  options.params = Object.create(options.params || Object.prototype);
	
	  var iceServers,
	    extraHeaders = (options.extraHeaders || []).slice(),
	    stunServers = options.stunServers || null,
	    turnServers = options.turnServers || null,
	    mediaHandlerFactory = options.mediaHandlerFactory || ua.configuration.mediaHandlerFactory,
	    isMediaSupported = mediaHandlerFactory.isSupported;
	
	  // Check WebRTC support
	  if (isMediaSupported && !isMediaSupported()) {
	    throw new SIP.Exceptions.NotSupportedError('Media not supported');
	  }
	
	  this.RTCConstraints = options.RTCConstraints || {};
	  this.inviteWithoutSdp = options.inviteWithoutSdp || false;
	
	  // Set anonymous property
	  this.anonymous = options.anonymous || false;
	
	  // Custom data to be sent either in INVITE or in ACK
	  this.renderbody = options.renderbody || null;
	  this.rendertype = options.rendertype || 'text/plain';
	
	  options.params.from_tag = this.from_tag;
	
	  /* Do not add ;ob in initial forming dialog requests if the registration over
	   *  the current connection got a GRUU URI.
	   */
	  this.contact = ua.contact.toString({
	    anonymous: this.anonymous,
	    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu
	  });
	
	  if (this.anonymous) {
	    options.params.from_displayName = 'Anonymous';
	    options.params.from_uri = 'sip:anonymous@anonymous.invalid';
	
	    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());
	    extraHeaders.push('Privacy: id');
	  }
	  extraHeaders.push('Contact: '+ this.contact);
	  extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	  if (!this.inviteWithoutSdp) {
	    extraHeaders.push('Content-Type: application/sdp');
	  } else if (this.renderbody) {
	    extraHeaders.push('Content-Type: ' + this.rendertype);
	    extraHeaders.push('Content-Disposition: render;handling=optional');
	  }
	
	  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {
	    extraHeaders.push('Require: 100rel');
	  }
	  if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {
	    extraHeaders.push('Require: replaces');
	  }
	
	  options.extraHeaders = extraHeaders;
	
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);
	  SIP.Utils.augment(this, SIP.Session, [mediaHandlerFactory]);
	
	  // Check Session Status
	  if (this.status !== C.STATUS_NULL) {
	    throw new SIP.Exceptions.InvalidStateError(this.status);
	  }
	
	  // Session parameter initialization
	  this.from_tag = SIP.Utils.newTag();
	
	  // OutgoingSession specific parameters
	  this.isCanceled = false;
	  this.received_100 = false;
	
	  this.method = SIP.C.INVITE;
	
	  this.receiveNonInviteResponse = this.receiveResponse;
	  this.receiveResponse = this.receiveInviteResponse;
	
	  this.logger = ua.getLogger('sip.inviteclientcontext');
	
	  if (stunServers) {
	    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	    if (!iceServers) {
	      throw new TypeError('Invalid stunServers: '+ stunServers);
	    } else {
	      this.stunServers = iceServers;
	    }
	  }
	
	  if (turnServers) {
	    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	    if (!iceServers) {
	      throw new TypeError('Invalid turnServers: '+ turnServers);
	    } else {
	      this.turnServers = iceServers;
	    }
	  }
	
	  ua.applicants[this] = this;
	
	  this.id = this.request.call_id + this.from_tag;
	
	  //Initialize Media Session
	  this.mediaHandler = this.mediaHandlerFactory(this, {
	    RTCConstraints: this.RTCConstraints,
	    stunServers: this.stunServers,
	    turnServers: this.turnServers
	  });
	
	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
	  }
	
	  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
	  this.mediaHint = options.media;
	};
	
	InviteClientContext.prototype = {
	  invite: function () {
	    var self = this;
	
	    //Save the session into the ua sessions collection.
	    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway
	    this.ua.sessions[this.id] = this;
	
	    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level
	    // and hand sip.js a stream as the mediaHint
	    if (this.inviteWithoutSdp) {
	      //just send an invite with no sdp...
	      this.request.body = self.renderbody;
	      this.status = C.STATUS_INVITE_SENT;
	      this.send();
	    } else {
	      this.mediaHandler.getDescription(self.mediaHint)
	      .then(
	        function onSuccess(offer) {
	          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {
	            return;
	          }
	          self.hasOffer = true;
	          self.request.body = offer;
	          self.status = C.STATUS_INVITE_SENT;
	          self.send();
	        },
	        function onFailure() {
	          if (self.status === C.STATUS_TERMINATED) {
	            return;
	          }
	          // TODO...fail out
	          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
	          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	        }
	      );
	    }
	
	    return this;
	  },
	
	  receiveInviteResponse: function(response) {
	    var cause, //localMedia,
	      session = this,
	      id = response.call_id + response.from_tag + response.to_tag,
	      extraHeaders = [],
	      options = {};
	
	    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {
	      return;
	    }
	
	    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {
	      if (id !== this.dialog.id.toString() ) {
	        if (!this.createDialog(response, 'UAC', true)) {
	          return;
	        }
	        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,
	                                          {
	                                            body: SIP.Utils.generateFakeSDP(response.body)
	                                          });
	        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);
	
	        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable
	         * leg (due to peerConnection limitations) has been answered first. If your forking
	         * proxy does not hang up all unanswered branches on the first branch answered, remove this.
	         */
	        if(this.status !== C.STATUS_CONFIRMED) {
	          this.failed(response, SIP.C.causes.WEBRTC_ERROR);
	          this.terminated(response, SIP.C.causes.WEBRTC_ERROR);
	        }
	        return;
	      } else if (this.status === C.STATUS_CONFIRMED) {
	        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
	        return;
	      } else if (!this.hasAnswer) {
	        // invite w/o sdp is waiting for callback
	        //an invite with sdp must go on, and hasAnswer is true
	        return;
	      }
	    }
	
	    if (this.dialog && response.status_code < 200) {
	      /*
	        Early media has been set up with at least one other different branch,
	        but a final 2xx response hasn't been received
	      */
	      if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	          (this.dialog.pracked[this.dialog.pracked.length-1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0)) {
	        return;
	      }
	
	      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {
	        return;
	      }
	
	      if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	          (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
	        return;
	      }
	
	      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
	
	      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
	        extraHeaders: extraHeaders,
	        body: SIP.Utils.generateFakeSDP(response.body)
	      });
	      return;
	    }
	
	    // Proceed to cancellation if the user requested.
	    if(this.isCanceled) {
	      if(response.status_code >= 100 && response.status_code < 200) {
	        this.request.cancel(this.cancelReason);
	        this.canceled(null);
	      } else if(response.status_code >= 200 && response.status_code < 299) {
	        this.acceptAndTerminate(response);
	        this.emit('bye', this.request);
	      } else if (response.status_code >= 300) {
	        cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;
	        this.rejected(response, cause);
	        this.failed(response, cause);
	        this.terminated(response, cause);
	      }
	      return;
	    }
	
	    switch(true) {
	      case /^100$/.test(response.status_code):
	        this.received_100 = true;
	        this.emit('progress', response);
	        break;
	      case (/^1[0-9]{2}$/.test(response.status_code)):
	        // Do nothing with 1xx responses without To tag.
	        if(!response.to_tag) {
	          this.logger.warn('1xx response received without to tag');
	          break;
	        }
	
	        // Create Early Dialog if 1XX comes with contact
	        if(response.hasHeader('contact')) {
	          // An error on dialog creation will fire 'failed' event
	          if (!this.createDialog(response, 'UAC', true)) {
	            break;
	          }
	        }
	
	        this.status = C.STATUS_1XX_RECEIVED;
	
	        if(response.hasHeader('require') &&
	           response.getHeader('require').indexOf('100rel') !== -1) {
	
	          // Do nothing if this.dialog is already confirmed
	          if (this.dialog || !this.earlyDialogs[id]) {
	            break;
	          }
	
	          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
	            return;
	          }
	
	          SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);
	          SIP.Hacks.AllBrowsers.maskDtls(response);
	
	          if (!response.body) {
	            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
	            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
	              extraHeaders: extraHeaders
	            });
	            this.emit('progress', response);
	
	          } else if (this.hasOffer) {
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.hasAnswer = true;
	            this.dialog.pracked.push(response.getHeader('rseq'));
	
	            this.mediaHandler.setDescription(response.body)
	            .then(
	              function onSuccess () {
	                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	
	                session.sendRequest(SIP.C.PRACK, {
	                  extraHeaders: extraHeaders,
	                  receiveResponse: function() {}
	                });
	                session.status = C.STATUS_EARLY_MEDIA;
	                session.mute();
	                session.emit('progress', response);
	                /*
	                if (session.status === C.STATUS_EARLY_MEDIA) {
	                  localMedia = session.mediaHandler.localMedia;
	                  if (localMedia.getAudioTracks().length > 0) {
	                    localMedia.getAudioTracks()[0].enabled = false;
	                  }
	                  if (localMedia.getVideoTracks().length > 0) {
	                    localMedia.getVideoTracks()[0].enabled = false;
	                  }
	                }*/
	              },
	              function onFailure (e) {
	                session.logger.warn(e);
	                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
	                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }
	            );
	          } else {
	            var earlyDialog = this.earlyDialogs[id];
	            var earlyMedia = earlyDialog.mediaHandler;
	
	            earlyDialog.pracked.push(response.getHeader('rseq'));
	
	            earlyMedia.setDescription(response.body)
	            .then(earlyMedia.getDescription.bind(earlyMedia, session.mediaHint))
	            .then(function onSuccess(sdp) {
	              extraHeaders.push('Content-Type: application/sdp');
	              extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	              earlyDialog.sendRequest(session, SIP.C.PRACK, {
	                extraHeaders: extraHeaders,
	                body: sdp
	              });
	              session.status = C.STATUS_EARLY_MEDIA;
	              session.emit('progress', response);
	            })
	            .catch(function onFailure(e) {
	              if (e instanceof SIP.Exceptions.GetDescriptionError) {
	                earlyDialog.pracked.push(response.getHeader('rseq'));
	                if (session.status === C.STATUS_TERMINATED) {
	                  return;
	                }
	                // TODO - fail out on error
	                // session.failed(gum error);
	                session.failed(null, SIP.C.causes.WEBRTC_ERROR);
	                session.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	              } else {
	                earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1);
	                // Could not set remote description
	                session.logger.warn('invalid SDP');
	                session.logger.warn(e);
	              }
	            });
	          }
	        } else {
	          this.emit('progress', response);
	        }
	        break;
	      case /^2[0-9]{2}$/.test(response.status_code):
	        var cseq = this.request.cseq + ' ' + this.request.method;
	        if (cseq !== response.getHeader('cseq')) {
	          break;
	        }
	
	        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {
	          this.status = C.STATUS_CONFIRMED;
	          this.unmute();
	          /*localMedia = this.mediaHandler.localMedia;
	          if (localMedia.getAudioTracks().length > 0) {
	            localMedia.getAudioTracks()[0].enabled = true;
	          }
	          if (localMedia.getVideoTracks().length > 0) {
	            localMedia.getVideoTracks()[0].enabled = true;
	          }*/
	          options = {};
	          if (this.renderbody) {
	            extraHeaders.push('Content-Type: ' + this.rendertype);
	            options.extraHeaders = extraHeaders;
	            options.body = this.renderbody;
	          }
	          options.cseq = response.cseq;
	          this.sendRequest(SIP.C.ACK, options);
	          this.accepted(response);
	          break;
	        }
	        // Do nothing if this.dialog is already confirmed
	        if (this.dialog) {
	          break;
	        }
	
	        SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);
	        SIP.Hacks.AllBrowsers.maskDtls(response);
	
	        // This is an invite without sdp
	        if (!this.hasOffer) {
	          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {
	            //REVISIT
	            this.hasOffer = true;
	            this.hasAnswer = true;
	            this.mediaHandler = this.earlyDialogs[id].mediaHandler;
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.status = C.STATUS_CONFIRMED;
	            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});
	
	            this.unmute();
	            /*
	            localMedia = session.mediaHandler.localMedia;
	            if (localMedia.getAudioTracks().length > 0) {
	              localMedia.getAudioTracks()[0].enabled = true;
	            }
	            if (localMedia.getVideoTracks().length > 0) {
	              localMedia.getVideoTracks()[0].enabled = true;
	            }*/
	            this.accepted(response);
	          } else {
	            if(!response.body) {
	              this.acceptAndTerminate(response, 400, 'Missing session description');
	              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              break;
	            }
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.hasOffer = true;
	            this.mediaHandler.setDescription(response.body)
	            .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
	            .then(function onSuccess(sdp) {
	              //var localMedia;
	              if(session.isCanceled || session.status === C.STATUS_TERMINATED) {
	                return;
	              }
	
	              sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);
	
	              session.status = C.STATUS_CONFIRMED;
	              session.hasAnswer = true;
	
	              session.unmute();
	              /*localMedia = session.mediaHandler.localMedia;
	              if (localMedia.getAudioTracks().length > 0) {
	                localMedia.getAudioTracks()[0].enabled = true;
	              }
	              if (localMedia.getVideoTracks().length > 0) {
	                localMedia.getVideoTracks()[0].enabled = true;
	              }*/
	              session.sendRequest(SIP.C.ACK,{
	                body: sdp,
	                extraHeaders:['Content-Type: application/sdp'],
	                cseq:response.cseq
	              });
	              session.accepted(response);
	            })
	            .catch(function onFailure(e) {
	              if (e instanceof SIP.Exceptions.GetDescriptionError) {
	                // TODO do something here
	                session.logger.warn("there was a problem");
	              } else {
	                session.logger.warn('invalid SDP');
	                session.logger.warn(e);
	                response.reply(488);
	              }
	            });
	          }
	        } else if (this.hasAnswer){
	          if (this.renderbody) {
	            extraHeaders.push('Content-Type: ' + session.rendertype);
	            options.extraHeaders = extraHeaders;
	            options.body = this.renderbody;
	          }
	          this.sendRequest(SIP.C.ACK, options);
	        } else {
	          if(!response.body) {
	            this.acceptAndTerminate(response, 400, 'Missing session description');
	            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            break;
	          }
	          if (!this.createDialog(response, 'UAC')) {
	            break;
	          }
	          this.hasAnswer = true;
	          this.mediaHandler.setDescription(response.body)
	          .then(
	            function onSuccess () {
	              var options = {};//,localMedia;
	              session.status = C.STATUS_CONFIRMED;
	              session.unmute();
	              /*localMedia = session.mediaHandler.localMedia;
	              if (localMedia.getAudioTracks().length > 0) {
	                localMedia.getAudioTracks()[0].enabled = true;
	              }
	              if (localMedia.getVideoTracks().length > 0) {
	                localMedia.getVideoTracks()[0].enabled = true;
	              }*/
	              if (session.renderbody) {
	                extraHeaders.push('Content-Type: ' + session.rendertype);
	                options.extraHeaders = extraHeaders;
	                options.body = session.renderbody;
	              }
	              options.cseq = response.cseq;
	              session.sendRequest(SIP.C.ACK, options);
	              session.accepted(response);
	            },
	            function onFailure (e) {
	              session.logger.warn(e);
	              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
	              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            }
	          );
	        }
	        break;
	      default:
	        cause = SIP.Utils.sipErrorCause(response.status_code);
	        this.rejected(response, cause);
	        this.failed(response, cause);
	        this.terminated(response, cause);
	    }
	  },
	
	  cancel: function(options) {
	    options = options || {};
	
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.logger.log('canceling RTCSession');
	
	    var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
	
	    // Check Session Status
	    if (this.status === C.STATUS_NULL ||
	        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {
	      this.isCanceled = true;
	      this.cancelReason = cancel_reason;
	    } else if (this.status === C.STATUS_INVITE_SENT ||
	               this.status === C.STATUS_1XX_RECEIVED ||
	               this.status === C.STATUS_EARLY_MEDIA) {
	      this.request.cancel(cancel_reason);
	    }
	
	    return this.canceled();
	  },
	
	  terminate: function(options) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {
	      this.bye(options);
	    } else {
	      this.cancel(options);
	    }
	
	    return this;
	  },
	
	  receiveRequest: function(request) {
	    // ICC RECEIVE REQUEST
	
	    // Reject CANCELs
	    if (request.method === SIP.C.CANCEL) {
	      // TODO; make this a switch when it gets added
	    }
	
	    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {
	      SIP.Timers.clearTimeout(this.timers.ackTimer);
	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
	      this.status = C.STATUS_CONFIRMED;
	      this.unmute();
	
	      this.accepted();
	    }
	
	    return Session.prototype.receiveRequest.apply(this, [request]);
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  }
	
	};
	
	SIP.InviteClientContext = InviteClientContext;
	
	};


/***/ },
/* 234 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview DTMF
	 */
	
	/**
	 * @class DTMF
	 * @param {SIP.Session} session
	 */
	module.exports = function (SIP) {
	
	var DTMF,
	  C = {
	    MIN_DURATION:            70,
	    MAX_DURATION:            6000,
	    DEFAULT_DURATION:        100,
	    MIN_INTER_TONE_GAP:      50,
	    DEFAULT_INTER_TONE_GAP:  500
	  };
	
	DTMF = function(session, tone, options) {
	  var duration, interToneGap;
	
	  if (tone === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);
	  this.owner = session;
	  this.direction = null;
	
	  options = options || {};
	  duration = options.duration || null;
	  interToneGap = options.interToneGap || null;
	
	  // Check tone type
	  if (typeof tone === 'string' ) {
	    tone = tone.toUpperCase();
	  } else if (typeof tone === 'number') {
	    tone = tone.toString();
	  } else {
	    throw new TypeError('Invalid tone: '+ tone);
	  }
	
	  // Check tone value
	  if (!tone.match(/^[0-9A-D#*]$/)) {
	    throw new TypeError('Invalid tone: '+ tone);
	  } else {
	    this.tone = tone;
	  }
	
	  // Check duration
	  if (duration && !SIP.Utils.isDecimal(duration)) {
	    throw new TypeError('Invalid tone duration: '+ duration);
	  } else if (!duration) {
	    duration = DTMF.C.DEFAULT_DURATION;
	  } else if (duration < DTMF.C.MIN_DURATION) {
	    this.logger.warn('"duration" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');
	    duration = DTMF.C.MIN_DURATION;
	  } else if (duration > DTMF.C.MAX_DURATION) {
	    this.logger.warn('"duration" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');
	    duration = DTMF.C.MAX_DURATION;
	  } else {
	    duration = Math.abs(duration);
	  }
	  this.duration = duration;
	
	  // Check interToneGap
	  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {
	    throw new TypeError('Invalid interToneGap: '+ interToneGap);
	  } else if (!interToneGap) {
	    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;
	  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {
	    this.logger.warn('"interToneGap" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');
	    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;
	  } else {
	    interToneGap = Math.abs(interToneGap);
	  }
	  this.interToneGap = interToneGap;
	};
	DTMF.prototype = Object.create(SIP.EventEmitter.prototype);
	
	
	DTMF.prototype.send = function(options) {
	  var extraHeaders, body;
	
	  this.direction = 'outgoing';
	
	  // Check RTCSession Status
	  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&
	    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {
	    throw new SIP.Exceptions.InvalidStateError(this.owner.status);
	  }
	
	  // Get DTMF options
	  options = options || {};
	  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
	
	  extraHeaders.push('Content-Type: application/dtmf-relay');
	
	  body = "Signal= " + this.tone + "\r\n";
	  body += "Duration= " + this.duration;
	
	  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {
	    extraHeaders: extraHeaders,
	    body: body
	  });
	
	  this.owner.emit('dtmf', this.request, this);
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.receiveResponse = function(response) {
	  var cause;
	
	  switch(true) {
	    case /^1[0-9]{2}$/.test(response.status_code):
	      // Ignore provisional responses.
	      break;
	
	    case /^2[0-9]{2}$/.test(response.status_code):
	      this.emit('succeeded', {
	        originator: 'remote',
	        response: response
	      });
	      break;
	
	    default:
	      cause = SIP.Utils.sipErrorCause(response.status_code);
	      this.emit('failed', response, cause);
	      break;
	  }
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onRequestTimeout = function() {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	  this.owner.onRequestTimeout();
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onTransportError = function() {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	  this.owner.onTransportError();
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onDialogError = function(response) {
	  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);
	  this.owner.onDialogError(response);
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.init_incoming = function(request) {
	  this.direction = 'incoming';
	  this.request = request;
	
	  request.reply(200);
	
	  if (!this.tone || !this.duration) {
	    this.logger.warn('invalid INFO DTMF received, discarded');
	  } else {
	    this.owner.emit('dtmf', request, this);
	  }
	};
	
	DTMF.C = C;
	return DTMF;
	};


/***/ },
/* 235 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP Subscription.
	 */
	module.exports = function (SIP) {
	SIP.Subscription = function (ua, target, event, options) {
	  options = Object.create(options || Object.prototype);
	  this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();
	
	  this.id = null;
	  this.state = 'init';
	
	  if (!event) {
	    throw new TypeError('Event necessary to create a subscription.');
	  } else {
	    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?
	    //The check may need to/should probably occur on the other side,
	    this.event = event;
	  }
	
	  if(typeof options.expires !== 'number'){
	    ua.logger.warn('expires must be a number. Using default of 3600.');
	    this.expires = 3600;
	  } else {
	    this.expires = options.expires;
	  }
	
	  options.extraHeaders.push('Event: ' + this.event);
	  options.extraHeaders.push('Expires: ' + this.expires);
	
	  if (options.body) {
	    this.body = options.body;
	  }
	
	  this.contact = ua.contact.toString();
	
	  options.extraHeaders.push('Contact: '+ this.contact);
	  options.extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);
	
	  this.logger = ua.getLogger('sip.subscription');
	
	  this.dialog = null;
	  this.timers = {N: null, sub_duration: null};
	  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];
	};
	
	SIP.Subscription.prototype = {
	  subscribe: function() {
	    var sub = this;
	
	     //these states point to an existing subscription, no subscribe is necessary
	    if (this.state === 'active') {
	      this.refresh();
	      return this;
	    } else if (this.state === 'notify_wait') {
	      return this;
	    }
	
	    SIP.Timers.clearTimeout(this.timers.sub_duration);
	    SIP.Timers.clearTimeout(this.timers.N);
	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
	
	    this.send();
	
	    this.state = 'notify_wait';
	
	    return this;
	  },
	
	  refresh: function () {
	    if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {
	      return;
	    }
	
	    this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {
	      extraHeaders: this.extraHeaders,
	      body: this.body
	    });
	  },
	
	  receiveResponse: function(response) {
	    var expires, sub = this,
	        cause = SIP.Utils.getReasonPhrase(response.status_code);
	
	    if ((this.state === 'notify_wait' && response.status_code >= 300) ||
	        (this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1)) {
	      this.failed(response, null);
	    } else if (/^2[0-9]{2}$/.test(response.status_code)){
	      expires = response.getHeader('Expires');
	      SIP.Timers.clearTimeout(this.timers.N);
	
	      if (this.createConfirmedDialog(response,'UAC')) {
	        this.id = this.dialog.id.toString();
	        this.ua.subscriptions[this.id] = this;
	        this.emit('accepted', response, cause);
	        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?
	      }
	
	      if (expires && expires <= this.expires) {
	        // Preserve new expires value for subsequent requests
	        this.expires = expires;
	        this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);
	      } else {
	        if (!expires) {
	          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');
	          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);
	        } else {
	          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');
	          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);
	        }
	      }
	    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx
	  },
	
	  unsubscribe: function() {
	    var extraHeaders = [], sub = this;
	
	    this.state = 'terminated';
	
	    extraHeaders.push('Event: ' + this.event);
	    extraHeaders.push('Expires: 0');
	
	    extraHeaders.push('Contact: '+ this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	
	    //makes sure expires isn't set, and other typical resubscribe behavior
	    this.receiveResponse = function(){};
	
	    this.dialog.sendRequest(this, this.method, {
	      extraHeaders: extraHeaders,
	      body: this.body
	    });
	
	    SIP.Timers.clearTimeout(this.timers.sub_duration);
	    SIP.Timers.clearTimeout(this.timers.N);
	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
	  },
	
	  /**
	  * @private
	  */
	  timer_fire: function(){
	    if (this.state === 'terminated') {
	      this.terminateDialog();
	      SIP.Timers.clearTimeout(this.timers.N);
	      SIP.Timers.clearTimeout(this.timers.sub_duration);
	
	      delete this.ua.subscriptions[this.id];
	    } else if (this.state === 'pending' || this.state === 'notify_wait') {
	      this.close();
	    } else {
	      this.refresh();
	    }
	  },
	
	  /**
	  * @private
	  */
	  close: function() {
	    if(this.state !== 'notify_wait' && this.state !== 'terminated') {
	      this.unsubscribe();
	    }
	  },
	
	  /**
	  * @private
	  */
	  createConfirmedDialog: function(message, type) {
	    var dialog;
	
	    this.terminateDialog();
	    dialog = new SIP.Dialog(this, message, type);
	
	    if(!dialog.error) {
	      this.dialog = dialog;
	      return true;
	    }
	    // Dialog not created due to an error
	    else {
	      return false;
	    }
	  },
	
	  /**
	  * @private
	  */
	  terminateDialog: function() {
	    if(this.dialog) {
	      delete this.ua.subscriptions[this.id];
	      this.dialog.terminate();
	      delete this.dialog;
	    }
	  },
	
	  /**
	  * @private
	  */
	  receiveRequest: function(request) {
	    var sub_state, sub = this;
	
	    function setExpiresTimeout() {
	      if (sub_state.expires) {
	        SIP.Timers.clearTimeout(sub.timers.sub_duration);
	        sub_state.expires = Math.min(sub.expires,
	                                     Math.max(sub_state.expires, 0));
	        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub),
	                                                    sub_state.expires * 900);
	      }
	    }
	
	    if (!this.matchEvent(request)) { //checks event and subscription_state headers
	      request.reply(489);
	      return;
	    }
	
	    sub_state = request.parseHeader('Subscription-State');
	
	    request.reply(200, SIP.C.REASON_200);
	
	    SIP.Timers.clearTimeout(this.timers.N);
	
	    this.emit('notify', {request: request});
	
	    // if we've set state to terminated, no further processing should take place
	    // and we are only interested in cleaning up after the appropriate NOTIFY
	    if (this.state === 'terminated') {
	      if (sub_state.state === 'terminated') {
	        this.terminateDialog();
	        SIP.Timers.clearTimeout(this.timers.N);
	        SIP.Timers.clearTimeout(this.timers.sub_duration);
	
	        delete this.ua.subscriptions[this.id];
	      }
	      return;
	    }
	
	    switch (sub_state.state) {
	      case 'active':
	        this.state = 'active';
	        setExpiresTimeout();
	        break;
	      case 'pending':
	        if (this.state === 'notify_wait') {
	          setExpiresTimeout();
	        }
	        this.state = 'pending';
	        break;
	      case 'terminated':
	        SIP.Timers.clearTimeout(this.timers.sub_duration);
	        if (sub_state.reason) {
	          this.logger.log('terminating subscription with reason '+ sub_state.reason);
	          switch (sub_state.reason) {
	            case 'deactivated':
	            case 'timeout':
	              this.subscribe();
	              return;
	            case 'probation':
	            case 'giveup':
	              if(sub_state.params && sub_state.params['retry-after']) {
	                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);
	              } else {
	                this.subscribe();
	              }
	              return;
	            case 'rejected':
	            case 'noresource':
	            case 'invariant':
	              break;
	          }
	        }
	        this.close();
	        break;
	    }
	  },
	
	  failed: function(response, cause) {
	    this.close();
	    this.emit('failed', response, cause);
	    return this;
	  },
	
	  onDialogError: function(response) {
	    this.failed(response, SIP.C.causes.DIALOG_ERROR);
	  },
	
	  /**
	  * @private
	  */
	  matchEvent: function(request) {
	    var event;
	
	    // Check mandatory header Event
	    if (!request.hasHeader('Event')) {
	      this.logger.warn('missing Event header');
	      return false;
	    }
	    // Check mandatory header Subscription-State
	    if (!request.hasHeader('Subscription-State')) {
	      this.logger.warn('missing Subscription-State header');
	      return false;
	    }
	
	    // Check whether the event in NOTIFY matches the event in SUBSCRIBE
	    event = request.parseHeader('event').event;
	
	    if (this.event !== event) {
	      this.logger.warn('event match failed');
	      request.reply(481, 'Event Match Failed');
	      return false;
	    } else {
	      return true;
	    }
	  }
	};
	};


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileoverview WebRTC
	 */
	
	module.exports = function (SIP, environment) {
	var WebRTC;
	
	WebRTC = {};
	
	WebRTC.MediaHandler = __webpack_require__(237)(SIP);
	WebRTC.MediaStreamManager = __webpack_require__(238)(SIP, environment);
	
	var _isSupported;
	
	WebRTC.isSupported = function () {
	  if (_isSupported !== undefined) {
	    return _isSupported;
	  }
	
	  WebRTC.MediaStream = environment.MediaStream;
	  WebRTC.getUserMedia = environment.getUserMedia;
	  WebRTC.RTCPeerConnection = environment.RTCPeerConnection;
	  WebRTC.RTCSessionDescription = environment.RTCSessionDescription;
	
	  if (WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {
	    if (WebRTC.getUserMedia) {
	      WebRTC.getUserMedia = SIP.Utils.promisify(environment, 'getUserMedia');
	    }
	    _isSupported = true;
	  }
	  else {
	    _isSupported = false;
	  }
	  return _isSupported;
	};
	
	return WebRTC;
	};


/***/ },
/* 237 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaHandler
	 */
	
	/* MediaHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]
	 *        The MediaStreamManager to acquire/release streams from/to.
	 *        If not provided, a default MediaStreamManager will be used.
	 */
	module.exports = function (SIP) {
	
	var MediaHandler = function(session, options) {
	  options = options || {};
	
	  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);
	  this.session = session;
	  this.localMedia = null;
	  this.ready = true;
	  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);
	  this.audioMuted = false;
	  this.videoMuted = false;
	
	  // old init() from here on
	  var servers = this.prepareIceServers(options.stunServers, options.turnServers);
	  this.RTCConstraints = options.RTCConstraints || {};
	
	  this.initPeerConnection(servers, this.RTCConstraints);
	
	  function selfEmit(mh, event) {
	    if (mh.mediaStreamManager.on) {
	      mh.mediaStreamManager.on(event, function () {
	        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));
	      });
	    }
	  }
	
	  selfEmit(this, 'userMediaRequest');
	  selfEmit(this, 'userMedia');
	  selfEmit(this, 'userMediaFailed');
	};
	
	MediaHandler.defaultFactory = function defaultFactory (session, options) {
	  return new MediaHandler(session, options);
	};
	MediaHandler.defaultFactory.isSupported = function () {
	  return SIP.WebRTC.isSupported();
	};
	
	MediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {
	// Functions the session can use
	  isReady: {writable: true, value: function isReady () {
	    return this.ready;
	  }},
	
	  close: {writable: true, value: function close () {
	    this.logger.log('closing PeerConnection');
	    this._remoteStreams = [];
	    // have to check signalingState since this.close() gets called multiple times
	    // TODO figure out why that happens
	    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {
	      this.peerConnection.close();
	
	      if(this.localMedia) {
	        this.mediaStreamManager.release(this.localMedia);
	      }
	    }
	  }},
	
	  /**
	   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]
	   *        the MediaStream (or the constraints describing it) to be used for the session
	   */
	  getDescription: {writable: true, value: function getDescription (mediaHint) {
	    var self = this;
	    var acquire = self.mediaStreamManager.acquire;
	    if (acquire.length > 1) {
	      acquire = SIP.Utils.promisify(this.mediaStreamManager, 'acquire', true);
	    }
	    mediaHint = mediaHint || {};
	    if (mediaHint.dataChannel === true) {
	      mediaHint.dataChannel = {};
	    }
	    this.mediaHint = mediaHint;
	
	    /*
	     * 1. acquire streams (skip if MediaStreams passed in)
	     * 2. addStreams
	     * 3. createOffer/createAnswer
	     */
	
	    var streamPromise;
	    if (self.localMedia) {
	      self.logger.log('already have local media');
	      streamPromise = SIP.Utils.Promise.resolve(self.localMedia);
	    }
	    else {
	      self.logger.log('acquiring local media');
	      streamPromise = acquire.call(self.mediaStreamManager, mediaHint)
	        .then(function acquireSucceeded(streams) {
	          self.logger.log('acquired local media streams');
	          self.localMedia = streams;
	          self.session.connecting();
	          return streams;
	        }, function acquireFailed(err) {
	          self.logger.error('unable to acquire streams');
	          self.logger.error(err);
	          self.session.connecting();
	          throw err;
	        })
	        .then(this.addStreams.bind(this))
	      ;
	    }
	
	    return streamPromise
	      .then(function streamAdditionSucceeded() {
	        if (self.hasOffer('remote')) {
	          self.peerConnection.ondatachannel = function (evt) {
	            self.dataChannel = evt.channel;
	            self.emit('dataChannel', self.dataChannel);
	          };
	        } else if (mediaHint.dataChannel &&
	                   self.peerConnection.createDataChannel) {
	          self.dataChannel = self.peerConnection.createDataChannel(
	            'sipjs',
	            mediaHint.dataChannel
	          );
	          self.emit('dataChannel', self.dataChannel);
	        }
	
	        self.render();
	        return self.createOfferOrAnswer(self.RTCConstraints);
	      })
	    ;
	  }},
	
	  /**
	  * Message reception.
	  * @param {String} type
	  * @param {String} sdp
	  */
	  setDescription: {writable: true, value: function setDescription (sdp) {
	    var rawDescription = {
	      type: this.hasOffer('local') ? 'answer' : 'offer',
	      sdp: sdp
	    };
	
	    this.emit('setDescription', rawDescription);
	
	    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);
	    return SIP.Utils.promisify(this.peerConnection, 'setRemoteDescription')(description);
	  }},
	
	  /**
	   * If the Session associated with this MediaHandler were to be referred,
	   * what mediaHint should be provided to the UA's invite method?
	   */
	  getReferMedia: {writable: true, value: function getReferMedia () {
	    function hasTracks (trackGetter, stream) {
	      return stream[trackGetter]().length > 0;
	    }
	
	    function bothHaveTracks (trackGetter) {
	      /* jshint validthis:true */
	      return this.getLocalStreams().some(hasTracks.bind(null, trackGetter)) &&
	             this.getRemoteStreams().some(hasTracks.bind(null, trackGetter));
	    }
	
	    return {
	      constraints: {
	        audio: bothHaveTracks.call(this, 'getAudioTracks'),
	        video: bothHaveTracks.call(this, 'getVideoTracks')
	      }
	    };
	  }},
	
	  updateIceServers: {writeable:true, value: function (options) {
	    var servers = this.prepareIceServers(options.stunServers, options.turnServers);
	    this.RTCConstraints = options.RTCConstraints || this.RTCConstraints;
	
	    this.initPeerConnection(servers, this.RTCConstraints);
	
	    /* once updateIce is implemented correctly, this is better than above
	    //no op if browser does not support this
	    if (!this.peerConnection.updateIce) {
	      return;
	    }
	
	    this.peerConnection.updateIce({'iceServers': servers}, this.RTCConstraints);
	    */
	  }},
	
	// Functions the session can use, but only because it's convenient for the application
	  isMuted: {writable: true, value: function isMuted () {
	    return {
	      audio: this.audioMuted,
	      video: this.videoMuted
	    };
	  }},
	
	  mute: {writable: true, value: function mute (options) {
	    if (this.getLocalStreams().length === 0) {
	      return;
	    }
	
	    options = options || {
	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
	      video: this.getLocalStreams()[0].getVideoTracks().length > 0
	    };
	
	    var audioMuted = false,
	        videoMuted = false;
	
	    if (options.audio && !this.audioMuted) {
	      audioMuted = true;
	      this.audioMuted = true;
	      this.toggleMuteAudio(true);
	    }
	
	    if (options.video && !this.videoMuted) {
	      videoMuted = true;
	      this.videoMuted = true;
	      this.toggleMuteVideo(true);
	    }
	
	    //REVISIT
	    if (audioMuted || videoMuted) {
	      return {
	        audio: audioMuted,
	        video: videoMuted
	      };
	      /*this.session.onmute({
	        audio: audioMuted,
	        video: videoMuted
	      });*/
	    }
	  }},
	
	  unmute: {writable: true, value: function unmute (options) {
	    if (this.getLocalStreams().length === 0) {
	      return;
	    }
	
	    options = options || {
	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
	      video: this.getLocalStreams()[0].getVideoTracks().length > 0
	    };
	
	    var audioUnMuted = false,
	        videoUnMuted = false;
	
	    if (options.audio && this.audioMuted) {
	      audioUnMuted = true;
	      this.audioMuted = false;
	      this.toggleMuteAudio(false);
	    }
	
	    if (options.video && this.videoMuted) {
	      videoUnMuted = true;
	      this.videoMuted = false;
	      this.toggleMuteVideo(false);
	    }
	
	    //REVISIT
	    if (audioUnMuted || videoUnMuted) {
	      return {
	        audio: audioUnMuted,
	        video: videoUnMuted
	      };
	      /*this.session.onunmute({
	        audio: audioUnMuted,
	        video: videoUnMuted
	      });*/
	    }
	  }},
	
	  hold: {writable: true, value: function hold () {
	    this.toggleMuteAudio(true);
	    this.toggleMuteVideo(true);
	  }},
	
	  unhold: {writable: true, value: function unhold () {
	    if (!this.audioMuted) {
	      this.toggleMuteAudio(false);
	    }
	
	    if (!this.videoMuted) {
	      this.toggleMuteVideo(false);
	    }
	  }},
	
	// Functions the application can use, but not the session
	  getLocalStreams: {writable: true, value: function getLocalStreams () {
	    var pc = this.peerConnection;
	    if (pc && pc.signalingState === 'closed') {
	      this.logger.warn('peerConnection is closed, getLocalStreams returning []');
	      return [];
	    }
	    return (pc.getLocalStreams && pc.getLocalStreams()) ||
	      pc.localStreams || [];
	  }},
	
	  getRemoteStreams: {writable: true, value: function getRemoteStreams () {
	    var pc = this.peerConnection;
	    if (pc && pc.signalingState === 'closed') {
	      this.logger.warn('peerConnection is closed, getRemoteStreams returning this._remoteStreams');
	      return this._remoteStreams;
	    }
	    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||
	      pc.remoteStreams || [];
	  }},
	
	  render: {writable: true, value: function render (renderHint) {
	    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);
	    if (!renderHint) {
	      return false;
	    }
	    var streamGetters = {
	      local: 'getLocalStreams',
	      remote: 'getRemoteStreams'
	    };
	    Object.keys(streamGetters).forEach(function (loc) {
	      var streamGetter = streamGetters[loc];
	      var streams = this[streamGetter]();
	      SIP.WebRTC.MediaStreamManager.render(streams, renderHint[loc]);
	    }.bind(this));
	  }},
	
	// Internal functions
	  hasOffer: {writable: true, value: function hasOffer (where) {
	    var offerState = 'have-' + where + '-offer';
	    return this.peerConnection.signalingState === offerState;
	    // TODO consider signalingStates with 'pranswer'?
	  }},
	
	  prepareIceServers: {writable: true, value: function prepareIceServers (stunServers, turnServers) {
	    var servers = [],
	      config = this.session.ua.configuration;
	
	    stunServers = stunServers || config.stunServers;
	    turnServers = turnServers || config.turnServers;
	
	    [].concat(stunServers).forEach(function (server) {
	      servers.push({'urls': server});
	    });
	
	    [].concat(turnServers).forEach(function (server) {
	      servers.push({
	        'urls': server.urls,
	        'username': server.username,
	        'credential': server.password
	      });
	    });
	
	    return servers;
	  }},
	
	  initPeerConnection: {writable: true, value: function initPeerConnection(servers, RTCConstraints) {
	    var self = this,
	      config = this.session.ua.configuration;
	
	    this.onIceCompleted = SIP.Utils.defer();
	    this.onIceCompleted.promise.then(function(pc) {
	      self.emit('iceGatheringComplete', pc);
	      if (self.iceCheckingTimer) {
	        SIP.Timers.clearTimeout(self.iceCheckingTimer);
	        self.iceCheckingTimer = null;
	      }
	    });
	
	    if (this.peerConnection) {
	      this.peerConnection.close();
	    }
	
	    this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers}, RTCConstraints);
	
	    // Firefox (35.0.1) sometimes throws on calls to peerConnection.getRemoteStreams
	    // even if peerConnection.onaddstream was just called. In order to make
	    // MediaHandler.prototype.getRemoteStreams work, keep track of them manually
	    this._remoteStreams = [];
	
	    this.peerConnection.onaddstream = function(e) {
	      self.logger.log('stream added: '+ e.stream.id);
	      self._remoteStreams.push(e.stream);
	      self.render();
	      self.emit('addStream', e);
	    };
	
	    this.peerConnection.onremovestream = function(e) {
	      self.logger.log('stream removed: '+ e.stream.id);
	    };
	
	    this.startIceCheckingTimer = function () {
	      if (!self.iceCheckingTimer) {
	        self.iceCheckingTimer = SIP.Timers.setTimeout(function() {
	          self.logger.log('RTCIceChecking Timeout Triggered after '+config.iceCheckingTimeout+' milliseconds');
	          self.onIceCompleted.resolve(this);
	        }.bind(this.peerConnection), config.iceCheckingTimeout);
	      }
	    };
	
	    this.peerConnection.onicecandidate = function(e) {
	      self.emit('iceCandidate', e);
	      if (e.candidate) {
	        self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));
	        self.startIceCheckingTimer();
	      } else {
	        self.onIceCompleted.resolve(this);
	      }
	    };
	
	    this.peerConnection.onicegatheringstatechange = function () {
	      self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);
	      if (this.iceGatheringState === 'gathering') {
	        self.emit('iceGathering', this);
	      }
	      if (this.iceGatheringState === 'complete') {
	        self.onIceCompleted.resolve(this);
	      }
	    };
	
	    this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case
	      var stateEvent;
	
	      if (this.iceConnectionState === 'checking') {
	        self.startIceCheckingTimer();
	      }
	
	      switch (this.iceConnectionState) {
	      case 'new':
	        stateEvent = 'iceConnection';
	        break;
	      case 'checking':
	        stateEvent = 'iceConnectionChecking';
	        break;
	      case 'connected':
	        stateEvent = 'iceConnectionConnected';
	        break;
	      case 'completed':
	        stateEvent = 'iceConnectionCompleted';
	        break;
	      case 'failed':
	        stateEvent = 'iceConnectionFailed';
	        break;
	      case 'disconnected':
	        stateEvent = 'iceConnectionDisconnected';
	        break;
	      case 'closed':
	        stateEvent = 'iceConnectionClosed';
	        break;
	      default:
	        self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);
	        return;
	      }
	      self.emit(stateEvent, this);
	
	      //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated
	      //normal calls switch from failed to connected in some cases, so checking for failed and terminated
	      /*if (this.iceConnectionState === 'failed') {
	        self.session.terminate({
	        cause: SIP.C.causes.RTP_TIMEOUT,
	        status_code: 200,
	        reason_phrase: SIP.C.causes.RTP_TIMEOUT
	      });
	      } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {
	      self.onIceCompleted(this);
	      }*/
	    };
	
	    this.peerConnection.onstatechange = function() {
	      self.logger.log('PeerConnection state changed to "'+ this.readyState +'"');
	    };
	  }},
	
	  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (constraints) {
	    var self = this;
	    var methodName;
	    var pc = self.peerConnection;
	
	    self.ready = false;
	    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';
	
	    return SIP.Utils.promisify(pc, methodName, true)(constraints)
	      .then(SIP.Utils.promisify(pc, 'setLocalDescription'))
	      .then(function onSetLocalDescriptionSuccess() {
	        var deferred = SIP.Utils.defer();
	        if (pc.iceGatheringState === 'complete' && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed')) {
	          deferred.resolve();
	        } else {
	          self.onIceCompleted.promise.then(deferred.resolve);
	        }
	        return deferred.promise;
	      })
	      .then(function readySuccess () {
	        var sdp = pc.localDescription.sdp;
	
	        sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);
	        sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);
	
	        var sdpWrapper = {
	          type: methodName === 'createOffer' ? 'offer' : 'answer',
	          sdp: sdp
	        };
	
	        self.emit('getDescription', sdpWrapper);
	
	        self.ready = true;
	        return sdpWrapper.sdp;
	      })
	      .catch(function methodFailed (e) {
	        self.logger.error(e);
	        self.ready = true;
	        throw new SIP.Exceptions.GetDescriptionError(e);
	      })
	    ;
	  }},
	
	  addStreams: {writable: true, value: function addStreams (streams) {
	    try {
	      streams = [].concat(streams);
	      streams.forEach(function (stream) {
	        this.peerConnection.addStream(stream);
	      }, this);
	    } catch(e) {
	      this.logger.error('error adding stream');
	      this.logger.error(e);
	      return SIP.Utils.Promise.reject(e);
	    }
	
	    return SIP.Utils.Promise.resolve();
	  }},
	
	  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {
	    this.getLocalStreams().forEach(function (stream) {
	      stream[trackGetter]().forEach(function (track) {
	        track.enabled = !mute;
	      });
	    });
	  }},
	
	  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {
	    this.toggleMuteHelper('getAudioTracks', mute);
	  }},
	
	  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {
	    this.toggleMuteHelper('getVideoTracks', mute);
	  }}
	});
	
	// Return since it will be assigned to a variable.
	return MediaHandler;
	};


/***/ },
/* 238 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaStreamManager
	 */
	
	/* MediaStreamManager
	 * @class Manages the acquisition and release of MediaStreams.
	 * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()
	 */
	module.exports = function (SIP, environment) {
	
	// Default MediaStreamManager provides single-use streams created with getUserMedia
	var MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {
	  if (!SIP.WebRTC.isSupported()) {
	    throw new SIP.Exceptions.NotSupportedError('Media not supported');
	  }
	
	  this.mediaHint = defaultMediaHint || {
	    constraints: {audio: true, video: true}
	  };
	
	  // map of streams to acquisition manner:
	  // true -> passed in as mediaHint.stream
	  // false -> getUserMedia
	  this.acquisitions = {};
	};
	MediaStreamManager.streamId = function (stream) {
	  return stream.getAudioTracks().concat(stream.getVideoTracks())
	    .map(function trackId (track) {
	      return track.id;
	    })
	    .join('');
	};
	
	/**
	 * @param {(Array of) MediaStream} streams - The streams to render
	 *
	 * @param {(Array of) HTMLMediaElement} elements
	 *        - The <audio>/<video> element(s) that should render the streams
	 *
	 * Each stream in streams renders to the corresponding element in elements,
	 * wrapping around elements if needed.
	 */
	MediaStreamManager.render = function render (streams, elements) {
	  if (!elements) {
	    return false;
	  }
	  if (Array.isArray(elements) && !elements.length) {
	    throw new TypeError('elements must not be empty');
	  }
	
	  function attachMediaStream(element, stream) {
	    if (typeof element.src !== 'undefined') {
	      environment.revokeObjectURL(element.src);
	      element.src = environment.createObjectURL(stream);
	    } else if (typeof (element.srcObject || element.mozSrcObject) !== 'undefined') {
	      element.srcObject = element.mozSrcObject = stream;
	    } else {
	      return false;
	    }
	
	    return true;
	  }
	
	  function ensureMediaPlaying (mediaElement) {
	    var interval = 100;
	    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {
	      if (mediaElement.paused) {
	        mediaElement.play();
	      }
	      else {
	        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);
	      }
	    }, interval);
	  }
	
	  function attachAndPlay (elements, stream, index) {
	    if (typeof elements === 'function') {
	      elements = elements();
	    }
	    var element = elements[index % elements.length];
	    (environment.attachMediaStream || attachMediaStream)(element, stream);
	    ensureMediaPlaying(element);
	  }
	
	  // [].concat "casts" `elements` into an array
	  // so forEach works even if `elements` was a single element
	  elements = [].concat(elements);
	  [].concat(streams).forEach(attachAndPlay.bind(null, elements));
	};
	
	MediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {
	  'acquire': {writable: true, value: function acquire (mediaHint) {
	    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;
	
	    var saveSuccess = function (isHintStream, streams) {
	      streams = [].concat(streams);
	      streams.forEach(function (stream) {
	        var streamId = MediaStreamManager.streamId(stream);
	        this.acquisitions[streamId] = !!isHintStream;
	      }, this);
	      return SIP.Utils.Promise.resolve(streams);
	    }.bind(this);
	
	    if (mediaHint.stream) {
	      return saveSuccess(true, mediaHint.stream);
	    } else {
	      // Fallback to audio/video enabled if no mediaHint can be found.
	      var constraints = mediaHint.constraints ||
	        (this.mediaHint && this.mediaHint.constraints) ||
	        {audio: true, video: true};
	
	      var deferred = SIP.Utils.defer();
	
	      /*
	       * Make the call asynchronous, so that ICCs have a chance
	       * to define callbacks to `userMediaRequest`
	       */
	      SIP.Timers.setTimeout(function () {
	        this.emit('userMediaRequest', constraints);
	
	        var emitThenCall = function (eventName, callback) {
	          var callbackArgs = Array.prototype.slice.call(arguments, 2);
	          // Emit with all of the arguments from the real callback.
	          var newArgs = [eventName].concat(callbackArgs);
	
	          this.emit.apply(this, newArgs);
	
	          return callback.apply(null, callbackArgs);
	        }.bind(this);
	
	        if (constraints.audio || constraints.video) {
	          deferred.resolve(
	            SIP.WebRTC.getUserMedia(constraints)
	            .then(
	              emitThenCall.bind(this, 'userMedia', saveSuccess.bind(null, false)),
	              emitThenCall.bind(this, 'userMediaFailed', function(e){throw e;})
	            )
	          );
	        } else {
	          // Local streams were explicitly excluded.
	          deferred.resolve([]);
	        }
	      }.bind(this), 0);
	
	      return deferred.promise;
	    }
	  }},
	
	  'release': {writable: true, value: function release (streams) {
	    streams = [].concat(streams);
	    streams.forEach(function (stream) {
	      var streamId = MediaStreamManager.streamId(stream);
	      if (this.acquisitions[streamId] === false) {
	        stream.getTracks().forEach(function (track) {
	          track.stop();
	        });
	      }
	      delete this.acquisitions[streamId];
	    }, this);
	  }},
	});
	
	// Return since it will be assigned to a variable.
	return MediaStreamManager;
	};


/***/ },
/* 239 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * @augments SIP
	 * @class Class creating a SIP User Agent.
	 * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]
	 *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.
	 *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.
	 *
	 * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	 */
	module.exports = function (SIP, environment) {
	var UA,
	  C = {
	    // UA status codes
	    STATUS_INIT:                0,
	    STATUS_STARTING:            1,
	    STATUS_READY:               2,
	    STATUS_USER_CLOSED:         3,
	    STATUS_NOT_READY:           4,
	
	    // UA error codes
	    CONFIGURATION_ERROR:  1,
	    NETWORK_ERROR:        2,
	
	    ALLOWED_METHODS: [
	      'ACK',
	      'CANCEL',
	      'INVITE',
	      'MESSAGE',
	      'BYE',
	      'OPTIONS',
	      'INFO',
	      'NOTIFY',
	      'REFER'
	    ],
	
	    ACCEPTED_BODY_TYPES: [
	      'application/sdp',
	      'application/dtmf-relay'
	    ],
	
	    MAX_FORWARDS: 70,
	    TAG_LENGTH: 10
	  };
	
	UA = function(configuration) {
	  var self = this;
	
	  // Helper function for forwarding events
	  function selfEmit(type) {
	    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments
	    return self.emit.bind(self, type);
	  }
	
	  // Set Accepted Body Types
	  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();
	
	  this.log = new SIP.LoggerFactory();
	  this.logger = this.getLogger('sip.ua');
	
	  this.cache = {
	    credentials: {}
	  };
	
	  this.configuration = {};
	  this.dialogs = {};
	
	  //User actions outside any session/dialog (MESSAGE)
	  this.applicants = {};
	
	  this.data = {};
	  this.sessions = {};
	  this.subscriptions = {};
	  this.transport = null;
	  this.contact = null;
	  this.status = C.STATUS_INIT;
	  this.error = null;
	  this.transactions = {
	    nist: {},
	    nict: {},
	    ist: {},
	    ict: {}
	  };
	
	  this.transportRecoverAttempts = 0;
	  this.transportRecoveryTimer = null;
	
	  Object.defineProperties(this, {
	    transactionsCount: {
	      get: function() {
	        var type,
	          transactions = ['nist','nict','ist','ict'],
	          count = 0;
	
	        for (type in transactions) {
	          count += Object.keys(this.transactions[transactions[type]]).length;
	        }
	
	        return count;
	      }
	    },
	
	    nictTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['nict']).length;
	      }
	    },
	
	    nistTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['nist']).length;
	      }
	    },
	
	    ictTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['ict']).length;
	      }
	    },
	
	    istTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['ist']).length;
	      }
	    }
	  });
	
	  /**
	   * Load configuration
	   *
	   * @throws {SIP.Exceptions.ConfigurationError}
	   * @throws {TypeError}
	   */
	
	  if(configuration === undefined) {
	    configuration = {};
	  } else if (typeof configuration === 'string' || configuration instanceof String) {
	    configuration = {
	      uri: configuration
	    };
	  }
	
	  // Apply log configuration if present
	  if (configuration.log) {
	    if (configuration.log.hasOwnProperty('builtinEnabled')) {
	      this.log.builtinEnabled = configuration.log.builtinEnabled;
	    }
	
	    if (configuration.log.hasOwnProperty('level')) {
	      this.log.level = configuration.log.level;
	    }
	
	    if (configuration.log.hasOwnProperty('connector')) {
	      this.log.connector = configuration.log.connector;
	    }
	  }
	
	  try {
	    this.loadConfig(configuration);
	  } catch(e) {
	    this.status = C.STATUS_NOT_READY;
	    this.error = C.CONFIGURATION_ERROR;
	    throw e;
	  }
	
	  // Initialize registerContext
	  this.registerContext = new SIP.RegisterContext(this);
	  this.registerContext.on('failed', selfEmit('registrationFailed'));
	  this.registerContext.on('registered', selfEmit('registered'));
	  this.registerContext.on('unregistered', selfEmit('unregistered'));
	
	  if(this.configuration.autostart) {
	    this.start();
	  }
	
	  if (typeof environment.addEventListener === 'function') {
	    // Google Chrome Packaged Apps don't allow 'unload' listeners:
	    // unload is not available in packaged apps
	    if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {
	      environment.addEventListener('unload', this.stop.bind(this));
	    }
	  }
	};
	UA.prototype = Object.create(SIP.EventEmitter.prototype);
	
	//=================
	//  High Level API
	//=================
	
	UA.prototype.register = function(options) {
	  this.configuration.register = true;
	  this.registerContext.register(options);
	
	  return this;
	};
	
	/**
	 * Unregister.
	 *
	 * @param {Boolean} [all] unregister all user bindings.
	 *
	 */
	UA.prototype.unregister = function(options) {
	  this.configuration.register = false;
	
	  var context = this.registerContext;
	  this.afterConnected(context.unregister.bind(context, options));
	
	  return this;
	};
	
	UA.prototype.isRegistered = function() {
	  return this.registerContext.registered;
	};
	
	/**
	 * Connection state.
	 * @param {Boolean}
	 */
	UA.prototype.isConnected = function() {
	  return this.transport ? this.transport.connected : false;
	};
	
	UA.prototype.afterConnected = function afterConnected (callback) {
	  if (this.isConnected()) {
	    callback();
	  } else {
	    this.once('connected', callback);
	  }
	};
	
	/**
	 * Make an outgoing call.
	 *
	 * @param {String} target
	 * @param {Object} views
	 * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	 *
	 * @throws {TypeError}
	 *
	 */
	UA.prototype.invite = function(target, options) {
	  var context = new SIP.InviteClientContext(this, target, options);
	
	  this.afterConnected(context.invite.bind(context));
	  return context;
	};
	
	UA.prototype.subscribe = function(target, event, options) {
	  var sub = new SIP.Subscription(this, target, event, options);
	
	  this.afterConnected(sub.subscribe.bind(sub));
	  return sub;
	};
	
	/**
	 * Send a message.
	 *
	 * @param {String} target
	 * @param {String} body
	 * @param {Object} [options]
	 *
	 * @throws {TypeError}
	 *
	 */
	UA.prototype.message = function(target, body, options) {
	  if (body === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  // There is no Message module, so it is okay that the UA handles defaults here.
	  options = Object.create(options || Object.prototype);
	  options.contentType || (options.contentType = 'text/plain');
	  options.body = body;
	
	  return this.request(SIP.C.MESSAGE, target, options);
	};
	
	UA.prototype.request = function (method, target, options) {
	  var req = new SIP.ClientContext(this, method, target, options);
	
	  this.afterConnected(req.send.bind(req));
	  return req;
	};
	
	/**
	 * Gracefully close.
	 *
	 */
	UA.prototype.stop = function() {
	  var session, subscription, applicant,
	    ua = this;
	
	  function transactionsListener() {
	    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {
	        ua.removeListener('transactionDestroyed', transactionsListener);
	        ua.transport.disconnect();
	    }
	  }
	
	  this.logger.log('user requested closure...');
	
	  if(this.status === C.STATUS_USER_CLOSED) {
	    this.logger.warn('UA already closed');
	    return this;
	  }
	
	  // Clear transportRecoveryTimer
	  SIP.Timers.clearTimeout(this.transportRecoveryTimer);
	
	  // Close registerContext
	  this.logger.log('closing registerContext');
	  this.registerContext.close();
	
	  // Run  _terminate_ on every Session
	  for(session in this.sessions) {
	    this.logger.log('closing session ' + session);
	    this.sessions[session].terminate();
	  }
	
	  //Run _close_ on every Subscription
	  for(subscription in this.subscriptions) {
	    this.logger.log('unsubscribing from subscription ' + subscription);
	    this.subscriptions[subscription].close();
	  }
	
	  // Run  _close_ on every applicant
	  for(applicant in this.applicants) {
	    this.applicants[applicant].close();
	  }
	
	  this.status = C.STATUS_USER_CLOSED;
	
	  /*
	   * If the remaining transactions are all INVITE transactions, there is no need to
	   * wait anymore because every session has already been closed by this method.
	   * - locally originated sessions where terminated (CANCEL or BYE)
	   * - remotely originated sessions where rejected (4XX) or terminated (BYE)
	   * Remaining INVITE transactions belong tho sessions that where answered. This are in
	   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]
	   */
	  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {
	    this.transport.disconnect();
	  } else {
	    this.on('transactionDestroyed', transactionsListener);
	  }
	
	  return this;
	};
	
	/**
	 * Connect to the WS server if status = STATUS_INIT.
	 * Resume UA after being closed.
	 *
	 */
	UA.prototype.start = function() {
	  var server;
	
	  this.logger.log('user requested startup...');
	  if (this.status === C.STATUS_INIT) {
	    server = this.getNextWsServer();
	    this.status = C.STATUS_STARTING;
	    new SIP.Transport(this, server);
	  } else if(this.status === C.STATUS_USER_CLOSED) {
	    this.logger.log('resuming');
	    this.status = C.STATUS_READY;
	    this.transport.connect();
	  } else if (this.status === C.STATUS_STARTING) {
	    this.logger.log('UA is in STARTING status, not opening new connection');
	  } else if (this.status === C.STATUS_READY) {
	    this.logger.log('UA is in READY status, not resuming');
	  } else {
	    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');
	  }
	
	  return this;
	};
	
	/**
	 * Normalize a string into a valid SIP request URI
	 *
	 * @param {String} target
	 *
	 * @returns {SIP.URI|undefined}
	 */
	UA.prototype.normalizeTarget = function(target) {
	  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);
	};
	
	
	//===============================
	//  Private (For internal use)
	//===============================
	
	UA.prototype.saveCredentials = function(credentials) {
	  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};
	  this.cache.credentials[credentials.realm][credentials.uri] = credentials;
	
	  return this;
	};
	
	UA.prototype.getCredentials = function(request) {
	  var realm, credentials;
	
	  realm = request.ruri.host;
	
	  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {
	    credentials = this.cache.credentials[realm][request.ruri];
	    credentials.method = request.method;
	  }
	
	  return credentials;
	};
	
	UA.prototype.getLogger = function(category, label) {
	  return this.log.getLogger(category, label);
	};
	
	
	//==============================
	// Event Handlers
	//==============================
	
	/**
	 * Transport Close event
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportClosed = function(transport) {
	  // Run _onTransportError_ callback on every client transaction using _transport_
	  var type, idx, length,
	    client_transactions = ['nict', 'ict', 'nist', 'ist'];
	
	  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;
	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);
	
	  length = client_transactions.length;
	  for (type = 0; type < length; type++) {
	    for(idx in this.transactions[client_transactions[type]]) {
	      this.transactions[client_transactions[type]][idx].onTransportError();
	    }
	  }
	
	  // Close sessions if GRUU is not being used
	  if (!this.contact.pub_gruu) {
	    this.closeSessionsOnTransportError();
	  }
	
	};
	
	/**
	 * Unrecoverable transport event.
	 * Connection reattempt logic has been done and didn't success.
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportError = function(transport) {
	  var server;
	
	  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);
	
	  // Close sessions.
	  //Mark this transport as 'down'
	  transport.server.status = SIP.Transport.C.STATUS_ERROR;
	
	  this.emit('disconnected', {
	    transport: transport
	  });
	
	  // try the next transport if the UA isn't closed
	  if(this.status === C.STATUS_USER_CLOSED) {
	    return;
	  }
	
	  server = this.getNextWsServer();
	
	  if(server) {
	    new SIP.Transport(this, server);
	  }else {
	    this.closeSessionsOnTransportError();
	    if (!this.error || this.error !== C.NETWORK_ERROR) {
	      this.status = C.STATUS_NOT_READY;
	      this.error = C.NETWORK_ERROR;
	    }
	    // Transport Recovery process
	    this.recoverTransport();
	  }
	};
	
	/**
	 * Transport connection event.
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportConnected = function(transport) {
	  this.transport = transport;
	
	  // Reset transport recovery counter
	  this.transportRecoverAttempts = 0;
	
	  transport.server.status = SIP.Transport.C.STATUS_READY;
	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);
	
	  if(this.status === C.STATUS_USER_CLOSED) {
	    return;
	  }
	
	  this.status = C.STATUS_READY;
	  this.error = null;
	
	  if(this.configuration.register) {
	    this.configuration.authenticationFactory.initialize().then(function () {
	      this.registerContext.onTransportConnected();
	    }.bind(this));
	  }
	
	  this.emit('connected', {
	    transport: transport
	  });
	};
	
	
	/**
	 * Transport connecting event
	 * @private
	 * @param {SIP.Transport} transport.
	 * #param {Integer} attempts.
	 */
	  UA.prototype.onTransportConnecting = function(transport, attempts) {
	    this.emit('connecting', {
	      transport: transport,
	      attempts: attempts
	    });
	  };
	
	
	/**
	 * new Transaction
	 * @private
	 * @param {SIP.Transaction} transaction.
	 */
	UA.prototype.newTransaction = function(transaction) {
	  this.transactions[transaction.type][transaction.id] = transaction;
	  this.emit('newTransaction', {transaction: transaction});
	};
	
	
	/**
	 * destroy Transaction
	 * @private
	 * @param {SIP.Transaction} transaction.
	 */
	UA.prototype.destroyTransaction = function(transaction) {
	  delete this.transactions[transaction.type][transaction.id];
	  this.emit('transactionDestroyed', {
	    transaction: transaction
	  });
	};
	
	
	//=========================
	// receiveRequest
	//=========================
	
	/**
	 * Request reception
	 * @private
	 * @param {SIP.IncomingRequest} request.
	 */
	UA.prototype.receiveRequest = function(request) {
	  var dialog, session, message,
	    method = request.method,
	    transaction,
	    replaces,
	    replacedDialog,
	    self = this;
	
	  function ruriMatches (uri) {
	    return uri && uri.user === request.ruri.user;
	  }
	
	  // Check that request URI points to us
	  if(!(ruriMatches(this.configuration.uri) ||
	       ruriMatches(this.contact.uri) ||
	       ruriMatches(this.contact.pub_gruu) ||
	       ruriMatches(this.contact.temp_gruu))) {
	    this.logger.warn('Request-URI does not point to us');
	    if (request.method !== SIP.C.ACK) {
	      request.reply_sl(404);
	    }
	    return;
	  }
	
	  // Check request URI scheme
	  if(request.ruri.scheme === SIP.C.SIPS) {
	    request.reply_sl(416);
	    return;
	  }
	
	  // Check transaction
	  if(SIP.Transactions.checkTransaction(this, request)) {
	    return;
	  }
	
	  /* RFC3261 12.2.2
	   * Requests that do not change in any way the state of a dialog may be
	   * received within a dialog (for example, an OPTIONS request).
	   * They are processed as if they had been received outside the dialog.
	   */
	  if(method === SIP.C.OPTIONS) {
	    new SIP.Transactions.NonInviteServerTransaction(request, this);
	    request.reply(200, null, [
	      'Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString(),
	      'Accept: '+ C.ACCEPTED_BODY_TYPES
	    ]);
	  } else if (method === SIP.C.MESSAGE) {
	    message = new SIP.ServerContext(this, request);
	    message.body = request.body;
	    message.content_type = request.getHeader('Content-Type') || 'text/plain';
	
	    request.reply(200, null);
	    this.emit('message', message);
	  } else if (method !== SIP.C.INVITE &&
	             method !== SIP.C.ACK) {
	    // Let those methods pass through to normal processing for now.
	    transaction = new SIP.ServerContext(this, request);
	  }
	
	  // Initial Request
	  if(!request.to_tag) {
	    switch(method) {
	      case SIP.C.INVITE:
	        replaces =
	          this.configuration.replaces !== SIP.C.supported.UNSUPPORTED &&
	          request.parseHeader('replaces');
	
	        if (replaces) {
	          replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];
	
	          if (!replacedDialog) {
	            //Replaced header without a matching dialog, reject
	            request.reply_sl(481, null);
	            return;
	          } else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {
	            request.reply_sl(603, null);
	            return;
	          } else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {
	            request.reply_sl(486, null);
	            return;
	          }
	        }
	
	        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;
	        if(!isMediaSupported || isMediaSupported()) {
	          session = new SIP.InviteServerContext(this, request);
	          session.replacee = replacedDialog && replacedDialog.owner;
	          session.on('invite', function() {
	            self.emit('invite', this);
	          });
	        } else {
	          this.logger.warn('INVITE received but WebRTC is not supported');
	          request.reply(488);
	        }
	        break;
	      case SIP.C.BYE:
	        // Out of dialog BYE received
	        request.reply(481);
	        break;
	      case SIP.C.CANCEL:
	        session = this.findSession(request);
	        if(session) {
	          session.receiveRequest(request);
	        } else {
	          this.logger.warn('received CANCEL request for a non existent session');
	        }
	        break;
	      case SIP.C.ACK:
	        /* Absorb it.
	         * ACK request without a corresponding Invite Transaction
	         * and without To tag.
	         */
	        break;
	      default:
	        request.reply(405);
	        break;
	    }
	  }
	  // In-dialog request
	  else {
	    dialog = this.findDialog(request);
	
	    if(dialog) {
	      if (method === SIP.C.INVITE) {
	        new SIP.Transactions.InviteServerTransaction(request, this);
	      }
	      dialog.receiveRequest(request);
	    } else if (method === SIP.C.NOTIFY) {
	      session = this.findSession(request);
	      if(session) {
	        session.receiveRequest(request);
	      } else {
	        this.logger.warn('received NOTIFY request for a non existent session');
	        request.reply(481, 'Subscription does not exist');
	      }
	    }
	    /* RFC3261 12.2.2
	     * Request with to tag, but no matching dialog found.
	     * Exception: ACK for an Invite request for which a dialog has not
	     * been created.
	     */
	    else {
	      if(method !== SIP.C.ACK) {
	        request.reply(481);
	      }
	    }
	  }
	};
	
	//=================
	// Utils
	//=================
	
	/**
	 * Get the session to which the request belongs to, if any.
	 * @private
	 * @param {SIP.IncomingRequest} request.
	 * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}
	 */
	UA.prototype.findSession = function(request) {
	  return this.sessions[request.call_id + request.from_tag] ||
	          this.sessions[request.call_id + request.to_tag] ||
	          null;
	};
	
	/**
	 * Get the dialog to which the request belongs to, if any.
	 * @private
	 * @param {SIP.IncomingRequest}
	 * @returns {SIP.Dialog|null}
	 */
	UA.prototype.findDialog = function(request) {
	  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||
	          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||
	          null;
	};
	
	/**
	 * Retrieve the next server to which connect.
	 * @private
	 * @returns {Object} ws_server
	 */
	UA.prototype.getNextWsServer = function() {
	  // Order servers by weight
	  var idx, length, ws_server,
	    candidates = [];
	
	  length = this.configuration.wsServers.length;
	  for (idx = 0; idx < length; idx++) {
	    ws_server = this.configuration.wsServers[idx];
	
	    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {
	      continue;
	    } else if (candidates.length === 0) {
	      candidates.push(ws_server);
	    } else if (ws_server.weight > candidates[0].weight) {
	      candidates = [ws_server];
	    } else if (ws_server.weight === candidates[0].weight) {
	      candidates.push(ws_server);
	    }
	  }
	
	  idx = Math.floor(Math.random() * candidates.length);
	
	  return candidates[idx];
	};
	
	/**
	 * Close all sessions on transport error.
	 * @private
	 */
	UA.prototype.closeSessionsOnTransportError = function() {
	  var idx;
	
	  // Run _transportError_ for every Session
	  for(idx in this.sessions) {
	    this.sessions[idx].onTransportError();
	  }
	  // Call registerContext _onTransportClosed_
	  this.registerContext.onTransportClosed();
	};
	
	UA.prototype.recoverTransport = function(ua) {
	  var idx, length, k, nextRetry, count, server;
	
	  ua = ua || this;
	  count = ua.transportRecoverAttempts;
	
	  length = ua.configuration.wsServers.length;
	  for (idx = 0; idx < length; idx++) {
	    ua.configuration.wsServers[idx].status = 0;
	  }
	
	  server = ua.getNextWsServer();
	
	  k = Math.floor((Math.random() * Math.pow(2,count)) +1);
	  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;
	
	  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {
	    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');
	    nextRetry = ua.configuration.connectionRecoveryMinInterval;
	    count = 0;
	  }
	
	  this.logger.log('next connection attempt in '+ nextRetry +' seconds');
	
	  this.transportRecoveryTimer = SIP.Timers.setTimeout(
	    function(){
	      ua.transportRecoverAttempts = count + 1;
	      new SIP.Transport(ua, server);
	    }, nextRetry * 1000);
	};
	
	function checkAuthenticationFactory (authenticationFactory) {
	  if (!(authenticationFactory instanceof Function)) {
	    return;
	  }
	  if (!authenticationFactory.initialize) {
	    authenticationFactory.initialize = function initialize () {
	      return SIP.Utils.Promise.resolve();
	    };
	  }
	  return authenticationFactory;
	}
	
	/**
	 * Configuration load.
	 * @private
	 * returns {Boolean}
	 */
	UA.prototype.loadConfig = function(configuration) {
	  // Settings and default values
	  var parameter, value, checked_value, hostportParams, registrarServer,
	    settings = {
	      /* Host address
	      * Value to be set in Via sent_by and host part of Contact FQDN
	      */
	      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',
	
	      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),
	      wsServers: [{
	        scheme: 'WSS',
	        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',
	        status: 0,
	        weight: 0,
	        ws_uri: 'wss://edge.sip.onsip.com'
	      }],
	
	      // Password
	      password: null,
	
	      // Registration parameters
	      registerExpires: 600,
	      register: true,
	      registrarServer: null,
	
	      // Transport related parameters
	      wsServerMaxReconnection: 3,
	      wsServerReconnectionTimeout: 4,
	
	      connectionRecoveryMinInterval: 2,
	      connectionRecoveryMaxInterval: 30,
	
	      keepAliveInterval: 0,
	
	      extraSupported: [],
	
	      usePreloadedRoute: false,
	
	      //string to be inserted into User-Agent request header
	      userAgentString: SIP.C.USER_AGENT,
	
	      // Session parameters
	      iceCheckingTimeout: 5000,
	      noAnswerTimeout: 60,
	      stunServers: ['stun:stun.l.google.com:19302'],
	      turnServers: [],
	
	      // Logging parameters
	      traceSip: false,
	
	      // Hacks
	      hackViaTcp: false,
	      hackIpInContact: false,
	      hackWssInTransport: false,
	      hackAllowUnregisteredOptionTags: false,
	
	      contactTransport: 'ws',
	      forceRport: false,
	
	      //autostarting
	      autostart: true,
	
	      //Reliable Provisional Responses
	      rel100: SIP.C.supported.UNSUPPORTED,
	
	      // Replaces header (RFC 3891)
	      // http://tools.ietf.org/html/rfc3891
	      replaces: SIP.C.supported.UNSUPPORTED,
	
	      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory,
	
	      authenticationFactory: checkAuthenticationFactory(function authenticationFactory (ua) {
	        return new SIP.DigestAuthentication(ua);
	      })
	    };
	
	  // Pre-Configuration
	  function aliasUnderscored (parameter, logger) {
	    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {
	      return m[0] + '_' + m[1].toLowerCase();
	    });
	
	    if (parameter === underscored) {
	      return;
	    }
	
	    var hasParameter = configuration.hasOwnProperty(parameter);
	    if (configuration.hasOwnProperty(underscored)) {
	      logger.warn(underscored + ' is deprecated, please use ' + parameter);
	      if (hasParameter) {
	        logger.warn(parameter + ' overriding ' + underscored);
	      }
	    }
	
	    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];
	  }
	
	  // Check Mandatory parameters
	  for(parameter in UA.configuration_check.mandatory) {
	    aliasUnderscored(parameter, this.logger);
	    if(!configuration.hasOwnProperty(parameter)) {
	      throw new SIP.Exceptions.ConfigurationError(parameter);
	    } else {
	      value = configuration[parameter];
	      checked_value = UA.configuration_check.mandatory[parameter](value);
	      if (checked_value !== undefined) {
	        settings[parameter] = checked_value;
	      } else {
	        throw new SIP.Exceptions.ConfigurationError(parameter, value);
	      }
	    }
	  }
	
	  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);
	
	  var emptyArraysAllowed = ['stunServers', 'turnServers'];
	
	  // Check Optional parameters
	  for(parameter in UA.configuration_check.optional) {
	    aliasUnderscored(parameter, this.logger);
	    if(configuration.hasOwnProperty(parameter)) {
	      value = configuration[parameter];
	
	      // If the parameter value is an empty array, but shouldn't be, apply its default value.
	      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }
	
	      // If the parameter value is null, empty string, or undefined then apply its default value.
	      if(value === null || value === "" || value === undefined) { continue; }
	      // If it's a number with NaN value then also apply its default value.
	      // NOTE: JS does not allow "value === NaN", the following does the work:
	      else if(typeof(value) === 'number' && isNaN(value)) { continue; }
	
	      checked_value = UA.configuration_check.optional[parameter](value);
	      if (checked_value !== undefined) {
	        settings[parameter] = checked_value;
	      } else {
	        throw new SIP.Exceptions.ConfigurationError(parameter, value);
	      }
	    }
	  }
	
	  // Sanity Checks
	
	  // Connection recovery intervals
	  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {
	    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);
	  }
	
	  // Post Configuration Process
	
	  // Allow passing 0 number as displayName.
	  if (settings.displayName === 0) {
	    settings.displayName = '0';
	  }
	
	  // Instance-id for GRUU
	  if (!settings.instanceId) {
	    settings.instanceId = SIP.Utils.newUUID();
	  }
	
	  // sipjsId instance parameter. Static random tag of length 5
	  settings.sipjsId = SIP.Utils.createRandomToken(5);
	
	  // String containing settings.uri without scheme and user.
	  hostportParams = settings.uri.clone();
	  hostportParams.user = null;
	  settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');
	
	  /* Check whether authorizationUser is explicitly defined.
	   * Take 'settings.uri.user' value if not.
	   */
	  if (!settings.authorizationUser) {
	    settings.authorizationUser = settings.uri.user;
	  }
	
	  /* If no 'registrarServer' is set use the 'uri' value without user portion. */
	  if (!settings.registrarServer) {
	    registrarServer = settings.uri.clone();
	    registrarServer.user = null;
	    settings.registrarServer = registrarServer;
	  }
	
	  // User noAnswerTimeout
	  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;
	
	  // Via Host
	  if (settings.hackIpInContact) {
	    if (typeof settings.hackIpInContact === 'boolean') {
	      settings.viaHost = SIP.Utils.getRandomTestNetIP();
	    }
	    else if (typeof settings.hackIpInContact === 'string') {
	      settings.viaHost = settings.hackIpInContact;
	    }
	  }
	
	  // Contact transport parameter
	  if (settings.hackWssInTransport) {
	    settings.contactTransport = 'wss';
	  }
	
	  this.contact = {
	    pub_gruu: null,
	    temp_gruu: null,
	    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: settings.contactTransport}),
	    toString: function(options){
	      options = options || {};
	
	      var
	        anonymous = options.anonymous || null,
	        outbound = options.outbound || null,
	        contact = '<';
	
	      if (anonymous) {
	        contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport='+settings.contactTransport)).toString();
	      } else {
	        contact += (this.pub_gruu || this.uri).toString();
	      }
	
	      if (outbound) {
	        contact += ';ob';
	      }
	
	      contact += '>';
	
	      return contact;
	    }
	  };
	
	  // media overrides mediaConstraints
	  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);
	
	  // Fill the value of the configuration_skeleton
	  for(parameter in settings) {
	    UA.configuration_skeleton[parameter].value = settings[parameter];
	  }
	
	  Object.defineProperties(this.configuration, UA.configuration_skeleton);
	
	  // Clean UA.configuration_skeleton
	  for(parameter in settings) {
	    UA.configuration_skeleton[parameter].value = '';
	  }
	
	  this.logger.log('configuration parameters after validation:');
	  for(parameter in settings) {
	    switch(parameter) {
	      case 'uri':
	      case 'registrarServer':
	      case 'mediaHandlerFactory':
	        this.logger.log('· ' + parameter + ': ' + settings[parameter]);
	        break;
	      case 'password':
	        this.logger.log('· ' + parameter + ': ' + 'NOT SHOWN');
	        break;
	      default:
	        this.logger.log('· ' + parameter + ': ' + JSON.stringify(settings[parameter]));
	    }
	  }
	
	  return;
	};
	
	/**
	 * Configuration Object skeleton.
	 * @private
	 */
	UA.configuration_skeleton = (function() {
	  var idx,  parameter,
	    skeleton = {},
	    parameters = [
	      // Internal parameters
	      "sipjsId",
	      "hostportParams",
	
	      // Optional user configurable parameters
	      "uri",
	      "wsServers",
	      "authorizationUser",
	      "connectionRecoveryMaxInterval",
	      "connectionRecoveryMinInterval",
	      "keepAliveInterval",
	      "extraSupported",
	      "displayName",
	      "hackViaTcp", // false.
	      "hackIpInContact", //false
	      "hackWssInTransport", //false
	      "hackAllowUnregisteredOptionTags", //false
	      "contactTransport", // 'ws'
	      "forceRport", // false
	      "iceCheckingTimeout",
	      "instanceId",
	      "noAnswerTimeout", // 30 seconds.
	      "password",
	      "registerExpires", // 600 seconds.
	      "registrarServer",
	      "reliable",
	      "rel100",
	      "replaces",
	      "userAgentString", //SIP.C.USER_AGENT
	      "autostart",
	      "stunServers",
	      "traceSip",
	      "turnServers",
	      "usePreloadedRoute",
	      "wsServerMaxReconnection",
	      "wsServerReconnectionTimeout",
	      "mediaHandlerFactory",
	      "media",
	      "mediaConstraints",
	      "authenticationFactory",
	
	      // Post-configuration generated parameters
	      "via_core_value",
	      "viaHost"
	    ];
	
	  for(idx in parameters) {
	    parameter = parameters[idx];
	    skeleton[parameter] = {
	      value: '',
	      writable: false,
	      configurable: false
	    };
	  }
	
	  skeleton['register'] = {
	    value: '',
	    writable: true,
	    configurable: false
	  };
	
	  return skeleton;
	}());
	
	/**
	 * Configuration checker.
	 * @private
	 * @return {Boolean}
	 */
	UA.configuration_check = {
	  mandatory: {
	  },
	
	  optional: {
	
	    uri: function(uri) {
	      var parsed;
	
	      if (!(/^sip:/i).test(uri)) {
	        uri = SIP.C.SIP + ':' + uri;
	      }
	      parsed = SIP.URI.parse(uri);
	
	      if(!parsed) {
	        return;
	      } else if(!parsed.user) {
	        return;
	      } else {
	        return parsed;
	      }
	    },
	
	    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid
	    wsServers: function(wsServers) {
	      var idx, length, url;
	
	      /* Allow defining wsServers parameter as:
	       *  String: "host"
	       *  Array of Strings: ["host1", "host2"]
	       *  Array of Objects: [{ws_uri:"host1", weight:1}, {ws_uri:"host2", weight:0}]
	       *  Array of Objects and Strings: [{ws_uri:"host1"}, "host2"]
	       */
	      if (typeof wsServers === 'string') {
	        wsServers = [{ws_uri: wsServers}];
	      } else if (wsServers instanceof Array) {
	        length = wsServers.length;
	        for (idx = 0; idx < length; idx++) {
	          if (typeof wsServers[idx] === 'string'){
	            wsServers[idx] = {ws_uri: wsServers[idx]};
	          }
	        }
	      } else {
	        return;
	      }
	
	      if (wsServers.length === 0) {
	        return false;
	      }
	
	      length = wsServers.length;
	      for (idx = 0; idx < length; idx++) {
	        if (!wsServers[idx].ws_uri) {
	          return;
	        }
	        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {
	          return;
	        }
	
	        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');
	
	        if(url === -1) {
	          return;
	        } else if(['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {
	          return;
	        } else {
	          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';
	
	          if (!wsServers[idx].weight) {
	            wsServers[idx].weight = 0;
	          }
	
	          wsServers[idx].status = 0;
	          wsServers[idx].scheme = url.scheme.toUpperCase();
	        }
	      }
	      return wsServers;
	    },
	
	    authorizationUser: function(authorizationUser) {
	      if(SIP.Grammar.parse('"'+ authorizationUser +'"', 'quoted_string') === -1) {
	        return;
	      } else {
	        return authorizationUser;
	      }
	    },
	
	    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {
	      var value;
	      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {
	        value = Number(connectionRecoveryMaxInterval);
	        if(value > 0) {
	          return value;
	        }
	      }
	    },
	
	    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {
	      var value;
	      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {
	        value = Number(connectionRecoveryMinInterval);
	        if(value > 0) {
	          return value;
	        }
	      }
	    },
	
	    displayName: function(displayName) {
	      if(SIP.Grammar.parse('"' + displayName + '"', 'displayName') === -1) {
	        return;
	      } else {
	        return displayName;
	      }
	    },
	
	    hackViaTcp: function(hackViaTcp) {
	      if (typeof hackViaTcp === 'boolean') {
	        return hackViaTcp;
	      }
	    },
	
	    hackIpInContact: function(hackIpInContact) {
	      if (typeof hackIpInContact === 'boolean') {
	        return hackIpInContact;
	      }
	      else if (typeof hackIpInContact === 'string' && SIP.Grammar.parse(hackIpInContact, 'host') !== -1) {
	        return hackIpInContact;
	      }
	    },
	
	    iceCheckingTimeout: function(iceCheckingTimeout) {
	      if(SIP.Utils.isDecimal(iceCheckingTimeout)) {
	        return Math.max(500, iceCheckingTimeout);
	      }
	    },
	
	    hackWssInTransport: function(hackWssInTransport) {
	      if (typeof hackWssInTransport === 'boolean') {
	        return hackWssInTransport;
	      }
	    },
	
	    hackAllowUnregisteredOptionTags: function(hackAllowUnregisteredOptionTags) {
	      if (typeof hackAllowUnregisteredOptionTags === 'boolean') {
	        return hackAllowUnregisteredOptionTags;
	      }
	    },
	
	    contactTransport: function(contactTransport) {
	      if (typeof contactTransport === 'string') {
	        return contactTransport;
	      }
	    },
	
	    forceRport: function(forceRport) {
	      if (typeof forceRport === 'boolean') {
	        return forceRport;
	      }
	    },
	
	    instanceId: function(instanceId) {
	      if(typeof instanceId !== 'string') {
	        return;
	      }
	
	      if ((/^uuid:/i.test(instanceId))) {
	        instanceId = instanceId.substr(5);
	      }
	
	      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {
	        return;
	      } else {
	        return instanceId;
	      }
	    },
	
	    keepAliveInterval: function(keepAliveInterval) {
	      var value;
	      if (SIP.Utils.isDecimal(keepAliveInterval)) {
	        value = Number(keepAliveInterval);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    extraSupported: function(optionTags) {
	      var idx, length;
	
	      if (!(optionTags instanceof Array)) {
	        return;
	      }
	
	      length = optionTags.length;
	      for (idx = 0; idx < length; idx++) {
	        if (typeof optionTags[idx] !== 'string') {
	          return;
	        }
	      }
	
	      return optionTags;
	    },
	
	    noAnswerTimeout: function(noAnswerTimeout) {
	      var value;
	      if (SIP.Utils.isDecimal(noAnswerTimeout)) {
	        value = Number(noAnswerTimeout);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    password: function(password) {
	      return String(password);
	    },
	
	    rel100: function(rel100) {
	      if(rel100 === SIP.C.supported.REQUIRED) {
	        return SIP.C.supported.REQUIRED;
	      } else if (rel100 === SIP.C.supported.SUPPORTED) {
	        return SIP.C.supported.SUPPORTED;
	      } else  {
	        return SIP.C.supported.UNSUPPORTED;
	      }
	    },
	
	    replaces: function(replaces) {
	      if(replaces === SIP.C.supported.REQUIRED) {
	        return SIP.C.supported.REQUIRED;
	      } else if (replaces === SIP.C.supported.SUPPORTED) {
	        return SIP.C.supported.SUPPORTED;
	      } else  {
	        return SIP.C.supported.UNSUPPORTED;
	      }
	    },
	
	    register: function(register) {
	      if (typeof register === 'boolean') {
	        return register;
	      }
	    },
	
	    registerExpires: function(registerExpires) {
	      var value;
	      if (SIP.Utils.isDecimal(registerExpires)) {
	        value = Number(registerExpires);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    registrarServer: function(registrarServer) {
	      var parsed;
	
	      if(typeof registrarServer !== 'string') {
	        return;
	      }
	
	      if (!/^sip:/i.test(registrarServer)) {
	        registrarServer = SIP.C.SIP + ':' + registrarServer;
	      }
	      parsed = SIP.URI.parse(registrarServer);
	
	      if(!parsed) {
	        return;
	      } else if(parsed.user) {
	        return;
	      } else {
	        return parsed;
	      }
	    },
	
	    stunServers: function(stunServers) {
	      var idx, length, stun_server;
	
	      if (typeof stunServers === 'string') {
	        stunServers = [stunServers];
	      } else if (!(stunServers instanceof Array)) {
	        return;
	      }
	
	      length = stunServers.length;
	      for (idx = 0; idx < length; idx++) {
	        stun_server = stunServers[idx];
	        if (!(/^stuns?:/.test(stun_server))) {
	          stun_server = 'stun:' + stun_server;
	        }
	
	        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {
	          return;
	        } else {
	          stunServers[idx] = stun_server;
	        }
	      }
	      return stunServers;
	    },
	
	    traceSip: function(traceSip) {
	      if (typeof traceSip === 'boolean') {
	        return traceSip;
	      }
	    },
	
	    turnServers: function(turnServers) {
	      var idx, jdx, length, turn_server, num_turn_server_urls, url;
	
	      if (turnServers instanceof Array) {
	        // Do nothing
	      } else {
	        turnServers = [turnServers];
	      }
	
	      length = turnServers.length;
	      for (idx = 0; idx < length; idx++) {
	        turn_server = turnServers[idx];
	        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.
	        if (turn_server.server) {
	          turn_server.urls = [turn_server.server];
	        }
	
	        if (!turn_server.urls || !turn_server.username || !turn_server.password) {
	          return;
	        }
	
	        if (turn_server.urls instanceof Array) {
	          num_turn_server_urls = turn_server.urls.length;
	        } else {
	          turn_server.urls = [turn_server.urls];
	          num_turn_server_urls = 1;
	        }
	
	        for (jdx = 0; jdx < num_turn_server_urls; jdx++) {
	          url = turn_server.urls[jdx];
	
	          if (!(/^turns?:/.test(url))) {
	            url = 'turn:' + url;
	          }
	
	          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {
	            return;
	          }
	        }
	      }
	      return turnServers;
	    },
	
	    userAgentString: function(userAgentString) {
	      if (typeof userAgentString === 'string') {
	        return userAgentString;
	      }
	    },
	
	    usePreloadedRoute: function(usePreloadedRoute) {
	      if (typeof usePreloadedRoute === 'boolean') {
	        return usePreloadedRoute;
	      }
	    },
	
	    wsServerMaxReconnection: function(wsServerMaxReconnection) {
	      var value;
	      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {
	        value = Number(wsServerMaxReconnection);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {
	      var value;
	      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {
	        value = Number(wsServerReconnectionTimeout);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    autostart: function(autostart) {
	      if (typeof autostart === 'boolean') {
	        return autostart;
	      }
	    },
	
	    mediaHandlerFactory: function(mediaHandlerFactory) {
	      if (mediaHandlerFactory instanceof Function) {
	        var promisifiedFactory = function promisifiedFactory () {
	          var mediaHandler = mediaHandlerFactory.apply(this, arguments);
	
	          function patchMethod (methodName) {
	            var method = mediaHandler[methodName];
	            if (method.length > 1) {
	              var callbacksFirst = methodName === 'getDescription';
	              mediaHandler[methodName] = SIP.Utils.promisify(mediaHandler, methodName, callbacksFirst);
	            }
	          }
	
	          patchMethod('getDescription');
	          patchMethod('setDescription');
	
	          return mediaHandler;
	        };
	
	        promisifiedFactory.isSupported = mediaHandlerFactory.isSupported;
	        return promisifiedFactory;
	      }
	    },
	
	    authenticationFactory: checkAuthenticationFactory
	  }
	};
	
	UA.C = C;
	SIP.UA = UA;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 240 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Hacks - This file contains all of the things we
	 * wish we didn't have to do, just for interop.  It is similar to
	 * Utils, which provides actually useful and relevant functions for
	 * a SIP library. Methods in this file are grouped by vendor, so
	 * as to most easily track when particular hacks may not be necessary anymore.
	 */
	
	module.exports = function (SIP) {
	
	//keep to quiet jshint, and remain consistent with other files
	SIP = SIP;
	
	var Hacks = {
	  AllBrowsers: {
	    maskDtls: function (message) {
	      if (message.body) {
	        message.body = message.body.replace(/ UDP\/TLS\/RTP\/SAVP/gmi, " RTP/SAVP");
	      }
	    },
	    unmaskDtls: function (sdp) {
	      /**
	       * Chrome does not handle DTLS correctly (Canaray does, but not production)
	       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)
	       *
	       * UPDATE: May 21, 2014
	       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES
	       *
	       * UPDATE: 2014-09-24
	       * Opera now supports DTLS by default as well.
	       *
	       **/
	      return sdp.replace(/ RTP\/SAVP/gmi, " UDP/TLS/RTP/SAVP");
	    }
	  },
	  Firefox: {
	    /* Condition to detect if hacks are applicable */
	    isFirefox: function () {
	      return typeof mozRTCPeerConnection !== 'undefined';
	    },
	
	    cannotHandleExtraWhitespace: function (message) {
	      if (this.isFirefox() && message.body) {
	        message.body = message.body.replace(/ \r\n/g, "\r\n");
	      }
	    },
	
	    hasMissingCLineInSDP: function (sdp) {
	      /*
	       * This is a Firefox hack to insert valid sdp when getDescription is
	       * called with the constraint offerToReceiveVideo = false.
	       * We search for either a c-line at the top of the sdp above all
	       * m-lines. If that does not exist then we search for a c-line
	       * beneath each m-line. If it is missing a c-line, we insert
	       * a fake c-line with the ip address 0.0.0.0. This is then valid
	       * sdp and no media will be sent for that m-line.
	       *
	       * Valid SDP is:
	       * m=
	       * i=
	       * c=
	       */
	      var insertAt, mlines;
	      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {
	
	        // Find all m= lines
	        mlines = sdp.match(/m=.*\r\n.*/g);
	        for (var i=0; i<mlines.length; i++) {
	
	          // If it has an i= line, check if the next line is the c= line
	          if (mlines[i].toString().search(/i=.*/) >= 0) {
	            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;
	            if (sdp.substr(insertAt,2)!=='c=') {
	              sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
	            }
	
	          // else add the C line if it's missing
	          } else if (mlines[i].toString().search(/c=.*/) < 0) {
	            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;
	            sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
	          }
	        }
	      }
	      return sdp;
	    },
	  },
	
	  Chrome: {
	    needsExplicitlyInactiveSDP: function (sdp) {
	      var sub, index;
	
	      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending
	        index = sdp.indexOf('m=video 0');
	        if (index !== -1) {
	          sub = sdp.substr(index);
	          sub = sub.replace(/\r\nc=IN IP4.*\r\n$/,
	                            '\r\nc=IN IP4 0.0.0.0\r\na=inactive\r\n');
	          return sdp.substr(0, index) + sub;
	        }
	      }
	      return sdp;
	    },
	
	    getsConfusedAboutGUM: function (session) {
	      if (session.mediaHandler) {
	        session.mediaHandler.close();
	      }
	    }
	  }
	};
	return Hacks;
	};

/***/ },
/* 241 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Incoming SIP Message Sanity Check
	 */
	
	/**
	 * SIP message sanity check.
	 * @augments SIP
	 * @function
	 * @param {SIP.IncomingMessage} message
	 * @param {SIP.UA} ua
	 * @param {SIP.Transport} transport
	 * @returns {Boolean}
	 */
	module.exports = function (SIP) {
	var sanityCheck,
	 logger,
	 message, ua, transport,
	 requests = [],
	 responses = [],
	 all = [];
	
	// Reply
	function reply(status_code) {
	  var to,
	    response = SIP.Utils.buildStatusLine(status_code),
	    vias = message.getHeaders('via'),
	    length = vias.length,
	    idx = 0;
	
	  for(idx; idx < length; idx++) {
	    response += "Via: " + vias[idx] + "\r\n";
	  }
	
	  to = message.getHeader('To');
	
	  if(!message.to_tag) {
	    to += ';tag=' + SIP.Utils.newTag();
	  }
	
	  response += "To: " + to + "\r\n";
	  response += "From: " + message.getHeader('From') + "\r\n";
	  response += "Call-ID: " + message.call_id + "\r\n";
	  response += "CSeq: " + message.cseq + " " + message.method + "\r\n";
	  response += "\r\n";
	
	  transport.send(response);
	}
	
	/*
	 * Sanity Check for incoming Messages
	 *
	 * Requests:
	 *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
	 *  - _rfc3261_16_3_4_ Receive a Request already sent by us
	 *   Does not look at via sent-by but at sipjsId, which is inserted as
	 *   a prefix in all initial requests generated by the ua
	 *  - _rfc3261_18_3_request_ Body Content-Length
	 *  - _rfc3261_8_2_2_2_ Merged Requests
	 *
	 * Responses:
	 *  - _rfc3261_8_1_3_3_ Multiple Via headers
	 *  - _rfc3261_18_1_2_ sent-by mismatch
	 *  - _rfc3261_18_3_response_ Body Content-Length
	 *
	 * All:
	 *  - Minimum headers in a SIP message
	 */
	
	// Sanity Check functions for requests
	function rfc3261_8_2_2_1() {
	  if(!message.ruri || message.ruri.scheme !== 'sip') {
	    reply(416);
	    return false;
	  }
	}
	
	function rfc3261_16_3_4() {
	  if(!message.to_tag) {
	    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {
	      reply(482);
	      return false;
	    }
	  }
	}
	
	function rfc3261_18_3_request() {
	  var len = SIP.Utils.str_utf8_length(message.body),
	  contentLength = message.getHeader('content-length');
	
	  if(len < contentLength) {
	    reply(400);
	    return false;
	  }
	}
	
	function rfc3261_8_2_2_2() {
	  var tr, idx,
	    fromTag = message.from_tag,
	    call_id = message.call_id,
	    cseq = message.cseq;
	
	  if(!message.to_tag) {
	    if(message.method === SIP.C.INVITE) {
	      tr = ua.transactions.ist[message.via_branch];
	      if(tr) {
	        return;
	      } else {
	        for(idx in ua.transactions.ist) {
	          tr = ua.transactions.ist[idx];
	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
	            reply(482);
	            return false;
	          }
	        }
	      }
	    } else {
	      tr = ua.transactions.nist[message.via_branch];
	      if(tr) {
	        return;
	      } else {
	        for(idx in ua.transactions.nist) {
	          tr = ua.transactions.nist[idx];
	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
	            reply(482);
	            return false;
	          }
	        }
	      }
	    }
	  }
	}
	
	// Sanity Check functions for responses
	function rfc3261_8_1_3_3() {
	  if(message.getHeaders('via').length > 1) {
	    logger.warn('More than one Via header field present in the response. Dropping the response');
	    return false;
	  }
	}
	
	function rfc3261_18_1_2() {
	  var viaHost = ua.configuration.viaHost;
	  if(message.via.host !== viaHost || message.via.port !== undefined) {
	    logger.warn('Via sent-by in the response does not match UA Via host value. Dropping the response');
	    return false;
	  }
	}
	
	function rfc3261_18_3_response() {
	  var
	    len = SIP.Utils.str_utf8_length(message.body),
	    contentLength = message.getHeader('content-length');
	
	    if(len < contentLength) {
	      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');
	      return false;
	    }
	}
	
	// Sanity Check functions for requests and responses
	function minimumHeaders() {
	  var
	    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],
	    idx = mandatoryHeaders.length;
	
	  while(idx--) {
	    if(!message.hasHeader(mandatoryHeaders[idx])) {
	      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');
	      return false;
	    }
	  }
	}
	
	requests.push(rfc3261_8_2_2_1);
	requests.push(rfc3261_16_3_4);
	requests.push(rfc3261_18_3_request);
	requests.push(rfc3261_8_2_2_2);
	
	responses.push(rfc3261_8_1_3_3);
	responses.push(rfc3261_18_1_2);
	responses.push(rfc3261_18_3_response);
	
	all.push(minimumHeaders);
	
	sanityCheck = function(m, u, t) {
	  var len, pass;
	
	  message = m;
	  ua = u;
	  transport = t;
	
	  logger = ua.getLogger('sip.sanitycheck');
	
	  len = all.length;
	  while(len--) {
	    pass = all[len](message);
	    if(pass === false) {
	      return false;
	    }
	  }
	
	  if(message instanceof SIP.IncomingRequest) {
	    len = requests.length;
	    while(len--) {
	      pass = requests[len](message);
	      if(pass === false) {
	        return false;
	      }
	    }
	  }
	
	  else if(message instanceof SIP.IncomingResponse) {
	    len = responses.length;
	    while(len--) {
	      pass = responses[len](message);
	      if(pass === false) {
	        return false;
	      }
	    }
	  }
	
	  //Everything is OK
	  return true;
	};
	
	SIP.sanityCheck = sanityCheck;
	};


/***/ },
/* 242 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview SIP Digest Authentication
	 */
	
	/**
	 * SIP Digest Authentication.
	 * @augments SIP.
	 * @function Digest Authentication
	 * @param {SIP.UA} ua
	 */
	module.exports = function (Utils) {
	var DigestAuthentication;
	
	DigestAuthentication = function(ua) {
	  this.logger = ua.getLogger('sipjs.digestauthentication');
	  this.username = ua.configuration.authorizationUser;
	  this.password = ua.configuration.password;
	  this.cnonce = null;
	  this.nc = 0;
	  this.ncHex = '00000000';
	  this.response = null;
	};
	
	
	/**
	* Performs Digest authentication given a SIP request and the challenge
	* received in a response to that request.
	* Returns true if credentials were successfully generated, false otherwise.
	*
	* @param {SIP.OutgoingRequest} request
	* @param {Object} challenge
	*/
	DigestAuthentication.prototype.authenticate = function(request, challenge) {
	  // Inspect and validate the challenge.
	
	  this.algorithm = challenge.algorithm;
	  this.realm = challenge.realm;
	  this.nonce = challenge.nonce;
	  this.opaque = challenge.opaque;
	  this.stale = challenge.stale;
	
	  if (this.algorithm) {
	    if (this.algorithm !== 'MD5') {
	      this.logger.warn('challenge with Digest algorithm different than "MD5", authentication aborted');
	      return false;
	    }
	  } else {
	    this.algorithm = 'MD5';
	  }
	
	  if (! this.realm) {
	    this.logger.warn('challenge without Digest realm, authentication aborted');
	    return false;
	  }
	
	  if (! this.nonce) {
	    this.logger.warn('challenge without Digest nonce, authentication aborted');
	    return false;
	  }
	
	  // 'qop' can contain a list of values (Array). Let's choose just one.
	  if (challenge.qop) {
	    if (challenge.qop.indexOf('auth') > -1) {
	      this.qop = 'auth';
	    } else if (challenge.qop.indexOf('auth-int') > -1) {
	      this.qop = 'auth-int';
	    } else {
	      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
	      this.logger.warn('challenge without Digest qop different than "auth" or "auth-int", authentication aborted');
	      return false;
	    }
	  } else {
	    this.qop = null;
	  }
	
	  // Fill other attributes.
	
	  this.method = request.method;
	  this.uri = request.ruri;
	  this.cnonce = Utils.createRandomToken(12);
	  this.nc += 1;
	  this.updateNcHex();
	
	  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
	  if (this.nc === 4294967296) {
	    this.nc = 1;
	    this.ncHex = '00000001';
	  }
	
	  // Calculate the Digest "response" value.
	  this.calculateResponse();
	
	  return true;
	};
	
	
	/**
	* Generate Digest 'response' value.
	* @private
	*/
	DigestAuthentication.prototype.calculateResponse = function() {
	  var ha1, ha2;
	
	  // HA1 = MD5(A1) = MD5(username:realm:password)
	  ha1 = Utils.calculateMD5(this.username + ":" + this.realm + ":" + this.password);
	
	  if (this.qop === 'auth') {
	    // HA2 = MD5(A2) = MD5(method:digestURI)
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
	
	  } else if (this.qop === 'auth-int') {
	    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri + ":" + Utils.calculateMD5(this.body ? this.body : ""));
	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
	
	  } else if (this.qop === null) {
	    // HA2 = MD5(A2) = MD5(method:digestURI)
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
	    // response = MD5(HA1:nonce:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + ha2);
	  }
	};
	
	
	/**
	* Return the Proxy-Authorization or WWW-Authorization header value.
	*/
	DigestAuthentication.prototype.toString = function() {
	  var auth_params = [];
	
	  if (! this.response) {
	    throw new Error('response field does not exist, cannot generate Authorization header');
	  }
	
	  auth_params.push('algorithm=' + this.algorithm);
	  auth_params.push('username="' + this.username + '"');
	  auth_params.push('realm="' + this.realm + '"');
	  auth_params.push('nonce="' + this.nonce + '"');
	  auth_params.push('uri="' + this.uri + '"');
	  auth_params.push('response="' + this.response + '"');
	  if (this.opaque) {
	    auth_params.push('opaque="' + this.opaque + '"');
	  }
	  if (this.qop) {
	    auth_params.push('qop=' + this.qop);
	    auth_params.push('cnonce="' + this.cnonce + '"');
	    auth_params.push('nc=' + this.ncHex);
	  }
	
	  return 'Digest ' + auth_params.join(', ');
	};
	
	
	/**
	* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
	* @private
	*/
	DigestAuthentication.prototype.updateNcHex = function() {
	  var hex = Number(this.nc).toString(16);
	  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;
	};
	
	return DigestAuthentication;
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Grammar = __webpack_require__(244);
	
	module.exports = function (SIP) {
	
	return {
	  parse: function parseCustom (input, startRule) {
	    var options = {startRule: startRule, SIP: SIP};
	    try {
	      Grammar.parse(input, options);
	    } catch (e) {
	      options.data = -1;
	    }
	    return options.data;
	  }
	};
	
	};


/***/ },
/* 244 */
/***/ function(module, exports) {

	module.exports = (function() {
	  /*
	   * Generated by PEG.js 0.8.0.
	   *
	   * http://pegjs.majda.cz/
	   */
	
	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }
	
	  function SyntaxError(message, expected, found, offset, line, column) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.offset   = offset;
	    this.line     = line;
	    this.column   = column;
	
	    this.name     = "SyntaxError";
	  }
	
	  peg$subclass(SyntaxError, Error);
	
	  function parse(input) {
	    var options = arguments.length > 1 ? arguments[1] : {},
	
	        peg$FAILED = {},
	
	        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 185, Supported: 190, Require: 181, Via: 193, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Min_SE: 212, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, Replaces: 178, Session_Expires: 209, stun_URI: 216, To: 191, turn_URI: 223, uuid: 226, WWW_Authenticate: 208, challenge: 157 },
	        peg$startRuleIndex   = 118,
	
	        peg$consts = [
	          "\r\n",
	          { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
	          /^[0-9]/,
	          { type: "class", value: "[0-9]", description: "[0-9]" },
	          /^[a-zA-Z]/,
	          { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
	          /^[0-9a-fA-F]/,
	          { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
	          /^[\0-\xFF]/,
	          { type: "class", value: "[\\0-\\xFF]", description: "[\\0-\\xFF]" },
	          /^["]/,
	          { type: "class", value: "[\"]", description: "[\"]" },
	          " ",
	          { type: "literal", value: " ", description: "\" \"" },
	          "\t",
	          { type: "literal", value: "\t", description: "\"\\t\"" },
	          /^[a-zA-Z0-9]/,
	          { type: "class", value: "[a-zA-Z0-9]", description: "[a-zA-Z0-9]" },
	          ";",
	          { type: "literal", value: ";", description: "\";\"" },
	          "/",
	          { type: "literal", value: "/", description: "\"/\"" },
	          "?",
	          { type: "literal", value: "?", description: "\"?\"" },
	          ":",
	          { type: "literal", value: ":", description: "\":\"" },
	          "@",
	          { type: "literal", value: "@", description: "\"@\"" },
	          "&",
	          { type: "literal", value: "&", description: "\"&\"" },
	          "=",
	          { type: "literal", value: "=", description: "\"=\"" },
	          "+",
	          { type: "literal", value: "+", description: "\"+\"" },
	          "$",
	          { type: "literal", value: "$", description: "\"$\"" },
	          ",",
	          { type: "literal", value: ",", description: "\",\"" },
	          "-",
	          { type: "literal", value: "-", description: "\"-\"" },
	          "_",
	          { type: "literal", value: "_", description: "\"_\"" },
	          ".",
	          { type: "literal", value: ".", description: "\".\"" },
	          "!",
	          { type: "literal", value: "!", description: "\"!\"" },
	          "~",
	          { type: "literal", value: "~", description: "\"~\"" },
	          "*",
	          { type: "literal", value: "*", description: "\"*\"" },
	          "'",
	          { type: "literal", value: "'", description: "\"'\"" },
	          "(",
	          { type: "literal", value: "(", description: "\"(\"" },
	          ")",
	          { type: "literal", value: ")", description: "\")\"" },
	          peg$FAILED,
	          "%",
	          { type: "literal", value: "%", description: "\"%\"" },
	          null,
	          [],
	          function() {return " "; },
	          function() {return ':'; },
	          /^[!-~]/,
	          { type: "class", value: "[!-~]", description: "[!-~]" },
	          /^[\x80-\uFFFF]/,
	          { type: "class", value: "[\\x80-\\uFFFF]", description: "[\\x80-\\uFFFF]" },
	          /^[\x80-\xBF]/,
	          { type: "class", value: "[\\x80-\\xBF]", description: "[\\x80-\\xBF]" },
	          /^[a-f]/,
	          { type: "class", value: "[a-f]", description: "[a-f]" },
	          "`",
	          { type: "literal", value: "`", description: "\"`\"" },
	          "<",
	          { type: "literal", value: "<", description: "\"<\"" },
	          ">",
	          { type: "literal", value: ">", description: "\">\"" },
	          "\\",
	          { type: "literal", value: "\\", description: "\"\\\\\"" },
	          "[",
	          { type: "literal", value: "[", description: "\"[\"" },
	          "]",
	          { type: "literal", value: "]", description: "\"]\"" },
	          "{",
	          { type: "literal", value: "{", description: "\"{\"" },
	          "}",
	          { type: "literal", value: "}", description: "\"}\"" },
	          function() {return "*"; },
	          function() {return "/"; },
	          function() {return "="; },
	          function() {return "("; },
	          function() {return ")"; },
	          function() {return ">"; },
	          function() {return "<"; },
	          function() {return ","; },
	          function() {return ";"; },
	          function() {return ":"; },
	          function() {return "\""; },
	          /^[!-']/,
	          { type: "class", value: "[!-']", description: "[!-']" },
	          /^[*-[]/,
	          { type: "class", value: "[*-[]", description: "[*-[]" },
	          /^[\]-~]/,
	          { type: "class", value: "[\\]-~]", description: "[\\]-~]" },
	          function(contents) {
	                                  return contents; },
	          /^[#-[]/,
	          { type: "class", value: "[#-[]", description: "[#-[]" },
	          /^[\0-\t]/,
	          { type: "class", value: "[\\0-\\t]", description: "[\\0-\\t]" },
	          /^[\x0B-\f]/,
	          { type: "class", value: "[\\x0B-\\f]", description: "[\\x0B-\\f]" },
	          /^[\x0E-]/,
	          { type: "class", value: "[\\x0E-]", description: "[\\x0E-]" },
	          function() {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                },
	          function() {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                  delete options.data.uri_params;
	
	                                  if (options.startRule === 'SIP_URI') { options.data = options.data.uri;}
	                                },
	          "sips",
	          { type: "literal", value: "sips", description: "\"sips\"" },
	          "sip",
	          { type: "literal", value: "sip", description: "\"sip\"" },
	          function(uri_scheme) {
	                              options.data.scheme = uri_scheme; },
	          function() {
	                              options.data.user = decodeURIComponent(text().slice(0, -1));},
	          function() {
	                              options.data.password = text(); },
	          function() {
	                              options.data.host = text();
	                              return options.data.host; },
	          function() {
	                            options.data.host_type = 'domain';
	                            return text(); },
	          /^[a-zA-Z0-9_\-]/,
	          { type: "class", value: "[a-zA-Z0-9_\\-]", description: "[a-zA-Z0-9_\\-]" },
	          /^[a-zA-Z0-9\-]/,
	          { type: "class", value: "[a-zA-Z0-9\\-]", description: "[a-zA-Z0-9\\-]" },
	          function() {
	                              options.data.host_type = 'IPv6';
	                              return text(); },
	          "::",
	          { type: "literal", value: "::", description: "\"::\"" },
	          function() {
	                            options.data.host_type = 'IPv6';
	                            return text(); },
	          function() {
	                              options.data.host_type = 'IPv4';
	                              return text(); },
	          "25",
	          { type: "literal", value: "25", description: "\"25\"" },
	          /^[0-5]/,
	          { type: "class", value: "[0-5]", description: "[0-5]" },
	          "2",
	          { type: "literal", value: "2", description: "\"2\"" },
	          /^[0-4]/,
	          { type: "class", value: "[0-4]", description: "[0-4]" },
	          "1",
	          { type: "literal", value: "1", description: "\"1\"" },
	          /^[1-9]/,
	          { type: "class", value: "[1-9]", description: "[1-9]" },
	          function(port) {
	                              port = parseInt(port.join(''));
	                              options.data.port = port;
	                              return port; },
	          "transport=",
	          { type: "literal", value: "transport=", description: "\"transport=\"" },
	          "udp",
	          { type: "literal", value: "udp", description: "\"udp\"" },
	          "tcp",
	          { type: "literal", value: "tcp", description: "\"tcp\"" },
	          "sctp",
	          { type: "literal", value: "sctp", description: "\"sctp\"" },
	          "tls",
	          { type: "literal", value: "tls", description: "\"tls\"" },
	          function(transport) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['transport'] = transport.toLowerCase(); },
	          "user=",
	          { type: "literal", value: "user=", description: "\"user=\"" },
	          "phone",
	          { type: "literal", value: "phone", description: "\"phone\"" },
	          "ip",
	          { type: "literal", value: "ip", description: "\"ip\"" },
	          function(user) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['user'] = user.toLowerCase(); },
	          "method=",
	          { type: "literal", value: "method=", description: "\"method=\"" },
	          function(method) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['method'] = method; },
	          "ttl=",
	          { type: "literal", value: "ttl=", description: "\"ttl=\"" },
	          function(ttl) {
	                                if(!options.data.params) options.data.params={};
	                                options.data.params['ttl'] = ttl; },
	          "maddr=",
	          { type: "literal", value: "maddr=", description: "\"maddr=\"" },
	          function(maddr) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['maddr'] = maddr; },
	          "lr",
	          { type: "literal", value: "lr", description: "\"lr\"" },
	          function() {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['lr'] = undefined; },
	          function(param, value) {
	                                if(!options.data.uri_params) options.data.uri_params = {};
	                                if (value === null){
	                                  value = undefined;
	                                }
	                                else {
	                                  value = value[1];
	                                }
	                                options.data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},
	          function(hname, hvalue) {
	                                hname = hname.join('').toLowerCase();
	                                hvalue = hvalue.join('');
	                                if(!options.data.uri_headers) options.data.uri_headers = {};
	                                if (!options.data.uri_headers[hname]) {
	                                  options.data.uri_headers[hname] = [hvalue];
	                                } else {
	                                  options.data.uri_headers[hname].push(hvalue);
	                                }},
	          function() {
	                                // lots of tests fail if this isn't guarded...
	                                if (options.startRule === 'Refer_To') {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                  delete options.data.uri_params;
	                                }
	                              },
	          "//",
	          { type: "literal", value: "//", description: "\"//\"" },
	          function() {
	                              options.data.scheme= text(); },
	          { type: "literal", value: "SIP", description: "\"SIP\"" },
	          function() {
	                              options.data.sip_version = text(); },
	          "INVITE",
	          { type: "literal", value: "INVITE", description: "\"INVITE\"" },
	          "ACK",
	          { type: "literal", value: "ACK", description: "\"ACK\"" },
	          "VXACH",
	          { type: "literal", value: "VXACH", description: "\"VXACH\"" },
	          "OPTIONS",
	          { type: "literal", value: "OPTIONS", description: "\"OPTIONS\"" },
	          "BYE",
	          { type: "literal", value: "BYE", description: "\"BYE\"" },
	          "CANCEL",
	          { type: "literal", value: "CANCEL", description: "\"CANCEL\"" },
	          "REGISTER",
	          { type: "literal", value: "REGISTER", description: "\"REGISTER\"" },
	          "SUBSCRIBE",
	          { type: "literal", value: "SUBSCRIBE", description: "\"SUBSCRIBE\"" },
	          "NOTIFY",
	          { type: "literal", value: "NOTIFY", description: "\"NOTIFY\"" },
	          "REFER",
	          { type: "literal", value: "REFER", description: "\"REFER\"" },
	          function() {
	
	                              options.data.method = text();
	                              return options.data.method; },
	          function(status_code) {
	                            options.data.status_code = parseInt(status_code.join('')); },
	          function() {
	                            options.data.reason_phrase = text(); },
	          function() {
	                        options.data = text(); },
	          function() {
	                                  var idx, length;
	                                  length = options.data.multi_header.length;
	                                  for (idx = 0; idx < length; idx++) {
	                                    if (options.data.multi_header[idx].parsed === null) {
	                                      options.data = null;
	                                      break;
	                                    }
	                                  }
	                                  if (options.data !== null) {
	                                    options.data = options.data.multi_header;
	                                  } else {
	                                    options.data = -1;
	                                  }},
	          function() {
	                                  var header;
	                                  if(!options.data.multi_header) options.data.multi_header = [];
	                                  try {
	                                    header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                                    delete options.data.uri;
	                                    delete options.data.displayName;
	                                    delete options.data.params;
	                                  } catch(e) {
	                                    header = null;
	                                  }
	                                  options.data.multi_header.push( { 'position': peg$currPos,
	                                                            'offset': offset(),
	                                                            'parsed': header
	                                                          });},
	          function(displayName) {
	                                  displayName = text().trim();
	                                  if (displayName[0] === '\"') {
	                                    displayName = displayName.substring(1, displayName.length-1);
	                                  }
	                                  options.data.displayName = displayName; },
	          "q",
	          { type: "literal", value: "q", description: "\"q\"" },
	          function(q) {
	                                  if(!options.data.params) options.data.params = {};
	                                  options.data.params['q'] = q; },
	          "expires",
	          { type: "literal", value: "expires", description: "\"expires\"" },
	          function(expires) {
	                                  if(!options.data.params) options.data.params = {};
	                                  options.data.params['expires'] = expires; },
	          function(delta_seconds) {
	                                  return parseInt(delta_seconds.join('')); },
	          "0",
	          { type: "literal", value: "0", description: "\"0\"" },
	          function() {
	                                  return parseFloat(text()); },
	          function(param, value) {
	                                  if(!options.data.params) options.data.params = {};
	                                  if (value === null){
	                                    value = undefined;
	                                  }
	                                  else {
	                                    value = value[1];
	                                  }
	                                  options.data.params[param.toLowerCase()] = value;},
	          "render",
	          { type: "literal", value: "render", description: "\"render\"" },
	          "session",
	          { type: "literal", value: "session", description: "\"session\"" },
	          "icon",
	          { type: "literal", value: "icon", description: "\"icon\"" },
	          "alert",
	          { type: "literal", value: "alert", description: "\"alert\"" },
	          function() {
	                                      if (options.startRule === 'Content_Disposition') {
	                                        options.data.type = text().toLowerCase();
	                                      }
	                                    },
	          "handling",
	          { type: "literal", value: "handling", description: "\"handling\"" },
	          "optional",
	          { type: "literal", value: "optional", description: "\"optional\"" },
	          "required",
	          { type: "literal", value: "required", description: "\"required\"" },
	          function(length) {
	                                  options.data = parseInt(length.join('')); },
	          function() {
	                                  options.data = text(); },
	          "text",
	          { type: "literal", value: "text", description: "\"text\"" },
	          "image",
	          { type: "literal", value: "image", description: "\"image\"" },
	          "audio",
	          { type: "literal", value: "audio", description: "\"audio\"" },
	          "video",
	          { type: "literal", value: "video", description: "\"video\"" },
	          "application",
	          { type: "literal", value: "application", description: "\"application\"" },
	          "message",
	          { type: "literal", value: "message", description: "\"message\"" },
	          "multipart",
	          { type: "literal", value: "multipart", description: "\"multipart\"" },
	          "x-",
	          { type: "literal", value: "x-", description: "\"x-\"" },
	          function(cseq_value) {
	                            options.data.value=parseInt(cseq_value.join('')); },
	          function(expires) {options.data = expires; },
	          function(event_type) {
	                                 options.data.event = event_type.toLowerCase(); },
	          function() {
	                          var tag = options.data.tag;
	                            options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                            if (tag) {options.data.setParam('tag',tag)}
	                          },
	          "tag",
	          { type: "literal", value: "tag", description: "\"tag\"" },
	          function(tag) {options.data.tag = tag; },
	          function(forwards) {
	                            options.data = parseInt(forwards.join('')); },
	          function(min_expires) {options.data = min_expires; },
	          function() {
	                                  options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                                },
	          "digest",
	          { type: "literal", value: "Digest", description: "\"Digest\"" },
	          "realm",
	          { type: "literal", value: "realm", description: "\"realm\"" },
	          function(realm) { options.data.realm = realm; },
	          "domain",
	          { type: "literal", value: "domain", description: "\"domain\"" },
	          "nonce",
	          { type: "literal", value: "nonce", description: "\"nonce\"" },
	          function(nonce) { options.data.nonce=nonce; },
	          "opaque",
	          { type: "literal", value: "opaque", description: "\"opaque\"" },
	          function(opaque) { options.data.opaque=opaque; },
	          "stale",
	          { type: "literal", value: "stale", description: "\"stale\"" },
	          "true",
	          { type: "literal", value: "true", description: "\"true\"" },
	          function() { options.data.stale=true; },
	          "false",
	          { type: "literal", value: "false", description: "\"false\"" },
	          function() { options.data.stale=false; },
	          "algorithm",
	          { type: "literal", value: "algorithm", description: "\"algorithm\"" },
	          "md5",
	          { type: "literal", value: "MD5", description: "\"MD5\"" },
	          "md5-sess",
	          { type: "literal", value: "MD5-sess", description: "\"MD5-sess\"" },
	          function(algorithm) {
	                                options.data.algorithm=algorithm.toUpperCase(); },
	          "qop",
	          { type: "literal", value: "qop", description: "\"qop\"" },
	          "auth-int",
	          { type: "literal", value: "auth-int", description: "\"auth-int\"" },
	          "auth",
	          { type: "literal", value: "auth", description: "\"auth\"" },
	          function(qop_value) {
	                                  options.data.qop || (options.data.qop=[]);
	                                  options.data.qop.push(qop_value.toLowerCase()); },
	          function(rack_value) {
	                            options.data.value=parseInt(rack_value.join('')); },
	          function() {
	                            var idx, length;
	                            length = options.data.multi_header.length;
	                            for (idx = 0; idx < length; idx++) {
	                              if (options.data.multi_header[idx].parsed === null) {
	                                options.data = null;
	                                break;
	                              }
	                            }
	                            if (options.data !== null) {
	                              options.data = options.data.multi_header;
	                            } else {
	                              options.data = -1;
	                            }},
	          function() {
	                            var header;
	                            if(!options.data.multi_header) options.data.multi_header = [];
	                            try {
	                              header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                              delete options.data.uri;
	                              delete options.data.displayName;
	                              delete options.data.params;
	                            } catch(e) {
	                              header = null;
	                            }
	                            options.data.multi_header.push( { 'position': peg$currPos,
	                                                      'offset': offset(),
	                                                      'parsed': header
	                                                    });},
	          function() {
	                        options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                      },
	          function() {
	                                if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
	                                  options.data = -1;
	                                }
	                              },
	          function() {
	                                options.data = {
	                                  call_id: options.data
	                                };
	                              },
	          "from-tag",
	          { type: "literal", value: "from-tag", description: "\"from-tag\"" },
	          function(from_tag) {
	                                options.data.replaces_from_tag = from_tag;
	                              },
	          "to-tag",
	          { type: "literal", value: "to-tag", description: "\"to-tag\"" },
	          function(to_tag) {
	                                options.data.replaces_to_tag = to_tag;
	                              },
	          "early-only",
	          { type: "literal", value: "early-only", description: "\"early-only\"" },
	          function() {
	                                options.data.early_only = true;
	                              },
	          function(r) {return r;},
	          function(first, rest) { return list(first, rest); },
	          function(value) {
	                          if (options.startRule === 'Require') {
	                            options.data = value || [];
	                          }
	                        },
	          function(rseq_value) {
	                            options.data.value=parseInt(rseq_value.join('')); },
	          "active",
	          { type: "literal", value: "active", description: "\"active\"" },
	          "pending",
	          { type: "literal", value: "pending", description: "\"pending\"" },
	          "terminated",
	          { type: "literal", value: "terminated", description: "\"terminated\"" },
	          function() {
	                                  options.data.state = text(); },
	          "reason",
	          { type: "literal", value: "reason", description: "\"reason\"" },
	          function(reason) {
	                                  if (typeof reason !== 'undefined') options.data.reason = reason; },
	          function(expires) {
	                                  if (typeof expires !== 'undefined') options.data.expires = expires; },
	          "retry_after",
	          { type: "literal", value: "retry_after", description: "\"retry_after\"" },
	          function(retry_after) {
	                                  if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after; },
	          "deactivated",
	          { type: "literal", value: "deactivated", description: "\"deactivated\"" },
	          "probation",
	          { type: "literal", value: "probation", description: "\"probation\"" },
	          "rejected",
	          { type: "literal", value: "rejected", description: "\"rejected\"" },
	          "timeout",
	          { type: "literal", value: "timeout", description: "\"timeout\"" },
	          "giveup",
	          { type: "literal", value: "giveup", description: "\"giveup\"" },
	          "noresource",
	          { type: "literal", value: "noresource", description: "\"noresource\"" },
	          "invariant",
	          { type: "literal", value: "invariant", description: "\"invariant\"" },
	          function(value) {
	                          if (options.startRule === 'Supported') {
	                            options.data = value || [];
	                          }
	                        },
	          function() {
	                        var tag = options.data.tag;
	                          options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                          if (tag) {options.data.setParam('tag',tag)}
	                        },
	          "ttl",
	          { type: "literal", value: "ttl", description: "\"ttl\"" },
	          function(via_ttl_value) {
	                                options.data.ttl = via_ttl_value; },
	          "maddr",
	          { type: "literal", value: "maddr", description: "\"maddr\"" },
	          function(via_maddr) {
	                                options.data.maddr = via_maddr; },
	          "received",
	          { type: "literal", value: "received", description: "\"received\"" },
	          function(via_received) {
	                                options.data.received = via_received; },
	          "branch",
	          { type: "literal", value: "branch", description: "\"branch\"" },
	          function(via_branch) {
	                                options.data.branch = via_branch; },
	          "rport",
	          { type: "literal", value: "rport", description: "\"rport\"" },
	          function() {
	                                if(typeof response_port !== 'undefined')
	                                  options.data.rport = response_port.join(''); },
	          function(via_protocol) {
	                                options.data.protocol = via_protocol; },
	          { type: "literal", value: "UDP", description: "\"UDP\"" },
	          { type: "literal", value: "TCP", description: "\"TCP\"" },
	          { type: "literal", value: "TLS", description: "\"TLS\"" },
	          { type: "literal", value: "SCTP", description: "\"SCTP\"" },
	          function(via_transport) {
	                                options.data.transport = via_transport; },
	          function() {
	                                options.data.host = text(); },
	          function(via_sent_by_port) {
	                                options.data.port = parseInt(via_sent_by_port.join('')); },
	          function(ttl) {
	                                return parseInt(ttl.join('')); },
	          function(deltaSeconds) {
	                                if (options.startRule === 'Session_Expires') {
	                                  options.data.deltaSeconds = deltaSeconds;
	                                }
	                              },
	          "refresher",
	          { type: "literal", value: "refresher", description: "\"refresher\"" },
	          "uas",
	          { type: "literal", value: "uas", description: "\"uas\"" },
	          "uac",
	          { type: "literal", value: "uac", description: "\"uac\"" },
	          function(endpoint) {
	                                if (options.startRule === 'Session_Expires') {
	                                  options.data.refresher = endpoint;
	                                }
	                              },
	          function(deltaSeconds) {
	                                if (options.startRule === 'Min_SE') {
	                                  options.data = deltaSeconds;
	                                }
	                              },
	          "stuns",
	          { type: "literal", value: "stuns", description: "\"stuns\"" },
	          "stun",
	          { type: "literal", value: "stun", description: "\"stun\"" },
	          function(scheme) {
	                                options.data.scheme = scheme; },
	          function(host) {
	                                options.data.host = host; },
	          "?transport=",
	          { type: "literal", value: "?transport=", description: "\"?transport=\"" },
	          "turns",
	          { type: "literal", value: "turns", description: "\"turns\"" },
	          "turn",
	          { type: "literal", value: "turn", description: "\"turn\"" },
	          function() {
	                                options.data.transport = transport; },
	          function() {
	                            options.data = text(); }
	        ],
	
	        peg$bytecode = [
	          peg$decode(". \"\"2 3!"),
	          peg$decode("0\"\"\"1!3#"),
	          peg$decode("0$\"\"1!3%"),
	          peg$decode("0&\"\"1!3'"),
	          peg$decode("7'*# \"7("),
	          peg$decode("0(\"\"1!3)"),
	          peg$decode("0*\"\"1!3+"),
	          peg$decode(".,\"\"2,3-"),
	          peg$decode("..\"\"2.3/"),
	          peg$decode("00\"\"1!31"),
	          peg$decode(".2\"\"2233*\x89 \".4\"\"2435*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("7)*# \"7,"),
	          peg$decode(".F\"\"2F3G*} \".H\"\"2H3I*q \".J\"\"2J3K*e \".L\"\"2L3M*Y \".N\"\"2N3O*M \".P\"\"2P3Q*A \".R\"\"2R3S*5 \".T\"\"2T3U*) \".V\"\"2V3W"),
	          peg$decode("!!.Y\"\"2Y3Z+7$7#+-%7#+#%'#%$## X$\"# X\"# X+! (%"),
	          peg$decode("!! \\7$,#&7$\"+-$7 +#%'\"%$\"# X\"# X*# \" [+@$ \\7$+&$,#&7$\"\"\" X+'%4\"6]\" %$\"# X\"# X"),
	          peg$decode("7.*# \" ["),
	          peg$decode("! \\7'*# \"7(,)&7'*# \"7(\"+A$.8\"\"2839+1%7/+'%4#6^# %$## X$\"# X\"# X"),
	          peg$decode("!! \\72+&$,#&72\"\"\" X+o$ \\! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X,@&! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
	          peg$decode("0_\"\"1!3`*# \"73"),
	          peg$decode("0a\"\"1!3b"),
	          peg$decode("0c\"\"1!3d"),
	          peg$decode("7!*) \"0e\"\"1!3f"),
	          peg$decode("! \\7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x9E$,\x9B&7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
	          peg$decode("! \\7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x92$,\x8F&7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
	          peg$decode(".T\"\"2T3U*\xE3 \".V\"\"2V3W*\xD7 \".i\"\"2i3j*\xCB \".k\"\"2k3l*\xBF \".:\"\"2:3;*\xB3 \".D\"\"2D3E*\xA7 \".2\"\"2233*\x9B \".8\"\"2839*\x8F \".m\"\"2m3n*\x83 \"7&*} \".4\"\"2435*q \".o\"\"2o3p*e \".q\"\"2q3r*Y \".6\"\"2637*M \".>\"\"2>3?*A \".s\"\"2s3t*5 \".u\"\"2u3v*) \"7'*# \"7("),
	          peg$decode("! \\7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v+\u0134$,\u0131&7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v\"\"\" X+! (%"),
	          peg$decode("!7/+A$.P\"\"2P3Q+1%7/+'%4#6w# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.4\"\"2435+1%7/+'%4#6x# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.>\"\"2>3?+1%7/+'%4#6y# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.T\"\"2T3U+1%7/+'%4#6z# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.V\"\"2V3W+1%7/+'%4#6{# %$## X$\"# X\"# X"),
	          peg$decode("!.k\"\"2k3l+1$7/+'%4\"6|\" %$\"# X\"# X"),
	          peg$decode("!7/+7$.i\"\"2i3j+'%4\"6}\" %$\"# X\"# X"),
	          peg$decode("!7/+A$.D\"\"2D3E+1%7/+'%4#6~# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.2\"\"2233+1%7/+'%4#6# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.8\"\"2839+1%7/+'%4#6\x80# %$## X$\"# X\"# X"),
	          peg$decode("!7/+1$7&+'%4\"6\x81\" %$\"# X\"# X"),
	          peg$decode("!7&+1$7/+'%4\"6\x81\" %$\"# X\"# X"),
	          peg$decode("!7=+W$ \\7G*) \"7K*# \"7F,/&7G*) \"7K*# \"7F\"+-%7>+#%'#%$## X$\"# X\"# X"),
	          peg$decode("0\x82\"\"1!3\x83*A \"0\x84\"\"1!3\x85*5 \"0\x86\"\"1!3\x87*) \"73*# \"7."),
	          peg$decode("!!7/+U$7&+K% \\7J*# \"7K,)&7J*# \"7K\"+-%7&+#%'$%$$# X$## X$\"# X\"# X+! (%"),
	          peg$decode("!7/+`$7&+V%! \\7J*# \"7K,)&7J*# \"7K\"+! (%+2%7&+(%4$6\x88$!!%$$# X$## X$\"# X\"# X"),
	          peg$decode("7.*G \".L\"\"2L3M*; \"0\x89\"\"1!3\x8A*/ \"0\x86\"\"1!3\x87*# \"73"),
	          peg$decode("!.m\"\"2m3n+K$0\x8B\"\"1!3\x8C*5 \"0\x8D\"\"1!3\x8E*) \"0\x8F\"\"1!3\x90+#%'\"%$\"# X\"# X"),
	          peg$decode("!7N+Q$.8\"\"2839+A%7O*# \" [+1%7S+'%4$6\x91$ %$$# X$## X$\"# X\"# X"),
	          peg$decode("!7N+k$.8\"\"2839+[%7O*# \" [+K%7S+A%7_+7%7l*# \" [+'%4&6\x92& %$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\x93\"\"1$3\x94*) \"/\x95\"\"1#3\x96+' 4!6\x97!! %"),
	          peg$decode("!7P+b$!.8\"\"2839+-$7R+#%'\"%$\"# X\"# X*# \" [+7%.:\"\"2:3;+'%4#6\x98# %$## X$\"# X\"# X"),
	          peg$decode(" \\7+*) \"7-*# \"7Q+2$,/&7+*) \"7-*# \"7Q\"\"\" X"),
	          peg$decode(".<\"\"2<3=*q \".>\"\"2>3?*e \".@\"\"2@3A*Y \".B\"\"2B3C*M \".D\"\"2D3E*A \".2\"\"2233*5 \".6\"\"2637*) \".4\"\"2435"),
	          peg$decode("! \\7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E,e&7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E\"+& 4!6\x99! %"),
	          peg$decode("!7T+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\x9A! %"),
	          peg$decode("! \\!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X,>&!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X\"+G$7W+=%.J\"\"2J3K*# \" [+'%4#6\x9B# %$## X$\"# X\"# X"),
	          peg$decode(" \\0\x9C\"\"1!3\x9D+,$,)&0\x9C\"\"1!3\x9D\"\"\" X"),
	          peg$decode("!0$\"\"1!3%+A$ \\0\x9E\"\"1!3\x9F,)&0\x9E\"\"1!3\x9F\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!.o\"\"2o3p+A$7Y+7%.q\"\"2q3r+'%4#6\xA0# %$## X$\"# X\"# X"),
	          peg$decode("!!7Z+\xBF$.8\"\"2839+\xAF%7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0838 \"!.\xA1\"\"2\xA13\xA2+\xAF$7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0795 \"!.\xA1\"\"2\xA13\xA2+\x95$7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u070C \"!.\xA1\"\"2\xA13\xA2+{$7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u069D \"!.\xA1\"\"2\xA13\xA2+a$7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X*\u0648 \"!.\xA1\"\"2\xA13\xA2+G$7Z+=%.8\"\"2839+-%7[+#%'$%$$# X$## X$\"# X\"# X*\u060D \"!.\xA1\"\"2\xA13\xA2+-$7[+#%'\"%$\"# X\"# X*\u05EC \"!.\xA1\"\"2\xA13\xA2+-$7Z+#%'\"%$\"# X\"# X*\u05CB \"!7Z+\xA5$.\xA1\"\"2\xA13\xA2+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0538 \"!7Z+\xB6$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x8B%.\xA1\"\"2\xA13\xA2+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0494 \"!7Z+\xC7$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x9C%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+q%.\xA1\"\"2\xA13\xA2+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u03DF \"!7Z+\xD8$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xAD%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x82%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+W%.\xA1\"\"2\xA13\xA2+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0319 \"!7Z+\xE9$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0242 \"!7Z+\u0114$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xE9%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0140 \"!7Z+\u0135$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\u010A%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xDF%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xB4%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x89%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+^%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+3%.\xA1\"\"2\xA13\xA2+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X+& 4!6\xA3! %"),
	          peg$decode("!7#+S$7#*# \" [+C%7#*# \" [+3%7#*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!7Z+=$.8\"\"2839+-%7Z+#%'#%$## X$\"# X\"# X*# \"7\\"),
	          peg$decode("!7]+u$.J\"\"2J3K+e%7]+[%.J\"\"2J3K+K%7]+A%.J\"\"2J3K+1%7]+'%4'6\xA4' %$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!.\xA5\"\"2\xA53\xA6+3$0\xA7\"\"1!3\xA8+#%'\"%$\"# X\"# X*\xA0 \"!.\xA9\"\"2\xA93\xAA+=$0\xAB\"\"1!3\xAC+-%7!+#%'#%$## X$\"# X\"# X*o \"!.\xAD\"\"2\xAD3\xAE+7$7!+-%7!+#%'#%$## X$\"# X\"# X*D \"!0\xAF\"\"1!3\xB0+-$7!+#%'\"%$\"# X\"# X*# \"7!"),
	          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\xB1!! %"),
	          peg$decode(" \\!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X\""),
	          peg$decode("7a*A \"7b*; \"7c*5 \"7d*/ \"7e*) \"7f*# \"7g"),
	          peg$decode("!/\xB2\"\"1*3\xB3+b$/\xB4\"\"1#3\xB5*G \"/\xB6\"\"1#3\xB7*; \"/\xB8\"\"1$3\xB9*/ \"/\xBA\"\"1#3\xBB*# \"76+(%4\"6\xBC\"! %$\"# X\"# X"),
	          peg$decode("!/\xBD\"\"1%3\xBE+J$/\xBF\"\"1%3\xC0*/ \"/\xC1\"\"1\"3\xC2*# \"76+(%4\"6\xC3\"! %$\"# X\"# X"),
	          peg$decode("!/\xC4\"\"1'3\xC5+2$7\x8F+(%4\"6\xC6\"! %$\"# X\"# X"),
	          peg$decode("!/\xC7\"\"1$3\xC8+2$7\xEF+(%4\"6\xC9\"! %$\"# X\"# X"),
	          peg$decode("!/\xCA\"\"1&3\xCB+2$7T+(%4\"6\xCC\"! %$\"# X\"# X"),
	          peg$decode("!/\xCD\"\"1\"3\xCE+R$!.>\"\"2>3?+-$76+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xCF\" %$\"# X\"# X"),
	          peg$decode("!7h+T$!.>\"\"2>3?+-$7i+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xD0\"\"! %$\"# X\"# X"),
	          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
	          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
	          peg$decode("7k*) \"7+*# \"7-"),
	          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".8\"\"2839*A \".<\"\"2<3=*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
	          peg$decode("!.6\"\"2637+u$7m+k% \\!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X,>&!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X\"+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7n+C$.>\"\"2>3?+3%7o+)%4#6\xD1#\"\" %$## X$\"# X\"# X"),
	          peg$decode(" \\7p*) \"7+*# \"7-+2$,/&7p*) \"7+*# \"7-\"\"\" X"),
	          peg$decode(" \\7p*) \"7+*# \"7-,/&7p*) \"7+*# \"7-\""),
	          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".6\"\"2637*A \".8\"\"2839*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
	          peg$decode("7\x90*# \"7r"),
	          peg$decode("!7\x8F+K$7'+A%7s+7%7'+-%7\x84+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7M*# \"7t"),
	          peg$decode("!7+G$.8\"\"2839+7%7u*# \"7x+'%4#6\xD2# %$## X$\"# X\"# X"),
	          peg$decode("!7v*# \"7w+N$!.6\"\"2637+-$7\x83+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!.\xD3\"\"2\xD33\xD4+=$7\x80+3%7w*# \" [+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!.4\"\"2435+-$7{+#%'\"%$\"# X\"# X"),
	          peg$decode("!7z+5$ \\7y,#&7y\"+#%'\"%$\"# X\"# X"),
	          peg$decode("7**) \"7+*# \"7-"),
	          peg$decode("7+*\x8F \"7-*\x89 \".2\"\"2233*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("!7|+k$ \\!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X,>&!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7~,#&7~\"+k$ \\!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode(" \\7~,#&7~\""),
	          peg$decode("7+*w \"7-*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("!7\"+\x8D$ \\7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K,M&7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K\"+'%4\"6\xD5\" %$\"# X\"# X"),
	          peg$decode("7\x81*# \"7\x82"),
	          peg$decode("!!7O+3$.:\"\"2:3;+#%'\"%$\"# X\"# X*# \" [+-$7S+#%'\"%$\"# X\"# X*# \" ["),
	          peg$decode(" \\7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A+\x8C$,\x89&7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A\"\"\" X"),
	          peg$decode(" \\7y,#&7y\""),
	          peg$decode("!/\x95\"\"1#3\xD6+y$.4\"\"2435+i% \\7!+&$,#&7!\"\"\" X+P%.J\"\"2J3K+@% \\7!+&$,#&7!\"\"\" X+'%4%6\xD7% %$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode(".\xD8\"\"2\xD83\xD9"),
	          peg$decode(".\xDA\"\"2\xDA3\xDB"),
	          peg$decode(".\xDC\"\"2\xDC3\xDD"),
	          peg$decode(".\xDE\"\"2\xDE3\xDF"),
	          peg$decode(".\xE0\"\"2\xE03\xE1"),
	          peg$decode(".\xE2\"\"2\xE23\xE3"),
	          peg$decode(".\xE4\"\"2\xE43\xE5"),
	          peg$decode(".\xE6\"\"2\xE63\xE7"),
	          peg$decode(".\xE8\"\"2\xE83\xE9"),
	          peg$decode(".\xEA\"\"2\xEA3\xEB"),
	          peg$decode("!7\x85*S \"7\x86*M \"7\x88*G \"7\x89*A \"7\x8A*; \"7\x8B*5 \"7\x8C*/ \"7\x8D*) \"7\x8E*# \"76+& 4!6\xEC! %"),
	          peg$decode("!7\x84+K$7'+A%7\x91+7%7'+-%7\x93+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!7\x92+' 4!6\xED!! %"),
	          peg$decode("!7!+7$7!+-%7!+#%'#%$## X$\"# X\"# X"),
	          peg$decode("! \\7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(,G&7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(\"+& 4!6\xEE! %"),
	          peg$decode("!7\xB5+_$ \\!7A+-$7\xB5+#%'\"%$\"# X\"# X,8&!7A+-$7\xB5+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!79+R$!.:\"\"2:3;+-$79+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xEF\" %$\"# X\"# X"),
	          peg$decode("!7:*j \"!7\x97+_$ \\!7A+-$7\x97+#%'\"%$\"# X\"# X,8&!7A+-$7\x97+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+& 4!6\xF0! %"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\x9A+#%'\"%$\"# X\"# X,8&!7B+-$7\x9A+#%'\"%$\"# X\"# X\"+'%4\"6\xF1\" %$\"# X\"# X"),
	          peg$decode("!7\x99*# \" [+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!!76+_$ \\!7.+-$76+#%'\"%$\"# X\"# X,8&!7.+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X*# \"7H+' 4!6\xF2!! %"),
	          peg$decode("7\x9B*) \"7\x9C*# \"7\x9F"),
	          peg$decode("!/\xF3\"\"1!3\xF4+<$7<+2%7\x9E+(%4#6\xF5#! %$## X$\"# X\"# X"),
	          peg$decode("!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\xF8#! %$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\xF9!! %"),
	          peg$decode("!.\xFA\"\"2\xFA3\xFB+x$!.J\"\"2J3K+S$7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'$%$$# X$## X$\"# X\"# X*# \" [+'%4\"6\xFC\" %$\"# X\"# X"),
	          peg$decode("!76+N$!7<+-$7\xA0+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xFD\"\"! %$\"# X\"# X"),
	          peg$decode("76*) \"7T*# \"7H"),
	          peg$decode("!7\xA2+_$ \\!7B+-$7\xA3+#%'\"%$\"# X\"# X,8&!7B+-$7\xA3+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!/\xFE\"\"1&3\xFF*G \"/\u0100\"\"1'3\u0101*; \"/\u0102\"\"1$3\u0103*/ \"/\u0104\"\"1%3\u0105*# \"76+& 4!6\u0106! %"),
	          peg$decode("7\xA4*# \"7\x9F"),
	          peg$decode("!/\u0107\"\"1(3\u0108+O$7<+E%/\u0109\"\"1(3\u010A*/ \"/\u010B\"\"1(3\u010C*# \"76+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u010D!! %"),
	          peg$decode("!7\xA8+& 4!6\u010E! %"),
	          peg$decode("!7\xA9+s$7;+i%7\xAE+_% \\!7B+-$7\xAF+#%'\"%$\"# X\"# X,8&!7B+-$7\xAF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xAA*# \"7\xAB"),
	          peg$decode("/\u010F\"\"1$3\u0110*S \"/\u0111\"\"1%3\u0112*G \"/\u0113\"\"1%3\u0114*; \"/\u0115\"\"1%3\u0116*/ \"/\u0117\"\"1+3\u0118*# \"7\xAC"),
	          peg$decode("/\u0119\"\"1'3\u011A*/ \"/\u011B\"\"1)3\u011C*# \"7\xAC"),
	          peg$decode("76*# \"7\xAD"),
	          peg$decode("!/\u011D\"\"1\"3\u011E+-$76+#%'\"%$\"# X\"# X"),
	          peg$decode("7\xAC*# \"76"),
	          peg$decode("!76+7$7<+-%7\xB0+#%'#%$## X$\"# X\"# X"),
	          peg$decode("76*# \"7H"),
	          peg$decode("!7\xB2+7$7.+-%7\x8F+#%'#%$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u011F!! %"),
	          peg$decode("!7\x9D+' 4!6\u0120!! %"),
	          peg$decode("!7\xB5+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u0121\"!!%$\"# X\"# X"),
	          peg$decode("!!77+k$ \\!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X,>&!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xB7+#%'\"%$\"# X\"# X,8&!7B+-$7\xB7+#%'\"%$\"# X\"# X\"+'%4\"6\u0122\" %$\"# X\"# X"),
	          peg$decode("7\xB8*# \"7\x9F"),
	          peg$decode("!/\u0123\"\"1#3\u0124+<$7<+2%76+(%4#6\u0125#! %$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u0126!! %"),
	          peg$decode("!7\x9D+' 4!6\u0127!! %"),
	          peg$decode("! \\7\x99,#&7\x99\"+\x81$7@+w%7M+m%7?+c% \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4%6\u0128% %$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xBD"),
	          peg$decode("!/\u0129\"\"1&3\u012A+s$7.+i%7\xC0+_% \\!7A+-$7\xC0+#%'\"%$\"# X\"# X,8&!7A+-$7\xC0+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X*# \"7\xBE"),
	          peg$decode("!76+s$7.+i%7\xBF+_% \\!7A+-$7\xBF+#%'\"%$\"# X\"# X,8&!7A+-$7\xBF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!76+=$7<+3%76*# \"7H+#%'#%$## X$\"# X\"# X"),
	          peg$decode("7\xC1*G \"7\xC3*A \"7\xC5*; \"7\xC7*5 \"7\xC8*/ \"7\xC9*) \"7\xCA*# \"7\xBF"),
	          peg$decode("!/\u012B\"\"1%3\u012C+7$7<+-%7\xC2+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7I+' 4!6\u012D!! %"),
	          peg$decode("!/\u012E\"\"1&3\u012F+\xA5$7<+\x9B%7D+\x91%7\xC4+\x87% \\! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X,G&! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7t*# \"7w"),
	          peg$decode("!/\u0130\"\"1%3\u0131+7$7<+-%7\xC6+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7I+' 4!6\u0132!! %"),
	          peg$decode("!/\u0133\"\"1&3\u0134+<$7<+2%7I+(%4#6\u0135#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0136\"\"1%3\u0137+_$7<+U%!/\u0138\"\"1$3\u0139+& 4!6\u013A! %*4 \"!/\u013B\"\"1%3\u013C+& 4!6\u013D! %+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!/\u013E\"\"1)3\u013F+T$7<+J%/\u0140\"\"1#3\u0141*/ \"/\u0142\"\"1(3\u0143*# \"76+(%4#6\u0144#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0145\"\"1#3\u0146+\x9E$7<+\x94%7D+\x8A%!7\xCB+k$ \\!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X,>&!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+-%7E+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\u0147\"\"1(3\u0148*/ \"/\u0149\"\"1$3\u014A*# \"76+' 4!6\u014B!! %"),
	          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\xCE+K$7.+A%7\xCE+7%7.+-%7\x8F+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u014C!! %"),
	          peg$decode("!7\xD0+c$ \\!7A+-$7\xD0+#%'\"%$\"# X\"# X,8&!7A+-$7\xD0+#%'\"%$\"# X\"# X\"+'%4\"6\u014D\" %$\"# X\"# X"),
	          peg$decode("!7\x98+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014E\" %$\"# X\"# X"),
	          peg$decode("!7L*T \"7\x98*N \"!7@*# \" [+=$7t+3%7?*# \" [+#%'#%$## X$\"# X\"# X+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014F\" %$\"# X\"# X"),
	          peg$decode("!7\xD3+c$ \\!7B+-$7\xD4+#%'\"%$\"# X\"# X,8&!7B+-$7\xD4+#%'\"%$\"# X\"# X\"+'%4\"6\u0150\" %$\"# X\"# X"),
	          peg$decode("!7\x95+& 4!6\u0151! %"),
	          peg$decode("!/\u0152\"\"1(3\u0153+<$7<+2%76+(%4#6\u0154#! %$## X$\"# X\"# X*j \"!/\u0155\"\"1&3\u0156+<$7<+2%76+(%4#6\u0157#! %$## X$\"# X\"# X*: \"!/\u0158\"\"1*3\u0159+& 4!6\u015A! %*# \"7\x9F"),
	          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u015D!! %"),
	          peg$decode("!7\xD7+_$ \\!7A+-$7\xD7+#%'\"%$\"# X\"# X,8&!7A+-$7\xD7+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\x98+_$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u015E!! %"),
	          peg$decode("!7\xDA+_$ \\!7B+-$7\xDB+#%'\"%$\"# X\"# X,8&!7B+-$7\xDB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!/\u015F\"\"1&3\u0160*; \"/\u0161\"\"1'3\u0162*/ \"/\u0163\"\"1*3\u0164*# \"76+& 4!6\u0165! %"),
	          peg$decode("!/\u0166\"\"1&3\u0167+<$7<+2%7\xDC+(%4#6\u0168#! %$## X$\"# X\"# X*\x83 \"!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\u0169#! %$## X$\"# X\"# X*S \"!/\u016A\"\"1+3\u016B+<$7<+2%7\x9D+(%4#6\u016C#! %$## X$\"# X\"# X*# \"7\x9F"),
	          peg$decode("/\u016D\"\"1+3\u016E*k \"/\u016F\"\"1)3\u0170*_ \"/\u0171\"\"1(3\u0172*S \"/\u0173\"\"1'3\u0174*G \"/\u0175\"\"1&3\u0176*; \"/\u0177\"\"1*3\u0178*/ \"/\u0179\"\"1)3\u017A*# \"76"),
	          peg$decode("71*# \" ["),
	          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u017B!! %"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xE0+#%'\"%$\"# X\"# X,8&!7B+-$7\xE0+#%'\"%$\"# X\"# X\"+'%4\"6\u017C\" %$\"# X\"# X"),
	          peg$decode("7\xB8*# \"7\x9F"),
	          peg$decode("!7\xE2+_$ \\!7A+-$7\xE2+#%'\"%$\"# X\"# X,8&!7A+-$7\xE2+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\xE9+s$7.+i%7\xEC+_% \\!7B+-$7\xE3+#%'\"%$\"# X\"# X,8&!7B+-$7\xE3+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xE4*; \"7\xE5*5 \"7\xE6*/ \"7\xE7*) \"7\xE8*# \"7\x9F"),
	          peg$decode("!/\u017D\"\"1#3\u017E+<$7<+2%7\xEF+(%4#6\u017F#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0180\"\"1%3\u0181+<$7<+2%7T+(%4#6\u0182#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0183\"\"1(3\u0184+B$7<+8%7\\*# \"7Y+(%4#6\u0185#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0186\"\"1&3\u0187+<$7<+2%76+(%4#6\u0188#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0189\"\"1%3\u018A+T$!7<+5$ \\7!,#&7!\"+#%'\"%$\"# X\"# X*# \" [+'%4\"6\u018B\" %$\"# X\"# X"),
	          peg$decode("!7\xEA+K$7;+A%76+7%7;+-%7\xEB+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\x95\"\"1#3\xD6*# \"76+' 4!6\u018C!! %"),
	          peg$decode("!/\xB4\"\"1#3\u018D*G \"/\xB6\"\"1#3\u018E*; \"/\xBA\"\"1#3\u018F*/ \"/\xB8\"\"1$3\u0190*# \"76+' 4!6\u0191!! %"),
	          peg$decode("!7\xED+H$!7C+-$7\xEE+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\u0192! %"),
	          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\u0193!! %"),
	          peg$decode("!!7!+C$7!*# \" [+3%7!*# \" [+#%'#%$## X$\"# X\"# X+' 4!6\u0194!! %"),
	          peg$decode("7\xBD"),
	          peg$decode("!7\x9D+d$ \\!7B+-$7\xF2+#%'\"%$\"# X\"# X,8&!7B+-$7\xF2+#%'\"%$\"# X\"# X\"+(%4\"6\u0195\"!!%$\"# X\"# X"),
	          peg$decode("7\xF3*# \"7\x9F"),
	          peg$decode("!.\u0196\"\"2\u01963\u0197+N$7<+D%.\u0198\"\"2\u01983\u0199*) \".\u019A\"\"2\u019A3\u019B+(%4#6\u019C#! %$## X$\"# X\"# X"),
	          peg$decode("!7\x9D+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u019D\"!!%$\"# X\"# X"),
	          peg$decode("!76+7$70+-%7\xF6+#%'#%$## X$\"# X\"# X"),
	          peg$decode(" \\72*) \"74*# \"7.,/&72*) \"74*# \"7.\""),
	          peg$decode(" \\7%,#&7%\""),
	          peg$decode("!7\xF9+=$.8\"\"2839+-%7\xFA+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!/\u019E\"\"1%3\u019F*) \"/\u01A0\"\"1$3\u01A1+' 4!6\u01A2!! %"),
	          peg$decode("!7\xFB+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\\*) \"7X*# \"7\x82+' 4!6\u01A3!! %"),
	          peg$decode("! \\7\xFD*) \"7-*# \"7\xFE,/&7\xFD*) \"7-*# \"7\xFE\"+! (%"),
	          peg$decode("7\"*S \"7!*M \".F\"\"2F3G*A \".J\"\"2J3K*5 \".H\"\"2H3I*) \".N\"\"2N3O"),
	          peg$decode(".L\"\"2L3M*\x95 \".B\"\"2B3C*\x89 \".<\"\"2<3=*} \".R\"\"2R3S*q \".T\"\"2T3U*e \".V\"\"2V3W*Y \".P\"\"2P3Q*M \".@\"\"2@3A*A \".D\"\"2D3E*5 \".2\"\"2233*) \".>\"\"2>3?"),
	          peg$decode("!7\u0100+h$.8\"\"2839+X%7\xFA+N%!.\u01A4\"\"2\u01A43\u01A5+-$7\xEB+#%'\"%$\"# X\"# X*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\u01A6\"\"1%3\u01A7*) \"/\u01A8\"\"1$3\u01A9+' 4!6\u01A2!! %"),
	          peg$decode("!7\xEB+Q$/\xB4\"\"1#3\xB5*7 \"/\xB6\"\"1#3\xB7*+ \" \\7+,#&7+\"+'%4\"6\u01AA\" %$\"# X\"# X"),
	          peg$decode("!7\u0104+\x8F$.F\"\"2F3G+%7\u0103+u%.F\"\"2F3G+e%7\u0103+[%.F\"\"2F3G+K%7\u0103+A%.F\"\"2F3G+1%7\u0105+'%4)6\u01AB) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!7\u0103+-$7\u0103+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\u0103+7$7\u0103+-%7\u0103+#%'#%$## X$\"# X\"# X")
	        ],
	
	        peg$currPos          = 0,
	        peg$reportedPos      = 0,
	        peg$cachedPos        = 0,
	        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,
	
	        peg$result;
	
	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleIndices)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }
	
	      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
	    }
	
	    function text() {
	      return input.substring(peg$reportedPos, peg$currPos);
	    }
	
	    function offset() {
	      return peg$reportedPos;
	    }
	
	    function line() {
	      return peg$computePosDetails(peg$reportedPos).line;
	    }
	
	    function column() {
	      return peg$computePosDetails(peg$reportedPos).column;
	    }
	
	    function expected(description) {
	      throw peg$buildException(
	        null,
	        [{ type: "other", description: description }],
	        peg$reportedPos
	      );
	    }
	
	    function error(message) {
	      throw peg$buildException(message, null, peg$reportedPos);
	    }
	
	    function peg$computePosDetails(pos) {
	      function advance(details, startPos, endPos) {
	        var p, ch;
	
	        for (p = startPos; p < endPos; p++) {
	          ch = input.charAt(p);
	          if (ch === "\n") {
	            if (!details.seenCR) { details.line++; }
	            details.column = 1;
	            details.seenCR = false;
	          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	            details.line++;
	            details.column = 1;
	            details.seenCR = true;
	          } else {
	            details.column++;
	            details.seenCR = false;
	          }
	        }
	      }
	
	      if (peg$cachedPos !== pos) {
	        if (peg$cachedPos > pos) {
	          peg$cachedPos = 0;
	          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
	        }
	        advance(peg$cachedPosDetails, peg$cachedPos, pos);
	        peg$cachedPos = pos;
	      }
	
	      return peg$cachedPosDetails;
	    }
	
	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }
	
	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }
	
	      peg$maxFailExpected.push(expected);
	    }
	
	    function peg$buildException(message, expected, pos) {
	      function cleanupExpected(expected) {
	        var i = 1;
	
	        expected.sort(function(a, b) {
	          if (a.description < b.description) {
	            return -1;
	          } else if (a.description > b.description) {
	            return 1;
	          } else {
	            return 0;
	          }
	        });
	
	        while (i < expected.length) {
	          if (expected[i - 1] === expected[i]) {
	            expected.splice(i, 1);
	          } else {
	            i++;
	          }
	        }
	      }
	
	      function buildMessage(expected, found) {
	        function stringEscape(s) {
	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
	
	          return s
	            .replace(/\\/g,   '\\\\')
	            .replace(/"/g,    '\\"')
	            .replace(/\x08/g, '\\b')
	            .replace(/\t/g,   '\\t')
	            .replace(/\n/g,   '\\n')
	            .replace(/\f/g,   '\\f')
	            .replace(/\r/g,   '\\r')
	            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
	            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
	            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
	            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
	        }
	
	        var expectedDescs = new Array(expected.length),
	            expectedDesc, foundDesc, i;
	
	        for (i = 0; i < expected.length; i++) {
	          expectedDescs[i] = expected[i].description;
	        }
	
	        expectedDesc = expected.length > 1
	          ? expectedDescs.slice(0, -1).join(", ")
	              + " or "
	              + expectedDescs[expected.length - 1]
	          : expectedDescs[0];
	
	        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	
	        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	      }
	
	      var posDetails = peg$computePosDetails(pos),
	          found      = pos < input.length ? input.charAt(pos) : null;
	
	      if (expected !== null) {
	        cleanupExpected(expected);
	      }
	
	      return new SyntaxError(
	        message !== null ? message : buildMessage(expected, found),
	        expected,
	        found,
	        pos,
	        posDetails.line,
	        posDetails.column
	      );
	    }
	
	    function peg$decode(s) {
	      var bc = new Array(s.length), i;
	
	      for (i = 0; i < s.length; i++) {
	        bc[i] = s.charCodeAt(i) - 32;
	      }
	
	      return bc;
	    }
	
	    function peg$parseRule(index) {
	      var bc    = peg$bytecode[index],
	          ip    = 0,
	          ips   = [],
	          end   = bc.length,
	          ends  = [],
	          stack = [],
	          params, i;
	
	      function protect(object) {
	        return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;
	      }
	
	      while (true) {
	        while (ip < end) {
	          switch (bc[ip]) {
	            case 0:
	              stack.push(protect(peg$consts[bc[ip + 1]]));
	              ip += 2;
	              break;
	
	            case 1:
	              stack.push(peg$currPos);
	              ip++;
	              break;
	
	            case 2:
	              stack.pop();
	              ip++;
	              break;
	
	            case 3:
	              peg$currPos = stack.pop();
	              ip++;
	              break;
	
	            case 4:
	              stack.length -= bc[ip + 1];
	              ip += 2;
	              break;
	
	            case 5:
	              stack.splice(-2, 1);
	              ip++;
	              break;
	
	            case 6:
	              stack[stack.length - 2].push(stack.pop());
	              ip++;
	              break;
	
	            case 7:
	              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
	              ip += 2;
	              break;
	
	            case 8:
	              stack.pop();
	              stack.push(input.substring(stack[stack.length - 1], peg$currPos));
	              ip++;
	              break;
	
	            case 9:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1]) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 10:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1] === peg$FAILED) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 11:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1] !== peg$FAILED) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 12:
	              if (stack[stack.length - 1] !== peg$FAILED) {
	                ends.push(end);
	                ips.push(ip);
	
	                end = ip + 2 + bc[ip + 1];
	                ip += 2;
	              } else {
	                ip += 2 + bc[ip + 1];
	              }
	
	              break;
	
	            case 13:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (input.length > peg$currPos) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 14:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 15:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 16:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 17:
	              stack.push(input.substr(peg$currPos, bc[ip + 1]));
	              peg$currPos += bc[ip + 1];
	              ip += 2;
	              break;
	
	            case 18:
	              stack.push(peg$consts[bc[ip + 1]]);
	              peg$currPos += peg$consts[bc[ip + 1]].length;
	              ip += 2;
	              break;
	
	            case 19:
	              stack.push(peg$FAILED);
	              if (peg$silentFails === 0) {
	                peg$fail(peg$consts[bc[ip + 1]]);
	              }
	              ip += 2;
	              break;
	
	            case 20:
	              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];
	              ip += 2;
	              break;
	
	            case 21:
	              peg$reportedPos = peg$currPos;
	              ip++;
	              break;
	
	            case 22:
	              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
	              for (i = 0; i < bc[ip + 3]; i++) {
	                params[i] = stack[stack.length - 1 - params[i]];
	              }
	
	              stack.splice(
	                stack.length - bc[ip + 2],
	                bc[ip + 2],
	                peg$consts[bc[ip + 1]].apply(null, params)
	              );
	
	              ip += 4 + bc[ip + 3];
	              break;
	
	            case 23:
	              stack.push(peg$parseRule(bc[ip + 1]));
	              ip += 2;
	              break;
	
	            case 24:
	              peg$silentFails++;
	              ip++;
	              break;
	
	            case 25:
	              peg$silentFails--;
	              ip++;
	              break;
	
	            default:
	              throw new Error("Invalid opcode: " + bc[ip] + ".");
	          }
	        }
	
	        if (ends.length > 0) {
	          end = ends.pop();
	          ip = ips.pop();
	        } else {
	          break;
	        }
	      }
	
	      return stack[0];
	    }
	
	
	      options.data = {}; // Object to which header attributes will be assigned during parsing
	
	      function list (first, rest) {
	        return [first].concat(rest);
	      }
	
	
	    peg$result = peg$parseRule(peg$startRuleIndex);
	
	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail({ type: "end", description: "end of input" });
	      }
	
	      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
	    }
	  }
	
	  return {
	    SyntaxError: SyntaxError,
	    parse:       parse
	  };
	})();


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var toplevel = global.window || global;
	
	function getPrefixedProperty (object, name) {
	  if (object == null) {
	    return;
	  }
	  var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
	  var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];
	  for (var i in prefixedNames) {
	    var property = object[prefixedNames[i]];
	    if (property) {
	      return property.bind(object);
	    }
	  }
	}
	
	module.exports = {
	  WebSocket: toplevel.WebSocket,
	  Transport: __webpack_require__(246),
	  open: toplevel.open,
	  Promise: toplevel.Promise,
	  timers: toplevel,
	
	  // Console is not defined in ECMAScript, so just in case...
	  console: toplevel.console || {
	    debug: function () {},
	    log: function () {},
	    warn: function () {},
	    error: function () {}
	  },
	
	  MediaStream: getPrefixedProperty(toplevel, 'MediaStream'),
	  getUserMedia: getPrefixedProperty(toplevel.navigator, 'getUserMedia'),
	  RTCPeerConnection: getPrefixedProperty(toplevel, 'RTCPeerConnection'),
	  RTCSessionDescription: getPrefixedProperty(toplevel, 'RTCSessionDescription'),
	
	  addEventListener: getPrefixedProperty(toplevel, 'addEventListener'),
	  HTMLMediaElement: toplevel.HTMLMediaElement,
	
	  attachMediaStream: toplevel.attachMediaStream,
	  createObjectURL: toplevel.URL && toplevel.URL.createObjectURL,
	  revokeObjectURL: toplevel.URL && toplevel.URL.revokeObjectURL
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 246 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Transport
	 */
	
	/**
	 * @augments SIP
	 * @class Transport
	 * @param {SIP.UA} ua
	 * @param {Object} server ws_server Object
	 */
	module.exports = function (SIP, WebSocket) {
	var Transport,
	  C = {
	    // Transport status codes
	    STATUS_READY:        0,
	    STATUS_DISCONNECTED: 1,
	    STATUS_ERROR:        2
	  };
	
	/**
	 * Compute an amount of time in seconds to wait before sending another
	 * keep-alive.
	 * @returns {Number}
	 */
	function computeKeepAliveTimeout(upperBound) {
	  var lowerBound = upperBound * 0.8;
	  return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);
	}
	
	Transport = function(ua, server) {
	
	  this.logger = ua.getLogger('sip.transport');
	  this.ua = ua;
	  this.ws = null;
	  this.server = server;
	  this.reconnection_attempts = 0;
	  this.closed = false;
	  this.connected = false;
	  this.reconnectTimer = null;
	  this.lastTransportError = {};
	
	  this.keepAliveInterval = ua.configuration.keepAliveInterval;
	  this.keepAliveTimeout = null;
	  this.keepAliveTimer = null;
	
	  this.ua.transport = this;
	
	  // Connect
	  this.connect();
	};
	
	Transport.prototype = {
	  /**
	   * Send a message.
	   * @param {SIP.OutgoingRequest|String} msg
	   * @returns {Boolean}
	   */
	  send: function(msg) {
	    var message = msg.toString();
	
	    if(this.ws && this.ws.readyState === WebSocket.OPEN) {
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('sending WebSocket message:\n\n' + message + '\n');
	      }
	      this.ws.send(message);
	      return true;
	    } else {
	      this.logger.warn('unable to send message, WebSocket is not open');
	      return false;
	    }
	  },
	
	  /**
	   * Send a keep-alive (a double-CRLF sequence).
	   * @private
	   * @returns {Boolean}
	   */
	  sendKeepAlive: function() {
	    if(this.keepAliveTimeout) { return; }
	
	    this.keepAliveTimeout = SIP.Timers.setTimeout(function() {
	      this.ua.emit('keepAliveTimeout');
	    }.bind(this), 10000);
	
	    return this.send('\r\n\r\n');
	  },
	
	  /**
	   * Start sending keep-alives.
	   * @private
	   */
	  startSendingKeepAlives: function() {
	    if (this.keepAliveInterval && !this.keepAliveTimer) {
	      this.keepAliveTimer = SIP.Timers.setTimeout(function() {
	        this.sendKeepAlive();
	        this.keepAliveTimer = null;
	        this.startSendingKeepAlives();
	      }.bind(this), computeKeepAliveTimeout(this.keepAliveInterval));
	    }
	  },
	
	  /**
	   * Stop sending keep-alives.
	   * @private
	   */
	  stopSendingKeepAlives: function() {
	    SIP.Timers.clearTimeout(this.keepAliveTimer);
	    SIP.Timers.clearTimeout(this.keepAliveTimeout);
	    this.keepAliveTimer = null;
	    this.keepAliveTimeout = null;
	  },
	
	  /**
	  * Disconnect socket.
	  */
	  disconnect: function() {
	    if(this.ws) {
	      // Clear reconnectTimer
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	
	      this.stopSendingKeepAlives();
	
	      this.closed = true;
	      this.logger.log('closing WebSocket ' + this.server.ws_uri);
	      this.ws.close();
	    }
	
	    if (this.reconnectTimer !== null) {
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	      this.reconnectTimer = null;
	      this.ua.emit('disconnected', {
	        transport: this,
	        code: this.lastTransportError.code,
	        reason: this.lastTransportError.reason
	      });
	    }
	  },
	
	  /**
	  * Connect socket.
	  */
	  connect: function() {
	    var transport = this;
	
	    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
	      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');
	      return false;
	    }
	
	    if(this.ws) {
	      this.ws.close();
	    }
	
	    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);
	    this.ua.onTransportConnecting(this,
	      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);
	
	    try {
	      this.ws = new WebSocket(this.server.ws_uri, 'sip');
	    } catch(e) {
	      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);
	    }
	
	    this.ws.binaryType = 'arraybuffer';
	
	    this.ws.onopen = function() {
	      transport.onOpen();
	    };
	
	    this.ws.onclose = function(e) {
	      transport.onClose(e);
	    };
	
	    this.ws.onmessage = function(e) {
	      transport.onMessage(e);
	    };
	
	    this.ws.onerror = function(e) {
	      transport.onError(e);
	    };
	  },
	
	  // Transport Event Handlers
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onOpen: function() {
	    this.connected = true;
	
	    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');
	    // Clear reconnectTimer since we are not disconnected
	    if (this.reconnectTimer !== null) {
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	      this.reconnectTimer = null;
	    }
	    // Reset reconnection_attempts
	    this.reconnection_attempts = 0;
	    // Disable closed
	    this.closed = false;
	    // Trigger onTransportConnected callback
	    this.ua.onTransportConnected(this);
	    // Start sending keep-alives
	    this.startSendingKeepAlives();
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onClose: function(e) {
	    var connected_before = this.connected;
	
	    this.lastTransportError.code = e.code;
	    this.lastTransportError.reason = e.reason;
	
	    this.stopSendingKeepAlives();
	
	    if (this.reconnection_attempts > 0) {
	      this.logger.log('Reconnection attempt ' + this.reconnection_attempts + ' failed (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
	      this.reconnect();
	    } else {
	      this.connected = false;
	      this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
	
	      if(e.wasClean === false) {
	        this.logger.warn('WebSocket abrupt disconnection');
	      }
	      // Transport was connected
	      if(connected_before === true) {
	        this.ua.onTransportClosed(this);
	        // Check whether the user requested to close.
	        if(!this.closed) {
	          this.reconnect();
	        } else {
	          this.ua.emit('disconnected', {
	            transport: this,
	            code: this.lastTransportError.code,
	            reason: this.lastTransportError.reason
	          });
	
	        }
	      } else {
	        // This is the first connection attempt
	        //Network error
	        this.ua.onTransportError(this);
	      }
	    }
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onMessage: function(e) {
	    var message, transaction,
	      data = e.data;
	
	    // CRLF Keep Alive response from server. Ignore it.
	    if(data === '\r\n') {
	      SIP.Timers.clearTimeout(this.keepAliveTimeout);
	      this.keepAliveTimeout = null;
	
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket message with CRLF Keep Alive response');
	      }
	
	      return;
	    }
	
	    // WebSocket binary message.
	    else if (typeof data !== 'string') {
	      try {
	        data = String.fromCharCode.apply(null, new Uint8Array(data));
	      } catch(evt) {
	        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');
	        return;
	      }
	
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket binary message:\n\n' + data + '\n');
	      }
	    }
	
	    // WebSocket text message.
	    else {
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket text message:\n\n' + data + '\n');
	      }
	    }
	
	    message = SIP.Parser.parseMessage(data, this.ua);
	
	    if (!message) {
	      return;
	    }
	
	    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {
	      return;
	    }
	
	    // Do some sanity check
	    if(SIP.sanityCheck(message, this.ua, this)) {
	      if(message instanceof SIP.IncomingRequest) {
	        message.transport = this;
	        this.ua.receiveRequest(message);
	      } else if(message instanceof SIP.IncomingResponse) {
	        /* Unike stated in 18.1.2, if a response does not match
	        * any transaction, it is discarded here and no passed to the core
	        * in order to be discarded there.
	        */
	        switch(message.method) {
	          case SIP.C.INVITE:
	            transaction = this.ua.transactions.ict[message.via_branch];
	            if(transaction) {
	              transaction.receiveResponse(message);
	            }
	            break;
	          case SIP.C.ACK:
	            // Just in case ;-)
	            break;
	          default:
	            transaction = this.ua.transactions.nict[message.via_branch];
	            if(transaction) {
	              transaction.receiveResponse(message);
	            }
	            break;
	        }
	      }
	    }
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onError: function(e) {
	    this.logger.warn('WebSocket connection error: ' + JSON.stringify(e));
	  },
	
	  /**
	  * Reconnection attempt logic.
	  * @private
	  */
	  reconnect: function() {
	    var transport = this;
	
	    this.reconnection_attempts += 1;
	
	    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {
	      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);
	      this.ua.onTransportError(this);
	    } else if (this.reconnection_attempts === 1) {
	      this.logger.log('Connection to WebSocket ' + this.server.ws_uri + ' severed, attempting first reconnect');
	      transport.connect();
	    } else {
	      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');
	
	      this.reconnectTimer = SIP.Timers.setTimeout(function() {
	        transport.connect();
	        transport.reconnectTimer = null;
	      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);
	    }
	  }
	};
	
	Transport.C = C;
	return Transport;
	};


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAzZjVhYTdhOWQ2ZDY0NDA4ODBjNyIsIndlYnBhY2s6Ly8vLi9zcmMvcmMtcGhvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2FkZC1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yaW5nY2VudHJhbC9idWlsZC9yaW5nY2VudHJhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwid2VicGFjazovLy8uL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vL3ZlcnR4IChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpbmdjZW50cmFsL34vd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwid2VicGFjazovLy8uL34vcHVibnViL21vZGVybi9kaXN0L3B1Ym51Yi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpbmdjZW50cmFsLWNsaWVudC9idWlsZC9yaW5nY2VudHJhbC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yYy1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9zeW1ib2wtbWFwLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvZW51bS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlZHV4LWhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2V2ZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qva2V5cy9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc2V0dGluZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0hvc3RPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvYnJhbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvYnJhbmQvYnJhbmQtYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9icmFuZC9icmFuZC1yZWR1Y2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2F1dGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2xvZ2luLXN0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3N1YnNjcmlwdGlvbi9zdWJzY3JpcHRpb24tYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1zdGF0dXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvdXNlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLWFjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1hY3Rpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL3dlYnBob25lLXN0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS9jYWxsLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL2NhbGwtc3RhdHVzLmpzIiwid2VicGFjazovLy8uL34vcmluZ2NlbnRyYWwtd2ViLXBob25lL3NyYy9yaW5nY2VudHJhbC13ZWItcGhvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9TSVAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvcGFja2FnZS5qc29uIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvTG9nZ2VyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvQ29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9FeGNlcHRpb25zLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9UaW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU0lQTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVVJJLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9OYW1lQWRkckhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVHJhbnNhY3Rpb25zLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9EaWFsb2dzLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9EaWFsb2cvUmVxdWVzdFNlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvUmVxdWVzdFNlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvUmVnaXN0ZXJDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9NZWRpYUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL0NsaWVudENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1NlcnZlckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1Nlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1Nlc3Npb24vRFRNRi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9XZWJSVEMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYVN0cmVhbU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1VBLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9IYWNrcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU2FuaXR5Q2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL0RpZ2VzdEF1dGhlbnRpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9HcmFtbWFyLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9HcmFtbWFyL2Rpc3QvR3JhbW1hci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvZW52aXJvbm1lbnRfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVHJhbnNwb3J0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLEtBQU0sVUFBVSx1QkFBaEI7O0FBRUEsVUFBUywyQkFBVCxHQUF1QztBQUNyQyxPQUFNLFdBQVcsbUJBQWpCO0FBQ0EsVUFBTyxDQUNMLFVBQUMsRUFBRDtBQUFBLFlBQVEsU0FBUyxHQUFULENBQWEsRUFBYixDQUFSO0FBQUEsSUFESyxFQUVMLFVBQUMsS0FBRDtBQUFBLFlBQVcsU0FBUyxPQUFULENBQWlCO0FBQUEsY0FBTSxHQUFHLEtBQUgsQ0FBTjtBQUFBLE1BQWpCLENBQVg7QUFBQSxJQUZLLENBQVA7QUFJRDs7S0FFb0IsTzs7O0FBQ25CLDBCQU9HO0FBQUEsU0FORCxvQkFNQyxRQU5ELG9CQU1DO0FBQUEsU0FMRCxRQUtDLFFBTEQsUUFLQztBQUFBLFNBSkQsWUFJQyxRQUpELFdBSUM7QUFBQSw0QkFIRCxNQUdDO0FBQUEsU0FIRCxNQUdDLCtCQUhRLElBR1I7QUFBQSxTQUZELFdBRUMsUUFGRCxXQUVD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FB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QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNILHFCQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsVUFBVTs7Ozs7OztBQ3RIdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDLDZCQUFxRDs7Ozs7OztBQzNIdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsU0FBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7O0FDbkZBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOzs7Ozs7OytDQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMEc7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLHNCQUFzQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7QUFDVCx3QkFBdUIsUUFBUTtBQUMvQjs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUVBQWtFLFFBQVE7O0FBRTFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBa0UsUUFBUTtBQUMxRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFFBQVE7O0FBRTdDOztBQUVBLHNCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBLGVBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0EsZUFBYyxTQUFTO0FBQ3ZCLGVBQWMsU0FBUztBQUN2QjtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0EsZUFBYyxTQUFTO0FBQ3ZCO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixrRUFBa0U7QUFDdkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCx1REFBc0QsZ0JBQWdCLEVBQUU7QUFDeEU7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXlCLHdDQUF3QyxFQUFFO0FBQ25FLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7Ozs7Ozs7O0FDNzdCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1RBLGdCOzs7Ozs7QUNBQSw4QkFBNkIsbURBQW1EOzs7Ozs7O0FDQWhGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQLE1BQUs7QUFDTDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF1RDtBQUN2RCxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBLHdDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUErQiwwQkFBMEIsZUFBZTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsT0FBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVE7QUFDUixPQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQSxPQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLG1FQUFtRTtBQUNwRztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsT0FBTTs7QUFFTjtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsbUVBQW1FO0FBQ3BHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLFNBQVE7QUFDUjtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEMsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLDZEQUE2RDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsNERBQTREO0FBQ3pHLGlCQUFnQjtBQUNoQiwrQ0FBOEMsNkNBQTZDO0FBQzNGO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0Esa0NBQWlDLEVBQUU7QUFDbkM7QUFDQTtBQUNBOztBQUVBLG9CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUixPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQSwyQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBLHNCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLGtCQUFrQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTs7QUFFVjtBQUNBO0FBQ0Esc0JBQXFCLGtCQUFrQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0EsV0FBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsa0JBQWtCO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQztBQUNwQyxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyw2QkFBNkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEIsbUJBQWtCO0FBQ2xCO0FBQ0EsZUFBYztBQUNkLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjOztBQUVkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCLG1CQUFrQjtBQUNsQjtBQUNBLGVBQWM7QUFDZCxhQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFxQyw2QkFBNkI7O0FBRWxFO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBOEUseUJBQXlCO0FBQ3ZHLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7O0FBRWQ7QUFDQTtBQUNBLFdBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0Esd0JBQXVCLHNDQUFzQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBLHdDQUF1QyxzQ0FBc0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxpQkFBaUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWOztBQUVBLFNBQVE7QUFDUixPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTJFLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsVUFBVSxlQUFlLGNBQWM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDhGQUE4RjtBQUMvRjs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE2RSxVQUFVLFlBQVksWUFBWTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZLFdBQVcsYUFBYTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLG9GQUFtRixRQUFRO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBc0YsV0FBVztBQUNqRztBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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TUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBMkUsVUFBVSxZQUFZLFlBQVk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWSxVQUFVLFVBQVU7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE2RSxVQUFVLFlBQVksWUFBWSxVQUFVLFVBQVU7QUFDbkk7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLDhFQUE4RTtBQUMzRixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGdHQUFnRztBQUM3RyxjQUFhLG9HQUFvRztBQUNqSCxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLGtGQUFrRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxzRkFBc0Y7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsc0ZBQXNGO0FBQ3ZGOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTJFLFVBQVUsWUFBWSxZQUFZO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsVUFBVSxZQUFZLFlBQVksb0JBQW9CLG1CQUFtQjtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQTZFLFVBQVUsWUFBWSxZQUFZLG9CQUFvQixtQkFBbUI7QUFDdEo7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsMEdBQTBHO0FBQ3ZILGNBQWEsa0dBQWtHO0FBQy9HLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsOEVBQThFO0FBQzNGLGNBQWEsK0VBQStFO0FBQzVGLGNBQWEsdUZBQXVGO0FBQ3BHLGNBQWEsaUZBQWlGO0FBQzlGLGNBQWEsK0ZBQStGO0FBQzVHLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLG9GQUFvRjtBQUNyRjs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBMkUsVUFBVSxZQUFZLFlBQVk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZLGlCQUFpQixnQkFBZ0I7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWSxpQkFBaUIsZ0JBQWdCO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBNkUsVUFBVSxZQUFZLFlBQVksaUJBQWlCLGdCQUFnQjtBQUNoSjtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsK0VBQStFO0FBQzVGLGNBQWEsOEVBQThFO0FBQzNGLGNBQWEsZ0ZBQWdGO0FBQzdGLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsbUdBQW1HO0FBQ2hILGNBQWEsaUdBQWlHO0FBQzlHLGNBQWE7QUFDYjtBQUNB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2QsTUFBSztBQUNMLGVBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx5Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDNVNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0Esd0NBQXVDLG9CQUFvQixFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0YsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHOzs7Ozs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0Esd0JBQXVCLGlCQUFpQixFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2pIQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7QUFDSCxxQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOzs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVSxrQkFBa0I7QUFDNUIsV0FBVSxvQkFBb0I7QUFDOUIsV0FBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0EsV0FBVSxrQkFBa0I7QUFDNUIsV0FBVSxvQkFBb0I7QUFDOUIsV0FBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxrQkFBa0I7QUFDN0IsWUFBVyxvQkFBb0I7QUFDL0IsWUFBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLG9CQUFvQjtBQUM5QixXQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVSxvQkFBb0I7QUFDOUIsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLG9CQUFv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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQLHNDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFFBQU87O0FBRVA7O0FBRUE7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7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QUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxxQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLEVBQUU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNB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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCLEVBQUU7QUFDcEI7QUFDQTs7QUFFQSxtQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsTEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILHVFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1R0FBc0csVUFBVTs7QUFFaEg7QUFDQSxrRUFBaUUsVUFBVTtBQUMzRTtBQUNBO0FBQ0EsNERBQTJELFVBQVU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0ZBQXFGLHFDQUFxQztBQUMxSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXdFO0FBQ3hFLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4Qix5QkFBeUIsR0FBRyx5QkFBeUI7QUFDbkYsMkNBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNBLHVCQUFzQixrQkFBa0I7QUFDeEMsUUFBTztBQUNQO0FBQ0Esc0JBQXFCLGNBQWM7QUFDbkM7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNULDhGQUE2RixxREFBcUQ7O0FBRWxKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLDRCQUE0QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzlqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCLGlCQUFpQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxvQkFBb0I7QUFDL0IsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsY0FBYztBQUN6QixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNuT0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7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QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWlCLGNBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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dXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlJjUGhvbmVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUmNQaG9uZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvblxuICoqLyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgM2Y1YWE3YTlkNmQ2NDQwODgwYzdcbiAqKi8iLCJpbXBvcnQgYWRkTW9kdWxlIGZyb20gJy4vbGliL2FkZC1tb2R1bGUnO1xuaW1wb3J0IFJpbmdDZW50cmFsIGZyb20gJ3JpbmdjZW50cmFsJztcbmltcG9ydCBSaW5nQ2VudHJhbENsaWVudCBmcm9tICdyaW5nY2VudHJhbC1jbGllbnQnO1xuXG5pbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi9saWIvcmMtbW9kdWxlJztcblxuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4vbW9kdWxlcy9zZXR0aW5ncyc7XG5pbXBvcnQgQnJhbmQgZnJvbSAnLi9tb2R1bGVzL2JyYW5kJztcbmltcG9ydCBBdXRoIGZyb20gJy4vbW9kdWxlcy9hdXRoJztcbmltcG9ydCBTdWJzY3JpcHRpb24gZnJvbSAnLi9tb2R1bGVzL3N1YnNjcmlwdGlvbic7XG5pbXBvcnQgVXNlciBmcm9tICcuL21vZHVsZXMvdXNlcic7XG5pbXBvcnQgV2VicGhvbmUgZnJvbSAnLi9tb2R1bGVzL3dlYnBob25lJztcbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycywgY3JlYXRlU3RvcmUgfSBmcm9tICdyZWR1eCc7XG5cbmNvbnN0IFJFRFVDRVIgPSBTeW1ib2woKTtcblxuZnVuY3Rpb24gZ2V0U3RvcmVSZWdpc3RlckFuZFJlc29sdmVyKCkge1xuICBjb25zdCBoYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIFtcbiAgICAoZm4pID0+IGhhbmRsZXJzLmFkZChmbiksXG4gICAgKHN0b3JlKSA9PiBoYW5kbGVycy5mb3JFYWNoKGZuID0+IGZuKHN0b3JlKSksXG4gIF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJjUGhvbmUgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZWdpc3RlclN0b3JlSGFuZGxlcixcbiAgICBnZXRTdG9yZSxcbiAgICBzdGF0ZU1hcHBlcixcbiAgICBwcmVmaXggPSAncmMnLFxuICAgIHNka1NldHRpbmdzLFxuICAgIGRlZmF1bHRCcmFuZCxcbiAgfSkge1xuICAgIGxldCByZWdpc3RlciA9IHJlZ2lzdGVyU3RvcmVIYW5kbGVyO1xuICAgIGxldCByZXNvbHZlO1xuICAgIGlmICghcmVnaXN0ZXIpIHtcbiAgICAgIFtyZWdpc3RlciwgcmVzb2x2ZV0gPSBnZXRTdG9yZVJlZ2lzdGVyQW5kUmVzb2x2ZXIoKTtcbiAgICB9XG5cbiAgICBzdXBlcih7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcixcbiAgICB9KTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgnc2RrJywgbmV3IFJpbmdDZW50cmFsKHtcblxuICAgICAgY2FjaGVQcmVmaXg6IGAke3ByZWZpeH0tYCxcbiAgICAgIC4uLnNka1NldHRpbmdzLFxuICAgIH0pKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgncGxhdGZvcm0nLCB0aGlzLnNkay5wbGF0Zm9ybSgpKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgnYXBpJywgbmV3IFJpbmdDZW50cmFsQ2xpZW50KHRoaXMuc2RrKSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ2F1dGgnLCBuZXcgQXV0aCh7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcjogc3RhdGUgPT4gc3RhdGVNYXBwZXIoc3RhdGUpLmF1dGgsXG4gICAgICBwcmVmaXgsXG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3NldHRpbmdzJywgbmV3IFNldHRpbmdzKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyOiBzdGF0ZSA9PiBzdGF0ZU1hcHBlcihzdGF0ZSkuc2V0dGluZ3MsXG4gICAgfSkpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCdkZWZhdWx0QnJhbmQnLCBuZXcgQnJhbmQoe1xuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IHJlZ2lzdGVyLFxuICAgICAgcHJlZml4OiBgJHtwcmVmaXh9LWRlZmF1bHRgLFxuICAgICAgc3RhdGVNYXBwZXI6IHN0YXRlID0+IHN0YXRlTWFwcGVyKHN0YXRlKS5kZWZhdWx0QnJhbmQsXG4gICAgICAuLi5kZWZhdWx0QnJhbmQsXG4gICAgfSkpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCdzdWJzY3JpcHRpb24nLCBuZXcgU3Vic2NyaXB0aW9uKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyOiBzdGF0ZSA9PiBzdGF0ZU1hcHBlcihzdGF0ZSkuc3Vic2NyaXB0aW9uLFxuICAgICAgcHJlZml4LFxuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgc2RrOiB0aGlzLnNkayxcbiAgICAgIGF1dGg6IHRoaXMuYXV0aCxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3VzZXInLCBuZXcgVXNlcih7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcjogc3RhdGUgPT4gc3RhdGVNYXBwZXIoc3RhdGUpLnVzZXIsXG4gICAgICBwcmVmaXgsXG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3dlYnBob25lJywgbmV3IFdlYnBob25lKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyOiAoc3RhdGUpID0+IHN0YXRlTWFwcGVyKHN0YXRlKS53ZWJwaG9uZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuICAgIH0pKTtcblxuICAgIC8vIGNvbWJpbmUgcmVkdWNlcnNcbiAgICB0aGlzW1JFRFVDRVJdID0gY29tYmluZVJlZHVjZXJzKHtcbiAgICAgIGF1dGg6IHRoaXMuYXV0aC5yZWR1Y2VyLFxuICAgICAgZGVmYXVsdEJyYW5kOiB0aGlzLmRlZmF1bHRCcmFuZC5yZWR1Y2VyLFxuICAgICAgc3Vic2NyaXB0aW9uOiB0aGlzLnN1YnNjcmlwdGlvbi5yZWR1Y2VyLFxuICAgICAgdXNlcjogdGhpcy51c2VyLnJlZHVjZXIsXG4gICAgICB3ZWJwaG9uZTogdGhpcy53ZWJwaG9uZS5yZWR1Y2VyLFxuICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MucmVkdWNlcixcbiAgICB9KTtcblxuICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKGdldFN0b3JlKHRoaXMucmVkdWNlcikpO1xuICAgICAgLy8gcmVzb2x2ZShjcmVhdGVTdG9yZSh0aGlzLnJlZHVjZXIpKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIHRoaXNbUkVEVUNFUl07XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3JjLXBob25lLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiKTtcblxudmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX2Fzc2lnbjIuZGVmYXVsdCB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xyXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcclxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXHJcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcclxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xyXG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxyXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcclxuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcclxuICAgICwgaSAgICAgID0gMFxyXG4gICAgLCByZXN1bHQgPSBbXVxyXG4gICAgLCBrZXk7XHJcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xyXG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcclxuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XHJcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXHJcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xyXG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xyXG5tb2R1bGUuZXhwb3J0cyA9IChcclxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xyXG4pLnNwbGl0KCcsJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcclxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcclxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXHJcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcclxuICBPID0gdG9PYmplY3QoTyk7XHJcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XHJcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XHJcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XHJcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxyXG4gICwgZFBzICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJylcclxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXHJcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxyXG4gICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XHJcbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xyXG5cclxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxyXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XHJcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcclxuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKVxyXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcclxuICAgICwgZ3QgICAgID0gJz4nXHJcbiAgICAsIGlmcmFtZURvY3VtZW50O1xyXG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcclxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xyXG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcclxuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xyXG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcclxuICBpZnJhbWVEb2N1bWVudC53cml0ZSgnPHNjcmlwdD5kb2N1bWVudC5GPU9iamVjdDwvc2NyaXB0JyArIGd0KTtcclxuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xyXG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xyXG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcclxuICByZXR1cm4gY3JlYXRlRGljdCgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcclxuICB2YXIgcmVzdWx0O1xyXG4gIGlmKE8gIT09IG51bGwpe1xyXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xyXG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xyXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XHJcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXHJcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcclxuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xyXG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxyXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxyXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xyXG4gIGFuT2JqZWN0KE8pO1xyXG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXHJcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAsIGkgPSAwXHJcbiAgICAsIFA7XHJcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xyXG4gIHJldHVybiBPO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0ICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcclxuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcclxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgTUVUQSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZXG4gICwgJGZhaWxzICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc2hhcmVkICAgICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIHVpZCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCB3a3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCB3a3NEZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fa2V5b2YnKVxuICAsIGVudW1LZXlzICAgICAgID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJylcbiAgLCBpc0FycmF5ICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBfY3JlYXRlICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGdPUE5FeHQgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JylcbiAgLCAkR09QRCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCAkRFAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGtleXMgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QRCAgICAgICAgICAgPSAkR09QRC5mXG4gICwgZFAgICAgICAgICAgICAgPSAkRFAuZlxuICAsIGdPUE4gICAgICAgICAgID0gZ09QTkV4dC5mXG4gICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXG4gICwgJEpTT04gICAgICAgICAgPSBnbG9iYWwuSlNPTlxuICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG4gICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xuICAsIEhJRERFTiAgICAgICAgID0gd2tzKCdfaGlkZGVuJylcbiAgLCBUT19QUklNSVRJVkUgICA9IHdrcygndG9QcmltaXRpdmUnKVxuICAsIGlzRW51bSAgICAgICAgID0ge30ucHJvcGVydHlJc0VudW1lcmFibGVcbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG4gICwgT1BTeW1ib2xzICAgICAgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKVxuICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0W1BST1RPVFlQRV1cbiAgLCBVU0VfTkFUSVZFICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcbiAgLCBRT2JqZWN0ICAgICAgICA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8pJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZih0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgaXQgID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnT1BOKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIElTX09QICA9IGl0ID09PSBPYmplY3RQcm90b1xuICAgICwgbmFtZXMgID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZighVVNFX05BVElWRSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZih0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKHRoaXMgPT09IE9iamVjdFByb3RvKSRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZihERVNDUklQVE9SUyAmJiBzZXR0ZXIpc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7Y29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXR9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiAgID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5Jykpe1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuZm9yKHZhciBzeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3Moc3ltYm9sc1tpKytdKTtcblxuZm9yKHZhciBzeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrc0RlZmluZShzeW1ib2xzW2krK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIGlmKGlzU3ltYm9sKGtleSkpcmV0dXJuIGtleU9mKFN5bWJvbFJlZ2lzdHJ5LCBrZXkpO1xuICAgIHRocm93IFR5cGVFcnJvcihrZXkgKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcbiAgICBpZihpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSlyZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICB2YXIgYXJncyA9IFtpdF1cbiAgICAgICwgaSAgICA9IDFcbiAgICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXHJcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxyXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcclxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXHJcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcclxuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2tleW9mLmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSA4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxyXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcclxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XHJcblxyXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xyXG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcbiAqKiBtb2R1bGUgaWQgPSA4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXHJcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxyXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcclxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcclxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxyXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xyXG5cclxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XHJcbiAgTyA9IHRvSU9iamVjdChPKTtcclxuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XHJcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcclxuICAgIHJldHVybiBnT1BEKE8sIFApO1xyXG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cclxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanNcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qc1xuICoqIG1vZHVsZSBpZCA9IDk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXHJcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc2V0XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlNldDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMTAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGhpZGUgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJylcbiAgLCBzdGVwICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgc2V0U3BlY2llcyAgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgZmFzdEtleSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleVxuICAsIFNJWkUgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsICdmb3JFYWNoJyk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKVxuICAgICAgICAgICwgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZil7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihERVNDUklQVE9SUylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXtcbiAgICBpZihzYWZlICYmIHRhcmdldFtrZXldKXRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpe1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgLCBCUkVBSyAgICAgICA9IHt9XG4gICwgUkVUVVJOICAgICAgPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyAgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gdHlwZW9mIGNvcmVbS0VZXSA9PSAnZnVuY3Rpb24nID8gY29yZVtLRVldIDogZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbWV0YSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBmYWlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lQWxsICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgYW5JbnN0YW5jZSAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGVhY2ggICAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKXtcbiAgdmFyIEJhc2UgID0gZ2xvYmFsW05BTUVdXG4gICAgLCBDICAgICA9IEJhc2VcbiAgICAsIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJ1xuICAgICwgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlXG4gICAgLCBPICAgICA9IHt9O1xuICBpZighREVTQ1JJUFRPUlMgfHwgdHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUsICdfYycpO1xuICAgICAgdGFyZ2V0Ll9jID0gbmV3IEJhc2U7XG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGFyZ2V0W0FEREVSXSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBlYWNoKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04nLnNwbGl0KCcsJyksZnVuY3Rpb24oS0VZKXtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG4gICAgICBpZihLRVkgaW4gcHJvdG8gJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSloaWRlKEMucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsIEtFWSk7XG4gICAgICAgIGlmKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSlyZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKCdzaXplJyBpbiBwcm90bylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGFzYyAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVFlQRSwgJGNyZWF0ZSl7XG4gIHZhciBJU19NQVAgICAgICAgID0gVFlQRSA9PSAxXG4gICAgLCBJU19GSUxURVIgICAgID0gVFlQRSA9PSAyXG4gICAgLCBJU19TT01FICAgICAgID0gVFlQRSA9PSAzXG4gICAgLCBJU19FVkVSWSAgICAgID0gVFlQRSA9PSA0XG4gICAgLCBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2XG4gICAgLCBOT19IT0xFUyAgICAgID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVhcbiAgICAsIGNyZWF0ZSAgICAgICAgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QoJHRoaXMpXG4gICAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAsIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWRcbiAgICAgICwgdmFsLCByZXM7XG4gICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKXtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmKFRZUEUpe1xuICAgICAgICBpZihJU19NQVApcmVzdWx0W2luZGV4XSA9IHJlczsgICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZihyZXMpc3dpdGNoKFRZUEUpe1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYoSVNfRVZFUlkpcmV0dXJuIGZhbHNlOyAgICAgICAgICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCwgbGVuZ3RoKXtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxyXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXHJcbiAgLCBTUEVDSUVTICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcclxuICB2YXIgQztcclxuICBpZihpc0FycmF5KG9yaWdpbmFsKSl7XHJcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XHJcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xyXG4gICAgaWYodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKUMgPSB1bmRlZmluZWQ7XHJcbiAgICBpZihpc09iamVjdChDKSl7XHJcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xyXG4gICAgICBpZihDID09PSBudWxsKUMgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlciwgSVRFUkFUT1Ipe1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZE1vZHVsZShuYW1lLCBtb2R1bGUpIHtcbiAgaWYgKHRoaXM6Ok9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG1vZHVsZSAnJHtuYW1lfScgYWxyZWFkeSBleGlzdHMuLi5gKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gIH0pO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL2FkZC1tb2R1bGUuanNcbiAqKi8iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJlczYtcHJvbWlzZVwiKSwgcmVxdWlyZShcIm5vZGUtZmV0Y2hcIiksIHJlcXVpcmUoXCJwdWJudWJcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoWywgLCBcInB1Ym51YlwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJTREtcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJlczYtcHJvbWlzZVwiKSwgcmVxdWlyZShcIm5vZGUtZmV0Y2hcIiksIHJlcXVpcmUoXCJwdWJudWJcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJpbmdDZW50cmFsXCJdID0gcm9vdFtcIlJpbmdDZW50cmFsXCJdIHx8IHt9LCByb290W1wiUmluZ0NlbnRyYWxcIl1bXCJTREtcIl0gPSBmYWN0b3J5KHJvb3RbdW5kZWZpbmVkXSwgcm9vdFt1bmRlZmluZWRdLCByb290W3VuZGVmaW5lZF0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV81X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9idWlsZC9cIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfVXRpbHMpO1xuXG52YXIgX0NhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9DYWNoZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYWNoZSk7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIEV4dGVybmFscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9FeHRlcm5hbHMpO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfQ2xpZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NsaWVudCk7XG5cbnZhciBfQXBpUmVzcG9uc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9BcGlSZXNwb25zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BcGlSZXNwb25zZSk7XG5cbnZhciBfQ2xpZW50TW9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG52YXIgX0NsaWVudE1vY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2xpZW50TW9jayk7XG5cbnZhciBfTW9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgX01vY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9jayk7XG5cbnZhciBfUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9SZWdpc3RyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWdpc3RyeSk7XG5cbnZhciBfUGxhdGZvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9QbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QbGF0Zm9ybSk7XG5cbnZhciBfQXV0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX0F1dGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXV0aCk7XG5cbnZhciBfUHVibnViRmFjdG9yeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgX1B1Ym51YkZhY3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHVibnViRmFjdG9yeSk7XG5cbnZhciBfU3Vic2NyaXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbnZhciBfU3Vic2NyaXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1YnNjcmlwdGlvbik7XG5cbnZhciBfQ2FjaGVkU3Vic2NyaXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBfQ2FjaGVkU3Vic2NyaXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhY2hlZFN1YnNjcmlwdGlvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTREsgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlIFJpbmdDZW50cmFsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZXJ2ZXJdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNhY2hlUHJlZml4XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcHBTZWNyZXRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFwcEtleV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwTmFtZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwVmVyc2lvbl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHVibnViRmFjdG9yeV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xpZW50XVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU0RLKG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNESyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKCFFeHRlcm5hbHMuZmV0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmF0aXZlIEZldGNoIGlzIG1pc3NpbmcsIHNldCBSaW5nQ2VudHJhbC5TREsuY29yZS5FeHRlcm5hbHMuZmV0Y2ggdG8geW91ciBmYXZvcml0ZSBhbHRlcm5hdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFFeHRlcm5hbHMuUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgUHJvbWlzZSBpcyBtaXNzaW5nLCBzZXQgUmluZ0NlbnRyYWwuU0RLLmNvcmUuRXh0ZXJuYWxzLlByb21pc2UgdG8geW91ciBmYXZvcml0ZSBhbHRlcm5hdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgX0NhY2hlMi5kZWZhdWx0KEV4dGVybmFscy5sb2NhbFN0b3JhZ2UsIG9wdGlvbnMuY2FjaGVQcmVmaXgpO1xuXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IG9wdGlvbnMuY2xpZW50IHx8IG5ldyBfQ2xpZW50Mi5kZWZhdWx0KCk7XG5cbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBuZXcgX1BsYXRmb3JtMi5kZWZhdWx0KHRoaXMuX2NsaWVudCwgdGhpcy5fY2FjaGUsIG9wdGlvbnMuc2VydmVyLCBvcHRpb25zLmFwcEtleSwgb3B0aW9ucy5hcHBTZWNyZXQsIG9wdGlvbnMuYXBwTmFtZSwgb3B0aW9ucy5hcHBWZXJzaW9uLCBTREsudmVyc2lvbik7XG5cbiAgICAgICAgdGhpcy5fcHVibnViRmFjdG9yeSA9IG9wdGlvbnMucHVibnViRmFjdG9yeSB8fCBFeHRlcm5hbHMuUFVCTlVCO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1BsYXRmb3JtfVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLnBsYXRmb3JtID0gZnVuY3Rpb24gcGxhdGZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfU3Vic2NyaXB0aW9uMi5kZWZhdWx0KHRoaXMuX3B1Ym51YkZhY3RvcnksIHRoaXMuX3BsYXRmb3JtKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Q2FjaGVkU3Vic2NyaXB0aW9ufVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLmNyZWF0ZUNhY2hlZFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUNhY2hlZFN1YnNjcmlwdGlvbihjYWNoZUtleSkge1xuICAgICAgICByZXR1cm4gbmV3IF9DYWNoZWRTdWJzY3JpcHRpb24yLmRlZmF1bHQodGhpcy5fcHVibnViRmFjdG9yeSwgdGhpcy5fcGxhdGZvcm0sIHRoaXMuX2NhY2hlLCBjYWNoZUtleSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0NhY2hlfVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24gY2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9O1xuXG4gICAgU0RLLmhhbmRsZUxvZ2luUmVkaXJlY3QgPSBmdW5jdGlvbiBoYW5kbGVMb2dpblJlZGlyZWN0KG9yaWdpbikge1xuICAgICAgICB3aW5kb3cub3BlbmVyLnBvc3RNZXNzYWdlKHsgUkNBdXRob3JpemF0aW9uQ29kZTogd2luZG93LmxvY2F0aW9uLnNlYXJjaCB9LCBvcmlnaW4gfHwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gICAgfTtcblxuICAgIHJldHVybiBTREs7XG59KCk7XG5cblNESy52ZXJzaW9uID0gIHRydWUgPyAoXCIzLjAuMC1yYzFcIikgOiAneC54LngnO1xuU0RLLnNlcnZlciA9IHtcbiAgICBzYW5kYm94OiAnaHR0cHM6Ly9wbGF0Zm9ybS5kZXZ0ZXN0LnJpbmdjZW50cmFsLmNvbScsXG4gICAgcHJvZHVjdGlvbjogJ2h0dHBzOi8vcGxhdGZvcm0ucmluZ2NlbnRyYWwuY29tJ1xufTtcblNESy5jb3JlID0ge1xuICAgIENhY2hlOiBfQ2FjaGUyLmRlZmF1bHQsXG4gICAgRXZlbnRFbWl0dGVyOiBfZXZlbnRzMi5kZWZhdWx0LFxuICAgIFV0aWxzOiBVdGlscyxcbiAgICBFeHRlcm5hbHM6IEV4dGVybmFsc1xufTtcblNESy5odHRwID0ge1xuICAgIENsaWVudDogX0NsaWVudDIuZGVmYXVsdCxcbiAgICBBcGlSZXNwb25zZTogX0FwaVJlc3BvbnNlMi5kZWZhdWx0XG59O1xuU0RLLnBsYXRmb3JtID0ge1xuICAgIEF1dGg6IF9BdXRoMi5kZWZhdWx0LFxuICAgIFBsYXRmb3JtOiBfUGxhdGZvcm0yLmRlZmF1bHRcbn07XG5TREsuc3Vic2NyaXB0aW9uID0ge1xuICAgIFN1YnNjcmlwdGlvbjogX1N1YnNjcmlwdGlvbjIuZGVmYXVsdFxufTtcblNESy5tb2NrcyA9IHtcbiAgICBDbGllbnQ6IF9DbGllbnRNb2NrMi5kZWZhdWx0LFxuICAgIFJlZ2lzdHJ5OiBfUmVnaXN0cnkyLmRlZmF1bHQsXG4gICAgTW9jazogX01vY2syLmRlZmF1bHRcbn07XG5TREsucHVibnViID0ge1xuICAgIFB1Ym51Yk1vY2tGYWN0b3J5OiBfUHVibnViRmFjdG9yeTIuZGVmYXVsdFxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNESztcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgaXRlcmF0b3JTeW1ib2wgPVxuICAgIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50YCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4gU29tZSBtYXkgY29uc2lkZXIgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgdG9vXG4gIC8vIGN1dGVzeSwgYnV0IHRoZXkgYXJlIGN1cm11ZGdlb25zLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgLy8gVGhpcyBpbnZva2UgZnVuY3Rpb24gaXMgd3JpdHRlbiBpbiBhIHN0eWxlIHRoYXQgYXNzdW1lcyBzb21lXG4gICAgLy8gY2FsbGluZyBmdW5jdGlvbiAob3IgUHJvbWlzZSkgd2lsbCBoYW5kbGUgZXhjZXB0aW9ucy5cbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZW5lcmF0b3JbbWV0aG9kXShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudFxuICAgICAgICA/IFByb21pc2UucmVzb2x2ZSh2YWx1ZS5hcmcpLnRoZW4oaW52b2tlTmV4dCwgaW52b2tlVGhyb3cpXG4gICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBpbnZva2VOZXh0ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcIm5leHRcIik7XG4gICAgdmFyIGludm9rZVRocm93ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIHZhciBpbnZva2VSZXR1cm4gPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwicmV0dXJuXCIpO1xuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8XG4gICAgICAgICAgICAgIChtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9zZW50ID0gYXJnO1xuXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSBhcmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgdGhpcy5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMucXVlcnlTdHJpbmdpZnkgPSBxdWVyeVN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2VRdWVyeVN0cmluZyA9IHBhcnNlUXVlcnlTdHJpbmc7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNPYmplY3RPYmplY3QgPSBpc09iamVjdE9iamVjdDtcbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG5leHBvcnRzLmlzTm9kZUpTID0gaXNOb2RlSlM7XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4vKipcbiAqIFRPRE8gUmVwbGFjZSB3aXRoIHNvbWV0aGluZyBiZXR0ZXJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9xdWVyeXN0cmluZy5qc1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5U3RyaW5naWZ5KHBhcmFtZXRlcnMpIHtcblxuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cbiAgICAgICAgdmFyIHYgPSBwYXJhbWV0ZXJzW2tdO1xuXG4gICAgICAgIGlmIChpc0FycmF5KHYpKSB7XG4gICAgICAgICAgICB2LmZvckVhY2goZnVuY3Rpb24gKHZ2KSB7XG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaChlbmNvZGVVUklDb21wb25lbnQoaykgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodnYpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXkucHVzaChlbmNvZGVVUklDb21wb25lbnQoaykgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodikpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJyYXkuam9pbignJicpO1xufVxuXG4vKipcbiAqIFRPRE8gUmVwbGFjZSB3aXRoIHNvbWV0aGluZyBiZXR0ZXJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9xdWVyeXN0cmluZy5qc1xuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5U3RyaW5nXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5U3RyaW5nKSB7XG5cbiAgICB2YXIgYXJnc1BhcnNlZCA9IHt9O1xuXG4gICAgcXVlcnlTdHJpbmcuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcblxuICAgICAgICBhcmcgPSBkZWNvZGVVUklDb21wb25lbnQoYXJnKTtcblxuICAgICAgICBpZiAoYXJnLmluZGV4T2YoJz0nKSA9PSAtMSkge1xuXG4gICAgICAgICAgICBhcmdzUGFyc2VkW2FyZy50cmltKCldID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIHBhaXIgPSBhcmcuc3BsaXQoJz0nKSxcbiAgICAgICAgICAgICAgICBrZXkgPSBwYWlyWzBdLnRyaW0oKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhaXJbMV0udHJpbSgpO1xuXG4gICAgICAgICAgICBpZiAoa2V5IGluIGFyZ3NQYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGFyZ3NQYXJzZWQgJiYgIWlzQXJyYXkoYXJnc1BhcnNlZFtrZXldKSkgYXJnc1BhcnNlZFtrZXldID0gW2FyZ3NQYXJzZWRba2V5XV07XG4gICAgICAgICAgICAgICAgYXJnc1BhcnNlZFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzUGFyc2VkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFyZ3NQYXJzZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEBwYXJhbSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KG9iaikgOiB0eXBlb2Ygb2JqID09PSBcImFycmF5XCI7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgICByZXR1cm4gbyAhPSBudWxsICYmICh0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobykpID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShvKTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RPYmplY3Qobykge1xuICAgIHJldHVybiBpc09iamVjdChvKSA9PT0gdHJ1ZSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcbiAgICB2YXIgY3RvciwgcHJvdDtcblxuICAgIGlmIChpc09iamVjdE9iamVjdChvKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuICAgIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0eXBlb2YgY3RvciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZVxuICAgIHByb3QgPSBjdG9yLnByb3RvdHlwZTtcbiAgICBpZiAoaXNPYmplY3RPYmplY3QocHJvdCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcbiAgICBpZiAocHJvdC5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTW9zdCBsaWtlbHkgYSBwbGFpbiBPYmplY3RcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlSlMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gZGVsYXkodGltZW91dCkge1xuICAgIHJldHVybiBuZXcgX0V4dGVybmFscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICB9KTtcbn1cblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvY2FsU3RvcmFnZSA9IGV4cG9ydHMuUFVCTlVCID0gZXhwb3J0cy5IZWFkZXJzID0gZXhwb3J0cy5SZXNwb25zZSA9IGV4cG9ydHMuUmVxdWVzdCA9IGV4cG9ydHMuZmV0Y2ggPSBleHBvcnRzLlByb21pc2UgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXM2UHJvbWlzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfZXM2UHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lczZQcm9taXNlKTtcblxudmFyIF9ub2RlRmV0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX25vZGVGZXRjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlRmV0Y2gpO1xuXG52YXIgX3B1Ym51YiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfcHVibnViMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3B1Ym51Yik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciByb290ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpcztcIikoKTtcblxudmFyIFByb21pc2UgPSBfZXM2UHJvbWlzZTIuZGVmYXVsdCAmJiBfZXM2UHJvbWlzZTIuZGVmYXVsdC5Qcm9taXNlIHx8IHJvb3QuUHJvbWlzZTtcblxudmFyIGZldGNoID0gX25vZGVGZXRjaDIuZGVmYXVsdCAmJiB0eXBlb2YgX25vZGVGZXRjaDIuZGVmYXVsdCA9PSAnZnVuY3Rpb24nID8gX25vZGVGZXRjaDIuZGVmYXVsdCA6IHJvb3QuZmV0Y2g7XG52YXIgUmVxdWVzdCA9IGZldGNoLlJlcXVlc3QgfHwgcm9vdC5SZXF1ZXN0O1xudmFyIFJlc3BvbnNlID0gZmV0Y2guUmVzcG9uc2UgfHwgcm9vdC5SZXNwb25zZTtcbnZhciBIZWFkZXJzID0gZmV0Y2guSGVhZGVycyB8fCByb290LkhlYWRlcnM7XG5cbnZhciBQVUJOVUIgPSBfcHVibnViMi5kZWZhdWx0IHx8IHJvb3QuUFVCTlVCO1xuXG52YXIgbG9jYWxTdG9yYWdlID0gdHlwZW9mIHJvb3QubG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJyA/IHJvb3QubG9jYWxTdG9yYWdlIDoge307XG5cbmV4cG9ydHMuUHJvbWlzZSA9IFByb21pc2U7XG5leHBvcnRzLmZldGNoID0gZmV0Y2g7XG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbmV4cG9ydHMuUFVCTlVCID0gUFVCTlVCO1xuZXhwb3J0cy5sb2NhbFN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2U7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzVfXztcblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNl9fO1xuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83X187XG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FjaGUoc3RvcmFnZSwgcHJlZml4KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWNoZSk7XG5cbiAgICAgICAgdGhpcy5zZXRQcmVmaXgocHJlZml4KTtcbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgfVxuXG4gICAgQ2FjaGUucHJvdG90eXBlLnNldFByZWZpeCA9IGZ1bmN0aW9uIHNldFByZWZpeChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5fcHJlZml4ID0gcHJlZml4IHx8IENhY2hlLmRlZmF1bHRQcmVmaXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBDYWNoZS5wcm90b3R5cGUuc2V0SXRlbSA9IGZ1bmN0aW9uIHNldEl0ZW0oa2V5LCBkYXRhKSB7XG4gICAgICAgIHRoaXMuX3N0b3JhZ2VbdGhpcy5fcHJlZml4S2V5KGtleSldID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBDYWNoZS5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yYWdlW3RoaXMuX3ByZWZpeEtleShrZXkpXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENhY2hlLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9zdG9yYWdlW3RoaXMuX3ByZWZpeEtleShrZXkpXTtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoaXRlbSk7XG4gICAgfTtcblxuICAgIENhY2hlLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uIGNsZWFuKCkge1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9zdG9yYWdlKSB7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKHRoaXMuX3ByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fc3RvcmFnZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENhY2hlLnByb3RvdHlwZS5fcHJlZml4S2V5ID0gZnVuY3Rpb24gX3ByZWZpeEtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWZpeCArIGtleTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhY2hlO1xufSgpO1xuXG5DYWNoZS5kZWZhdWx0UHJlZml4ID0gJ3JjLSc7XG5leHBvcnRzLmRlZmF1bHQgPSBDYWNoZTtcblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmZpbmRIZWFkZXJOYW1lID0gZmluZEhlYWRlck5hbWU7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9VdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9BcGlSZXNwb25zZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgX0FwaVJlc3BvbnNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FwaVJlc3BvbnNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDbGllbnQgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAgIF9pbmhlcml0cyhDbGllbnQsIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgZnVuY3Rpb24gQ2xpZW50KCkge1xuICAgICAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGllbnQpO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwuYXBwbHkoX0V2ZW50RW1pdHRlciwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIGJlZm9yZVJlcXVlc3Q6ICdiZWZvcmVSZXF1ZXN0JyxcbiAgICAgICAgICAgIHJlcXVlc3RTdWNjZXNzOiAncmVxdWVzdFN1Y2Nlc3MnLFxuICAgICAgICAgICAgcmVxdWVzdEVycm9yOiAncmVxdWVzdEVycm9yJ1xuICAgICAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuICAgIENsaWVudC5wcm90b3R5cGUuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgYXBpUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVzcG9uc2UgPSBuZXcgX0FwaVJlc3BvbnNlMi5kZWZhdWx0KHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gU3RvcCByZXF1ZXN0IGlmIGxpc3RlbmVycyByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMuYmVmb3JlUmVxdWVzdCwgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRSZXNwb25zZShyZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlLl9yZXNwb25zZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlc3BvbnNlLl9pbml0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBpUmVzcG9uc2Uub2soKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaGFzIHVuc3VjY2Vzc2Z1bCBzdGF0dXMnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5yZXF1ZXN0U3VjY2VzcywgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcGlSZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfY29udGV4dC50MC5hcGlSZXNwb25zZSkgX2NvbnRleHQudDAgPSB0aGlzLm1ha2VFcnJvcihfY29udGV4dC50MCwgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLnJlcXVlc3RFcnJvciwgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMSwgMTRdXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBzZW5kUmVxdWVzdChfeCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZW5kUmVxdWVzdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBDbGllbnQucHJvdG90eXBlLl9sb2FkUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfRXh0ZXJuYWxzLmZldGNoLmNhbGwobnVsbCwgcmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9sb2FkUmVzcG9uc2UoX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfbG9hZFJlc3BvbnNlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIHRoZSBKUyBFcnJvciBvYmplY3Qgd2l0aCB0cmFuc2FjdGlvbiBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7RXJyb3J8SUFwaUVycm9yfSBlXG4gICAgICogQHBhcmFtIHtBcGlSZXNwb25zZX0gYXBpUmVzcG9uc2VcbiAgICAgKiBAcmV0dXJuIHtJQXBpRXJyb3J9XG4gICAgICovXG5cblxuICAgIENsaWVudC5wcm90b3R5cGUubWFrZUVycm9yID0gZnVuY3Rpb24gbWFrZUVycm9yKGUsIGFwaVJlc3BvbnNlKSB7XG5cbiAgICAgICAgLy8gV3JhcCBvbmx5IGlmIHJlZ3VsYXIgZXJyb3JcbiAgICAgICAgaWYgKCFlLmhhc093blByb3BlcnR5KCdhcGlSZXNwb25zZScpICYmICFlLmhhc093blByb3BlcnR5KCdvcmlnaW5hbE1lc3NhZ2UnKSkge1xuXG4gICAgICAgICAgICBlLmFwaVJlc3BvbnNlID0gYXBpUmVzcG9uc2U7XG4gICAgICAgICAgICBlLm9yaWdpbmFsTWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICAgICAgICAgIGUubWVzc2FnZSA9IGFwaVJlc3BvbnNlICYmIGFwaVJlc3BvbnNlLmVycm9yKHRydWUpIHx8IGUub3JpZ2luYWxNZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluaXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2luaXQudXJsXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbaW5pdC5ib2R5XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbaW5pdC5tZXRob2RdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtpbml0LnF1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbaW5pdC5oZWFkZXJzXVxuICAgICAqIEByZXR1cm4ge1JlcXVlc3R9XG4gICAgICovXG5cblxuICAgIENsaWVudC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QoaW5pdCkge1xuXG4gICAgICAgIGluaXQgPSBpbml0IHx8IHt9O1xuICAgICAgICBpbml0LmhlYWRlcnMgPSBpbml0LmhlYWRlcnMgfHwge307XG5cbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrc1xuICAgICAgICBpZiAoIWluaXQudXJsKSB0aHJvdyBuZXcgRXJyb3IoJ1VybCBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICBpZiAoIWluaXQubWV0aG9kKSBpbml0Lm1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBpZiAoaW5pdC5tZXRob2QgJiYgQ2xpZW50Ll9hbGxvd2VkTWV0aG9kcy5pbmRleE9mKGluaXQubWV0aG9kLnRvVXBwZXJDYXNlKCkpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgaGFzIHdyb25nIHZhbHVlOiAnICsgaW5pdC5tZXRob2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdHNcbiAgICAgICAgaW5pdC5jcmVkZW50aWFscyA9IGluaXQuY3JlZGVudGlhbHMgfHwgJ2luY2x1ZGUnO1xuICAgICAgICBpbml0Lm1vZGUgPSBpbml0Lm1vZGUgfHwgJ2NvcnMnO1xuXG4gICAgICAgIC8vIEFwcGVuZCBRdWVyeSBTdHJpbmdcbiAgICAgICAgaWYgKGluaXQucXVlcnkpIHtcbiAgICAgICAgICAgIGluaXQudXJsID0gaW5pdC51cmwgKyAoaW5pdC51cmwuaW5kZXhPZignPycpID4gLTEgPyAnJicgOiAnPycpICsgKDAsIF9VdGlscy5xdWVyeVN0cmluZ2lmeSkoaW5pdC5xdWVyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZpbmRIZWFkZXJOYW1lKCdBY2NlcHQnLCBpbml0LmhlYWRlcnMpKSB7XG4gICAgICAgICAgICBpbml0LmhlYWRlcnNbJ0FjY2VwdCddID0gX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9qc29uQ29udGVudFR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXJpYWxpemUgYm9keVxuICAgICAgICBpZiAoKDAsIF9VdGlscy5pc1BsYWluT2JqZWN0KShpbml0LmJvZHkpIHx8ICFpbml0LmJvZHkpIHtcblxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGVhZGVyTmFtZSA9IGZpbmRIZWFkZXJOYW1lKF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fY29udGVudFR5cGUsIGluaXQuaGVhZGVycyk7XG5cbiAgICAgICAgICAgIGlmICghY29udGVudFR5cGVIZWFkZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVIZWFkZXJOYW1lID0gX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9jb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICBpbml0LmhlYWRlcnNbY29udGVudFR5cGVIZWFkZXJOYW1lXSA9IF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fanNvbkNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBpbml0LmhlYWRlcnNbY29udGVudFR5cGVIZWFkZXJOYW1lXTtcblxuICAgICAgICAgICAgLy8gQXNzaWduIGEgbmV3IGVuY29kZWQgYm9keVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9qc29uQ29udGVudFR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShpbml0LmJvZHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250ZW50VHlwZS5pbmRleE9mKF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fdXJsZW5jb2RlZENvbnRlbnRUeXBlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaW5pdC5ib2R5ID0gKDAsIF9VdGlscy5xdWVyeVN0cmluZ2lmeSkoaW5pdC5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIHJlcXVlc3Qgd2l0aCBlbmNvZGVkIGJvZHlcbiAgICAgICAgdmFyIHJlcSA9IG5ldyBfRXh0ZXJuYWxzLlJlcXVlc3QoaW5pdC51cmwsIGluaXQpO1xuXG4gICAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIGJvZHkgYWNjZXNzaWJsZSBkaXJlY3RseSAoZm9yIG1vY2tzKVxuICAgICAgICByZXEub3JpZ2luYWxCb2R5ID0gaW5pdC5ib2R5O1xuXG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfTtcblxuICAgIHJldHVybiBDbGllbnQ7XG59KF9ldmVudHMyLmRlZmF1bHQpO1xuXG5DbGllbnQuX2FsbG93ZWRNZXRob2RzID0gWydHRVQnLCAnUE9TVCcsICdQVVQnLCAnREVMRVRFJywgJ1BBVENIJywgJ09QVElPTlMnLCAnSEVBRCddO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2xpZW50O1xuZnVuY3Rpb24gZmluZEhlYWRlck5hbWUobmFtZSwgaGVhZGVycykge1xuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMpLnJlZHVjZShmdW5jdGlvbiAocmVzLCBrZXkpIHtcbiAgICAgICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICAgICAgaWYgKG5hbWUgPT0ga2V5LnRvTG93ZXJDYXNlKCkpIHJldHVybiBrZXk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgbnVsbCk7XG59XG5cbi8qKlxuICogQG5hbWUgSUFwaUVycm9yXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhY2tcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvcmlnaW5hbE1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7QXBpUmVzcG9uc2V9IGFwaVJlc3BvbnNlXG4gKi9cblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IF9FeHRlcm5hbHMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIF9FeHRlcm5hbHMuUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBcGlSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlVGV4dFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQXBpUmVzcG9uc2UocmVxdWVzdCwgcmVzcG9uc2UsIHJlc3BvbnNlVGV4dCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXBpUmVzcG9uc2UpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7UmVxdWVzdH0gKi9cbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtSZXNwb25zZX0gKi9cbiAgICAgICAgdGhpcy5fcmVzcG9uc2UgPSByZXNwb25zZTtcblxuICAgICAgICB0aGlzLl90ZXh0ID0gcmVzcG9uc2VUZXh0O1xuICAgICAgICB0aGlzLl9qc29uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXVsdGlwYXJ0ID0gW107XG4gICAgfVxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5faXNNdWx0aXBhcnQoKSB8fCB0aGlzLl9pc0pzb24oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlKCkudGV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCB0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2luaXQ7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7UmVzcG9uc2V9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5yZXNwb25zZSA9IGZ1bmN0aW9uIHJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1JlcXVlc3R9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5vayA9IGZ1bmN0aW9uIG9rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2UgJiYgdGhpcy5fcmVzcG9uc2Uub2s7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiB0ZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzSnNvbigpICYmICF0aGlzLl9pc011bHRpcGFydCgpKSB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGlzIG5vdCB0ZXh0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24ganNvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0pzb24oKSkgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBpcyBub3QgSlNPTicpO1xuICAgICAgICBpZiAoIXRoaXMuX2pzb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2pzb24gPSB0aGlzLl90ZXh0ID8gSlNPTi5wYXJzZSh0aGlzLl90ZXh0KSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2pzb247XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBbc2tpcE9LQ2hlY2tdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihza2lwT0tDaGVjaykge1xuXG4gICAgICAgIGlmICh0aGlzLm9rKCkgJiYgIXNraXBPS0NoZWNrKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgbWVzc2FnZSA9ICh0aGlzLl9yZXNwb25zZSAmJiB0aGlzLl9yZXNwb25zZS5zdGF0dXMgPyB0aGlzLl9yZXNwb25zZS5zdGF0dXMgKyAnICcgOiAnJykgKyAodGhpcy5fcmVzcG9uc2UgJiYgdGhpcy5fcmVzcG9uc2Uuc3RhdHVzVGV4dCA/IHRoaXMuX3Jlc3BvbnNlLnN0YXR1c1RleHQgOiAnJyk7XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuanNvbigpLm1lc3NhZ2UpIG1lc3NhZ2UgPSB0aGlzLmpzb24oKS5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKHRoaXMuanNvbigpLmVycm9yX2Rlc2NyaXB0aW9uKSBtZXNzYWdlID0gdGhpcy5qc29uKCkuZXJyb3JfZGVzY3JpcHRpb247XG4gICAgICAgICAgICBpZiAodGhpcy5qc29uKCkuZGVzY3JpcHRpb24pIG1lc3NhZ2UgPSB0aGlzLmpzb24oKS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXBpUmVzcG9uc2VbXX1cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLm11bHRpcGFydCA9IGZ1bmN0aW9uIG11bHRpcGFydCgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzTXVsdGlwYXJ0KCkpIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaXMgbm90IG11bHRpcGFydCcpO1xuXG4gICAgICAgIGlmICghdGhpcy5fbXVsdGlwYXJ0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICAvLyBTdGVwIDEuIFNwbGl0IG11bHRpcGFydCByZXNwb25zZVxuXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMudGV4dCgpO1xuXG4gICAgICAgICAgICBpZiAoIXRleHQpIHRocm93IG5ldyBFcnJvcignTm8gcmVzcG9uc2UgYm9keScpO1xuXG4gICAgICAgICAgICB2YXIgYm91bmRhcnkgPSB0aGlzLl9nZXRDb250ZW50VHlwZSgpLm1hdGNoKC9ib3VuZGFyeT0oW147XSspL2kpWzFdO1xuXG4gICAgICAgICAgICBpZiAoIWJvdW5kYXJ5KSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGJvdW5kYXJ5Jyk7XG5cbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHRleHQudG9TdHJpbmcoKS5zcGxpdChBcGlSZXNwb25zZS5fYm91bmRhcnlTZXBhcmF0b3IgKyBib3VuZGFyeSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0c1swXS50cmltKCkgPT09ICcnKSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRyaW0oKSA9PSBBcGlSZXNwb25zZS5fYm91bmRhcnlTZXBhcmF0b3IpIHBhcnRzLnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IEVycm9yKCdObyBwYXJ0cyBpbiBib2R5Jyk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgMi4gUGFyc2Ugc3RhdHVzIGluZm9cblxuICAgICAgICAgICAgdmFyIHN0YXR1c0luZm8gPSBBcGlSZXNwb25zZS5jcmVhdGUocGFydHMuc2hpZnQoKSwgdGhpcy5fcmVzcG9uc2Uuc3RhdHVzLCB0aGlzLl9yZXNwb25zZS5zdGF0dXNUZXh0KS5qc29uKCk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgMy4gUGFyc2UgYWxsIG90aGVyIHBhcnRzXG5cbiAgICAgICAgICAgIHRoaXMuX211bHRpcGFydCA9IHBhcnRzLm1hcChmdW5jdGlvbiAocGFydCwgaSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHN0YXR1c0luZm8ucmVzcG9uc2VbaV0uc3RhdHVzO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFwaVJlc3BvbnNlLmNyZWF0ZShwYXJ0LCBzdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbXVsdGlwYXJ0O1xuICAgIH07XG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuX2lzQ29udGVudFR5cGUgPSBmdW5jdGlvbiBfaXNDb250ZW50VHlwZShjb250ZW50VHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29udGVudFR5cGUoKS5pbmRleE9mKGNvbnRlbnRUeXBlKSA+IC0xO1xuICAgIH07XG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuX2dldENvbnRlbnRUeXBlID0gZnVuY3Rpb24gX2dldENvbnRlbnRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2UuaGVhZGVycy5nZXQoQXBpUmVzcG9uc2UuX2NvbnRlbnRUeXBlKSB8fCAnJztcbiAgICB9O1xuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pc011bHRpcGFydCA9IGZ1bmN0aW9uIF9pc011bHRpcGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ29udGVudFR5cGUoQXBpUmVzcG9uc2UuX211bHRpcGFydENvbnRlbnRUeXBlKTtcbiAgICB9O1xuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pc1VybEVuY29kZWQgPSBmdW5jdGlvbiBfaXNVcmxFbmNvZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDb250ZW50VHlwZShBcGlSZXNwb25zZS5fdXJsZW5jb2RlZENvbnRlbnRUeXBlKTtcbiAgICB9O1xuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pc0pzb24gPSBmdW5jdGlvbiBfaXNKc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDb250ZW50VHlwZShBcGlSZXNwb25zZS5fanNvbkNvbnRlbnRUeXBlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGlzIHVzZWQgdG8gY3JlYXRlIEFwaVJlc3BvbnNlIG9iamVjdCBmcm9tIHN0cmluZyBwYXJ0cyBvZiBtdWx0aXBhcnQvbWl4ZWQgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGF0dXNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0dXNUZXh0XVxuICAgICAqIEByZXR1cm4ge0FwaVJlc3BvbnNlfVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUodGV4dCwgc3RhdHVzLCBzdGF0dXNUZXh0KSB7XG5cbiAgICAgICAgdGV4dCA9IHRleHQgfHwgJyc7XG4gICAgICAgIHN0YXR1cyA9IHN0YXR1cyB8fCAyMDA7XG4gICAgICAgIHN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8ICdPSyc7XG5cbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyL2csICcnKTtcblxuICAgICAgICB2YXIgaGVhZGVycyA9IG5ldyBfRXh0ZXJuYWxzLkhlYWRlcnMoKSxcbiAgICAgICAgICAgIGhlYWRlcnNBbmRCb2R5ID0gdGV4dC5zcGxpdChBcGlSZXNwb25zZS5fYm9keVNlcGFyYXRvciksXG4gICAgICAgICAgICBoZWFkZXJzVGV4dCA9IGhlYWRlcnNBbmRCb2R5Lmxlbmd0aCA+IDEgPyBoZWFkZXJzQW5kQm9keS5zaGlmdCgpIDogJyc7XG5cbiAgICAgICAgdGV4dCA9IGhlYWRlcnNBbmRCb2R5Lmxlbmd0aCA+IDAgPyBoZWFkZXJzQW5kQm9keS5qb2luKEFwaVJlc3BvbnNlLl9ib2R5U2VwYXJhdG9yKSA6IG51bGw7XG5cbiAgICAgICAgKGhlYWRlcnNUZXh0IHx8ICcnKS5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG5cbiAgICAgICAgICAgIHZhciBzcGxpdCA9IGhlYWRlci50cmltKCkuc3BsaXQoQXBpUmVzcG9uc2UuX2hlYWRlclNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAga2V5ID0gc3BsaXQuc2hpZnQoKS50cmltKCksXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzcGxpdC5qb2luKEFwaVJlc3BvbnNlLl9oZWFkZXJTZXBhcmF0b3IpLnRyaW0oKTtcblxuICAgICAgICAgICAgaWYgKGtleSkgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgQXBpUmVzcG9uc2UobnVsbCwgbmV3IF9FeHRlcm5hbHMuUmVzcG9uc2UodGV4dCA/IHRleHQgOiB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHN0YXR1c1RleHRcbiAgICAgICAgfSksIHRleHQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXBpUmVzcG9uc2U7XG59KCk7XG5cbkFwaVJlc3BvbnNlLl9jb250ZW50VHlwZSA9ICdDb250ZW50LVR5cGUnO1xuQXBpUmVzcG9uc2UuX2pzb25Db250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbkFwaVJlc3BvbnNlLl9tdWx0aXBhcnRDb250ZW50VHlwZSA9ICdtdWx0aXBhcnQvbWl4ZWQnO1xuQXBpUmVzcG9uc2UuX3VybGVuY29kZWRDb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuQXBpUmVzcG9uc2UuX2hlYWRlclNlcGFyYXRvciA9ICc6JztcbkFwaVJlc3BvbnNlLl9ib2R5U2VwYXJhdG9yID0gJ1xcblxcbic7XG5BcGlSZXNwb25zZS5fYm91bmRhcnlTZXBhcmF0b3IgPSAnLS0nO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBpUmVzcG9uc2U7XG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9SZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX1JlZ2lzdHJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZ2lzdHJ5KTtcblxudmFyIF9DbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9DbGllbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2xpZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDbGllbnQgPSBmdW5jdGlvbiAoX0h0dHBDbGllbnQpIHtcbiAgICBfaW5oZXJpdHMoQ2xpZW50LCBfSHR0cENsaWVudCk7XG5cbiAgICBmdW5jdGlvbiBDbGllbnQoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGllbnQpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9IdHRwQ2xpZW50LmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLl9yZWdpc3RyeSA9IG5ldyBfUmVnaXN0cnkyLmRlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIENsaWVudC5wcm90b3R5cGUucmVnaXN0cnkgPSBmdW5jdGlvbiByZWdpc3RyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5O1xuICAgIH07XG5cbiAgICBDbGllbnQucHJvdG90eXBlLl9sb2FkUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgbW9jaztcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2NrID0gdGhpcy5fcmVnaXN0cnkuZmluZChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9jay5nZXRSZXNwb25zZShyZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9sb2FkUmVzcG9uc2UoX3gpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xvYWRSZXNwb25zZTtcbiAgICB9KCk7XG5cbiAgICByZXR1cm4gQ2xpZW50O1xufShfQ2xpZW50Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2xpZW50O1xuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfTW9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgX01vY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9jayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBSZWdpc3RyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWdpc3RyeSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZ2lzdHJ5KTtcblxuICAgICAgICB0aGlzLl9tb2NrcyA9IFtdO1xuICAgIH1cblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobW9jaykge1xuICAgICAgICB0aGlzLl9tb2Nrcy5wdXNoKG1vY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX21vY2tzID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQocmVxdWVzdCkge1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ1JlZ2lzdHJ5IGlzIGxvb2tpbmcgZm9yJywgcmVxdWVzdCk7XG5cbiAgICAgICAgdmFyIG1vY2sgPSB0aGlzLl9tb2Nrcy5zaGlmdCgpO1xuXG4gICAgICAgIGlmICghbW9jaykgdGhyb3cgbmV3IEVycm9yKCdObyBtb2NrIGluIHJlZ2lzdHJ5IGZvciByZXF1ZXN0ICcgKyByZXF1ZXN0Lm1ldGhvZCArICcgJyArIHJlcXVlc3QudXJsKTtcblxuICAgICAgICBpZiAoIW1vY2sudGVzdChyZXF1ZXN0KSkgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyByZXF1ZXN0ICcgKyByZXF1ZXN0Lm1ldGhvZCArICcgJyArIHJlcXVlc3QudXJsICsgJyBmb3IgZXhwZWN0ZWQgbW9jayAnICsgbW9jay5tZXRob2QoKSArICcgJyArIG1vY2sucGF0aCgpKTtcblxuICAgICAgICByZXR1cm4gbW9jaztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLmFwaUNhbGwgPSBmdW5jdGlvbiBhcGlDYWxsKG1ldGhvZCwgcGF0aCwgcmVzcG9uc2UsIHN0YXR1cywgc3RhdHVzVGV4dCwgZGVsYXkpIHtcblxuICAgICAgICB0aGlzLmFkZChuZXcgX01vY2syLmRlZmF1bHQobWV0aG9kLCBwYXRoLCByZXNwb25zZSwgc3RhdHVzLCBzdGF0dXNUZXh0LCBkZWxheSkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuYXV0aGVudGljYXRpb24gPSBmdW5jdGlvbiBhdXRoZW50aWNhdGlvbigpIHtcblxuICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvb2F1dGgvdG9rZW4nLCB7XG4gICAgICAgICAgICAnYWNjZXNzX3Rva2VuJzogJ0FDQ0VTU19UT0tFTicsXG4gICAgICAgICAgICAndG9rZW5fdHlwZSc6ICdiZWFyZXInLFxuICAgICAgICAgICAgJ2V4cGlyZXNfaW4nOiAzNjAwLFxuICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW4nOiAnUkVGUkVTSF9UT0tFTicsXG4gICAgICAgICAgICAncmVmcmVzaF90b2tlbl9leHBpcmVzX2luJzogNjA0ODAsXG4gICAgICAgICAgICAnc2NvcGUnOiAnU01TIFJDTSBGb28gQm9vJyxcbiAgICAgICAgICAgICdleHBpcmVUaW1lJzogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyAzNjAwMDAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24gbG9nb3V0KCkge1xuXG4gICAgICAgIHRoaXMuYXBpQ2FsbCgnUE9TVCcsICcvcmVzdGFwaS9vYXV0aC9yZXZva2UnLCB7fSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5wcmVzZW5jZUxvYWQgPSBmdW5jdGlvbiBwcmVzZW5jZUxvYWQoaWQpIHtcblxuICAgICAgICB0aGlzLmFwaUNhbGwoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vJyArIGlkICsgJy9wcmVzZW5jZScsIHtcbiAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cHM6Ly9wbGF0Zm9ybS5yaW5nY2VudHJhbC5jb20vcmVzdGFwaS92MS4wL2FjY291bnQvMTIzL2V4dGVuc2lvbi9cIiArIGlkICsgXCIvcHJlc2VuY2VcIixcbiAgICAgICAgICAgIFwiZXh0ZW5zaW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHBzOi8vcGxhdGZvcm0ucmluZ2NlbnRyYWwuY29tL3Jlc3RhcGkvdjEuMC9hY2NvdW50LzEyMy9leHRlbnNpb24vXCIgKyBpZCxcbiAgICAgICAgICAgICAgICBcImlkXCI6IGlkLFxuICAgICAgICAgICAgICAgIFwiZXh0ZW5zaW9uTnVtYmVyXCI6IFwiMTAxXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFjdGl2ZUNhbGxzXCI6IFtdLFxuICAgICAgICAgICAgXCJwcmVzZW5jZVN0YXR1c1wiOiBcIkF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgXCJ0ZWxlcGhvbnlTdGF0dXNcIjogXCJSaW5naW5nXCIsXG4gICAgICAgICAgICBcInVzZXJTdGF0dXNcIjogXCJBdmFpbGFibGVcIixcbiAgICAgICAgICAgIFwiZG5kU3RhdHVzXCI6IFwiVGFrZUFsbENhbGxzXCIsXG4gICAgICAgICAgICBcImV4dGVuc2lvbklkXCI6IGlkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuc3Vic2NyaWJlR2VuZXJpYyA9IGZ1bmN0aW9uIHN1YnNjcmliZUdlbmVyaWMoZXhwaXJlc0luKSB7XG5cbiAgICAgICAgZXhwaXJlc0luID0gZXhwaXJlc0luIHx8IDE1ICogNjAgKiA2MDtcblxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgdGhpcy5hcGlDYWxsKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uJywge1xuICAgICAgICAgICAgJ2V2ZW50RmlsdGVycyc6IFsnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UnXSxcbiAgICAgICAgICAgICdleHBpcmF0aW9uVGltZSc6IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgZXhwaXJlc0luICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICdleHBpcmVzSW4nOiBleHBpcmVzSW4sXG4gICAgICAgICAgICAnZGVsaXZlcnlNb2RlJzoge1xuICAgICAgICAgICAgICAgICd0cmFuc3BvcnRUeXBlJzogJ1B1Yk51YicsXG4gICAgICAgICAgICAgICAgJ2VuY3J5cHRpb24nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnYWRkcmVzcyc6ICcxMjNfZm9vJyxcbiAgICAgICAgICAgICAgICAnc3Vic2NyaWJlcktleSc6ICdzdWItYy1mb28nLFxuICAgICAgICAgICAgICAgICdzZWNyZXRLZXknOiAnc2VjLWMtYmFyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpZCc6ICdmb28tYmFyLWJheicsXG4gICAgICAgICAgICAnY3JlYXRpb25UaW1lJzogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdBY3RpdmUnLFxuICAgICAgICAgICAgJ3VyaSc6ICdodHRwczovL3BsYXRmb3JtLnJpbmdjZW50cmFsLmNvbS9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uL2Zvby1iYXItYmF6J1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLnN1YnNjcmliZU9uUHJlc2VuY2UgPSBmdW5jdGlvbiBzdWJzY3JpYmVPblByZXNlbmNlKGlkLCBkZXRhaWxlZCkge1xuXG4gICAgICAgIGlkID0gaWQgfHwgJzEnO1xuXG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAnZXZlbnRGaWx0ZXJzJzogWycvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vJyArIGlkICsgJy9wcmVzZW5jZScgKyAoZGV0YWlsZWQgPyAnP2RldGFpbGVkVGVsZXBob255U3RhdGU9dHJ1ZScgOiAnJyldLFxuICAgICAgICAgICAgJ2V4cGlyYXRpb25UaW1lJzogbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgKyAxNSAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgJ2RlbGl2ZXJ5TW9kZSc6IHtcbiAgICAgICAgICAgICAgICAndHJhbnNwb3J0VHlwZSc6ICdQdWJOdWInLFxuICAgICAgICAgICAgICAgICdlbmNyeXB0aW9uJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnYWRkcmVzcyc6ICcxMjNfZm9vJyxcbiAgICAgICAgICAgICAgICAnc3Vic2NyaWJlcktleSc6ICdzdWItYy1mb28nLFxuICAgICAgICAgICAgICAgICdzZWNyZXRLZXknOiAnc2VjLWMtYmFyJyxcbiAgICAgICAgICAgICAgICAnZW5jcnlwdGlvbkFsZ29yaXRobSc6ICdBRVMnLFxuICAgICAgICAgICAgICAgICdlbmNyeXB0aW9uS2V5JzogJ1ZRd2I2RVZOY1FQQmhFL0pnRloyenc9PSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY3JlYXRpb25UaW1lJzogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgJ2lkJzogJ2Zvby1iYXItYmF6JyxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnQWN0aXZlJyxcbiAgICAgICAgICAgICd1cmknOiAnaHR0cHM6Ly9wbGF0Zm9ybS5yaW5nY2VudHJhbC5jb20vcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbi9mb28tYmFyLWJheidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS50b2tlblJlZnJlc2ggPSBmdW5jdGlvbiB0b2tlblJlZnJlc2goZmFpbHVyZSkge1xuXG4gICAgICAgIGlmICghZmFpbHVyZSkge1xuXG4gICAgICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvb2F1dGgvdG9rZW4nLCB7XG4gICAgICAgICAgICAgICAgJ2FjY2Vzc190b2tlbic6ICdBQ0NFU1NfVE9LRU5fRlJPTV9SRUZSRVNIJyxcbiAgICAgICAgICAgICAgICAndG9rZW5fdHlwZSc6ICdiZWFyZXInLFxuICAgICAgICAgICAgICAgICdleHBpcmVzX2luJzogMzYwMCxcbiAgICAgICAgICAgICAgICAncmVmcmVzaF90b2tlbic6ICdSRUZSRVNIX1RPS0VOX0ZST01fUkVGUkVTSCcsXG4gICAgICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW5fZXhwaXJlc19pbic6IDYwNDgwLFxuICAgICAgICAgICAgICAgICdzY29wZSc6ICdTTVMgUkNNIEZvbyBCb28nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5hcGlDYWxsKCdQT1NUJywgJy9yZXN0YXBpL29hdXRoL3Rva2VuJywge1xuICAgICAgICAgICAgICAgICdtZXNzYWdlJzogJ1dyb25nIHRva2VuJyxcbiAgICAgICAgICAgICAgICAnZXJyb3JfZGVzY3JpcHRpb24nOiAnV3JvbmcgdG9rZW4nLFxuICAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbic6ICdXcm9uZyB0b2tlbidcbiAgICAgICAgICAgIH0sIDQwMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlZ2lzdHJ5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZWdpc3RyeTtcblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfQXBpUmVzcG9uc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9BcGlSZXNwb25zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BcGlSZXNwb25zZSk7XG5cbnZhciBfVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBfRXh0ZXJuYWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBfRXh0ZXJuYWxzLlByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTW9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2NrKG1ldGhvZCwgcGF0aCwganNvbiwgc3RhdHVzLCBzdGF0dXNUZXh0LCBkZWxheSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9jayk7XG5cbiAgICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLl9qc29uID0ganNvbiB8fCB7fTtcbiAgICAgICAgdGhpcy5fZGVsYXkgPSBkZWxheSB8fCAxMDtcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gc3RhdHVzIHx8IDIwMDtcbiAgICAgICAgdGhpcy5fc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgJ09LJztcbiAgICB9XG5cbiAgICBNb2NrLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgfTtcblxuICAgIE1vY2sucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uIG1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZDtcbiAgICB9O1xuXG4gICAgTW9jay5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIHRlc3QocmVxdWVzdCkge1xuXG4gICAgICAgIHJldHVybiByZXF1ZXN0LnVybC5pbmRleE9mKHRoaXMuX3BhdGgpID4gLTEgJiYgcmVxdWVzdC5tZXRob2QudG9VcHBlckNhc2UoKSA9PSB0aGlzLl9tZXRob2Q7XG4gICAgfTtcblxuICAgIE1vY2sucHJvdG90eXBlLmdldFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX1V0aWxzLmRlbGF5KSh0aGlzLl9kZWxheSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCB0aGlzLmNyZWF0ZVJlc3BvbnNlKHRoaXMuX2pzb24pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRSZXNwb25zZShfeCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRSZXNwb25zZTtcbiAgICB9KCk7XG5cbiAgICBNb2NrLnByb3RvdHlwZS5jcmVhdGVSZXNwb25zZSA9IGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlKGpzb24sIGluaXQpIHtcblxuICAgICAgICBpbml0ID0gaW5pdCB8fCB7fTtcblxuICAgICAgICBpbml0LnN0YXR1cyA9IGluaXQuc3RhdHVzIHx8IHRoaXMuX3N0YXR1cztcbiAgICAgICAgaW5pdC5zdGF0dXNUZXh0ID0gaW5pdC5zdGF0dXNUZXh0IHx8IHRoaXMuX3N0YXR1c1RleHQ7XG5cbiAgICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KGpzb24pLFxuICAgICAgICAgICAgcmVzID0gbmV3IF9FeHRlcm5hbHMuUmVzcG9uc2Uoc3RyLCBpbml0KTtcblxuICAgICAgICByZXMuaGVhZGVycy5zZXQoX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9jb250ZW50VHlwZSwgX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9qc29uQ29udGVudFR5cGUpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHJldHVybiBNb2NrO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNb2NrO1xuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfQXV0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX0F1dGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXV0aCk7XG5cbnZhciBfVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBfRXh0ZXJuYWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBfRXh0ZXJuYWxzLlByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBQbGF0Zm9ybSA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKFBsYXRmb3JtLCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIGZ1bmN0aW9uIFBsYXRmb3JtKGNsaWVudCwgY2FjaGUsIHNlcnZlciwgYXBwS2V5LCBhcHBTZWNyZXQsIGFwcE5hbWUsIGFwcFZlcnNpb24sIHNka1ZlcnNpb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXRmb3JtKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIGJlZm9yZUxvZ2luOiAnYmVmb3JlTG9naW4nLFxuICAgICAgICAgICAgbG9naW5TdWNjZXNzOiAnbG9naW5TdWNjZXNzJyxcbiAgICAgICAgICAgIGxvZ2luRXJyb3I6ICdsb2dpbkVycm9yJyxcbiAgICAgICAgICAgIGJlZm9yZVJlZnJlc2g6ICdiZWZvcmVSZWZyZXNoJyxcbiAgICAgICAgICAgIHJlZnJlc2hTdWNjZXNzOiAncmVmcmVzaFN1Y2Nlc3MnLFxuICAgICAgICAgICAgcmVmcmVzaEVycm9yOiAncmVmcmVzaEVycm9yJyxcbiAgICAgICAgICAgIGJlZm9yZUxvZ291dDogJ2JlZm9yZUxvZ291dCcsXG4gICAgICAgICAgICBsb2dvdXRTdWNjZXNzOiAnbG9nb3V0U3VjY2VzcycsXG4gICAgICAgICAgICBsb2dvdXRFcnJvcjogJ2xvZ291dEVycm9yJ1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgX3RoaXMuX3NlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgX3RoaXMuX2FwcEtleSA9IGFwcEtleTtcbiAgICAgICAgX3RoaXMuX2FwcFNlY3JldCA9IGFwcFNlY3JldDtcblxuICAgICAgICAvKiogQHR5cGUge0NhY2hlfSAqL1xuICAgICAgICBfdGhpcy5fY2FjaGUgPSBjYWNoZTtcblxuICAgICAgICAvKiogQHR5cGUge0NsaWVudH0gKi9cbiAgICAgICAgX3RoaXMuX2NsaWVudCA9IGNsaWVudDtcblxuICAgICAgICAvKiogQHR5cGUge1Byb21pc2U8QXBpUmVzcG9uc2U+fSAqL1xuICAgICAgICBfdGhpcy5fcmVmcmVzaFByb21pc2UgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLl9hdXRoID0gbmV3IF9BdXRoMi5kZWZhdWx0KF90aGlzLl9jYWNoZSwgUGxhdGZvcm0uX2NhY2hlSWQpO1xuXG4gICAgICAgIF90aGlzLl91c2VyQWdlbnQgPSAoYXBwTmFtZSA/IGFwcE5hbWUgKyAoYXBwVmVyc2lvbiA/ICcvJyArIGFwcFZlcnNpb24gOiAnJykgKyAnICcgOiAnJykgKyAnUkNKU1NESy8nICsgc2RrVmVyc2lvbjtcblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXV0aH1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbiBhdXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0aDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Q2xpZW50fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuY2xpZW50ID0gZnVuY3Rpb24gY2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFkZFNlcnZlcl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWRkTWV0aG9kXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWRkVG9rZW5dXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuY3JlYXRlVXJsID0gZnVuY3Rpb24gY3JlYXRlVXJsKHBhdGgsIG9wdGlvbnMpIHtcblxuICAgICAgICBwYXRoID0gcGF0aCB8fCAnJztcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGJ1aWx0VXJsID0gJycsXG4gICAgICAgICAgICBoYXNIdHRwID0gcGF0aC5pbmRleE9mKCdodHRwOi8vJykgIT0gLTEgfHwgcGF0aC5pbmRleE9mKCdodHRwczovLycpICE9IC0xO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFkZFNlcnZlciAmJiAhaGFzSHR0cCkgYnVpbHRVcmwgKz0gdGhpcy5fc2VydmVyO1xuXG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoUGxhdGZvcm0uX3VybFByZWZpeCkgPT0gLTEgJiYgIWhhc0h0dHApIGJ1aWx0VXJsICs9IFBsYXRmb3JtLl91cmxQcmVmaXggKyAnLycgKyBQbGF0Zm9ybS5fYXBpVmVyc2lvbjtcblxuICAgICAgICBidWlsdFVybCArPSBwYXRoO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFkZE1ldGhvZCB8fCBvcHRpb25zLmFkZFRva2VuKSBidWlsdFVybCArPSBwYXRoLmluZGV4T2YoJz8nKSA+IC0xID8gJyYnIDogJz8nO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFkZE1ldGhvZCkgYnVpbHRVcmwgKz0gJ19tZXRob2Q9JyArIG9wdGlvbnMuYWRkTWV0aG9kO1xuICAgICAgICBpZiAob3B0aW9ucy5hZGRUb2tlbikgYnVpbHRVcmwgKz0gKG9wdGlvbnMuYWRkTWV0aG9kID8gJyYnIDogJycpICsgJ2FjY2Vzc190b2tlbj0nICsgdGhpcy5fYXV0aC5hY2Nlc3NUb2tlbigpO1xuXG4gICAgICAgIHJldHVybiBidWlsdFVybDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucmVkaXJlY3RVcmlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zdGF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJyYW5kSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5kaXNwbGF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucHJvbXB0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmxvZ2luVXJsID0gZnVuY3Rpb24gbG9naW5Vcmwob3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVVybChQbGF0Zm9ybS5fYXV0aG9yaXplRW5kcG9pbnQgKyAnPycgKyAoMCwgX1V0aWxzLnF1ZXJ5U3RyaW5naWZ5KSh7XG4gICAgICAgICAgICAncmVzcG9uc2VfdHlwZSc6ICdjb2RlJyxcbiAgICAgICAgICAgICdyZWRpcmVjdF91cmknOiBvcHRpb25zLnJlZGlyZWN0VXJpIHx8ICcnLFxuICAgICAgICAgICAgJ2NsaWVudF9pZCc6IHRoaXMuX2FwcEtleSxcbiAgICAgICAgICAgICdzdGF0ZSc6IG9wdGlvbnMuc3RhdGUgfHwgJycsXG4gICAgICAgICAgICAnYnJhbmRfaWQnOiBvcHRpb25zLmJyYW5kSWQgfHwgJycsXG4gICAgICAgICAgICAnZGlzcGxheSc6IG9wdGlvbnMuZGlzcGxheSB8fCAnJyxcbiAgICAgICAgICAgICdwcm9tcHQnOiBvcHRpb25zLnByb21wdCB8fCAnJ1xuICAgICAgICB9KSwgeyBhZGRTZXJ2ZXI6IHRydWUgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5wYXJzZUxvZ2luUmVkaXJlY3RVcmwgPSBmdW5jdGlvbiBwYXJzZUxvZ2luUmVkaXJlY3RVcmwodXJsKSB7XG5cbiAgICAgICAgdmFyIHFzID0gKDAsIF9VdGlscy5wYXJzZVF1ZXJ5U3RyaW5nKSh1cmwuc3BsaXQoJz8nKS5yZXZlcnNlKClbMF0pLFxuICAgICAgICAgICAgZXJyb3IgPSBxcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCBxcy5lcnJvcjtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGUuZXJyb3IgPSBxcy5lcnJvcjtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBoYW5kbGUgMy1sZWdnZWQgT0F1dGhcbiAgICAgKlxuICAgICAqIEF0dGVudGlvbiEgVGhpcyBpcyBhbiBleHBlcmltZW50YWwgbWV0aG9kIGFuZCBpdCdzIHNpZ25hdHVyZSBhbmQgYmVoYXZpb3IgbWF5IGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubG9naW5dIGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9naW4oKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vcmlnaW5dXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb3BlcnR5XSBuYW1lIG9mIHdpbmRvdy5wb3N0TWVzc2FnZSdzIGV2ZW50IGRhdGEgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGFyZ2V0XSB0YXJnZXQgZm9yIHdpbmRvdy5vcGVuKClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmxcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUubG9naW5XaW5kb3cgPSBmdW5jdGlvbiBsb2dpbldpbmRvdyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgX0V4dGVybmFscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgaWYgKCEoMCwgX1V0aWxzLmlzQnJvd3NlcikoKSkgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBvbmx5IGluIGJyb3dzZXInKTtcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVybCkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIG1hbmRhdG9yeSBVUkwgcGFyYW1ldGVyJyk7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLnVybCB8fCA0MDA7XG4gICAgICAgICAgICBvcHRpb25zLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCA0MDA7XG4gICAgICAgICAgICBvcHRpb25zLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IDYwMDtcbiAgICAgICAgICAgIG9wdGlvbnMub3JpZ2luID0gb3B0aW9ucy5vcmlnaW4gfHwgd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgICAgIG9wdGlvbnMucHJvcGVydHkgPSBvcHRpb25zLnByb3BlcnR5IHx8ICdSQ0F1dGhvcml6YXRpb25Db2RlJztcbiAgICAgICAgICAgIG9wdGlvbnMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgJ19ibGFuayc7XG5cbiAgICAgICAgICAgIHZhciBkdWFsU2NyZWVuTGVmdCA9IHdpbmRvdy5zY3JlZW5MZWZ0ICE9IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5MZWZ0IDogc2NyZWVuLmxlZnQ7XG4gICAgICAgICAgICB2YXIgZHVhbFNjcmVlblRvcCA9IHdpbmRvdy5zY3JlZW5Ub3AgIT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlblRvcCA6IHNjcmVlbi50b3A7XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoID8gd2luZG93LmlubmVyV2lkdGggOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggOiBzY3JlZW4ud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ID8gd2luZG93LmlubmVySGVpZ2h0IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiBzY3JlZW4uaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHdpZHRoIC8gMiAtIG9wdGlvbnMud2lkdGggLyAyICsgZHVhbFNjcmVlbkxlZnQ7XG4gICAgICAgICAgICB2YXIgdG9wID0gaGVpZ2h0IC8gMiAtIG9wdGlvbnMuaGVpZ2h0IC8gMiArIGR1YWxTY3JlZW5Ub3A7XG4gICAgICAgICAgICB2YXIgd2luID0gd2luZG93Lm9wZW4ob3B0aW9ucy51cmwsICdfYmxhbmsnLCBvcHRpb25zLnRhcmdldCA9PSAnX2JsYW5rJyA/ICdzY3JvbGxiYXJzPXllcywgc3RhdHVzPXllcywgd2lkdGg9JyArIG9wdGlvbnMud2lkdGggKyAnLCBoZWlnaHQ9JyArIG9wdGlvbnMuaGVpZ2h0ICsgJywgbGVmdD0nICsgbGVmdCArICcsIHRvcD0nICsgdG9wIDogJycpO1xuXG4gICAgICAgICAgICBpZiAod2luZG93LmZvY3VzKSB3aW4uZm9jdXMoKTtcblxuICAgICAgICAgICAgdmFyIGV2ZW50TWV0aG9kID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAnYXR0YWNoRXZlbnQnO1xuICAgICAgICAgICAgdmFyIGV2ZW50UmVtb3ZlTWV0aG9kID0gZXZlbnRNZXRob2QgPT0gJ2FkZEV2ZW50TGlzdGVuZXInID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2RldGFjaEV2ZW50JztcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRXZlbnQgPSBldmVudE1ldGhvZCA9PSAnYWRkRXZlbnRMaXN0ZW5lcicgPyAnbWVzc2FnZScgOiAnb25tZXNzYWdlJztcblxuICAgICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBldmVudExpc3RlbmVyKGUpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiAhPSBvcHRpb25zLm9yaWdpbikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghZS5kYXRhIHx8ICFlLmRhdGFbb3B0aW9ucy5wcm9wZXJ0eV0pIHJldHVybjsgLy8ga2VlcCB3YWl0aW5nXG5cbiAgICAgICAgICAgICAgICB3aW4uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB3aW5kb3dbZXZlbnRSZW1vdmVNZXRob2RdKG1lc3NhZ2VFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2dpbk9wdGlvbnMgPSBfdGhpczIucGFyc2VMb2dpblJlZGlyZWN0VXJsKGUuZGF0YVtvcHRpb25zLnByb3BlcnR5XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2dpbk9wdGlvbnMuY29kZSkgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRob3JpemF0aW9uIGNvZGUnKTtcblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGxvZ2luT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2luZG93W2V2ZW50TWV0aG9kXShtZXNzYWdlRXZlbnQsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5sb2dnZWRJbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUxvZ2dlZEluKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwgNl1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvZ2dlZEluKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2dnZWRJbjtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51c2VybmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZXh0ZW5zaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY29kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlZGlyZWN0VXJpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZW5kcG9pbnRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlbWVtYmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYWNjZXNzVG9rZW5UdGxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZWZyZXNoVG9rZW5UdGxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGJvZHksIGFwaVJlc3BvbnNlLCBqc29uO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmJlZm9yZUxvZ2luKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSB7fTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNvZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LmdyYW50X3R5cGUgPSAncGFzc3dvcmQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LnVzZXJuYW1lID0gb3B0aW9ucy51c2VybmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5wYXNzd29yZCA9IG9wdGlvbnMucGFzc3dvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuZXh0ZW5zaW9uID0gb3B0aW9ucy5leHRlbnNpb24gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmNvZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LmdyYW50X3R5cGUgPSAnYXV0aG9yaXphdGlvbl9jb2RlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5jb2RlID0gb3B0aW9ucy5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LnJlZGlyZWN0X3VyaSA9IG9wdGlvbnMucmVkaXJlY3RVcmk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYm9keS5jbGllbnRfaWQgPSB0aGlzLmdldENyZWRlbnRpYWxzKCkua2V5OyAvLyBub3QgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5kcG9pbnRJZCkgYm9keS5lbmRwb2ludF9pZCA9IG9wdGlvbnMuZW5kcG9pbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hY2Nlc3NUb2tlblR0bCkgYm9keS5hY2Nlc3NUb2tlblR0bCA9IG9wdGlvbnMuYWNjZXNzVG9rZW5UdGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVmcmVzaFRva2VuVHRsKSBib2R5LnJlZnJlc2hUb2tlblR0bCA9IG9wdGlvbnMucmVmcmVzaFRva2VuVHRsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5SZXF1ZXN0KFBsYXRmb3JtLl90b2tlbkVuZHBvaW50LCBib2R5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSBhcGlSZXNwb25zZS5qc29uKCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGguc2V0RGF0YShqc29uKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5sb2dpblN1Y2Nlc3MsIGFwaVJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGFwaVJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmxvZ2luRXJyb3IsIF9jb250ZXh0Mi50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDIudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCAxN11dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvZ2luKF94KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2dpbjtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLl9yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgICAgIHZhciByZXMsIGpzb247XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmJlZm9yZVJlZnJlc2gpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX1V0aWxzLmRlbGF5KShQbGF0Zm9ybS5fcmVmcmVzaERlbGF5TXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F1dGgucmVmcmVzaFRva2VuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZnJlc2ggdG9rZW4gaXMgbWlzc2luZycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F1dGgucmVmcmVzaFRva2VuVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmcmVzaCB0b2tlbiBoYXMgZXhwaXJlZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5SZXF1ZXN0KFBsYXRmb3JtLl90b2tlbkVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ3JhbnRfdHlwZVwiOiBcInJlZnJlc2hfdG9rZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWZyZXNoX3Rva2VuXCI6IHRoaXMuX2F1dGgucmVmcmVzaFRva2VuKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWNjZXNzX3Rva2VuX3R0bFwiOiB0aGlzLl9hdXRoLmRhdGEoKS5leHBpcmVzX2luICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWZyZXNoX3Rva2VuX3R0bFwiOiB0aGlzLl9hdXRoLmRhdGEoKS5yZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW4gKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IHJlcy5qc29uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY2xpZW50Lm1ha2VFcnJvcihuZXcgRXJyb3IoJ01hbGZvcm1lZCBPQXV0aCByZXNwb25zZScpLCByZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aC5zZXREYXRhKGpzb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLnJlZnJlc2hTdWNjZXNzLCByZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSB0aGlzLl9jbGllbnQubWFrZUVycm9yKF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoUGxhdGZvcm0uX2NsZWFyQ2FjaGVPblJlZnJlc2hFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5yZWZyZXNoRXJyb3IsIF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDMudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMywgdGhpcywgW1swLCAxOV1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9yZWZyZXNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3JlZnJlc2g7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JlZnJlc2hQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fcmVmcmVzaFByb21pc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAyO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoUHJvbWlzZSA9IHRoaXMuX3JlZnJlc2goKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzLl9yZWZyZXNoUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9yZWZyZXNoUHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMik7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDQudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1syLCA3XV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZnJlc2g7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjUgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmJlZm9yZUxvZ291dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuUmVxdWVzdChQbGF0Zm9ybS5fcmV2b2tlRW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMuX2F1dGguYWNjZXNzVG9rZW4oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ1LnNlbnQ7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNsZWFuKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMubG9nb3V0U3VjY2VzcywgcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHJlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgwKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmxvZ291dEVycm9yLCBfY29udGV4dDUudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ1LnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTUsIHRoaXMsIFtbMCwgMTBdXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2dvdXQ7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEF1dGhDaGVja11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlcXVlc3Q+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuaW5mbGF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmNiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5za2lwQXV0aENoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTG9nZ2VkSW4oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldCgnWC1Vc2VyLUFnZW50JywgdGhpcy5fdXNlckFnZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdDbGllbnQtSWQnLCB0aGlzLl9hcHBLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCB0aGlzLl9hdXRoSGVhZGVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVxdWVzdC51cmwgPSB0aGlzLmNyZWF0ZVVybChyZXF1ZXN0LnVybCwge2FkZFNlcnZlcjogdHJ1ZX0pOyAvL0ZJWE1FIFNwZWMgcHJldmVudHMgdGhpcy4uLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluZmxhdGVSZXF1ZXN0KF94MiwgX3gzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmZsYXRlUmVxdWVzdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmNyA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlUmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ny5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcudDAgPSBfY29udGV4dDdbXCJjYXRjaFwiXSgwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFfY29udGV4dDcudDAuYXBpUmVzcG9uc2UgfHwgIV9jb250ZXh0Ny50MC5hcGlSZXNwb25zZS5yZXNwb25zZSgpIHx8IF9jb250ZXh0Ny50MC5hcGlSZXNwb25zZS5yZXNwb25zZSgpLnN0YXR1cyAhPSA0MDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0Ny50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGguY2FuY2VsQWNjZXNzVG9rZW4oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ3LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMsIFtbMCwgOV1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KF94NCwgX3g1KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZW5kUmVxdWVzdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmFsIHB1cnBvc2UgZnVuY3Rpb24gdG8gc2VuZCBhbnl0aGluZyB0byBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuYm9keV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWV0aG9kXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5xdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjggPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9GSVhNRSBodHRwczovL2dpdGh1Yi5jb20vYml0aW5uL25vZGUtZmV0Y2gvaXNzdWVzLzQzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB0aGlzLmNyZWF0ZVVybChvcHRpb25zLnVybCwgeyBhZGRTZXJ2ZXI6IHRydWUgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QodGhpcy5fY2xpZW50LmNyZWF0ZVJlcXVlc3Qob3B0aW9ucyksIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ4LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlOCwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBzZW5kKF94Nikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWY4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VuZDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtxdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjkgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOSh1cmwsIHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ5LnByZXYgPSBfY29udGV4dDkubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ5LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXQoX3g4LCBfeDksIF94MTApIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmOS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3F1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjEwID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKHVybCwgYm9keSwgcXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDEwLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTEwLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHBvc3QoX3gxMSwgX3gxMiwgX3gxMywgX3gxNCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbYm9keV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3F1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMTEgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEodXJsLCBib2R5LCBxdWVyeSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnUFVUJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQxMS5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUxMSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBwdXQoX3gxNSwgX3gxNiwgX3gxNywgX3gxOCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB1dDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtxdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjEyID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEyKHVybCwgcXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTIkKF9jb250ZXh0MTIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDEyLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9kZWxldGUoX3gxOSwgX3gyMCwgX3gyMSkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9kZWxldGU7XG4gICAgfSgpO1xuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLl90b2tlblJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMTMgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMocGF0aCwgYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMyQoX2NvbnRleHQxMykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMy5wcmV2ID0gX2NvbnRleHQxMy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwQXV0aENoZWNrOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmFzaWMgJyArIHRoaXMuX2FwaUtleSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDEzLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTEzLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF90b2tlblJlcXVlc3QoX3gyMiwgX3gyMykge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90b2tlblJlcXVlc3Q7XG4gICAgfSgpO1xuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmVuc3VyZUxvZ2dlZEluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjE0ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNCQoX2NvbnRleHQxNCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNC5wcmV2ID0gX2NvbnRleHQxNC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0FjY2Vzc1Rva2VuVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDE0LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTE0LCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVuc3VyZUxvZ2dlZEluKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVuc3VyZUxvZ2dlZEluO1xuICAgIH0oKTtcblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5faXNBY2Nlc3NUb2tlblZhbGlkID0gZnVuY3Rpb24gX2lzQWNjZXNzVG9rZW5WYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGguYWNjZXNzVG9rZW5WYWxpZCgpO1xuICAgIH07XG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuX2FwaUtleSA9IGZ1bmN0aW9uIF9hcGlLZXkoKSB7XG4gICAgICAgIHZhciBhcGlLZXkgPSB0aGlzLl9hcHBLZXkgKyAnOicgKyB0aGlzLl9hcHBTZWNyZXQ7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYnRvYSA9PSAnZnVuY3Rpb24nID8gYnRvYShhcGlLZXkpIDogbmV3IEJ1ZmZlcihhcGlLZXkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9O1xuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLl9hdXRoSGVhZGVyID0gZnVuY3Rpb24gX2F1dGhIZWFkZXIoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX2F1dGguYWNjZXNzVG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGgudG9rZW5UeXBlKCkgKyAodG9rZW4gPyAnICcgKyB0b2tlbiA6ICcnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBsYXRmb3JtO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuUGxhdGZvcm0uX3VybFByZWZpeCA9ICcvcmVzdGFwaSc7XG5QbGF0Zm9ybS5fYXBpVmVyc2lvbiA9ICd2MS4wJztcblBsYXRmb3JtLl90b2tlbkVuZHBvaW50ID0gJy9yZXN0YXBpL29hdXRoL3Rva2VuJztcblBsYXRmb3JtLl9yZXZva2VFbmRwb2ludCA9ICcvcmVzdGFwaS9vYXV0aC9yZXZva2UnO1xuUGxhdGZvcm0uX2F1dGhvcml6ZUVuZHBvaW50ID0gJy9yZXN0YXBpL29hdXRoL2F1dGhvcml6ZSc7XG5QbGF0Zm9ybS5fcmVmcmVzaERlbGF5TXMgPSAxMDA7XG5QbGF0Zm9ybS5fY2FjaGVJZCA9ICdwbGF0Zm9ybSc7XG5QbGF0Zm9ybS5fY2xlYXJDYWNoZU9uUmVmcmVzaEVycm9yID0gZmFsc2U7XG5leHBvcnRzLmRlZmF1bHQgPSBQbGF0Zm9ybTtcblxuLyoqKi8gfSxcbi8qIDE2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQXV0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRoKGNhY2hlLCBjYWNoZUlkKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdXRoKTtcblxuICAgICAgICAvKiogQHR5cGUge0NhY2hlfSAqL1xuICAgICAgICB0aGlzLl9jYWNoZSA9IGNhY2hlO1xuICAgICAgICB0aGlzLl9jYWNoZUlkID0gY2FjaGVJZDtcbiAgICB9IC8vIDEgbWludXRlXG5cblxuICAgIEF1dGgucHJvdG90eXBlLmFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gYWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKS5hY2Nlc3NfdG9rZW47XG4gICAgfTtcblxuICAgIEF1dGgucHJvdG90eXBlLnJlZnJlc2hUb2tlbiA9IGZ1bmN0aW9uIHJlZnJlc2hUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpLnJlZnJlc2hfdG9rZW47XG4gICAgfTtcblxuICAgIEF1dGgucHJvdG90eXBlLnRva2VuVHlwZSA9IGZ1bmN0aW9uIHRva2VuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpLnRva2VuX3R5cGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3t0b2tlbl90eXBlOiBzdHJpbmcsIGFjY2Vzc190b2tlbjogc3RyaW5nLCBleHBpcmVzX2luOiBudW1iZXIsIHJlZnJlc2hfdG9rZW46IHN0cmluZywgcmVmcmVzaF90b2tlbl9leHBpcmVzX2luOiBudW1iZXJ9fVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gZGF0YSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZ2V0SXRlbSh0aGlzLl9jYWNoZUlkKSB8fCB7XG4gICAgICAgICAgICB0b2tlbl90eXBlOiAnJyxcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogJycsXG4gICAgICAgICAgICBleHBpcmVzX2luOiAwLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogJycsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW46IDBcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld0RhdGFcbiAgICAgKiBAcmV0dXJuIHtBdXRofVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShuZXdEYXRhKSB7XG5cbiAgICAgICAgbmV3RGF0YSA9IG5ld0RhdGEgfHwge307XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEoKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhuZXdEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IG5ld0RhdGFba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGF0YS5leHBpcmVfdGltZSA9IERhdGUubm93KCkgKyBkYXRhLmV4cGlyZXNfaW4gKiAxMDAwO1xuICAgICAgICBkYXRhLnJlZnJlc2hfdG9rZW5fZXhwaXJlX3RpbWUgPSBEYXRlLm5vdygpICsgZGF0YS5yZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW4gKiAxMDAwO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlLnNldEl0ZW0odGhpcy5fY2FjaGVJZCwgZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGEgdmFsaWQgKG5vdCBleHBpcmVkKSBhY2Nlc3MgdG9rZW5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5hY2Nlc3NUb2tlblZhbGlkID0gZnVuY3Rpb24gYWNjZXNzVG9rZW5WYWxpZCgpIHtcblxuICAgICAgICB2YXIgYXV0aERhdGEgPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgcmV0dXJuIGF1dGhEYXRhLnRva2VuX3R5cGUgPT09IEF1dGguZm9yY2VkVG9rZW5UeXBlIHx8IGF1dGhEYXRhLmV4cGlyZV90aW1lIC0gQXV0aC5yZWZyZXNoSGFuZGljYXBNcyA+IERhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGEgdmFsaWQgKG5vdCBleHBpcmVkKSBhY2Nlc3MgdG9rZW5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5yZWZyZXNoVG9rZW5WYWxpZCA9IGZ1bmN0aW9uIHJlZnJlc2hUb2tlblZhbGlkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKS5yZWZyZXNoX3Rva2VuX2V4cGlyZV90aW1lID4gRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXV0aH1cbiAgICAgKi9cblxuXG4gICAgQXV0aC5wcm90b3R5cGUuY2FuY2VsQWNjZXNzVG9rZW4gPSBmdW5jdGlvbiBjYW5jZWxBY2Nlc3NUb2tlbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogJycsXG4gICAgICAgICAgICBleHBpcmVzX2luOiAwXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIGEgc3BlY2lhbCBhdXRoZW50aWNhdGlvbiBtb2RlIHVzZWQgaW4gU2VydmljZSBXZWJcbiAgICAgKiBAcmV0dXJuIHtBdXRofVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5mb3JjZUF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gZm9yY2VBdXRoZW50aWNhdGlvbigpIHtcblxuICAgICAgICB0aGlzLnNldERhdGEoe1xuICAgICAgICAgICAgdG9rZW5fdHlwZTogQXV0aC5mb3JjZWRUb2tlblR5cGUsXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46ICcnLFxuICAgICAgICAgICAgZXhwaXJlc19pbjogMCxcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46ICcnLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbl9leHBpcmVzX2luOiAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXV0aDtcbn0oKTtcblxuLy9leHBvcnQgaW50ZXJmYWNlIElBdXRoRGF0YSB7XG4vLyAgICByZW1lbWJlcj86Ym9vbGVhbjtcbi8vICAgIHRva2VuX3R5cGU/OnN0cmluZztcbi8vICAgIGFjY2Vzc190b2tlbj86c3RyaW5nO1xuLy8gICAgZXhwaXJlc19pbj86bnVtYmVyOyAvLyBhY3R1YWxseSBpdCdzIHN0cmluZ1xuLy8gICAgZXhwaXJlX3RpbWU/Om51bWJlcjtcbi8vICAgIHJlZnJlc2hfdG9rZW4/OnN0cmluZztcbi8vICAgIHJlZnJlc2hfdG9rZW5fZXhwaXJlc19pbj86bnVtYmVyOyAvLyBhY3R1YWxseSBpdCdzIHN0cmluZ1xuLy8gICAgcmVmcmVzaF90b2tlbl9leHBpcmVfdGltZT86bnVtYmVyO1xuLy8gICAgc2NvcGU/OnN0cmluZztcbi8vfVxuXG5cbkF1dGgucmVmcmVzaEhhbmRpY2FwTXMgPSA2MCAqIDEwMDA7XG5BdXRoLmZvcmNlZFRva2VuVHlwZSA9ICdmb3JjZWQnO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXV0aDtcblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1B1Ym51Yk1vY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIF9QdWJudWJNb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1B1Ym51Yk1vY2spO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQdWJudWJNb2NrRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdWJudWJNb2NrRmFjdG9yeSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFB1Ym51Yk1vY2tGYWN0b3J5KTtcblxuICAgICAgICB0aGlzLmNyeXB0b19vYmogPSBfRXh0ZXJuYWxzLlBVQk5VQi5jcnlwdG9fb2JqO1xuICAgIH1cblxuICAgIFB1Ym51Yk1vY2tGYWN0b3J5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1B1Ym51Yk1vY2syLmRlZmF1bHQob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBQdWJudWJNb2NrRmFjdG9yeTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUHVibnViTW9ja0ZhY3Rvcnk7XG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUHVibnViTW9jayA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKFB1Ym51Yk1vY2ssIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgZnVuY3Rpb24gUHVibnViTW9jayhvcHRpb25zKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdWJudWJNb2NrKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBfdGhpcy5jcnlwdG9fb2JqID0gX0V4dGVybmFscy5QVUJOVUIuY3J5cHRvX29iajtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFB1Ym51Yk1vY2sucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9O1xuXG4gICAgUHVibnViTW9jay5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiByZWFkeSgpIHt9O1xuXG4gICAgUHVibnViTW9jay5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vbignbWVzc2FnZS0nICsgb3B0aW9ucy5jaGFubmVsLCBvcHRpb25zLm1lc3NhZ2UpO1xuICAgIH07XG5cbiAgICBQdWJudWJNb2NrLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ21lc3NhZ2UtJyArIG9wdGlvbnMuY2hhbm5lbCk7XG4gICAgfTtcblxuICAgIFB1Ym51Yk1vY2sucHJvdG90eXBlLnJlY2VpdmVNZXNzYWdlID0gZnVuY3Rpb24gcmVjZWl2ZU1lc3NhZ2UobXNnLCBjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZS0nICsgY2hhbm5lbCwgbXNnLCAnZW52JywgY2hhbm5lbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBQdWJudWJNb2NrO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUHVibnViTW9jaztcblxuLyoqKi8gfSxcbi8qIDE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoU3Vic2NyaXB0aW9uLCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihwdWJudWJGYWN0b3J5LCBwbGF0Zm9ybSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic2NyaXB0aW9uKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbjogJ25vdGlmaWNhdGlvbicsXG4gICAgICAgICAgICByZW1vdmVTdWNjZXNzOiAncmVtb3ZlU3VjY2VzcycsXG4gICAgICAgICAgICByZW1vdmVFcnJvcjogJ3JlbW92ZUVycm9yJyxcbiAgICAgICAgICAgIHJlbmV3U3VjY2VzczogJ3JlbmV3U3VjY2VzcycsXG4gICAgICAgICAgICByZW5ld0Vycm9yOiAncmVuZXdFcnJvcicsXG4gICAgICAgICAgICBzdWJzY3JpYmVTdWNjZXNzOiAnc3Vic2NyaWJlU3VjY2VzcycsXG4gICAgICAgICAgICBzdWJzY3JpYmVFcnJvcjogJ3N1YnNjcmliZUVycm9yJ1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgX3RoaXMuX3B1Ym51YkZhY3RvcnkgPSBwdWJudWJGYWN0b3J5O1xuICAgICAgICBfdGhpcy5fcGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgX3RoaXMuX3B1Ym51YiA9IG51bGw7XG4gICAgICAgIF90aGlzLl9wdWJudWJMYXN0Q2hhbm5lbCA9IG51bGw7XG4gICAgICAgIF90aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbiA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc3Vic2NyaWJlZCA9IGZ1bmN0aW9uIHN1YnNjcmliZWQoKSB7XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9uKCk7XG5cbiAgICAgICAgcmV0dXJuICEhKHN1YnNjcmlwdGlvbi5pZCAmJiBzdWJzY3JpcHRpb24uZGVsaXZlcnlNb2RlICYmIHN1YnNjcmlwdGlvbi5kZWxpdmVyeU1vZGUuc3Vic2NyaWJlcktleSAmJiBzdWJzY3JpcHRpb24uZGVsaXZlcnlNb2RlLmFkZHJlc3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFsaXZlID0gZnVuY3Rpb24gYWxpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZWQoKSAmJiBEYXRlLm5vdygpIDwgdGhpcy5leHBpcmF0aW9uVGltZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmV4cGlyZWQgPSBmdW5jdGlvbiBleHBpcmVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZCgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICF0aGlzLnN1YnNjcmliZWQoKSB8fCBEYXRlLm5vdygpID4gdGhpcy5zdWJzY3JpcHRpb24oKS5leHBpcmF0aW9uVGltZTtcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5leHBpcmF0aW9uVGltZSA9IGZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5zdWJzY3JpcHRpb24oKS5leHBpcmF0aW9uVGltZSB8fCAwKS5nZXRUaW1lKCkgLSBTdWJzY3JpcHRpb24uX3JlbmV3SGFuZGljYXBNcztcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5zZXRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG5cbiAgICAgICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlQXRQdWJudWIoKTtcbiAgICAgICAgdGhpcy5fc2V0VGltZW91dCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIHN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbiB8fCB7fTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciB1cGRhdGVzIHN1YnNjcmlwdGlvbiBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgb25lXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFsaXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmV3KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyO1xuICAgIH0oKTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZXZlbnRGaWx0ZXJzID0gZnVuY3Rpb24gZXZlbnRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb24oKS5ldmVudEZpbHRlcnMgfHwgW107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50c1xuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGRFdmVudEZpbHRlcnMgPSBmdW5jdGlvbiBhZGRFdmVudEZpbHRlcnMoZXZlbnRzKSB7XG4gICAgICAgIHRoaXMuc2V0RXZlbnRGaWx0ZXJzKHRoaXMuZXZlbnRGaWx0ZXJzKCkuY29uY2F0KGV2ZW50cykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnRzXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnNldEV2ZW50RmlsdGVycyA9IGZ1bmN0aW9uIHNldEV2ZW50RmlsdGVycyhldmVudHMpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5ldmVudEZpbHRlcnMgPSBldmVudHM7XG4gICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGpzb247XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEZpbHRlcnMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50cyBhcmUgdW5kZWZpbmVkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtLnBvc3QoJy9zdWJzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RmlsdGVyczogdGhpcy5fZ2V0RnVsbEV2ZW50RmlsdGVycygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpdmVyeU1vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydFR5cGU6ICdQdWJOdWInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IHJlc3BvbnNlLmpzb24oKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdWJzY3JpcHRpb24oanNvbikuZW1pdCh0aGlzLmV2ZW50cy5zdWJzY3JpYmVTdWNjZXNzLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgncmV0dXJuJywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyWydjYXRjaCddKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSB0aGlzLl9wbGF0Zm9ybS5jbGllbnQoKS5tYWtlRXJyb3IoX2NvbnRleHQyLnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKS5lbWl0KHRoaXMuZXZlbnRzLnN1YnNjcmliZUVycm9yLCBfY29udGV4dDIudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQyLnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzAsIDEyXV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW5ldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGpzb247XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1YnNjcmlwdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRGaWx0ZXJzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudHMgYXJlIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybS5wdXQoJy9zdWJzY3JpcHRpb24vJyArIHRoaXMuc3Vic2NyaXB0aW9uKCkuaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRGaWx0ZXJzOiB0aGlzLl9nZXRGdWxsRXZlbnRGaWx0ZXJzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IHJlc3BvbnNlLmpzb24oKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdWJzY3JpcHRpb24oanNvbikuZW1pdCh0aGlzLmV2ZW50cy5yZW5ld1N1Y2Nlc3MsIHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCdyZXR1cm4nLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbJ2NhdGNoJ10oMCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IHRoaXMuX3BsYXRmb3JtLmNsaWVudCgpLm1ha2VFcnJvcihfY29udGV4dDMudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpLmVtaXQodGhpcy5ldmVudHMucmVuZXdFcnJvciwgX2NvbnRleHQzLnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0My50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMywgdGhpcywgW1swLCAxNF1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmV3KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZXc7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3Vic2NyaXB0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtLmRlbGV0ZSgnL3N1YnNjcmlwdGlvbi8nICsgdGhpcy5zdWJzY3JpcHRpb24oKS5pZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0NC5zZW50O1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCkuZW1pdCh0aGlzLmV2ZW50cy5yZW1vdmVTdWNjZXNzLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgncmV0dXJuJywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0WydjYXRjaCddKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQudDAgPSB0aGlzLl9wbGF0Zm9ybS5jbGllbnQoKS5tYWtlRXJyb3IoX2NvbnRleHQ0LnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5yZW1vdmVFcnJvciwgX2NvbnRleHQ0LnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0NC50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1swLCAxMF1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbW92ZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVzdWJzY3JpYmUgPSBmdW5jdGlvbiByZXN1YnNjcmliZSgpIHtcbiAgICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLmV2ZW50RmlsdGVycygpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpLnNldEV2ZW50RmlsdGVycyhmaWx0ZXJzKS5zdWJzY3JpYmUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHN1YnNjcmlwdGlvbiBhbmQgZGlzY29ubmVjdCBmcm9tIFBVQk5VQlxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyBzdWJzY3JpcHRpb24gYXQgY2xpZW50IHNpZGUgYnV0IGJhY2tlbmQgaXMgbm90IG5vdGlmaWVkXG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWQoKSAmJiB0aGlzLl9wdWJudWIpIHRoaXMuX3B1Ym51Yi51bnN1YnNjcmliZSh7IGNoYW5uZWw6IHRoaXMuc3Vic2NyaXB0aW9uKCkuZGVsaXZlcnlNb2RlLmFkZHJlc3MgfSk7XG4gICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3NldFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIF9zZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fZ2V0RnVsbEV2ZW50RmlsdGVycyA9IGZ1bmN0aW9uIF9nZXRGdWxsRXZlbnRGaWx0ZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudEZpbHRlcnMoKS5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9wbGF0Zm9ybS5jcmVhdGVVcmwoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fc2V0VGltZW91dCA9IGZ1bmN0aW9uIF9zZXRUaW1lb3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgICAgICBpZiAoIXRoaXMuYWxpdmUoKSkgdGhyb3cgbmV3IEVycm9yKCdTdWJzY3JpcHRpb24gaXMgbm90IGFsaXZlJyk7XG5cbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKF90aGlzMy5hbGl2ZSgpKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChfdGhpczMuZXhwaXJlZCgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpczMucmVuZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgU3Vic2NyaXB0aW9uLl9wb2xsSW50ZXJ2YWwpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fZGVjcnlwdCA9IGZ1bmN0aW9uIF9kZWNyeXB0KG1lc3NhZ2UpIHtcblxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZCgpKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1YnNjcmlwdGlvbicpO1xuXG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbigpLmRlbGl2ZXJ5TW9kZS5lbmNyeXB0aW9uS2V5KSB7XG5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9wdWJudWJGYWN0b3J5LmNyeXB0b19vYmouZGVjcnlwdChtZXNzYWdlLCB0aGlzLnN1YnNjcmlwdGlvbigpLmRlbGl2ZXJ5TW9kZS5lbmNyeXB0aW9uS2V5LCB7XG4gICAgICAgICAgICAgICAgZW5jcnlwdEtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAga2V5RW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICAgICAgICAgIGtleUxlbmd0aDogMTI4LFxuICAgICAgICAgICAgICAgIG1vZGU6ICdlY2InXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9ub3RpZnkgPSBmdW5jdGlvbiBfbm90aWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLm5vdGlmaWNhdGlvbiwgdGhpcy5fZGVjcnlwdChtZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9zdWJzY3JpYmVBdFB1Ym51YiA9IGZ1bmN0aW9uIF9zdWJzY3JpYmVBdFB1Ym51YigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuYWxpdmUoKSkgdGhyb3cgbmV3IEVycm9yKCdTdWJzY3JpcHRpb24gaXMgbm90IGFsaXZlJyk7XG5cbiAgICAgICAgdmFyIGRlbGl2ZXJ5TW9kZSA9IHRoaXMuc3Vic2NyaXB0aW9uKCkuZGVsaXZlcnlNb2RlO1xuXG4gICAgICAgIGlmICh0aGlzLl9wdWJudWIpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3B1Ym51Ykxhc3RDaGFubmVsID09IGRlbGl2ZXJ5TW9kZS5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byB1cGRhdGUsIGtlZXAgbGlzdGVuaW5nIHRvIHNhbWUgY2hhbm5lbFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9wdWJudWJMYXN0Q2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gc3Vic2NyaWJlIHRvIG5ldyBjaGFubmVsXG4gICAgICAgICAgICAgICAgdGhpcy5fcHVibnViLnVuc3Vic2NyaWJlKHsgY2hhbm5lbDogdGhpcy5fcHVibnViTGFzdENoYW5uZWwgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlLWluaXQgZm9yIG5ldyBkYXRhXG4gICAgICAgICAgICB0aGlzLl9wdWJudWIgPSB0aGlzLl9wdWJudWIuaW5pdCh7XG4gICAgICAgICAgICAgICAgc3NsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZV9rZXk6IGRlbGl2ZXJ5TW9kZS5zdWJzY3JpYmVyS2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gSW5pdCBmcm9tIHNjcmF0Y2hcbiAgICAgICAgICAgIHRoaXMuX3B1Ym51YiA9IHRoaXMuX3B1Ym51YkZhY3RvcnkuaW5pdCh7XG4gICAgICAgICAgICAgICAgc3NsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZV9rZXk6IGRlbGl2ZXJ5TW9kZS5zdWJzY3JpYmVyS2V5XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fcHVibnViLnJlYWR5KCk7IC8vVE9ETyBUaGlzIG1heSBiZSBub3QgbmVlZGVkIGFueW1vcmVcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3B1Ym51Ykxhc3RDaGFubmVsID0gZGVsaXZlcnlNb2RlLmFkZHJlc3M7XG5cbiAgICAgICAgdGhpcy5fcHVibnViLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBjaGFubmVsOiBkZWxpdmVyeU1vZGUuYWRkcmVzcyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuX25vdGlmeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY29ubmVjdDogZnVuY3Rpb24gY29ubmVjdCgpIHt9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuLy9leHBvcnQgaW50ZXJmYWNlIElTdWJzY3JpcHRpb24ge1xuLy8gICAgaWQ/OnN0cmluZztcbi8vICAgIHVyaT86IHN0cmluZztcbi8vICAgIGV2ZW50RmlsdGVycz86c3RyaW5nW107XG4vLyAgICBleHBpcmF0aW9uVGltZT86c3RyaW5nOyAvLyAyMDE0LTAzLTEyVDE5OjU0OjM1LjYxM1pcbi8vICAgIGV4cGlyZXNJbj86bnVtYmVyO1xuLy8gICAgZGVsaXZlcnlNb2RlPzoge1xuLy8gICAgICAgIHRyYW5zcG9ydFR5cGU/OnN0cmluZztcbi8vICAgICAgICBlbmNyeXB0aW9uPzpib29sZWFuO1xuLy8gICAgICAgIGFkZHJlc3M/OnN0cmluZztcbi8vICAgICAgICBzdWJzY3JpYmVyS2V5PzpzdHJpbmc7XG4vLyAgICAgICAgZW5jcnlwdGlvbktleT86c3RyaW5nO1xuLy8gICAgICAgIHNlY3JldEtleT86c3RyaW5nO1xuLy8gICAgfTtcbi8vICAgIGNyZWF0aW9uVGltZT86c3RyaW5nOyAvLyAyMDE0LTAzLTEyVDE5OjU0OjM1LjYxM1pcbi8vICAgIHN0YXR1cz86c3RyaW5nOyAvLyBBY3RpdmVcbi8vfVxuXG5cblN1YnNjcmlwdGlvbi5fcmVuZXdIYW5kaWNhcE1zID0gMiAqIDYwICogMTAwMDtcblN1YnNjcmlwdGlvbi5fcG9sbEludGVydmFsID0gMTAgKiAxMDAwO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3Vic2NyaXB0aW9uO1xuXG4vKioqLyB9LFxuLyogMjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9TdWJzY3JpcHRpb24yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbnZhciBfU3Vic2NyaXB0aW9uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1YnNjcmlwdGlvbjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDYWNoZWRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoX1N1YnNjcmlwdGlvbikge1xuICAgIF9pbmhlcml0cyhDYWNoZWRTdWJzY3JpcHRpb24sIF9TdWJzY3JpcHRpb24pO1xuXG4gICAgZnVuY3Rpb24gQ2FjaGVkU3Vic2NyaXB0aW9uKHB1Ym51YkZhY3RvcnksIHBsYXRmb3JtLCBjYWNoZSwgY2FjaGVLZXkpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhY2hlZFN1YnNjcmlwdGlvbik7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtDYWNoZX0gKi9cblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3Vic2NyaXB0aW9uLmNhbGwodGhpcywgcHVibnViRmFjdG9yeSwgcGxhdGZvcm0pKTtcblxuICAgICAgICBfdGhpcy5fY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgX3RoaXMuX2NhY2hlS2V5ID0gY2FjaGVLZXk7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIENhY2hlZFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gc3Vic2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZ2V0SXRlbSh0aGlzLl9jYWNoZUtleSkgfHwge307XG4gICAgfTtcblxuICAgIENhY2hlZFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3NldFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIF9zZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5zZXRJdGVtKHRoaXMuX2NhY2hlS2V5LCBzdWJzY3JpcHRpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgcHJlLWRlZmluZWQgZXZlbnRGaWx0ZXJzIGluIGNhY2hlIGFuZCBpZiBub3QgLS0gdXNlcyBwcm92aWRlZCBhcyBkZWZhdWx0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50c1xuICAgICAqIEByZXR1cm4ge0NhY2hlZFN1YnNjcmlwdGlvbn1cbiAgICAgKi9cblxuXG4gICAgQ2FjaGVkU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShldmVudHMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuZXZlbnRGaWx0ZXJzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNldEV2ZW50RmlsdGVycyhldmVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBDYWNoZWRTdWJzY3JpcHRpb247XG59KF9TdWJzY3JpcHRpb24zLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYWNoZWRTdWJzY3JpcHRpb247XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpbmdjZW50cmFsLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JpbmdjZW50cmFsL2J1aWxkL3JpbmdjZW50cmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMTIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG59ICgpKVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gY2FjaGVkU2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgcm9vdFBhcmVudCA9IHt9XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gU2FmYXJpIDUtNyBsYWNrcyBzdXBwb3J0IGZvciBjaGFuZ2luZyB0aGUgYE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3JgIHByb3BlcnR5XG4gKiAgICAgb24gb2JqZWN0cy5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIGZ1bmN0aW9uIEJhciAoKSB7fVxuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgYXJyLmNvbnN0cnVjdG9yID0gQmFyXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgYXJyLmNvbnN0cnVjdG9yID09PSBCYXIgJiYgLy8gY29uc3RydWN0b3IgY2FuIGJlIHNldFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAvLyBBdm9pZCBnb2luZyB0aHJvdWdoIGFuIEFyZ3VtZW50c0FkYXB0b3JUcmFtcG9saW5lIGluIHRoZSBjb21tb24gY2FzZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZylcbiAgfVxuXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMsIGFyZylcbiAgfVxuXG4gIC8vIFNsaWdodGx5IGxlc3MgY29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoaXMsIGFyZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiAndXRmOCcpXG4gIH1cblxuICAvLyBVbnVzdWFsLlxuICByZXR1cm4gZnJvbU9iamVjdCh0aGlzLCBhcmcpXG59XG5cbmZ1bmN0aW9uIGZyb21OdW1iZXIgKHRoYXQsIGxlbmd0aCkge1xuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGxlbmd0aCkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgLy8gQXNzdW1wdGlvbjogYnl0ZUxlbmd0aCgpIHJldHVybiB2YWx1ZSBpcyBhbHdheXMgPCBrTWF4TGVuZ3RoLlxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBmcm9tQnVmZmVyKHRoYXQsIG9iamVjdClcblxuICBpZiAoaXNBcnJheShvYmplY3QpKSByZXR1cm4gZnJvbUFycmF5KHRoYXQsIG9iamVjdClcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChvYmplY3QuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tVHlwZWRBcnJheSh0aGF0LCBvYmplY3QpXG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCBvYmplY3QpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9iamVjdC5sZW5ndGgpIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iamVjdClcblxuICByZXR1cm4gZnJvbUpzb25PYmplY3QodGhhdCwgb2JqZWN0KVxufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyICh0aGF0LCBidWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYnVmZmVyLmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGJ1ZmZlci5jb3B5KHRoYXQsIDAsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRHVwbGljYXRlIG9mIGZyb21BcnJheSgpIHRvIGtlZXAgZnJvbUFycmF5KCkgbW9ub21vcnBoaWMuXG5mdW5jdGlvbiBmcm9tVHlwZWRBcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgLy8gVHJ1bmNhdGluZyB0aGUgZWxlbWVudHMgaXMgcHJvYmFibHkgbm90IHdoYXQgcGVvcGxlIGV4cGVjdCBmcm9tIHR5cGVkXG4gIC8vIGFycmF5cyB3aXRoIEJZVEVTX1BFUl9FTEVNRU5UID4gMSBidXQgaXQncyBjb21wYXRpYmxlIHdpdGggdGhlIGJlaGF2aW9yXG4gIC8vIG9mIHRoZSBvbGQgQnVmZmVyIGNvbnN0cnVjdG9yLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBhcnJheS5ieXRlTGVuZ3RoXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShhcnJheSkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tVHlwZWRBcnJheSh0aGF0LCBuZXcgVWludDhBcnJheShhcnJheSkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIERlc2VyaWFsaXplIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsxLDIsMywuLi5dIH0gaW50byBhIEJ1ZmZlciBvYmplY3QuXG4vLyBSZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyIGZvciBpbnB1dHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZSBzcGVjLlxuZnVuY3Rpb24gZnJvbUpzb25PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICB2YXIgYXJyYXlcbiAgdmFyIGxlbmd0aCA9IDBcblxuICBpZiAob2JqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqZWN0LmRhdGEpKSB7XG4gICAgYXJyYXkgPSBvYmplY3QuZGF0YVxuICAgIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgfVxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxufSBlbHNlIHtcbiAgLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbiAgQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbiAgQnVmZmVyLnByb3RvdHlwZS5wYXJlbnQgPSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gYWxsb2NhdGUgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhhdC5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgZnJvbVBvb2wgPSBsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSA+Pj4gMVxuICBpZiAoZnJvbVBvb2wpIHRoYXQucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKSByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIHZhciBpID0gMFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgYnJlYWtcblxuICAgICsraVxuICB9XG5cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHN0cmluZyA9ICcnICsgc3RyaW5nXG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAvLyBEZXByZWNhdGVkXG4gICAgICBjYXNlICdyYXcnOlxuICAgICAgY2FzZSAncmF3cyc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCB8IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID09PSBJbmZpbml0eSA/IHRoaXMubGVuZ3RoIDogZW5kIHwgMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gMFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0KSB7XG4gIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgYnl0ZU9mZnNldCA+Pj0gMFxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG4gIGlmIChieXRlT2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm4gLTFcblxuICAvLyBOZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoICsgYnl0ZU9mZnNldCwgMClcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xIC8vIHNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nIGFsd2F5cyBmYWlsc1xuICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0KSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAodmFyIGkgPSAwOyBieXRlT2Zmc2V0ICsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltieXRlT2Zmc2V0ICsgaV0gPT09IHZhbFtmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleF0pIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWwubGVuZ3RoKSByZXR1cm4gYnl0ZU9mZnNldCArIGZvdW5kSW5kZXhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbi8vIGBnZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmluZGV4T2YgPSBCUC5pbmRleE9mXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcbiAgYXJyLnJlYWRVSW50QkUgPSBCUC5yZWFkVUludEJFXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludExFID0gQlAucmVhZEludExFXG4gIGFyci5yZWFkSW50QkUgPSBCUC5yZWFkSW50QkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50TEUgPSBCUC53cml0ZVVJbnRMRVxuICBhcnIud3JpdGVVSW50QkUgPSBCUC53cml0ZVVJbnRCRVxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50TEUgPSBCUC53cml0ZUludExFXG4gIGFyci53cml0ZUludEJFID0gQlAud3JpdGVJbnRCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYnVmZmVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Jhc2U2NC1qcy9saWIvYjY0LmpzXG4gKiogbW9kdWxlIGlkID0gMTIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2llZWU3NTQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaXNhcnJheS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pha2VhcmNoaWJhbGQvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgMy4yLjFcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc01heWJlVGhlbmFibGUoeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheSkge1xuICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5ID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9IDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQ7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbjtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2xpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW5dID0gY2FsbGJhY2s7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArIDFdID0gYXJnO1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArPSAyO1xuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPT09IDIpIHtcbiAgICAgICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgICAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4obGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwKGFzYXBGbikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBhc2FwRm47XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyB8fCB7fTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbiAgICAvLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyBub2RlXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCkge1xuICAgICAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB2ZXJ0eFxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcihsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB3ZWIgd29ya2VyXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2goKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW47IGkrPTIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldO1xuICAgICAgICB2YXIgYXJnID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2krMV07XG5cbiAgICAgICAgY2FsbGJhY2soYXJnKTtcblxuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXR0ZW1wdFZlcnR4KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHIgPSByZXF1aXJlO1xuICAgICAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoO1xuICAgIC8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG4gICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc05vZGUpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc1dvcmtlcikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0eCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR0aGVuJCR0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcztcblxuICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmIChjaGlsZFtsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tzdGF0ZSAtIDFdO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbigpe1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHN0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdGhlbiQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSR0aGVuJCR0aGVuO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJHJlc29sdmUob2JqZWN0KSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygxNik7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKCkge31cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICAgPSB2b2lkIDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCA9IDE7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEICA9IDI7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IgPSBuZXcgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4ocHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3IgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgICAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgICAgIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuKSB7XG4gICAgICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgIHRoZW4gPT09IGxpYiRlczYkcHJvbWlzZSR0aGVuJCRkZWZhdWx0ICYmXG4gICAgICAgICAgY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGVuID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc2VsZkZ1bGZpbGxtZW50KCkpO1xuICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4odmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICAgICAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICAgICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cblxuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRDtcblxuICAgICAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEXSAgPSBvblJlamVjdGlvbjtcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gsIHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgICAgIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCkge1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICB2YXIgaGFzQ2FsbGJhY2sgPSBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgICAgIHZhbHVlLCBlcnJvciwgc3VjY2VlZGVkLCBmYWlsZWQ7XG5cbiAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICB2YWx1ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAvLyBub29wXG4gICAgICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpe1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGlkID0gMDtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRuZXh0SWQoKSB7XG4gICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaWQrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gICAgICBwcm9taXNlW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaWQrKztcbiAgICAgIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbChlbnRyaWVzKSB7XG4gICAgICByZXR1cm4gbmV3IGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0KHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbDtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRyYWNlKGVudHJpZXMpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICBpZiAoIWxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJHJlamVjdChyZWFzb24pIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRyZWplY3Q7XG5cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2U7XG4gICAgLyoqXG4gICAgICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gICAgICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICAgICAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gICAgICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgVGVybWlub2xvZ3lcbiAgICAgIC0tLS0tLS0tLS0tXG5cbiAgICAgIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gICAgICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gICAgICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgICAgIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgICAgIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gICAgICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gICAgICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gICAgICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICAgICAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gICAgICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gICAgICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgICAgIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgICAgIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgICAgIEJhc2ljIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIGBgYGpzXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBvbiBzdWNjZXNzXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgICAgIC8vIG9uIGZhaWx1cmVcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gICAgICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgICAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICAgICAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgICAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQGNsYXNzIFByb21pc2VcbiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgICB0aGlzW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbmV4dElkKCk7XG4gICAgICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wICE9PSByZXNvbHZlcikge1xuICAgICAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgICAgdGhpcyBpbnN0YW5jZW9mIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlID8gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuYWxsID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJhY2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlc29sdmUgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlamVjdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcjtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0QXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwO1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9hc2FwID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXA7XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UsXG5cbiAgICAvKipcbiAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBDaGFpbmluZ1xuICAgICAgLS0tLS0tLS1cblxuICAgICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgICB9KTtcblxuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgICAgfSk7XG4gICAgICBgYGBcbiAgICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFzc2ltaWxhdGlvblxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBTaW1wbGUgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcblxuICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG5cbiAgICAgIH1cblxuICAgICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kQXV0aG9yKCkuXG4gICAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgdGhlblxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgIHRoZW46IGxpYiRlczYkcHJvbWlzZSR0aGVuJCRkZWZhdWx0LFxuXG4gICAgLyoqXG4gICAgICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gICAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3luY2hyb25vdXNcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmRBdXRob3IoKTtcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9XG5cbiAgICAgIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCBjYXRjaFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3I7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmICghdGhpcy5wcm9taXNlW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0ICAgICA9IGlucHV0O1xuICAgICAgICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgICB0aGlzLl9lbnVtZXJhdGUoKTtcbiAgICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdCh0aGlzLnByb21pc2UsIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCR2YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoICA9IHRoaXMubGVuZ3RoO1xuICAgICAgdmFyIGlucHV0ICAgPSB0aGlzLl9pbnB1dDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5LCBpKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgICB2YXIgcmVzb2x2ZSA9IGMucmVzb2x2ZTtcblxuICAgICAgaWYgKHJlc29sdmUgPT09IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQpIHtcbiAgICAgICAgdmFyIHRoZW4gPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKGVudHJ5KTtcblxuICAgICAgICBpZiAodGhlbiA9PT0gbGliJGVzNiRwcm9taXNlJHRoZW4kJGRlZmF1bHQgJiZcbiAgICAgICAgICAgIGVudHJ5Ll9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQpIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIHRoZW4pO1xuICAgICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24ocmVzb2x2ZSkgeyByZXNvbHZlKGVudHJ5KTsgfSksIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZShlbnRyeSksIGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbihwcm9taXNlLCBpKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkcG9seWZpbGwoKSB7XG4gICAgICB2YXIgbG9jYWw7XG5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxvY2FsID0gZ2xvYmFsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgICAgIGlmIChQICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSkgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9jYWwuUHJvbWlzZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0O1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRwb2x5ZmlsbDtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlID0ge1xuICAgICAgJ1Byb21pc2UnOiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCxcbiAgICAgICdwb2x5ZmlsbCc6IGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdFxuICAgIH07XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lOnRydWUgbW9kdWxlOnRydWUgd2luZG93OiB0cnVlICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTsgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGVbJ2V4cG9ydHMnXSkge1xuICAgICAgbW9kdWxlWydleHBvcnRzJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzWydFUzZQcm9taXNlJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCgpO1xufSkuY2FsbCh0aGlzKTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogKGlnbm9yZWQpICovXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiB2ZXJ0eCAoaWdub3JlZClcbiAqKiBtb2R1bGUgaWQgPSAxMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcImRlZmluZSBjYW5ub3QgYmUgdXNlZCBpbmRpcmVjdFwiKTsgfTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9hbWQtZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge31cblxuICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgfSwgdGhpcylcblxuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgICB9LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICAgIHZhciBsaXN0ID0gdGhpcy5tYXBbbmFtZV1cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgIGxpc3QgPSBbXVxuICAgICAgdGhpcy5tYXBbbmFtZV0gPSBsaXN0XG4gICAgfVxuICAgIGxpc3QucHVzaCh2YWx1ZSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgICByZXR1cm4gdmFsdWVzID8gdmFsdWVzWzBdIDogbnVsbFxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSB8fCBbXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IFtub3JtYWxpemVWYWx1ZSh2YWx1ZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLm1hcCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLm1hcFtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpXG4gICAgICB9LCB0aGlzKVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgICByZXR1cm4gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpXG4gICAgcmV0dXJuIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAvLyBPbmx5IHN1cHBvcnQgQXJyYXlCdWZmZXJzIGZvciBQT1NUIG1ldGhvZC5cbiAgICAgICAgLy8gUmVjZWl2aW5nIEFycmF5QnVmZmVycyBoYXBwZW5zIHZpYSBCbG9icywgaW5zdGVhZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZCA6IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ11cblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIHJldHVybiAobWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEpID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcbiAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBpbnB1dFxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBoZWFkZXJzKHhocikge1xuICAgIHZhciBoZWFkID0gbmV3IEhlYWRlcnMoKVxuICAgIHZhciBwYWlycyA9ICh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpLnRyaW0oKS5zcGxpdCgnXFxuJylcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgdmFyIHNwbGl0ID0gaGVhZGVyLnRyaW0oKS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gc3BsaXQuc2hpZnQoKS50cmltKClcbiAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJzonKS50cmltKClcbiAgICAgIGhlYWQuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICByZXR1cm4gaGVhZFxuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dFxuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgPyBvcHRpb25zLmhlYWRlcnMgOiBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVyc1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZVxuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0XG4gICAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgJiYgIWluaXQpIHtcbiAgICAgICAgcmVxdWVzdCA9IGlucHV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICBmdW5jdGlvbiByZXNwb25zZVVSTCgpIHtcbiAgICAgICAgaWYgKCdyZXNwb25zZVVSTCcgaW4geGhyKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVVSTFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgc2VjdXJpdHkgd2FybmluZ3Mgb24gZ2V0UmVzcG9uc2VIZWFkZXIgd2hlbiBub3QgYWxsb3dlZCBieSBDT1JTXG4gICAgICAgIGlmICgvXlgtUmVxdWVzdC1VUkw6L20udGVzdCh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMpID8gMjA0IDogeGhyLnN0YXR1c1xuICAgICAgICBpZiAoc3RhdHVzIDwgMTAwIHx8IHN0YXR1cyA+IDU5OSkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVycyh4aHIpLFxuICAgICAgICAgIHVybDogcmVzcG9uc2VVUkwoKVxuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfVxuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgICB9KVxuICB9XG4gIHNlbGYuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yaW5nY2VudHJhbC9+L3doYXR3Zy1mZXRjaC9mZXRjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohIDMuMTUuMiAvIG1vZGVybiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUFVCTlVCXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlBVQk5VQlwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBnbG9iYWxzICdNb2Rlcm4nICovXG5cdC8qIGVzbGludCBjdXJseTogMCwgY2FtZWxjYXNlOiAwLCBkb3Qtbm90YXRpb246IDAgKi9cblxuXHR2YXIgcGFja2FnZUpTT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHR2YXIgcHViTnViQ29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBjcnlwdG9fb2JqID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIENyeXB0b0pTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIFdTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuXHQvKipcblx0ICogVVRJTCBMT0NBTFNcblx0ICovXG5cdHZhciBQTlNESyA9ICdQdWJOdWItSlMtJyArICdNb2Rlcm4nICsgJy8nICsgcGFja2FnZUpTT04udmVyc2lvbjtcblxuXHQvKipcblx0ICogTE9DQUwgU1RPUkFHRVxuXHQgKi9cblx0dmFyIGRiID0gKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgbHMgPSB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhbFN0b3JhZ2U7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGlmIChscykgcmV0dXJuIGxzLmdldEl0ZW0oa2V5KTtcblx0ICAgICAgICBpZiAoZG9jdW1lbnQuY29va2llLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHJldHVybiBudWxsO1xuXHQgICAgICAgIHJldHVybiAoKGRvY3VtZW50LmNvb2tpZSB8fCAnJykubWF0Y2goXG5cdCAgICAgICAgICAgIFJlZ0V4cChrZXkgKyAnPShbXjtdKyknKVxuXHQgICAgICAgICAgKSB8fCBbXSlbMV0gfHwgbnVsbDtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBpZiAobHMpIHJldHVybiBscy5zZXRJdGVtKGtleSwgdmFsdWUpICYmIDA7XG5cdCAgICAgICAgZG9jdW1lbnQuY29va2llID0ga2V5ICsgJz0nICsgdmFsdWUgK1xuXHQgICAgICAgICAgJzsgZXhwaXJlcz1UaHUsIDEgQXVnIDIwMzAgMjA6MDA6MDAgVVRDOyBwYXRoPS8nO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0fSkoKTtcblxuXG5cdC8qKlxuXHQgKiBDT1JTIFhIUiBSZXF1ZXN0XG5cdCAqID09PT09PT09PT09PT09PT1cblx0ICogIHhkcih7XG5cdCAqICAgICB1cmwgICAgIDogWydodHRwOi8vd3d3LmJsYWguY29tL3VybCddLFxuXHQgKiAgICAgc3VjY2VzcyA6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7fSxcblx0ICogICAgIGZhaWwgICAgOiBmdW5jdGlvbigpIHt9XG5cdCAqICB9KTtcblx0ICovXG5cdGZ1bmN0aW9uIHhkcihzZXR1cCkge1xuXHQgIHZhciB4aHI7XG5cdCAgdmFyIHRpbWVyO1xuXHQgIHZhciBjb21wbGV0ZSA9IDA7XG5cdCAgdmFyIGxvYWRlZCA9IDA7XG5cdCAgdmFyIGFzeW5jID0gdHJ1ZTsgLyogZG8gbm90IGFsbG93IHN5bmMgb3BlcmF0aW9ucyBpbiBtb2Rlcm4gYnVpbGRzICovXG5cdCAgdmFyIHhocnRtZSA9IHNldHVwLnRpbWVvdXQgfHwgcHViTnViQ29yZS5ERUZfVElNRU9VVDtcblx0ICB2YXIgZGF0YSA9IHNldHVwLmRhdGEgfHwge307XG5cdCAgdmFyIGZhaWwgPSBzZXR1cC5mYWlsIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgIHZhciBzdWNjZXNzID0gc2V0dXAuc3VjY2VzcyB8fCBmdW5jdGlvbiAoKSB7fTtcblxuXHQgIHZhciBkb25lID0gZnVuY3Rpb24gKGZhaWxlZCwgcmVzcG9uc2UpIHtcblx0ICAgIGlmIChjb21wbGV0ZSkgcmV0dXJuO1xuXHQgICAgY29tcGxldGUgPSAxO1xuXG5cdCAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG5cdCAgICBpZiAoeGhyKSB7XG5cdCAgICAgIHhoci5vbmVycm9yID0geGhyLm9ubG9hZCA9IG51bGw7XG5cdCAgICAgIGlmICh4aHIuYWJvcnQpIHhoci5hYm9ydCgpO1xuXHQgICAgICB4aHIgPSBudWxsO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZmFpbGVkKSBmYWlsKHJlc3BvbnNlKTtcblx0ICB9O1xuXG5cdCAgdmFyIGZpbmlzaGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGxvYWRlZCkgcmV0dXJuO1xuXHQgICAgdmFyIHJlc3BvbnNlO1xuXHQgICAgbG9hZGVkID0gMTtcblxuXHQgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuXHQgICAgdHJ5IHtcblx0ICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuXHQgICAgfSBjYXRjaCAocikge1xuXHQgICAgICByZXR1cm4gZG9uZSgxKTtcblx0ICAgIH1cblxuXHQgICAgc3VjY2VzcyhyZXNwb25zZSk7XG5cdCAgfTtcblxuXHQgIHRpbWVyID0gcHViTnViQ29yZS50aW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgIGRvbmUoMSk7XG5cdCAgfSwgeGhydG1lKTtcblxuXHQgIC8vIFNlbmRcblx0ICB0cnkge1xuXHQgICAgeGhyID0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgICBuZXcgWERvbWFpblJlcXVlc3QoKSB8fFxuXHQgICAgICBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHQgICAgeGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgZG9uZSgxLCB4aHIucmVzcG9uc2VUZXh0IHx8IHsgZXJyb3I6ICdOZXR3b3JrIENvbm5lY3Rpb24gRXJyb3InIH0pO1xuXHQgICAgfTtcblx0ICAgIHhoci5vbmxvYWQgPSB4aHIub25sb2FkZW5kID0gZmluaXNoZWQ7XG5cblx0ICAgIGRhdGEucG5zZGsgPSBQTlNESztcblx0ICAgIHZhciB1cmwgPSBwdWJOdWJDb3JlLmJ1aWxkX3VybChzZXR1cC51cmwsIGRhdGEpO1xuXHQgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgYXN5bmMpO1xuXHQgICAgaWYgKGFzeW5jKSB4aHIudGltZW91dCA9IHhocnRtZTtcblx0ICAgIHhoci5zZW5kKCk7XG5cdCAgfSBjYXRjaCAoZWVlKSB7XG5cdCAgICBkb25lKDEsIHsgZXJyb3I6ICdYSFIgRmFpbGVkJywgc3RhY2t0cmFjZTogZWVlIH0pO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiAnZG9uZSdcblx0ICByZXR1cm4gZG9uZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCSU5EXG5cdCAqID09PT1cblx0ICogYmluZCggJ2tleWRvd24nLCBzZWFyY2goJ2EnKVswXSwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHQgKiAgICAgLi4uXG5cdCAqIH0gKTtcblx0ICovXG5cdGZ1bmN0aW9uIGJpbmQodHlwZSwgZWwsIGZ1bikge1xuXHQgIHB1Yk51YkNvcmUuZWFjaCh0eXBlLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChldHlwZSkge1xuXHQgICAgdmFyIHJhcGZ1biA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGlmICghZSkgZSA9IHdpbmRvdy5ldmVudDtcblx0ICAgICAgaWYgKCFmdW4oZSkpIHtcblx0ICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cdCAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHQgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikgZWwuYWRkRXZlbnRMaXN0ZW5lcihldHlwZSwgcmFwZnVuLCBmYWxzZSk7XG5cdCAgICBlbHNlIGlmIChlbC5hdHRhY2hFdmVudCkgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV0eXBlLCByYXBmdW4pO1xuXHQgICAgZWxzZSBlbFsnb24nICsgZXR5cGVdID0gcmFwZnVuO1xuXHQgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVSUk9SXG5cdCAqID09PVxuXHQgKiBlcnJvcignbWVzc2FnZScpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuXHQgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXHR9XG5cblx0LyoqXG5cdCAqIEVWRU5UU1xuXHQgKiA9PT09PT1cblx0ICogUFVCTlVCLmV2ZW50cy5iaW5kKCAneW91LXN0ZXBwZWQtb24tZmxvd2VyJywgZnVuY3Rpb24obWVzc2FnZSkge1xuXHQgKiAgICAgLy8gRG8gU3R1ZmYgd2l0aCBtZXNzYWdlXG5cdCAqIH0gKTtcblx0ICpcblx0ICogUFVCTlVCLmV2ZW50cy5maXJlKCAneW91LXN0ZXBwZWQtb24tZmxvd2VyJywgXCJtZXNzYWdlLWRhdGFcIiApO1xuXHQgKiBQVUJOVUIuZXZlbnRzLmZpcmUoICd5b3Utc3RlcHBlZC1vbi1mbG93ZXInLCB7bWVzc2FnZTpcImRhdGFcIn0gKTtcblx0ICogUFVCTlVCLmV2ZW50cy5maXJlKCAneW91LXN0ZXBwZWQtb24tZmxvd2VyJywgWzEsMiwzXSApO1xuXHQgKlxuXHQgKi9cblx0dmFyIGV2ZW50cyA9IHtcblx0ICBsaXN0OiB7fSxcblx0ICB1bmJpbmQ6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICBldmVudHMubGlzdFtuYW1lXSA9IFtdO1xuXHQgIH0sXG5cdCAgYmluZDogZnVuY3Rpb24gKG5hbWUsIGZ1bikge1xuXHQgICAgKGV2ZW50cy5saXN0W25hbWVdID0gZXZlbnRzLmxpc3RbbmFtZV0gfHwgW10pLnB1c2goZnVuKTtcblx0ICB9LFxuXHQgIGZpcmU6IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG5cdCAgICBwdWJOdWJDb3JlLmVhY2goXG5cdCAgICAgIGV2ZW50cy5saXN0W25hbWVdIHx8IFtdLFxuXHQgICAgICBmdW5jdGlvbiAoZnVuKSB7XG5cdCAgICAgICAgZnVuKGRhdGEpO1xuXHQgICAgICB9XG5cdCAgICApO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQVRUUlxuXHQgKiA9PT09XG5cdCAqIHZhciBhdHRyaWJ1dGUgPSBhdHRyKCBub2RlLCAnYXR0cmlidXRlJyApO1xuXHQgKi9cblx0ZnVuY3Rpb24gYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdCAgaWYgKHZhbHVlKSBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcblx0ICBlbHNlIHJldHVybiBub2RlICYmIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogJFxuXHQgKiA9XG5cdCAqIHZhciBkaXYgPSAkKCdkaXZpZCcpO1xuXHQgKi9cblx0ZnVuY3Rpb24gJChpZCkge1xuXHQgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBTRUFSQ0hcblx0ICogPT09PT09XG5cdCAqIHZhciBlbGVtZW50cyA9IHNlYXJjaCgnYSBkaXYgc3BhbicpO1xuXHQgKi9cblx0ZnVuY3Rpb24gc2VhcmNoKGVsZW1lbnRzLCBzdGFydCkge1xuXHQgIHZhciBsaXN0ID0gW107XG5cdCAgcHViTnViQ29yZS5lYWNoKGVsZW1lbnRzLnNwbGl0KC9cXHMrLyksIGZ1bmN0aW9uIChlbCkge1xuXHQgICAgcHViTnViQ29yZS5lYWNoKChzdGFydCB8fCBkb2N1bWVudCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZWwpLCBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICBsaXN0LnB1c2gobm9kZSk7XG5cdCAgICB9KTtcblx0ICB9KTtcblx0ICByZXR1cm4gbGlzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDU1Ncblx0ICogPT09XG5cdCAqIHZhciBvYmogPSBjcmVhdGUoJ2RpdicpO1xuXHQgKi9cblx0ZnVuY3Rpb24gY3NzKGVsZW1lbnQsIHN0eWxlcykge1xuXHQgIGZvciAodmFyIHN0eWxlIGluIHN0eWxlcykgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpXG5cdCAgICB0cnkge1xuXHQgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlXSA9IHN0eWxlc1tzdHlsZV0gKyAoXG5cdCAgICAgICAgICAnfHdpZHRofGhlaWdodHx0b3B8bGVmdHwnLmluZGV4T2Yoc3R5bGUpID4gMCAmJlxuXHQgICAgICAgICAgdHlwZW9mIHN0eWxlc1tzdHlsZV0gPT09ICdudW1iZXInXG5cdCAgICAgICAgICAgID8gJ3B4JyA6ICcnXG5cdCAgICAgICAgKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIENSRUFURVxuXHQgKiA9PT09PT1cblx0ICogdmFyIG9iaiA9IGNyZWF0ZSgnZGl2Jyk7XG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGUoZWxlbWVudCkge1xuXHQgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnQpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBnZXRfaG1hY19TSEEyNTYoZGF0YSwga2V5KSB7XG5cdCAgdmFyIGhhc2ggPSBDcnlwdG9KU1snSG1hY1NIQTI1NiddKGRhdGEsIGtleSk7XG5cdCAgcmV0dXJuIGhhc2gudG9TdHJpbmcoQ3J5cHRvSlNbJ2VuYyddWydCYXNlNjQnXSk7XG5cdH1cblxuXHQvKiA9LT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09LT0gKi9cblx0LyogPS09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS09ICovXG5cdC8qID0tPT09PT09PT09PT09PT09PT09PT09PT09PSAgICAgUFVCTlVCICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT0tPSAqL1xuXHQvKiA9LT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09LT0gKi9cblx0LyogPS09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS09ICovXG5cblx0ZnVuY3Rpb24gQ1JFQVRFX1BVQk5VQihzZXR1cCkge1xuXHQgIHNldHVwLmRiID0gZGI7XG5cdCAgc2V0dXAueGRyID0geGRyO1xuXHQgIHNldHVwLmVycm9yID0gc2V0dXAuZXJyb3IgfHwgZXJyb3I7XG5cdCAgc2V0dXAuaG1hY19TSEEyNTYgPSBnZXRfaG1hY19TSEEyNTY7XG5cdCAgc2V0dXAuY3J5cHRvX29iaiA9IGNyeXB0b19vYmooKTtcblx0ICBzZXR1cC5XUyA9IFdTO1xuXHQgIHNldHVwLnBhcmFtcyA9IHsgcG5zZGs6IFBOU0RLIH07XG5cblx0ICB2YXIgU0VMRiA9IGZ1bmN0aW9uIChzZXR1cCkge1xuXHQgICAgcmV0dXJuIENSRUFURV9QVUJOVUIoc2V0dXApO1xuXHQgIH07XG5cblx0ICB2YXIgUE4gPSBwdWJOdWJDb3JlLlBOX0FQSShzZXR1cCk7XG5cdCAgZm9yICh2YXIgcHJvcCBpbiBQTikge1xuXHQgICAgaWYgKFBOLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdCAgICAgIFNFTEZbcHJvcF0gPSBQTltwcm9wXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBTRUxGLmluaXQgPSBTRUxGO1xuXHQgIFNFTEYuJCA9ICQ7XG5cdCAgU0VMRi5hdHRyID0gYXR0cjtcblx0ICBTRUxGLnNlYXJjaCA9IHNlYXJjaDtcblx0ICBTRUxGLmJpbmQgPSBiaW5kO1xuXHQgIFNFTEYuY3NzID0gY3NzO1xuXHQgIFNFTEYuY3JlYXRlID0gY3JlYXRlO1xuXHQgIFNFTEYuY3J5cHRvX29iaiA9IGNyeXB0b19vYmooKTtcblx0ICBTRUxGLldTID0gV1M7XG5cdCAgU0VMRi5QTm1lc3NhZ2UgPSBwdWJOdWJDb3JlLlBObWVzc2FnZTtcblx0ICBTRUxGLnN1cHBsYW50ID0gcHViTnViQ29yZS5zdXBwbGFudDtcblxuXHQgIGlmICh0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIGJpbmQoJ2JlZm9yZXVubG9hZCcsIHdpbmRvdywgZnVuY3Rpb24gKCkge1xuXHQgICAgICBTRUxGWydlYWNoLWNoYW5uZWwnXShmdW5jdGlvbiAoY2gpIHtcblx0ICAgICAgICBTRUxGWydMRUFWRSddKGNoLm5hbWUsIDEpO1xuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBTRUxGLnJlYWR5KCk7XG5cblx0ICAvLyBSZXR1cm4gd2l0aG91dCBUZXN0aW5nXG5cdCAgaWYgKHNldHVwLm5vdGVzdCkgcmV0dXJuIFNFTEY7XG5cblx0ICBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICBiaW5kKCdvZmZsaW5lJywgd2luZG93LCBTRUxGWydvZmZsaW5lJ10pO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgYmluZCgnb2ZmbGluZScsIGRvY3VtZW50LCBTRUxGWydvZmZsaW5lJ10pO1xuXHQgIH1cblxuXHQgIHJldHVybiBTRUxGO1xuXHR9XG5cblx0Q1JFQVRFX1BVQk5VQi5pbml0ID0gQ1JFQVRFX1BVQk5VQjtcblx0Q1JFQVRFX1BVQk5VQi5zZWN1cmUgPSBDUkVBVEVfUFVCTlVCO1xuXHRDUkVBVEVfUFVCTlVCLmNyeXB0b19vYmogPSBjcnlwdG9fb2JqKCk7XG5cdENSRUFURV9QVUJOVUIuV1MgPSBXUztcblx0Q1JFQVRFX1BVQk5VQi5kYiA9IGRiO1xuXHRDUkVBVEVfUFVCTlVCLlBObWVzc2FnZSA9IHB1Yk51YkNvcmUuUE5tZXNzYWdlO1xuXHRDUkVBVEVfUFVCTlVCLnV1aWQgPSBwdWJOdWJDb3JlLnV1aWQ7XG5cblx0Q1JFQVRFX1BVQk5VQi5jc3MgPSBjc3M7XG5cdENSRUFURV9QVUJOVUIuJCA9ICQ7XG5cdENSRUFURV9QVUJOVUIuY3JlYXRlID0gJDtcblx0Q1JFQVRFX1BVQk5VQi5iaW5kID0gYmluZDtcblx0Q1JFQVRFX1BVQk5VQi5zZWFyY2ggPSBzZWFyY2g7XG5cdENSRUFURV9QVUJOVUIuYXR0ciA9IGF0dHI7XG5cdENSRUFURV9QVUJOVUIuZXZlbnRzID0gZXZlbnRzO1xuXG5cdENSRUFURV9QVUJOVUIubWFwID0gcHViTnViQ29yZS5tYXA7XG5cdENSRUFURV9QVUJOVUIuZWFjaCA9IHB1Yk51YkNvcmUuZWFjaDtcblx0Q1JFQVRFX1BVQk5VQi5ncmVwID0gcHViTnViQ29yZS5ncmVwO1xuXHRDUkVBVEVfUFVCTlVCLnN1cHBsYW50ID0gcHViTnViQ29yZS5zdXBwbGFudDtcblx0Q1JFQVRFX1BVQk5VQi5ub3cgPSBwdWJOdWJDb3JlLm5vdztcblx0Q1JFQVRFX1BVQk5VQi51bmlxdWUgPSBwdWJOdWJDb3JlLnVuaXF1ZTtcblx0Q1JFQVRFX1BVQk5VQi51cGRhdGVyID0gcHViTnViQ29yZS51cGRhdGVyO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQ1JFQVRFX1BVQk5VQjtcblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdFx0XCJuYW1lXCI6IFwicHVibnViXCIsXG5cdFx0XCJwcmVmZXJHbG9iYWxcIjogZmFsc2UsXG5cdFx0XCJ2ZXJzaW9uXCI6IFwiMy4xNS4yXCIsXG5cdFx0XCJhdXRob3JcIjogXCJQdWJOdWIgPHN1cHBvcnRAcHVibnViLmNvbT5cIixcblx0XHRcImRlc2NyaXB0aW9uXCI6IFwiUHVibGlzaCAmIFN1YnNjcmliZSBSZWFsLXRpbWUgTWVzc2FnaW5nIHdpdGggUHViTnViXCIsXG5cdFx0XCJjb250cmlidXRvcnNcIjogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIm5hbWVcIjogXCJTdGVwaGVuIEJsdW1cIixcblx0XHRcdFx0XCJlbWFpbFwiOiBcInN0ZXBoZW5AcHVibnViLmNvbVwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcImJpblwiOiB7fSxcblx0XHRcInNjcmlwdHNcIjoge1xuXHRcdFx0XCJ0ZXN0XCI6IFwiZ3J1bnQgdGVzdCAtLWZvcmNlXCJcblx0XHR9LFxuXHRcdFwibWFpblwiOiBcIi4vbm9kZS5qcy9wdWJudWIuanNcIixcblx0XHRcImJyb3dzZXJcIjogXCIuL21vZGVybi9kaXN0L3B1Ym51Yi5qc1wiLFxuXHRcdFwicmVwb3NpdG9yeVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcdFwidXJsXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9wdWJudWIvamF2YXNjcmlwdC5naXRcIlxuXHRcdH0sXG5cdFx0XCJrZXl3b3Jkc1wiOiBbXG5cdFx0XHRcImNsb3VkXCIsXG5cdFx0XHRcInB1Ymxpc2hcIixcblx0XHRcdFwic3Vic2NyaWJlXCIsXG5cdFx0XHRcIndlYnNvY2tldHNcIixcblx0XHRcdFwiY29tZXRcIixcblx0XHRcdFwiYm9zaFwiLFxuXHRcdFx0XCJ4bXBwXCIsXG5cdFx0XHRcInJlYWwtdGltZVwiLFxuXHRcdFx0XCJtZXNzYWdpbmdcIlxuXHRcdF0sXG5cdFx0XCJkZXBlbmRlbmNpZXNcIjoge1xuXHRcdFx0XCJhZ2VudGtlZXBhbGl2ZVwiOiBcIn4wLjJcIixcblx0XHRcdFwibG9kYXNoXCI6IFwiXjQuMS4wXCJcblx0XHR9LFxuXHRcdFwibm9BbmFseXplXCI6IGZhbHNlLFxuXHRcdFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcdFwiY2hhaVwiOiBcIl4zLjUuMFwiLFxuXHRcdFx0XCJlc2xpbnRcIjogXCIyLjQuMFwiLFxuXHRcdFx0XCJlc2xpbnQtY29uZmlnLWFpcmJuYlwiOiBcIl42LjAuMlwiLFxuXHRcdFx0XCJlc2xpbnQtcGx1Z2luLWZsb3d0eXBlXCI6IFwiXjIuMS4wXCIsXG5cdFx0XHRcImVzbGludC1wbHVnaW4tbW9jaGFcIjogXCJeMi4wLjBcIixcblx0XHRcdFwiZXNsaW50LXBsdWdpbi1yZWFjdFwiOiBcIl40LjEuMFwiLFxuXHRcdFx0XCJmbG93LWJpblwiOiBcIl4wLjIyLjBcIixcblx0XHRcdFwiZ3J1bnRcIjogXCJeMC40LjVcIixcblx0XHRcdFwiZ3J1bnQtY29udHJpYi1jbGVhblwiOiBcIl4xLjAuMFwiLFxuXHRcdFx0XCJncnVudC1jb250cmliLWNvcHlcIjogXCJeMC44LjJcIixcblx0XHRcdFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJeMC4xMS4xXCIsXG5cdFx0XHRcImdydW50LWVudlwiOiBcIl4wLjQuNFwiLFxuXHRcdFx0XCJncnVudC1lc2xpbnRcIjogXCJeMTguMC4wXCIsXG5cdFx0XHRcImdydW50LWZsb3dcIjogXCJeMS4wLjNcIixcblx0XHRcdFwiZ3J1bnQta2FybWFcIjogXCJeMC4xMi4xXCIsXG5cdFx0XHRcImdydW50LW1vY2hhLWlzdGFuYnVsXCI6IFwiXjMuMC4xXCIsXG5cdFx0XHRcImdydW50LXRleHQtcmVwbGFjZVwiOiBcIl4wLjQuMFwiLFxuXHRcdFx0XCJncnVudC13ZWJwYWNrXCI6IFwiXjEuMC4xMVwiLFxuXHRcdFx0XCJpbXBvcnRzLWxvYWRlclwiOiBcIl4wLjYuNVwiLFxuXHRcdFx0XCJpc3BhcnRhXCI6IFwiXjQuMC4wXCIsXG5cdFx0XHRcImpzb24tbG9hZGVyXCI6IFwiXjAuNS40XCIsXG5cdFx0XHRcImthcm1hXCI6IFwiXjAuMTMuMjFcIixcblx0XHRcdFwia2FybWEtY2hhaVwiOiBcIl4wLjEuMFwiLFxuXHRcdFx0XCJrYXJtYS1tb2NoYVwiOiBcIl4wLjIuMVwiLFxuXHRcdFx0XCJrYXJtYS1waGFudG9tanMtbGF1bmNoZXJcIjogXCJeMS4wLjBcIixcblx0XHRcdFwia2FybWEtc3BlYy1yZXBvcnRlclwiOiBcIjAuMC4yNFwiLFxuXHRcdFx0XCJsb2FkLWdydW50LXRhc2tzXCI6IFwiXjMuNC4wXCIsXG5cdFx0XHRcIm1vY2hhXCI6IFwiXjIuNC41XCIsXG5cdFx0XHRcIm5vY2tcIjogXCJeMS4xLjBcIixcblx0XHRcdFwibm9kZS11dWlkXCI6IFwiXjEuNC43XCIsXG5cdFx0XHRcIm5vZGV1bml0XCI6IFwiXjAuOS4wXCIsXG5cdFx0XHRcInBoYW50b21qcy1wcmVidWlsdFwiOiBcIl4yLjEuNFwiLFxuXHRcdFx0XCJwcm94eXF1aXJlXCI6IFwiXjEuNy40XCIsXG5cdFx0XHRcInNpbm9uXCI6IFwiXjEuMTcuMlwiLFxuXHRcdFx0XCJ1Z2xpZnktanNcIjogXCJeMi42LjFcIixcblx0XHRcdFwidW5kZXJzY29yZVwiOiBcIl4xLjcuMFwiLFxuXHRcdFx0XCJ3ZWJwYWNrXCI6IFwiXjEuMTIuMTNcIixcblx0XHRcdFwid2VicGFjay1kZXYtc2VydmVyXCI6IFwiXjEuMTQuMVwiXG5cdFx0fSxcblx0XHRcImJ1bmRsZURlcGVuZGVuY2llc1wiOiBbXSxcblx0XHRcImxpY2Vuc2VcIjogXCJNSVRcIixcblx0XHRcImVuZ2luZVwiOiB7XG5cdFx0XHRcIm5vZGVcIjogXCI+PTAuOFwiXG5cdFx0fSxcblx0XHRcImZpbGVzXCI6IFtcblx0XHRcdFwiY29yZVwiLFxuXHRcdFx0XCJub2RlLmpzXCIsXG5cdFx0XHRcIm1vZGVyblwiLFxuXHRcdFx0XCJDSEFOR0VMT0dcIixcblx0XHRcdFwiRlVUVVJFLm1kXCIsXG5cdFx0XHRcIkxJQ0VOU0VcIixcblx0XHRcdFwiUkVBRE1FLm1kXCJcblx0XHRdXG5cdH07XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBlc2xpbnQgY2FtZWxjYXNlOiAwLCBuby11c2UtYmVmb3JlLWRlZmluZTogMCwgbm8tdW51c2VkLWV4cHJlc3Npb25zOiAwICAqL1xuXHQvKiBlc2xpbnQgZXFlcWVxOiAwLCBvbmUtdmFyOiAwICovXG5cdC8qIGVzbGludCBuby1yZWRlY2xhcmU6IDAgKi9cblx0LyogZXNsaW50IGd1YXJkLWZvci1pbjogMCAqL1xuXHQvKiBlc2xpbnQgYmxvY2stc2NvcGVkLXZhcjogMCBzcGFjZS1yZXR1cm4tdGhyb3ctY2FzZTogMCwgbm8tdW51c2VkLXZhcnM6IDAgKi9cblxuXHR2YXIgcGFja2FnZUpTT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHR2YXIgZGVmYXVsdENvbmZpZ3VyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdHZhciBOT1cgPSAxO1xuXHR2YXIgUkVBRFkgPSBmYWxzZTtcblx0dmFyIFJFQURZX0JVRkZFUiA9IFtdO1xuXHR2YXIgUFJFU0VOQ0VfU1VGRklYID0gJy1wbnByZXMnO1xuXHR2YXIgREVGX1dJTkRPV0lORyA9IDEwOyAvLyBNSUxMSVNFQ09ORFMuXG5cdHZhciBERUZfVElNRU9VVCA9IDE1MDAwOyAvLyBNSUxMSVNFQ09ORFMuXG5cdHZhciBERUZfU1VCX1RJTUVPVVQgPSAzMTA7IC8vIFNFQ09ORFMuXG5cdHZhciBERUZfS0VFUEFMSVZFID0gNjA7IC8vIFNFQ09ORFMgKEZPUiBUSU1FU1lOQykuXG5cdHZhciBTRUNPTkQgPSAxMDAwOyAvLyBBIFRIT1VTQU5EIE1JTExJU0VDT05EUy5cblx0dmFyIFBSRVNFTkNFX0hCX1RIUkVTSE9MRCA9IDU7XG5cdHZhciBQUkVTRU5DRV9IQl9ERUZBVUxUID0gMzA7XG5cdHZhciBTREtfVkVSID0gcGFja2FnZUpTT04udmVyc2lvbjtcblxuXHQvKipcblx0ICogVVRJTElUSUVTXG5cdCAqL1xuXHRmdW5jdGlvbiB1bmlxdWUoKSB7XG5cdCAgcmV0dXJuICd4JyArICsrTk9XICsgJycgKyAoK25ldyBEYXRlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBORVhUT1JJR0lOXG5cdCAqID09PT09PT09PT1cblx0ICogdmFyIG5leHRfb3JpZ2luID0gbmV4dG9yaWdpbigpO1xuXHQgKi9cblx0dmFyIG5leHRvcmlnaW4gPSAoZnVuY3Rpb24gKCkge1xuXHQgIHZhciBtYXggPSAyMDtcblx0ICB2YXIgb3JpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcblx0ICByZXR1cm4gZnVuY3Rpb24gKG9yaWdpbiwgZmFpbG92ZXIpIHtcblx0ICAgIHJldHVybiBvcmlnaW4uaW5kZXhPZigncHVic3ViLicpID4gMFxuXHQgICAgICAmJiBvcmlnaW4ucmVwbGFjZShcblx0ICAgICAgICAncHVic3ViJywgJ3BzJyArIChcblx0ICAgICAgICAgIGZhaWxvdmVyID8gdXRpbHMuZ2VuZXJhdGVVVUlEKCkuc3BsaXQoJy0nKVswXSA6XG5cdCAgICAgICAgICAgICgrK29yaSA8IG1heCA/IG9yaSA6IG9yaSA9IDEpXG5cdCAgICAgICAgKSkgfHwgb3JpZ2luO1xuXHQgIH07XG5cdH0pKCk7XG5cblxuXHQvKipcblx0ICogR2VuZXJhdGUgU3Vic2NyaXB0aW9uIENoYW5uZWwgTGlzdFxuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIGdlbmVyYXRlX2NoYW5uZWxfbGlzdChjaGFubmVsc19vYmplY3QpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuZXJhdGVfY2hhbm5lbF9saXN0KGNoYW5uZWxzLCBub3ByZXNlbmNlKSB7XG5cdCAgdmFyIGxpc3QgPSBbXTtcblx0ICB1dGlscy5lYWNoKGNoYW5uZWxzLCBmdW5jdGlvbiAoY2hhbm5lbCwgc3RhdHVzKSB7XG5cdCAgICBpZiAobm9wcmVzZW5jZSkge1xuXHQgICAgICBpZiAoY2hhbm5lbC5zZWFyY2goJy1wbnByZXMnKSA8IDApIHtcblx0ICAgICAgICBpZiAoc3RhdHVzLnN1YnNjcmliZWQpIGxpc3QucHVzaChjaGFubmVsKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHN0YXR1cy5zdWJzY3JpYmVkKSBsaXN0LnB1c2goY2hhbm5lbCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGxpc3Quc29ydCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIFN1YnNjcmlwdGlvbiBDaGFubmVsIEdyb3VwcyBMaXN0XG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KGNoYW5uZWxzX2dyb3VwcyBvYmplY3QpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KGNoYW5uZWxfZ3JvdXBzLCBub3ByZXNlbmNlKSB7XG5cdCAgdmFyIGxpc3QgPSBbXTtcblx0ICB1dGlscy5lYWNoKGNoYW5uZWxfZ3JvdXBzLCBmdW5jdGlvbiAoY2hhbm5lbF9ncm91cCwgc3RhdHVzKSB7XG5cdCAgICBpZiAobm9wcmVzZW5jZSkge1xuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cC5zZWFyY2goJy1wbnByZXMnKSA8IDApIHtcblx0ICAgICAgICBpZiAoc3RhdHVzLnN1YnNjcmliZWQpIGxpc3QucHVzaChjaGFubmVsX2dyb3VwKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHN0YXR1cy5zdWJzY3JpYmVkKSBsaXN0LnB1c2goY2hhbm5lbF9ncm91cCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGxpc3Quc29ydCgpO1xuXHR9XG5cblx0Ly8gUFVCTlVCIFJFQURZIFRPIENPTk5FQ1Rcblx0ZnVuY3Rpb24gcmVhZHkoKSB7XG5cdCAgaWYgKFJFQURZKSByZXR1cm47XG5cdCAgUkVBRFkgPSAxO1xuXHQgIHV0aWxzLmVhY2goUkVBRFlfQlVGRkVSLCBmdW5jdGlvbiAoY29ubmVjdCkge1xuXHQgICAgY29ubmVjdCgpO1xuXHQgIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gUE5tZXNzYWdlKGFyZ3MpIHtcblx0ICB2YXIgbXNnID0gYXJncyB8fCB7IGFwbnM6IHt9IH07XG5cblx0ICBtc2dbJ2dldFB1Ym51Yk1lc3NhZ2UnXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBtID0ge307XG5cblx0ICAgIGlmIChPYmplY3Qua2V5cyhtc2dbJ2FwbnMnXSkubGVuZ3RoKSB7XG5cdCAgICAgIG1bJ3BuX2FwbnMnXSA9IHtcblx0ICAgICAgICBhcHM6IHtcblx0ICAgICAgICAgIGFsZXJ0OiBtc2dbJ2FwbnMnXVsnYWxlcnQnXSxcblx0ICAgICAgICAgIGJhZGdlOiBtc2dbJ2FwbnMnXVsnYmFkZ2UnXVxuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgICAgZm9yICh2YXIgayBpbiBtc2dbJ2FwbnMnXSkge1xuXHQgICAgICAgIG1bJ3BuX2FwbnMnXVtrXSA9IG1zZ1snYXBucyddW2tdO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBleGNsdWRlMSA9IFsnYmFkZ2UnLCAnYWxlcnQnXTtcblx0ICAgICAgZm9yICh2YXIgayBpbiBleGNsdWRlMSkge1xuXHQgICAgICAgIGRlbGV0ZSBtWydwbl9hcG5zJ11bZXhjbHVkZTFba11dO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChtc2dbJ2djbSddKSB7XG5cdCAgICAgIG1bJ3BuX2djbSddID0ge1xuXHQgICAgICAgIGRhdGE6IG1zZ1snZ2NtJ11cblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgayBpbiBtc2cpIHtcblx0ICAgICAgbVtrXSA9IG1zZ1trXTtcblx0ICAgIH1cblx0ICAgIHZhciBleGNsdWRlID0gWydhcG5zJywgJ2djbScsICdwdWJsaXNoJywgJ2NoYW5uZWwnLCAnY2FsbGJhY2snLCAnZXJyb3InXTtcblx0ICAgIGZvciAodmFyIGsgaW4gZXhjbHVkZSkge1xuXHQgICAgICBkZWxldGUgbVtleGNsdWRlW2tdXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG07XG5cdCAgfTtcblx0ICBtc2dbJ3B1Ymxpc2gnXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBtID0gbXNnLmdldFB1Ym51Yk1lc3NhZ2UoKTtcblxuXHQgICAgaWYgKG1zZ1sncHVibnViJ10gJiYgbXNnWydjaGFubmVsJ10pIHtcblx0ICAgICAgbXNnWydwdWJudWInXS5wdWJsaXNoKHtcblx0ICAgICAgICBtZXNzYWdlOiBtLFxuXHQgICAgICAgIGNoYW5uZWw6IG1zZ1snY2hhbm5lbCddLFxuXHQgICAgICAgIGNhbGxiYWNrOiBtc2dbJ2NhbGxiYWNrJ10sXG5cdCAgICAgICAgZXJyb3I6IG1zZ1snZXJyb3InXVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIHJldHVybiBtc2c7XG5cdH1cblxuXHRmdW5jdGlvbiBQTl9BUEkoc2V0dXApIHtcblx0ICB2YXIgU1VCX1dJTkRPV0lORyA9ICtzZXR1cFsnd2luZG93aW5nJ10gfHwgREVGX1dJTkRPV0lORztcblx0ICB2YXIgU1VCX1RJTUVPVVQgPSAoK3NldHVwWyd0aW1lb3V0J10gfHwgREVGX1NVQl9USU1FT1VUKSAqIFNFQ09ORDtcblx0ICB2YXIgS0VFUEFMSVZFID0gKCtzZXR1cFsna2VlcGFsaXZlJ10gfHwgREVGX0tFRVBBTElWRSkgKiBTRUNPTkQ7XG5cdCAgdmFyIFRJTUVfQ0hFQ0sgPSBzZXR1cFsndGltZWNoZWNrJ10gfHwgMDtcblx0ICB2YXIgTk9MRUFWRSA9IHNldHVwWydub2xlYXZlJ10gfHwgMDtcblx0ICB2YXIgUFVCTElTSF9LRVkgPSBzZXR1cFsncHVibGlzaF9rZXknXTtcblx0ICB2YXIgU1VCU0NSSUJFX0tFWSA9IHNldHVwWydzdWJzY3JpYmVfa2V5J107XG5cdCAgdmFyIEFVVEhfS0VZID0gc2V0dXBbJ2F1dGhfa2V5J10gfHwgJyc7XG5cdCAgdmFyIFNFQ1JFVF9LRVkgPSBzZXR1cFsnc2VjcmV0X2tleSddIHx8ICcnO1xuXHQgIHZhciBobWFjX1NIQTI1NiA9IHNldHVwWydobWFjX1NIQTI1NiddO1xuXHQgIHZhciBTU0wgPSBzZXR1cFsnc3NsJ10gPyAncycgOiAnJztcblx0ICB2YXIgT1JJR0lOID0gJ2h0dHAnICsgU1NMICsgJzovLycgKyAoc2V0dXBbJ29yaWdpbiddIHx8ICdwdWJzdWIucHVibnViLmNvbScpO1xuXHQgIHZhciBTVERfT1JJR0lOID0gbmV4dG9yaWdpbihPUklHSU4pO1xuXHQgIHZhciBTVUJfT1JJR0lOID0gbmV4dG9yaWdpbihPUklHSU4pO1xuXHQgIHZhciBDT05ORUNUID0gZnVuY3Rpb24gKCkge1xuXHQgIH07XG5cdCAgdmFyIFBVQl9RVUVVRSA9IFtdO1xuXHQgIHZhciBDTE9BSyA9IHRydWU7XG5cdCAgdmFyIFRJTUVfRFJJRlQgPSAwO1xuXHQgIHZhciBTVUJfQ0FMTEJBQ0sgPSAwO1xuXHQgIHZhciBTVUJfQ0hBTk5FTCA9IDA7XG5cdCAgdmFyIFNVQl9SRUNFSVZFUiA9IDA7XG5cdCAgdmFyIFNVQl9SRVNUT1JFID0gc2V0dXBbJ3Jlc3RvcmUnXSB8fCAwO1xuXHQgIHZhciBTVUJfQlVGRl9XQUlUID0gMDtcblx0ICB2YXIgVElNRVRPS0VOID0gMDtcblx0ICB2YXIgUkVTVU1FRCA9IGZhbHNlO1xuXHQgIHZhciBDSEFOTkVMUyA9IHt9O1xuXHQgIHZhciBDSEFOTkVMX0dST1VQUyA9IHt9O1xuXHQgIHZhciBTVUJfRVJST1IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgfTtcblx0ICB2YXIgU1RBVEUgPSB7fTtcblx0ICB2YXIgUFJFU0VOQ0VfSEJfVElNRU9VVCA9IG51bGw7XG5cdCAgdmFyIFBSRVNFTkNFX0hCID0gdmFsaWRhdGVfcHJlc2VuY2VfaGVhcnRiZWF0KFxuXHQgICAgc2V0dXBbJ2hlYXJ0YmVhdCddIHx8IHNldHVwWydwbmV4cGlyZXMnXSB8fCAwLCBzZXR1cFsnZXJyb3InXVxuXHQgICk7XG5cdCAgdmFyIFBSRVNFTkNFX0hCX0lOVEVSVkFMID0gc2V0dXBbJ2hlYXJ0YmVhdF9pbnRlcnZhbCddIHx8IChQUkVTRU5DRV9IQiAvIDIpIC0gMTtcblx0ICB2YXIgUFJFU0VOQ0VfSEJfUlVOTklORyA9IGZhbHNlO1xuXHQgIHZhciBOT19XQUlUX0ZPUl9QRU5ESU5HID0gc2V0dXBbJ25vX3dhaXRfZm9yX3BlbmRpbmcnXTtcblx0ICB2YXIgQ09NUEFUSUJMRV8zNSA9IHNldHVwWydjb21wYXRpYmxlXzMuNSddIHx8IGZhbHNlO1xuXHQgIHZhciB4ZHIgPSBzZXR1cFsneGRyJ107XG5cdCAgdmFyIHBhcmFtcyA9IHNldHVwWydwYXJhbXMnXSB8fCB7fTtcblx0ICB2YXIgZXJyb3IgPSBzZXR1cFsnZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICB2YXIgX2lzX29ubGluZSA9IHNldHVwWydfaXNfb25saW5lJ10gfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMTt9O1xuXHQgIHZhciBqc29ucF9jYiA9IHNldHVwWydqc29ucF9jYiddIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XG5cdCAgdmFyIGRiID0gc2V0dXBbJ2RiJ10gfHwgeyBnZXQ6IGZ1bmN0aW9uICgpIHt9LCBzZXQ6IGZ1bmN0aW9uICgpIHt9IH07XG5cdCAgdmFyIENJUEhFUl9LRVkgPSBzZXR1cFsnY2lwaGVyX2tleSddO1xuXHQgIHZhciBVVUlEID0gc2V0dXBbJ3V1aWQnXSB8fCAoIXNldHVwWyd1bmlxdWVfdXVpZCddICYmIGRiICYmIGRiWydnZXQnXShTVUJTQ1JJQkVfS0VZICsgJ3V1aWQnKSB8fCAnJyk7XG5cdCAgdmFyIFVTRV9JTlNUQU5DRUlEID0gc2V0dXBbJ2luc3RhbmNlX2lkJ10gfHwgZmFsc2U7XG5cdCAgdmFyIElOU1RBTkNFSUQgPSAnJztcblx0ICB2YXIgc2h1dGRvd24gPSBzZXR1cFsnc2h1dGRvd24nXTtcblx0ICB2YXIgdXNlX3NlbmRfYmVhY29uID0gKHR5cGVvZiBzZXR1cFsndXNlX3NlbmRfYmVhY29uJ10gIT0gJ3VuZGVmaW5lZCcpID8gc2V0dXBbJ3VzZV9zZW5kX2JlYWNvbiddIDogdHJ1ZTtcblx0ICB2YXIgc2VuZEJlYWNvbiA9ICh1c2Vfc2VuZF9iZWFjb24pID8gc2V0dXBbJ3NlbmRCZWFjb24nXSA6IG51bGw7XG5cdCAgdmFyIF9wb2xsX3RpbWVyO1xuXHQgIHZhciBfcG9sbF90aW1lcjI7XG5cblx0ICBpZiAoUFJFU0VOQ0VfSEIgPT09IDIpIFBSRVNFTkNFX0hCX0lOVEVSVkFMID0gMTtcblxuXHQgIHZhciBjcnlwdG9fb2JqID0gc2V0dXBbJ2NyeXB0b19vYmonXSB8fCB7XG5cdCAgICBlbmNyeXB0OiBmdW5jdGlvbiAoYSwga2V5KSB7XG5cdCAgICAgIHJldHVybiBhO1xuXHQgICAgfSxcblx0ICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChiLCBrZXkpIHtcblx0ICAgICAgcmV0dXJuIGI7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIF9nZXRfdXJsX3BhcmFtcyhkYXRhKSB7XG5cdCAgICBpZiAoIWRhdGEpIGRhdGEgPSB7fTtcblx0ICAgIHV0aWxzLmVhY2gocGFyYW1zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgICAgICBpZiAoIShrZXkgaW4gZGF0YSkpIGRhdGFba2V5XSA9IHZhbHVlO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfb2JqZWN0X3RvX2tleV9saXN0KG8pIHtcblx0ICAgIHZhciBsID0gW107XG5cdCAgICB1dGlscy5lYWNoKG8sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdCAgICAgIGwucHVzaChrZXkpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gbDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfb2JqZWN0X3RvX2tleV9saXN0X3NvcnRlZChvKSB7XG5cdCAgICByZXR1cm4gX29iamVjdF90b19rZXlfbGlzdChvKS5zb3J0KCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX2dldF9wYW1fc2lnbl9pbnB1dF9mcm9tX3BhcmFtcyhwYXJhbXMpIHtcblx0ICAgIHZhciBzaSA9ICcnO1xuXHQgICAgdmFyIGwgPSBfb2JqZWN0X3RvX2tleV9saXN0X3NvcnRlZChwYXJhbXMpO1xuXG5cdCAgICBmb3IgKHZhciBpIGluIGwpIHtcblx0ICAgICAgdmFyIGsgPSBsW2ldO1xuXHQgICAgICBzaSArPSBrICsgJz0nICsgdXRpbHMucGFtRW5jb2RlKHBhcmFtc1trXSk7XG5cdCAgICAgIGlmIChpICE9IGwubGVuZ3RoIC0gMSkgc2kgKz0gJyYnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHNpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHZhbGlkYXRlX3ByZXNlbmNlX2hlYXJ0YmVhdChoZWFydGJlYXQsIGN1cl9oZWFydGJlYXQsIGVycm9yKSB7XG5cdCAgICB2YXIgZXJyID0gZmFsc2U7XG5cblx0ICAgIGlmICh0eXBlb2YgaGVhcnRiZWF0ID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgICByZXR1cm4gY3VyX2hlYXJ0YmVhdDtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBoZWFydGJlYXQgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIGlmIChoZWFydGJlYXQgPiBQUkVTRU5DRV9IQl9USFJFU0hPTEQgfHwgaGVhcnRiZWF0ID09IDApIHtcblx0ICAgICAgICBlcnIgPSBmYWxzZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBlcnIgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFydGJlYXQgPT09ICdib29sZWFuJykge1xuXHQgICAgICBpZiAoIWhlYXJ0YmVhdCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBQUkVTRU5DRV9IQl9ERUZBVUxUO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBlcnIgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZXJyKSB7XG5cdCAgICAgIGVycm9yICYmIGVycm9yKCdQcmVzZW5jZSBIZWFydGJlYXQgdmFsdWUgaW52YWxpZC4gVmFsaWQgcmFuZ2UgKCB4ID4gJyArIFBSRVNFTkNFX0hCX1RIUkVTSE9MRCArICcgb3IgeCA9IDApLiBDdXJyZW50IFZhbHVlIDogJyArIChjdXJfaGVhcnRiZWF0IHx8IFBSRVNFTkNFX0hCX1RIUkVTSE9MRCkpO1xuXHQgICAgICByZXR1cm4gY3VyX2hlYXJ0YmVhdCB8fCBQUkVTRU5DRV9IQl9USFJFU0hPTEQ7XG5cdCAgICB9IGVsc2UgcmV0dXJuIGhlYXJ0YmVhdDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBlbmNyeXB0KGlucHV0LCBrZXkpIHtcblx0ICAgIHJldHVybiBjcnlwdG9fb2JqWydlbmNyeXB0J10oaW5wdXQsIGtleSB8fCBDSVBIRVJfS0VZKSB8fCBpbnB1dDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkZWNyeXB0KGlucHV0LCBrZXkpIHtcblx0ICAgIHJldHVybiBjcnlwdG9fb2JqWydkZWNyeXB0J10oaW5wdXQsIGtleSB8fCBDSVBIRVJfS0VZKSB8fFxuXHQgICAgICBjcnlwdG9fb2JqWydkZWNyeXB0J10oaW5wdXQsIENJUEhFUl9LRVkpIHx8XG5cdCAgICAgIGlucHV0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGVycm9yX2NvbW1vbihtZXNzYWdlLCBjYWxsYmFjaykge1xuXHQgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soeyBlcnJvcjogbWVzc2FnZSB8fCAnZXJyb3Igb2NjdXJyZWQnIH0pO1xuXHQgICAgZXJyb3IgJiYgZXJyb3IobWVzc2FnZSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX3ByZXNlbmNlX2hlYXJ0YmVhdCgpIHtcblx0ICAgIGNsZWFyVGltZW91dChQUkVTRU5DRV9IQl9USU1FT1VUKTtcblxuXHQgICAgaWYgKCFQUkVTRU5DRV9IQl9JTlRFUlZBTCB8fCBQUkVTRU5DRV9IQl9JTlRFUlZBTCA+PSA1MDAgfHxcblx0ICAgICAgUFJFU0VOQ0VfSEJfSU5URVJWQUwgPCAxIHx8XG5cdCAgICAgICghZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTLCB0cnVlKS5sZW5ndGggJiYgIWdlbmVyYXRlX2NoYW5uZWxfZ3JvdXBfbGlzdChDSEFOTkVMX0dST1VQUywgdHJ1ZSkubGVuZ3RoKSkge1xuXHQgICAgICBQUkVTRU5DRV9IQl9SVU5OSU5HID0gZmFsc2U7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgUFJFU0VOQ0VfSEJfUlVOTklORyA9IHRydWU7XG5cdCAgICBTRUxGWydwcmVzZW5jZV9oZWFydGJlYXQnXSh7XG5cdCAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAocikge1xuXHQgICAgICAgIFBSRVNFTkNFX0hCX1RJTUVPVVQgPSB1dGlscy50aW1lb3V0KF9wcmVzZW5jZV9oZWFydGJlYXQsIChQUkVTRU5DRV9IQl9JTlRFUlZBTCkgKiBTRUNPTkQpO1xuXHQgICAgICB9LFxuXHQgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBlcnJvciAmJiBlcnJvcignUHJlc2VuY2UgSGVhcnRiZWF0IHVuYWJsZSB0byByZWFjaCBQdWJudWIgc2VydmVycy4nICsgSlNPTi5zdHJpbmdpZnkoZSkpO1xuXHQgICAgICAgIFBSRVNFTkNFX0hCX1RJTUVPVVQgPSB1dGlscy50aW1lb3V0KF9wcmVzZW5jZV9oZWFydGJlYXQsIChQUkVTRU5DRV9IQl9JTlRFUlZBTCkgKiBTRUNPTkQpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzdGFydF9wcmVzZW5jZV9oZWFydGJlYXQoKSB7XG5cdCAgICAhUFJFU0VOQ0VfSEJfUlVOTklORyAmJiBfcHJlc2VuY2VfaGVhcnRiZWF0KCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcHVibGlzaChuZXh0KSB7XG5cdCAgICBpZiAoTk9fV0FJVF9GT1JfUEVORElORykge1xuXHQgICAgICBpZiAoIVBVQl9RVUVVRS5sZW5ndGgpIHJldHVybjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChuZXh0KSBQVUJfUVVFVUUuc2VuZGluZyA9IDA7XG5cdCAgICAgIGlmIChQVUJfUVVFVUUuc2VuZGluZyB8fCAhUFVCX1FVRVVFLmxlbmd0aCkgcmV0dXJuO1xuXHQgICAgICBQVUJfUVVFVUUuc2VuZGluZyA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHhkcihQVUJfUVVFVUUuc2hpZnQoKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZWFjaF9jaGFubmVsX2dyb3VwKGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgY291bnQgPSAwO1xuXG5cdCAgICB1dGlscy5lYWNoKGdlbmVyYXRlX2NoYW5uZWxfZ3JvdXBfbGlzdChDSEFOTkVMX0dST1VQUyksIGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgIHZhciBjaGFuZyA9IENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdO1xuXG5cdCAgICAgIGlmICghY2hhbmcpIHJldHVybjtcblxuXHQgICAgICBjb3VudCsrO1xuXHQgICAgICAoY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge1xuXHQgICAgICB9KShjaGFuZyk7XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIGNvdW50O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGVhY2hfY2hhbm5lbChjYWxsYmFjaykge1xuXHQgICAgdmFyIGNvdW50ID0gMDtcblxuXHQgICAgdXRpbHMuZWFjaChnZW5lcmF0ZV9jaGFubmVsX2xpc3QoQ0hBTk5FTFMpLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICB2YXIgY2hhbiA9IENIQU5ORUxTW2NoYW5uZWxdO1xuXG5cdCAgICAgIGlmICghY2hhbikgcmV0dXJuO1xuXG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICAgIChjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIH0pKGNoYW4pO1xuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiBjb3VudDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKSB7XG5cdCAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09ICdvYmplY3QnKSB7XG5cdCAgICAgIGlmIChyZXNwb25zZVsnZXJyb3InXSkge1xuXHQgICAgICAgIHZhciBjYWxsYmFja19kYXRhID0ge307XG5cblx0ICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSkge1xuXHQgICAgICAgICAgY2FsbGJhY2tfZGF0YVsnbWVzc2FnZSddID0gcmVzcG9uc2VbJ21lc3NhZ2UnXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAocmVzcG9uc2VbJ3BheWxvYWQnXSkge1xuXHQgICAgICAgICAgY2FsbGJhY2tfZGF0YVsncGF5bG9hZCddID0gcmVzcG9uc2VbJ3BheWxvYWQnXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBlcnIgJiYgZXJyKGNhbGxiYWNrX2RhdGEpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAocmVzcG9uc2VbJ3BheWxvYWQnXSkge1xuXHQgICAgICAgIGlmIChyZXNwb25zZVsnbmV4dF9wYWdlJ10pIHtcblx0ICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlWydwYXlsb2FkJ10sIHJlc3BvbnNlWyduZXh0X3BhZ2UnXSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlWydwYXlsb2FkJ10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpIHtcblx0ICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT0gJ29iamVjdCcgJiYgcmVzcG9uc2VbJ2Vycm9yJ10pIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrX2RhdGEgPSB7fTtcblxuXHQgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSkge1xuXHQgICAgICAgIGNhbGxiYWNrX2RhdGFbJ21lc3NhZ2UnXSA9IHJlc3BvbnNlWydtZXNzYWdlJ107XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAocmVzcG9uc2VbJ3BheWxvYWQnXSkge1xuXHQgICAgICAgIGNhbGxiYWNrX2RhdGFbJ3BheWxvYWQnXSA9IHJlc3BvbnNlWydwYXlsb2FkJ107XG5cdCAgICAgIH1cblxuXHQgICAgICBlcnIgJiYgZXJyKGNhbGxiYWNrX2RhdGEpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBlcnIgJiYgZXJyKHJlc3BvbnNlKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBDUihhcmdzLCBjYWxsYmFjaywgdXJsMSwgZGF0YSkge1xuXHQgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBjYWxsYmFjaztcblx0ICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGVycm9yO1xuXHQgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblxuXHQgICAgZGF0YSA9IGRhdGEgfHwge307XG5cblx0ICAgIGlmICghZGF0YVsnYXV0aCddKSB7XG5cdCAgICAgIGRhdGFbJ2F1dGgnXSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICB9XG5cblx0ICAgIHZhciB1cmwgPSBbXG5cdCAgICAgIFNURF9PUklHSU4sICd2MScsICdjaGFubmVsLXJlZ2lzdHJhdGlvbicsXG5cdCAgICAgICdzdWIta2V5JywgU1VCU0NSSUJFX0tFWVxuXHQgICAgXTtcblxuXHQgICAgdXJsLnB1c2guYXBwbHkodXJsLCB1cmwxKTtcblxuXHQgICAgaWYgKGpzb25wKSBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cblx0ICAgIHhkcih7XG5cdCAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpLFxuXHQgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgfSxcblx0ICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgfSxcblx0ICAgICAgdXJsOiB1cmxcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIC8vIEFubm91bmNlIExlYXZlIEV2ZW50XG5cdCAgdmFyIFNFTEYgPSB7XG5cdCAgICBMRUFWRTogZnVuY3Rpb24gKGNoYW5uZWwsIGJsb2NraW5nLCBhdXRoX2tleSwgY2FsbGJhY2ssIGVycm9yKSB7XG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBhdXRoX2tleSB8fCBBVVRIX0tFWSB9O1xuXHQgICAgICB2YXIgb3JpZ2luID0gbmV4dG9yaWdpbihPUklHSU4pO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGVycm9yIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgdXJsO1xuXHQgICAgICB2YXIgcGFyYW1zO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICAgIC8vIFByZXZlbnQgTGVhdmluZyBhIFByZXNlbmNlIENoYW5uZWxcblx0ICAgICAgaWYgKGNoYW5uZWwuaW5kZXhPZihQUkVTRU5DRV9TVUZGSVgpID4gMCkgcmV0dXJuIHRydWU7XG5cblxuXHQgICAgICBpZiAoQ09NUEFUSUJMRV8zNSkge1xuXHQgICAgICAgIGlmICghU1NMKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgaWYgKGpzb25wID09ICcwJykgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKE5PTEVBVkUpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHVybCA9IFtcblx0ICAgICAgICBvcmlnaW4sICd2MicsICdwcmVzZW5jZScsICdzdWJfa2V5Jyxcblx0ICAgICAgICBTVUJTQ1JJQkVfS0VZLCAnY2hhbm5lbCcsIHV0aWxzLmVuY29kZShjaGFubmVsKSwgJ2xlYXZlJ1xuXHQgICAgICBdO1xuXG5cdCAgICAgIHBhcmFtcyA9IF9nZXRfdXJsX3BhcmFtcyhkYXRhKTtcblxuXG5cdCAgICAgIGlmIChzZW5kQmVhY29uKSB7XG5cdCAgICAgICAgdmFyIHVybF9zdHJpbmcgPSB1dGlscy5idWlsZFVSTCh1cmwsIHBhcmFtcyk7XG5cdCAgICAgICAgaWYgKHNlbmRCZWFjb24odXJsX3N0cmluZykpIHtcblx0ICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHsgc3RhdHVzOiAyMDAsIGFjdGlvbjogJ2xlYXZlJywgbWVzc2FnZTogJ09LJywgc2VydmljZTogJ1ByZXNlbmNlJyB9KTtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBibG9ja2luZzogYmxvY2tpbmcgfHwgU1NMLFxuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBwYXJhbXMsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogdXJsXG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0sXG5cblx0ICAgIExFQVZFX0dST1VQOiBmdW5jdGlvbiAoY2hhbm5lbF9ncm91cCwgYmxvY2tpbmcsIGF1dGhfa2V5LCBjYWxsYmFjaywgZXJyb3IpIHtcblx0ICAgICAgdmFyIGRhdGEgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IGF1dGhfa2V5IHx8IEFVVEhfS0VZIH07XG5cdCAgICAgIHZhciBvcmlnaW4gPSBuZXh0b3JpZ2luKE9SSUdJTik7XG5cdCAgICAgIHZhciB1cmw7XG5cdCAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgZXJyID0gZXJyb3IgfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cblx0ICAgICAgLy8gUHJldmVudCBMZWF2aW5nIGEgUHJlc2VuY2UgQ2hhbm5lbCBHcm91cFxuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cC5pbmRleE9mKFBSRVNFTkNFX1NVRkZJWCkgPiAwKSByZXR1cm4gdHJ1ZTtcblxuXHQgICAgICBpZiAoQ09NUEFUSUJMRV8zNSkge1xuXHQgICAgICAgIGlmICghU1NMKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgaWYgKGpzb25wID09ICcwJykgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKE5PTEVBVkUpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXAgJiYgY2hhbm5lbF9ncm91cC5sZW5ndGggPiAwKSBkYXRhWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3VwO1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICB1cmwgPSBbXG5cdCAgICAgICAgb3JpZ2luLCAndjInLCAncHJlc2VuY2UnLCAnc3ViX2tleScsXG5cdCAgICAgICAgU1VCU0NSSUJFX0tFWSwgJ2NoYW5uZWwnLCB1dGlscy5lbmNvZGUoJywnKSwgJ2xlYXZlJ1xuXHQgICAgICBdO1xuXG5cdCAgICAgIHBhcmFtcyA9IF9nZXRfdXJsX3BhcmFtcyhkYXRhKTtcblxuXHQgICAgICBpZiAoc2VuZEJlYWNvbikge1xuXHQgICAgICAgIHZhciB1cmxfc3RyaW5nID0gdXRpbHMuYnVpbGRVUkwodXJsLCBwYXJhbXMpO1xuXHQgICAgICAgIGlmIChzZW5kQmVhY29uKHVybF9zdHJpbmcpKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh7IHN0YXR1czogMjAwLCBhY3Rpb246ICdsZWF2ZScsIG1lc3NhZ2U6ICdPSycsIHNlcnZpY2U6ICdQcmVzZW5jZScgfSk7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGJsb2NraW5nOiBibG9ja2luZyB8fCBTU0wsXG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IHBhcmFtcyxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSxcblxuXHQgICAgc2V0X3Jlc3VtZWQ6IGZ1bmN0aW9uIChyZXN1bWVkKSB7XG5cdCAgICAgIFJFU1VNRUQgPSByZXN1bWVkO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X2NpcGhlcl9rZXk6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIENJUEhFUl9LRVk7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRfY2lwaGVyX2tleTogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICBDSVBIRVJfS0VZID0ga2V5O1xuXHQgICAgfSxcblxuXHQgICAgcmF3X2VuY3J5cHQ6IGZ1bmN0aW9uIChpbnB1dCwga2V5KSB7XG5cdCAgICAgIHJldHVybiBlbmNyeXB0KGlucHV0LCBrZXkpO1xuXHQgICAgfSxcblxuXHQgICAgcmF3X2RlY3J5cHQ6IGZ1bmN0aW9uIChpbnB1dCwga2V5KSB7XG5cdCAgICAgIHJldHVybiBkZWNyeXB0KGlucHV0LCBrZXkpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X2hlYXJ0YmVhdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gUFJFU0VOQ0VfSEI7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRfaGVhcnRiZWF0OiBmdW5jdGlvbiAoaGVhcnRiZWF0LCBoZWFydGJlYXRfaW50ZXJ2YWwpIHtcblx0ICAgICAgUFJFU0VOQ0VfSEIgPSB2YWxpZGF0ZV9wcmVzZW5jZV9oZWFydGJlYXQoaGVhcnRiZWF0LCBQUkVTRU5DRV9IQiwgZXJyb3IpO1xuXHQgICAgICBQUkVTRU5DRV9IQl9JTlRFUlZBTCA9IGhlYXJ0YmVhdF9pbnRlcnZhbCB8fCAoUFJFU0VOQ0VfSEIgLyAyKSAtIDE7XG5cdCAgICAgIGlmIChQUkVTRU5DRV9IQiA9PSAyKSB7XG5cdCAgICAgICAgUFJFU0VOQ0VfSEJfSU5URVJWQUwgPSAxO1xuXHQgICAgICB9XG5cdCAgICAgIENPTk5FQ1QoKTtcblx0ICAgICAgX3ByZXNlbmNlX2hlYXJ0YmVhdCgpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X2hlYXJ0YmVhdF9pbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gUFJFU0VOQ0VfSEJfSU5URVJWQUw7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRfaGVhcnRiZWF0X2ludGVydmFsOiBmdW5jdGlvbiAoaGVhcnRiZWF0X2ludGVydmFsKSB7XG5cdCAgICAgIFBSRVNFTkNFX0hCX0lOVEVSVkFMID0gaGVhcnRiZWF0X2ludGVydmFsO1xuXHQgICAgICBfcHJlc2VuY2VfaGVhcnRiZWF0KCk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRfdmVyc2lvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gU0RLX1ZFUjtcblx0ICAgIH0sXG5cblx0ICAgIGdldEdjbU1lc3NhZ2VPYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkYXRhOiBvYmpcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEFwbnNNZXNzYWdlT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHZhciB4ID0ge1xuXHQgICAgICAgIGFwczogeyBiYWRnZTogMSwgYWxlcnQ6ICcnIH1cblx0ICAgICAgfTtcblx0ICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcblx0ICAgICAgICBrW3hdID0gb2JqW2tdO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB4O1xuXHQgICAgfSxcblxuXHQgICAgX2FkZF9wYXJhbTogZnVuY3Rpb24gKGtleSwgdmFsKSB7XG5cdCAgICAgIHBhcmFtc1trZXldID0gdmFsO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBuc19jaCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXTtcblx0ICAgICAgdmFyIGNoYW5uZWxzID0gYXJnc1snY2hhbm5lbHMnXSB8fCBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBjbG9hayA9IGFyZ3NbJ2Nsb2FrJ107XG5cdCAgICAgIHZhciBuYW1lc3BhY2U7XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwO1xuXHQgICAgICB2YXIgdXJsID0gW107XG5cdCAgICAgIHZhciBkYXRhID0ge307XG5cdCAgICAgIHZhciBtb2RlID0gYXJnc1snbW9kZSddIHx8ICdhZGQnO1xuXG5cblx0ICAgICAgaWYgKG5zX2NoKSB7XG5cdCAgICAgICAgdmFyIG5zX2NoX2EgPSBuc19jaC5zcGxpdCgnOicpO1xuXG5cdCAgICAgICAgaWYgKG5zX2NoX2EubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgbmFtZXNwYWNlID0gKG5zX2NoX2FbMF0gPT09ICcqJykgPyBudWxsIDogbnNfY2hfYVswXTtcblxuXHQgICAgICAgICAgY2hhbm5lbF9ncm91cCA9IG5zX2NoX2FbMV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGNoYW5uZWxfZ3JvdXAgPSBuc19jaF9hWzBdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIG5hbWVzcGFjZSAmJiB1cmwucHVzaCgnbmFtZXNwYWNlJykgJiYgdXJsLnB1c2godXRpbHMuZW5jb2RlKG5hbWVzcGFjZSkpO1xuXG5cdCAgICAgIHVybC5wdXNoKCdjaGFubmVsLWdyb3VwJyk7XG5cblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXAgJiYgY2hhbm5lbF9ncm91cCAhPT0gJyonKSB7XG5cdCAgICAgICAgdXJsLnB1c2goY2hhbm5lbF9ncm91cCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY2hhbm5lbHMpIHtcblx0ICAgICAgICBpZiAodXRpbHMuaXNBcnJheShjaGFubmVscykpIHtcblx0ICAgICAgICAgIGNoYW5uZWxzID0gY2hhbm5lbHMuam9pbignLCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBkYXRhW21vZGVdID0gY2hhbm5lbHM7XG5cdCAgICAgICAgZGF0YVsnY2xvYWsnXSA9IChDTE9BSykgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChtb2RlID09PSAncmVtb3ZlJykgdXJsLnB1c2goJ3JlbW92ZScpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBjbG9hayAhPSAndW5kZWZpbmVkJykgZGF0YVsnY2xvYWsnXSA9IChjbG9haykgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG5cdCAgICAgIENSKGFyZ3MsIGNhbGxiYWNrLCB1cmwsIGRhdGEpO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9saXN0X2dyb3VwczogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBuYW1lc3BhY2U7XG5cblx0ICAgICAgbmFtZXNwYWNlID0gYXJnc1snbmFtZXNwYWNlJ10gfHwgYXJnc1snbnMnXSB8fCBhcmdzWydjaGFubmVsX2dyb3VwJ10gfHwgbnVsbDtcblx0ICAgICAgaWYgKG5hbWVzcGFjZSkge1xuXHQgICAgICAgIGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSA9IG5hbWVzcGFjZSArICc6Kic7XG5cdCAgICAgIH1cblxuXHQgICAgICBTRUxGWydjaGFubmVsX2dyb3VwJ10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9saXN0X2NoYW5uZWxzOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsX2dyb3VwJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsIEdyb3VwJyk7XG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX3JlbW92ZV9jaGFubmVsOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsX2dyb3VwJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsIEdyb3VwJyk7XG5cdCAgICAgIGlmICghYXJnc1snY2hhbm5lbCddICYmICFhcmdzWydjaGFubmVscyddKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCcpO1xuXG5cdCAgICAgIGFyZ3NbJ21vZGUnXSA9ICdyZW1vdmUnO1xuXHQgICAgICBTRUxGWydjaGFubmVsX2dyb3VwJ10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9yZW1vdmVfZ3JvdXA6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBpZiAoIWFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwgR3JvdXAnKTtcblx0ICAgICAgaWYgKGFyZ3NbJ2NoYW5uZWwnXSkgcmV0dXJuIGVycm9yKCdVc2UgY2hhbm5lbF9ncm91cF9yZW1vdmVfY2hhbm5lbCBpZiB5b3Ugd2FudCB0byByZW1vdmUgYSBjaGFubmVsIGZyb20gYSBncm91cC4nKTtcblxuXHQgICAgICBhcmdzWydtb2RlJ10gPSAncmVtb3ZlJztcblx0ICAgICAgU0VMRlsnY2hhbm5lbF9ncm91cCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfYWRkX2NoYW5uZWw6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBpZiAoIWFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwgR3JvdXAnKTtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsJ10gJiYgIWFyZ3NbJ2NoYW5uZWxzJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsJyk7XG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX2Nsb2FrOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKHR5cGVvZiBhcmdzWydjbG9hayddID09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgY2FsbGJhY2soQ0xPQUspO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBDTE9BSyA9IGFyZ3NbJ2Nsb2FrJ107XG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX2xpc3RfbmFtZXNwYWNlczogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciB1cmwgPSBbJ25hbWVzcGFjZSddO1xuXHQgICAgICBDUihhcmdzLCBjYWxsYmFjaywgdXJsKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfcmVtb3ZlX25hbWVzcGFjZTogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciB1cmwgPSBbJ25hbWVzcGFjZScsIGFyZ3NbJ25hbWVzcGFjZSddLCAncmVtb3ZlJ107XG5cdCAgICAgIENSKGFyZ3MsIGNhbGxiYWNrLCB1cmwpO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuaGlzdG9yeSh7XG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdF9jaGFubmVsJyxcblx0ICAgICBsaW1pdCAgICA6IDEwMCxcblx0ICAgICBjYWxsYmFjayA6IGZ1bmN0aW9uKGhpc3RvcnkpIHsgfVxuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBoaXN0b3J5OiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBjYWxsYmFjaztcblx0ICAgICAgdmFyIGNvdW50ID0gYXJnc1snY291bnQnXSB8fCBhcmdzWydsaW1pdCddIHx8IDEwMDtcblx0ICAgICAgdmFyIHJldmVyc2UgPSBhcmdzWydyZXZlcnNlJ10gfHwgJ2ZhbHNlJztcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBjaXBoZXJfa2V5ID0gYXJnc1snY2lwaGVyX2tleSddO1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBzdGFydCA9IGFyZ3NbJ3N0YXJ0J107XG5cdCAgICAgIHZhciBlbmQgPSBhcmdzWydlbmQnXTtcblx0ICAgICAgdmFyIGluY2x1ZGVfdG9rZW4gPSBhcmdzWydpbmNsdWRlX3Rva2VuJ107XG5cdCAgICAgIHZhciBzdHJpbmdfbXNnX3Rva2VuID0gYXJnc1snc3RyaW5nX21lc3NhZ2VfdG9rZW4nXSB8fCBmYWxzZTtcblx0ICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgQ2hhbm5lbFxuXHQgICAgICBpZiAoIWNoYW5uZWwgJiYgIWNoYW5uZWxfZ3JvdXApIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsJyk7XG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgcGFyYW1zWydzdHJpbmd0b2tlbiddID0gJ3RydWUnO1xuXHQgICAgICBwYXJhbXNbJ2NvdW50J10gPSBjb3VudDtcblx0ICAgICAgcGFyYW1zWydyZXZlcnNlJ10gPSByZXZlcnNlO1xuXHQgICAgICBwYXJhbXNbJ2F1dGgnXSA9IGF1dGhfa2V5O1xuXG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgcGFyYW1zWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3VwO1xuXHQgICAgICAgIGlmICghY2hhbm5lbCkge1xuXHQgICAgICAgICAgY2hhbm5lbCA9ICcsJztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGpzb25wKSBwYXJhbXNbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgaWYgKHN0YXJ0KSBwYXJhbXNbJ3N0YXJ0J10gPSBzdGFydDtcblx0ICAgICAgaWYgKGVuZCkgcGFyYW1zWydlbmQnXSA9IGVuZDtcblx0ICAgICAgaWYgKGluY2x1ZGVfdG9rZW4pIHBhcmFtc1snaW5jbHVkZV90b2tlbiddID0gJ3RydWUnO1xuXHQgICAgICBpZiAoc3RyaW5nX21zZ190b2tlbikgcGFyYW1zWydzdHJpbmdfbWVzc2FnZV90b2tlbiddID0gJ3RydWUnO1xuXG5cdCAgICAgIC8vIFNlbmQgTWVzc2FnZVxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMocGFyYW1zKSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT0gJ29iamVjdCcgJiYgcmVzcG9uc2VbJ2Vycm9yJ10pIHtcblx0ICAgICAgICAgICAgZXJyKHsgbWVzc2FnZTogcmVzcG9uc2VbJ21lc3NhZ2UnXSwgcGF5bG9hZDogcmVzcG9uc2VbJ3BheWxvYWQnXSB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gcmVzcG9uc2VbMF07XG5cdCAgICAgICAgICB2YXIgZGVjcnlwdGVkX21lc3NhZ2VzID0gW107XG5cdCAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IG1lc3NhZ2VzLmxlbmd0aDsgYSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpbmNsdWRlX3Rva2VuKSB7XG5cdCAgICAgICAgICAgICAgdmFyIG5ld19tZXNzYWdlID0gZGVjcnlwdChtZXNzYWdlc1thXVsnbWVzc2FnZSddLCBjaXBoZXJfa2V5KTtcblx0ICAgICAgICAgICAgICB2YXIgdGltZXRva2VuID0gbWVzc2FnZXNbYV1bJ3RpbWV0b2tlbiddO1xuXHQgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBkZWNyeXB0ZWRfbWVzc2FnZXNbJ3B1c2gnXSh7IG1lc3NhZ2U6IEpTT05bJ3BhcnNlJ10obmV3X21lc3NhZ2UpLCB0aW1ldG9rZW46IHRpbWV0b2tlbiB9KTtcblx0ICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICBkZWNyeXB0ZWRfbWVzc2FnZXNbJ3B1c2gnXSgoeyBtZXNzYWdlOiBuZXdfbWVzc2FnZSwgdGltZXRva2VuOiB0aW1ldG9rZW4gfSkpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICB2YXIgbmV3X21lc3NhZ2UgPSBkZWNyeXB0KG1lc3NhZ2VzW2FdLCBjaXBoZXJfa2V5KTtcblx0ICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZGVjcnlwdGVkX21lc3NhZ2VzWydwdXNoJ10oSlNPTlsncGFyc2UnXShuZXdfbWVzc2FnZSkpO1xuXHQgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIGRlY3J5cHRlZF9tZXNzYWdlc1sncHVzaCddKChuZXdfbWVzc2FnZSkpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgY2FsbGJhY2soW2RlY3J5cHRlZF9tZXNzYWdlcywgcmVzcG9uc2VbMV0sIHJlc3BvbnNlWzJdXSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MicsICdoaXN0b3J5JywgJ3N1Yi1rZXknLFxuXHQgICAgICAgICAgU1VCU0NSSUJFX0tFWSwgJ2NoYW5uZWwnLCB1dGlscy5lbmNvZGUoY2hhbm5lbClcblx0ICAgICAgICBdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIucmVwbGF5KHtcblx0ICAgICBzb3VyY2UgICAgICA6ICdteV9jaGFubmVsJyxcblx0ICAgICBkZXN0aW5hdGlvbiA6ICduZXdfY2hhbm5lbCdcblx0ICAgICB9KTtcblx0ICAgICAqL1xuXHQgICAgcmVwbGF5OiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIHNvdXJjZSA9IGFyZ3NbJ3NvdXJjZSddO1xuXHQgICAgICB2YXIgZGVzdGluYXRpb24gPSBhcmdzWydkZXN0aW5hdGlvbiddO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgc3RvcCA9IGFyZ3NbJ3N0b3AnXTtcblx0ICAgICAgdmFyIHN0YXJ0ID0gYXJnc1snc3RhcnQnXTtcblx0ICAgICAgdmFyIGVuZCA9IGFyZ3NbJ2VuZCddO1xuXHQgICAgICB2YXIgcmV2ZXJzZSA9IGFyZ3NbJ3JldmVyc2UnXTtcblx0ICAgICAgdmFyIGxpbWl0ID0gYXJnc1snbGltaXQnXTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIGRhdGEgPSB7fTtcblx0ICAgICAgdmFyIHVybDtcblxuXHQgICAgICAvLyBDaGVjayBVc2VyIElucHV0XG5cdCAgICAgIGlmICghc291cmNlKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU291cmNlIENoYW5uZWwnKTtcblx0ICAgICAgaWYgKCFkZXN0aW5hdGlvbikgcmV0dXJuIGVycm9yKCdNaXNzaW5nIERlc3RpbmF0aW9uIENoYW5uZWwnKTtcblx0ICAgICAgaWYgKCFQVUJMSVNIX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFB1Ymxpc2ggS2V5Jyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICAvLyBTZXR1cCBVUkwgUGFyYW1zXG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgaWYgKHN0b3ApIGRhdGFbJ3N0b3AnXSA9ICdhbGwnO1xuXHQgICAgICBpZiAocmV2ZXJzZSkgZGF0YVsncmV2ZXJzZSddID0gJ3RydWUnO1xuXHQgICAgICBpZiAoc3RhcnQpIGRhdGFbJ3N0YXJ0J10gPSBzdGFydDtcblx0ICAgICAgaWYgKGVuZCkgZGF0YVsnZW5kJ10gPSBlbmQ7XG5cdCAgICAgIGlmIChsaW1pdCkgZGF0YVsnY291bnQnXSA9IGxpbWl0O1xuXG5cdCAgICAgIGRhdGFbJ2F1dGgnXSA9IGF1dGhfa2V5O1xuXG5cdCAgICAgIC8vIENvbXBvc2UgVVJMIFBhcnRzXG5cdCAgICAgIHVybCA9IFtcblx0ICAgICAgICBTVERfT1JJR0lOLCAndjEnLCAncmVwbGF5Jyxcblx0ICAgICAgICBQVUJMSVNIX0tFWSwgU1VCU0NSSUJFX0tFWSxcblx0ICAgICAgICBzb3VyY2UsIGRlc3RpbmF0aW9uXG5cdCAgICAgIF07XG5cblx0ICAgICAgLy8gU3RhcnQgKG9yIFN0b3ApIFJlcGxheSFcblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKFswLCAnRGlzY29ubmVjdGVkJ10pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiB1cmwsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuYXV0aCgnQUpGTEtBSlNES0xBJyk7XG5cdCAgICAgKi9cblx0ICAgIGF1dGg6IGZ1bmN0aW9uIChhdXRoKSB7XG5cdCAgICAgIEFVVEhfS0VZID0gYXV0aDtcblx0ICAgICAgQ09OTkVDVCgpO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIudGltZShmdW5jdGlvbih0aW1lKXsgfSk7XG5cdCAgICAgKi9cblx0ICAgIHRpbWU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBBVVRIX0tFWSB9O1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgdXJsOiBbU1REX09SSUdJTiwgJ3RpbWUnLCBqc29ucF0sXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZVswXSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBjYWxsYmFjaygwKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIucHVibGlzaCh7XG5cdCAgICAgY2hhbm5lbCA6ICdteV9jaGF0X2NoYW5uZWwnLFxuXHQgICAgIG1lc3NhZ2UgOiAnaGVsbG8hJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBwdWJsaXNoOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIG1zZyA9IGFyZ3NbJ21lc3NhZ2UnXTtcblx0ICAgICAgaWYgKCFtc2cpIHJldHVybiBlcnJvcignTWlzc2luZyBNZXNzYWdlJyk7XG5cblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXSB8fCBtc2dbJ2NhbGxiYWNrJ10gfHwgYXJnc1snc3VjY2VzcyddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXSB8fCBtc2dbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIG1ldGEgPSBhcmdzWydtZXRhJ10gfHwgYXJnc1snbWV0YWRhdGEnXTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIGNpcGhlcl9rZXkgPSBhcmdzWydjaXBoZXJfa2V5J107XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IG1zZ1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIHBvc3QgPSBhcmdzWydwb3N0J10gfHwgZmFsc2U7XG5cdCAgICAgIHZhciBzdG9yZSA9ICgnc3RvcmVfaW5faGlzdG9yeScgaW4gYXJncykgPyBhcmdzWydzdG9yZV9pbl9oaXN0b3J5J10gOiB0cnVlO1xuXHQgICAgICB2YXIgcmVwbGljYXRlID0gKCdyZXBsaWNhdGUnIGluIGFyZ3MpID8gYXJnc1sncmVwbGljYXRlJ10gOiB0cnVlO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgYWRkX21zZyA9ICdwdXNoJztcblx0ICAgICAgdmFyIHBhcmFtcztcblx0ICAgICAgdmFyIHVybDtcblxuXHQgICAgICBpZiAoYXJnc1sncHJlcGVuZCddKSBhZGRfbXNnID0gJ3Vuc2hpZnQnO1xuXG5cdCAgICAgIGlmICghY2hhbm5lbCkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblx0ICAgICAgaWYgKCFQVUJMSVNIX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFB1Ymxpc2ggS2V5Jyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICBpZiAobXNnWydnZXRQdWJudWJNZXNzYWdlJ10pIHtcblx0ICAgICAgICBtc2cgPSBtc2dbJ2dldFB1Ym51Yk1lc3NhZ2UnXSgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gSWYgdHJ5aW5nIHRvIHNlbmQgT2JqZWN0XG5cdCAgICAgIG1zZyA9IEpTT05bJ3N0cmluZ2lmeSddKGVuY3J5cHQobXNnLCBjaXBoZXJfa2V5KSk7XG5cblx0ICAgICAgLy8gQ3JlYXRlIFVSTFxuXHQgICAgICB1cmwgPSBbXG5cdCAgICAgICAgU1REX09SSUdJTiwgJ3B1Ymxpc2gnLFxuXHQgICAgICAgIFBVQkxJU0hfS0VZLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgIDAsIHV0aWxzLmVuY29kZShjaGFubmVsKSxcblx0ICAgICAgICBqc29ucCwgdXRpbHMuZW5jb2RlKG1zZylcblx0ICAgICAgXTtcblxuXHQgICAgICBwYXJhbXMgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IGF1dGhfa2V5IH07XG5cblx0ICAgICAgaWYgKG1ldGEgJiYgdHlwZW9mIG1ldGEgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgcGFyYW1zWydtZXRhJ10gPSBKU09OLnN0cmluZ2lmeShtZXRhKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghc3RvcmUpIHBhcmFtc1snc3RvcmUnXSA9ICcwJztcblx0ICAgICAgaWYgKCFyZXBsaWNhdGUpIHBhcmFtc1snbm9yZXAnXSA9ICd0cnVlJztcblxuXHQgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIHBhcmFtc1snaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICAvLyBRdWV1ZSBNZXNzYWdlIFNlbmRcblx0ICAgICAgUFVCX1FVRVVFW2FkZF9tc2ddKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgdXJsOiB1cmwsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKHBhcmFtcyksXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgICAgcHVibGlzaCgxKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgICBwdWJsaXNoKDEpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgbW9kZTogKHBvc3QpID8gJ1BPU1QnIDogJ0dFVCdcblx0ICAgICAgfSk7XG5cblx0ICAgICAgLy8gU2VuZCBNZXNzYWdlXG5cdCAgICAgIHB1Ymxpc2goKTtcblx0ICAgIH0sXG5cblx0ICAgIGZpcmU6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBhcmdzLnN0b3JlX2luX2hpc3RvcnkgPSBmYWxzZTtcblx0ICAgICAgYXJncy5yZXBsaWNhdGUgPSBmYWxzZTtcblx0ICAgICAgU0VMRlsncHVibGlzaCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLnVuc3Vic2NyaWJlKHsgY2hhbm5lbCA6ICdteV9jaGF0JyB9KTtcblx0ICAgICAqL1xuXHQgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2hhbm5lbEFyZyA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxHcm91cEFyZyA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cblx0ICAgICAgaWYgKCFjaGFubmVsQXJnICYmICFjaGFubmVsR3JvdXBBcmcpIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsIG9yIENoYW5uZWwgR3JvdXAnKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXG5cdCAgICAgIGlmIChjaGFubmVsQXJnKSB7XG5cdCAgICAgICAgdmFyIGNoYW5uZWxzID0gdXRpbHMuaXNBcnJheShjaGFubmVsQXJnKSA/IGNoYW5uZWxBcmcgOiAoJycgKyBjaGFubmVsQXJnKS5zcGxpdCgnLCcpO1xuXHQgICAgICAgIHZhciBleGlzdGluZ0NoYW5uZWxzID0gW107XG5cdCAgICAgICAgdmFyIHByZXNlbmNlQ2hhbm5lbHMgPSBbXTtcblxuXHQgICAgICAgIHV0aWxzLmVhY2goY2hhbm5lbHMsIGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgICBpZiAoQ0hBTk5FTFNbY2hhbm5lbF0pIGV4aXN0aW5nQ2hhbm5lbHMucHVzaChjaGFubmVsKTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIC8vIGlmIHdlIGRvIG5vdCBoYXZlIGFueSBjaGFubmVscyB0byB1bnN1YnNjcmliZSBmcm9tLCB0cmlnZ2VyIGEgY2FsbGJhY2suXG5cdCAgICAgICAgaWYgKGV4aXN0aW5nQ2hhbm5lbHMubGVuZ3RoID09IDApIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKHsgYWN0aW9uOiAnbGVhdmUnIH0pO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFByZXBhcmUgcHJlc2VuY2UgY2hhbm5lbHNcblx0ICAgICAgICB1dGlscy5lYWNoKGV4aXN0aW5nQ2hhbm5lbHMsIGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgICBwcmVzZW5jZUNoYW5uZWxzLnB1c2goY2hhbm5lbCArIFBSRVNFTkNFX1NVRkZJWCk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICB1dGlscy5lYWNoKGV4aXN0aW5nQ2hhbm5lbHMuY29uY2F0KHByZXNlbmNlQ2hhbm5lbHMpLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgaWYgKGNoYW5uZWwgaW4gQ0hBTk5FTFMpIGRlbGV0ZSBDSEFOTkVMU1tjaGFubmVsXTtcblx0ICAgICAgICAgIGlmIChjaGFubmVsIGluIFNUQVRFKSBkZWxldGUgU1RBVEVbY2hhbm5lbF07XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBpZiAoQ0hBTk5FTFMubGVuZ3RoID09PSAwICYmIENIQU5ORUxfR1JPVVBTLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgVElNRVRPS0VOID0gMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgQ0JfQ0FMTEVEID0gdHJ1ZTtcblx0ICAgICAgICBpZiAoUkVBRFkpIHtcblx0ICAgICAgICAgIENCX0NBTExFRCA9IFNFTEZbJ0xFQVZFJ10oZXhpc3RpbmdDaGFubmVscy5qb2luKCcsJyksIDAsIGF1dGhfa2V5LCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFDQl9DQUxMRUQpIGNhbGxiYWNrKHsgYWN0aW9uOiAnbGVhdmUnIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGNoYW5uZWxHcm91cEFyZykge1xuXHQgICAgICAgIHZhciBjaGFubmVsR3JvdXBzID0gdXRpbHMuaXNBcnJheShjaGFubmVsR3JvdXBBcmcpID8gY2hhbm5lbEdyb3VwQXJnIDogKCcnICsgY2hhbm5lbEdyb3VwQXJnKS5zcGxpdCgnLCcpO1xuXHQgICAgICAgIHZhciBleGlzdGluZ0NoYW5uZWxHcm91cHMgPSBbXTtcblx0ICAgICAgICB2YXIgcHJlc2VuY2VDaGFubmVsR3JvdXBzID0gW107XG5cblx0ICAgICAgICB1dGlscy5lYWNoKGNoYW5uZWxHcm91cHMsIGZ1bmN0aW9uIChjaGFubmVsR3JvdXApIHtcblx0ICAgICAgICAgIGlmIChDSEFOTkVMX0dST1VQU1tjaGFubmVsR3JvdXBdKSBleGlzdGluZ0NoYW5uZWxHcm91cHMucHVzaChjaGFubmVsR3JvdXApO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLy8gaWYgd2UgZG8gbm90IGhhdmUgYW55IGNoYW5uZWwgZ3JvdXBzIHRvIHVuc3Vic2NyaWJlIGZyb20sIHRyaWdnZXIgYSBjYWxsYmFjay5cblx0ICAgICAgICBpZiAoZXhpc3RpbmdDaGFubmVsR3JvdXBzLmxlbmd0aCA9PSAwKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayh7IGFjdGlvbjogJ2xlYXZlJyB9KTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBQcmVwYXJlIHByZXNlbmNlIGNoYW5uZWxzXG5cdCAgICAgICAgdXRpbHMuZWFjaChleGlzdGluZ0NoYW5uZWxHcm91cHMsIGZ1bmN0aW9uIChjaGFubmVsR3JvdXApIHtcblx0ICAgICAgICAgIHByZXNlbmNlQ2hhbm5lbEdyb3Vwcy5wdXNoKGNoYW5uZWxHcm91cCArIFBSRVNFTkNFX1NVRkZJWCk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICB1dGlscy5lYWNoKGV4aXN0aW5nQ2hhbm5lbEdyb3Vwcy5jb25jYXQocHJlc2VuY2VDaGFubmVsR3JvdXBzKSwgZnVuY3Rpb24gKGNoYW5uZWxHcm91cCkge1xuXHQgICAgICAgICAgaWYgKGNoYW5uZWxHcm91cCBpbiBDSEFOTkVMX0dST1VQUykgZGVsZXRlIENIQU5ORUxfR1JPVVBTW2NoYW5uZWxHcm91cF07XG5cdCAgICAgICAgICBpZiAoY2hhbm5lbEdyb3VwIGluIFNUQVRFKSBkZWxldGUgU1RBVEVbY2hhbm5lbEdyb3VwXTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGlmIChDSEFOTkVMUy5sZW5ndGggPT09IDAgJiYgQ0hBTk5FTF9HUk9VUFMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICBUSU1FVE9LRU4gPSAwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBDQl9DQUxMRUQgPSB0cnVlO1xuXHQgICAgICAgIGlmIChSRUFEWSkge1xuXHQgICAgICAgICAgQ0JfQ0FMTEVEID0gU0VMRlsnTEVBVkVfR1JPVVAnXShleGlzdGluZ0NoYW5uZWxHcm91cHMuam9pbignLCcpLCAwLCBhdXRoX2tleSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghQ0JfQ0FMTEVEKSBjYWxsYmFjayh7IGFjdGlvbjogJ2xlYXZlJyB9KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIFJlc2V0IENvbm5lY3Rpb24gaWYgQ291bnQgTGVzc1xuXHQgICAgICBDT05ORUNUKCk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5zdWJzY3JpYmUoe1xuXHQgICAgIGNoYW5uZWwgIDogJ215X2NoYXQnXG5cdCAgICAgY2FsbGJhY2sgOiBmdW5jdGlvbihtZXNzYWdlKSB7IH1cblx0ICAgICB9KTtcblx0ICAgICAqL1xuXHQgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwID0gYXJnc1snY2hhbm5lbF9ncm91cCddO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBhcmdzWydjYWxsYmFjayddO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBhcmdzWydtZXNzYWdlJ107XG5cdCAgICAgIHZhciBjb25uZWN0ID0gYXJnc1snY29ubmVjdCddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgcmVjb25uZWN0ID0gYXJnc1sncmVjb25uZWN0J10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBkaXNjb25uZWN0ID0gYXJnc1snZGlzY29ubmVjdCddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgU1VCX0VSUk9SID0gYXJnc1snZXJyb3InXSB8fCBTVUJfRVJST1IgfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBpZGxlY2IgPSBhcmdzWydpZGxlJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBwcmVzZW5jZSA9IGFyZ3NbJ3ByZXNlbmNlJ10gfHwgMDtcblx0ICAgICAgdmFyIG5vaGVyZXN5bmMgPSBhcmdzWydub2hlcmVzeW5jJ10gfHwgMDtcblx0ICAgICAgdmFyIGJhY2tmaWxsID0gYXJnc1snYmFja2ZpbGwnXSB8fCAwO1xuXHQgICAgICB2YXIgdGltZXRva2VuID0gYXJnc1sndGltZXRva2VuJ10gfHwgMDtcblx0ICAgICAgdmFyIHN1Yl90aW1lb3V0ID0gYXJnc1sndGltZW91dCddIHx8IFNVQl9USU1FT1VUO1xuXHQgICAgICB2YXIgd2luZG93aW5nID0gYXJnc1snd2luZG93aW5nJ10gfHwgU1VCX1dJTkRPV0lORztcblx0ICAgICAgdmFyIHN0YXRlID0gYXJnc1snc3RhdGUnXTtcblx0ICAgICAgdmFyIGhlYXJ0YmVhdCA9IGFyZ3NbJ2hlYXJ0YmVhdCddIHx8IGFyZ3NbJ3BuZXhwaXJlcyddO1xuXHQgICAgICB2YXIgaGVhcnRiZWF0X2ludGVydmFsID0gYXJnc1snaGVhcnRiZWF0X2ludGVydmFsJ107XG5cdCAgICAgIHZhciByZXN0b3JlID0gYXJnc1sncmVzdG9yZSddIHx8IFNVQl9SRVNUT1JFO1xuXG5cdCAgICAgIEFVVEhfS0VZID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblxuXHQgICAgICAvLyBSZXN0b3JlIEVuYWJsZWQ/XG5cdCAgICAgIFNVQl9SRVNUT1JFID0gcmVzdG9yZTtcblxuXHQgICAgICAvLyBBbHdheXMgUmVzZXQgdGhlIFRUXG5cdCAgICAgIFRJTUVUT0tFTiA9IHRpbWV0b2tlbjtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFjaGFubmVsICYmICFjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgaWYgKGhlYXJ0YmVhdCB8fCBoZWFydGJlYXQgPT09IDAgfHwgaGVhcnRiZWF0X2ludGVydmFsIHx8IGhlYXJ0YmVhdF9pbnRlcnZhbCA9PT0gMCkge1xuXHQgICAgICAgIFNFTEZbJ3NldF9oZWFydGJlYXQnXShoZWFydGJlYXQsIGhlYXJ0YmVhdF9pbnRlcnZhbCk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBTZXR1cCBDaGFubmVsKHMpXG5cdCAgICAgIGlmIChjaGFubmVsKSB7XG5cdCAgICAgICAgdXRpbHMuZWFjaCgoY2hhbm5lbC5qb2luID8gY2hhbm5lbC5qb2luKCcsJykgOiAnJyArIGNoYW5uZWwpLnNwbGl0KCcsJyksXG5cdCAgICAgICAgICBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBDSEFOTkVMU1tjaGFubmVsXSB8fCB7fTtcblxuXHQgICAgICAgICAgICAvLyBTdG9yZSBDaGFubmVsIFN0YXRlXG5cdCAgICAgICAgICAgIENIQU5ORUxTW1NVQl9DSEFOTkVMID0gY2hhbm5lbF0gPSB7XG5cdCAgICAgICAgICAgICAgbmFtZTogY2hhbm5lbCxcblx0ICAgICAgICAgICAgICBjb25uZWN0ZWQ6IHNldHRpbmdzLmNvbm5lY3RlZCxcblx0ICAgICAgICAgICAgICBkaXNjb25uZWN0ZWQ6IHNldHRpbmdzLmRpc2Nvbm5lY3RlZCxcblx0ICAgICAgICAgICAgICBzdWJzY3JpYmVkOiAxLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBTVUJfQ0FMTEJBQ0sgPSBjYWxsYmFjayxcblx0ICAgICAgICAgICAgICBjaXBoZXJfa2V5OiBhcmdzWydjaXBoZXJfa2V5J10sXG5cdCAgICAgICAgICAgICAgY29ubmVjdDogY29ubmVjdCxcblx0ICAgICAgICAgICAgICBkaXNjb25uZWN0OiBkaXNjb25uZWN0LFxuXHQgICAgICAgICAgICAgIHJlY29ubmVjdDogcmVjb25uZWN0XG5cdCAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgaWYgKGNoYW5uZWwgaW4gc3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgIFNUQVRFW2NoYW5uZWxdID0gc3RhdGVbY2hhbm5lbF07XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIFNUQVRFW2NoYW5uZWxdID0gc3RhdGU7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUHJlc2VuY2UgRW5hYmxlZD9cblx0ICAgICAgICAgICAgaWYgKCFwcmVzZW5jZSkgcmV0dXJuO1xuXG5cdCAgICAgICAgICAgIC8vIFN1YnNjcmliZSBQcmVzZW5jZSBDaGFubmVsXG5cdCAgICAgICAgICAgIFNFTEZbJ3N1YnNjcmliZSddKHtcblx0ICAgICAgICAgICAgICBjaGFubmVsOiBjaGFubmVsICsgUFJFU0VOQ0VfU1VGRklYLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBwcmVzZW5jZSxcblx0ICAgICAgICAgICAgICByZXN0b3JlOiByZXN0b3JlXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIC8vIFByZXNlbmNlIFN1YnNjcmliZWQ/XG5cdCAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zdWJzY3JpYmVkKSByZXR1cm47XG5cblx0ICAgICAgICAgICAgLy8gU2VlIFdobydzIEhlcmUgTm93P1xuXHQgICAgICAgICAgICBpZiAobm9oZXJlc3luYykgcmV0dXJuO1xuXHQgICAgICAgICAgICBTRUxGWydoZXJlX25vdyddKHtcblx0ICAgICAgICAgICAgICBjaGFubmVsOiBjaGFubmVsLFxuXHQgICAgICAgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyh7IHV1aWQ6IFVVSUQsIGF1dGg6IEFVVEhfS0VZIH0pLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoaGVyZSkge1xuXHQgICAgICAgICAgICAgICAgdXRpbHMuZWFjaCgndXVpZHMnIGluIGhlcmUgPyBoZXJlWyd1dWlkcyddIDogW10sIGZ1bmN0aW9uICh1aWQpIHtcblx0ICAgICAgICAgICAgICAgICAgcHJlc2VuY2Uoe1xuXHQgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2pvaW4nLFxuXHQgICAgICAgICAgICAgICAgICAgIHV1aWQ6IHVpZCxcblx0ICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IE1hdGguZmxvb3IodXRpbHMucm5vdygpIC8gMTAwMCksXG5cdCAgICAgICAgICAgICAgICAgICAgb2NjdXBhbmN5OiBoZXJlWydvY2N1cGFuY3knXSB8fCAxXG5cdCAgICAgICAgICAgICAgICAgIH0sIGhlcmUsIGNoYW5uZWwpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gU2V0dXAgQ2hhbm5lbCBHcm91cHNcblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgICB1dGlscy5lYWNoKChjaGFubmVsX2dyb3VwLmpvaW4gPyBjaGFubmVsX2dyb3VwLmpvaW4oJywnKSA6ICcnICsgY2hhbm5lbF9ncm91cCkuc3BsaXQoJywnKSxcblx0ICAgICAgICAgIGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdIHx8IHt9O1xuXG5cdCAgICAgICAgICAgIENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdID0ge1xuXHQgICAgICAgICAgICAgIG5hbWU6IGNoYW5uZWxfZ3JvdXAsXG5cdCAgICAgICAgICAgICAgY29ubmVjdGVkOiBzZXR0aW5ncy5jb25uZWN0ZWQsXG5cdCAgICAgICAgICAgICAgZGlzY29ubmVjdGVkOiBzZXR0aW5ncy5kaXNjb25uZWN0ZWQsXG5cdCAgICAgICAgICAgICAgc3Vic2NyaWJlZDogMSxcblx0ICAgICAgICAgICAgICBjYWxsYmFjazogU1VCX0NBTExCQUNLID0gY2FsbGJhY2ssXG5cdCAgICAgICAgICAgICAgY2lwaGVyX2tleTogYXJnc1snY2lwaGVyX2tleSddLFxuXHQgICAgICAgICAgICAgIGNvbm5lY3Q6IGNvbm5lY3QsXG5cdCAgICAgICAgICAgICAgZGlzY29ubmVjdDogZGlzY29ubmVjdCxcblx0ICAgICAgICAgICAgICByZWNvbm5lY3Q6IHJlY29ubmVjdFxuXHQgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIC8vIFByZXNlbmNlIEVuYWJsZWQ/XG5cdCAgICAgICAgICAgIGlmICghcHJlc2VuY2UpIHJldHVybjtcblxuXHQgICAgICAgICAgICAvLyBTdWJzY3JpYmUgUHJlc2VuY2UgQ2hhbm5lbFxuXHQgICAgICAgICAgICBTRUxGWydzdWJzY3JpYmUnXSh7XG5cdCAgICAgICAgICAgICAgY2hhbm5lbF9ncm91cDogY2hhbm5lbF9ncm91cCArIFBSRVNFTkNFX1NVRkZJWCxcblx0ICAgICAgICAgICAgICBjYWxsYmFjazogcHJlc2VuY2UsXG5cdCAgICAgICAgICAgICAgcmVzdG9yZTogcmVzdG9yZSxcblx0ICAgICAgICAgICAgICBhdXRoX2tleTogQVVUSF9LRVlcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgLy8gUHJlc2VuY2UgU3Vic2NyaWJlZD9cblx0ICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN1YnNjcmliZWQpIHJldHVybjtcblxuXHQgICAgICAgICAgICAvLyBTZWUgV2hvJ3MgSGVyZSBOb3c/XG5cdCAgICAgICAgICAgIGlmIChub2hlcmVzeW5jKSByZXR1cm47XG5cdCAgICAgICAgICAgIFNFTEZbJ2hlcmVfbm93J10oe1xuXHQgICAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXA6IGNoYW5uZWxfZ3JvdXAsXG5cdCAgICAgICAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKHsgdXVpZDogVVVJRCwgYXV0aDogQVVUSF9LRVkgfSksXG5cdCAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChoZXJlKSB7XG5cdCAgICAgICAgICAgICAgICB1dGlscy5lYWNoKCd1dWlkcycgaW4gaGVyZSA/IGhlcmVbJ3V1aWRzJ10gOiBbXSwgZnVuY3Rpb24gKHVpZCkge1xuXHQgICAgICAgICAgICAgICAgICBwcmVzZW5jZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnam9pbicsXG5cdCAgICAgICAgICAgICAgICAgICAgdXVpZDogdWlkLFxuXHQgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogTWF0aC5mbG9vcih1dGlscy5ybm93KCkgLyAxMDAwKSxcblx0ICAgICAgICAgICAgICAgICAgICBvY2N1cGFuY3k6IGhlcmVbJ29jY3VwYW5jeSddIHx8IDFcblx0ICAgICAgICAgICAgICAgICAgfSwgaGVyZSwgY2hhbm5lbF9ncm91cCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXG5cdCAgICAgIC8vIFRlc3QgTmV0d29yayBDb25uZWN0aW9uXG5cdCAgICAgIGZ1bmN0aW9uIF90ZXN0X2Nvbm5lY3Rpb24oc3VjY2Vzcykge1xuXHQgICAgICAgIGlmIChzdWNjZXNzKSB7XG5cdCAgICAgICAgICAvLyBCZWdpbiBOZXh0IFNvY2tldCBDb25uZWN0aW9uXG5cdCAgICAgICAgICB1dGlscy50aW1lb3V0KENPTk5FQ1QsIHdpbmRvd2luZyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIE5ldyBPcmlnaW4gb24gRmFpbGVkIENvbm5lY3Rpb25cblx0ICAgICAgICAgIFNURF9PUklHSU4gPSBuZXh0b3JpZ2luKE9SSUdJTiwgMSk7XG5cdCAgICAgICAgICBTVUJfT1JJR0lOID0gbmV4dG9yaWdpbihPUklHSU4sIDEpO1xuXG5cdCAgICAgICAgICAvLyBSZS10ZXN0IENvbm5lY3Rpb25cblx0ICAgICAgICAgIHV0aWxzLnRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBTRUxGWyd0aW1lJ10oX3Rlc3RfY29ubmVjdGlvbik7XG5cdCAgICAgICAgICB9LCBTRUNPTkQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIERpc2Nvbm5lY3QgJiBSZWNvbm5lY3Rcblx0ICAgICAgICBlYWNoX2NoYW5uZWwoZnVuY3Rpb24gKGNoYW5uZWwpIHtcblx0ICAgICAgICAgIC8vIFJlY29ubmVjdFxuXHQgICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgY2hhbm5lbC5kaXNjb25uZWN0ZWQpIHtcblx0ICAgICAgICAgICAgY2hhbm5lbC5kaXNjb25uZWN0ZWQgPSAwO1xuXHQgICAgICAgICAgICByZXR1cm4gY2hhbm5lbC5yZWNvbm5lY3QoY2hhbm5lbC5uYW1lKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgLy8gRGlzY29ubmVjdFxuXHQgICAgICAgICAgaWYgKCFzdWNjZXNzICYmICFjaGFubmVsLmRpc2Nvbm5lY3RlZCkge1xuXHQgICAgICAgICAgICBjaGFubmVsLmRpc2Nvbm5lY3RlZCA9IDE7XG5cdCAgICAgICAgICAgIGNoYW5uZWwuZGlzY29ubmVjdChjaGFubmVsLm5hbWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLy8gRGlzY29ubmVjdCAmIFJlY29ubmVjdCBmb3IgY2hhbm5lbCBncm91cHNcblx0ICAgICAgICBlYWNoX2NoYW5uZWxfZ3JvdXAoZnVuY3Rpb24gKGNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgICAgIC8vIFJlY29ubmVjdFxuXHQgICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgY2hhbm5lbF9ncm91cC5kaXNjb25uZWN0ZWQpIHtcblx0ICAgICAgICAgICAgY2hhbm5lbF9ncm91cC5kaXNjb25uZWN0ZWQgPSAwO1xuXHQgICAgICAgICAgICByZXR1cm4gY2hhbm5lbF9ncm91cC5yZWNvbm5lY3QoY2hhbm5lbF9ncm91cC5uYW1lKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgLy8gRGlzY29ubmVjdFxuXHQgICAgICAgICAgaWYgKCFzdWNjZXNzICYmICFjaGFubmVsX2dyb3VwLmRpc2Nvbm5lY3RlZCkge1xuXHQgICAgICAgICAgICBjaGFubmVsX2dyb3VwLmRpc2Nvbm5lY3RlZCA9IDE7XG5cdCAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXAuZGlzY29ubmVjdChjaGFubmVsX2dyb3VwLm5hbWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gRXZlbnRlZCBTdWJzY3JpYmVcblx0ICAgICAgZnVuY3Rpb24gX2Nvbm5lY3QoKSB7XG5cdCAgICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgICB2YXIgY2hhbm5lbHMgPSBnZW5lcmF0ZV9jaGFubmVsX2xpc3QoQ0hBTk5FTFMpLmpvaW4oJywnKTtcblx0ICAgICAgICB2YXIgY2hhbm5lbF9ncm91cHMgPSBnZW5lcmF0ZV9jaGFubmVsX2dyb3VwX2xpc3QoQ0hBTk5FTF9HUk9VUFMpLmpvaW4oJywnKTtcblxuXHQgICAgICAgIC8vIFN0b3AgQ29ubmVjdGlvblxuXHQgICAgICAgIGlmICghY2hhbm5lbHMgJiYgIWNoYW5uZWxfZ3JvdXBzKSByZXR1cm47XG5cblx0ICAgICAgICBpZiAoIWNoYW5uZWxzKSBjaGFubmVscyA9ICcsJztcblxuXHQgICAgICAgIC8vIENvbm5lY3QgdG8gUHViTnViIFN1YnNjcmliZSBTZXJ2ZXJzXG5cdCAgICAgICAgX3Jlc2V0X29mZmxpbmUoKTtcblxuXHQgICAgICAgIHZhciBkYXRhID0gX2dldF91cmxfcGFyYW1zKHsgdXVpZDogVVVJRCwgYXV0aDogQVVUSF9LRVkgfSk7XG5cblx0ICAgICAgICBpZiAoY2hhbm5lbF9ncm91cHMpIHtcblx0ICAgICAgICAgIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXBzO1xuXHQgICAgICAgIH1cblxuXG5cdCAgICAgICAgdmFyIHN0ID0gSlNPTi5zdHJpbmdpZnkoU1RBVEUpO1xuXHQgICAgICAgIGlmIChzdC5sZW5ndGggPiAyKSBkYXRhWydzdGF0ZSddID0gSlNPTi5zdHJpbmdpZnkoU1RBVEUpO1xuXG5cdCAgICAgICAgaWYgKFBSRVNFTkNFX0hCKSBkYXRhWydoZWFydGJlYXQnXSA9IFBSRVNFTkNFX0hCO1xuXG5cdCAgICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgICAgc3RhcnRfcHJlc2VuY2VfaGVhcnRiZWF0KCk7XG5cdCAgICAgICAgU1VCX1JFQ0VJVkVSID0geGRyKHtcblx0ICAgICAgICAgIHRpbWVvdXQ6IHN1Yl90aW1lb3V0LFxuXHQgICAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZVsnZXJyb3InXSAmJiByZXNwb25zZVsnc2VydmljZSddKSB7XG5cdCAgICAgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgU1VCX0VSUk9SKTtcblx0ICAgICAgICAgICAgICBfdGVzdF9jb25uZWN0aW9uKGZhbHNlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBTRUxGWyd0aW1lJ10oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcblx0ICAgICAgICAgICAgICAgICFzdWNjZXNzICYmIChfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBTVUJfRVJST1IpKTtcblx0ICAgICAgICAgICAgICAgIF90ZXN0X2Nvbm5lY3Rpb24oc3VjY2Vzcyk7XG5cdCAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgICAgU1VCX09SSUdJTiwgJ3N1YnNjcmliZScsXG5cdCAgICAgICAgICAgIFNVQlNDUklCRV9LRVksIHV0aWxzLmVuY29kZShjaGFubmVscyksXG5cdCAgICAgICAgICAgIGpzb25wLCBUSU1FVE9LRU5cblx0ICAgICAgICAgIF0sXG5cdCAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAobWVzc2FnZXMpIHtcblx0ICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEVycm9yc1xuXHQgICAgICAgICAgICBpZiAoIW1lc3NhZ2VzIHx8ICh0eXBlb2YgbWVzc2FnZXMgPT0gJ29iamVjdCcgJiYgJ2Vycm9yJyBpbiBtZXNzYWdlcyAmJiBtZXNzYWdlc1snZXJyb3InXSkpIHtcblx0ICAgICAgICAgICAgICBTVUJfRVJST1IobWVzc2FnZXMpO1xuXHQgICAgICAgICAgICAgIHJldHVybiB1dGlscy50aW1lb3V0KENPTk5FQ1QsIFNFQ09ORCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBVc2VyIElkbGUgQ2FsbGJhY2tcblx0ICAgICAgICAgICAgaWRsZWNiKG1lc3NhZ2VzWzFdKTtcblxuXHQgICAgICAgICAgICAvLyBSZXN0b3JlIFByZXZpb3VzIENvbm5lY3Rpb24gUG9pbnQgaWYgTmVlZGVkXG5cdCAgICAgICAgICAgIFRJTUVUT0tFTiA9ICFUSU1FVE9LRU4gJiYgU1VCX1JFU1RPUkUgJiYgZGJbJ2dldCddKFNVQlNDUklCRV9LRVkpIHx8IG1lc3NhZ2VzWzFdO1xuXG5cdCAgICAgICAgICAgIC8qXG5cdCAgICAgICAgICAgICAvLyBDb25uZWN0XG5cdCAgICAgICAgICAgICBlYWNoX2NoYW5uZWxfcmVnaXN0cnkoZnVuY3Rpb24ocmVnaXN0cnkpe1xuXHQgICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5LmNvbm5lY3RlZCkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgcmVnaXN0cnkuY29ubmVjdGVkID0gMTtcblx0ICAgICAgICAgICAgIHJlZ2lzdHJ5LmNvbm5lY3QoY2hhbm5lbC5uYW1lKTtcblx0ICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblxuXHQgICAgICAgICAgICAvLyBDb25uZWN0XG5cdCAgICAgICAgICAgIGVhY2hfY2hhbm5lbChmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgICAgIGlmIChjaGFubmVsLmNvbm5lY3RlZCkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgIGNoYW5uZWwuY29ubmVjdGVkID0gMTtcblx0ICAgICAgICAgICAgICBjaGFubmVsLmNvbm5lY3QoY2hhbm5lbC5uYW1lKTtcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgLy8gQ29ubmVjdCBmb3IgY2hhbm5lbCBncm91cHNcblx0ICAgICAgICAgICAgZWFjaF9jaGFubmVsX2dyb3VwKGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgICAgICAgaWYgKGNoYW5uZWxfZ3JvdXAuY29ubmVjdGVkKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgY2hhbm5lbF9ncm91cC5jb25uZWN0ZWQgPSAxO1xuXHQgICAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXAuY29ubmVjdChjaGFubmVsX2dyb3VwLm5hbWUpO1xuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBpZiAoUkVTVU1FRCAmJiAhU1VCX1JFU1RPUkUpIHtcblx0ICAgICAgICAgICAgICBUSU1FVE9LRU4gPSAwO1xuXHQgICAgICAgICAgICAgIFJFU1VNRUQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAvLyBVcGRhdGUgU2F2ZWQgVGltZXRva2VuXG5cdCAgICAgICAgICAgICAgZGJbJ3NldCddKFNVQlNDUklCRV9LRVksIDApO1xuXHQgICAgICAgICAgICAgIHV0aWxzLnRpbWVvdXQoX2Nvbm5lY3QsIHdpbmRvd2luZyk7XG5cdCAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW52b2tlIE1lbW9yeSBDYXRjaHVwIGFuZCBSZWNlaXZlIFVwIHRvIDEwMFxuXHQgICAgICAgICAgICAvLyBQcmV2aW91cyBNZXNzYWdlcyBmcm9tIHRoZSBRdWV1ZS5cblx0ICAgICAgICAgICAgaWYgKGJhY2tmaWxsKSB7XG5cdCAgICAgICAgICAgICAgVElNRVRPS0VOID0gMTAwMDA7XG5cdCAgICAgICAgICAgICAgYmFja2ZpbGwgPSAwO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gVXBkYXRlIFNhdmVkIFRpbWV0b2tlblxuXHQgICAgICAgICAgICBkYlsnc2V0J10oU1VCU0NSSUJFX0tFWSwgbWVzc2FnZXNbMV0pO1xuXG5cdCAgICAgICAgICAgIC8vIFJvdXRlIENoYW5uZWwgPC0tLT4gQ2FsbGJhY2sgZm9yIE1lc3NhZ2Vcblx0ICAgICAgICAgICAgdmFyIG5leHRfY2FsbGJhY2sgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgIHZhciBjaGFubmVscyA9ICcnO1xuXHQgICAgICAgICAgICAgIHZhciBjaGFubmVsczIgPSAnJztcblxuXHQgICAgICAgICAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPiAzKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFubmVscyA9IG1lc3NhZ2VzWzNdO1xuXHQgICAgICAgICAgICAgICAgY2hhbm5lbHMyID0gbWVzc2FnZXNbMl07XG5cdCAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlcy5sZW5ndGggPiAyKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFubmVscyA9IG1lc3NhZ2VzWzJdO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBjaGFubmVscyA9IHV0aWxzLm1hcChcblx0ICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTKSwgZnVuY3Rpb24gKGNoYW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMubWFwKFxuXHQgICAgICAgICAgICAgICAgICAgICAgQXJyYXkobWVzc2FnZXNbMF0ubGVuZ3RoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCcpLnNwbGl0KCcsJyksXG5cdCAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJywnKTtcblx0ICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICB2YXIgbGlzdCA9IGNoYW5uZWxzLnNwbGl0KCcsJyk7XG5cdCAgICAgICAgICAgICAgdmFyIGxpc3QyID0gKGNoYW5uZWxzMikgPyBjaGFubmVsczIuc3BsaXQoJywnKSA6IFtdO1xuXG5cdCAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gbGlzdC5zaGlmdCgpIHx8IFNVQl9DSEFOTkVMO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwyID0gbGlzdDIuc2hpZnQoKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIGNob2JqID0ge307XG5cblx0ICAgICAgICAgICAgICAgIGlmIChjaGFubmVsMikge1xuXHQgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbCAmJiBjaGFubmVsLmluZGV4T2YoJy1wbnByZXMnKSA+PSAwXG5cdCAgICAgICAgICAgICAgICAgICAgJiYgY2hhbm5lbDIuaW5kZXhPZignLXBucHJlcycpIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwyICs9ICctcG5wcmVzJztcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICBjaG9iaiA9IENIQU5ORUxfR1JPVVBTW2NoYW5uZWwyXSB8fCBDSEFOTkVMU1tjaGFubmVsMl0gfHwgeyBjYWxsYmFjazogZnVuY3Rpb24gKCkge30gfTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgIGNob2JqID0gQ0hBTk5FTFNbY2hhbm5lbF07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciByID0gW1xuXHQgICAgICAgICAgICAgICAgICBjaG9ialxuXHQgICAgICAgICAgICAgICAgICAgIC5jYWxsYmFjayB8fCBTVUJfQ0FMTEJBQ0ssXG5cdCAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3BsaXQoUFJFU0VOQ0VfU1VGRklYKVswXVxuXHQgICAgICAgICAgICAgICAgXTtcblx0ICAgICAgICAgICAgICAgIGNoYW5uZWwyICYmIHIucHVzaChjaGFubmVsMi5zcGxpdChQUkVTRU5DRV9TVUZGSVgpWzBdKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByO1xuXHQgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pKCk7XG5cblx0ICAgICAgICAgICAgdmFyIGxhdGVuY3kgPSBkZXRlY3RfbGF0ZW5jeSgrbWVzc2FnZXNbMV0pO1xuXHQgICAgICAgICAgICB1dGlscy5lYWNoKG1lc3NhZ2VzWzBdLCBmdW5jdGlvbiAobXNnKSB7XG5cdCAgICAgICAgICAgICAgdmFyIG5leHQgPSBuZXh0X2NhbGxiYWNrKCk7XG5cdCAgICAgICAgICAgICAgdmFyIGRlY3J5cHRlZF9tc2cgPSBkZWNyeXB0KG1zZyxcblx0ICAgICAgICAgICAgICAgIChDSEFOTkVMU1tuZXh0WzFdXSkgPyBDSEFOTkVMU1tuZXh0WzFdXVsnY2lwaGVyX2tleSddIDogbnVsbCk7XG5cdCAgICAgICAgICAgICAgbmV4dFswXSAmJiBuZXh0WzBdKGRlY3J5cHRlZF9tc2csIG1lc3NhZ2VzLCBuZXh0WzJdIHx8IG5leHRbMV0sIGxhdGVuY3ksIG5leHRbMV0pO1xuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICB1dGlscy50aW1lb3V0KF9jb25uZWN0LCB3aW5kb3dpbmcpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgQ09OTkVDVCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBfcmVzZXRfb2ZmbGluZSgpO1xuXHQgICAgICAgIHV0aWxzLnRpbWVvdXQoX2Nvbm5lY3QsIHdpbmRvd2luZyk7XG5cdCAgICAgIH07XG5cblx0ICAgICAgLy8gUmVkdWNlIFN0YXR1cyBGbGlja2VyXG5cdCAgICAgIGlmICghUkVBRFkpIHJldHVybiBSRUFEWV9CVUZGRVIucHVzaChDT05ORUNUKTtcblxuXHQgICAgICAvLyBDb25uZWN0IE5vd1xuXHQgICAgICBDT05ORUNUKCk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5oZXJlX25vdyh7IGNoYW5uZWwgOiAnbXlfY2hhdCcsIGNhbGxiYWNrIDogZnVuIH0pO1xuXHQgICAgICovXG5cdCAgICBoZXJlX25vdzogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBkZWJ1ZyA9IGFyZ3NbJ2RlYnVnJ107XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciB1dWlkcyA9ICgndXVpZHMnIGluIGFyZ3MpID8gYXJnc1sndXVpZHMnXSA6IHRydWU7XG5cdCAgICAgIHZhciBzdGF0ZSA9IGFyZ3NbJ3N0YXRlJ107XG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBhdXRoX2tleSB9O1xuXG5cdCAgICAgIGlmICghdXVpZHMpIGRhdGFbJ2Rpc2FibGVfdXVpZHMnXSA9IDE7XG5cdCAgICAgIGlmIChzdGF0ZSkgZGF0YVsnc3RhdGUnXSA9IDE7XG5cblx0ICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBDaGFubmVsXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgdmFyIHVybCA9IFtcblx0ICAgICAgICBTVERfT1JJR0lOLCAndjInLCAncHJlc2VuY2UnLFxuXHQgICAgICAgICdzdWJfa2V5JywgU1VCU0NSSUJFX0tFWVxuXHQgICAgICBdO1xuXG5cdCAgICAgIGNoYW5uZWwgJiYgdXJsLnB1c2goJ2NoYW5uZWwnKSAmJiB1cmwucHVzaCh1dGlscy5lbmNvZGUoY2hhbm5lbCkpO1xuXG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIHtcblx0ICAgICAgICBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cCkge1xuXHQgICAgICAgIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXA7XG5cdCAgICAgICAgIWNoYW5uZWwgJiYgdXJsLnB1c2goJ2NoYW5uZWwnKSAmJiB1cmwucHVzaCgnLCcpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZGVidWc6IGRlYnVnLFxuXHQgICAgICAgIHVybDogdXJsXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuY3VycmVudF9jaGFubmVsc19ieV91dWlkKHsgY2hhbm5lbCA6ICdteV9jaGF0JywgY2FsbGJhY2sgOiBmdW4gfSk7XG5cdCAgICAgKi9cblx0ICAgIHdoZXJlX25vdzogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgdXVpZCA9IGFyZ3NbJ3V1aWQnXSB8fCBVVUlEO1xuXHQgICAgICB2YXIgZGF0YSA9IHsgYXV0aDogYXV0aF9rZXkgfTtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENhbGxiYWNrJyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjInLCAncHJlc2VuY2UnLFxuXHQgICAgICAgICAgJ3N1Yl9rZXknLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgICAgJ3V1aWQnLCB1dGlscy5lbmNvZGUodXVpZClcblx0ICAgICAgICBdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgc3RhdGU6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGNhbGxiYWNrIHx8IGZ1bmN0aW9uIChyKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciBzdGF0ZSA9IGFyZ3NbJ3N0YXRlJ107XG5cdCAgICAgIHZhciB1dWlkID0gYXJnc1sndXVpZCddIHx8IFVVSUQ7XG5cdCAgICAgIHZhciBjaGFubmVsID0gYXJnc1snY2hhbm5lbCddO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIHVybDtcblx0ICAgICAgdmFyIGRhdGEgPSBfZ2V0X3VybF9wYXJhbXMoeyBhdXRoOiBhdXRoX2tleSB9KTtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXHQgICAgICBpZiAoIXV1aWQpIHJldHVybiBlcnJvcignTWlzc2luZyBVVUlEJyk7XG5cdCAgICAgIGlmICghY2hhbm5lbCAmJiAhY2hhbm5lbF9ncm91cCkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9ICd1bmRlZmluZWQnXG5cdCAgICAgICAgJiYgQ0hBTk5FTFNbY2hhbm5lbF0gJiYgQ0hBTk5FTFNbY2hhbm5lbF0uc3Vic2NyaWJlZCkge1xuXHQgICAgICAgIGlmIChzdGF0ZSkgU1RBVEVbY2hhbm5lbF0gPSBzdGF0ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbF9ncm91cCAhPSAndW5kZWZpbmVkJ1xuXHQgICAgICAgICYmIENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdXG5cdCAgICAgICAgJiYgQ0hBTk5FTF9HUk9VUFNbY2hhbm5lbF9ncm91cF0uc3Vic2NyaWJlZFxuXHQgICAgICApIHtcblx0ICAgICAgICBpZiAoc3RhdGUpIFNUQVRFW2NoYW5uZWxfZ3JvdXBdID0gc3RhdGU7XG5cdCAgICAgICAgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cDtcblxuXHQgICAgICAgIGlmICghY2hhbm5lbCkge1xuXHQgICAgICAgICAgY2hhbm5lbCA9ICcsJztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBkYXRhWydzdGF0ZSddID0gSlNPTi5zdHJpbmdpZnkoc3RhdGUpO1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICBpZiAoc3RhdGUpIHtcblx0ICAgICAgICB1cmwgPSBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjInLCAncHJlc2VuY2UnLFxuXHQgICAgICAgICAgJ3N1Yi1rZXknLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgICAgJ2NoYW5uZWwnLCBjaGFubmVsLFxuXHQgICAgICAgICAgJ3V1aWQnLCB1dWlkLCAnZGF0YSdcblx0ICAgICAgICBdO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHVybCA9IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MicsICdwcmVzZW5jZScsXG5cdCAgICAgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVksXG5cdCAgICAgICAgICAnY2hhbm5lbCcsIGNoYW5uZWwsXG5cdCAgICAgICAgICAndXVpZCcsIHV0aWxzLmVuY29kZSh1dWlkKVxuXHQgICAgICAgIF07XG5cdCAgICAgIH1cblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogdXJsXG5cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5ncmFudCh7XG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdCcsXG5cdCAgICAgY2FsbGJhY2sgOiBmdW4sXG5cdCAgICAgZXJyb3IgICAgOiBmdW4sXG5cdCAgICAgdHRsICAgICAgOiAyNCAqIDYwLCAvLyBNaW51dGVzXG5cdCAgICAgcmVhZCAgICAgOiB0cnVlLFxuXHQgICAgIHdyaXRlICAgIDogdHJ1ZSxcblx0ICAgICBhdXRoX2tleSA6ICczeTh1aWFqZGtseXRvd3NqJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBncmFudDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXSB8fCBhcmdzWydjaGFubmVscyddO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIHR0bCA9IGFyZ3NbJ3R0bCddO1xuXHQgICAgICB2YXIgciA9IChhcmdzWydyZWFkJ10pID8gJzEnIDogJzAnO1xuXHQgICAgICB2YXIgdyA9IChhcmdzWyd3cml0ZSddKSA/ICcxJyA6ICcwJztcblx0ICAgICAgdmFyIG0gPSAoYXJnc1snbWFuYWdlJ10pID8gJzEnIDogJzAnO1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IGFyZ3NbJ2F1dGhfa2V5cyddO1xuXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cdCAgICAgIGlmICghUFVCTElTSF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBQdWJsaXNoIEtleScpO1xuXHQgICAgICBpZiAoIVNFQ1JFVF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTZWNyZXQgS2V5Jyk7XG5cblx0ICAgICAgdmFyIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcblx0ICAgICAgdmFyIHNpZ25faW5wdXQgPSBTVUJTQ1JJQkVfS0VZICsgJ1xcbicgKyBQVUJMSVNIX0tFWSArICdcXG4nICsgJ2dyYW50JyArICdcXG4nO1xuXG5cdCAgICAgIHZhciBkYXRhID0geyB3OiB3LCByOiByLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9O1xuXG5cdCAgICAgIGlmIChhcmdzWydtYW5hZ2UnXSkge1xuXHQgICAgICAgIGRhdGFbJ20nXSA9IG07XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoY2hhbm5lbCkpIHtcblx0ICAgICAgICBjaGFubmVsID0gY2hhbm5lbFsnam9pbiddKCcsJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoYXV0aF9rZXkpKSB7XG5cdCAgICAgICAgYXV0aF9rZXkgPSBhdXRoX2tleVsnam9pbiddKCcsJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9ICd1bmRlZmluZWQnICYmIGNoYW5uZWwgIT0gbnVsbCAmJiBjaGFubmVsLmxlbmd0aCA+IDApIGRhdGFbJ2NoYW5uZWwnXSA9IGNoYW5uZWw7XG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbF9ncm91cCAhPSAndW5kZWZpbmVkJyAmJiBjaGFubmVsX2dyb3VwICE9IG51bGwgJiYgY2hhbm5lbF9ncm91cC5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0dGwgfHwgdHRsID09PSAwKSBkYXRhWyd0dGwnXSA9IHR0bDtcblxuXHQgICAgICBpZiAoYXV0aF9rZXkpIGRhdGFbJ2F1dGgnXSA9IGF1dGhfa2V5O1xuXG5cdCAgICAgIGRhdGEgPSBfZ2V0X3VybF9wYXJhbXMoZGF0YSk7XG5cblx0ICAgICAgaWYgKCFhdXRoX2tleSkgZGVsZXRlIGRhdGFbJ2F1dGgnXTtcblxuXHQgICAgICBzaWduX2lucHV0ICs9IF9nZXRfcGFtX3NpZ25faW5wdXRfZnJvbV9wYXJhbXMoZGF0YSk7XG5cblx0ICAgICAgdmFyIHNpZ25hdHVyZSA9IGhtYWNfU0hBMjU2KHNpZ25faW5wdXQsIFNFQ1JFVF9LRVkpO1xuXG5cdCAgICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS5yZXBsYWNlKC9cXCsvZywgJy0nKTtcblx0ICAgICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xuXG5cdCAgICAgIGRhdGFbJ3NpZ25hdHVyZSddID0gc2lnbmF0dXJlO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogW1xuXHQgICAgICAgICAgU1REX09SSUdJTiwgJ3YxJywgJ2F1dGgnLCAnZ3JhbnQnLFxuXHQgICAgICAgICAgJ3N1Yi1rZXknLCBTVUJTQ1JJQkVfS0VZXG5cdCAgICAgICAgXVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLm1vYmlsZV9nd19wcm92aXNpb24gKHtcblx0ICAgICBkZXZpY2VfaWQ6ICdBNjU1RkJBOTkzMUFCJyxcblx0ICAgICBvcCAgICAgICA6ICdhZGQnIHwgJ3JlbW92ZScsXG5cdCAgICAgZ3dfdHlwZSAgOiAnYXBucycgfCAnZ2NtJyxcblx0ICAgICBjaGFubmVsICA6ICdteV9jaGF0Jyxcblx0ICAgICBjYWxsYmFjayA6IGZ1bixcblx0ICAgICBlcnJvciAgICA6IGZ1bixcblx0ICAgICB9KTtcblx0ICAgICAqL1xuXG5cdCAgICBtb2JpbGVfZ3dfcHJvdmlzaW9uOiBmdW5jdGlvbiAoYXJncykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBvcCA9IGFyZ3NbJ29wJ107XG5cdCAgICAgIHZhciBnd190eXBlID0gYXJnc1snZ3dfdHlwZSddO1xuXHQgICAgICB2YXIgZGV2aWNlX2lkID0gYXJnc1snZGV2aWNlX2lkJ107XG5cdCAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgIHZhciB1cmw7XG5cblx0ICAgICAgaWYgKCFkZXZpY2VfaWQpIHJldHVybiBlcnJvcignTWlzc2luZyBEZXZpY2UgSUQgKGRldmljZV9pZCknKTtcblx0ICAgICAgaWYgKCFnd190eXBlKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgR1cgVHlwZSAoZ3dfdHlwZTogZ2NtIG9yIGFwbnMpJyk7XG5cdCAgICAgIGlmICghb3ApIHJldHVybiBlcnJvcignTWlzc2luZyBHVyBPcGVyYXRpb24gKG9wOiBhZGQgb3IgcmVtb3ZlKScpO1xuXHQgICAgICBpZiAoIWNoYW5uZWwpIHJldHVybiBlcnJvcignTWlzc2luZyBndyBkZXN0aW5hdGlvbiBDaGFubmVsIChjaGFubmVsKScpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgLy8gQ3JlYXRlIFVSTFxuXHQgICAgICB1cmwgPSBbXG5cdCAgICAgICAgU1REX09SSUdJTiwgJ3YxL3B1c2gvc3ViLWtleScsXG5cdCAgICAgICAgU1VCU0NSSUJFX0tFWSwgJ2RldmljZXMnLCBkZXZpY2VfaWRcblx0ICAgICAgXTtcblxuXHQgICAgICBwYXJhbXMgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IGF1dGhfa2V5LCB0eXBlOiBnd190eXBlIH07XG5cblx0ICAgICAgaWYgKG9wID09ICdhZGQnKSB7XG5cdCAgICAgICAgcGFyYW1zWydhZGQnXSA9IGNoYW5uZWw7XG5cdCAgICAgIH0gZWxzZSBpZiAob3AgPT0gJ3JlbW92ZScpIHtcblx0ICAgICAgICBwYXJhbXNbJ3JlbW92ZSddID0gY2hhbm5lbDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgcGFyYW1zWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IHBhcmFtcyxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5hdWRpdCh7XG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdCcsXG5cdCAgICAgY2FsbGJhY2sgOiBmdW4sXG5cdCAgICAgZXJyb3IgICAgOiBmdW4sXG5cdCAgICAgcmVhZCAgICAgOiB0cnVlLFxuXHQgICAgIHdyaXRlICAgIDogdHJ1ZSxcblx0ICAgICBhdXRoX2tleSA6ICczeTh1aWFqZGtseXRvd3NqJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBhdWRpdDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J107XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cblx0ICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBDaGFubmVsXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cdCAgICAgIGlmICghUFVCTElTSF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBQdWJsaXNoIEtleScpO1xuXHQgICAgICBpZiAoIVNFQ1JFVF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTZWNyZXQgS2V5Jyk7XG5cblx0ICAgICAgdmFyIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcblx0ICAgICAgdmFyIHNpZ25faW5wdXQgPSBTVUJTQ1JJQkVfS0VZICsgJ1xcbicgKyBQVUJMSVNIX0tFWSArICdcXG4nICsgJ2F1ZGl0JyArICdcXG4nO1xuXG5cdCAgICAgIHZhciBkYXRhID0geyB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9O1xuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbCAhPSAndW5kZWZpbmVkJyAmJiBjaGFubmVsICE9IG51bGwgJiYgY2hhbm5lbC5sZW5ndGggPiAwKSBkYXRhWydjaGFubmVsJ10gPSBjaGFubmVsO1xuXHQgICAgICBpZiAodHlwZW9mIGNoYW5uZWxfZ3JvdXAgIT0gJ3VuZGVmaW5lZCcgJiYgY2hhbm5lbF9ncm91cCAhPSBudWxsICYmIGNoYW5uZWxfZ3JvdXAubGVuZ3RoID4gMCkge1xuXHQgICAgICAgIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGF1dGhfa2V5KSBkYXRhWydhdXRoJ10gPSBhdXRoX2tleTtcblxuXHQgICAgICBkYXRhID0gX2dldF91cmxfcGFyYW1zKGRhdGEpO1xuXG5cdCAgICAgIGlmICghYXV0aF9rZXkpIGRlbGV0ZSBkYXRhWydhdXRoJ107XG5cblx0ICAgICAgc2lnbl9pbnB1dCArPSBfZ2V0X3BhbV9zaWduX2lucHV0X2Zyb21fcGFyYW1zKGRhdGEpO1xuXG5cdCAgICAgIHZhciBzaWduYXR1cmUgPSBobWFjX1NIQTI1NihzaWduX2lucHV0LCBTRUNSRVRfS0VZKTtcblxuXHQgICAgICBzaWduYXR1cmUgPSBzaWduYXR1cmUucmVwbGFjZSgvXFwrL2csICctJyk7XG5cdCAgICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcblxuXHQgICAgICBkYXRhWydzaWduYXR1cmUnXSA9IHNpZ25hdHVyZTtcblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogZGF0YSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjEnLCAnYXV0aCcsICdhdWRpdCcsXG5cdCAgICAgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVlcblx0ICAgICAgICBdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIucmV2b2tlKHtcblx0ICAgICBjaGFubmVsICA6ICdteV9jaGF0Jyxcblx0ICAgICBjYWxsYmFjayA6IGZ1bixcblx0ICAgICBlcnJvciAgICA6IGZ1bixcblx0ICAgICBhdXRoX2tleSA6ICczeTh1aWFqZGtseXRvd3NqJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICByZXZva2U6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBhcmdzWydyZWFkJ10gPSBmYWxzZTtcblx0ICAgICAgYXJnc1snd3JpdGUnXSA9IGZhbHNlO1xuXHQgICAgICBTRUxGWydncmFudCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIHNldF91dWlkOiBmdW5jdGlvbiAodXVpZCkge1xuXHQgICAgICBVVUlEID0gdXVpZDtcblx0ICAgICAgQ09OTkVDVCgpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X3V1aWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIFVVSUQ7XG5cdCAgICB9LFxuXG5cdCAgICBpc0FycmF5OiBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgIHJldHVybiB1dGlscy5pc0FycmF5KGFyZyk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRfc3Vic2NyaWJlZF9jaGFubmVsczogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTLCB0cnVlKTtcblx0ICAgIH0sXG5cblx0ICAgIHByZXNlbmNlX2hlYXJ0YmVhdDogZnVuY3Rpb24gKGFyZ3MpIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBBVVRIX0tFWSB9O1xuXG5cdCAgICAgIHZhciBzdCA9IEpTT05bJ3N0cmluZ2lmeSddKFNUQVRFKTtcblx0ICAgICAgaWYgKHN0Lmxlbmd0aCA+IDIpIGRhdGFbJ3N0YXRlJ10gPSBKU09OWydzdHJpbmdpZnknXShTVEFURSk7XG5cblx0ICAgICAgaWYgKFBSRVNFTkNFX0hCID4gMCAmJiBQUkVTRU5DRV9IQiA8IDMyMCkgZGF0YVsnaGVhcnRiZWF0J10gPSBQUkVTRU5DRV9IQjtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGNoYW5uZWxzID0gdXRpbHMuZW5jb2RlKGdlbmVyYXRlX2NoYW5uZWxfbGlzdChDSEFOTkVMUywgdHJ1ZSlbJ2pvaW4nXSgnLCcpKTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXBzID0gZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KENIQU5ORUxfR1JPVVBTLCB0cnVlKVsnam9pbiddKCcsJyk7XG5cblx0ICAgICAgaWYgKCFjaGFubmVscykgY2hhbm5lbHMgPSAnLCc7XG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwcykgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cHM7XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MicsICdwcmVzZW5jZScsXG5cdCAgICAgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVksXG5cdCAgICAgICAgICAnY2hhbm5lbCcsIGNoYW5uZWxzLFxuXHQgICAgICAgICAgJ2hlYXJ0YmVhdCdcblx0ICAgICAgICBdLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIHN0b3BfdGltZXJzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGNsZWFyVGltZW91dChfcG9sbF90aW1lcik7XG5cdCAgICAgIGNsZWFyVGltZW91dChfcG9sbF90aW1lcjIpO1xuXHQgICAgICBjbGVhclRpbWVvdXQoUFJFU0VOQ0VfSEJfVElNRU9VVCk7XG5cdCAgICB9LFxuXG5cdCAgICBzaHV0ZG93bjogZnVuY3Rpb24gKCkge1xuXHQgICAgICBTRUxGWydzdG9wX3RpbWVycyddKCk7XG5cdCAgICAgIHNodXRkb3duICYmIHNodXRkb3duKCk7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBFeHBvc2UgUFVCTlVCIEZ1bmN0aW9uc1xuXHQgICAgeGRyOiB4ZHIsXG5cdCAgICByZWFkeTogcmVhZHksXG5cdCAgICBkYjogZGIsXG5cdCAgICB1dWlkOiB1dGlscy5nZW5lcmF0ZVVVSUQsXG5cdCAgICBtYXA6IHV0aWxzLm1hcCxcblx0ICAgIGVhY2g6IHV0aWxzLmVhY2gsXG5cdCAgICAnZWFjaC1jaGFubmVsJzogZWFjaF9jaGFubmVsLFxuXHQgICAgZ3JlcDogdXRpbHMuZ3JlcCxcblx0ICAgIG9mZmxpbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgX3Jlc2V0X29mZmxpbmUoMSwgeyBtZXNzYWdlOiAnT2ZmbGluZS4gUGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yayBzZXR0aW5ncy4nIH0pO1xuXHQgICAgfSxcblx0ICAgIHN1cHBsYW50OiB1dGlscy5zdXBwbGFudCxcblx0ICAgIG5vdzogdXRpbHMucm5vdyxcblx0ICAgIHVuaXF1ZTogdW5pcXVlLFxuXHQgICAgdXBkYXRlcjogdXRpbHMudXBkYXRlclxuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBfcG9sbF9vbmxpbmUoKSB7XG5cdCAgICBfaXNfb25saW5lKCkgfHwgX3Jlc2V0X29mZmxpbmUoMSwgeyBlcnJvcjogJ09mZmxpbmUuIFBsZWFzZSBjaGVjayB5b3VyIG5ldHdvcmsgc2V0dGluZ3MuJyB9KTtcblx0ICAgIF9wb2xsX3RpbWVyICYmIGNsZWFyVGltZW91dChfcG9sbF90aW1lcik7XG5cdCAgICBfcG9sbF90aW1lciA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lLCBTRUNPTkQpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9wb2xsX29ubGluZTIoKSB7XG5cdCAgICBpZiAoIVRJTUVfQ0hFQ0spIHJldHVybjtcblx0ICAgIFNFTEZbJ3RpbWUnXShmdW5jdGlvbiAoc3VjY2Vzcykge1xuXHQgICAgICBkZXRlY3RfdGltZV9kZXRsYShmdW5jdGlvbiAoKSB7XG5cdCAgICAgIH0sIHN1Y2Nlc3MpO1xuXHQgICAgICBzdWNjZXNzIHx8IF9yZXNldF9vZmZsaW5lKDEsIHtcblx0ICAgICAgICBlcnJvcjogJ0hlYXJ0YmVhdCBmYWlsZWQgdG8gY29ubmVjdCB0byBQdWJudWIgU2VydmVycy4nICtcblx0ICAgICAgICAnUGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yayBzZXR0aW5ncy4nXG5cdCAgICAgIH0pO1xuXHQgICAgICBfcG9sbF90aW1lcjIgJiYgY2xlYXJUaW1lb3V0KF9wb2xsX3RpbWVyMik7XG5cdCAgICAgIF9wb2xsX3RpbWVyMiA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lMiwgS0VFUEFMSVZFKTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9yZXNldF9vZmZsaW5lKGVyciwgbXNnKSB7XG5cdCAgICBTVUJfUkVDRUlWRVIgJiYgU1VCX1JFQ0VJVkVSKGVyciwgbXNnKTtcblx0ICAgIFNVQl9SRUNFSVZFUiA9IG51bGw7XG5cblx0ICAgIGNsZWFyVGltZW91dChfcG9sbF90aW1lcik7XG5cdCAgICBjbGVhclRpbWVvdXQoX3BvbGxfdGltZXIyKTtcblx0ICB9XG5cblx0ICBpZiAoIVVVSUQpIFVVSUQgPSBTRUxGWyd1dWlkJ10oKTtcblx0ICBpZiAoIUlOU1RBTkNFSUQpIElOU1RBTkNFSUQgPSBTRUxGWyd1dWlkJ10oKTtcblx0ICBkYlsnc2V0J10oU1VCU0NSSUJFX0tFWSArICd1dWlkJywgVVVJRCk7XG5cblx0ICBfcG9sbF90aW1lciA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lLCBTRUNPTkQpO1xuXHQgIF9wb2xsX3RpbWVyMiA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lMiwgS0VFUEFMSVZFKTtcblx0ICBQUkVTRU5DRV9IQl9USU1FT1VUID0gdXRpbHMudGltZW91dChcblx0ICAgIHN0YXJ0X3ByZXNlbmNlX2hlYXJ0YmVhdCxcblx0ICAgIChQUkVTRU5DRV9IQl9JTlRFUlZBTCAtIDMpICogU0VDT05EXG5cdCAgKTtcblxuXHQgIC8vIERldGVjdCBBZ2Ugb2YgTWVzc2FnZVxuXHQgIGZ1bmN0aW9uIGRldGVjdF9sYXRlbmN5KHR0KSB7XG5cdCAgICB2YXIgYWRqdXN0ZWRfdGltZSA9IHV0aWxzLnJub3coKSAtIFRJTUVfRFJJRlQ7XG5cdCAgICByZXR1cm4gYWRqdXN0ZWRfdGltZSAtIHR0IC8gMTAwMDA7XG5cdCAgfVxuXG5cdCAgZGV0ZWN0X3RpbWVfZGV0bGEoKTtcblx0ICBmdW5jdGlvbiBkZXRlY3RfdGltZV9kZXRsYShjYiwgdGltZSkge1xuXHQgICAgdmFyIHN0aW1lID0gdXRpbHMucm5vdygpO1xuXG5cdCAgICB0aW1lICYmIGNhbGN1bGF0ZSh0aW1lKSB8fCBTRUxGWyd0aW1lJ10oY2FsY3VsYXRlKTtcblxuXHQgICAgZnVuY3Rpb24gY2FsY3VsYXRlKHRpbWUpIHtcblx0ICAgICAgaWYgKCF0aW1lKSByZXR1cm47XG5cdCAgICAgIHZhciBwdGltZSA9IHRpbWUgLyAxMDAwMDtcblx0ICAgICAgdmFyIGxhdGVuY3kgPSAodXRpbHMucm5vdygpIC0gc3RpbWUpIC8gMjtcblx0ICAgICAgVElNRV9EUklGVCA9IHV0aWxzLnJub3coKSAtIChwdGltZSArIGxhdGVuY3kpO1xuXHQgICAgICBjYiAmJiBjYihUSU1FX0RSSUZUKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gU0VMRjtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIFBOX0FQSTogUE5fQVBJLFxuXHQgIHVuaXF1ZTogdW5pcXVlLFxuXHQgIFBObWVzc2FnZTogUE5tZXNzYWdlLFxuXHQgIERFRl9USU1FT1VUOiBERUZfVElNRU9VVCxcblx0ICB0aW1lb3V0OiB1dGlscy50aW1lb3V0LFxuXHQgIGJ1aWxkX3VybDogdXRpbHMuYnVpbGRVUkwsXG5cdCAgZWFjaDogdXRpbHMuZWFjaCxcblx0ICB1dWlkOiB1dGlscy5nZW5lcmF0ZVVVSUQsXG5cdCAgVVJMQklUOiBkZWZhdWx0Q29uZmlndXJhdGlvbi5VUkxCSVQsXG5cdCAgZ3JlcDogdXRpbHMuZ3JlcCxcblx0ICBzdXBwbGFudDogdXRpbHMuc3VwcGxhbnQsXG5cdCAgbm93OiB1dGlscy5ybm93LFxuXHQgIHVwZGF0ZXI6IHV0aWxzLnVwZGF0ZXIsXG5cdCAgbWFwOiB1dGlscy5tYXBcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdFx0XCJQQVJBTVNCSVRcIjogXCImXCIsXG5cdFx0XCJVUkxCSVRcIjogXCIvXCJcblx0fTtcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IDAsIGJsb2NrLXNjb3BlZC12YXI6IDAsIG5vLXJlZGVjbGFyZTogMCwgZ3VhcmQtZm9yLWluOiAwICovXG5cblx0dmFyIGRlZmF1bHRDb25maWd1cmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIFJFUEwgPSAveyhbXFx3XFwtXSspfS9nO1xuXG5cdGZ1bmN0aW9uIHJub3coKSB7XG5cdCAgcmV0dXJuICtuZXcgRGF0ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG5cdCAgcmV0dXJuICEhYXJnICYmIHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnICYmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkoYXJnKSB8fCB0eXBlb2YoYXJnLmxlbmd0aCkgPT09ICdudW1iZXInKTtcblx0ICAvLyByZXR1cm4gISFhcmcgJiYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheShhcmcpIHx8IHR5cGVvZihhcmcubGVuZ3RoKSA9PT0gXCJudW1iZXJcIilcblx0fVxuXG5cdC8qKlxuXHQgKiBFQUNIXG5cdCAqID09PT1cblx0ICogZWFjaCggWzEsMiwzXSwgZnVuY3Rpb24oaXRlbSkgeyB9IClcblx0ICovXG5cdGZ1bmN0aW9uIGVhY2gobywgZikge1xuXHQgIGlmICghbyB8fCAhZikge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIGlmIChpc0FycmF5KG8pKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IG8ubGVuZ3RoOyBpIDwgbDspIHtcblx0ICAgICAgZi5jYWxsKG9baV0sIG9baV0sIGkrKyk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGZvciAodmFyIGkgaW4gbykge1xuXHQgICAgICBvLmhhc093blByb3BlcnR5ICYmXG5cdCAgICAgIG8uaGFzT3duUHJvcGVydHkoaSkgJiZcblx0ICAgICAgZi5jYWxsKG9baV0sIGksIG9baV0pO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFTkNPREVcblx0ICogPT09PT09XG5cdCAqIHZhciBlbmNvZGVkX2RhdGEgPSBlbmNvZGUoJ3BhdGgnKTtcblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShwYXRoKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQocGF0aCk7IH1cblxuXHQvKipcblx0ICogQnVpbGQgVXJsXG5cdCAqID09PT09PT1cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIGJ1aWxkVVJMKHVybENvbXBvbmVudHMsIHVybFBhcmFtcykge1xuXHQgIHZhciB1cmwgPSB1cmxDb21wb25lbnRzLmpvaW4oZGVmYXVsdENvbmZpZ3VyYXRpb24uVVJMQklUKTtcblx0ICB2YXIgcGFyYW1zID0gW107XG5cblx0ICBpZiAoIXVybFBhcmFtcykgcmV0dXJuIHVybDtcblxuXHQgIGVhY2godXJsUGFyYW1zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgICAgdmFyIHZhbHVlU3RyID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpID8gSlNPTlsnc3RyaW5naWZ5J10odmFsdWUpIDogdmFsdWU7XG5cdCAgICAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgICB2YWx1ZSAhPT0gbnVsbCAmJiBlbmNvZGUodmFsdWVTdHIpLmxlbmd0aCA+IDBcblx0ICAgICkgJiYgcGFyYW1zLnB1c2goa2V5ICsgJz0nICsgZW5jb2RlKHZhbHVlU3RyKSk7XG5cdCAgfSk7XG5cblx0ICB1cmwgKz0gJz8nICsgcGFyYW1zLmpvaW4oZGVmYXVsdENvbmZpZ3VyYXRpb24uUEFSQU1TQklUKTtcblx0ICByZXR1cm4gdXJsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVQREFURVJcblx0ICogPT09PT09PVxuXHQgKiB2YXIgdGltZXN0YW1wID0gdW5pcXVlKCk7XG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGVyKGZ1biwgcmF0ZSkge1xuXHQgIHZhciB0aW1lb3V0O1xuXHQgIHZhciBsYXN0ID0gMDtcblx0ICB2YXIgcnVubml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGxhc3QgKyByYXRlID4gcm5vdygpKSB7XG5cdCAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0ICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocnVubml0LCByYXRlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxhc3QgPSBybm93KCk7XG5cdCAgICAgIGZ1bigpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICByZXR1cm4gcnVubml0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdSRVBcblx0ICogPT09PVxuXHQgKiB2YXIgbGlzdCA9IGdyZXAoIFsxLDIsM10sIGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gJSAyIH0gKVxuXHQgKi9cblx0ZnVuY3Rpb24gZ3JlcChsaXN0LCBmdW4pIHtcblx0ICB2YXIgZmluID0gW107XG5cdCAgZWFjaChsaXN0IHx8IFtdLCBmdW5jdGlvbiAobCkge1xuXHQgICAgZnVuKGwpICYmIGZpbi5wdXNoKGwpO1xuXHQgIH0pO1xuXHQgIHJldHVybiBmaW47XG5cdH1cblxuXHQvKipcblx0ICogU1VQUExBTlRcblx0ICogPT09PT09PT1cblx0ICogdmFyIHRleHQgPSBzdXBwbGFudCggJ0hlbGxvIHtuYW1lfSEnLCB7IG5hbWUgOiAnSm9obicgfSApXG5cdCAqL1xuXHRmdW5jdGlvbiBzdXBwbGFudChzdHIsIHZhbHVlcykge1xuXHQgIHJldHVybiBzdHIucmVwbGFjZShSRVBMLCBmdW5jdGlvbiAoXywgbWF0Y2gpIHtcblx0ICAgIHJldHVybiB2YWx1ZXNbbWF0Y2hdIHx8IF87XG5cdCAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogdGltZW91dFxuXHQgKiA9PT09PT09XG5cdCAqIHRpbWVvdXQoIGZ1bmN0aW9uKCl7fSwgMTAwICk7XG5cdCAqL1xuXHRmdW5jdGlvbiB0aW1lb3V0KGZ1biwgd2FpdCkge1xuXHQgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICByZXR1cm4gc2V0VGltZW91dChmdW4sIHdhaXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIHV1aWRcblx0ICogPT09PVxuXHQgKiB2YXIgbXlfdXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKGNhbGxiYWNrKSB7XG5cdCAgdmFyIHUgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csXG5cdCAgICBmdW5jdGlvbiAoYykge1xuXHQgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG5cdCAgICAgIHZhciB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcblx0ICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuXHQgICAgfSk7XG5cdCAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayh1KTtcblx0ICByZXR1cm4gdTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNQVBcblx0ICogPT09XG5cdCAqIHZhciBsaXN0ID0gbWFwKCBbMSwyLDNdLCBmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtICsgMSB9IClcblx0ICovXG5cdGZ1bmN0aW9uIG1hcChsaXN0LCBmdW4pIHtcblx0ICB2YXIgZmluID0gW107XG5cdCAgZWFjaChsaXN0IHx8IFtdLCBmdW5jdGlvbiAoaywgdikge1xuXHQgICAgZmluLnB1c2goZnVuKGssIHYpKTtcblx0ICB9KTtcblx0ICByZXR1cm4gZmluO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBwYW1FbmNvZGUoc3RyKSB7XG5cdCAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKn5dL2csIGZ1bmN0aW9uIChjKSB7XG5cdCAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHQgIH0pO1xuXHR9XG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBidWlsZFVSTDogYnVpbGRVUkwsXG5cdCAgZW5jb2RlOiBlbmNvZGUsXG5cdCAgZWFjaDogZWFjaCxcblx0ICB1cGRhdGVyOiB1cGRhdGVyLFxuXHQgIHJub3c6IHJub3csXG5cdCAgaXNBcnJheTogaXNBcnJheSxcblx0ICBtYXA6IG1hcCxcblx0ICBwYW1FbmNvZGU6IHBhbUVuY29kZSxcblx0ICBnZW5lcmF0ZVVVSUQ6IGdlbmVyYXRlVVVJRCxcblx0ICB0aW1lb3V0OiB0aW1lb3V0LFxuXHQgIHN1cHBsYW50OiBzdXBwbGFudCxcblx0ICBncmVwOiBncmVwXG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIGVzbGludCBjYW1lbGNhc2U6IDAgZXFlcWVxOiAwICovXG5cblx0dmFyIENyeXB0b0pTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuXHRmdW5jdGlvbiBjcnlwdG9fb2JqKCkge1xuXHQgIGZ1bmN0aW9uIFNIQTI1NihzKSB7XG5cdCAgICByZXR1cm4gQ3J5cHRvSlNbJ1NIQTI1NiddKHMpWyd0b1N0cmluZyddKENyeXB0b0pTWydlbmMnXVsnSGV4J10pO1xuXHQgIH1cblxuXHQgIHZhciBpdiA9ICcwMTIzNDU2Nzg5MDEyMzQ1JztcblxuXHQgIHZhciBhbGxvd2VkS2V5RW5jb2RpbmdzID0gWydoZXgnLCAndXRmOCcsICdiYXNlNjQnLCAnYmluYXJ5J107XG5cdCAgdmFyIGFsbG93ZWRLZXlMZW5ndGhzID0gWzEyOCwgMjU2XTtcblx0ICB2YXIgYWxsb3dlZE1vZGVzID0gWydlY2InLCAnY2JjJ107XG5cblx0ICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdCAgICBlbmNyeXB0S2V5OiB0cnVlLFxuXHQgICAga2V5RW5jb2Rpbmc6ICd1dGY4Jyxcblx0ICAgIGtleUxlbmd0aDogMjU2LFxuXHQgICAgbW9kZTogJ2NiYydcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gcGFyc2Vfb3B0aW9ucyhvcHRpb25zKSB7XG5cdCAgICAvLyBEZWZhdWx0c1xuXHQgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgICBpZiAoIW9wdGlvbnNbJ2hhc093blByb3BlcnR5J10oJ2VuY3J5cHRLZXknKSkgb3B0aW9uc1snZW5jcnlwdEtleSddID0gZGVmYXVsdE9wdGlvbnNbJ2VuY3J5cHRLZXknXTtcblx0ICAgIGlmICghb3B0aW9uc1snaGFzT3duUHJvcGVydHknXSgna2V5RW5jb2RpbmcnKSkgb3B0aW9uc1sna2V5RW5jb2RpbmcnXSA9IGRlZmF1bHRPcHRpb25zWydrZXlFbmNvZGluZyddO1xuXHQgICAgaWYgKCFvcHRpb25zWydoYXNPd25Qcm9wZXJ0eSddKCdrZXlMZW5ndGgnKSkgb3B0aW9uc1sna2V5TGVuZ3RoJ10gPSBkZWZhdWx0T3B0aW9uc1sna2V5TGVuZ3RoJ107XG5cdCAgICBpZiAoIW9wdGlvbnNbJ2hhc093blByb3BlcnR5J10oJ21vZGUnKSkgb3B0aW9uc1snbW9kZSddID0gZGVmYXVsdE9wdGlvbnNbJ21vZGUnXTtcblxuXHQgICAgLy8gVmFsaWRhdGlvblxuXHQgICAgaWYgKGFsbG93ZWRLZXlFbmNvZGluZ3NbJ2luZGV4T2YnXShvcHRpb25zWydrZXlFbmNvZGluZyddWyd0b0xvd2VyQ2FzZSddKCkpID09IC0xKSBvcHRpb25zWydrZXlFbmNvZGluZyddID0gZGVmYXVsdE9wdGlvbnNbJ2tleUVuY29kaW5nJ107XG5cdCAgICBpZiAoYWxsb3dlZEtleUxlbmd0aHNbJ2luZGV4T2YnXShwYXJzZUludChvcHRpb25zWydrZXlMZW5ndGgnXSwgMTApKSA9PSAtMSkgb3B0aW9uc1sna2V5TGVuZ3RoJ10gPSBkZWZhdWx0T3B0aW9uc1sna2V5TGVuZ3RoJ107XG5cdCAgICBpZiAoYWxsb3dlZE1vZGVzWydpbmRleE9mJ10ob3B0aW9uc1snbW9kZSddWyd0b0xvd2VyQ2FzZSddKCkpID09IC0xKSBvcHRpb25zWydtb2RlJ10gPSBkZWZhdWx0T3B0aW9uc1snbW9kZSddO1xuXG5cdCAgICByZXR1cm4gb3B0aW9ucztcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkZWNvZGVfa2V5KGtleSwgb3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnNbJ2tleUVuY29kaW5nJ10gPT09ICdiYXNlNjQnKSB7XG5cdCAgICAgIHJldHVybiBDcnlwdG9KU1snZW5jJ11bJ0Jhc2U2NCddWydwYXJzZSddKGtleSk7XG5cdCAgICB9IGVsc2UgaWYgKG9wdGlvbnNbJ2tleUVuY29kaW5nJ10gPT09ICdoZXgnKSB7XG5cdCAgICAgIHJldHVybiBDcnlwdG9KU1snZW5jJ11bJ0hleCddWydwYXJzZSddKGtleSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4ga2V5O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdldF9wYWRkZWRfa2V5KGtleSwgb3B0aW9ucykge1xuXHQgICAga2V5ID0gZGVjb2RlX2tleShrZXksIG9wdGlvbnMpO1xuXHQgICAgaWYgKG9wdGlvbnNbJ2VuY3J5cHRLZXknXSkge1xuXHQgICAgICByZXR1cm4gQ3J5cHRvSlNbJ2VuYyddWydVdGY4J11bJ3BhcnNlJ10oU0hBMjU2KGtleSlbJ3NsaWNlJ10oMCwgMzIpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBrZXk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZ2V0X21vZGUob3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnNbJ21vZGUnXSA9PT0gJ2VjYicpIHtcblx0ICAgICAgcmV0dXJuIENyeXB0b0pTWydtb2RlJ11bJ0VDQiddO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIENyeXB0b0pTWydtb2RlJ11bJ0NCQyddO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdldF9pdihvcHRpb25zKSB7XG5cdCAgICByZXR1cm4gKG9wdGlvbnNbJ21vZGUnXSA9PT0gJ2NiYycpID8gQ3J5cHRvSlNbJ2VuYyddWydVdGY4J11bJ3BhcnNlJ10oaXYpIDogbnVsbDtcblx0ICB9XG5cblx0ICByZXR1cm4ge1xuXHQgICAgZW5jcnlwdDogZnVuY3Rpb24gKGRhdGEsIGtleSwgb3B0aW9ucykge1xuXHQgICAgICBpZiAoIWtleSkgcmV0dXJuIGRhdGE7XG5cdCAgICAgIG9wdGlvbnMgPSBwYXJzZV9vcHRpb25zKG9wdGlvbnMpO1xuXHQgICAgICB2YXIgaXYgPSBnZXRfaXYob3B0aW9ucyk7XG5cdCAgICAgIHZhciBtb2RlID0gZ2V0X21vZGUob3B0aW9ucyk7XG5cdCAgICAgIHZhciBjaXBoZXJfa2V5ID0gZ2V0X3BhZGRlZF9rZXkoa2V5LCBvcHRpb25zKTtcblx0ICAgICAgdmFyIGhleF9tZXNzYWdlID0gSlNPTlsnc3RyaW5naWZ5J10oZGF0YSk7XG5cdCAgICAgIHZhciBlbmNyeXB0ZWRIZXhBcnJheSA9IENyeXB0b0pTWydBRVMnXVsnZW5jcnlwdCddKGhleF9tZXNzYWdlLCBjaXBoZXJfa2V5LCB7IGl2OiBpdiwgbW9kZTogbW9kZSB9KVsnY2lwaGVydGV4dCddO1xuXHQgICAgICB2YXIgYmFzZV82NF9lbmNyeXB0ZWQgPSBlbmNyeXB0ZWRIZXhBcnJheVsndG9TdHJpbmcnXShDcnlwdG9KU1snZW5jJ11bJ0Jhc2U2NCddKTtcblx0ICAgICAgcmV0dXJuIGJhc2VfNjRfZW5jcnlwdGVkIHx8IGRhdGE7XG5cdCAgICB9LFxuXG5cdCAgICBkZWNyeXB0OiBmdW5jdGlvbiAoZGF0YSwga2V5LCBvcHRpb25zKSB7XG5cdCAgICAgIGlmICgha2V5KSByZXR1cm4gZGF0YTtcblx0ICAgICAgb3B0aW9ucyA9IHBhcnNlX29wdGlvbnMob3B0aW9ucyk7XG5cdCAgICAgIHZhciBpdiA9IGdldF9pdihvcHRpb25zKTtcblx0ICAgICAgdmFyIG1vZGUgPSBnZXRfbW9kZShvcHRpb25zKTtcblx0ICAgICAgdmFyIGNpcGhlcl9rZXkgPSBnZXRfcGFkZGVkX2tleShrZXksIG9wdGlvbnMpO1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHZhciBiaW5hcnlfZW5jID0gQ3J5cHRvSlNbJ2VuYyddWydCYXNlNjQnXVsncGFyc2UnXShkYXRhKTtcblx0ICAgICAgICB2YXIganNvbl9wbGFpbiA9IENyeXB0b0pTWydBRVMnXVsnZGVjcnlwdCddKHsgY2lwaGVydGV4dDogYmluYXJ5X2VuYyB9LCBjaXBoZXJfa2V5LCB7IGl2OiBpdiwgbW9kZTogbW9kZSB9KVsndG9TdHJpbmcnXShDcnlwdG9KU1snZW5jJ11bJ1V0ZjgnXSk7XG5cdCAgICAgICAgdmFyIHBsYWludGV4dCA9IEpTT05bJ3BhcnNlJ10oanNvbl9wbGFpbik7XG5cdCAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBjcnlwdG9fb2JqO1xuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKlxuXHQgQ3J5cHRvSlMgdjMuMS4yXG5cdCBjb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcblx0IChjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHQgY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuXHQgKi9cblx0dmFyIENyeXB0b0pTPUNyeXB0b0pTfHxmdW5jdGlvbihoLHMpe3ZhciBmPXt9LGc9Zi5saWI9e30scT1mdW5jdGlvbigpe30sbT1nLkJhc2U9e2V4dGVuZDpmdW5jdGlvbihhKXtxLnByb3RvdHlwZT10aGlzO3ZhciBjPW5ldyBxO2EmJmMubWl4SW4oYSk7Yy5oYXNPd25Qcm9wZXJ0eShcImluaXRcIil8fChjLmluaXQ9ZnVuY3Rpb24oKXtjLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pO2MuaW5pdC5wcm90b3R5cGU9YztjLiRzdXBlcj10aGlzO3JldHVybiBjfSxjcmVhdGU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmV4dGVuZCgpO2EuaW5pdC5hcHBseShhLGFyZ3VtZW50cyk7cmV0dXJuIGF9LGluaXQ6ZnVuY3Rpb24oKXt9LG1peEluOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYyBpbiBhKWEuaGFzT3duUHJvcGVydHkoYykmJih0aGlzW2NdPWFbY10pO2EuaGFzT3duUHJvcGVydHkoXCJ0b1N0cmluZ1wiKSYmKHRoaXMudG9TdHJpbmc9YS50b1N0cmluZyl9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpfX0sXG5cdCAgICByPWcuV29yZEFycmF5PW0uZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGEsYyl7YT10aGlzLndvcmRzPWF8fFtdO3RoaXMuc2lnQnl0ZXM9YyE9cz9jOjQqYS5sZW5ndGh9LHRvU3RyaW5nOmZ1bmN0aW9uKGEpe3JldHVybihhfHxrKS5zdHJpbmdpZnkodGhpcyl9LGNvbmNhdDpmdW5jdGlvbihhKXt2YXIgYz10aGlzLndvcmRzLGQ9YS53b3JkcyxiPXRoaXMuc2lnQnl0ZXM7YT1hLnNpZ0J5dGVzO3RoaXMuY2xhbXAoKTtpZihiJTQpZm9yKHZhciBlPTA7ZTxhO2UrKyljW2IrZT4+PjJdfD0oZFtlPj4+Ml0+Pj4yNC04KihlJTQpJjI1NSk8PDI0LTgqKChiK2UpJTQpO2Vsc2UgaWYoNjU1MzU8ZC5sZW5ndGgpZm9yKGU9MDtlPGE7ZSs9NCljW2IrZT4+PjJdPWRbZT4+PjJdO2Vsc2UgYy5wdXNoLmFwcGx5KGMsZCk7dGhpcy5zaWdCeXRlcys9YTtyZXR1cm4gdGhpc30sY2xhbXA6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLndvcmRzLGM9dGhpcy5zaWdCeXRlczthW2M+Pj4yXSY9NDI5NDk2NzI5NTw8XG5cdCAgICAgIDMyLTgqKGMlNCk7YS5sZW5ndGg9aC5jZWlsKGMvNCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGE9bS5jbG9uZS5jYWxsKHRoaXMpO2Eud29yZHM9dGhpcy53b3Jkcy5zbGljZSgwKTtyZXR1cm4gYX0scmFuZG9tOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1bXSxkPTA7ZDxhO2QrPTQpYy5wdXNoKDQyOTQ5NjcyOTYqaC5yYW5kb20oKXwwKTtyZXR1cm4gbmV3IHIuaW5pdChjLGEpfX0pLGw9Zi5lbmM9e30saz1sLkhleD17c3RyaW5naWZ5OmZ1bmN0aW9uKGEpe3ZhciBjPWEud29yZHM7YT1hLnNpZ0J5dGVzO2Zvcih2YXIgZD1bXSxiPTA7YjxhO2IrKyl7dmFyIGU9Y1tiPj4+Ml0+Pj4yNC04KihiJTQpJjI1NTtkLnB1c2goKGU+Pj40KS50b1N0cmluZygxNikpO2QucHVzaCgoZSYxNSkudG9TdHJpbmcoMTYpKX1yZXR1cm4gZC5qb2luKFwiXCIpfSxwYXJzZTpmdW5jdGlvbihhKXtmb3IodmFyIGM9YS5sZW5ndGgsZD1bXSxiPTA7YjxjO2IrPTIpZFtiPj4+M118PXBhcnNlSW50KGEuc3Vic3RyKGIsXG5cdCAgICAgICAgMiksMTYpPDwyNC00KihiJTgpO3JldHVybiBuZXcgci5pbml0KGQsYy8yKX19LG49bC5MYXRpbjE9e3N0cmluZ2lmeTpmdW5jdGlvbihhKXt2YXIgYz1hLndvcmRzO2E9YS5zaWdCeXRlcztmb3IodmFyIGQ9W10sYj0wO2I8YTtiKyspZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY1tiPj4+Ml0+Pj4yNC04KihiJTQpJjI1NSkpO3JldHVybiBkLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1hLmxlbmd0aCxkPVtdLGI9MDtiPGM7YisrKWRbYj4+PjJdfD0oYS5jaGFyQ29kZUF0KGIpJjI1NSk8PDI0LTgqKGIlNCk7cmV0dXJuIG5ldyByLmluaXQoZCxjKX19LGo9bC5VdGY4PXtzdHJpbmdpZnk6ZnVuY3Rpb24oYSl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKG4uc3RyaW5naWZ5KGEpKSl9Y2F0Y2goYyl7dGhyb3cgRXJyb3IoXCJNYWxmb3JtZWQgVVRGLTggZGF0YVwiKTt9fSxwYXJzZTpmdW5jdGlvbihhKXtyZXR1cm4gbi5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYSkpKX19LFxuXHQgICAgdT1nLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG09bS5leHRlbmQoe3Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fZGF0YT1uZXcgci5pbml0O3RoaXMuX25EYXRhQnl0ZXM9MH0sX2FwcGVuZDpmdW5jdGlvbihhKXtcInN0cmluZ1wiPT10eXBlb2YgYSYmKGE9ai5wYXJzZShhKSk7dGhpcy5fZGF0YS5jb25jYXQoYSk7dGhpcy5fbkRhdGFCeXRlcys9YS5zaWdCeXRlc30sX3Byb2Nlc3M6ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5fZGF0YSxkPWMud29yZHMsYj1jLnNpZ0J5dGVzLGU9dGhpcy5ibG9ja1NpemUsZj1iLyg0KmUpLGY9YT9oLmNlaWwoZik6aC5tYXgoKGZ8MCktdGhpcy5fbWluQnVmZmVyU2l6ZSwwKTthPWYqZTtiPWgubWluKDQqYSxiKTtpZihhKXtmb3IodmFyIGc9MDtnPGE7Zys9ZSl0aGlzLl9kb1Byb2Nlc3NCbG9jayhkLGcpO2c9ZC5zcGxpY2UoMCxhKTtjLnNpZ0J5dGVzLT1ifXJldHVybiBuZXcgci5pbml0KGcsYil9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGE9bS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICBhLl9kYXRhPXRoaXMuX2RhdGEuY2xvbmUoKTtyZXR1cm4gYX0sX21pbkJ1ZmZlclNpemU6MH0pO2cuSGFzaGVyPXUuZXh0ZW5kKHtjZmc6bS5leHRlbmQoKSxpbml0OmZ1bmN0aW9uKGEpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChhKTt0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7dS5yZXNldC5jYWxsKHRoaXMpO3RoaXMuX2RvUmVzZXQoKX0sdXBkYXRlOmZ1bmN0aW9uKGEpe3RoaXMuX2FwcGVuZChhKTt0aGlzLl9wcm9jZXNzKCk7cmV0dXJuIHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKGEpe2EmJnRoaXMuX2FwcGVuZChhKTtyZXR1cm4gdGhpcy5fZG9GaW5hbGl6ZSgpfSxibG9ja1NpemU6MTYsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYyxkKXtyZXR1cm4obmV3IGEuaW5pdChkKSkuZmluYWxpemUoYyl9fSxfY3JlYXRlSG1hY0hlbHBlcjpmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYyxkKXtyZXR1cm4obmV3IHQuSE1BQy5pbml0KGEsXG5cdCAgICBkKSkuZmluYWxpemUoYyl9fX0pO3ZhciB0PWYuYWxnbz17fTtyZXR1cm4gZn0oTWF0aCk7XG5cblx0Ly8gU0hBMjU2XG5cdChmdW5jdGlvbihoKXtmb3IodmFyIHM9Q3J5cHRvSlMsZj1zLmxpYixnPWYuV29yZEFycmF5LHE9Zi5IYXNoZXIsZj1zLmFsZ28sbT1bXSxyPVtdLGw9ZnVuY3Rpb24oYSl7cmV0dXJuIDQyOTQ5NjcyOTYqKGEtKGF8MCkpfDB9LGs9MixuPTA7NjQ+bjspe3ZhciBqO2E6e2o9aztmb3IodmFyIHU9aC5zcXJ0KGopLHQ9Mjt0PD11O3QrKylpZighKGoldCkpe2o9ITE7YnJlYWsgYX1qPSEwfWomJig4Pm4mJihtW25dPWwoaC5wb3coaywwLjUpKSkscltuXT1sKGgucG93KGssMS8zKSksbisrKTtrKyt9dmFyIGE9W10sZj1mLlNIQTI1Nj1xLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBnLmluaXQobS5zbGljZSgwKSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihjLGQpe2Zvcih2YXIgYj10aGlzLl9oYXNoLndvcmRzLGU9YlswXSxmPWJbMV0sZz1iWzJdLGo9YlszXSxoPWJbNF0sbT1iWzVdLG49Yls2XSxxPWJbN10scD0wOzY0PnA7cCsrKXtpZigxNj5wKWFbcF09XG5cdCAgY1tkK3BdfDA7ZWxzZXt2YXIgaz1hW3AtMTVdLGw9YVtwLTJdO2FbcF09KChrPDwyNXxrPj4+NyleKGs8PDE0fGs+Pj4xOCleaz4+PjMpK2FbcC03XSsoKGw8PDE1fGw+Pj4xNyleKGw8PDEzfGw+Pj4xOSlebD4+PjEwKSthW3AtMTZdfWs9cSsoKGg8PDI2fGg+Pj42KV4oaDw8MjF8aD4+PjExKV4oaDw8N3xoPj4+MjUpKSsoaCZtXn5oJm4pK3JbcF0rYVtwXTtsPSgoZTw8MzB8ZT4+PjIpXihlPDwxOXxlPj4+MTMpXihlPDwxMHxlPj4+MjIpKSsoZSZmXmUmZ15mJmcpO3E9bjtuPW07bT1oO2g9aitrfDA7aj1nO2c9ZjtmPWU7ZT1rK2x8MH1iWzBdPWJbMF0rZXwwO2JbMV09YlsxXStmfDA7YlsyXT1iWzJdK2d8MDtiWzNdPWJbM10ranwwO2JbNF09Yls0XStofDA7Yls1XT1iWzVdK218MDtiWzZdPWJbNl0rbnwwO2JbN109Yls3XStxfDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fZGF0YSxkPWEud29yZHMsYj04KnRoaXMuX25EYXRhQnl0ZXMsZT04KmEuc2lnQnl0ZXM7XG5cdCAgZFtlPj4+NV18PTEyODw8MjQtZSUzMjtkWyhlKzY0Pj4+OTw8NCkrMTRdPWguZmxvb3IoYi80Mjk0OTY3Mjk2KTtkWyhlKzY0Pj4+OTw8NCkrMTVdPWI7YS5zaWdCeXRlcz00KmQubGVuZ3RoO3RoaXMuX3Byb2Nlc3MoKTtyZXR1cm4gdGhpcy5faGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgYT1xLmNsb25lLmNhbGwodGhpcyk7YS5faGFzaD10aGlzLl9oYXNoLmNsb25lKCk7cmV0dXJuIGF9fSk7cy5TSEEyNTY9cS5fY3JlYXRlSGVscGVyKGYpO3MuSG1hY1NIQTI1Nj1xLl9jcmVhdGVIbWFjSGVscGVyKGYpfSkoTWF0aCk7XG5cblx0Ly8gSE1BQyBTSEEyNTZcblx0KGZ1bmN0aW9uKCl7dmFyIGg9Q3J5cHRvSlMscz1oLmVuYy5VdGY4O2guYWxnby5ITUFDPWgubGliLkJhc2UuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGYsZyl7Zj10aGlzLl9oYXNoZXI9bmV3IGYuaW5pdDtcInN0cmluZ1wiPT10eXBlb2YgZyYmKGc9cy5wYXJzZShnKSk7dmFyIGg9Zi5ibG9ja1NpemUsbT00Kmg7Zy5zaWdCeXRlcz5tJiYoZz1mLmZpbmFsaXplKGcpKTtnLmNsYW1wKCk7Zm9yKHZhciByPXRoaXMuX29LZXk9Zy5jbG9uZSgpLGw9dGhpcy5faUtleT1nLmNsb25lKCksaz1yLndvcmRzLG49bC53b3JkcyxqPTA7ajxoO2orKylrW2pdXj0xNTQ5NTU2ODI4LG5bal1ePTkwOTUyMjQ4NjtyLnNpZ0J5dGVzPWwuc2lnQnl0ZXM9bTt0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7dmFyIGY9dGhpcy5faGFzaGVyO2YucmVzZXQoKTtmLnVwZGF0ZSh0aGlzLl9pS2V5KX0sdXBkYXRlOmZ1bmN0aW9uKGYpe3RoaXMuX2hhc2hlci51cGRhdGUoZik7cmV0dXJuIHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKGYpe3ZhciBnPVxuXHQgIHRoaXMuX2hhc2hlcjtmPWcuZmluYWxpemUoZik7Zy5yZXNldCgpO3JldHVybiBnLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoZikpfX0pfSkoKTtcblxuXHQvLyBCYXNlNjRcblx0KGZ1bmN0aW9uKCl7dmFyIHU9Q3J5cHRvSlMscD11LmxpYi5Xb3JkQXJyYXk7dS5lbmMuQmFzZTY0PXtzdHJpbmdpZnk6ZnVuY3Rpb24oZCl7dmFyIGw9ZC53b3JkcyxwPWQuc2lnQnl0ZXMsdD10aGlzLl9tYXA7ZC5jbGFtcCgpO2Q9W107Zm9yKHZhciByPTA7cjxwO3IrPTMpZm9yKHZhciB3PShsW3I+Pj4yXT4+PjI0LTgqKHIlNCkmMjU1KTw8MTZ8KGxbcisxPj4+Ml0+Pj4yNC04KigocisxKSU0KSYyNTUpPDw4fGxbcisyPj4+Ml0+Pj4yNC04KigocisyKSU0KSYyNTUsdj0wOzQ+diYmciswLjc1KnY8cDt2KyspZC5wdXNoKHQuY2hhckF0KHc+Pj42KigzLXYpJjYzKSk7aWYobD10LmNoYXJBdCg2NCkpZm9yKDtkLmxlbmd0aCU0OylkLnB1c2gobCk7cmV0dXJuIGQuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24oZCl7dmFyIGw9ZC5sZW5ndGgscz10aGlzLl9tYXAsdD1zLmNoYXJBdCg2NCk7dCYmKHQ9ZC5pbmRleE9mKHQpLC0xIT10JiYobD10KSk7Zm9yKHZhciB0PVtdLHI9MCx3PTA7dzxcblx0bDt3KyspaWYodyU0KXt2YXIgdj1zLmluZGV4T2YoZC5jaGFyQXQody0xKSk8PDIqKHclNCksYj1zLmluZGV4T2YoZC5jaGFyQXQodykpPj4+Ni0yKih3JTQpO3Rbcj4+PjJdfD0odnxiKTw8MjQtOCoociU0KTtyKyt9cmV0dXJuIHAuY3JlYXRlKHQscil9LF9tYXA6XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwifX0pKCk7XG5cblx0Ly8gQmxvY2tDaXBoZXJcblx0KGZ1bmN0aW9uKHUpe2Z1bmN0aW9uIHAoYixuLGEsYyxlLGosayl7Yj1iKyhuJmF8fm4mYykrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZ1bmN0aW9uIGQoYixuLGEsYyxlLGosayl7Yj1iKyhuJmN8YSZ+YykrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZ1bmN0aW9uIGwoYixuLGEsYyxlLGosayl7Yj1iKyhuXmFeYykrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZ1bmN0aW9uIHMoYixuLGEsYyxlLGosayl7Yj1iKyhhXihufH5jKSkrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZvcih2YXIgdD1DcnlwdG9KUyxyPXQubGliLHc9ci5Xb3JkQXJyYXksdj1yLkhhc2hlcixyPXQuYWxnbyxiPVtdLHg9MDs2ND54O3grKyliW3hdPTQyOTQ5NjcyOTYqdS5hYnModS5zaW4oeCsxKSl8MDtyPXIuTUQ1PXYuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IHcuaW5pdChbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4XSl9LFxuXHQgIF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihxLG4pe2Zvcih2YXIgYT0wOzE2PmE7YSsrKXt2YXIgYz1uK2EsZT1xW2NdO3FbY109KGU8PDh8ZT4+PjI0KSYxNjcxMTkzNXwoZTw8MjR8ZT4+PjgpJjQyNzgyNTUzNjB9dmFyIGE9dGhpcy5faGFzaC53b3JkcyxjPXFbbiswXSxlPXFbbisxXSxqPXFbbisyXSxrPXFbbiszXSx6PXFbbis0XSxyPXFbbis1XSx0PXFbbis2XSx3PXFbbis3XSx2PXFbbis4XSxBPXFbbis5XSxCPXFbbisxMF0sQz1xW24rMTFdLHU9cVtuKzEyXSxEPXFbbisxM10sRT1xW24rMTRdLHg9cVtuKzE1XSxmPWFbMF0sbT1hWzFdLGc9YVsyXSxoPWFbM10sZj1wKGYsbSxnLGgsYyw3LGJbMF0pLGg9cChoLGYsbSxnLGUsMTIsYlsxXSksZz1wKGcsaCxmLG0saiwxNyxiWzJdKSxtPXAobSxnLGgsZixrLDIyLGJbM10pLGY9cChmLG0sZyxoLHosNyxiWzRdKSxoPXAoaCxmLG0sZyxyLDEyLGJbNV0pLGc9cChnLGgsZixtLHQsMTcsYls2XSksbT1wKG0sZyxoLGYsdywyMixiWzddKSxcblx0ICAgIGY9cChmLG0sZyxoLHYsNyxiWzhdKSxoPXAoaCxmLG0sZyxBLDEyLGJbOV0pLGc9cChnLGgsZixtLEIsMTcsYlsxMF0pLG09cChtLGcsaCxmLEMsMjIsYlsxMV0pLGY9cChmLG0sZyxoLHUsNyxiWzEyXSksaD1wKGgsZixtLGcsRCwxMixiWzEzXSksZz1wKGcsaCxmLG0sRSwxNyxiWzE0XSksbT1wKG0sZyxoLGYseCwyMixiWzE1XSksZj1kKGYsbSxnLGgsZSw1LGJbMTZdKSxoPWQoaCxmLG0sZyx0LDksYlsxN10pLGc9ZChnLGgsZixtLEMsMTQsYlsxOF0pLG09ZChtLGcsaCxmLGMsMjAsYlsxOV0pLGY9ZChmLG0sZyxoLHIsNSxiWzIwXSksaD1kKGgsZixtLGcsQiw5LGJbMjFdKSxnPWQoZyxoLGYsbSx4LDE0LGJbMjJdKSxtPWQobSxnLGgsZix6LDIwLGJbMjNdKSxmPWQoZixtLGcsaCxBLDUsYlsyNF0pLGg9ZChoLGYsbSxnLEUsOSxiWzI1XSksZz1kKGcsaCxmLG0saywxNCxiWzI2XSksbT1kKG0sZyxoLGYsdiwyMCxiWzI3XSksZj1kKGYsbSxnLGgsRCw1LGJbMjhdKSxoPWQoaCxmLFxuXHQgICAgICBtLGcsaiw5LGJbMjldKSxnPWQoZyxoLGYsbSx3LDE0LGJbMzBdKSxtPWQobSxnLGgsZix1LDIwLGJbMzFdKSxmPWwoZixtLGcsaCxyLDQsYlszMl0pLGg9bChoLGYsbSxnLHYsMTEsYlszM10pLGc9bChnLGgsZixtLEMsMTYsYlszNF0pLG09bChtLGcsaCxmLEUsMjMsYlszNV0pLGY9bChmLG0sZyxoLGUsNCxiWzM2XSksaD1sKGgsZixtLGcseiwxMSxiWzM3XSksZz1sKGcsaCxmLG0sdywxNixiWzM4XSksbT1sKG0sZyxoLGYsQiwyMyxiWzM5XSksZj1sKGYsbSxnLGgsRCw0LGJbNDBdKSxoPWwoaCxmLG0sZyxjLDExLGJbNDFdKSxnPWwoZyxoLGYsbSxrLDE2LGJbNDJdKSxtPWwobSxnLGgsZix0LDIzLGJbNDNdKSxmPWwoZixtLGcsaCxBLDQsYls0NF0pLGg9bChoLGYsbSxnLHUsMTEsYls0NV0pLGc9bChnLGgsZixtLHgsMTYsYls0Nl0pLG09bChtLGcsaCxmLGosMjMsYls0N10pLGY9cyhmLG0sZyxoLGMsNixiWzQ4XSksaD1zKGgsZixtLGcsdywxMCxiWzQ5XSksZz1zKGcsaCxmLG0sXG5cdCAgICAgIEUsMTUsYls1MF0pLG09cyhtLGcsaCxmLHIsMjEsYls1MV0pLGY9cyhmLG0sZyxoLHUsNixiWzUyXSksaD1zKGgsZixtLGcsaywxMCxiWzUzXSksZz1zKGcsaCxmLG0sQiwxNSxiWzU0XSksbT1zKG0sZyxoLGYsZSwyMSxiWzU1XSksZj1zKGYsbSxnLGgsdiw2LGJbNTZdKSxoPXMoaCxmLG0sZyx4LDEwLGJbNTddKSxnPXMoZyxoLGYsbSx0LDE1LGJbNThdKSxtPXMobSxnLGgsZixELDIxLGJbNTldKSxmPXMoZixtLGcsaCx6LDYsYls2MF0pLGg9cyhoLGYsbSxnLEMsMTAsYls2MV0pLGc9cyhnLGgsZixtLGosMTUsYls2Ml0pLG09cyhtLGcsaCxmLEEsMjEsYls2M10pO2FbMF09YVswXStmfDA7YVsxXT1hWzFdK218MDthWzJdPWFbMl0rZ3wwO2FbM109YVszXStofDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5fZGF0YSxuPWIud29yZHMsYT04KnRoaXMuX25EYXRhQnl0ZXMsYz04KmIuc2lnQnl0ZXM7bltjPj4+NV18PTEyODw8MjQtYyUzMjt2YXIgZT11LmZsb29yKGEvXG5cdCAgICA0Mjk0OTY3Mjk2KTtuWyhjKzY0Pj4+OTw8NCkrMTVdPShlPDw4fGU+Pj4yNCkmMTY3MTE5MzV8KGU8PDI0fGU+Pj44KSY0Mjc4MjU1MzYwO25bKGMrNjQ+Pj45PDw0KSsxNF09KGE8PDh8YT4+PjI0KSYxNjcxMTkzNXwoYTw8MjR8YT4+PjgpJjQyNzgyNTUzNjA7Yi5zaWdCeXRlcz00KihuLmxlbmd0aCsxKTt0aGlzLl9wcm9jZXNzKCk7Yj10aGlzLl9oYXNoO249Yi53b3Jkcztmb3IoYT0wOzQ+YTthKyspYz1uW2FdLG5bYV09KGM8PDh8Yz4+PjI0KSYxNjcxMTkzNXwoYzw8MjR8Yz4+PjgpJjQyNzgyNTUzNjA7cmV0dXJuIGJ9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGI9di5jbG9uZS5jYWxsKHRoaXMpO2IuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpO3JldHVybiBifX0pO3QuTUQ1PXYuX2NyZWF0ZUhlbHBlcihyKTt0LkhtYWNNRDU9di5fY3JlYXRlSG1hY0hlbHBlcihyKX0pKE1hdGgpO1xuXHQoZnVuY3Rpb24oKXt2YXIgdT1DcnlwdG9KUyxwPXUubGliLGQ9cC5CYXNlLGw9cC5Xb3JkQXJyYXkscD11LmFsZ28scz1wLkV2cEtERj1kLmV4dGVuZCh7Y2ZnOmQuZXh0ZW5kKHtrZXlTaXplOjQsaGFzaGVyOnAuTUQ1LGl0ZXJhdGlvbnM6MX0pLGluaXQ6ZnVuY3Rpb24oZCl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKGQpfSxjb21wdXRlOmZ1bmN0aW9uKGQscil7Zm9yKHZhciBwPXRoaXMuY2ZnLHM9cC5oYXNoZXIuY3JlYXRlKCksYj1sLmNyZWF0ZSgpLHU9Yi53b3JkcyxxPXAua2V5U2l6ZSxwPXAuaXRlcmF0aW9uczt1Lmxlbmd0aDxxOyl7biYmcy51cGRhdGUobik7dmFyIG49cy51cGRhdGUoZCkuZmluYWxpemUocik7cy5yZXNldCgpO2Zvcih2YXIgYT0xO2E8cDthKyspbj1zLmZpbmFsaXplKG4pLHMucmVzZXQoKTtiLmNvbmNhdChuKX1iLnNpZ0J5dGVzPTQqcTtyZXR1cm4gYn19KTt1LkV2cEtERj1mdW5jdGlvbihkLGwscCl7cmV0dXJuIHMuY3JlYXRlKHApLmNvbXB1dGUoZCxcblx0ICBsKX19KSgpO1xuXG5cdC8vIENpcGhlclxuXHRDcnlwdG9KUy5saWIuQ2lwaGVyfHxmdW5jdGlvbih1KXt2YXIgcD1DcnlwdG9KUyxkPXAubGliLGw9ZC5CYXNlLHM9ZC5Xb3JkQXJyYXksdD1kLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0scj1wLmVuYy5CYXNlNjQsdz1wLmFsZ28uRXZwS0RGLHY9ZC5DaXBoZXI9dC5leHRlbmQoe2NmZzpsLmV4dGVuZCgpLGNyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbihlLGEpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSxlLGEpfSxjcmVhdGVEZWNyeXB0b3I6ZnVuY3Rpb24oZSxhKXtyZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fREVDX1hGT1JNX01PREUsZSxhKX0saW5pdDpmdW5jdGlvbihlLGEsYil7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKGIpO3RoaXMuX3hmb3JtTW9kZT1lO3RoaXMuX2tleT1hO3RoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXt0LnJlc2V0LmNhbGwodGhpcyk7dGhpcy5fZG9SZXNldCgpfSxwcm9jZXNzOmZ1bmN0aW9uKGUpe3RoaXMuX2FwcGVuZChlKTtyZXR1cm4gdGhpcy5fcHJvY2VzcygpfSxcblx0ICBmaW5hbGl6ZTpmdW5jdGlvbihlKXtlJiZ0aGlzLl9hcHBlbmQoZSk7cmV0dXJuIHRoaXMuX2RvRmluYWxpemUoKX0sa2V5U2l6ZTo0LGl2U2l6ZTo0LF9FTkNfWEZPUk1fTU9ERToxLF9ERUNfWEZPUk1fTU9ERToyLF9jcmVhdGVIZWxwZXI6ZnVuY3Rpb24oZSl7cmV0dXJue2VuY3J5cHQ6ZnVuY3Rpb24oYixrLGQpe3JldHVybihcInN0cmluZ1wiPT10eXBlb2Ygaz9jOmEpLmVuY3J5cHQoZSxiLGssZCl9LGRlY3J5cHQ6ZnVuY3Rpb24oYixrLGQpe3JldHVybihcInN0cmluZ1wiPT10eXBlb2Ygaz9jOmEpLmRlY3J5cHQoZSxiLGssZCl9fX19KTtkLlN0cmVhbUNpcGhlcj12LmV4dGVuZCh7X2RvRmluYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvY2VzcyghMCl9LGJsb2NrU2l6ZToxfSk7dmFyIGI9cC5tb2RlPXt9LHg9ZnVuY3Rpb24oZSxhLGIpe3ZhciBjPXRoaXMuX2l2O2M/dGhpcy5faXY9dTpjPXRoaXMuX3ByZXZCbG9jaztmb3IodmFyIGQ9MDtkPGI7ZCsrKWVbYStkXV49XG5cdCAgY1tkXX0scT0oZC5CbG9ja0NpcGhlck1vZGU9bC5leHRlbmQoe2NyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbihlLGEpe3JldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoZSxhKX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKGUsYSl7cmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShlLGEpfSxpbml0OmZ1bmN0aW9uKGUsYSl7dGhpcy5fY2lwaGVyPWU7dGhpcy5faXY9YX19KSkuZXh0ZW5kKCk7cS5FbmNyeXB0b3I9cS5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLGEpe3ZhciBiPXRoaXMuX2NpcGhlcixjPWIuYmxvY2tTaXplO3guY2FsbCh0aGlzLGUsYSxjKTtiLmVuY3J5cHRCbG9jayhlLGEpO3RoaXMuX3ByZXZCbG9jaz1lLnNsaWNlKGEsYStjKX19KTtxLkRlY3J5cHRvcj1xLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsYSl7dmFyIGI9dGhpcy5fY2lwaGVyLGM9Yi5ibG9ja1NpemUsZD1lLnNsaWNlKGEsYStjKTtiLmRlY3J5cHRCbG9jayhlLGEpO3guY2FsbCh0aGlzLFxuXHQgIGUsYSxjKTt0aGlzLl9wcmV2QmxvY2s9ZH19KTtiPWIuQ0JDPXE7cT0ocC5wYWQ9e30pLlBrY3M3PXtwYWQ6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9NCpiLGM9Yy1hLnNpZ0J5dGVzJWMsZD1jPDwyNHxjPDwxNnxjPDw4fGMsbD1bXSxuPTA7bjxjO24rPTQpbC5wdXNoKGQpO2M9cy5jcmVhdGUobCxjKTthLmNvbmNhdChjKX0sdW5wYWQ6ZnVuY3Rpb24oYSl7YS5zaWdCeXRlcy09YS53b3Jkc1thLnNpZ0J5dGVzLTE+Pj4yXSYyNTV9fTtkLkJsb2NrQ2lwaGVyPXYuZXh0ZW5kKHtjZmc6di5jZmcuZXh0ZW5kKHttb2RlOmIscGFkZGluZzpxfSkscmVzZXQ6ZnVuY3Rpb24oKXt2LnJlc2V0LmNhbGwodGhpcyk7dmFyIGE9dGhpcy5jZmcsYj1hLml2LGE9YS5tb2RlO2lmKHRoaXMuX3hmb3JtTW9kZT09dGhpcy5fRU5DX1hGT1JNX01PREUpdmFyIGM9YS5jcmVhdGVFbmNyeXB0b3I7ZWxzZSBjPWEuY3JlYXRlRGVjcnlwdG9yLHRoaXMuX21pbkJ1ZmZlclNpemU9MTt0aGlzLl9tb2RlPWMuY2FsbChhLFxuXHQgIHRoaXMsYiYmYi53b3Jkcyl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihhLGIpe3RoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKGEsYil9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jZmcucGFkZGluZztpZih0aGlzLl94Zm9ybU1vZGU9PXRoaXMuX0VOQ19YRk9STV9NT0RFKXthLnBhZCh0aGlzLl9kYXRhLHRoaXMuYmxvY2tTaXplKTt2YXIgYj10aGlzLl9wcm9jZXNzKCEwKX1lbHNlIGI9dGhpcy5fcHJvY2VzcyghMCksYS51bnBhZChiKTtyZXR1cm4gYn0sYmxvY2tTaXplOjR9KTt2YXIgbj1kLkNpcGhlclBhcmFtcz1sLmV4dGVuZCh7aW5pdDpmdW5jdGlvbihhKXt0aGlzLm1peEluKGEpfSx0b1N0cmluZzpmdW5jdGlvbihhKXtyZXR1cm4oYXx8dGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKX19KSxiPShwLmZvcm1hdD17fSkuT3BlblNTTD17c3RyaW5naWZ5OmZ1bmN0aW9uKGEpe3ZhciBiPWEuY2lwaGVydGV4dDthPWEuc2FsdDtyZXR1cm4oYT9zLmNyZWF0ZShbMTM5ODg5MzY4NCxcblx0ICAxNzAxMDc2ODMxXSkuY29uY2F0KGEpLmNvbmNhdChiKTpiKS50b1N0cmluZyhyKX0scGFyc2U6ZnVuY3Rpb24oYSl7YT1yLnBhcnNlKGEpO3ZhciBiPWEud29yZHM7aWYoMTM5ODg5MzY4ND09YlswXSYmMTcwMTA3NjgzMT09YlsxXSl7dmFyIGM9cy5jcmVhdGUoYi5zbGljZSgyLDQpKTtiLnNwbGljZSgwLDQpO2Euc2lnQnl0ZXMtPTE2fXJldHVybiBuLmNyZWF0ZSh7Y2lwaGVydGV4dDphLHNhbHQ6Y30pfX0sYT1kLlNlcmlhbGl6YWJsZUNpcGhlcj1sLmV4dGVuZCh7Y2ZnOmwuZXh0ZW5kKHtmb3JtYXQ6Yn0pLGVuY3J5cHQ6ZnVuY3Rpb24oYSxiLGMsZCl7ZD10aGlzLmNmZy5leHRlbmQoZCk7dmFyIGw9YS5jcmVhdGVFbmNyeXB0b3IoYyxkKTtiPWwuZmluYWxpemUoYik7bD1sLmNmZztyZXR1cm4gbi5jcmVhdGUoe2NpcGhlcnRleHQ6YixrZXk6YyxpdjpsLml2LGFsZ29yaXRobTphLG1vZGU6bC5tb2RlLHBhZGRpbmc6bC5wYWRkaW5nLGJsb2NrU2l6ZTphLmJsb2NrU2l6ZSxmb3JtYXR0ZXI6ZC5mb3JtYXR9KX0sXG5cdCAgZGVjcnlwdDpmdW5jdGlvbihhLGIsYyxkKXtkPXRoaXMuY2ZnLmV4dGVuZChkKTtiPXRoaXMuX3BhcnNlKGIsZC5mb3JtYXQpO3JldHVybiBhLmNyZWF0ZURlY3J5cHRvcihjLGQpLmZpbmFsaXplKGIuY2lwaGVydGV4dCl9LF9wYXJzZTpmdW5jdGlvbihhLGIpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhP2IucGFyc2UoYSx0aGlzKTphfX0pLHA9KHAua2RmPXt9KS5PcGVuU1NMPXtleGVjdXRlOmZ1bmN0aW9uKGEsYixjLGQpe2R8fChkPXMucmFuZG9tKDgpKTthPXcuY3JlYXRlKHtrZXlTaXplOmIrY30pLmNvbXB1dGUoYSxkKTtjPXMuY3JlYXRlKGEud29yZHMuc2xpY2UoYiksNCpjKTthLnNpZ0J5dGVzPTQqYjtyZXR1cm4gbi5jcmVhdGUoe2tleTphLGl2OmMsc2FsdDpkfSl9fSxjPWQuUGFzc3dvcmRCYXNlZENpcGhlcj1hLmV4dGVuZCh7Y2ZnOmEuY2ZnLmV4dGVuZCh7a2RmOnB9KSxlbmNyeXB0OmZ1bmN0aW9uKGIsYyxkLGwpe2w9dGhpcy5jZmcuZXh0ZW5kKGwpO2Q9bC5rZGYuZXhlY3V0ZShkLFxuXHQgIGIua2V5U2l6ZSxiLml2U2l6ZSk7bC5pdj1kLml2O2I9YS5lbmNyeXB0LmNhbGwodGhpcyxiLGMsZC5rZXksbCk7Yi5taXhJbihkKTtyZXR1cm4gYn0sZGVjcnlwdDpmdW5jdGlvbihiLGMsZCxsKXtsPXRoaXMuY2ZnLmV4dGVuZChsKTtjPXRoaXMuX3BhcnNlKGMsbC5mb3JtYXQpO2Q9bC5rZGYuZXhlY3V0ZShkLGIua2V5U2l6ZSxiLml2U2l6ZSxjLnNhbHQpO2wuaXY9ZC5pdjtyZXR1cm4gYS5kZWNyeXB0LmNhbGwodGhpcyxiLGMsZC5rZXksbCl9fSl9KCk7XG5cblx0Ly8gQUVTXG5cdChmdW5jdGlvbigpe2Zvcih2YXIgdT1DcnlwdG9KUyxwPXUubGliLkJsb2NrQ2lwaGVyLGQ9dS5hbGdvLGw9W10scz1bXSx0PVtdLHI9W10sdz1bXSx2PVtdLGI9W10seD1bXSxxPVtdLG49W10sYT1bXSxjPTA7MjU2PmM7YysrKWFbY109MTI4PmM/Yzw8MTpjPDwxXjI4Mztmb3IodmFyIGU9MCxqPTAsYz0wOzI1Nj5jO2MrKyl7dmFyIGs9al5qPDwxXmo8PDJeajw8M15qPDw0LGs9az4+PjheayYyNTVeOTk7bFtlXT1rO3Nba109ZTt2YXIgej1hW2VdLEY9YVt6XSxHPWFbRl0seT0yNTcqYVtrXV4xNjg0MzAwOCprO3RbZV09eTw8MjR8eT4+Pjg7cltlXT15PDwxNnx5Pj4+MTY7d1tlXT15PDw4fHk+Pj4yNDt2W2VdPXk7eT0xNjg0MzAwOSpHXjY1NTM3KkZeMjU3KnpeMTY4NDMwMDgqZTtiW2tdPXk8PDI0fHk+Pj44O3hba109eTw8MTZ8eT4+PjE2O3Fba109eTw8OHx5Pj4+MjQ7bltrXT15O2U/KGU9el5hW2FbYVtHXnpdXV0sal49YVthW2pdXSk6ZT1qPTF9dmFyIEg9WzAsMSwyLDQsOCxcblx0ICAxNiwzMiw2NCwxMjgsMjcsNTRdLGQ9ZC5BRVM9cC5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuX2tleSxjPWEud29yZHMsZD1hLnNpZ0J5dGVzLzQsYT00KigodGhpcy5fblJvdW5kcz1kKzYpKzEpLGU9dGhpcy5fa2V5U2NoZWR1bGU9W10saj0wO2o8YTtqKyspaWYoajxkKWVbal09Y1tqXTtlbHNle3ZhciBrPWVbai0xXTtqJWQ/NjxkJiY0PT1qJWQmJihrPWxbaz4+PjI0XTw8MjR8bFtrPj4+MTYmMjU1XTw8MTZ8bFtrPj4+OCYyNTVdPDw4fGxbayYyNTVdKTooaz1rPDw4fGs+Pj4yNCxrPWxbaz4+PjI0XTw8MjR8bFtrPj4+MTYmMjU1XTw8MTZ8bFtrPj4+OCYyNTVdPDw4fGxbayYyNTVdLGtePUhbai9kfDBdPDwyNCk7ZVtqXT1lW2otZF1ea31jPXRoaXMuX2ludktleVNjaGVkdWxlPVtdO2ZvcihkPTA7ZDxhO2QrKylqPWEtZCxrPWQlND9lW2pdOmVbai00XSxjW2RdPTQ+ZHx8ND49aj9rOmJbbFtrPj4+MjRdXV54W2xbaz4+PjE2JjI1NV1dXnFbbFtrPj4+XG5cdDgmMjU1XV1ebltsW2smMjU1XV19LGVuY3J5cHRCbG9jazpmdW5jdGlvbihhLGIpe3RoaXMuX2RvQ3J5cHRCbG9jayhhLGIsdGhpcy5fa2V5U2NoZWR1bGUsdCxyLHcsdixsKX0sZGVjcnlwdEJsb2NrOmZ1bmN0aW9uKGEsYyl7dmFyIGQ9YVtjKzFdO2FbYysxXT1hW2MrM107YVtjKzNdPWQ7dGhpcy5fZG9DcnlwdEJsb2NrKGEsYyx0aGlzLl9pbnZLZXlTY2hlZHVsZSxiLHgscSxuLHMpO2Q9YVtjKzFdO2FbYysxXT1hW2MrM107YVtjKzNdPWR9LF9kb0NyeXB0QmxvY2s6ZnVuY3Rpb24oYSxiLGMsZCxlLGosbCxmKXtmb3IodmFyIG09dGhpcy5fblJvdW5kcyxnPWFbYl1eY1swXSxoPWFbYisxXV5jWzFdLGs9YVtiKzJdXmNbMl0sbj1hW2IrM11eY1szXSxwPTQscj0xO3I8bTtyKyspdmFyIHE9ZFtnPj4+MjRdXmVbaD4+PjE2JjI1NV1ealtrPj4+OCYyNTVdXmxbbiYyNTVdXmNbcCsrXSxzPWRbaD4+PjI0XV5lW2s+Pj4xNiYyNTVdXmpbbj4+PjgmMjU1XV5sW2cmMjU1XV5jW3ArK10sdD1cblx0ICBkW2s+Pj4yNF1eZVtuPj4+MTYmMjU1XV5qW2c+Pj44JjI1NV1ebFtoJjI1NV1eY1twKytdLG49ZFtuPj4+MjRdXmVbZz4+PjE2JjI1NV1ealtoPj4+OCYyNTVdXmxbayYyNTVdXmNbcCsrXSxnPXEsaD1zLGs9dDtxPShmW2c+Pj4yNF08PDI0fGZbaD4+PjE2JjI1NV08PDE2fGZbaz4+PjgmMjU1XTw8OHxmW24mMjU1XSleY1twKytdO3M9KGZbaD4+PjI0XTw8MjR8ZltrPj4+MTYmMjU1XTw8MTZ8ZltuPj4+OCYyNTVdPDw4fGZbZyYyNTVdKV5jW3ArK107dD0oZltrPj4+MjRdPDwyNHxmW24+Pj4xNiYyNTVdPDwxNnxmW2c+Pj44JjI1NV08PDh8ZltoJjI1NV0pXmNbcCsrXTtuPShmW24+Pj4yNF08PDI0fGZbZz4+PjE2JjI1NV08PDE2fGZbaD4+PjgmMjU1XTw8OHxmW2smMjU1XSleY1twKytdO2FbYl09cTthW2IrMV09czthW2IrMl09dDthW2IrM109bn0sa2V5U2l6ZTo4fSk7dS5BRVM9cC5fY3JlYXRlSGVscGVyKGQpfSkoKTtcblxuXHQvLyBNb2RlIEVDQlxuXHRDcnlwdG9KUy5tb2RlLkVDQiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIEVDQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICBFQ0IuRW5jcnlwdG9yID0gRUNCLmV4dGVuZCh7XG5cdCAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICBFQ0IuRGVjcnlwdG9yID0gRUNCLmV4dGVuZCh7XG5cdCAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgIHRoaXMuX2NpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICByZXR1cm4gRUNCO1xuXHR9KCkpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQ3J5cHRvSlM7XG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBXRUJTT0NLRVQgSU5URVJGQUNFXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHR2YXIgV1MgPSBmdW5jdGlvbiggdXJsLCBwcm90b2NvbHMgKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdTKSkgcmV0dXJuIG5ldyBXUyggdXJsLCBwcm90b2NvbHMgKTtcblxuXHQgIHZhciBzZWxmICAgICA9IHRoaXNcblx0ICAgICwgICB1cmwgICAgICA9IHNlbGYudXJsICAgICAgPSB1cmwgfHwgJydcblx0ICAgICwgICBwcm90b2NvbCA9IHNlbGYucHJvdG9jb2wgPSBwcm90b2NvbHMgfHwgJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXG5cdCAgICAsICAgYml0cyAgICAgPSB1cmwuc3BsaXQoJy8nKVxuXHQgICAgLCAgIHNldHVwICAgID0ge1xuXHQgICAgJ3NzbCcgICAgICAgICAgIDogYml0c1swXSA9PT0gJ3dzczonXG5cdCAgICAsJ29yaWdpbicgICAgICAgIDogYml0c1syXVxuXHQgICAgLCdwdWJsaXNoX2tleScgICA6IGJpdHNbM11cblx0ICAgICwnc3Vic2NyaWJlX2tleScgOiBiaXRzWzRdXG5cdCAgICAsJ2NoYW5uZWwnICAgICAgIDogYml0c1s1XVxuXHQgIH07XG5cblx0ICAvLyBSRUFEWSBTVEFURVNcblx0ICBzZWxmWydDT05ORUNUSU5HJ10gPSAwOyAvLyBUaGUgY29ubmVjdGlvbiBpcyBub3QgeWV0IG9wZW4uXG5cdCAgc2VsZlsnT1BFTiddICAgICAgID0gMTsgLy8gVGhlIGNvbm5lY3Rpb24gaXMgb3BlbiBhbmQgcmVhZHkgdG8gY29tbXVuaWNhdGUuXG5cdCAgc2VsZlsnQ0xPU0lORyddICAgID0gMjsgLy8gVGhlIGNvbm5lY3Rpb24gaXMgaW4gdGhlIHByb2Nlc3Mgb2YgY2xvc2luZy5cblx0ICBzZWxmWydDTE9TRUQnXSAgICAgPSAzOyAvLyBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQgb3IgY291bGRuJ3QgYmUgb3BlbmVkLlxuXG5cdCAgLy8gQ0xPU0UgU1RBVEVTXG5cdCAgc2VsZlsnQ0xPU0VfTk9STUFMJ10gICAgICAgICA9IDEwMDA7IC8vIE5vcm1hbCBJbnRlbmRlZCBDbG9zZTsgY29tcGxldGVkLlxuXHQgIHNlbGZbJ0NMT1NFX0dPSU5HX0FXQVknXSAgICAgPSAxMDAxOyAvLyBDbG9zZWQgVW5leHBlY3R0ZWRseS5cblx0ICBzZWxmWydDTE9TRV9QUk9UT0NPTF9FUlJPUiddID0gMTAwMjsgLy8gU2VydmVyOiBOb3QgU3VwcG9ydGVkLlxuXHQgIHNlbGZbJ0NMT1NFX1VOU1VQUE9SVEVEJ10gICAgPSAxMDAzOyAvLyBTZXJ2ZXI6IFVuc3VwcG9ydGVkIFByb3RvY29sLlxuXHQgIHNlbGZbJ0NMT1NFX1RPT19MQVJHRSddICAgICAgPSAxMDA0OyAvLyBTZXJ2ZXI6IFRvbyBNdWNoIERhdGEuXG5cdCAgc2VsZlsnQ0xPU0VfTk9fU1RBVFVTJ10gICAgICA9IDEwMDU7IC8vIFNlcnZlcjogTm8gcmVhc29uLlxuXHQgIHNlbGZbJ0NMT1NFX0FCTk9STUFMJ10gICAgICAgPSAxMDA2OyAvLyBBYm5vcm1hbCBEaXNjb25uZWN0LlxuXG5cdCAgLy8gRXZlbnRzIERlZmF1bHRcblx0ICBzZWxmWydvbmNsb3NlJ10gICA9IHNlbGZbJ29uZXJyb3InXSA9XG5cdCAgICBzZWxmWydvbm1lc3NhZ2UnXSA9IHNlbGZbJ29ub3BlbiddICA9XG5cdCAgICAgIHNlbGZbJ29uc2VuZCddICAgID0gIGZ1bmN0aW9uKCl7fTtcblxuXHQgIC8vIEF0dHJpYnV0ZXNcblx0ICBzZWxmWydiaW5hcnlUeXBlJ10gICAgID0gJyc7XG5cdCAgc2VsZlsnZXh0ZW5zaW9ucyddICAgICA9ICcnO1xuXHQgIHNlbGZbJ2J1ZmZlcmVkQW1vdW50J10gPSAwO1xuXHQgIHNlbGZbJ3RyYXNubWl0dGluZyddICAgPSBmYWxzZTtcblx0ICBzZWxmWydidWZmZXInXSAgICAgICAgID0gW107XG5cdCAgc2VsZlsncmVhZHlTdGF0ZSddICAgICA9IHNlbGZbJ0NPTk5FQ1RJTkcnXTtcblxuXHQgIC8vIENsb3NlIGlmIG5vIHNldHVwLlxuXHQgIGlmICghdXJsKSB7XG5cdCAgICBzZWxmWydyZWFkeVN0YXRlJ10gPSBzZWxmWydDTE9TRUQnXTtcblx0ICAgIHNlbGZbJ29uY2xvc2UnXSh7XG5cdCAgICAgICdjb2RlJyAgICAgOiBzZWxmWydDTE9TRV9BQk5PUk1BTCddLFxuXHQgICAgICAncmVhc29uJyAgIDogJ01pc3NpbmcgVVJMJyxcblx0ICAgICAgJ3dhc0NsZWFuJyA6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHNlbGY7XG5cdCAgfVxuXG5cdCAgLy8gUHViTnViIFdlYlNvY2tldCBFbXVsYXRpb25cblx0ICBzZWxmLnB1Ym51YiAgICAgICA9IFBVQk5VQlsnaW5pdCddKHNldHVwKTtcblx0ICBzZWxmLnB1Ym51Yi5zZXR1cCA9IHNldHVwO1xuXHQgIHNlbGYuc2V0dXAgICAgICAgID0gc2V0dXA7XG5cblx0ICBzZWxmLnB1Ym51Ylsnc3Vic2NyaWJlJ10oe1xuXHQgICAgJ3Jlc3RvcmUnICAgIDogZmFsc2UsXG5cdCAgICAnY2hhbm5lbCcgICAgOiBzZXR1cFsnY2hhbm5lbCddLFxuXHQgICAgJ2Rpc2Nvbm5lY3QnIDogc2VsZlsnb25lcnJvciddLFxuXHQgICAgJ3JlY29ubmVjdCcgIDogc2VsZlsnb25vcGVuJ10sXG5cdCAgICAnZXJyb3InICAgICAgOiBmdW5jdGlvbigpIHtcblx0ICAgICAgc2VsZlsnb25jbG9zZSddKHtcblx0ICAgICAgICAnY29kZScgICAgIDogc2VsZlsnQ0xPU0VfQUJOT1JNQUwnXSxcblx0ICAgICAgICAncmVhc29uJyAgIDogJ01pc3NpbmcgVVJMJyxcblx0ICAgICAgICAnd2FzQ2xlYW4nIDogZmFsc2Vcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgJ2NhbGxiYWNrJyAgIDogZnVuY3Rpb24obWVzc2FnZSkge1xuXHQgICAgICBzZWxmWydvbm1lc3NhZ2UnXSh7ICdkYXRhJyA6IG1lc3NhZ2UgfSk7XG5cdCAgICB9LFxuXHQgICAgJ2Nvbm5lY3QnICAgIDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHNlbGZbJ3JlYWR5U3RhdGUnXSA9IHNlbGZbJ09QRU4nXTtcblx0ICAgICAgc2VsZlsnb25vcGVuJ10oKTtcblx0ICAgIH1cblx0ICB9KTtcblx0fTtcblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gV0VCU09DS0VUIFNFTkRcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFdTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBzZWxmLnB1Ym51YlsncHVibGlzaCddKHtcblx0ICAgICdjaGFubmVsJyAgOiBzZWxmLnB1Ym51Yi5zZXR1cFsnY2hhbm5lbCddLFxuXHQgICAgJ21lc3NhZ2UnICA6IGRhdGEsXG5cdCAgICAnY2FsbGJhY2snIDogZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0ICAgICAgc2VsZlsnb25zZW5kJ10oeyAnZGF0YScgOiByZXNwb25zZSB9KTtcblx0ICAgIH1cblx0ICB9KTtcblx0fTtcblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gV0VCU09DS0VUIENMT1NFXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRXUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgc2VsZi5wdWJudWJbJ3Vuc3Vic2NyaWJlJ10oeyAnY2hhbm5lbCcgOiBzZWxmLnB1Ym51Yi5zZXR1cFsnY2hhbm5lbCddIH0pO1xuXHQgIHNlbGZbJ3JlYWR5U3RhdGUnXSA9IHNlbGZbJ0NMT1NFRCddO1xuXHQgIHNlbGZbJ29uY2xvc2UnXSh7fSk7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBXUztcblxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcHVibnViL21vZGVybi9kaXN0L3B1Ym51Yi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQ2xpZW50XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJpbmdDZW50cmFsXCJdID0gcm9vdFtcIlJpbmdDZW50cmFsXCJdIHx8IHt9LCByb290W1wiUmluZ0NlbnRyYWxcIl1bXCJDbGllbnRcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBhY2NvdW50Q2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBjYWxsTG9nQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG52YXIgZGljdGlvbmFyeUNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xudmFyIGV4dGVuc2lvbkNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xudmFyIG1lc3NhZ2VzQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG52YXIgbm90aWZpY2F0aW9uc0NsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xudmFyIHByZXNlbmNlQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XG52YXIgcmluZ291dENsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOTMpO1xudmFyIGZvcndhcmRpbmdOdW1iZXJzQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nik7XG52YXIgYmxvY2tlZE51bWJlcnNDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KTtcbnZhciBDbGllbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsaWVudChzZGspIHtcbiAgICAgICAgdGhpcy5fc2RrID0gc2RrO1xuICAgICAgICB0aGlzLl9hY2NvdW50ID0gbmV3IGFjY291bnRDbGllbnQuQWNjb3VudChzZGspO1xuICAgICAgICB0aGlzLl9jYWxsTG9nID0gbmV3IGNhbGxMb2dDbGllbnQuQ2FsbExvZyhzZGspO1xuICAgICAgICB0aGlzLl9kaWN0aW9uYXJ5ID0gbmV3IGRpY3Rpb25hcnlDbGllbnQuRGljdGlvbmFyeShzZGspO1xuICAgICAgICB0aGlzLl9leHRlbnNpb24gPSBuZXcgZXh0ZW5zaW9uQ2xpZW50LkV4dGVuc2lvbihzZGspO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IG5ldyBtZXNzYWdlc0NsaWVudC5NZXNzYWdlcyhzZGspO1xuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25zID0gbmV3IG5vdGlmaWNhdGlvbnNDbGllbnQuTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSShzZGspO1xuICAgICAgICB0aGlzLl9wcmVzZW5jZSA9IG5ldyBwcmVzZW5jZUNsaWVudC5QcmVzZW5jZShzZGspO1xuICAgICAgICB0aGlzLl9yaW5nb3V0ID0gbmV3IHJpbmdvdXRDbGllbnQuUmluZ091dChzZGspO1xuICAgICAgICB0aGlzLl9mb3J3YXJkaW5nTnVtYmVycyA9IG5ldyBmb3J3YXJkaW5nTnVtYmVyc0NsaWVudC5Gb3J3YXJkaW5nTnVtYmVycyhzZGspO1xuICAgICAgICB0aGlzLl9ibG9ja2VkTnVtYmVycyA9IG5ldyBibG9ja2VkTnVtYmVyc0NsaWVudC5CbG9ja2VkTnVtYmVycyhzZGspO1xuICAgIH1cbiAgICBDbGllbnQucHJvdG90eXBlLmFjY291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hY2NvdW50OyB9O1xuICAgIENsaWVudC5wcm90b3R5cGUuY2FsbExvZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NhbGxMb2c7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5kaWN0aW9uYXJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGljdGlvbmFyeTsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmV4dGVuc2lvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2V4dGVuc2lvbjsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLm1lc3NhZ2VzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWVzc2FnZXM7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5ub3RpZmljYXRpb25zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbm90aWZpY2F0aW9uczsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLnByZXNlbmNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJlc2VuY2U7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5yaW5nb3V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmluZ291dDsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmZvcndhcmRpbmdOdW1iZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZm9yd2FyZGluZ051bWJlcnM7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5ibG9ja2VkTnVtYmVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Jsb2NrZWROdW1iZXJzOyB9O1xuICAgIENsaWVudC52ZXJzaW9uID0gJzAuMS4wJztcbiAgICByZXR1cm4gQ2xpZW50O1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50O1xuXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBhY2NvdW50aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgYWNjb3VudGJ1c2luZXNzYWRkcmVzcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xudmFyIGRpYWxpbmdwbGFuaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xudmFyIHBob25lbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIGFjY291bnRwaG9uZW51bWJlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcbnZhciBhY2NvdW50c2VydmljZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbnZhciBBY2NvdW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIEFjY291bnRcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPkNyZWF0ZXMgdGhlIGFjY291bnQgaW4gSW5pdGlhbCBzdGF0ZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+TWFuYWdpbmcgYWNjb3VudHM6IGNyZWF0aW5nIG5ldyBhY2NvdW50cywgdmlld2luZyBhbmQgdXBkYXRpbmcgYWNjb3VudCBpbmZvcm1hdGlvbiwgZGVsZXRpbmcgZXhpc3RpbmcgYWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlciwgYXNzaWduZWQgcGhvbmUgbnVtYmVycywgZGV2aWNlcyBhbmQgb3RoZXIgZXh0ZW5zaW9uIHNldHRpbmdzKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmNyZWF0ZUFjY291bnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudCcsIG9wdGlvbnMsIGV4cG9ydHMuY3JlYXRlQWNjb3VudE9wdGlvbnMpLCBhY2NvdW50aW5mby5BY2NvdW50SW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWNjb3VudCBJbmZvXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMDwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGEgcGFydGljdWxhciBSaW5nQ2VudHJhbCBjdXN0b21lciBhY2NvdW50LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxvYWRBY2NvdW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEFjY291bnRPcHRpb25zKSwgYWNjb3VudGluZm8uQWNjb3VudEluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgQnVzaW5lc3MgQWRkcmVzc1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxvYWRBY2NvdW50QnVzaW5lc3NBZGRyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9idXNpbmVzcy1hZGRyZXNzJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQWNjb3VudEJ1c2luZXNzQWRkcmVzc09wdGlvbnMpLCBhY2NvdW50aW5mby5BY2NvdW50SW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgQWNjb3VudCBCdXNpbmVzcyBBZGRyZXNzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0QWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUudXBkYXRlQWNjb3VudEJ1c2luZXNzQWRkcmVzcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BVVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vYnVzaW5lc3MtYWRkcmVzcycsIG9wdGlvbnMsIGV4cG9ydHMudXBkYXRlQWNjb3VudEJ1c2luZXNzQWRkcmVzc09wdGlvbnMpLCBhY2NvdW50YnVzaW5lc3NhZGRyZXNzLkFjY291bnRCdXNpbmVzc0FkZHJlc3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgRGlhbGluZyBQbGFuXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+UmV0dXJucyBsaXN0IG9mIGNvdW50cmllcyB3aGljaCBjYW4gYmUgc2VsZWN0ZWQgZm9yIGEgZGlhbGluZyBwbGFuICh0byBjYWxsIHNob3J0IG51bWJlcnMgYW5kIHNwZWNpYWwgc2VydmljZXMpLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxpc3REaWFsaW5nUGxhbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2RpYWxpbmctcGxhbicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdERpYWxpbmdQbGFuc09wdGlvbnMpLCBkaWFsaW5ncGxhbmluZm8uRGlhbGluZ1BsYW5JbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3Zpc2lvbiBQaG9uZSBOdW1iZXJzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTEgKFJlbGVhc2UgNi4zKTwvcD5cbiAgICAgKiA8cD5Qcm92aXNpb25zIGEgcGhvbmUgbnVtYmVyLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLnByb3Zpc2lvblBob25lTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vcGhvbmUtbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5wcm92aXNpb25QaG9uZU51bWJlck9wdGlvbnMpLCBwaG9uZW51bWJlcmluZm8uUGhvbmVOdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBBY2NvdW50IFBob25lIE51bWJlcnNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgcGhvbmUgbnVtYmVycyBhc3NpZ25lZCB0byB0aGUgUmluZ0NlbnRyYWwgY3VzdG9tZXIgYWNjb3VudC4gQm90aCBjb21wYW55LWxldmVsIGFuZCBleHRlbnNpb24tbGV2ZWwgbnVtYmVycyBhcmUgcmV0dXJuZWQuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUubGlzdEFjY291bnRQaG9uZU51bWJlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L3Bob25lLW51bWJlcicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEFjY291bnRQaG9uZU51bWJlcnNPcHRpb25zKSwgYWNjb3VudHBob25lbnVtYmVycy5BY2NvdW50UGhvbmVOdW1iZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBQaG9uZSBOdW1iZXIocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS5sb2FkQWNjb3VudFBob25lTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9waG9uZS1udW1iZXIve3Bob25lTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQWNjb3VudFBob25lTnVtYmVyT3B0aW9ucyksIHBob25lbnVtYmVyaW5mby5QaG9uZU51bWJlckluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgU2VydmljZSBJbmZvXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMDwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBzZXJ2aWNlIHBsYW4sIGF2YWlsYWJsZSBmZWF0dXJlcyBhbmQgbGltaXRhdGlvbnMgZm9yIGEgcGFydGljdWxhciBSaW5nQ2VudHJhbCBjdXN0b21lciBhY2NvdW50LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxvYWRTZXJ2aWNlSW5mbyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vc2VydmljZS1pbmZvJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkU2VydmljZUluZm9PcHRpb25zKSwgYWNjb3VudHNlcnZpY2VpbmZvLkFjY291bnRTZXJ2aWNlSW5mbyk7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudDtcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5BY2NvdW50ID0gQWNjb3VudDtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBjcmVhdGVBY2NvdW50IG9wZXJhdGlvblxuICovXG5leHBvcnRzLmNyZWF0ZUFjY291bnRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcImNyZWF0ZWFjY291bnRyZXF1ZXN0LkNyZWF0ZUFjY291bnRSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRBY2NvdW50IG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRBY2NvdW50T3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRBY2NvdW50QnVzaW5lc3NBZGRyZXNzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRBY2NvdW50QnVzaW5lc3NBZGRyZXNzT3B0aW9ucyA9IFtdO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHVwZGF0ZUFjY291bnRCdXNpbmVzc0FkZHJlc3Mgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlQWNjb3VudEJ1c2luZXNzQWRkcmVzc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibW9kaWZ5YWNjb3VudGJ1c2luZXNzYWRkcmVzc3JlcXVlc3QuTW9kaWZ5QWNjb3VudEJ1c2luZXNzQWRkcmVzc1JlcXVlc3RcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdERpYWxpbmdQbGFucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RGlhbGluZ1BsYW5zT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHByb3Zpc2lvblBob25lTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnByb3Zpc2lvblBob25lTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcInByb3Zpc2lvbnBob25lbnVtYmVycy5Qcm92aXNpb25QaG9uZU51bWJlcnNcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEFjY291bnRQaG9uZU51bWJlcnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEFjY291bnRQaG9uZU51bWJlcnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ1c2FnZVR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiTWFpbkNvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiQ29tcGFueU51bWJlclwiLFxuICAgICAgICAgICAgXCJEaXJlY3ROdW1iZXJcIixcbiAgICAgICAgICAgIFwiQ29tcGFueUZheE51bWJlclwiLFxuICAgICAgICAgICAgXCJGb3J3YXJkZWROdW1iZXJcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEFjY291bnRQaG9uZU51bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQWNjb3VudFBob25lTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGhvbmVOdW1iZXJJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkU2VydmljZUluZm8gb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFNlcnZpY2VJbmZvT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuKGZ1bmN0aW9uIChJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGUpIHtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiTWFpbkNvbXBhbnlOdW1iZXJcIl0gPSAnTWFpbkNvbXBhbnlOdW1iZXInXSA9IFwiTWFpbkNvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIl0gPSAnQWRkaXRpb25hbENvbXBhbnlOdW1iZXInXSA9IFwiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQ29tcGFueU51bWJlclwiXSA9ICdDb21wYW55TnVtYmVyJ10gPSBcIkNvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiRGlyZWN0TnVtYmVyXCJdID0gJ0RpcmVjdE51bWJlciddID0gXCJEaXJlY3ROdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQ29tcGFueUZheE51bWJlclwiXSA9ICdDb21wYW55RmF4TnVtYmVyJ10gPSBcIkNvbXBhbnlGYXhOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiRm9yd2FyZGVkTnVtYmVyXCJdID0gJ0ZvcndhcmRlZE51bWJlciddID0gXCJGb3J3YXJkZWROdW1iZXJcIjtcbn0pKGV4cG9ydHMuSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlIHx8IChleHBvcnRzLklMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlID0gZXhwb3J0cy5JTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ2xpZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGllbnQoc2RrKSB7XG4gICAgICAgIHRoaXMuX3NkayA9IHNkaztcbiAgICB9XG4gICAgQ2xpZW50LnByb3RvdHlwZS5wYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIG9wdGlvbnMsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgICAgICAgIGJvZHk6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICBpZiAocGFyYW0ucmVxdWlyZWQgJiYgIXBhcmFtLmRlZmF1bHQgJiYgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkocGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIHBhcmFtZXRlciBcIicgKyBwYXJhbS5uYW1lICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLmRlZmF1bHQgJiYgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkocGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW3BhcmFtLm5hbWVdID0gcGFyYW0uZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS5pbiA9PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnVybCA9IHJlcXVlc3QudXJsLnJlcGxhY2UoJ3snICsgcGFyYW0ubmFtZSArICd9Jywgb3B0aW9uc1twYXJhbS5uYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0uaW4gPT0gJ3F1ZXJ5JyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KHBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5xdWVyeVtwYXJhbS5uYW1lXSA9IG9wdGlvbnNbcGFyYW0ubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0uaW4gPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0gb3B0aW9uc1twYXJhbS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGFwaU9wdGlvbnMsIENsYXNzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZGsucGxhdGZvcm0oKVxuICAgICAgICAgICAgLnNlbmQoYXBpT3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIC8vVE9ETyBTdXBwb3J0IG11bHRpcGFydFxuICAgICAgICAgICAgLy9UT0RPIFRoaW5rIGhvdyB0byBwYXNzIGhlYWRlcnMmc3R1ZmYgdG8gb3V0c2lkZVxuICAgICAgICAgICAgaWYgKENsYXNzICYmICFyZXMuX2lzTXVsdGlwYXJ0KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDbGFzcyhfdGhpcy5fc2RrLCByZXMuanNvbigpKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENsaWVudDtcbn0oKSk7XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcblxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBleHRlbnNpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBzZXJ2aWNlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xudmFyIGFjY291bnRzdGF0dXNpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG52YXIgQWNjb3VudEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21haW5OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ29wZXJhdG9yJywgQ2xhc3M6IGV4dGVuc2lvbmluZm8uRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFydG5lcklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXJ2aWNlSW5mbycsIENsYXNzOiBzZXJ2aWNlaW5mby5TZXJ2aWNlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2V0dXBXaXphcmRTdGF0ZScsIENsYXNzOiBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXR1cycsIENsYXNzOiBBY2NvdW50SW5mb1N0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdHVzSW5mbycsIENsYXNzOiBhY2NvdW50c3RhdHVzaW5mby5BY2NvdW50U3RhdHVzSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50SW5mbyA9IEFjY291bnRJbmZvO1xuKGZ1bmN0aW9uIChBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGUpIHtcbiAgICBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW1wiTm90U3RhcnRlZFwiXSA9ICdOb3RTdGFydGVkJ10gPSBcIk5vdFN0YXJ0ZWRcIjtcbiAgICBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW1wiSW5jb21wbGV0ZVwiXSA9ICdJbmNvbXBsZXRlJ10gPSBcIkluY29tcGxldGVcIjtcbiAgICBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW1wiQ29tcGxldGVkXCJdID0gJ0NvbXBsZXRlZCddID0gXCJDb21wbGV0ZWRcIjtcbn0pKGV4cG9ydHMuQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlIHx8IChleHBvcnRzLkFjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZSA9IHt9KSk7XG52YXIgQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlID0gZXhwb3J0cy5BY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGU7XG4oZnVuY3Rpb24gKEFjY291bnRJbmZvU3RhdHVzKSB7XG4gICAgQWNjb3VudEluZm9TdGF0dXNbQWNjb3VudEluZm9TdGF0dXNbXCJDb25maXJtZWRcIl0gPSAnQ29uZmlybWVkJ10gPSBcIkNvbmZpcm1lZFwiO1xuICAgIEFjY291bnRJbmZvU3RhdHVzW0FjY291bnRJbmZvU3RhdHVzW1wiRGlzYWJsZWRcIl0gPSAnRGlzYWJsZWQnXSA9IFwiRGlzYWJsZWRcIjtcbn0pKGV4cG9ydHMuQWNjb3VudEluZm9TdGF0dXMgfHwgKGV4cG9ydHMuQWNjb3VudEluZm9TdGF0dXMgPSB7fSkpO1xudmFyIEFjY291bnRJbmZvU3RhdHVzID0gZXhwb3J0cy5BY2NvdW50SW5mb1N0YXR1cztcblxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBNb2RlbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kZWwoc2RrLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3NkayA9IHNkaztcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgIHRoaXMuZ2V0UHJvcGVydHlNYXBwaW5ncygpLmZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgICAgIHZhciBDbGFzcyA9IG1hcHBpbmcuQ2xhc3MsIHByb3AgPSBtYXBwaW5nLnByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBpbmcuaXNSZXF1aXJlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdSZXF1aXJlZCBwcm9wZXJ0eSBcIicgKyBwcm9wICsgJ1wiIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb2Nlc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uIChkYXRhUGFydCkge1xuICAgICAgICAgICAgICAgIGlmICghQ2xhc3MgfHwgdHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2xhc3MoX3RoaXMuX3NkaywgZGF0YVBhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobWFwcGluZy5pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXNbcHJvcF0gPSBkYXRhW3Byb3BdLm1hcChwcm9jZXNzUHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXNbcHJvcF0gPSBwcm9jZXNzUHJvcGVydHkoZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNb2RlbCc7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWydpZCddO1xuICAgIH07XG4gICAgcmV0dXJuIE1vZGVsO1xufSgpKTtcbmV4cG9ydHMuTW9kZWwgPSBNb2RlbDtcblxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjb250YWN0aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgZGVwYXJ0bWVudGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xudmFyIGV4dGVuc2lvbnBlcm1pc3Npb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgcHJvZmlsZWltYWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIHJlZmVyZW5jZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbnZhciByZWdpb25hbHNldHRpbmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgZXh0ZW5zaW9uc2VydmljZWZlYXR1cmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG52YXIgZXh0ZW5zaW9uc3RhdHVzaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xudmFyIEV4dGVuc2lvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb250YWN0JywgQ2xhc3M6IGNvbnRhY3RpbmZvLkNvbnRhY3RJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkZXBhcnRtZW50cycsIENsYXNzOiBkZXBhcnRtZW50aW5mby5EZXBhcnRtZW50SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYXJ0bmVySWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Blcm1pc3Npb25zJywgQ2xhc3M6IGV4dGVuc2lvbnBlcm1pc3Npb25zLkV4dGVuc2lvblBlcm1pc3Npb25zLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwcm9maWxlSW1hZ2UnLCBDbGFzczogcHJvZmlsZWltYWdlaW5mby5Qcm9maWxlSW1hZ2VJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlZmVyZW5jZXMnLCBDbGFzczogcmVmZXJlbmNlaW5mby5SZWZlcmVuY2VJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlZ2lvbmFsU2V0dGluZ3MnLCBDbGFzczogcmVnaW9uYWxzZXR0aW5ncy5SZWdpb25hbFNldHRpbmdzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXJ2aWNlRmVhdHVyZXMnLCBDbGFzczogZXh0ZW5zaW9uc2VydmljZWZlYXR1cmVpbmZvLkV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXR1cFdpemFyZFN0YXRlJywgQ2xhc3M6IEV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXMnLCBDbGFzczogRXh0ZW5zaW9uSW5mb1N0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXNJbmZvJywgQ2xhc3M6IGV4dGVuc2lvbnN0YXR1c2luZm8uRXh0ZW5zaW9uU3RhdHVzSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBFeHRlbnNpb25JbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkluZm8gPSBFeHRlbnNpb25JbmZvO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZSkge1xuICAgIEV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlW0V4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlW1wiTm90U3RhcnRlZFwiXSA9ICdOb3RTdGFydGVkJ10gPSBcIk5vdFN0YXJ0ZWRcIjtcbiAgICBFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZVtFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZVtcIkluY29tcGxldGVcIl0gPSAnSW5jb21wbGV0ZSddID0gXCJJbmNvbXBsZXRlXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGVbRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGVbXCJDb21wbGV0ZWRcIl0gPSAnQ29tcGxldGVkJ10gPSBcIkNvbXBsZXRlZFwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZSB8fCAoZXhwb3J0cy5FeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZSA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGUgPSBleHBvcnRzLkV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvU3RhdHVzKSB7XG4gICAgRXh0ZW5zaW9uSW5mb1N0YXR1c1tFeHRlbnNpb25JbmZvU3RhdHVzW1wiRW5hYmxlZFwiXSA9ICdFbmFibGVkJ10gPSBcIkVuYWJsZWRcIjtcbiAgICBFeHRlbnNpb25JbmZvU3RhdHVzW0V4dGVuc2lvbkluZm9TdGF0dXNbXCJEaXNhYmxlZFwiXSA9ICdEaXNhYmxlZCddID0gXCJEaXNhYmxlZFwiO1xuICAgIEV4dGVuc2lvbkluZm9TdGF0dXNbRXh0ZW5zaW9uSW5mb1N0YXR1c1tcIk5vdEFjdGl2YXRlZFwiXSA9ICdOb3RBY3RpdmF0ZWQnXSA9IFwiTm90QWN0aXZhdGVkXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1N0YXR1c1tFeHRlbnNpb25JbmZvU3RhdHVzW1wiVW5hc3NpZ25lZFwiXSA9ICdVbmFzc2lnbmVkJ10gPSBcIlVuYXNzaWduZWRcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uSW5mb1N0YXR1cyB8fCAoZXhwb3J0cy5FeHRlbnNpb25JbmZvU3RhdHVzID0ge30pKTtcbnZhciBFeHRlbnNpb25JbmZvU3RhdHVzID0gZXhwb3J0cy5FeHRlbnNpb25JbmZvU3RhdHVzO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvVHlwZSkge1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiVXNlclwiXSA9ICdVc2VyJ10gPSBcIlVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkZheFVzZXJcIl0gPSAnRmF4VXNlciddID0gXCJGYXhVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJWaXJ0dWFsVXNlclwiXSA9ICdWaXJ0dWFsVXNlciddID0gXCJWaXJ0dWFsVXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiRGlnaXRhbFVzZXJcIl0gPSAnRGlnaXRhbFVzZXInXSA9IFwiRGlnaXRhbFVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkRlcGFydG1lbnRcIl0gPSAnRGVwYXJ0bWVudCddID0gXCJEZXBhcnRtZW50XCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJBbm5vdW5jZW1lbnRcIl0gPSAnQW5ub3VuY2VtZW50J10gPSBcIkFubm91bmNlbWVudFwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIlNoYXJlZExpbmVzR3JvdXBcIl0gPSAnU2hhcmVkTGluZXNHcm91cCddID0gXCJTaGFyZWRMaW5lc0dyb3VwXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJQYWdpbmdPbmx5R3JvdXBcIl0gPSAnUGFnaW5nT25seUdyb3VwJ10gPSBcIlBhZ2luZ09ubHlHcm91cFwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiSXZyTWVudVwiXSA9ICdJdnJNZW51J10gPSBcIkl2ck1lbnVcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCJdID0gJ0FwcGxpY2F0aW9uRXh0ZW5zaW9uJ10gPSBcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJQYXJrTG9jYXRpb25cIl0gPSAnUGFya0xvY2F0aW9uJ10gPSBcIlBhcmtMb2NhdGlvblwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25JbmZvVHlwZSB8fCAoZXhwb3J0cy5FeHRlbnNpb25JbmZvVHlwZSA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uSW5mb1R5cGUgPSBleHBvcnRzLkV4dGVuc2lvbkluZm9UeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNvbnRhY3RhZGRyZXNzaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgQ29udGFjdEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250YWN0SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250YWN0SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbnRhY3RJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZpcnN0TmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFzdE5hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbXBhbnknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VtYWlsJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdidXNpbmVzc1Bob25lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdidXNpbmVzc0FkZHJlc3MnLCBDbGFzczogY29udGFjdGFkZHJlc3NpbmZvLkNvbnRhY3RBZGRyZXNzSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENvbnRhY3RJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ29udGFjdEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRhY3RJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Db250YWN0SW5mbyA9IENvbnRhY3RJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIENvbnRhY3RBZGRyZXNzSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnRhY3RBZGRyZXNzSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250YWN0QWRkcmVzc0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb250YWN0QWRkcmVzc0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY291bnRyeScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NpdHknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0cmVldCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnemlwJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ29udGFjdEFkZHJlc3NJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ29udGFjdEFkZHJlc3NJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBDb250YWN0QWRkcmVzc0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNvbnRhY3RBZGRyZXNzSW5mbyA9IENvbnRhY3RBZGRyZXNzSW5mbztcblxuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBEZXBhcnRtZW50SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlcGFydG1lbnRJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlcGFydG1lbnRJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGVwYXJ0bWVudEluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGVwYXJ0bWVudEluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEZXBhcnRtZW50SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGVwYXJ0bWVudEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRlcGFydG1lbnRJbmZvID0gRGVwYXJ0bWVudEluZm87XG5cblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHBlcm1pc3Npb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgRXh0ZW5zaW9uUGVybWlzc2lvbnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25QZXJtaXNzaW9ucywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25QZXJtaXNzaW9ucygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvblBlcm1pc3Npb25zLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FkbWluJywgQ2xhc3M6IHBlcm1pc3Npb25pbmZvLlBlcm1pc3Npb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpbnRlcm5hdGlvbmFsQ2FsbGluZycsIENsYXNzOiBwZXJtaXNzaW9uaW5mby5QZXJtaXNzaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvblBlcm1pc3Npb25zLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uUGVybWlzc2lvbnMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvblBlcm1pc3Npb25zO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25QZXJtaXNzaW9ucyA9IEV4dGVuc2lvblBlcm1pc3Npb25zO1xuXG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQZXJtaXNzaW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBlcm1pc3Npb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBlcm1pc3Npb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGVybWlzc2lvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5hYmxlZCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQZXJtaXNzaW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1Blcm1pc3Npb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQZXJtaXNzaW9uSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUGVybWlzc2lvbkluZm8gPSBQZXJtaXNzaW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUHJvZmlsZUltYWdlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb2ZpbGVJbWFnZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvZmlsZUltYWdlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFByb2ZpbGVJbWFnZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V0YWcnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhc3RNb2RpZmllZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFR5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3NjYWxlcycsIENsYXNzOiBudWxsIC8qIHN0cmluZ1tdICovLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQcm9maWxlSW1hZ2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUHJvZmlsZUltYWdlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvZmlsZUltYWdlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUHJvZmlsZUltYWdlSW5mbyA9IFByb2ZpbGVJbWFnZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFJlZmVyZW5jZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZlcmVuY2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZWZlcmVuY2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlZicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBSZWZlcmVuY2VJbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFJlZmVyZW5jZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdSZWZlcmVuY2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBSZWZlcmVuY2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5SZWZlcmVuY2VJbmZvID0gUmVmZXJlbmNlSW5mbztcbihmdW5jdGlvbiAoUmVmZXJlbmNlSW5mb1R5cGUpIHtcbiAgICBSZWZlcmVuY2VJbmZvVHlwZVtSZWZlcmVuY2VJbmZvVHlwZVtcIlBhcnRuZXJJZFwiXSA9ICdQYXJ0bmVySWQnXSA9IFwiUGFydG5lcklkXCI7XG4gICAgUmVmZXJlbmNlSW5mb1R5cGVbUmVmZXJlbmNlSW5mb1R5cGVbXCJDdXN0b21lckRpcmVjdG9yeUlkXCJdID0gJ0N1c3RvbWVyRGlyZWN0b3J5SWQnXSA9IFwiQ3VzdG9tZXJEaXJlY3RvcnlJZFwiO1xufSkoZXhwb3J0cy5SZWZlcmVuY2VJbmZvVHlwZSB8fCAoZXhwb3J0cy5SZWZlcmVuY2VJbmZvVHlwZSA9IHt9KSk7XG52YXIgUmVmZXJlbmNlSW5mb1R5cGUgPSBleHBvcnRzLlJlZmVyZW5jZUluZm9UeXBlO1xuXG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjb3VudHJ5aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xudmFyIHRpbWV6b25laW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xudmFyIGxhbmd1YWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIGdyZWV0aW5nbGFuZ3VhZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG52YXIgZm9ybWF0dGluZ2xvY2FsZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBSZWdpb25hbFNldHRpbmdzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVnaW9uYWxTZXR0aW5ncywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWdpb25hbFNldHRpbmdzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmVnaW9uYWxTZXR0aW5ncy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdob21lQ291bnRyeScsIENsYXNzOiBjb3VudHJ5aW5mby5Db3VudHJ5SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndGltZXpvbmUnLCBDbGFzczogdGltZXpvbmVpbmZvLlRpbWV6b25lSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFuZ3VhZ2UnLCBDbGFzczogbGFuZ3VhZ2VpbmZvLkxhbmd1YWdlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZ3JlZXRpbmdMYW5ndWFnZScsIENsYXNzOiBncmVldGluZ2xhbmd1YWdlaW5mby5HcmVldGluZ0xhbmd1YWdlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZm9ybWF0dGluZ0xvY2FsZScsIENsYXNzOiBmb3JtYXR0aW5nbG9jYWxlaW5mby5Gb3JtYXR0aW5nTG9jYWxlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFJlZ2lvbmFsU2V0dGluZ3MucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdSZWdpb25hbFNldHRpbmdzJztcbiAgICB9O1xuICAgIHJldHVybiBSZWdpb25hbFNldHRpbmdzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5SZWdpb25hbFNldHRpbmdzID0gUmVnaW9uYWxTZXR0aW5ncztcblxuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQ291bnRyeUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb3VudHJ5SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb3VudHJ5SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDb3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NvdW50cnlJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBDb3VudHJ5SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQ291bnRyeUluZm8gPSBDb3VudHJ5SW5mbztcblxuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgVGltZXpvbmVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZXpvbmVJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWV6b25lSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRpbWV6b25lSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkZXNjcmlwdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFRpbWV6b25lSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1RpbWV6b25lSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXpvbmVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5UaW1lem9uZUluZm8gPSBUaW1lem9uZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIExhbmd1YWdlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExhbmd1YWdlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYW5ndWFnZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYW5ndWFnZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZ3JlZXRpbmcnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmb3JtYXR0aW5nTG9jYWxlJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYWxlQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndWknLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTGFuZ3VhZ2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTGFuZ3VhZ2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBMYW5ndWFnZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkxhbmd1YWdlSW5mbyA9IExhbmd1YWdlSW5mbztcblxuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgR3JlZXRpbmdMYW5ndWFnZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcmVldGluZ0xhbmd1YWdlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcmVldGluZ0xhbmd1YWdlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdyZWV0aW5nTGFuZ3VhZ2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsb2NhbGVDb2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgR3JlZXRpbmdMYW5ndWFnZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdHcmVldGluZ0xhbmd1YWdlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gR3JlZXRpbmdMYW5ndWFnZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkdyZWV0aW5nTGFuZ3VhZ2VJbmZvID0gR3JlZXRpbmdMYW5ndWFnZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEZvcm1hdHRpbmdMb2NhbGVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9ybWF0dGluZ0xvY2FsZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9ybWF0dGluZ0xvY2FsZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBGb3JtYXR0aW5nTG9jYWxlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYWxlQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEZvcm1hdHRpbmdMb2NhbGVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRm9ybWF0dGluZ0xvY2FsZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcm1hdHRpbmdMb2NhbGVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Gb3JtYXR0aW5nTG9jYWxlSW5mbyA9IEZvcm1hdHRpbmdMb2NhbGVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VuYWJsZWQnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmZWF0dXJlTmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVhc29uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbyA9IEV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbztcblxuXG4vKioqLyB9LFxuLyogMjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRXh0ZW5zaW9uU3RhdHVzSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvblN0YXR1c0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uU3RhdHVzSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvblN0YXR1c0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29tbWVudCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVhc29uJywgQ2xhc3M6IEV4dGVuc2lvblN0YXR1c0luZm9SZWFzb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25TdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uU3RhdHVzSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uU3RhdHVzSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uU3RhdHVzSW5mbyA9IEV4dGVuc2lvblN0YXR1c0luZm87XG4oZnVuY3Rpb24gKEV4dGVuc2lvblN0YXR1c0luZm9SZWFzb24pIHtcbiAgICBFeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uW0V4dGVuc2lvblN0YXR1c0luZm9SZWFzb25bXCJWb2x1bnRhcmlseVwiXSA9ICdWb2x1bnRhcmlseSddID0gXCJWb2x1bnRhcmlseVwiO1xuICAgIEV4dGVuc2lvblN0YXR1c0luZm9SZWFzb25bRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbltcIkludm9sdW50YXJpbHlcIl0gPSAnSW52b2x1bnRhcmlseSddID0gXCJJbnZvbHVudGFyaWx5XCI7XG59KShleHBvcnRzLkV4dGVuc2lvblN0YXR1c0luZm9SZWFzb24gfHwgKGV4cG9ydHMuRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbiA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbiA9IGV4cG9ydHMuRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbjtcblxuXG4vKioqLyB9LFxuLyogMjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgYmlsbGluZ3BsYW5pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG52YXIgYnJhbmRpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG52YXIgc2VydmljZXBsYW5pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG52YXIgdGFyZ2V0c2VydmljZXBsYW5pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG52YXIgU2VydmljZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXJ2aWNlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNlcnZpY2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYmlsbGluZ1BsYW4nLCBDbGFzczogYmlsbGluZ3BsYW5pbmZvLkJpbGxpbmdQbGFuSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYnJhbmQnLCBDbGFzczogYnJhbmRpbmZvLkJyYW5kSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2VydmljZVBsYW4nLCBDbGFzczogc2VydmljZXBsYW5pbmZvLlNlcnZpY2VQbGFuSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndGFyZ2V0U2VydmljZVBsYW4nLCBDbGFzczogdGFyZ2V0c2VydmljZXBsYW5pbmZvLlRhcmdldFNlcnZpY2VQbGFuSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFNlcnZpY2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU2VydmljZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZpY2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5TZXJ2aWNlSW5mbyA9IFNlcnZpY2VJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBCaWxsaW5nUGxhbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaWxsaW5nUGxhbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmlsbGluZ1BsYW5JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQmlsbGluZ1BsYW5JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvblVuaXQnLCBDbGFzczogQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0LCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBCaWxsaW5nUGxhbkluZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQmlsbGluZ1BsYW5JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQmlsbGluZ1BsYW5JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBCaWxsaW5nUGxhbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkJpbGxpbmdQbGFuSW5mbyA9IEJpbGxpbmdQbGFuSW5mbztcbihmdW5jdGlvbiAoQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0KSB7XG4gICAgQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0W0JpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdFtcIk1vbnRoXCJdID0gJ01vbnRoJ10gPSBcIk1vbnRoXCI7XG4gICAgQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0W0JpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdFtcIkRheVwiXSA9ICdEYXknXSA9IFwiRGF5XCI7XG59KShleHBvcnRzLkJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdCB8fCAoZXhwb3J0cy5CaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXQgPSB7fSkpO1xudmFyIEJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdCA9IGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0O1xuKGZ1bmN0aW9uIChCaWxsaW5nUGxhbkluZm9UeXBlKSB7XG4gICAgQmlsbGluZ1BsYW5JbmZvVHlwZVtCaWxsaW5nUGxhbkluZm9UeXBlW1wiSW5pdGlhbFwiXSA9ICdJbml0aWFsJ10gPSBcIkluaXRpYWxcIjtcbiAgICBCaWxsaW5nUGxhbkluZm9UeXBlW0JpbGxpbmdQbGFuSW5mb1R5cGVbXCJSZWd1bGFyXCJdID0gJ1JlZ3VsYXInXSA9IFwiUmVndWxhclwiO1xuICAgIEJpbGxpbmdQbGFuSW5mb1R5cGVbQmlsbGluZ1BsYW5JbmZvVHlwZVtcIlN1c3BlbmRlZFwiXSA9ICdTdXNwZW5kZWQnXSA9IFwiU3VzcGVuZGVkXCI7XG4gICAgQmlsbGluZ1BsYW5JbmZvVHlwZVtCaWxsaW5nUGxhbkluZm9UeXBlW1wiVHJpYWxcIl0gPSAnVHJpYWwnXSA9IFwiVHJpYWxcIjtcbiAgICBCaWxsaW5nUGxhbkluZm9UeXBlW0JpbGxpbmdQbGFuSW5mb1R5cGVbXCJUcmlhbE5vQ0NcIl0gPSAnVHJpYWxOb0NDJ10gPSBcIlRyaWFsTm9DQ1wiO1xuICAgIEJpbGxpbmdQbGFuSW5mb1R5cGVbQmlsbGluZ1BsYW5JbmZvVHlwZVtcIkZyZWVcIl0gPSAnRnJlZSddID0gXCJGcmVlXCI7XG59KShleHBvcnRzLkJpbGxpbmdQbGFuSW5mb1R5cGUgfHwgKGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvVHlwZSA9IHt9KSk7XG52YXIgQmlsbGluZ1BsYW5JbmZvVHlwZSA9IGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogMjQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbnZhciBCcmFuZEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCcmFuZEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnJhbmRJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQnJhbmRJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdob21lQ291bnRyeScsIENsYXNzOiBjb3VudHJ5aW5mby5Db3VudHJ5SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJyYW5kSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0JyYW5kSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQnJhbmRJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5CcmFuZEluZm8gPSBCcmFuZEluZm87XG5cblxuLyoqKi8gfSxcbi8qIDI1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFNlcnZpY2VQbGFuSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcnZpY2VQbGFuSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlUGxhbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZXJ2aWNlUGxhbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VkaXRpb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBTZXJ2aWNlUGxhbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTZXJ2aWNlUGxhbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZpY2VQbGFuSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuU2VydmljZVBsYW5JbmZvID0gU2VydmljZVBsYW5JbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBUYXJnZXRTZXJ2aWNlUGxhbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYXJnZXRTZXJ2aWNlUGxhbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFyZ2V0U2VydmljZVBsYW5JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGFyZ2V0U2VydmljZVBsYW5JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgVGFyZ2V0U2VydmljZVBsYW5JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnVGFyZ2V0U2VydmljZVBsYW5JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBUYXJnZXRTZXJ2aWNlUGxhbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlRhcmdldFNlcnZpY2VQbGFuSW5mbyA9IFRhcmdldFNlcnZpY2VQbGFuSW5mbztcblxuXG4vKioqLyB9LFxuLyogMjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQWNjb3VudFN0YXR1c0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50U3RhdHVzSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50U3RhdHVzSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRTdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbW1lbnQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlYXNvbicsIENsYXNzOiBBY2NvdW50U3RhdHVzSW5mb1JlYXNvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRTdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudFN0YXR1c0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRTdGF0dXNJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50U3RhdHVzSW5mbyA9IEFjY291bnRTdGF0dXNJbmZvO1xuKGZ1bmN0aW9uIChBY2NvdW50U3RhdHVzSW5mb1JlYXNvbikge1xuICAgIEFjY291bnRTdGF0dXNJbmZvUmVhc29uW0FjY291bnRTdGF0dXNJbmZvUmVhc29uW1wiVm9sdW50YXJpbHlcIl0gPSAnVm9sdW50YXJpbHknXSA9IFwiVm9sdW50YXJpbHlcIjtcbiAgICBBY2NvdW50U3RhdHVzSW5mb1JlYXNvbltBY2NvdW50U3RhdHVzSW5mb1JlYXNvbltcIkludm9sdW50YXJpbHlcIl0gPSAnSW52b2x1bnRhcmlseSddID0gXCJJbnZvbHVudGFyaWx5XCI7XG59KShleHBvcnRzLkFjY291bnRTdGF0dXNJbmZvUmVhc29uIHx8IChleHBvcnRzLkFjY291bnRTdGF0dXNJbmZvUmVhc29uID0ge30pKTtcbnZhciBBY2NvdW50U3RhdHVzSW5mb1JlYXNvbiA9IGV4cG9ydHMuQWNjb3VudFN0YXR1c0luZm9SZWFzb247XG5cblxuLyoqKi8gfSxcbi8qIDI4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGJ1c2luZXNzYWRkcmVzc2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcbnZhciBBY2NvdW50QnVzaW5lc3NBZGRyZXNzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudEJ1c2luZXNzQWRkcmVzcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50QnVzaW5lc3NBZGRyZXNzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudEJ1c2luZXNzQWRkcmVzcy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbXBhbnknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VtYWlsJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdidXNpbmVzc0FkZHJlc3MnLCBDbGFzczogYnVzaW5lc3NhZGRyZXNzaW5mby5CdXNpbmVzc0FkZHJlc3NJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50QnVzaW5lc3NBZGRyZXNzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudEJ1c2luZXNzQWRkcmVzcyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudEJ1c2luZXNzQWRkcmVzcztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudEJ1c2luZXNzQWRkcmVzcyA9IEFjY291bnRCdXNpbmVzc0FkZHJlc3M7XG5cblxuLyoqKi8gfSxcbi8qIDI5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEJ1c2luZXNzQWRkcmVzc0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXNpbmVzc0FkZHJlc3NJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1c2luZXNzQWRkcmVzc0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCdXNpbmVzc0FkZHJlc3NJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvdW50cnknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXRlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjaXR5JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdHJlZXQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ppcCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJ1c2luZXNzQWRkcmVzc0luZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdCdXNpbmVzc0FkZHJlc3NJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBCdXNpbmVzc0FkZHJlc3NJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5CdXNpbmVzc0FkZHJlc3NJbmZvID0gQnVzaW5lc3NBZGRyZXNzSW5mbztcblxuXG4vKioqLyB9LFxuLyogMzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGlhbGluZ3BsYW5jb3VudHJ5aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIERpYWxpbmdQbGFuSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpYWxpbmdQbGFuSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWFsaW5nUGxhbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWFsaW5nUGxhbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBkaWFsaW5ncGxhbmNvdW50cnlpbmZvLkRpYWxpbmdQbGFuQ291bnRyeUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpYWxpbmdQbGFuSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpYWxpbmdQbGFuSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGlhbGluZ1BsYW5JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWFsaW5nUGxhbkluZm8gPSBEaWFsaW5nUGxhbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDMxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIERpYWxpbmdQbGFuQ291bnRyeUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWFsaW5nUGxhbkNvdW50cnlJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpYWxpbmdQbGFuQ291bnRyeUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWFsaW5nUGxhbkNvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NhbGxpbmdDb2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpc29Db2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGlhbGluZ1BsYW5Db3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpYWxpbmdQbGFuQ291bnRyeUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIERpYWxpbmdQbGFuQ291bnRyeUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpYWxpbmdQbGFuQ291bnRyeUluZm8gPSBEaWFsaW5nUGxhbkNvdW50cnlJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAzMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQYWdpbmdJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFnaW5nSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYWdpbmdJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGFnaW5nSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdlJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwZXJQYWdlJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdlU3RhcnQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2VFbmQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvdGFsUGFnZXMnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvdGFsRWxlbWVudHMnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQYWdpbmdJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUGFnaW5nSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUGFnaW5nSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUGFnaW5nSW5mbyA9IFBhZ2luZ0luZm87XG5cblxuLyoqKi8gfSxcbi8qIDMzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE5hdmlnYXRpb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmF2aWdhdGlvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBOYXZpZ2F0aW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmaXJzdFBhZ2UnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25leHRQYWdlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwcmV2aW91c1BhZ2UnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhc3RQYWdlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTmF2aWdhdGlvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdOYXZpZ2F0aW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTmF2aWdhdGlvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk5hdmlnYXRpb25JbmZvID0gTmF2aWdhdGlvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDM0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNvdW50cnlpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG52YXIgcGhvbmVudW1iZXJzZXh0ZW5zaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xudmFyIFBob25lTnVtYmVySW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBob25lTnVtYmVySW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQaG9uZU51bWJlckluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQaG9uZU51bWJlckluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvdW50cnknLCBDbGFzczogY291bnRyeWluZm8uQ291bnRyeUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbicsIENsYXNzOiBwaG9uZW51bWJlcnNleHRlbnNpb25pbmZvLlBob25lTnVtYmVyc0V4dGVuc2lvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZlYXR1cmVzJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nW10gKi8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYXRpb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BheW1lbnRUeXBlJywgQ2xhc3M6IFBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaG9uZU51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdHVzJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IFBob25lTnVtYmVySW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VzYWdlVHlwZScsIENsYXNzOiBQaG9uZU51bWJlckluZm9Vc2FnZVR5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQaG9uZU51bWJlckluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdQaG9uZU51bWJlckluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFBob25lTnVtYmVySW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvID0gUGhvbmVOdW1iZXJJbmZvO1xuKGZ1bmN0aW9uIChQaG9uZU51bWJlckluZm9QYXltZW50VHlwZSkge1xuICAgIFBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlW1Bob25lTnVtYmVySW5mb1BheW1lbnRUeXBlW1wiRXh0ZXJuYWxcIl0gPSAnRXh0ZXJuYWwnXSA9IFwiRXh0ZXJuYWxcIjtcbiAgICBQaG9uZU51bWJlckluZm9QYXltZW50VHlwZVtQaG9uZU51bWJlckluZm9QYXltZW50VHlwZVtcIlRvbGxGcmVlXCJdID0gJ1RvbGxGcmVlJ10gPSBcIlRvbGxGcmVlXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGVbUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGVbXCJMb2NhbFwiXSA9ICdMb2NhbCddID0gXCJMb2NhbFwiO1xufSkoZXhwb3J0cy5QaG9uZU51bWJlckluZm9QYXltZW50VHlwZSB8fCAoZXhwb3J0cy5QaG9uZU51bWJlckluZm9QYXltZW50VHlwZSA9IHt9KSk7XG52YXIgUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGUgPSBleHBvcnRzLlBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlO1xuKGZ1bmN0aW9uIChQaG9uZU51bWJlckluZm9UeXBlKSB7XG4gICAgUGhvbmVOdW1iZXJJbmZvVHlwZVtQaG9uZU51bWJlckluZm9UeXBlW1wiVm9pY2VGYXhcIl0gPSAnVm9pY2VGYXgnXSA9IFwiVm9pY2VGYXhcIjtcbiAgICBQaG9uZU51bWJlckluZm9UeXBlW1Bob25lTnVtYmVySW5mb1R5cGVbXCJGYXhPbmx5XCJdID0gJ0ZheE9ubHknXSA9IFwiRmF4T25seVwiO1xuICAgIFBob25lTnVtYmVySW5mb1R5cGVbUGhvbmVOdW1iZXJJbmZvVHlwZVtcIlZvaWNlT25seVwiXSA9ICdWb2ljZU9ubHknXSA9IFwiVm9pY2VPbmx5XCI7XG59KShleHBvcnRzLlBob25lTnVtYmVySW5mb1R5cGUgfHwgKGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVHlwZSA9IHt9KSk7XG52YXIgUGhvbmVOdW1iZXJJbmZvVHlwZSA9IGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVHlwZTtcbihmdW5jdGlvbiAoUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlKSB7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIk1haW5Db21wYW55TnVtYmVyXCJdID0gJ01haW5Db21wYW55TnVtYmVyJ10gPSBcIk1haW5Db21wYW55TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCJdID0gJ0FkZGl0aW9uYWxDb21wYW55TnVtYmVyJ10gPSBcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkNvbXBhbnlOdW1iZXJcIl0gPSAnQ29tcGFueU51bWJlciddID0gXCJDb21wYW55TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkRpcmVjdE51bWJlclwiXSA9ICdEaXJlY3ROdW1iZXInXSA9IFwiRGlyZWN0TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkNvbXBhbnlGYXhOdW1iZXJcIl0gPSAnQ29tcGFueUZheE51bWJlciddID0gXCJDb21wYW55RmF4TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkZvcndhcmRlZE51bWJlclwiXSA9ICdGb3J3YXJkZWROdW1iZXInXSA9IFwiRm9yd2FyZGVkTnVtYmVyXCI7XG59KShleHBvcnRzLlBob25lTnVtYmVySW5mb1VzYWdlVHlwZSB8fCAoZXhwb3J0cy5QaG9uZU51bWJlckluZm9Vc2FnZVR5cGUgPSB7fSkpO1xudmFyIFBob25lTnVtYmVySW5mb1VzYWdlVHlwZSA9IGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiAzNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhcnRuZXJJZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFBob25lTnVtYmVyc0V4dGVuc2lvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5QaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvID0gUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogMzYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgcGhvbmVudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgQWNjb3VudFBob25lTnVtYmVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRQaG9uZU51bWJlcnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudFBob25lTnVtYmVycygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRQaG9uZU51bWJlcnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBwaG9uZW51bWJlcmluZm8uUGhvbmVOdW1iZXJJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50UGhvbmVOdW1iZXJzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudFBob25lTnVtYmVycyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudFBob25lTnVtYmVycztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudFBob25lTnVtYmVycyA9IEFjY291bnRQaG9uZU51bWJlcnM7XG5cblxuLyoqKi8gfSxcbi8qIDM3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHNlcnZpY2VmZWF0dXJlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xudmFyIGFjY291bnRsaW1pdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcbnZhciBBY2NvdW50U2VydmljZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50U2VydmljZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudFNlcnZpY2VJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudFNlcnZpY2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2VydmljZVBsYW5OYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXJ2aWNlRmVhdHVyZXMnLCBDbGFzczogc2VydmljZWZlYXR1cmVpbmZvLlNlcnZpY2VGZWF0dXJlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsaW1pdHMnLCBDbGFzczogYWNjb3VudGxpbWl0cy5BY2NvdW50TGltaXRzLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50U2VydmljZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50U2VydmljZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRTZXJ2aWNlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudFNlcnZpY2VJbmZvID0gQWNjb3VudFNlcnZpY2VJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAzOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTZXJ2aWNlRmVhdHVyZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXJ2aWNlRmVhdHVyZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VydmljZUZlYXR1cmVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VydmljZUZlYXR1cmVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZlYXR1cmVOYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlbmFibGVkJywgQ2xhc3M6IFNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBTZXJ2aWNlRmVhdHVyZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTZXJ2aWNlRmVhdHVyZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZpY2VGZWF0dXJlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuU2VydmljZUZlYXR1cmVJbmZvID0gU2VydmljZUZlYXR1cmVJbmZvO1xuKGZ1bmN0aW9uIChTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkKSB7XG4gICAgU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZFtTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkW1wiVHJ1ZVwiXSA9ICdUcnVlJ10gPSBcIlRydWVcIjtcbiAgICBTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkW1NlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWRbXCJGYWxzZVwiXSA9ICdGYWxzZSddID0gXCJGYWxzZVwiO1xufSkoZXhwb3J0cy5TZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkIHx8IChleHBvcnRzLlNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQgPSB7fSkpO1xudmFyIFNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQgPSBleHBvcnRzLlNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQ7XG5cblxuLyoqKi8gfSxcbi8qIDM5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEFjY291bnRMaW1pdHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50TGltaXRzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRMaW1pdHMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50TGltaXRzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZyZWVTb2Z0UGhvbmVMaW5lc1BlckV4dGVuc2lvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbWVldGluZ1NpemUnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21heE1vbml0b3JlZEV4dGVuc2lvbnNQZXJVc2VyJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudExpbWl0cy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRMaW1pdHMnO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRMaW1pdHM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRMaW1pdHMgPSBBY2NvdW50TGltaXRzO1xuXG5cbi8qKiovIH0sXG4vKiA0MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgYWNjb3VudGFjdGl2ZWNhbGxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG52YXIgYWNjb3VudGNhbGxsb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcbnZhciBhY2NvdW50Y2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xudmFyIGV4dGVuc2lvbmFjdGl2ZWNhbGxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgZXh0ZW5zaW9uY2FsbGxvZyA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xudmFyIGV4dGVuc2lvbmNhbGxsb2dyZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbnZhciBjYWxsbG9nc3luYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xudmFyIGNhbGxyZWNvcmRpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcbnZhciBDYWxsTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsbExvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsTG9nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgQWN0aXZlIENhbGxzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTMgKFJlbGVhc2UgNi41KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHJlY29yZHMgb2YgYWxsIGNhbGxzIHRoYXQgYXJlIGluIHByb2dyZXNzLCBvcmRlcmVkIGJ5IHN0YXJ0IHRpbWUgaW4gZGVzY2VuZGluZyBvcmRlci48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubGlzdEFjY291bnRBY3RpdmVDYWxscyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vYWN0aXZlLWNhbGxzJywgb3B0aW9ucywgZXhwb3J0cy5saXN0QWNjb3VudEFjdGl2ZUNhbGxzT3B0aW9ucyksIGFjY291bnRhY3RpdmVjYWxscy5BY2NvdW50QWN0aXZlQ2FsbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgTG9nIFJlY29yZHMgYnkgRmlsdGVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMyAoUmVsZWFzZSA1LjExKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGNhbGwgbG9nIHJlY29yZHMgZmlsdGVyZWQgYnkgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkQWNjb3VudENhbGxMb2cgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2NhbGwtbG9nJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQWNjb3VudENhbGxMb2dPcHRpb25zKSwgYWNjb3VudGNhbGxsb2cuQWNjb3VudENhbGxMb2cpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIENhbGwgTG9nIFJlY29yZHMgYnkgRmlsdGVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0Q2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmRlbGV0ZUFjY291bnRDYWxsTG9nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9jYWxsLWxvZycsIG9wdGlvbnMsIGV4cG9ydHMuZGVsZXRlQWNjb3VudENhbGxMb2dPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWNjb3VudCBDYWxsIExvZyBSZWNvcmQocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4zIChSZWxlYXNlIDUuMTEpPC9wPlxuICAgICAqIDxwPlJldHVybnMgaW5kaXZpZHVhbCBjYWxsIGxvZyByZWNvcmQocykgYnkgSUQocykuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLCBzZWUgQmF0Y2ggUmVxdWVzdHMgZm9yIGRldGFpbHMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxvYWRBY2NvdW50Q2FsbExvZ1JlY29yZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vY2FsbC1sb2cve2NhbGxSZWNvcmRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRBY2NvdW50Q2FsbExvZ1JlY29yZE9wdGlvbnMpLCBhY2NvdW50Y2FsbGxvZ3JlY29yZC5BY2NvdW50Q2FsbExvZ1JlY29yZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWN0aXZlIENhbGxzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTMgKFJlbGVhc2UgNi41KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHJlY29yZHMgb2YgYWxsIGV4dGVuc2lvbiBjYWxscyB0aGF0IGFyZSBpbiBwcm9ncmVzcywgb3JkZXJlZCBieSBzdGFydCB0aW1lIGluIGRlc2NlbmRpbmcgb3JkZXIuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxpc3RFeHRlbnNpb25BY3RpdmVDYWxscyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vYWN0aXZlLWNhbGxzJywgb3B0aW9ucywgZXhwb3J0cy5saXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNPcHRpb25zKSwgZXh0ZW5zaW9uYWN0aXZlY2FsbHMuRXh0ZW5zaW9uQWN0aXZlQ2FsbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgTG9nIFJlY29yZHMgYnkgRmlsdGVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMyAoUmVsZWFzZSA1LjExKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGNhbGwgbG9nIHJlY29yZHMgZmlsdGVyZWQgYnkgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkRXh0ZW5zaW9uQ2FsbExvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vY2FsbC1sb2cnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyksIGV4dGVuc2lvbmNhbGxsb2cuRXh0ZW5zaW9uQ2FsbExvZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgQ2FsbCBMb2cgUmVjb3JkcyBieSBGaWx0ZXJcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUuZGVsZXRlRXh0ZW5zaW9uQ2FsbExvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0RFTEVURScsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vY2FsbC1sb2cnLCBvcHRpb25zLCBleHBvcnRzLmRlbGV0ZUV4dGVuc2lvbkNhbGxMb2dPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIENhbGwgTG9nIFJlY29yZChzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjMgKFJlbGVhc2UgNS4xMSk8L3A+XG4gICAgICogPHA+UmV0dXJucyBjYWxsIGxvZyByZWNvcmQocykgYnkgdGhlaXIgSUQocykuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLCBzZWUgQmF0Y2ggUmVxdWVzdHMgZm9yIGRldGFpbHMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxvYWRFeHRlbnNpb25DYWxsTG9nUmVjb3JkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9jYWxsLWxvZy97Y2FsbFJlY29yZElkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRPcHRpb25zKSwgZXh0ZW5zaW9uY2FsbGxvZ3JlY29yZC5FeHRlbnNpb25DYWxsTG9nUmVjb3JkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGwgTG9nIFN5bmNocm9uaXphdGlvblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5zeW5jRXh0ZW5zaW9uQ2FsbExvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vY2FsbC1sb2ctc3luYycsIG9wdGlvbnMsIGV4cG9ydHMuc3luY0V4dGVuc2lvbkNhbGxMb2dPcHRpb25zKSwgY2FsbGxvZ3N5bmMuQ2FsbExvZ1N5bmMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgUmVjb3JkaW5nXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTg8L3A+XG4gICAgICogPHA+UmV0dXJucyBjYWxsIHJlY29yZGluZyBtZXRhZGF0YS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsUmVjb3JkaW5nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+RG93bmxvYWRpbmcgY2FsbCByZWNvcmRpbmcgY29udGVudDwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkQ2FsbFJlY29yZGluZ01ldGFkYXRhID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9yZWNvcmRpbmcve3JlY29yZGluZ0lkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZENhbGxSZWNvcmRpbmdNZXRhZGF0YU9wdGlvbnMpLCBjYWxscmVjb3JkaW5nLkNhbGxSZWNvcmRpbmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgUmVjb3JkaW5nIERhdGFcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsUmVjb3JkaW5nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+RG93bmxvYWRpbmcgY2FsbCByZWNvcmRpbmcgY29udGVudDwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubG9hZENhbGxSZWNvcmRpbmdDb250ZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9yZWNvcmRpbmcve3JlY29yZGluZ0lkfS9jb250ZW50Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQ2FsbFJlY29yZGluZ0NvbnRlbnRPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbExvZztcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5DYWxsTG9nID0gQ2FsbExvZztcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0QWNjb3VudEFjdGl2ZUNhbGxzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RBY2NvdW50QWN0aXZlQ2FsbHNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJWb2ljZVwiLFxuICAgICAgICAgICAgXCJGYXhcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEFjY291bnRDYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRBY2NvdW50Q2FsbExvZ09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbk51bWJlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGhvbmVOdW1iZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiSW5ib3VuZFwiLFxuICAgICAgICAgICAgXCJPdXRib3VuZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJWb2ljZVwiLFxuICAgICAgICAgICAgXCJGYXhcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ2aWV3XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMb2FkQWNjb3VudENhbGxMb2dWaWV3XCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiU2ltcGxlXCIsXG4gICAgICAgICAgICBcIkRldGFpbGVkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwid2l0aFJlY29yZGluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVGcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlVG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBkZWxldGVBY2NvdW50Q2FsbExvZyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5kZWxldGVBY2NvdW50Q2FsbExvZ09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRBY2NvdW50Q2FsbExvZ1JlY29yZCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQWNjb3VudENhbGxMb2dSZWNvcmRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjYWxsUmVjb3JkSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvblwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkluYm91bmRcIixcbiAgICAgICAgICAgIFwiT3V0Ym91bmRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiVm9pY2VcIixcbiAgICAgICAgICAgIFwiRmF4XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRFeHRlbnNpb25DYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbk51bWJlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGhvbmVOdW1iZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiVm9pY2VcIixcbiAgICAgICAgICAgIFwiRmF4XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidmlld1wiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3XCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiU2ltcGxlXCIsXG4gICAgICAgICAgICBcIkRldGFpbGVkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwid2l0aFJlY29yZGluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZUZyb21cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBkZWxldGVFeHRlbnNpb25DYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmRlbGV0ZUV4dGVuc2lvbkNhbGxMb2dPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZVRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY2FsbFJlY29yZElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHN5bmNFeHRlbnNpb25DYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnN5bmNFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN5bmNUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiRlN5bmNcIixcbiAgICAgICAgICAgIFwiSVN5bmNcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzeW5jVG9rZW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVGcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyZWNvcmRDb3VudFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3RhdHVzR3JvdXBcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXBcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJNaXNzZWRcIixcbiAgICAgICAgICAgIFwiQWxsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRDYWxsUmVjb3JkaW5nTWV0YWRhdGEgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZENhbGxSZWNvcmRpbmdNZXRhZGF0YU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInJlY29yZGluZ0lkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRDYWxsUmVjb3JkaW5nQ29udGVudCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQ2FsbFJlY29yZGluZ0NvbnRlbnRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyZWNvcmRpbmdJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbihmdW5jdGlvbiAoSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb24pIHtcbiAgICBJTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbltJTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb25bSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb24gPSBleHBvcnRzLklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGUpIHtcbiAgICBJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGVbSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGVbSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlIHx8IChleHBvcnRzLklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlID0gZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGU7XG4oZnVuY3Rpb24gKElMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb24pIHtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uW0lMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIElMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb25bSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb24gfHwgKGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbiA9IGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGUpIHtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nVHlwZVtJTG9hZEFjY291bnRDYWxsTG9nVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGVbSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nVHlwZSB8fCAoZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nVHlwZSA9IHt9KSk7XG52YXIgSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGUgPSBleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dUeXBlO1xuKGZ1bmN0aW9uIChJTG9hZEFjY291bnRDYWxsTG9nVmlldykge1xuICAgIElMb2FkQWNjb3VudENhbGxMb2dWaWV3W0lMb2FkQWNjb3VudENhbGxMb2dWaWV3W1wiU2ltcGxlXCJdID0gJ1NpbXBsZSddID0gXCJTaW1wbGVcIjtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nVmlld1tJTG9hZEFjY291bnRDYWxsTG9nVmlld1tcIkRldGFpbGVkXCJdID0gJ0RldGFpbGVkJ10gPSBcIkRldGFpbGVkXCI7XG59KShleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dWaWV3IHx8IChleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dWaWV3ID0ge30pKTtcbnZhciBJTG9hZEFjY291bnRDYWxsTG9nVmlldyA9IGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXc7XG4oZnVuY3Rpb24gKElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb24pIHtcbiAgICBJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uW0lMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb25bSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb24gfHwgKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbiA9IGV4cG9ydHMuSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGUpIHtcbiAgICBJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZVtJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGVbSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZSB8fCAoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGUgPSBleHBvcnRzLklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlO1xuKGZ1bmN0aW9uIChJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb24pIHtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb25bSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb25bSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uIHx8IChleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uID0gZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb247XG4oZnVuY3Rpb24gKElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGUpIHtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlW0lMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGVbSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGUgfHwgKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZSA9IHt9KSk7XG52YXIgSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZSA9IGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZTtcbihmdW5jdGlvbiAoSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlldykge1xuICAgIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXdbSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlld1tcIlNpbXBsZVwiXSA9ICdTaW1wbGUnXSA9IFwiU2ltcGxlXCI7XG4gICAgSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlld1tJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3W1wiRGV0YWlsZWRcIl0gPSAnRGV0YWlsZWQnXSA9IFwiRGV0YWlsZWRcIjtcbn0pKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlldyB8fCAoZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3ID0ge30pKTtcbnZhciBJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3ID0gZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3O1xuKGZ1bmN0aW9uIChJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZSkge1xuICAgIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlW0lTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlW1wiRlN5bmNcIl0gPSAnRlN5bmMnXSA9IFwiRlN5bmNcIjtcbiAgICBJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZVtJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZVtcIklTeW5jXCJdID0gJ0lTeW5jJ10gPSBcIklTeW5jXCI7XG59KShleHBvcnRzLklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlIHx8IChleHBvcnRzLklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlID0ge30pKTtcbnZhciBJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZSA9IGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGU7XG4oZnVuY3Rpb24gKElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwKSB7XG4gICAgSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXBbSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXBbXCJNaXNzZWRcIl0gPSAnTWlzc2VkJ10gPSBcIk1pc3NlZFwiO1xuICAgIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwW0lTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwW1wiQWxsXCJdID0gJ0FsbCddID0gXCJBbGxcIjtcbn0pKGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXAgfHwgKGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXAgPSB7fSkpO1xudmFyIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwID0gZXhwb3J0cy5JU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cDtcblxuXG4vKioqLyB9LFxuLyogNDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEFjY291bnRBY3RpdmVDYWxscyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRBY3RpdmVDYWxscywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50QWN0aXZlQ2FsbHMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50QWN0aXZlQ2FsbHMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBjYWxsbG9ncmVjb3JkLkNhbGxMb2dSZWNvcmQsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRBY3RpdmVDYWxscy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRBY3RpdmVDYWxscyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudEFjdGl2ZUNhbGxzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50QWN0aXZlQ2FsbHMgPSBBY2NvdW50QWN0aXZlQ2FsbHM7XG5cblxuLyoqKi8gfSxcbi8qIDQyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2djYWxsZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG52YXIgcmVjb3JkaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xudmFyIGNhbGxsb2dyZWNvcmRsZWdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG52YXIgQ2FsbExvZ1JlY29yZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGxMb2dSZWNvcmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsbExvZ1JlY29yZCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2Vzc2lvbklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmcm9tJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0bycsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBDYWxsTG9nUmVjb3JkVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGlyZWN0aW9uJywgQ2xhc3M6IENhbGxMb2dSZWNvcmREaXJlY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FjdGlvbicsIENsYXNzOiBDYWxsTG9nUmVjb3JkQWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZXN1bHQnLCBDbGFzczogQ2FsbExvZ1JlY29yZFJlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhcnRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFzdE1vZGlmaWVkVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHJhbnNwb3J0JywgQ2xhc3M6IENhbGxMb2dSZWNvcmRUcmFuc3BvcnQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xlZ3MnLCBDbGFzczogY2FsbGxvZ3JlY29yZGxlZ2luZm8uQ2FsbExvZ1JlY29yZExlZ0luZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2FsbExvZ1JlY29yZC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NhbGxMb2dSZWNvcmQnO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxMb2dSZWNvcmQ7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNhbGxMb2dSZWNvcmQgPSBDYWxsTG9nUmVjb3JkO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkVHlwZSkge1xuICAgIENhbGxMb2dSZWNvcmRUeXBlW0NhbGxMb2dSZWNvcmRUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBDYWxsTG9nUmVjb3JkVHlwZVtDYWxsTG9nUmVjb3JkVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRUeXBlIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRUeXBlID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkVHlwZSA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZFR5cGU7XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmREaXJlY3Rpb24pIHtcbiAgICBDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0NhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIENhbGxMb2dSZWNvcmREaXJlY3Rpb25bQ2FsbExvZ1JlY29yZERpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmREaXJlY3Rpb24gfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZERpcmVjdGlvbiA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZERpcmVjdGlvbiA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZERpcmVjdGlvbjtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZEFjdGlvbikge1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUGhvbmVDYWxsXCJdID0gJ1Bob25lIENhbGwnXSA9IFwiUGhvbmVDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUGhvbmVMb2dpblwiXSA9ICdQaG9uZSBMb2dpbiddID0gXCJQaG9uZUxvZ2luXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiSW5jb21pbmdGYXhcIl0gPSAnSW5jb21pbmcgRmF4J10gPSBcIkluY29taW5nRmF4XCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiQWNjZXB0Q2FsbFwiXSA9ICdBY2NlcHQgQ2FsbCddID0gXCJBY2NlcHRDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiRmluZE1lXCJdID0gJ0ZpbmRNZSddID0gXCJGaW5kTWVcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJGb2xsb3dNZVwiXSA9ICdGb2xsb3dNZSddID0gXCJGb2xsb3dNZVwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIk91dGdvaW5nRmF4XCJdID0gJ091dGdvaW5nIEZheCddID0gXCJPdXRnb2luZ0ZheFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxSZXR1cm5cIl0gPSAnQ2FsbCBSZXR1cm4nXSA9IFwiQ2FsbFJldHVyblwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxpbmdDYXJkXCJdID0gJ0NhbGxpbmcgQ2FyZCddID0gXCJDYWxsaW5nQ2FyZFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdEaXJlY3RseVwiXSA9ICdSaW5nIERpcmVjdGx5J10gPSBcIlJpbmdEaXJlY3RseVwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRXZWJcIl0gPSAnUmluZ091dCBXZWInXSA9IFwiUmluZ091dFdlYlwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlZvSVBDYWxsXCJdID0gJ1ZvSVAgQ2FsbCddID0gXCJWb0lQQ2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRQQ1wiXSA9ICdSaW5nT3V0IFBDJ10gPSBcIlJpbmdPdXRQQ1wiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdNZVwiXSA9ICdSaW5nTWUnXSA9IFwiUmluZ01lXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiVHJhbnNmZXJcIl0gPSAnVHJhbnNmZXInXSA9IFwiVHJhbnNmZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bJzQxMUluZm8nXSA9ICc0MTEgSW5mbyddID0gJzQxMUluZm8nO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkVtZXJnZW5jeVwiXSA9ICdFbWVyZ2VuY3knXSA9IFwiRW1lcmdlbmN5XCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uWydFOTExVXBkYXRlJ10gPSAnRTkxMSBVcGRhdGUnXSA9ICdFOTExVXBkYXRlJztcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJTdXBwb3J0XCJdID0gJ1N1cHBvcnQnXSA9IFwiU3VwcG9ydFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRNb2JpbGVcIl0gPSAnUmluZ091dCBNb2JpbGUnXSA9IFwiUmluZ091dE1vYmlsZVwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkQWN0aW9uIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRBY3Rpb24gPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRBY3Rpb24gPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRBY3Rpb247XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRSZXN1bHQpIHtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEluUHJvZ3Jlc3NcIl0gPSAnUmVzdWx0SW5Qcm9ncmVzcyddID0gXCJSZXN1bHRJblByb2dyZXNzXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiTWlzc2VkXCJdID0gJ01pc3NlZCddID0gXCJNaXNzZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsYWNjZXB0ZWRcIl0gPSAnQ2FsbCBhY2NlcHRlZCddID0gXCJDYWxsYWNjZXB0ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJWb2ljZW1haWxcIl0gPSAnVm9pY2VtYWlsJ10gPSBcIlZvaWNlbWFpbFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVwbHlcIl0gPSAnUmVwbHknXSA9IFwiUmVwbHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWNlaXZlZFwiXSA9ICdSZWNlaXZlZCddID0gXCJSZWNlaXZlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlY2VpdmVFcnJvclwiXSA9ICdSZWNlaXZlIEVycm9yJ10gPSBcIlJlY2VpdmVFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheG9uRGVtYW5kXCJdID0gJ0ZheCBvbiBEZW1hbmQnXSA9IFwiRmF4b25EZW1hbmRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsUmVjZWl2ZVwiXSA9ICdQYXJ0aWFsIFJlY2VpdmUnXSA9IFwiUGFydGlhbFJlY2VpdmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJCbG9ja2VkXCJdID0gJ0Jsb2NrZWQnXSA9IFwiQmxvY2tlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxjb25uZWN0ZWRcIl0gPSAnQ2FsbCBjb25uZWN0ZWQnXSA9IFwiQ2FsbGNvbm5lY3RlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIk5vQW5zd2VyXCJdID0gJ05vIEFuc3dlciddID0gXCJOb0Fuc3dlclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsIERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VuZEVycm9yXCJdID0gJ1NlbmQgRXJyb3InXSA9IFwiU2VuZEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb2ZheG1hY2hpbmVcIl0gPSAnTm8gZmF4IG1hY2hpbmUnXSA9IFwiTm9mYXhtYWNoaW5lXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVzdWx0RW1wdHlcIl0gPSAnUmVzdWx0RW1wdHknXSA9IFwiUmVzdWx0RW1wdHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJBY2NvdW50XCJdID0gJ0FjY291bnQnXSA9IFwiQWNjb3VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlN1c3BlbmRlZFwiXSA9ICdTdXNwZW5kZWQnXSA9IFwiU3VzcGVuZGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWxlZFwiXSA9ICdDYWxsIEZhaWxlZCddID0gXCJDYWxsRmFpbGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWx1cmVcIl0gPSAnQ2FsbCBGYWlsdXJlJ10gPSBcIkNhbGxGYWlsdXJlXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSW50ZXJuYWxFcnJvclwiXSA9ICdJbnRlcm5hbCBFcnJvciddID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSVBQaG9uZW9mZmxpbmVcIl0gPSAnSVAgUGhvbmUgb2ZmbGluZSddID0gXCJJUFBob25lb2ZmbGluZVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3RyaWN0ZWROdW1iZXJcIl0gPSAnUmVzdHJpY3RlZCBOdW1iZXInXSA9IFwiUmVzdHJpY3RlZE51bWJlclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIldyb25nTnVtYmVyXCJdID0gJ1dyb25nIE51bWJlciddID0gXCJXcm9uZ051bWJlclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlN0b3BwZWRcIl0gPSAnU3RvcHBlZCddID0gXCJTdG9wcGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSGFuZ3VwXCJdID0gJ0hhbmcgdXAnXSA9IFwiSGFuZ3VwXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUG9vckxpbmVRdWFsaXR5XCJdID0gJ1Bvb3IgTGluZSBRdWFsaXR5J10gPSBcIlBvb3JMaW5lUXVhbGl0eVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlBhcnRpYWxseVNlbnRcIl0gPSAnUGFydGlhbGx5IFNlbnQnXSA9IFwiUGFydGlhbGx5U2VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiXSA9ICdJbnRlcm5hdGlvbmFsIFJlc3RyaWN0aW9uJ10gPSBcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkFiYW5kb25lZFwiXSA9ICdBYmFuZG9uZWQnXSA9IFwiQWJhbmRvbmVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRGVjbGluZWRcIl0gPSAnRGVjbGluZWQnXSA9IFwiRGVjbGluZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhSZWNlaXB0RXJyb3JcIl0gPSAnRmF4IFJlY2VpcHQgRXJyb3InXSA9IFwiRmF4UmVjZWlwdEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4U2VuZEVycm9yXCJdID0gJ0ZheCBTZW5kIEVycm9yJ10gPSBcIkZheFNlbmRFcnJvclwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkUmVzdWx0IHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRSZXN1bHQgPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRSZXN1bHQgPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRSZXN1bHQ7XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRUcmFuc3BvcnQpIHtcbiAgICBDYWxsTG9nUmVjb3JkVHJhbnNwb3J0W0NhbGxMb2dSZWNvcmRUcmFuc3BvcnRbXCJQU1ROXCJdID0gJ1BTVE4nXSA9IFwiUFNUTlwiO1xuICAgIENhbGxMb2dSZWNvcmRUcmFuc3BvcnRbQ2FsbExvZ1JlY29yZFRyYW5zcG9ydFtcIlZvSVBcIl0gPSAnVm9JUCddID0gXCJWb0lQXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRUcmFuc3BvcnQgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZFRyYW5zcG9ydCA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZFRyYW5zcG9ydCA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZFRyYW5zcG9ydDtcblxuXG4vKioqLyB9LFxuLyogNDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQ2FsbExvZ0NhbGxlckluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxsTG9nQ2FsbGVySW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsTG9nQ2FsbGVySW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbGxMb2dDYWxsZXJJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Bob25lTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xvY2F0aW9uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2FsbExvZ0NhbGxlckluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDYWxsTG9nQ2FsbGVySW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbExvZ0NhbGxlckluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNhbGxMb2dDYWxsZXJJbmZvID0gQ2FsbExvZ0NhbGxlckluZm87XG5cblxuLyoqKi8gfSxcbi8qIDQ0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFJlY29yZGluZ0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWNvcmRpbmdJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlY29yZGluZ0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZWNvcmRpbmdJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogUmVjb3JkaW5nSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbnRlbnRVcmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBSZWNvcmRpbmdJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUmVjb3JkaW5nSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjb3JkaW5nSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUmVjb3JkaW5nSW5mbyA9IFJlY29yZGluZ0luZm87XG4oZnVuY3Rpb24gKFJlY29yZGluZ0luZm9UeXBlKSB7XG4gICAgUmVjb3JkaW5nSW5mb1R5cGVbUmVjb3JkaW5nSW5mb1R5cGVbXCJBdXRvbWF0aWNcIl0gPSAnQXV0b21hdGljJ10gPSBcIkF1dG9tYXRpY1wiO1xuICAgIFJlY29yZGluZ0luZm9UeXBlW1JlY29yZGluZ0luZm9UeXBlW1wiT25EZW1hbmRcIl0gPSAnT25EZW1hbmQnXSA9IFwiT25EZW1hbmRcIjtcbn0pKGV4cG9ydHMuUmVjb3JkaW5nSW5mb1R5cGUgfHwgKGV4cG9ydHMuUmVjb3JkaW5nSW5mb1R5cGUgPSB7fSkpO1xudmFyIFJlY29yZGluZ0luZm9UeXBlID0gZXhwb3J0cy5SZWNvcmRpbmdJbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogNDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZXh0ZW5zaW9uaW5mb2NhbGxsb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcbnZhciBjYWxsbG9nY2FsbGVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xudmFyIHJlY29yZGluZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGxMb2dSZWNvcmRMZWdJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGxMb2dSZWNvcmRMZWdJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYWN0aW9uJywgQ2xhc3M6IENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkaXJlY3Rpb24nLCBDbGFzczogQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2R1cmF0aW9uJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb24nLCBDbGFzczogZXh0ZW5zaW9uaW5mb2NhbGxsb2cuRXh0ZW5zaW9uSW5mb0NhbGxMb2csIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xlZ1R5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXJ0VGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Jlc3VsdCcsIENsYXNzOiBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZnJvbScsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndG8nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RyYW5zcG9ydCcsIENsYXNzOiBDYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ2FsbExvZ1JlY29yZExlZ0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxMb2dSZWNvcmRMZWdJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mbyA9IENhbGxMb2dSZWNvcmRMZWdJbmZvO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbikge1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlBob25lQ2FsbFwiXSA9ICdQaG9uZSBDYWxsJ10gPSBcIlBob25lQ2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiUGhvbmVMb2dpblwiXSA9ICdQaG9uZSBMb2dpbiddID0gXCJQaG9uZUxvZ2luXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJJbmNvbWluZ0ZheFwiXSA9ICdJbmNvbWluZyBGYXgnXSA9IFwiSW5jb21pbmdGYXhcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkFjY2VwdENhbGxcIl0gPSAnQWNjZXB0IENhbGwnXSA9IFwiQWNjZXB0Q2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiRmluZE1lXCJdID0gJ0ZpbmRNZSddID0gXCJGaW5kTWVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkZvbGxvd01lXCJdID0gJ0ZvbGxvd01lJ10gPSBcIkZvbGxvd01lXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJPdXRnb2luZ0ZheFwiXSA9ICdPdXRnb2luZyBGYXgnXSA9IFwiT3V0Z29pbmdGYXhcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkNhbGxSZXR1cm5cIl0gPSAnQ2FsbCBSZXR1cm4nXSA9IFwiQ2FsbFJldHVyblwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiQ2FsbGluZ0NhcmRcIl0gPSAnQ2FsbGluZyBDYXJkJ10gPSBcIkNhbGxpbmdDYXJkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJSaW5nRGlyZWN0bHlcIl0gPSAnUmluZyBEaXJlY3RseSddID0gXCJSaW5nRGlyZWN0bHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlJpbmdPdXRXZWJcIl0gPSAnUmluZ091dCBXZWInXSA9IFwiUmluZ091dFdlYlwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiVm9JUENhbGxcIl0gPSAnVm9JUCBDYWxsJ10gPSBcIlZvSVBDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJSaW5nT3V0UENcIl0gPSAnUmluZ091dCBQQyddID0gXCJSaW5nT3V0UENcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlJpbmdNZVwiXSA9ICdSaW5nTWUnXSA9IFwiUmluZ01lXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJUcmFuc2ZlclwiXSA9ICdUcmFuc2ZlciddID0gXCJUcmFuc2ZlclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uWyc0MTFJbmZvJ10gPSAnNDExIEluZm8nXSA9ICc0MTFJbmZvJztcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkVtZXJnZW5jeVwiXSA9ICdFbWVyZ2VuY3knXSA9IFwiRW1lcmdlbmN5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bJ0U5MTFVcGRhdGUnXSA9ICdFOTExIFVwZGF0ZSddID0gJ0U5MTFVcGRhdGUnO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiU3VwcG9ydFwiXSA9ICdTdXBwb3J0J10gPSBcIlN1cHBvcnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlJpbmdPdXRNb2JpbGVcIl0gPSAnUmluZ091dCBNb2JpbGUnXSA9IFwiUmluZ091dE1vYmlsZVwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbiB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbiA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb24gPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbikge1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbiA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb247XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZSkge1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZVtDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZVtDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGUgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGUgPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZTtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHQpIHtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJSZXN1bHRJblByb2dyZXNzXCJdID0gJ1Jlc3VsdEluUHJvZ3Jlc3MnXSA9IFwiUmVzdWx0SW5Qcm9ncmVzc1wiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiTWlzc2VkXCJdID0gJ01pc3NlZCddID0gXCJNaXNzZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkNhbGxhY2NlcHRlZFwiXSA9ICdDYWxsIGFjY2VwdGVkJ10gPSBcIkNhbGxhY2NlcHRlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJSZXBseVwiXSA9ICdSZXBseSddID0gXCJSZXBseVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlY2VpdmVFcnJvclwiXSA9ICdSZWNlaXZlIEVycm9yJ10gPSBcIlJlY2VpdmVFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiRmF4b25EZW1hbmRcIl0gPSAnRmF4IG9uIERlbWFuZCddID0gXCJGYXhvbkRlbWFuZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUGFydGlhbFJlY2VpdmVcIl0gPSAnUGFydGlhbCBSZWNlaXZlJ10gPSBcIlBhcnRpYWxSZWNlaXZlXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJCbG9ja2VkXCJdID0gJ0Jsb2NrZWQnXSA9IFwiQmxvY2tlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQ2FsbGNvbm5lY3RlZFwiXSA9ICdDYWxsIGNvbm5lY3RlZCddID0gXCJDYWxsY29ubmVjdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJOb0Fuc3dlclwiXSA9ICdObyBBbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsIERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlNlbmRFcnJvclwiXSA9ICdTZW5kIEVycm9yJ10gPSBcIlNlbmRFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIk5vZmF4bWFjaGluZVwiXSA9ICdObyBmYXggbWFjaGluZSddID0gXCJOb2ZheG1hY2hpbmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlc3VsdEVtcHR5XCJdID0gJ1Jlc3VsdEVtcHR5J10gPSBcIlJlc3VsdEVtcHR5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJBY2NvdW50XCJdID0gJ0FjY291bnQnXSA9IFwiQWNjb3VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkNhbGxGYWlsZWRcIl0gPSAnQ2FsbCBGYWlsZWQnXSA9IFwiQ2FsbEZhaWxlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQ2FsbEZhaWx1cmVcIl0gPSAnQ2FsbCBGYWlsdXJlJ10gPSBcIkNhbGxGYWlsdXJlXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJJbnRlcm5hbEVycm9yXCJdID0gJ0ludGVybmFsIEVycm9yJ10gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIklQUGhvbmVvZmZsaW5lXCJdID0gJ0lQIFBob25lIG9mZmxpbmUnXSA9IFwiSVBQaG9uZW9mZmxpbmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlc3RyaWN0ZWROdW1iZXJcIl0gPSAnUmVzdHJpY3RlZCBOdW1iZXInXSA9IFwiUmVzdHJpY3RlZE51bWJlclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiV3JvbmdOdW1iZXJcIl0gPSAnV3JvbmcgTnVtYmVyJ10gPSBcIldyb25nTnVtYmVyXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJTdG9wcGVkXCJdID0gJ1N0b3BwZWQnXSA9IFwiU3RvcHBlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiSGFuZ3VwXCJdID0gJ0hhbmcgdXAnXSA9IFwiSGFuZ3VwXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJQb29yTGluZVF1YWxpdHlcIl0gPSAnUG9vciBMaW5lIFF1YWxpdHknXSA9IFwiUG9vckxpbmVRdWFsaXR5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJQYXJ0aWFsbHlTZW50XCJdID0gJ1BhcnRpYWxseSBTZW50J10gPSBcIlBhcnRpYWxseVNlbnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiXSA9ICdJbnRlcm5hdGlvbmFsIFJlc3RyaWN0aW9uJ10gPSBcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQWJhbmRvbmVkXCJdID0gJ0FiYW5kb25lZCddID0gXCJBYmFuZG9uZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkRlY2xpbmVkXCJdID0gJ0RlY2xpbmVkJ10gPSBcIkRlY2xpbmVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJGYXhSZWNlaXB0RXJyb3JcIl0gPSAnRmF4IFJlY2VpcHQgRXJyb3InXSA9IFwiRmF4UmVjZWlwdEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJGYXhTZW5kRXJyb3JcIl0gPSAnRmF4IFNlbmQgRXJyb3InXSA9IFwiRmF4U2VuZEVycm9yXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0IHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0ID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdCA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHQ7XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0KSB7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnRbQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnRbXCJQU1ROXCJdID0gJ1BTVE4nXSA9IFwiUFNUTlwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0W0NhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0W1wiVm9JUFwiXSA9ICdWb0lQJ10gPSBcIlZvSVBcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnQgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnQgPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0ID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydDtcblxuXG4vKioqLyB9LFxuLyogNDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRXh0ZW5zaW9uSW5mb0NhbGxMb2cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25JbmZvQ2FsbExvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25JbmZvQ2FsbExvZygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkluZm9DYWxsTG9nLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25JbmZvQ2FsbExvZy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkluZm9DYWxsTG9nJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25JbmZvQ2FsbExvZztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uSW5mb0NhbGxMb2cgPSBFeHRlbnNpb25JbmZvQ2FsbExvZztcblxuXG4vKioqLyB9LFxuLyogNDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEFjY291bnRDYWxsTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudENhbGxMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudENhbGxMb2coKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50Q2FsbExvZy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGNhbGxsb2dyZWNvcmQuQ2FsbExvZ1JlY29yZCwgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudENhbGxMb2cucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50Q2FsbExvZyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudENhbGxMb2c7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRDYWxsTG9nID0gQWNjb3VudENhbGxMb2c7XG5cblxuLyoqKi8gfSxcbi8qIDQ4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2djYWxsZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG52YXIgcmVjb3JkaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xudmFyIEFjY291bnRDYWxsTG9nUmVjb3JkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudENhbGxMb2dSZWNvcmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudENhbGxMb2dSZWNvcmQoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXNzaW9uSWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Zyb20nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IEFjY291bnRDYWxsTG9nUmVjb3JkVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGlyZWN0aW9uJywgQ2xhc3M6IEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhY3Rpb24nLCBDbGFzczogQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Jlc3VsdCcsIENsYXNzOiBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhcnRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudENhbGxMb2dSZWNvcmQnO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRDYWxsTG9nUmVjb3JkO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZCA9IEFjY291bnRDYWxsTG9nUmVjb3JkO1xuKGZ1bmN0aW9uIChBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGUpIHtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGVbQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGVbQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlIHx8IChleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkVHlwZSA9IHt9KSk7XG52YXIgQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlID0gZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZFR5cGU7XG4oZnVuY3Rpb24gKEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uKSB7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb24gfHwgKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSB7fSkpO1xudmFyIEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uID0gZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbjtcbihmdW5jdGlvbiAoQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24pIHtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJQaG9uZUNhbGxcIl0gPSAnUGhvbmUgQ2FsbCddID0gXCJQaG9uZUNhbGxcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lTG9naW5cIl0gPSAnUGhvbmUgTG9naW4nXSA9IFwiUGhvbmVMb2dpblwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiSW5jb21pbmdGYXhcIl0gPSAnSW5jb21pbmcgRmF4J10gPSBcIkluY29taW5nRmF4XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJBY2NlcHRDYWxsXCJdID0gJ0FjY2VwdCBDYWxsJ10gPSBcIkFjY2VwdENhbGxcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIkZpbmRNZVwiXSA9ICdGaW5kTWUnXSA9IFwiRmluZE1lXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJGb2xsb3dNZVwiXSA9ICdGb2xsb3dNZSddID0gXCJGb2xsb3dNZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiT3V0Z29pbmdGYXhcIl0gPSAnT3V0Z29pbmcgRmF4J10gPSBcIk91dGdvaW5nRmF4XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsUmV0dXJuXCJdID0gJ0NhbGwgUmV0dXJuJ10gPSBcIkNhbGxSZXR1cm5cIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxpbmdDYXJkXCJdID0gJ0NhbGxpbmcgQ2FyZCddID0gXCJDYWxsaW5nQ2FyZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ0RpcmVjdGx5XCJdID0gJ1JpbmcgRGlyZWN0bHknXSA9IFwiUmluZ0RpcmVjdGx5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0V2ViXCJdID0gJ1JpbmdPdXQgV2ViJ10gPSBcIlJpbmdPdXRXZWJcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlZvSVBDYWxsXCJdID0gJ1ZvSVAgQ2FsbCddID0gXCJWb0lQQ2FsbFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ091dFBDXCJdID0gJ1JpbmdPdXQgUEMnXSA9IFwiUmluZ091dFBDXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nTWVcIl0gPSAnUmluZ01lJ10gPSBcIlJpbmdNZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiVHJhbnNmZXJcIl0gPSAnVHJhbnNmZXInXSA9IFwiVHJhbnNmZXJcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvblsnNDExSW5mbyddID0gJzQxMSBJbmZvJ10gPSAnNDExSW5mbyc7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJFbWVyZ2VuY3lcIl0gPSAnRW1lcmdlbmN5J10gPSBcIkVtZXJnZW5jeVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uWydFOTExVXBkYXRlJ10gPSAnRTkxMSBVcGRhdGUnXSA9ICdFOTExVXBkYXRlJztcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlN1cHBvcnRcIl0gPSAnU3VwcG9ydCddID0gXCJTdXBwb3J0XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0TW9iaWxlXCJdID0gJ1JpbmdPdXQgTW9iaWxlJ10gPSBcIlJpbmdPdXRNb2JpbGVcIjtcbn0pKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24gfHwgKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24gPSB7fSkpO1xudmFyIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uID0gZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbjtcbihmdW5jdGlvbiAoQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHQpIHtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN1bHRJblByb2dyZXNzXCJdID0gJ1Jlc3VsdEluUHJvZ3Jlc3MnXSA9IFwiUmVzdWx0SW5Qcm9ncmVzc1wiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiTWlzc2VkXCJdID0gJ01pc3NlZCddID0gXCJNaXNzZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxhY2NlcHRlZFwiXSA9ICdDYWxsIGFjY2VwdGVkJ10gPSBcIkNhbGxhY2NlcHRlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXBseVwiXSA9ICdSZXBseSddID0gXCJSZXBseVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlY2VpdmVFcnJvclwiXSA9ICdSZWNlaXZlIEVycm9yJ10gPSBcIlJlY2VpdmVFcnJvclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4b25EZW1hbmRcIl0gPSAnRmF4IG9uIERlbWFuZCddID0gXCJGYXhvbkRlbWFuZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUGFydGlhbFJlY2VpdmVcIl0gPSAnUGFydGlhbCBSZWNlaXZlJ10gPSBcIlBhcnRpYWxSZWNlaXZlXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJCbG9ja2VkXCJdID0gJ0Jsb2NrZWQnXSA9IFwiQmxvY2tlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbGNvbm5lY3RlZFwiXSA9ICdDYWxsIGNvbm5lY3RlZCddID0gXCJDYWxsY29ubmVjdGVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb0Fuc3dlclwiXSA9ICdObyBBbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsIERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbmRFcnJvclwiXSA9ICdTZW5kIEVycm9yJ10gPSBcIlNlbmRFcnJvclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIk5vZmF4bWFjaGluZVwiXSA9ICdObyBmYXggbWFjaGluZSddID0gXCJOb2ZheG1hY2hpbmVcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEVtcHR5XCJdID0gJ1Jlc3VsdEVtcHR5J10gPSBcIlJlc3VsdEVtcHR5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJBY2NvdW50XCJdID0gJ0FjY291bnQnXSA9IFwiQWNjb3VudFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsZWRcIl0gPSAnQ2FsbCBGYWlsZWQnXSA9IFwiQ2FsbEZhaWxlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWx1cmVcIl0gPSAnQ2FsbCBGYWlsdXJlJ10gPSBcIkNhbGxGYWlsdXJlXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hbEVycm9yXCJdID0gJ0ludGVybmFsIEVycm9yJ10gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIklQUGhvbmVvZmZsaW5lXCJdID0gJ0lQIFBob25lIG9mZmxpbmUnXSA9IFwiSVBQaG9uZW9mZmxpbmVcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3RyaWN0ZWROdW1iZXJcIl0gPSAnUmVzdHJpY3RlZCBOdW1iZXInXSA9IFwiUmVzdHJpY3RlZE51bWJlclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiV3JvbmdOdW1iZXJcIl0gPSAnV3JvbmcgTnVtYmVyJ10gPSBcIldyb25nTnVtYmVyXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdG9wcGVkXCJdID0gJ1N0b3BwZWQnXSA9IFwiU3RvcHBlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSGFuZ3VwXCJdID0gJ0hhbmcgdXAnXSA9IFwiSGFuZ3VwXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJQb29yTGluZVF1YWxpdHlcIl0gPSAnUG9vciBMaW5lIFF1YWxpdHknXSA9IFwiUG9vckxpbmVRdWFsaXR5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsbHlTZW50XCJdID0gJ1BhcnRpYWxseSBTZW50J10gPSBcIlBhcnRpYWxseVNlbnRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiXSA9ICdJbnRlcm5hdGlvbmFsIFJlc3RyaWN0aW9uJ10gPSBcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQWJhbmRvbmVkXCJdID0gJ0FiYW5kb25lZCddID0gXCJBYmFuZG9uZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkRlY2xpbmVkXCJdID0gJ0RlY2xpbmVkJ10gPSBcIkRlY2xpbmVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhSZWNlaXB0RXJyb3JcIl0gPSAnRmF4IFJlY2VpcHQgRXJyb3InXSA9IFwiRmF4UmVjZWlwdEVycm9yXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhTZW5kRXJyb3JcIl0gPSAnRmF4IFNlbmQgRXJyb3InXSA9IFwiRmF4U2VuZEVycm9yXCI7XG59KShleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0IHx8IChleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0ID0ge30pKTtcbnZhciBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdCA9IGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHQ7XG5cblxuLyoqKi8gfSxcbi8qIDQ5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2dyZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBFeHRlbnNpb25BY3RpdmVDYWxscyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkFjdGl2ZUNhbGxzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkFjdGl2ZUNhbGxzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uQWN0aXZlQ2FsbHMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBjYWxsbG9ncmVjb3JkLkNhbGxMb2dSZWNvcmQsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkFjdGl2ZUNhbGxzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uQWN0aXZlQ2FsbHMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkFjdGl2ZUNhbGxzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25BY3RpdmVDYWxscyA9IEV4dGVuc2lvbkFjdGl2ZUNhbGxzO1xuXG5cbi8qKiovIH0sXG4vKiA1MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9ncmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkNhbGxMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uQ2FsbExvZygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkNhbGxMb2cucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBjYWxsbG9ncmVjb3JkLkNhbGxMb2dSZWNvcmQsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkNhbGxMb2cucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25DYWxsTG9nJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25DYWxsTG9nO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nID0gRXh0ZW5zaW9uQ2FsbExvZztcblxuXG4vKioqLyB9LFxuLyogNTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ2NhbGxlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbnZhciByZWNvcmRpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2Vzc2lvbklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmcm9tJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0bycsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGlyZWN0aW9uJywgQ2xhc3M6IEV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FjdGlvbicsIENsYXNzOiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZXN1bHQnLCBDbGFzczogRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhcnRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25DYWxsTG9nUmVjb3JkJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkID0gRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZDtcbihmdW5jdGlvbiAoRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGUpIHtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZVtFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGVbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZSB8fCAoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZSA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGUgPSBleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uKSB7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uIHx8IChleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSB7fSkpO1xudmFyIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSBleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb247XG4oZnVuY3Rpb24gKEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb24pIHtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lQ2FsbFwiXSA9ICdQaG9uZSBDYWxsJ10gPSBcIlBob25lQ2FsbFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lTG9naW5cIl0gPSAnUGhvbmUgTG9naW4nXSA9IFwiUGhvbmVMb2dpblwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkluY29taW5nRmF4XCJdID0gJ0luY29taW5nIEZheCddID0gXCJJbmNvbWluZ0ZheFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkFjY2VwdENhbGxcIl0gPSAnQWNjZXB0IENhbGwnXSA9IFwiQWNjZXB0Q2FsbFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkZpbmRNZVwiXSA9ICdGaW5kTWUnXSA9IFwiRmluZE1lXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiRm9sbG93TWVcIl0gPSAnRm9sbG93TWUnXSA9IFwiRm9sbG93TWVcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJPdXRnb2luZ0ZheFwiXSA9ICdPdXRnb2luZyBGYXgnXSA9IFwiT3V0Z29pbmdGYXhcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsUmV0dXJuXCJdID0gJ0NhbGwgUmV0dXJuJ10gPSBcIkNhbGxSZXR1cm5cIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsaW5nQ2FyZFwiXSA9ICdDYWxsaW5nIENhcmQnXSA9IFwiQ2FsbGluZ0NhcmRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nRGlyZWN0bHlcIl0gPSAnUmluZyBEaXJlY3RseSddID0gXCJSaW5nRGlyZWN0bHlcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0V2ViXCJdID0gJ1JpbmdPdXQgV2ViJ10gPSBcIlJpbmdPdXRXZWJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJWb0lQQ2FsbFwiXSA9ICdWb0lQIENhbGwnXSA9IFwiVm9JUENhbGxcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0UENcIl0gPSAnUmluZ091dCBQQyddID0gXCJSaW5nT3V0UENcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nTWVcIl0gPSAnUmluZ01lJ10gPSBcIlJpbmdNZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlRyYW5zZmVyXCJdID0gJ1RyYW5zZmVyJ10gPSBcIlRyYW5zZmVyXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uWyc0MTFJbmZvJ10gPSAnNDExIEluZm8nXSA9ICc0MTFJbmZvJztcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJFbWVyZ2VuY3lcIl0gPSAnRW1lcmdlbmN5J10gPSBcIkVtZXJnZW5jeVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvblsnRTkxMVVwZGF0ZSddID0gJ0U5MTEgVXBkYXRlJ10gPSAnRTkxMVVwZGF0ZSc7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiU3VwcG9ydFwiXSA9ICdTdXBwb3J0J10gPSBcIlN1cHBvcnRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0TW9iaWxlXCJdID0gJ1JpbmdPdXQgTW9iaWxlJ10gPSBcIlJpbmdPdXRNb2JpbGVcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbiB8fCAoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uID0ge30pKTtcbnZhciBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uID0gZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0KSB7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN1bHRJblByb2dyZXNzXCJdID0gJ1Jlc3VsdEluUHJvZ3Jlc3MnXSA9IFwiUmVzdWx0SW5Qcm9ncmVzc1wiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIk1pc3NlZFwiXSA9ICdNaXNzZWQnXSA9IFwiTWlzc2VkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbGFjY2VwdGVkXCJdID0gJ0NhbGwgYWNjZXB0ZWQnXSA9IFwiQ2FsbGFjY2VwdGVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlcGx5XCJdID0gJ1JlcGx5J10gPSBcIlJlcGx5XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWNlaXZlRXJyb3JcIl0gPSAnUmVjZWl2ZSBFcnJvciddID0gXCJSZWNlaXZlRXJyb3JcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhvbkRlbWFuZFwiXSA9ICdGYXggb24gRGVtYW5kJ10gPSBcIkZheG9uRGVtYW5kXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUGFydGlhbFJlY2VpdmVcIl0gPSAnUGFydGlhbCBSZWNlaXZlJ10gPSBcIlBhcnRpYWxSZWNlaXZlXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQmxvY2tlZFwiXSA9ICdCbG9ja2VkJ10gPSBcIkJsb2NrZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsY29ubmVjdGVkXCJdID0gJ0NhbGwgY29ubmVjdGVkJ10gPSBcIkNhbGxjb25uZWN0ZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb0Fuc3dlclwiXSA9ICdObyBBbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbCBEaXNhYmxlZCddID0gXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJCdXN5XCJdID0gJ0J1c3knXSA9IFwiQnVzeVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbmRFcnJvclwiXSA9ICdTZW5kIEVycm9yJ10gPSBcIlNlbmRFcnJvclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiTm9mYXhtYWNoaW5lXCJdID0gJ05vIGZheCBtYWNoaW5lJ10gPSBcIk5vZmF4bWFjaGluZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEVtcHR5XCJdID0gJ1Jlc3VsdEVtcHR5J10gPSBcIlJlc3VsdEVtcHR5XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQWNjb3VudFwiXSA9ICdBY2NvdW50J10gPSBcIkFjY291bnRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdXNwZW5kZWRcIl0gPSAnU3VzcGVuZGVkJ10gPSBcIlN1c3BlbmRlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsZWRcIl0gPSAnQ2FsbCBGYWlsZWQnXSA9IFwiQ2FsbEZhaWxlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsdXJlXCJdID0gJ0NhbGwgRmFpbHVyZSddID0gXCJDYWxsRmFpbHVyZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmFsRXJyb3JcIl0gPSAnSW50ZXJuYWwgRXJyb3InXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIklQUGhvbmVvZmZsaW5lXCJdID0gJ0lQIFBob25lIG9mZmxpbmUnXSA9IFwiSVBQaG9uZW9mZmxpbmVcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN0cmljdGVkTnVtYmVyXCJdID0gJ1Jlc3RyaWN0ZWQgTnVtYmVyJ10gPSBcIlJlc3RyaWN0ZWROdW1iZXJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJXcm9uZ051bWJlclwiXSA9ICdXcm9uZyBOdW1iZXInXSA9IFwiV3JvbmdOdW1iZXJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdG9wcGVkXCJdID0gJ1N0b3BwZWQnXSA9IFwiU3RvcHBlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkhhbmd1cFwiXSA9ICdIYW5nIHVwJ10gPSBcIkhhbmd1cFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlBvb3JMaW5lUXVhbGl0eVwiXSA9ICdQb29yIExpbmUgUXVhbGl0eSddID0gXCJQb29yTGluZVF1YWxpdHlcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsbHlTZW50XCJdID0gJ1BhcnRpYWxseSBTZW50J10gPSBcIlBhcnRpYWxseVNlbnRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIl0gPSAnSW50ZXJuYXRpb25hbCBSZXN0cmljdGlvbiddID0gXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJBYmFuZG9uZWRcIl0gPSAnQWJhbmRvbmVkJ10gPSBcIkFiYW5kb25lZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkRlY2xpbmVkXCJdID0gJ0RlY2xpbmVkJ10gPSBcIkRlY2xpbmVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4UmVjZWlwdEVycm9yXCJdID0gJ0ZheCBSZWNlaXB0IEVycm9yJ10gPSBcIkZheFJlY2VpcHRFcnJvclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheFNlbmRFcnJvclwiXSA9ICdGYXggU2VuZCBFcnJvciddID0gXCJGYXhTZW5kRXJyb3JcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdCB8fCAoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0ID0ge30pKTtcbnZhciBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0ID0gZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0O1xuXG5cbi8qKiovIH0sXG4vKiA1MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9ncmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG52YXIgc3luY2luZm9jYWxsbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG52YXIgQ2FsbExvZ1N5bmMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxsTG9nU3luYywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsTG9nU3luYygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbGxMb2dTeW5jLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogY2FsbGxvZ3JlY29yZC5DYWxsTG9nUmVjb3JkLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY0luZm8nLCBDbGFzczogc3luY2luZm9jYWxsbG9nLlN5bmNJbmZvQ2FsbExvZywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENhbGxMb2dTeW5jLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ2FsbExvZ1N5bmMnO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxMb2dTeW5jO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5DYWxsTG9nU3luYyA9IENhbGxMb2dTeW5jO1xuXG5cbi8qKiovIH0sXG4vKiA1MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTeW5jSW5mb0NhbGxMb2cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTeW5jSW5mb0NhbGxMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3luY0luZm9DYWxsTG9nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3luY0luZm9DYWxsTG9nLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUeXBlJywgQ2xhc3M6IFN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jVG9rZW4nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU3luY0luZm9DYWxsTG9nLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU3luY0luZm9DYWxsTG9nJztcbiAgICB9O1xuICAgIHJldHVybiBTeW5jSW5mb0NhbGxMb2c7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlN5bmNJbmZvQ2FsbExvZyA9IFN5bmNJbmZvQ2FsbExvZztcbihmdW5jdGlvbiAoU3luY0luZm9DYWxsTG9nU3luY1R5cGUpIHtcbiAgICBTeW5jSW5mb0NhbGxMb2dTeW5jVHlwZVtTeW5jSW5mb0NhbGxMb2dTeW5jVHlwZVtcIkZTeW5jXCJdID0gJ0ZTeW5jJ10gPSBcIkZTeW5jXCI7XG4gICAgU3luY0luZm9DYWxsTG9nU3luY1R5cGVbU3luY0luZm9DYWxsTG9nU3luY1R5cGVbXCJJU3luY1wiXSA9ICdJU3luYyddID0gXCJJU3luY1wiO1xufSkoZXhwb3J0cy5TeW5jSW5mb0NhbGxMb2dTeW5jVHlwZSB8fCAoZXhwb3J0cy5TeW5jSW5mb0NhbGxMb2dTeW5jVHlwZSA9IHt9KSk7XG52YXIgU3luY0luZm9DYWxsTG9nU3luY1R5cGUgPSBleHBvcnRzLlN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA1NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBDYWxsUmVjb3JkaW5nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsbFJlY29yZGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsUmVjb3JkaW5nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2FsbFJlY29yZGluZy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFVyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFR5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2R1cmF0aW9uJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2FsbFJlY29yZGluZy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NhbGxSZWNvcmRpbmcnO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxSZWNvcmRpbmc7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNhbGxSZWNvcmRpbmcgPSBDYWxsUmVjb3JkaW5nO1xuXG5cbi8qKiovIH0sXG4vKiA1NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgY291bnRyeWxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcbnZhciBkaWN0aW9uYXJ5Y291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcbnZhciBsYW5ndWFnZWxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcbnZhciBsYW5ndWFnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBkaWN0aW9uYXJ5bG9jYXRpb25saXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG52YXIgZGljdGlvbmFyeXNlY3JldHF1ZXN0aW9ubGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xudmFyIHNlY3JldHF1ZXN0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xudmFyIGRpY3Rpb25hcnlzaGlwcGluZ29wdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcbnZhciBkaWN0aW9uYXJ5c3RhdGVsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG52YXIgZGljdGlvbmFyeXN0YXRlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xudmFyIGRpY3Rpb25hcnl0aW1lem9uZWxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcbnZhciBkaWN0aW9uYXJ5dGltZXpvbmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG52YXIgRGljdGlvbmFyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBDb3VudHJ5IExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIHRoZSBjb3VudHJpZXMgYXZhaWxhYmxlIGZvciBjYWxsaW5nLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5saXN0Q291bnRyaWVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9jb3VudHJ5Jywgb3B0aW9ucywgZXhwb3J0cy5saXN0Q291bnRyaWVzT3B0aW9ucyksIGNvdW50cnlsaXN0LkNvdW50cnlMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBDb3VudHJ5XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTAgKFJlbGVhc2UgNi4yKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBpbmZvcm1hdGlvbiBvbiB0aGUgcmVxdWlyZWQgY291bnRyeS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZENvdW50cnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L2NvdW50cnkve2NvdW50cnlJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRDb3VudHJ5T3B0aW9ucyksIGRpY3Rpb25hcnljb3VudHJ5aW5mby5EaWN0aW9uYXJ5Q291bnRyeUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IExhbmd1YWdlIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xNCAoUmVsZWFzZSA2LjYpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGluZm9ybWF0aW9uIGFib3V0IHN1cHBvcnRlZCBsYW5ndWFnZXMuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxpc3RMYW5ndWFnZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L2xhbmd1YWdlJywgb3B0aW9ucywgZXhwb3J0cy5saXN0TGFuZ3VhZ2VzT3B0aW9ucyksIGxhbmd1YWdlbGlzdC5MYW5ndWFnZUxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IExhbmd1YWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTQgKFJlbGVhc2UgNi42KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGxhbmd1YWdlIGJ5IGl0cyByZXNwZWN0aXZlIElELjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5sb2FkTGFuZ3VhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L2xhbmd1YWdlL3tsYW5ndWFnZUlkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZExhbmd1YWdlT3B0aW9ucyksIGxhbmd1YWdlaW5mby5MYW5ndWFnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IExvY2F0aW9uIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIHRoZSBhdmFpbGFibGUgbG9jYXRpb25zIGZvciB0aGUgY2VydGFpbiBzdGF0ZS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubGlzdExvY2F0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvbG9jYXRpb24nLCBvcHRpb25zLCBleHBvcnRzLmxpc3RMb2NhdGlvbnNPcHRpb25zKSwgZGljdGlvbmFyeWxvY2F0aW9ubGlzdC5EaWN0aW9uYXJ5TG9jYXRpb25MaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBTZWNyZXQgUXVlc3Rpb24gTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjIwIChSZWxlYXNlIDcuNCk8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBzZWNyZXQgcXVlc3Rpb25zIGZvciBhIHNwZWNpZmljIGxhbmd1YWdlLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5saXN0U2VjcmV0UXVlc3Rpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9zZWNyZXQtcXVlc3Rpb24nLCBvcHRpb25zLCBleHBvcnRzLmxpc3RTZWNyZXRRdWVzdGlvbnNPcHRpb25zKSwgZGljdGlvbmFyeXNlY3JldHF1ZXN0aW9ubGlzdC5EaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBTZWNyZXQgUXVlc3Rpb25cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yMCAoUmVsZWFzZSA3LjQpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYSBwYXJ0aWN1bGFyIHNlY3JldCBxdWVzdGlvbiBpbiBzcGVjaWZpYyBsYW5ndWFnZSBieSBxdWVzdGlvbiBJRC48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZFNlY3JldFF1ZXN0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9zZWNyZXQtcXVlc3Rpb24vcXVlc3Rpb25JZCcsIG9wdGlvbnMsIGV4cG9ydHMubG9hZFNlY3JldFF1ZXN0aW9uT3B0aW9ucyksIHNlY3JldHF1ZXN0aW9uaW5mby5TZWNyZXRRdWVzdGlvbkluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFNoaXBwaW5nIE9wdGlvbnNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xNiAoUmVsZWFzZSA3LjEpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgZGV2aWNlIHNoaXBwaW5nIG9wdGlvbnMgd2l0aCB0aGVpciBwcmljZXMsIGFjY29yZGluZyB0byBicmFuZCwgdGllciwgbnVtYmVyIG9mIG9yZGVyZWQgZGV2aWNlcy48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubGlzdFNoaXBwaW5nT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvc2hpcHBpbmctb3B0aW9ucycsIG9wdGlvbnMsIGV4cG9ydHMubGlzdFNoaXBwaW5nT3B0aW9uc09wdGlvbnMpLCBkaWN0aW9uYXJ5c2hpcHBpbmdvcHRpb25zLkRpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFN0YXRlIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIHRoZSBzdGF0ZXMgZm9yIGEgY2VydGFpbiBjb3VudHJ5LjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5sb2FkbGlzdFN0YXRlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvc3RhdGUnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRsaXN0U3RhdGVzT3B0aW9ucyksIGRpY3Rpb25hcnlzdGF0ZWxpc3QuRGljdGlvbmFyeVN0YXRlTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU3RhdGVcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGluZm9ybWF0aW9uIG9uIHRoZSByZXF1aXJlZCBzdGF0ZS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZFN0YXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9zdGF0ZS97c3RhdGVJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRTdGF0ZU9wdGlvbnMpLCBkaWN0aW9uYXJ5c3RhdGVpbmZvLkRpY3Rpb25hcnlTdGF0ZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFRpbWV6b25lIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIGF2YWlsYWJsZSB0aW1lem9uZXMuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxpc3RUaW1lem9uZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L3RpbWV6b25lJywgb3B0aW9ucywgZXhwb3J0cy5saXN0VGltZXpvbmVzT3B0aW9ucyksIGRpY3Rpb25hcnl0aW1lem9uZWxpc3QuRGljdGlvbmFyeVRpbWV6b25lTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgVGltZXpvbmVcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGluZm9ybWF0aW9uIG9uIGEgY2VydGFpbiB0aW1lem9uZS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZFRpbWV6b25lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS90aW1lem9uZS97dGltZXpvbmVJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRUaW1lem9uZU9wdGlvbnMpLCBkaWN0aW9uYXJ5dGltZXpvbmVpbmZvLkRpY3Rpb25hcnlUaW1lem9uZUluZm8pO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnk7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuRGljdGlvbmFyeSA9IERpY3Rpb25hcnk7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdENvdW50cmllcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0Q291bnRyaWVzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImxvZ2luQWxsb3dlZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm51bWJlclNlbGxpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZENvdW50cnkgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZENvdW50cnlPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY291bnRyeUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RMYW5ndWFnZXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdExhbmd1YWdlc09wdGlvbnMgPSBbXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkTGFuZ3VhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZExhbmd1YWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImxhbmd1YWdlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdExvY2F0aW9ucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0TG9jYXRpb25zT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm9yZGVyQnlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RMb2NhdGlvbnNPcmRlckJ5XCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiTnBhXCIsXG4gICAgICAgICAgICBcIkNpdHlcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdGF0ZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ3aXRoTnh4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RTZWNyZXRRdWVzdGlvbnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdFNlY3JldFF1ZXN0aW9uc09wdGlvbnMgPSBbXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkU2VjcmV0UXVlc3Rpb24gb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFNlY3JldFF1ZXN0aW9uT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInF1ZXN0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdFNoaXBwaW5nT3B0aW9ucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0U2hpcHBpbmdPcHRpb25zT3B0aW9ucyA9IFtdO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRsaXN0U3RhdGVzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRsaXN0U3RhdGVzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNvdW50cnlJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwid2l0aFBob25lTnVtYmVyc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkU3RhdGUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFN0YXRlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0YXRlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdFRpbWV6b25lcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0VGltZXpvbmVzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkVGltZXpvbmUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFRpbWV6b25lT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInRpbWV6b25lSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4oZnVuY3Rpb24gKElMaXN0TG9jYXRpb25zT3JkZXJCeSkge1xuICAgIElMaXN0TG9jYXRpb25zT3JkZXJCeVtJTGlzdExvY2F0aW9uc09yZGVyQnlbXCJOcGFcIl0gPSAnTnBhJ10gPSBcIk5wYVwiO1xuICAgIElMaXN0TG9jYXRpb25zT3JkZXJCeVtJTGlzdExvY2F0aW9uc09yZGVyQnlbXCJDaXR5XCJdID0gJ0NpdHknXSA9IFwiQ2l0eVwiO1xufSkoZXhwb3J0cy5JTGlzdExvY2F0aW9uc09yZGVyQnkgfHwgKGV4cG9ydHMuSUxpc3RMb2NhdGlvbnNPcmRlckJ5ID0ge30pKTtcbnZhciBJTGlzdExvY2F0aW9uc09yZGVyQnkgPSBleHBvcnRzLklMaXN0TG9jYXRpb25zT3JkZXJCeTtcblxuXG4vKioqLyB9LFxuLyogNTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGljdGlvbmFyeWNvdW50cnlpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgQ291bnRyeUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb3VudHJ5TGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb3VudHJ5TGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvdW50cnlMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZGljdGlvbmFyeWNvdW50cnlpbmZvLkRpY3Rpb25hcnlDb3VudHJ5SW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ291bnRyeUxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDb3VudHJ5TGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gQ291bnRyeUxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNvdW50cnlMaXN0ID0gQ291bnRyeUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDU3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIERpY3Rpb25hcnlDb3VudHJ5SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlDb3VudHJ5SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5Q291bnRyeUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5Q291bnRyeUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbGluZ0NvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VtZXJnZW5jeUNhbGxpbmcnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpc29Db2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdudW1iZXJTZWxsaW5nJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9naW5BbGxvd2VkJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlDb3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlDb3VudHJ5SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeUNvdW50cnlJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5Q291bnRyeUluZm8gPSBEaWN0aW9uYXJ5Q291bnRyeUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDU4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGxhbmd1YWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIExhbmd1YWdlTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExhbmd1YWdlTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYW5ndWFnZUxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYW5ndWFnZUxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogbGFuZ3VhZ2VpbmZvLkxhbmd1YWdlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTGFuZ3VhZ2VMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTGFuZ3VhZ2VMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBMYW5ndWFnZUxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkxhbmd1YWdlTGlzdCA9IExhbmd1YWdlTGlzdDtcblxuXG4vKioqLyB9LFxuLyogNTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbG9jYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRGljdGlvbmFyeUxvY2F0aW9uTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlMb2NhdGlvbkxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeUxvY2F0aW9uTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlMb2NhdGlvbkxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBsb2NhdGlvbmluZm8uTG9jYXRpb25JbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeUxvY2F0aW9uTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlMb2NhdGlvbkxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlMb2NhdGlvbkxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlMb2NhdGlvbkxpc3QgPSBEaWN0aW9uYXJ5TG9jYXRpb25MaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA2MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBMb2NhdGlvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhdGlvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTG9jYXRpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTG9jYXRpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYXJlYUNvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NpdHknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25wYScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbnh4JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0ZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIExvY2F0aW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0xvY2F0aW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYXRpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Mb2NhdGlvbkluZm8gPSBMb2NhdGlvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDYxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHNlY3JldHF1ZXN0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBzZWNyZXRxdWVzdGlvbmluZm8uU2VjcmV0UXVlc3Rpb25JbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdCA9IERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDYyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFNlY3JldFF1ZXN0aW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlY3JldFF1ZXN0aW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWNyZXRRdWVzdGlvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZWNyZXRRdWVzdGlvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3F1ZXN0aW9uVHlwZScsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFuZ3VhZ2VJZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncXVlc3Rpb25UZXh0JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzaG93SW5TaWduVXAnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU2VjcmV0UXVlc3Rpb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU2VjcmV0UXVlc3Rpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTZWNyZXRRdWVzdGlvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlNlY3JldFF1ZXN0aW9uSW5mbyA9IFNlY3JldFF1ZXN0aW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogNjMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgc2hpcHBpbmdtZXRob2RpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG52YXIgRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncXVhbnRpdHknLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ByaWNlJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdtZXRob2QnLCBDbGFzczogc2hpcHBpbmdtZXRob2RpbmZvLlNoaXBwaW5nTWV0aG9kSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMnO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMgPSBEaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zO1xuXG5cbi8qKiovIH0sXG4vKiA2NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTaGlwcGluZ01ldGhvZEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaGlwcGluZ01ldGhvZEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2hpcHBpbmdNZXRob2RJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2hpcHBpbmdNZXRob2RJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU2hpcHBpbmdNZXRob2RJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU2hpcHBpbmdNZXRob2RJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTaGlwcGluZ01ldGhvZEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlNoaXBwaW5nTWV0aG9kSW5mbyA9IFNoaXBwaW5nTWV0aG9kSW5mbztcblxuXG4vKioqLyB9LFxuLyogNjUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGljdGlvbmFyeXN0YXRlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERpY3Rpb25hcnlTdGF0ZUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5U3RhdGVMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlTdGF0ZUxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5U3RhdGVMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZGljdGlvbmFyeXN0YXRlaW5mby5EaWN0aW9uYXJ5U3RhdGVJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5U3RhdGVMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVN0YXRlTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVN0YXRlTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVN0YXRlTGlzdCA9IERpY3Rpb25hcnlTdGF0ZUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDY2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHN0YXRlY291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBEaWN0aW9uYXJ5U3RhdGVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGljdGlvbmFyeVN0YXRlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5U3RhdGVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGljdGlvbmFyeVN0YXRlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb3VudHJ5JywgQ2xhc3M6IHN0YXRlY291bnRyeWluZm8uU3RhdGVDb3VudHJ5SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaXNvQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlTdGF0ZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWN0aW9uYXJ5U3RhdGVJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5U3RhdGVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5U3RhdGVJbmZvID0gRGljdGlvbmFyeVN0YXRlSW5mbztcblxuXG4vKioqLyB9LFxuLyogNjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgU3RhdGVDb3VudHJ5SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YXRlQ291bnRyeUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhdGVDb3VudHJ5SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFN0YXRlQ291bnRyeUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFN0YXRlQ291bnRyeUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTdGF0ZUNvdW50cnlJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZUNvdW50cnlJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5TdGF0ZUNvdW50cnlJbmZvID0gU3RhdGVDb3VudHJ5SW5mbztcblxuXG4vKioqLyB9LFxuLyogNjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGljdGlvbmFyeXRpbWV6b25laW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERpY3Rpb25hcnlUaW1lem9uZUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5VGltZXpvbmVMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlUaW1lem9uZUxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5VGltZXpvbmVMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZGljdGlvbmFyeXRpbWV6b25laW5mby5EaWN0aW9uYXJ5VGltZXpvbmVJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5VGltZXpvbmVMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVRpbWV6b25lTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVRpbWV6b25lTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVRpbWV6b25lTGlzdCA9IERpY3Rpb25hcnlUaW1lem9uZUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDY5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIERpY3Rpb25hcnlUaW1lem9uZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5VGltZXpvbmVJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlUaW1lem9uZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5VGltZXpvbmVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Rlc2NyaXB0aW9uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeVRpbWV6b25lSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlUaW1lem9uZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlUaW1lem9uZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlUaW1lem9uZUluZm8gPSBEaWN0aW9uYXJ5VGltZXpvbmVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA3MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgZXh0ZW5zaW9ubGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xudmFyIGV4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIGV4dGVuc2lvbnBob25lbnVtYmVycyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xudmFyIGV4dGVuc2lvbmdyYW50bGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xudmFyIGRlcGFydG1lbnRtZW1iZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG52YXIgRXh0ZW5zaW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjA8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBleHRlbnNpb25zIGNyZWF0ZWQgZm9yIGEgcGFydGljdWxhciBhY2NvdW50LiBBbGwgdHlwZXMgb2YgZXh0ZW5zaW9ucyBhcmUgaW5jbHVkZWQgaW4gdGhpcyBsaXN0LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxpc3RFeHRlbnNpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24nLCBvcHRpb25zLCBleHBvcnRzLmxpc3RFeHRlbnNpb25zT3B0aW9ucyksIGV4dGVuc2lvbmxpc3QuRXh0ZW5zaW9uTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIEluZm9cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4wPC9wPlxuICAgICAqIDxwPlJldHVybnMgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgYSBwYXJ0aWN1bGFyIGV4dGVuc2lvbiBvZiBhbiBhY2NvdW50LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUubG9hZEV4dGVuc2lvbkluZm8gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkRXh0ZW5zaW9uSW5mb09wdGlvbnMpLCBleHRlbnNpb25pbmZvLkV4dGVuc2lvbkluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBQaG9uZSBOdW1iZXIgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBwaG9uZSBudW1iZXJzIHRoYXQgYXJlIHVzZWQgYnkgYSBwYXJ0aWN1bGFyIGV4dGVuc2lvbiwgYW5kIGNhbiBiZSBmaWx0ZXJlZCBieSB0aGUgcGhvbmUgbnVtYmVyIHR5cGUuIFRoZSByZXR1cm5lZCBsaXN0IGNvbnRhaW5zIGFsbCBudW1iZXJzIHdoaWNoIGFyZSBkaXJlY3RseSBtYXBwZWQgdG8gYSBnaXZlbiBleHRlbnNpb24gcGx1cyB0aGUgZmVhdHVyZXMgYW5kIGFsc28gY29tcGFueS1sZXZlbCBudW1iZXJzXG4gICAgICogICAgIHdoaWNoIG1heSBiZSB1c2VkIHdoZW4gcGVyZm9ybWluZyBkaWZmZXJlbnQgb3BlcmF0aW9ucyBvbiBiZWhhbGYgb2YgdGhpcyBleHRlbnNpb24uPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5saXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9waG9uZS1udW1iZXInLCBvcHRpb25zLCBleHBvcnRzLmxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNPcHRpb25zKSwgZXh0ZW5zaW9ucGhvbmVudW1iZXJzLkV4dGVuc2lvblBob25lTnVtYmVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIEdyYW50IExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBsaXN0IG9mIGV4dGVuc2lvbiBncmFudHMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5saXN0RXh0ZW5zaW9uR3JhbnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9ncmFudCcsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEV4dGVuc2lvbkdyYW50c09wdGlvbnMpLCBleHRlbnNpb25ncmFudGxpc3QuRXh0ZW5zaW9uR3JhbnRMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gUHJvZmlsZSBJbWFnZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGV4dGVuc2lvbiBwcm9maWxlIGltYWdlLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxvYWRFeHRlbnNpb25Qcm9maWxlSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3Byb2ZpbGUtaW1hZ2UnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRFeHRlbnNpb25Qcm9maWxlSW1hZ2VPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgRXh0ZW5zaW9uIFByb2ZpbGUgSW1hZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBleHRlbnNpb24gcHJvZmlsZSBpbWFnZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgbXkgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IaWdoPC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUuY3JlYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJvZmlsZS1pbWFnZScsIG9wdGlvbnMsIGV4cG9ydHMuY3JlYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIEV4dGVuc2lvbiBQcm9maWxlIEltYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+VXBkYXRlcyB0aGUgZXh0ZW5zaW9uIHByb2ZpbGUgaW1hZ2UuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIG15IGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGlnaDwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLnVwZGF0ZUV4dGVuc2lvblByb2ZpbGVJbWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BVVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJvZmlsZS1pbWFnZScsIG9wdGlvbnMsIGV4cG9ydHMudXBkYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBQcm9maWxlIEltYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgc2NhbGVkIHByb2ZpbGUgaW1hZ2Ugb2YgYW4gZXh0ZW5zaW9uLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxvYWRFeHRlbnNpb25TY2FsZWRQcm9maWxlSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3Byb2ZpbGUtaW1hZ2Uve3NjYWxlU2l6ZX0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRFeHRlbnNpb25TY2FsZWRQcm9maWxlSW1hZ2VPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRGVwYXJ0bWVudCBNZW1iZXIgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUubGlzdERlcGFydG1lbnRNZW1iZXJzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9kZXBhcnRtZW50L3tkZXBhcnRtZW50SWR9L21lbWJlcnMnLCBvcHRpb25zLCBleHBvcnRzLmxpc3REZXBhcnRtZW50TWVtYmVyc09wdGlvbnMpLCBkZXBhcnRtZW50bWVtYmVycy5EZXBhcnRtZW50TWVtYmVycyk7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLkV4dGVuc2lvbiA9IEV4dGVuc2lvbjtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0RXh0ZW5zaW9ucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RXh0ZW5zaW9uc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0YXR1c1wiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEV4dGVuc2lvbnNTdGF0dXNcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJFbmFibGVkXCIsXG4gICAgICAgICAgICBcIkRpc2FibGVkXCIsXG4gICAgICAgICAgICBcIk5vdEFjdGl2YXRlZFwiLFxuICAgICAgICAgICAgXCJVbmFzc2lnbmVkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEV4dGVuc2lvbnNUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiVXNlclwiLFxuICAgICAgICAgICAgXCJGYXhVc2VyXCIsXG4gICAgICAgICAgICBcIlZpcnR1YWxVc2VyXCIsXG4gICAgICAgICAgICBcIkRpZ2l0YWxVc2VyXCIsXG4gICAgICAgICAgICBcIkRlcGFydG1lbnRcIixcbiAgICAgICAgICAgIFwiQW5ub3VuY2VtZW50XCIsXG4gICAgICAgICAgICBcIlZvaWNlbWFpbFwiLFxuICAgICAgICAgICAgXCJTaGFyZWRMaW5lc0dyb3VwXCIsXG4gICAgICAgICAgICBcIlBhZ2luZ09ubHlHcm91cFwiLFxuICAgICAgICAgICAgXCJJdnJNZW51XCIsXG4gICAgICAgICAgICBcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCIsXG4gICAgICAgICAgICBcIlBhcmtMb2NhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkRXh0ZW5zaW9uSW5mbyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkRXh0ZW5zaW9uSW5mb09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEV4dGVuc2lvblBob25lTnVtYmVycyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInVzYWdlVHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIk1haW5Db21wYW55TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkNvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiRGlyZWN0TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkNvbXBhbnlGYXhOdW1iZXJcIixcbiAgICAgICAgICAgIFwiRm9yd2FyZGVkTnVtYmVyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RFeHRlbnNpb25HcmFudHMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEV4dGVuc2lvbkdyYW50c09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEV4dGVuc2lvblByb2ZpbGVJbWFnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBjcmVhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuY3JlYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkRXh0ZW5zaW9uU2NhbGVkUHJvZmlsZUltYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRFeHRlbnNpb25TY2FsZWRQcm9maWxlSW1hZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic2NhbGVTaXplXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3REZXBhcnRtZW50TWVtYmVycyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RGVwYXJ0bWVudE1lbWJlcnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkZXBhcnRtZW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4oZnVuY3Rpb24gKElMaXN0RXh0ZW5zaW9uc1N0YXR1cykge1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJFbmFibGVkXCJdID0gJ0VuYWJsZWQnXSA9IFwiRW5hYmxlZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJEaXNhYmxlZFwiXSA9ICdEaXNhYmxlZCddID0gXCJEaXNhYmxlZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJOb3RBY3RpdmF0ZWRcIl0gPSAnTm90QWN0aXZhdGVkJ10gPSBcIk5vdEFjdGl2YXRlZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJVbmFzc2lnbmVkXCJdID0gJ1VuYXNzaWduZWQnXSA9IFwiVW5hc3NpZ25lZFwiO1xufSkoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbnNTdGF0dXMgfHwgKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25zU3RhdHVzID0ge30pKTtcbnZhciBJTGlzdEV4dGVuc2lvbnNTdGF0dXMgPSBleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1N0YXR1cztcbihmdW5jdGlvbiAoSUxpc3RFeHRlbnNpb25zVHlwZSkge1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIlVzZXJcIl0gPSAnVXNlciddID0gXCJVc2VyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiRmF4VXNlclwiXSA9ICdGYXhVc2VyJ10gPSBcIkZheFVzZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJWaXJ0dWFsVXNlclwiXSA9ICdWaXJ0dWFsVXNlciddID0gXCJWaXJ0dWFsVXNlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIkRpZ2l0YWxVc2VyXCJdID0gJ0RpZ2l0YWxVc2VyJ10gPSBcIkRpZ2l0YWxVc2VyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiRGVwYXJ0bWVudFwiXSA9ICdEZXBhcnRtZW50J10gPSBcIkRlcGFydG1lbnRcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJBbm5vdW5jZW1lbnRcIl0gPSAnQW5ub3VuY2VtZW50J10gPSBcIkFubm91bmNlbWVudFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIlZvaWNlbWFpbFwiXSA9ICdWb2ljZW1haWwnXSA9IFwiVm9pY2VtYWlsXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiU2hhcmVkTGluZXNHcm91cFwiXSA9ICdTaGFyZWRMaW5lc0dyb3VwJ10gPSBcIlNoYXJlZExpbmVzR3JvdXBcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJQYWdpbmdPbmx5R3JvdXBcIl0gPSAnUGFnaW5nT25seUdyb3VwJ10gPSBcIlBhZ2luZ09ubHlHcm91cFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIkl2ck1lbnVcIl0gPSAnSXZyTWVudSddID0gXCJJdnJNZW51XCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiQXBwbGljYXRpb25FeHRlbnNpb25cIl0gPSAnQXBwbGljYXRpb25FeHRlbnNpb24nXSA9IFwiQXBwbGljYXRpb25FeHRlbnNpb25cIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJQYXJrTG9jYXRpb25cIl0gPSAnUGFya0xvY2F0aW9uJ10gPSBcIlBhcmtMb2NhdGlvblwiO1xufSkoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbnNUeXBlIHx8IChleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1R5cGUgPSB7fSkpO1xudmFyIElMaXN0RXh0ZW5zaW9uc1R5cGUgPSBleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1R5cGU7XG4oZnVuY3Rpb24gKElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlKSB7XG4gICAgSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJNYWluQ29tcGFueU51bWJlclwiXSA9ICdNYWluQ29tcGFueU51bWJlciddID0gXCJNYWluQ29tcGFueU51bWJlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIl0gPSAnQWRkaXRpb25hbENvbXBhbnlOdW1iZXInXSA9IFwiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkNvbXBhbnlOdW1iZXJcIl0gPSAnQ29tcGFueU51bWJlciddID0gXCJDb21wYW55TnVtYmVyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJEaXJlY3ROdW1iZXJcIl0gPSAnRGlyZWN0TnVtYmVyJ10gPSBcIkRpcmVjdE51bWJlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQ29tcGFueUZheE51bWJlclwiXSA9ICdDb21wYW55RmF4TnVtYmVyJ10gPSBcIkNvbXBhbnlGYXhOdW1iZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkZvcndhcmRlZE51bWJlclwiXSA9ICdGb3J3YXJkZWROdW1iZXInXSA9IFwiRm9yd2FyZGVkTnVtYmVyXCI7XG59KShleHBvcnRzLklMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlIHx8IChleHBvcnRzLklMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlID0ge30pKTtcbnZhciBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZSA9IGV4cG9ydHMuSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDcxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGV4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEV4dGVuc2lvbkxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25MaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25MaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZXh0ZW5zaW9uaW5mby5FeHRlbnNpb25JbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25MaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uTGlzdCA9IEV4dGVuc2lvbkxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDcyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHBob25lbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEV4dGVuc2lvblBob25lTnVtYmVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvblBob25lTnVtYmVycywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25QaG9uZU51bWJlcnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25QaG9uZU51bWJlcnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBwaG9uZW51bWJlcmluZm8uUGhvbmVOdW1iZXJJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25QaG9uZU51bWJlcnMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25QaG9uZU51bWJlcnMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvblBob25lTnVtYmVycztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uUGhvbmVOdW1iZXJzID0gRXh0ZW5zaW9uUGhvbmVOdW1iZXJzO1xuXG5cbi8qKiovIH0sXG4vKiA3MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBncmFudGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBFeHRlbnNpb25HcmFudExpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25HcmFudExpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uR3JhbnRMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uR3JhbnRMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZ3JhbnRpbmZvLkdyYW50SW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uR3JhbnRMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uR3JhbnRMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25HcmFudExpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkdyYW50TGlzdCA9IEV4dGVuc2lvbkdyYW50TGlzdDtcblxuXG4vKioqLyB9LFxuLyogNzQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZXh0ZW5zaW9uaW5mb2dyYW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xudmFyIEdyYW50SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyYW50SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcmFudEluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHcmFudEluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb24nLCBDbGFzczogZXh0ZW5zaW9uaW5mb2dyYW50cy5FeHRlbnNpb25JbmZvR3JhbnRzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsUGlja3VwJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbE1vbml0b3JpbmcnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgR3JhbnRJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnR3JhbnRJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBHcmFudEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkdyYW50SW5mbyA9IEdyYW50SW5mbztcblxuXG4vKioqLyB9LFxuLyogNzUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRXh0ZW5zaW9uSW5mb0dyYW50cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkluZm9HcmFudHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uSW5mb0dyYW50cygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkluZm9HcmFudHMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IEV4dGVuc2lvbkluZm9HcmFudHNUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50cy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkluZm9HcmFudHMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkluZm9HcmFudHM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkluZm9HcmFudHMgPSBFeHRlbnNpb25JbmZvR3JhbnRzO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvR3JhbnRzVHlwZSkge1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiVXNlclwiXSA9ICdVc2VyJ10gPSBcIlVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkZheFVzZXJcIl0gPSAnRmF4IFVzZXInXSA9IFwiRmF4VXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiVmlydHVhbFVzZXJcIl0gPSAnVmlydHVhbFVzZXInXSA9IFwiVmlydHVhbFVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkRpZ2l0YWxVc2VyXCJdID0gJ0RpZ2l0YWxVc2VyJ10gPSBcIkRpZ2l0YWxVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJEZXBhcnRtZW50XCJdID0gJ0RlcGFydG1lbnQnXSA9IFwiRGVwYXJ0bWVudFwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiQW5ub3VuY2VtZW50XCJdID0gJ0Fubm91bmNlbWVudCddID0gXCJBbm5vdW5jZW1lbnRcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIlZvaWNlbWFpbFwiXSA9ICdWb2ljZW1haWwnXSA9IFwiVm9pY2VtYWlsXCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJTaGFyZWRMaW5lc0dyb3VwXCJdID0gJ1NoYXJlZExpbmVzR3JvdXAnXSA9IFwiU2hhcmVkTGluZXNHcm91cFwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiUGFnaW5nT25seVwiXSA9ICdQYWdpbmdPbmx5J10gPSBcIlBhZ2luZ09ubHlcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkl2ck1lbnVcIl0gPSAnSXZyTWVudSddID0gXCJJdnJNZW51XCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiXSA9ICdBcHBsaWNhdGlvbkV4dGVuc2lvbiddID0gXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiUGFya0xvY2F0aW9uXCJdID0gJ1BhcmsgTG9jYXRpb24nXSA9IFwiUGFya0xvY2F0aW9uXCI7XG59KShleHBvcnRzLkV4dGVuc2lvbkluZm9HcmFudHNUeXBlIHx8IChleHBvcnRzLkV4dGVuc2lvbkluZm9HcmFudHNUeXBlID0ge30pKTtcbnZhciBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZSA9IGV4cG9ydHMuRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDc2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGV4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERlcGFydG1lbnRNZW1iZXJzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVwYXJ0bWVudE1lbWJlcnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVwYXJ0bWVudE1lbWJlcnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEZXBhcnRtZW50TWVtYmVycy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGV4dGVuc2lvbmluZm8uRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGVwYXJ0bWVudE1lbWJlcnMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEZXBhcnRtZW50TWVtYmVycyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGVwYXJ0bWVudE1lbWJlcnM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRlcGFydG1lbnRNZW1iZXJzID0gRGVwYXJ0bWVudE1lbWJlcnM7XG5cblxuLyoqKi8gfSxcbi8qIDc3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBtZXNzYWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xudmFyIG1lc3NhZ2VsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG52YXIgbWVzc2FnZXN5bmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyKTtcbnZhciBNZXNzYWdlcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFBhZ2VyIE1lc3NhZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPkNyZWF0ZXMgYW5kIHNlbmRzIGEgcGFnZXIgbWVzc2FnZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkludGVybmFsTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5TZW5kaW5nIGFuZCByZWNlaXZpbmcgaW50cmEtY29tcGFueSB0ZXh0IG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUuc2VuZEludGVybmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2NvbXBhbnktcGFnZXInLCBvcHRpb25zLCBleHBvcnRzLnNlbmRJbnRlcm5hbE1lc3NhZ2VPcHRpb25zKSwgbWVzc2FnZWluZm8uTWVzc2FnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIEZheCBNZXNzYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5DcmVhdGVzIGFuZCBzZW5kcy9yZXNlbmRzIG5ldyBmYXggbWVzc2FnZS4gUmVzZW5kIGNhbiBiZSBkb25lIGlmIHNlbmRpbmcgZmFpbGVkLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RmF4ZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5TZW5kaW5nIGFuZCByZWNlaXZpbmcgZmF4ZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnNlbmRGYXhNZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vZmF4Jywgb3B0aW9ucywgZXhwb3J0cy5zZW5kRmF4TWVzc2FnZU9wdGlvbnMpLCBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgU01TIE1lc3NhZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPkNyZWF0ZXMgYW5kIHNlbmRzIG5ldyBTTVMgbWVzc2FnZS4gU2VuZGluZyBTTVMgbWVzc2FnZXMgc2ltdWx0YW5lb3VzbHkgdG8gZGlmZmVyZW50IHJlY2lwaWVudHMgaXMgbGltaXRlZCB1cCB0byA1MCByZXF1ZXN0cyBwZXIgbWludXRlOyByZWxldmFudCBmb3IgYWxsIGNsaWVudCBhcHBsaWNhdGlvbnMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5TTVM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5TZW5kaW5nIGFuZCByZWNlaXZpbmcgU01TICh0ZXh0KSBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnNlbmRTTVMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9zbXMnLCBvcHRpb25zLCBleHBvcnRzLnNlbmRTTVNPcHRpb25zKSwgbWVzc2FnZWluZm8uTWVzc2FnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1lc3NhZ2UgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBtZXNzYWdlcyBmcm9tIGFuIGV4dGVuc2lvbiBtYWlsYm94LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUubGlzdE1lc3NhZ2VzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN0b3JlJywgb3B0aW9ucywgZXhwb3J0cy5saXN0TWVzc2FnZXNPcHRpb25zKSwgbWVzc2FnZWxpc3QuTWVzc2FnZUxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1lc3NhZ2UocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgaW5kaXZpZHVhbCBtZXNzYWdlIHJlY29yZChzKSBieSB0aGUgZ2l2ZW4gbWVzc2FnZSBJRChzKS4gVGhlIGxlbmd0aCBvZiBpbmJvdW5kIG1lc3NhZ2VzIGlzIHVubGltaXRlZC4gQmF0Y2ggcmVxdWVzdCBpcyBzdXBwb3J0ZWQsIHNlZSBCYXRjaCBSZXF1ZXN0cyBmb3IgZGV0YWlscy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLmxvYWRNZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN0b3JlL3ttZXNzYWdlSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkTWVzc2FnZU9wdGlvbnMpLCBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgTWVzc2FnZShzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+VXBkYXRlcyBtZXNzYWdlKHMpIGJ5IElEKHMpLiBCYXRjaCByZXF1ZXN0IGlzIHN1cHBvcnRlZCwgc2VlIEJhdGNoIFJlcXVlc3RzIGZvciBkZXRhaWxzLiBDdXJyZW50bHksIG9ubHkgdGhlIG1lc3NhZ2UgcmVhZCBzdGF0dXMgdXBkYXRpbmcgaXMgc3VwcG9ydGVkLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnVwZGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L21lc3NhZ2Utc3RvcmUve21lc3NhZ2VJZH0nLCBvcHRpb25zLCBleHBvcnRzLnVwZGF0ZU1lc3NhZ2VPcHRpb25zKSwgbWVzc2FnZWluZm8uTWVzc2FnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIE1lc3NhZ2UocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5EZWxldGVzIG1lc3NhZ2UocykgYnkgdGhlIGdpdmVuIG1lc3NhZ2UgSUQocykuIFRoZSBmaXJzdCBjYWxsIG9mIHRoaXMgbWV0aG9kIHRyYW5zZmVycyB0aGUgbWVzc2FnZSB0byB0aGUgJ0RlbGV0ZScgc3RhdHVzLiBUaGUgc2Vjb25kIGNhbGwgdHJhbnNmZXJzIHRoZSBkZWxldGVkIG1lc3NhZ2UgdG8gdGhlICdQdXJnZWQnIHN0YXR1cy4gSWYgaXQgaXMgcmVxdWlyZWQgdG8gbWFrZSB0aGUgbWVzc2FnZSAnUHVyZ2VkJyBpbW1lZGlhdGVseVxuICAgICAqICAgICAoZnJvbSB0aGUgZmlyc3QgY2FsbCksIHRoZW4gc2V0IHRoZSBxdWVyeSBwYXJhbWV0ZXIgcHVyZ2UgdG8gJ1RydWUnLiBCYXRjaCByZXF1ZXN0IGlzIHN1cHBvcnRlZC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIE1lc3NhZ2VzLnByb3RvdHlwZS5kZWxldGVNZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN0b3JlL3ttZXNzYWdlSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5kZWxldGVNZXNzYWdlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1lc3NhZ2UgQXR0YWNobWVudFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjQgKFJlbGVhc2UgNS4xMyk8L3A+XG4gICAgICogPHA+UmV0dXJucyBwYXJ0aWN1bGFyIG1lc3NhZ2UgYXR0YWNobWVudCBkYXRhIGFzIGEgbWVkaWEgc3RyZWFtLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLmxvYWRNZXNzYWdlQXR0YWNobWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vbWVzc2FnZS1zdG9yZS97bWVzc2FnZUlkfS9jb250ZW50L3thdHRhY2htZW50SWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkTWVzc2FnZUF0dGFjaG1lbnRPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgTWVzc2FnZSBTeW5jXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNCAoUmVsZWFzZSA1LjEzKTwvcD5cbiAgICAgKiA8cD5Qcm92aWRlcyBmYWNpbGl0aWVzIHRvIHN5bmNocm9uaXplIG1haWxib3ggY29udGVudCBzdG9yZWQgZXh0ZXJuYWxseSB3aXRoIHNlcnZlciBzdGF0ZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnN5bmNNZXNzYWdlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vbWVzc2FnZS1zeW5jJywgb3B0aW9ucywgZXhwb3J0cy5zeW5jTWVzc2FnZXNPcHRpb25zKSwgbWVzc2FnZXN5bmMuTWVzc2FnZVN5bmMpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VzO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLk1lc3NhZ2VzID0gTWVzc2FnZXM7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc2VuZEludGVybmFsTWVzc2FnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5zZW5kSW50ZXJuYWxNZXNzYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVwYWdlcm1lc3NhZ2VyZXF1ZXN0LkNyZWF0ZVBhZ2VyTWVzc2FnZVJlcXVlc3RcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc2VuZEZheE1lc3NhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuc2VuZEZheE1lc3NhZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwibm90ZXNcIjogXCJcIixcbiAgICAgICAgXCJwYXJhbVR5cGVcIjogXCJwYXRoXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IFwiflwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiYWxsb3dNdWx0aXBsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJub3Rlc1wiOiBcIlwiLFxuICAgICAgICBcInBhcmFtVHlwZVwiOiBcInBhdGhcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogXCJ+XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJhbGxvd011bHRpcGxlXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJDb250ZW50LVR5cGVcIixcbiAgICAgICAgXCJpblwiOiBcImhlYWRlclwiLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJtdWx0aXBhcnQvbWl4ZWQ7IGJvdW5kYXJ5PUJvdW5kYXJ5XzFfMTQ0MTM5MDFfMTM2MTg3MTA4MDg4OFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJDb250ZW50LUxlbmd0aFwiLFxuICAgICAgICBcImluXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIlwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwiY29uc3VtZXNcIjogW1xuICAgICAgICAgICAgXCJtdWx0aXBhcnQvbWl4ZWQ7IGJvdW5kYXJ5PUJvdW5kYXJ5XzFfMTQ0MTM5MDFfMTM2MTg3MTA4MDg4OFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIi0tQm91bmRhcnlfMV8xNDQxMzkwMV8xMzYxODcxMDgwODg4XFxuQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXFxuXFxue1xcbiAgXFxcInRvXFxcIjpbe1xcXCJwaG9uZU51bWJlclxcXCI6XFxcIjE4MDA1NjMwMDAzXFxcIn1dLFxcbiAgXFxcImZheFJlc29sdXRpb25cXFwiOlxcXCJIaWdoXFxcIixcXG4gIFxcXCJzZW5kVGltZVxcXCI6XFxcIjIwMTMtMDItMjZUMDk6MzE6MjAuODgyWlxcXCJcXG59XFxuXFxuLS1Cb3VuZGFyeV8xXzE0NDEzOTAxXzEzNjE4NzEwODA4ODhcXG5Db250ZW50LVR5cGU6IHRleHQvcGxhaW5cXG5cXG5IZWxsbywgV29ybGQhXFxuXFxuLS1Cb3VuZGFyeV8xXzE0NDEzOTAxXzEzNjE4NzEwODA4ODgtLVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc2VuZFNNUyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5zZW5kU01TT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVzbXNtZXNzYWdlLkNyZWF0ZVNNU01lc3NhZ2VcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdE1lc3NhZ2VzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RNZXNzYWdlc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhdmFpbGFiaWxpdHlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkFsaXZlXCIsXG4gICAgICAgICAgICBcIkRlbGV0ZWRcIixcbiAgICAgICAgICAgIFwiUHVyZ2VkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY29udmVyc2F0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVGcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlVG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiSW5ib3VuZFwiLFxuICAgICAgICAgICAgXCJPdXRib3VuZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpc3RpbmN0Q29udmVyc2F0aW9uc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm1lc3NhZ2VUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkZheFwiLFxuICAgICAgICAgICAgXCJTTVNcIixcbiAgICAgICAgICAgIFwiVm9pY2VNYWlsXCIsXG4gICAgICAgICAgICBcIlBhZ2VyXCIsXG4gICAgICAgICAgICBcIlRleHRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyZWFkU3RhdHVzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0TWVzc2FnZXNSZWFkU3RhdHVzXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiUmVhZFwiLFxuICAgICAgICAgICAgXCJVbnJlYWRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwaG9uZU51bWJlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRNZXNzYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRNZXNzYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm1lc3NhZ2VJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGVNZXNzYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZU1lc3NhZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibWVzc2FnZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcInVwZGF0ZW1lc3NhZ2VyZXF1ZXN0LlVwZGF0ZU1lc3NhZ2VSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGRlbGV0ZU1lc3NhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZGVsZXRlTWVzc2FnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJtZXNzYWdlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwdXJnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNvbnZlcnNhdGlvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZE1lc3NhZ2VBdHRhY2htZW50IG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRNZXNzYWdlQXR0YWNobWVudE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhdHRhY2htZW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJtZXNzYWdlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc3luY01lc3NhZ2VzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnN5bmNNZXNzYWdlc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjb252ZXJzYXRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZUZyb21cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklTeW5jTWVzc2FnZXNEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlzdGluY3RDb252ZXJzYXRpb25zXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibWVzc2FnZVR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiRmF4XCIsXG4gICAgICAgICAgICBcIlNNU1wiLFxuICAgICAgICAgICAgXCJWb2ljZU1haWxcIixcbiAgICAgICAgICAgIFwiUGFnZXJcIixcbiAgICAgICAgICAgIFwiVGV4dFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInJlY29yZENvdW50XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzeW5jVG9rZW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN5bmNUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklTeW5jTWVzc2FnZXNTeW5jVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkZTeW5jXCIsXG4gICAgICAgICAgICBcIklTeW5jXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuKGZ1bmN0aW9uIChJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5KSB7XG4gICAgSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVtJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5W1wiQWxpdmVcIl0gPSAnQWxpdmUnXSA9IFwiQWxpdmVcIjtcbiAgICBJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5W0lMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHlbXCJEZWxldGVkXCJdID0gJ0RlbGV0ZWQnXSA9IFwiRGVsZXRlZFwiO1xuICAgIElMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHlbSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVtcIlB1cmdlZFwiXSA9ICdQdXJnZWQnXSA9IFwiUHVyZ2VkXCI7XG59KShleHBvcnRzLklMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHkgfHwgKGV4cG9ydHMuSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eSA9IHt9KSk7XG52YXIgSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eSA9IGV4cG9ydHMuSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eTtcbihmdW5jdGlvbiAoSUxpc3RNZXNzYWdlc0RpcmVjdGlvbikge1xuICAgIElMaXN0TWVzc2FnZXNEaXJlY3Rpb25bSUxpc3RNZXNzYWdlc0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSUxpc3RNZXNzYWdlc0RpcmVjdGlvbltJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSUxpc3RNZXNzYWdlc0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JTGlzdE1lc3NhZ2VzRGlyZWN0aW9uID0ge30pKTtcbnZhciBJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uID0gZXhwb3J0cy5JTGlzdE1lc3NhZ2VzRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGUpIHtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiU01TXCJdID0gJ1NNUyddID0gXCJTTVNcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVm9pY2VNYWlsXCJdID0gJ1ZvaWNlTWFpbCddID0gXCJWb2ljZU1haWxcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiUGFnZXJcIl0gPSAnUGFnZXInXSA9IFwiUGFnZXJcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVGV4dFwiXSA9ICdUZXh0J10gPSBcIlRleHRcIjtcbn0pKGV4cG9ydHMuSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlIHx8IChleHBvcnRzLklMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlID0gZXhwb3J0cy5JTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKElMaXN0TWVzc2FnZXNSZWFkU3RhdHVzKSB7XG4gICAgSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXNbSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXNbXCJSZWFkXCJdID0gJ1JlYWQnXSA9IFwiUmVhZFwiO1xuICAgIElMaXN0TWVzc2FnZXNSZWFkU3RhdHVzW0lMaXN0TWVzc2FnZXNSZWFkU3RhdHVzW1wiVW5yZWFkXCJdID0gJ1VucmVhZCddID0gXCJVbnJlYWRcIjtcbn0pKGV4cG9ydHMuSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXMgfHwgKGV4cG9ydHMuSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXMgPSB7fSkpO1xudmFyIElMaXN0TWVzc2FnZXNSZWFkU3RhdHVzID0gZXhwb3J0cy5JTGlzdE1lc3NhZ2VzUmVhZFN0YXR1cztcbihmdW5jdGlvbiAoSVN5bmNNZXNzYWdlc0RpcmVjdGlvbikge1xuICAgIElTeW5jTWVzc2FnZXNEaXJlY3Rpb25bSVN5bmNNZXNzYWdlc0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSVN5bmNNZXNzYWdlc0RpcmVjdGlvbltJU3luY01lc3NhZ2VzRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSVN5bmNNZXNzYWdlc0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JU3luY01lc3NhZ2VzRGlyZWN0aW9uID0ge30pKTtcbnZhciBJU3luY01lc3NhZ2VzRGlyZWN0aW9uID0gZXhwb3J0cy5JU3luY01lc3NhZ2VzRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGUpIHtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiU01TXCJdID0gJ1NNUyddID0gXCJTTVNcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVm9pY2VNYWlsXCJdID0gJ1ZvaWNlTWFpbCddID0gXCJWb2ljZU1haWxcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiUGFnZXJcIl0gPSAnUGFnZXInXSA9IFwiUGFnZXJcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVGV4dFwiXSA9ICdUZXh0J10gPSBcIlRleHRcIjtcbn0pKGV4cG9ydHMuSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlIHx8IChleHBvcnRzLklTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZSA9IHt9KSk7XG52YXIgSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlID0gZXhwb3J0cy5JU3luY01lc3NhZ2VzTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKElTeW5jTWVzc2FnZXNTeW5jVHlwZSkge1xuICAgIElTeW5jTWVzc2FnZXNTeW5jVHlwZVtJU3luY01lc3NhZ2VzU3luY1R5cGVbXCJGU3luY1wiXSA9ICdGU3luYyddID0gXCJGU3luY1wiO1xuICAgIElTeW5jTWVzc2FnZXNTeW5jVHlwZVtJU3luY01lc3NhZ2VzU3luY1R5cGVbXCJJU3luY1wiXSA9ICdJU3luYyddID0gXCJJU3luY1wiO1xufSkoZXhwb3J0cy5JU3luY01lc3NhZ2VzU3luY1R5cGUgfHwgKGV4cG9ydHMuSVN5bmNNZXNzYWdlc1N5bmNUeXBlID0ge30pKTtcbnZhciBJU3luY01lc3NhZ2VzU3luY1R5cGUgPSBleHBvcnRzLklTeW5jTWVzc2FnZXNTeW5jVHlwZTtcblxuXG4vKioqLyB9LFxuLyogNzggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbWVzc2FnZWF0dGFjaG1lbnRpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG52YXIgbWVzc2FnZXN0b3JlY2FsbGVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xudmFyIE1lc3NhZ2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVzc2FnZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhdHRhY2htZW50cycsIENsYXNzOiBtZXNzYWdlYXR0YWNobWVudGluZm8uTWVzc2FnZUF0dGFjaG1lbnRJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2F2YWlsYWJpbGl0eScsIENsYXNzOiBNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udmVyc2F0aW9uSWQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NyZWF0aW9uVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGVsaXZlcnlFcnJvckNvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RpcmVjdGlvbicsIENsYXNzOiBNZXNzYWdlSW5mb0RpcmVjdGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmF4UGFnZUNvdW50JywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmYXhSZXNvbHV0aW9uJywgQ2xhc3M6IE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZnJvbScsIENsYXNzOiBtZXNzYWdlc3RvcmVjYWxsZXJpbmZvLk1lc3NhZ2VTdG9yZUNhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhc3RNb2RpZmllZFRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21lc3NhZ2VTdGF0dXMnLCBDbGFzczogTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwZ1RvRGVwYXJ0bWVudCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ByaW9yaXR5JywgQ2xhc3M6IE1lc3NhZ2VJbmZvUHJpb3JpdHksIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlYWRTdGF0dXMnLCBDbGFzczogTWVzc2FnZUluZm9SZWFkU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzbXNEZWxpdmVyeVRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Ntc1NlbmRpbmdBdHRlbXB0c0NvdW50JywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdWJqZWN0JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0bycsIENsYXNzOiBtZXNzYWdlc3RvcmVjYWxsZXJpbmZvLk1lc3NhZ2VTdG9yZUNhbGxlckluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBNZXNzYWdlSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ZtVHJhbnNjcmlwdGlvblN0YXR1cycsIENsYXNzOiBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE1lc3NhZ2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTWVzc2FnZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5NZXNzYWdlSW5mbyA9IE1lc3NhZ2VJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSkge1xuICAgIE1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5W01lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5W1wiQWxpdmVcIl0gPSAnQWxpdmUnXSA9IFwiQWxpdmVcIjtcbiAgICBNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eVtNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eVtcIkRlbGV0ZWRcIl0gPSAnRGVsZXRlZCddID0gXCJEZWxldGVkXCI7XG4gICAgTWVzc2FnZUluZm9BdmFpbGFiaWxpdHlbTWVzc2FnZUluZm9BdmFpbGFiaWxpdHlbXCJQdXJnZWRcIl0gPSAnUHVyZ2VkJ10gPSBcIlB1cmdlZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9BdmFpbGFiaWxpdHkgPSBleHBvcnRzLk1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5O1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb0RpcmVjdGlvbikge1xuICAgIE1lc3NhZ2VJbmZvRGlyZWN0aW9uW01lc3NhZ2VJbmZvRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBNZXNzYWdlSW5mb0RpcmVjdGlvbltNZXNzYWdlSW5mb0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvRGlyZWN0aW9uIHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvRGlyZWN0aW9uID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb0RpcmVjdGlvbiA9IGV4cG9ydHMuTWVzc2FnZUluZm9EaXJlY3Rpb247XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbikge1xuICAgIE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbltNZXNzYWdlSW5mb0ZheFJlc29sdXRpb25bXCJIaWdoXCJdID0gJ0hpZ2gnXSA9IFwiSGlnaFwiO1xuICAgIE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbltNZXNzYWdlSW5mb0ZheFJlc29sdXRpb25bXCJMb3dcIl0gPSAnTG93J10gPSBcIkxvd1wiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb0ZheFJlc29sdXRpb24gfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb0ZheFJlc29sdXRpb24gPSBleHBvcnRzLk1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbjtcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzKSB7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlF1ZXVlZFwiXSA9ICdRdWV1ZWQnXSA9IFwiUXVldWVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIkRlbGl2ZXJlZFwiXSA9ICdEZWxpdmVyZWQnXSA9IFwiRGVsaXZlcmVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIkRlbGl2ZXJ5RmFpbGVkXCJdID0gJ0RlbGl2ZXJ5RmFpbGVkJ10gPSBcIkRlbGl2ZXJ5RmFpbGVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbmRpbmdGYWlsZWRcIl0gPSAnU2VuZGluZ0ZhaWxlZCddID0gXCJTZW5kaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlJlY2VpdmVkXCJdID0gJ1JlY2VpdmVkJ10gPSBcIlJlY2VpdmVkXCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1cyB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXMgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1cyA9IGV4cG9ydHMuTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb1ByaW9yaXR5KSB7XG4gICAgTWVzc2FnZUluZm9Qcmlvcml0eVtNZXNzYWdlSW5mb1ByaW9yaXR5W1wiTm9ybWFsXCJdID0gJ05vcm1hbCddID0gXCJOb3JtYWxcIjtcbiAgICBNZXNzYWdlSW5mb1ByaW9yaXR5W01lc3NhZ2VJbmZvUHJpb3JpdHlbXCJIaWdoXCJdID0gJ0hpZ2gnXSA9IFwiSGlnaFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb1ByaW9yaXR5IHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvUHJpb3JpdHkgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvUHJpb3JpdHkgPSBleHBvcnRzLk1lc3NhZ2VJbmZvUHJpb3JpdHk7XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvUmVhZFN0YXR1cykge1xuICAgIE1lc3NhZ2VJbmZvUmVhZFN0YXR1c1tNZXNzYWdlSW5mb1JlYWRTdGF0dXNbXCJSZWFkXCJdID0gJ1JlYWQnXSA9IFwiUmVhZFwiO1xuICAgIE1lc3NhZ2VJbmZvUmVhZFN0YXR1c1tNZXNzYWdlSW5mb1JlYWRTdGF0dXNbXCJVbnJlYWRcIl0gPSAnVW5yZWFkJ10gPSBcIlVucmVhZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb1JlYWRTdGF0dXMgfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9SZWFkU3RhdHVzID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb1JlYWRTdGF0dXMgPSBleHBvcnRzLk1lc3NhZ2VJbmZvUmVhZFN0YXR1cztcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9UeXBlKSB7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlNNU1wiXSA9ICdTTVMnXSA9IFwiU01TXCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlZvaWNlTWFpbFwiXSA9ICdWb2ljZU1haWwnXSA9IFwiVm9pY2VNYWlsXCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlBhZ2VyXCJdID0gJ1BhZ2VyJ10gPSBcIlBhZ2VyXCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlRleHRcIl0gPSAnVGV4dCddID0gXCJUZXh0XCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvVHlwZSB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb1R5cGUgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvVHlwZSA9IGV4cG9ydHMuTWVzc2FnZUluZm9UeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cykge1xuICAgIE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW01lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW1wiTm90QXZhaWxhYmxlXCJdID0gJ05vdEF2YWlsYWJsZSddID0gXCJOb3RBdmFpbGFibGVcIjtcbiAgICBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tcIkluUHJvZ3Jlc3NcIl0gPSAnSW5Qcm9ncmVzcyddID0gXCJJblByb2dyZXNzXCI7XG4gICAgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbXCJUaW1lZE91dFwiXSA9ICdUaW1lZE91dCddID0gXCJUaW1lZE91dFwiO1xuICAgIE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW01lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW1wiQ29tcGxldGVkXCJdID0gJ0NvbXBsZXRlZCddID0gXCJDb21wbGV0ZWRcIjtcbiAgICBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tcIkNvbXBsZXRlZFBhcnRpYWxseVwiXSA9ICdDb21wbGV0ZWRQYXJ0aWFsbHknXSA9IFwiQ29tcGxldGVkUGFydGlhbGx5XCI7XG4gICAgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbXCJGYWlsZWRcIl0gPSAnRmFpbGVkJ10gPSBcIkZhaWxlZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cyB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cyA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXMgPSBleHBvcnRzLk1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA3OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBNZXNzYWdlQXR0YWNobWVudEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlQXR0YWNobWVudEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZUF0dGFjaG1lbnRJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFR5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ZtRHVyYXRpb24nLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNZXNzYWdlQXR0YWNobWVudEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VBdHRhY2htZW50SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTWVzc2FnZUF0dGFjaG1lbnRJbmZvID0gTWVzc2FnZUF0dGFjaG1lbnRJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlKSB7XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW1wiQXVkaW9SZWNvcmRpbmdcIl0gPSAnQXVkaW9SZWNvcmRpbmcnXSA9IFwiQXVkaW9SZWNvcmRpbmdcIjtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW01lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbXCJBdWRpb1RyYW5zY3JpcHRpb25cIl0gPSAnQXVkaW9UcmFuc2NyaXB0aW9uJ10gPSBcIkF1ZGlvVHJhbnNjcmlwdGlvblwiO1xuICAgIE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtcIlRleHRcIl0gPSAnVGV4dCddID0gXCJUZXh0XCI7XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW1wiU291cmNlRG9jdW1lbnRcIl0gPSAnU291cmNlRG9jdW1lbnQnXSA9IFwiU291cmNlRG9jdW1lbnRcIjtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW01lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbXCJSZW5kZXJlZERvY3VtZW50XCJdID0gJ1JlbmRlcmVkRG9jdW1lbnQnXSA9IFwiUmVuZGVyZWREb2N1bWVudFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlQXR0YWNobWVudEluZm9UeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGUgPSB7fSkpO1xudmFyIE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGUgPSBleHBvcnRzLk1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDgwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE1lc3NhZ2VTdG9yZUNhbGxlckluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlU3RvcmVDYWxsZXJJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VTdG9yZUNhbGxlckluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsb2NhdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbWVzc2FnZVN0YXR1cycsIENsYXNzOiBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmF4RXJyb3JDb2RlJywgQ2xhc3M6IE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Bob25lTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VTdG9yZUNhbGxlckluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VTdG9yZUNhbGxlckluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm8gPSBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cykge1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW1wiUXVldWVkXCJdID0gJ1F1ZXVlZCddID0gXCJRdWV1ZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbXCJEZWxpdmVyZWRcIl0gPSAnRGVsaXZlcmVkJ10gPSBcIkRlbGl2ZXJlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW1wiRGVsaXZlcnlGYWlsZWRcIl0gPSAnRGVsaXZlcnlGYWlsZWQnXSA9IFwiRGVsaXZlcnlGYWlsZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbmRpbmdGYWlsZWRcIl0gPSAnU2VuZGluZ0ZhaWxlZCddID0gXCJTZW5kaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbXCJSZWNlaXZlZFwiXSA9ICdSZWNlaXZlZCddID0gXCJSZWNlaXZlZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cyB8fCAoZXhwb3J0cy5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cyA9IHt9KSk7XG52YXIgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXMgPSBleHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzO1xuKGZ1bmN0aW9uIChNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlKSB7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiVW5kZWZpbmVkXCJdID0gJ1VuZGVmaW5lZCddID0gXCJVbmRlZmluZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJOb0ZheFNlbmRQZXJtaXNzaW9uXCJdID0gJ05vRmF4U2VuZFBlcm1pc3Npb24nXSA9IFwiTm9GYXhTZW5kUGVybWlzc2lvblwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIk5vSW50ZXJuYXRpb25hbFBlcm1pc3Npb25cIl0gPSAnTm9JbnRlcm5hdGlvbmFsUGVybWlzc2lvbiddID0gXCJOb0ludGVybmF0aW9uYWxQZXJtaXNzaW9uXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiTm9GYXhNYWNoaW5lXCJdID0gJ05vRmF4TWFjaGluZSddID0gXCJOb0ZheE1hY2hpbmVcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJPdXRnb2luZ0NhbGxFcnJvclwiXSA9ICdPdXRnb2luZ0NhbGxFcnJvciddID0gXCJPdXRnb2luZ0NhbGxFcnJvclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlJlbmRlcmluZ0ZhaWxlZFwiXSA9ICdSZW5kZXJpbmdGYWlsZWQnXSA9IFwiUmVuZGVyaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiVG9vTWFueVBhZ2VzXCJdID0gJ1Rvb01hbnlQYWdlcyddID0gXCJUb29NYW55UGFnZXNcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJSZXR1cm5Ub0RCUXVldWVcIl0gPSAnUmV0dXJuVG9EQlF1ZXVlJ10gPSBcIlJldHVyblRvREJRdWV1ZVwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIk5vQ2FsbFRpbWVcIl0gPSAnTm9DYWxsVGltZSddID0gXCJOb0NhbGxUaW1lXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiV3JvbmdOdW1iZXJcIl0gPSAnV3JvbmdOdW1iZXInXSA9IFwiV3JvbmdOdW1iZXJcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJQcm9oaWJpdGVkTnVtYmVyXCJdID0gJ1Byb2hpYml0ZWROdW1iZXInXSA9IFwiUHJvaGliaXRlZE51bWJlclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIkludGVybmFsRXJyb3JcIl0gPSAnSW50ZXJuYWxFcnJvciddID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiRmF4U2VuZGluZ1Byb2hpYml0ZWRcIl0gPSAnRmF4U2VuZGluZ1Byb2hpYml0ZWQnXSA9IFwiRmF4U2VuZGluZ1Byb2hpYml0ZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJUaGVQaG9uZUlzQmxhY2tsaXN0ZWRcIl0gPSAnVGhlUGhvbmVJc0JsYWNrbGlzdGVkJ10gPSBcIlRoZVBob25lSXNCbGFja2xpc3RlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlVzZXJOb3RGb3VuZFwiXSA9ICdVc2VyTm90Rm91bmQnXSA9IFwiVXNlck5vdEZvdW5kXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiQ29udmVydEVycm9yXCJdID0gJ0NvbnZlcnRFcnJvciddID0gXCJDb252ZXJ0RXJyb3JcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJEQkdlbmVyYWxFcnJvclwiXSA9ICdEQkdlbmVyYWxFcnJvciddID0gXCJEQkdlbmVyYWxFcnJvclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlNreXBlQmlsbGluZ0ZhaWxlZFwiXSA9ICdTa3lwZUJpbGxpbmdGYWlsZWQnXSA9IFwiU2t5cGVCaWxsaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiQWNjb3VudFN1c3BlbmRlZFwiXSA9ICdBY2NvdW50U3VzcGVuZGVkJ10gPSBcIkFjY291bnRTdXNwZW5kZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJQcm9oaWJpdGVkRGVzdGluYXRpb25cIl0gPSAnUHJvaGliaXRlZERlc3RpbmF0aW9uJ10gPSBcIlByb2hpYml0ZWREZXN0aW5hdGlvblwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG59KShleHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGUgfHwgKGV4cG9ydHMuTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZSA9IHt9KSk7XG52YXIgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZSA9IGV4cG9ydHMuTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZTtcblxuXG4vKioqLyB9LFxuLyogODEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbWVzc2FnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBNZXNzYWdlTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVzc2FnZUxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZUxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNZXNzYWdlTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZUxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VMaXN0ID0gTWVzc2FnZUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDgyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIG1lc3NhZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XG52YXIgbWVzc2FnZXNzeW5jaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oODMpO1xudmFyIE1lc3NhZ2VTeW5jID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVzc2FnZVN5bmMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVN5bmMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlU3luYy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IG1lc3NhZ2VpbmZvLk1lc3NhZ2VJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY0luZm8nLCBDbGFzczogbWVzc2FnZXNzeW5jaW5mby5NZXNzYWdlc1N5bmNJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNZXNzYWdlU3luYy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VTeW5jJztcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlU3luYztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTWVzc2FnZVN5bmMgPSBNZXNzYWdlU3luYztcblxuXG4vKioqLyB9LFxuLyogODMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgTWVzc2FnZXNTeW5jSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VzU3luY0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZXNTeW5jSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1lc3NhZ2VzU3luY0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY1R5cGUnLCBDbGFzczogTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jVG9rZW4nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZXNTeW5jSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VzU3luY0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VzU3luY0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VzU3luY0luZm8gPSBNZXNzYWdlc1N5bmNJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGUpIHtcbiAgICBNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGVbTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlW1wiRlN5bmNcIl0gPSAnRlN5bmMnXSA9IFwiRlN5bmNcIjtcbiAgICBNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGVbTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlW1wiSVN5bmNcIl0gPSAnSVN5bmMnXSA9IFwiSVN5bmNcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VzU3luY0luZm9TeW5jVHlwZSA9IHt9KSk7XG52YXIgTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlID0gZXhwb3J0cy5NZXNzYWdlc1N5bmNJbmZvU3luY1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDg0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBnZXRzdWJzY3JpcHRpb25pbmZvcmVzcG9uc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KTtcbnZhciBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjYgKFJlbGVhc2UgNS4xNSk8L3A+XG4gICAgICogPHA+Q3JlYXRlcyBhIG5ldyBzdWJzY3JpcHRpb24uIFRvIGNhbGwgdGhpcyBtZXRob2Qgd2l0aCBBUE5TIHRyYW5zcG9ydCB0eXBlIHlvdSBoYXZlIHRvIHNwZWNpZnkgZW5kcG9pbnRfaWQgYXR0cmlidXRlIGluIGdldCB0b2tlbiByZXF1ZXN0IGF0IGF1dGhvcml6YXRpb24uPC9wPlxuICAgICAqIDxoND5Vc2FnZSBQbGFuIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbicsIG9wdGlvbnMsIGV4cG9ydHMuY3JlYXRlT3B0aW9ucyksIGdldHN1YnNjcmlwdGlvbmluZm9yZXNwb25zZS5HZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjYgKFJlbGVhc2UgNS4xNSk8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgcmVxdWVzdGVkIHN1YnNjcmlwdGlvbi48L3A+XG4gICAgICogPGg0PlVzYWdlIFBsYW4gR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24ve3N1YnNjcmlwdGlvbklkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZE9wdGlvbnMpLCBnZXRzdWJzY3JpcHRpb25pbmZvcmVzcG9uc2UuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbmV3IFN1YnNjcmlwdGlvbiAvIE1vZGlmeSBFdmVudCBGaWx0ZXJzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNiAoUmVsZWFzZSA1LjE1KTwvcD5cbiAgICAgKiA8cD5XaXRoIGVtcHR5IHJlcXVlc3QgYm9keSAtIHJlbmV3cyB0aGUgZXhpc3RlbnQgc3Vic2NyaXB0aW9uLiBJZiBldmVudCBmaWx0ZXJzIHNwZWNpZmllZCAtIG1vZGlmaWVzIHRoZSBldmVudCBmaWx0ZXJzIGZvciB0aGUgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uLiBUaGUgY2xpZW50IGFwcGxpY2F0aW9uIGNhbiBleHRlbmQgb3IgbmFycm93IHRoZSBldmVudHMgZm9yIHdoaWNoIGl0IHJlY2VpdmVzIG5vdGlmaWNhdGlvbnMgaW4gdGhlIGZyYW1lXG4gICAgICogICAgIG9mIG9uZSBzdWJzY3JpcHRpb24uPC9wPlxuICAgICAqIDxoND5Vc2FnZSBQbGFuIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUFVUJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uL3tzdWJzY3JpcHRpb25JZH0nLCBvcHRpb25zLCBleHBvcnRzLnVwZGF0ZU9wdGlvbnMpLCBnZXRzdWJzY3JpcHRpb25pbmZvcmVzcG9uc2UuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbmNlbCBTdWJzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5DYW5jZWxzIHRoZSBleGlzdGVudCBzdWJzY3JpcHRpb24uPC9wPlxuICAgICAqIDxoND5Vc2FnZSBQbGFuIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uL3tzdWJzY3JpcHRpb25JZH0nLCBvcHRpb25zLCBleHBvcnRzLnJlbW92ZU9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkgPSBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGNyZWF0ZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5jcmVhdGVPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVzdWJzY3JpcHRpb25yZXF1ZXN0LkNyZWF0ZVN1YnNjcmlwdGlvblJlcXVlc3RcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3Vic2NyaXB0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgdXBkYXRlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdWJzY3JpcHRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibW9kaWZ5c3Vic2NyaXB0aW9ucmVxdWVzdC5Nb2RpZnlTdWJzY3JpcHRpb25SZXF1ZXN0XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgcmVtb3ZlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnJlbW92ZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdWJzY3JpcHRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcblxuXG4vKioqLyB9LFxuLyogODUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbm90aWZpY2F0aW9uZGVsaXZlcnltb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nik7XG52YXIgR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdldmVudEZpbHRlcnMnLCBDbGFzczogbnVsbCAvKiBzdHJpbmdbXSAqLywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHBpcmF0aW9uVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXhwaXJlc0luJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXMnLCBDbGFzczogR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjcmVhdGlvblRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RlbGl2ZXJ5TW9kZScsIENsYXNzOiBub3RpZmljYXRpb25kZWxpdmVyeW1vZGUuTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UnO1xuICAgIH07XG4gICAgcmV0dXJuIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZTtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlID0gR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlO1xuKGZ1bmN0aW9uIChHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXMpIHtcbiAgICBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXNbR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzW1wiQWN0aXZlXCJdID0gJ0FjdGl2ZSddID0gXCJBY3RpdmVcIjtcbiAgICBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXNbR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzW1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbn0pKGV4cG9ydHMuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzIHx8IChleHBvcnRzLkdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1cyA9IHt9KSk7XG52YXIgR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzID0gZXhwb3J0cy5HZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXM7XG5cblxuLyoqKi8gfSxcbi8qIDg2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGUucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHJhbnNwb3J0VHlwZScsIENsYXNzOiBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VuY3J5cHRpb24nLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FkZHJlc3MnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3Vic2NyaWJlcktleScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5jcnlwdGlvbkFsZ29yaXRobScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5jcnlwdGlvbktleScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVnaXN0cmF0aW9uSWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NlcnRpZmljYXRlTmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZS5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ05vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSc7XG4gICAgfTtcbiAgICByZXR1cm4gTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Ob3RpZmljYXRpb25EZWxpdmVyeU1vZGUgPSBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGU7XG4oZnVuY3Rpb24gKE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGUpIHtcbiAgICBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlW05vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbXCJQdWJOdWJcIl0gPSAnUHViTnViJ10gPSBcIlB1Yk51YlwiO1xuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtcIkFQTlNcIl0gPSAnQVBOUyddID0gXCJBUE5TXCI7XG4gICAgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlWydQdWJOdWIvQVBOUy9Wb0lQJ10gPSAnUHViTnViL0FQTlMvVm9JUCddID0gJ1B1Yk51Yi9BUE5TL1ZvSVAnO1xuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtcIldlYkhvb2tcIl0gPSAnV2ViSG9vayddID0gXCJXZWJIb29rXCI7XG59KShleHBvcnRzLk5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGUgfHwgKGV4cG9ydHMuTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZSA9IHt9KSk7XG52YXIgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZTtcblxuXG4vKioqLyB9LFxuLyogODcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIHByZXNlbmNlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xudmFyIG1vbml0b3JlZGV4dGVuc2lvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKTtcbnZhciBQcmVzZW5jZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByZXNlbmNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByZXNlbmNlKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbihzKSBQcmVzZW5jZSBTdGF0dXMgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgcHJlc2VuY2Ugc3RhdHVzIG9mIGFuIGV4dGVuc2lvbiBvciBzZXZlcmFsIGV4dGVuc2lvbnMgYnkgdGhlaXIgSUQocykuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLCBzZWUgQmF0Y2ggUmVxdWVzdHMgZm9yIGRldGFpbHMuVGhlIHByZXNlbmNlU3RhdHVzIGlzIHJldHVybmVkIGFzIE9mZmxpbmUgKHRoZSBwYXJhbWV0ZXJzIHRlbGVwaG9ueVN0YXR1cywgbWVzc2FnZSwgdXNlclN0YXR1cyBhbmQgZG5kU3RhdHVzIGFyZSBub3RcbiAgICAgKiAgICAgcmV0dXJuZWQgYXQgYWxsKSBmb3IgdGhlIGZvbGxvd2luZyBleHRlbnNpb24gdHlwZXM6IERlcGFydG1lbnQvQW5ub3VuY2VtZW50IE9ubHkvVGFrZSBNZXNzYWdlcyBPbmx5IChWb2ljZW1haWwpL0ZheCBVc2VyL1BhZ2luZyBPbmx5IEdyb3VwL1NoYXJlZCBMaW5lcyBHcm91cC9JVlIgTWVudS9BcHBsaWNhdGlvbiBFeHRlbnNpb24vUGFyayBMb2NhdGlvbi5JZiB0aGUgdXNlciByZXF1ZXN0cyBoaXMvaGVyIG93biBwcmVzZW5jZSBzdGF0dXMsXG4gICAgICogICAgIHRoZSByZXNwb25zZSBjb250YWlucyBhY3R1YWwgcHJlc2VuY2Ugc3RhdHVzIGV2ZW4gaWYgdGhlIHN0YXR1cyBwdWJsaWNhdGlvbiBpcyB0dXJuZWQgb2ZmLkJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLiBGb3IgYmF0Y2ggcmVxdWVzdHMgdGhlIG51bWJlciBvZiBleHRlbnNpb25zIGluIG9uZSByZXF1ZXN0IGlzIGxpbWl0ZWQgdG8gMzAuIElmIG1vcmUgZXh0ZW5zaW9ucyBhcmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QsIHRoZVxuICAgICAqICAgICBlcnJvciBjb2RlIDQwMCBCYWQgUmVxdWVzdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBsb2dpY2FsIGVycm9yIGNvZGUgSW52YWxpZE11bHRpcGFydFJlcXVlc3QgYW5kIHRoZSBjb3JyZXNwb25kaW5nIG1lc3NhZ2UgJ0V4dGVuc2lvbiBQcmVzZW5jZSBJbmZvIG11bHRpcGFydCByZXF1ZXN0IGlzIGxpbWl0ZWQgdG8gMzAgZXh0ZW5zaW9ucycuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkUHJlc2VuY2U8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5HZXR0aW5nIHVzZXIgcHJlc2VuY2UgaW5mb3JtYXRpb248L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIFByZXNlbmNlLnByb3RvdHlwZS5nZXRQcmVzZW5jZVN0YXR1cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJlc2VuY2UnLCBvcHRpb25zLCBleHBvcnRzLmdldFByZXNlbmNlU3RhdHVzT3B0aW9ucyksIHByZXNlbmNlaW5mby5QcmVzZW5jZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1vbml0b3JlZCBFeHRlbnNpb25zXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTMgKFJlbGVhc2UgNi41KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGxpc3Qgb2YgbGluZXMgLSBleHRlbnNpb25zIHdoaWNoIHByZXNlbmNlIHN0YXR1cyBjYW4gYmUgaW5kaWNhdGVkIGFuZCBtb25pdG9yZWQgb24gQkxGLWVuYWJsZWQgKEJ1c3kgTGFtcCBGaWVsZCkgZGV2aWNlcy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRQcmVzZW5jZTwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPkdldHRpbmcgdXNlciBwcmVzZW5jZSBpbmZvcm1hdGlvbjwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgUHJlc2VuY2UucHJvdG90eXBlLmxpc3RNb25pdG9yZWRFeHRlbnNpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9wcmVzZW5jZS9saW5lJywgb3B0aW9ucywgZXhwb3J0cy5saXN0TW9uaXRvcmVkRXh0ZW5zaW9uc09wdGlvbnMpLCBtb25pdG9yZWRleHRlbnNpb25zLk1vbml0b3JlZEV4dGVuc2lvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFByZXNlbmNlO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLlByZXNlbmNlID0gUHJlc2VuY2U7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgZ2V0UHJlc2VuY2VTdGF0dXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZ2V0UHJlc2VuY2VTdGF0dXNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RNb25pdG9yZWRFeHRlbnNpb25zIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RNb25pdG9yZWRFeHRlbnNpb25zT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcblxuXG4vKioqLyB9LFxuLyogODggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgcHJlc2VuY2VleHRlbnNpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OSk7XG52YXIgUHJlc2VuY2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJlc2VuY2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByZXNlbmNlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFByZXNlbmNlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FsbG93U2VlTXlQcmVzZW5jZScsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RuZFN0YXR1cycsIENsYXNzOiBQcmVzZW5jZUluZm9EbmRTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbicsIENsYXNzOiBwcmVzZW5jZWV4dGVuc2lvbmluZm8uUHJlc2VuY2VFeHRlbnNpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdtZXNzYWdlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaWNrVXBDYWxsc09uSG9sZCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ByZXNlbmNlU3RhdHVzJywgQ2xhc3M6IFByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyaW5nT25Nb25pdG9yZWRDYWxsJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndGVsZXBob255U3RhdHVzJywgQ2xhc3M6IFByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXNlclN0YXR1cycsIENsYXNzOiBQcmVzZW5jZUluZm9Vc2VyU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUHJlc2VuY2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUHJlc2VuY2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQcmVzZW5jZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlByZXNlbmNlSW5mbyA9IFByZXNlbmNlSW5mbztcbihmdW5jdGlvbiAoUHJlc2VuY2VJbmZvRG5kU3RhdHVzKSB7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIlRha2VBbGxDYWxsc1wiXSA9ICdUYWtlQWxsQ2FsbHMnXSA9IFwiVGFrZUFsbENhbGxzXCI7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIkRvTm90QWNjZXB0QW55Q2FsbHNcIl0gPSAnRG9Ob3RBY2NlcHRBbnlDYWxscyddID0gXCJEb05vdEFjY2VwdEFueUNhbGxzXCI7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIkRvTm90QWNjZXB0RGVwYXJ0bWVudENhbGxzXCJdID0gJ0RvTm90QWNjZXB0RGVwYXJ0bWVudENhbGxzJ10gPSBcIkRvTm90QWNjZXB0RGVwYXJ0bWVudENhbGxzXCI7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIlRha2VEZXBhcnRtZW50Q2FsbHNPbmx5XCJdID0gJ1Rha2VEZXBhcnRtZW50Q2FsbHNPbmx5J10gPSBcIlRha2VEZXBhcnRtZW50Q2FsbHNPbmx5XCI7XG59KShleHBvcnRzLlByZXNlbmNlSW5mb0RuZFN0YXR1cyB8fCAoZXhwb3J0cy5QcmVzZW5jZUluZm9EbmRTdGF0dXMgPSB7fSkpO1xudmFyIFByZXNlbmNlSW5mb0RuZFN0YXR1cyA9IGV4cG9ydHMuUHJlc2VuY2VJbmZvRG5kU3RhdHVzO1xuKGZ1bmN0aW9uIChQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cykge1xuICAgIFByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzW1ByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzW1wiT2ZmbGluZVwiXSA9ICdPZmZsaW5lJ10gPSBcIk9mZmxpbmVcIjtcbiAgICBQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1c1tQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1c1tcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXNbUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXNbXCJBdmFpbGFibGVcIl0gPSAnQXZhaWxhYmxlJ10gPSBcIkF2YWlsYWJsZVwiO1xufSkoZXhwb3J0cy5QcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cyB8fCAoZXhwb3J0cy5QcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cyA9IHt9KSk7XG52YXIgUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXMgPSBleHBvcnRzLlByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzO1xuKGZ1bmN0aW9uIChQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXMpIHtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiTm9DYWxsXCJdID0gJ05vQ2FsbCddID0gXCJOb0NhbGxcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiQ2FsbENvbm5lY3RlZFwiXSA9ICdDYWxsQ29ubmVjdGVkJ10gPSBcIkNhbGxDb25uZWN0ZWRcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiUmluZ2luZ1wiXSA9ICdSaW5naW5nJ10gPSBcIlJpbmdpbmdcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiT25Ib2xkXCJdID0gJ09uSG9sZCddID0gXCJPbkhvbGRcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiUGFya2VkQ2FsbFwiXSA9ICdQYXJrZWRDYWxsJ10gPSBcIlBhcmtlZENhbGxcIjtcbn0pKGV4cG9ydHMuUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzIHx8IChleHBvcnRzLlByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1cyA9IHt9KSk7XG52YXIgUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzID0gZXhwb3J0cy5QcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXM7XG4oZnVuY3Rpb24gKFByZXNlbmNlSW5mb1VzZXJTdGF0dXMpIHtcbiAgICBQcmVzZW5jZUluZm9Vc2VyU3RhdHVzW1ByZXNlbmNlSW5mb1VzZXJTdGF0dXNbXCJPZmZsaW5lXCJdID0gJ09mZmxpbmUnXSA9IFwiT2ZmbGluZVwiO1xuICAgIFByZXNlbmNlSW5mb1VzZXJTdGF0dXNbUHJlc2VuY2VJbmZvVXNlclN0YXR1c1tcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgUHJlc2VuY2VJbmZvVXNlclN0YXR1c1tQcmVzZW5jZUluZm9Vc2VyU3RhdHVzW1wiQXZhaWxhYmxlXCJdID0gJ0F2YWlsYWJsZSddID0gXCJBdmFpbGFibGVcIjtcbn0pKGV4cG9ydHMuUHJlc2VuY2VJbmZvVXNlclN0YXR1cyB8fCAoZXhwb3J0cy5QcmVzZW5jZUluZm9Vc2VyU3RhdHVzID0ge30pKTtcbnZhciBQcmVzZW5jZUluZm9Vc2VyU3RhdHVzID0gZXhwb3J0cy5QcmVzZW5jZUluZm9Vc2VyU3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA4OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQcmVzZW5jZUV4dGVuc2lvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmVzZW5jZUV4dGVuc2lvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJlc2VuY2VFeHRlbnNpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUHJlc2VuY2VFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFByZXNlbmNlRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1ByZXNlbmNlRXh0ZW5zaW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUHJlc2VuY2VFeHRlbnNpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5QcmVzZW5jZUV4dGVuc2lvbkluZm8gPSBQcmVzZW5jZUV4dGVuc2lvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDkwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGxpbmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgTW9uaXRvcmVkRXh0ZW5zaW9ucyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vbml0b3JlZEV4dGVuc2lvbnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9uaXRvcmVkRXh0ZW5zaW9ucygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1vbml0b3JlZEV4dGVuc2lvbnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGxpbmVpbmZvLkxpbmVJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNb25pdG9yZWRFeHRlbnNpb25zLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTW9uaXRvcmVkRXh0ZW5zaW9ucyc7XG4gICAgfTtcbiAgICByZXR1cm4gTW9uaXRvcmVkRXh0ZW5zaW9ucztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTW9uaXRvcmVkRXh0ZW5zaW9ucyA9IE1vbml0b3JlZEV4dGVuc2lvbnM7XG5cblxuLyoqKi8gfSxcbi8qIDkxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIG1vbml0b3JlZGxpbmVzZXh0ZW5zaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xudmFyIExpbmVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGluZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMaW5lSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb24nLCBDbGFzczogbW9uaXRvcmVkbGluZXNleHRlbnNpb25pbmZvLk1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIExpbmVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTGluZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIExpbmVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5MaW5lSW5mbyA9IExpbmVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA5MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbyA9IE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbztcbihmdW5jdGlvbiAoTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZSkge1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIlVzZXJcIl0gPSAnVXNlciddID0gXCJVc2VyXCI7XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW1wiRmF4VXNlclwiXSA9ICdGYXhVc2VyJ10gPSBcIkZheFVzZXJcIjtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbXCJWaXJ0dWFsVXNlclwiXSA9ICdWaXJ0dWFsVXNlciddID0gXCJWaXJ0dWFsVXNlclwiO1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIkRpZ2l0YWxVc2VyXCJdID0gJ0RpZ2l0YWxVc2VyJ10gPSBcIkRpZ2l0YWxVc2VyXCI7XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW1wiRGVwYXJ0bWVudFwiXSA9ICdEZXBhcnRtZW50J10gPSBcIkRlcGFydG1lbnRcIjtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiXSA9ICdBcHBsaWNhdGlvbkV4dGVuc2lvbiddID0gXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiO1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIlBhcmtMb2NhdGlvblwiXSA9ICdQYXJrTG9jYXRpb24nXSA9IFwiUGFya0xvY2F0aW9uXCI7XG59KShleHBvcnRzLk1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGUgfHwgKGV4cG9ydHMuTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZSA9IHt9KSk7XG52YXIgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZSA9IGV4cG9ydHMuTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogOTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIHJpbmdvdXRzdGF0dXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KTtcbnZhciBSaW5nT3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmluZ091dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSaW5nT3V0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSBSaW5nT3V0IENhbGxcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC43IChSZWxlYXNlIDUuMTYpPC9wPlxuICAgICAqIDxwPk1ha2VzIGEgMi1sZWcgUmluZ091dCBjYWxsLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmluZ091dDwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlBlcmZvcm1pbmcgdHdvLWxlZ2dlZCByaW5nLW91dCBwaG9uZSBjYWxsczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgUmluZ091dC5wcm90b3R5cGUubWFrZVJpbmdPdXRDYWxsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcmluZ291dCcsIG9wdGlvbnMsIGV4cG9ydHMubWFrZVJpbmdPdXRDYWxsT3B0aW9ucyksIHJpbmdvdXRzdGF0dXMuUmluZ091dFN0YXR1cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU3RhdHVzIG9mIFJpbmdPdXQgQ2FsbFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjcgKFJlbGVhc2UgNS4xNik8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgc3RhdHVzIG9mIGEgMi1sZWcgUmluZ091dCBjYWxsLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmluZ091dDwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlBlcmZvcm1pbmcgdHdvLWxlZ2dlZCByaW5nLW91dCBwaG9uZSBjYWxsczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgUmluZ091dC5wcm90b3R5cGUuZ2V0UmluZ091dENhbGxTdGF0dXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3JpbmdvdXQve3JpbmdvdXRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmdldFJpbmdPdXRDYWxsU3RhdHVzT3B0aW9ucyksIHJpbmdvdXRzdGF0dXMuUmluZ091dFN0YXR1cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYW5jZWwgUmluZ091dCBDYWxsXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+Q2FuY2VscyB0aGUgMi1sZWcgUmluZ091dCBjYWxsLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmluZ091dDwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlBlcmZvcm1pbmcgdHdvLWxlZ2dlZCByaW5nLW91dCBwaG9uZSBjYWxsczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgUmluZ091dC5wcm90b3R5cGUuY2FuY2VsUmluZ091dENhbGwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdERUxFVEUnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3JpbmdvdXQve3JpbmdvdXRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmNhbmNlbFJpbmdPdXRDYWxsT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIFJpbmdPdXQ7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuUmluZ091dCA9IFJpbmdPdXQ7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbWFrZVJpbmdPdXRDYWxsIG9wZXJhdGlvblxuICovXG5leHBvcnRzLm1ha2VSaW5nT3V0Q2FsbE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibWFrZXJpbmdvdXRyZXF1ZXN0Lk1ha2VSaW5nT3V0UmVxdWVzdFwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBnZXRSaW5nT3V0Q2FsbFN0YXR1cyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5nZXRSaW5nT3V0Q2FsbFN0YXR1c09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyaW5nb3V0SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgY2FuY2VsUmluZ091dENhbGwgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuY2FuY2VsUmluZ091dENhbGxPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicmluZ291dElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuXG5cbi8qKiovIH0sXG4vKiA5NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciByaW5nb3V0c3RhdHVzaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xudmFyIFJpbmdPdXRTdGF0dXMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSaW5nT3V0U3RhdHVzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJpbmdPdXRTdGF0dXMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSaW5nT3V0U3RhdHVzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXMnLCBDbGFzczogcmluZ291dHN0YXR1c2luZm8uUmluZ091dFN0YXR1c0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBSaW5nT3V0U3RhdHVzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUmluZ091dFN0YXR1cyc7XG4gICAgfTtcbiAgICByZXR1cm4gUmluZ091dFN0YXR1cztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUmluZ091dFN0YXR1cyA9IFJpbmdPdXRTdGF0dXM7XG5cblxuLyoqKi8gfSxcbi8qIDk1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFJpbmdPdXRTdGF0dXNJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmluZ091dFN0YXR1c0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmluZ091dFN0YXR1c0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSaW5nT3V0U3RhdHVzSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsU3RhdHVzJywgQ2xhc3M6IFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbGVyU3RhdHVzJywgQ2xhc3M6IFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsZWVTdGF0dXMnLCBDbGFzczogUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBSaW5nT3V0U3RhdHVzSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1JpbmdPdXRTdGF0dXNJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBSaW5nT3V0U3RhdHVzSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUmluZ091dFN0YXR1c0luZm8gPSBSaW5nT3V0U3RhdHVzSW5mbztcbihmdW5jdGlvbiAoUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzKSB7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkludmFsaWRcIl0gPSAnSW52YWxpZCddID0gXCJJbnZhbGlkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIlN1Y2Nlc3NcIl0gPSAnU3VjY2VzcyddID0gXCJTdWNjZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkluUHJvZ3Jlc3NcIl0gPSAnSW5Qcm9ncmVzcyddID0gXCJJblByb2dyZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIk5vQW5zd2VyXCJdID0gJ05vQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkdlbmVyaWNFcnJvclwiXSA9ICdHZW5lcmljRXJyb3InXSA9IFwiR2VuZXJpY0Vycm9yXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkZpbmlzaGVkXCJdID0gJ0ZpbmlzaGVkJ10gPSBcIkZpbmlzaGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkRlc3RpbmF0aW9uQmxvY2tlZFwiXSA9ICdEZXN0aW5hdGlvbkJsb2NrZWQnXSA9IFwiRGVzdGluYXRpb25CbG9ja2VkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIk5vdEVub3VnaEZ1bmRzXCJdID0gJ05vdEVub3VnaEZ1bmRzJ10gPSBcIk5vdEVub3VnaEZ1bmRzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIk5vU3VjaFVzZXJcIl0gPSAnTm9TdWNoVXNlciddID0gXCJOb1N1Y2hVc2VyXCI7XG59KShleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cyB8fCAoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXMgPSB7fSkpO1xudmFyIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cyA9IGV4cG9ydHMuUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzO1xuKGZ1bmN0aW9uIChSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cykge1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiSW52YWxpZFwiXSA9ICdJbnZhbGlkJ10gPSBcIkludmFsaWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIlN1Y2Nlc3NcIl0gPSAnU3VjY2VzcyddID0gXCJTdWNjZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJJblByb2dyZXNzXCJdID0gJ0luUHJvZ3Jlc3MnXSA9IFwiSW5Qcm9ncmVzc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIk5vQW5zd2VyXCJdID0gJ05vQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiR2VuZXJpY0Vycm9yXCJdID0gJ0dlbmVyaWNFcnJvciddID0gXCJHZW5lcmljRXJyb3JcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIkZpbmlzaGVkXCJdID0gJ0ZpbmlzaGVkJ10gPSBcIkZpbmlzaGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiRGVzdGluYXRpb25CbG9ja2VkXCJdID0gJ0Rlc3RpbmF0aW9uQmxvY2tlZCddID0gXCJEZXN0aW5hdGlvbkJsb2NrZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIk5vdEVub3VnaEZ1bmRzXCJdID0gJ05vdEVub3VnaEZ1bmRzJ10gPSBcIk5vdEVub3VnaEZ1bmRzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJOb1N1Y2hVc2VyXCJdID0gJ05vU3VjaFVzZXInXSA9IFwiTm9TdWNoVXNlclwiO1xufSkoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cyB8fCAoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cyA9IHt9KSk7XG52YXIgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXMgPSBleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzO1xuKGZ1bmN0aW9uIChSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cykge1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiSW52YWxpZFwiXSA9ICdJbnZhbGlkJ10gPSBcIkludmFsaWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIlN1Y2Nlc3NcIl0gPSAnU3VjY2VzcyddID0gXCJTdWNjZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJJblByb2dyZXNzXCJdID0gJ0luUHJvZ3Jlc3MnXSA9IFwiSW5Qcm9ncmVzc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIk5vQW5zd2VyXCJdID0gJ05vQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiR2VuZXJpY0Vycm9yXCJdID0gJ0dlbmVyaWNFcnJvciddID0gXCJHZW5lcmljRXJyb3JcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIkZpbmlzaGVkXCJdID0gJ0ZpbmlzaGVkJ10gPSBcIkZpbmlzaGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiRGVzdGluYXRpb25CbG9ja2VkXCJdID0gJ0Rlc3RpbmF0aW9uQmxvY2tlZCddID0gXCJEZXN0aW5hdGlvbkJsb2NrZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIk5vdEVub3VnaEZ1bmRzXCJdID0gJ05vdEVub3VnaEZ1bmRzJ10gPSBcIk5vdEVub3VnaEZ1bmRzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJOb1N1Y2hVc2VyXCJdID0gJ05vU3VjaFVzZXInXSA9IFwiTm9TdWNoVXNlclwiO1xufSkoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cyB8fCAoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cyA9IHt9KSk7XG52YXIgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXMgPSBleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA5NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgZXh0ZW5zaW9uZm9yd2FyZGluZ251bWJlcmxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcbnZhciBmb3J3YXJkaW5nbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOTgpO1xudmFyIEZvcndhcmRpbmdOdW1iZXJzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9yd2FyZGluZ051bWJlcnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9yd2FyZGluZ051bWJlcnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIEZvcndhcmRpbmcgTnVtYmVyIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC43IChSZWxlYXNlIDUuMTYpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgZXh0ZW5zaW9uIHBob25lIG51bWJlcnMgdXNlZCBmb3IgY2FsbCBmb3J3YXJkaW5nIGFuZCBjYWxsIGZsaXAuIFRoZSByZXR1cm5lZCBsaXN0IGNvbnRhaW5zIGFsbCB0aGUgZXh0ZW5zaW9uIHBob25lIG51bWJlcnMgdGhhdCBhcmUgdXNlZCBmb3IgY2FsbCBmb3J3YXJkaW5nIGFuZCBjYWxsIGZsaXAuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRm9yd2FyZGluZ051bWJlcnMucHJvdG90eXBlLmxpc3RFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVycyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vZm9yd2FyZGluZy1udW1iZXInLCBvcHRpb25zLCBleHBvcnRzLmxpc3RFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyc09wdGlvbnMpLCBleHRlbnNpb25mb3J3YXJkaW5nbnVtYmVybGlzdC5FeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgRm9yd2FyZGluZyBOdW1iZXJcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMiAoUmVsZWFzZSA2LjQpPC9wPlxuICAgICAqIDxwPkFkZHMgYSBuZXcgZm9yd2FyZGluZyBudW1iZXIgdG8gdGhlIGZvcndhcmRpbmcgbnVtYmVyIGxpc3QuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIsIGFzc2lnbmVkIHBob25lIG51bWJlcnMsIGRldmljZXMgYW5kIG90aGVyIGV4dGVuc2lvbiBzZXR0aW5ncyk8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBGb3J3YXJkaW5nTnVtYmVycy5wcm90b3R5cGUuY3JlYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2ZvcndhcmRpbmctbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5jcmVhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyksIGZvcndhcmRpbmdudW1iZXJpbmZvLkZvcndhcmRpbmdOdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBGb3J3YXJkaW5nIE51bWJlciBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI0IChSZWxlYXNlIDguMCk8L3A+XG4gICAgICogPHA+VXBkYXRlcyBhbiBleGlzdGVudCBmb3J3YXJkaW5nIG51bWJlciBmcm9tIHRoZSBmb3J3YXJkaW5nIG51bWJlciBsaXN0LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyLCBhc3NpZ25lZCBwaG9uZSBudW1iZXJzLCBkZXZpY2VzIGFuZCBvdGhlciBleHRlbnNpb24gc2V0dGluZ3MpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgRm9yd2FyZGluZ051bWJlcnMucHJvdG90eXBlLnVwZGF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2ZvcndhcmRpbmctbnVtYmVyL3tmb3J3YXJkaW5nTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy51cGRhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyksIGZvcndhcmRpbmdudW1iZXJpbmZvLkZvcndhcmRpbmdOdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBGb3J3YXJkaW5nIE51bWJlciBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI0IChSZWxlYXNlIDguMCk8L3A+XG4gICAgICogPHA+RGVsZXRlcyBhIGZvcndhcmRpbmcgbnVtYmVyIGZyb20gdGhlIGZvcndhcmRpbmcgbnVtYmVyIGxpc3QgYnkgaXRzIElELjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyLCBhc3NpZ25lZCBwaG9uZSBudW1iZXJzLCBkZXZpY2VzIGFuZCBvdGhlciBleHRlbnNpb24gc2V0dGluZ3MpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgRm9yd2FyZGluZ051bWJlcnMucHJvdG90eXBlLmRlbGV0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdERUxFVEUnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2ZvcndhcmRpbmctbnVtYmVyL3tmb3J3YXJkaW5nTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy5kZWxldGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcndhcmRpbmdOdW1iZXJzO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLkZvcndhcmRpbmdOdW1iZXJzID0gRm9yd2FyZGluZ051bWJlcnM7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgY3JlYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5jcmVhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVmb3J3YXJkaW5nbnVtYmVycmVxdWVzdC5DcmVhdGVGb3J3YXJkaW5nTnVtYmVyUmVxdWVzdFwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZm9yd2FyZGluZ051bWJlcklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcInVwZGF0ZWZvcndhcmRpbmdudW1iZXJyZXF1ZXN0LlVwZGF0ZUZvcndhcmRpbmdOdW1iZXJSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGRlbGV0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZGVsZXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJmb3J3YXJkaW5nTnVtYmVySWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG5cblxuLyoqKi8gfSxcbi8qIDk3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGZvcndhcmRpbmdudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZm9yd2FyZGluZ251bWJlcmluZm8uRm9yd2FyZGluZ051bWJlckluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCA9IEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA5OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBGb3J3YXJkaW5nTnVtYmVySW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZvcndhcmRpbmdOdW1iZXJJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcndhcmRpbmdOdW1iZXJJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRm9yd2FyZGluZ051bWJlckluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGhvbmVOdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhYmVsJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmZWF0dXJlcycsIENsYXNzOiBGb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmbGlwTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRm9yd2FyZGluZ051bWJlckluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdGb3J3YXJkaW5nTnVtYmVySW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRm9yd2FyZGluZ051bWJlckluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkZvcndhcmRpbmdOdW1iZXJJbmZvID0gRm9yd2FyZGluZ051bWJlckluZm87XG4oZnVuY3Rpb24gKEZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXMpIHtcbiAgICBGb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzW0ZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXNbXCJDYWxsRmxpcFwiXSA9ICdDYWxsRmxpcCddID0gXCJDYWxsRmxpcFwiO1xuICAgIEZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXNbRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlc1tcIkNhbGxGb3J3YXJkaW5nXCJdID0gJ0NhbGxGb3J3YXJkaW5nJ10gPSBcIkNhbGxGb3J3YXJkaW5nXCI7XG59KShleHBvcnRzLkZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXMgfHwgKGV4cG9ydHMuRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcyA9IHt9KSk7XG52YXIgRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcyA9IGV4cG9ydHMuRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcztcblxuXG4vKioqLyB9LFxuLyogOTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGJsb2NrZWRudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDApO1xudmFyIGJsb2NrZWRudW1iZXJzbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKTtcbnZhciBCbG9ja2VkTnVtYmVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrZWROdW1iZXJzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrZWROdW1iZXJzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIEJsb2NrZWQgTnVtYmVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIG15IGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEJsb2NrZWROdW1iZXJzLnByb3RvdHlwZS5ibG9ja051bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5ibG9ja051bWJlck9wdGlvbnMpLCBibG9ja2VkbnVtYmVyaW5mby5CbG9ja2VkTnVtYmVySW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQmxvY2tlZCBOdW1iZXIgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBwaG9uZSBudW1iZXJzIHdoaWNoIGFyZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdG8gYmxvY2sgaW5ib3VuZCBjYWxscyBhbmQgU01TIG1lc3NhZ2VzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEJsb2NrZWROdW1iZXJzLnByb3RvdHlwZS5saXN0QmxvY2tlZE51bWJlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5saXN0QmxvY2tlZE51bWJlcnNPcHRpb25zKSwgYmxvY2tlZG51bWJlcnNsaXN0LkJsb2NrZWROdW1iZXJzTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQmxvY2tlZCBOdW1iZXIocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBCbG9ja2VkTnVtYmVycy5wcm90b3R5cGUubG9hZEJsb2NrZWROdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyL3tibG9ja2VkTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQmxvY2tlZE51bWJlck9wdGlvbnMpLCBibG9ja2VkbnVtYmVyaW5mby5CbG9ja2VkTnVtYmVySW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgQmxvY2tlZCBOdW1iZXIocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgbXkgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgQmxvY2tlZE51bWJlcnMucHJvdG90eXBlLnVwZGF0ZUJsb2NrZWROdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyL3tibG9ja2VkTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy51cGRhdGVCbG9ja2VkTnVtYmVyT3B0aW9ucyksIGJsb2NrZWRudW1iZXJpbmZvLkJsb2NrZWROdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBCbG9ja2VkIE51bWJlcihzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyBteSBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBCbG9ja2VkTnVtYmVycy5wcm90b3R5cGUudW5ibG9ja051bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0RFTEVURScsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vYmxvY2tlZC1udW1iZXIve2Jsb2NrZWROdW1iZXJJZH0nLCBvcHRpb25zLCBleHBvcnRzLnVuYmxvY2tOdW1iZXJPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tlZE51bWJlcnM7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuQmxvY2tlZE51bWJlcnMgPSBCbG9ja2VkTnVtYmVycztcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBibG9ja051bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5ibG9ja051bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEJsb2NrZWROdW1iZXJzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RCbG9ja2VkTnVtYmVyc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEJsb2NrZWROdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEJsb2NrZWROdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYmxvY2tlZE51bWJlcklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHVwZGF0ZUJsb2NrZWROdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlQmxvY2tlZE51bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJibG9ja2VkTnVtYmVySWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgdW5ibG9ja051bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy51bmJsb2NrTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJsb2NrZWROdW1iZXJJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcblxuXG4vKioqLyB9LFxuLyogMTAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEJsb2NrZWROdW1iZXJJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tlZE51bWJlckluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tlZE51bWJlckluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCbG9ja2VkTnVtYmVySW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaG9uZU51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJsb2NrZWROdW1iZXJJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQmxvY2tlZE51bWJlckluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrZWROdW1iZXJJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5CbG9ja2VkTnVtYmVySW5mbyA9IEJsb2NrZWROdW1iZXJJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAxMDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgYmxvY2tlZG51bWJlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgQmxvY2tlZE51bWJlcnNMaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tlZE51bWJlcnNMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrZWROdW1iZXJzTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJsb2NrZWROdW1iZXJzTGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGJsb2NrZWRudW1iZXJpbmZvLkJsb2NrZWROdW1iZXJJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBCbG9ja2VkTnVtYmVyc0xpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdCbG9ja2VkTnVtYmVyc0xpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrZWROdW1iZXJzTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQmxvY2tlZE51bWJlcnNMaXN0ID0gQmxvY2tlZE51bWJlcnNMaXN0O1xuXG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpbmdjZW50cmFsLWNsaWVudC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yaW5nY2VudHJhbC1jbGllbnQvYnVpbGQvcmluZ2NlbnRyYWwtY2xpZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4vc3ltYm9sLW1hcCc7XG5pbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi9yZWR1eC1oZWxwZXInO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudC1lbWl0dGVyJztcblxuY29uc3Qgc3ltYm9scyA9IG5ldyBTeW1ib2xNYXAoW1xuICAnc3RvcmUnLFxuICAnbWFwcGVyJyxcbiAgJ3ByZWZpeCcsXG4gICdhY3Rpb25zJyxcbiAgJ2VtaXR0ZXInLFxuXSk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBkZXNjcmlwdGlvbiBEZWZhdWx0IHJlZHVjZXIgaWYgbW9kdWxlIGRvZXMgbm90IGhhcyBpdHMgb3duIHJlZHVjZXIuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRSZWR1Y2VyKHN0YXRlKSB7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4ge307XG4gIHJldHVybiBzdGF0ZTtcbn1cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBkZXNjcmlwdGlvbiBEZWZhdWx0IHBhcmVudCBzdGF0ZSB0byBtb2R1bGUgc3RhdGUgbWFwcGVyLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0TWFwcGVyKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBkZWZhdWx0XG4gKiBAZGVzY3JpcHRpb24gQmFzZSBtb2R1bGUgY2xhc3MuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJjTW9kdWxlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyLFxuICAgIHN0YXRlTWFwcGVyID0gZGVmYXVsdE1hcHBlcixcbiAgICBwcmVmaXgsXG4gICAgYWN0aW9ucyxcbiAgfSkge1xuICAgIC8vIEV4dGVuZGluZyBFdmVudEVtaXR0ZXIgYnJlYWtzIHNvbWUgbWVjaGFuaWMsIHNvIHdlIHdpcmUgZW1pdHRlciB1cCBsaWtlIHRoaXMgaW5zdGVhZC5cbiAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpc1tzeW1ib2xzLm1hcHBlcl0gPSBzdGF0ZU1hcHBlcjtcbiAgICB0aGlzW3N5bWJvbHMucHJlZml4XSA9IHByZWZpeDtcbiAgICB0aGlzW3N5bWJvbHMuYWN0aW9uc10gPSBhY3Rpb25zICYmIHByZWZpeEFjdGlvbnMoYWN0aW9ucywgcHJlZml4KTtcbiAgICByZWdpc3RlclN0b3JlSGFuZGxlcigoc3RvcmUpID0+IHtcbiAgICAgIHRoaXNbc3ltYm9scy5zdG9yZV0gPSBzdG9yZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiB7RnVuY3Rpb259IFVucmVnaXN0ZXIgZnVuY3Rpb24uXG4gICAqL1xuICBvbihldmVudCwgaGFuZGxlcikge1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5vbihldmVudCwgaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5vZmYoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbil9IGhhbmRsZXJcbiAgICogQHJldHVybiB7RnVuY3Rpb259IFVucmVnaXN0ZXIgZnVuY3Rpb24uXG4gICAqL1xuICBvbmNlKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGhpc1tzeW1ib2xzLmVtaXR0ZXJdLm9uY2UoZXZlbnQsIGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0ub2ZmKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7Li4uYXJnc30gYXJnc1xuICAgKi9cbiAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0ub2ZmKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLm1hcHBlcl0odGhpc1tzeW1ib2xzLnN0b3JlXS5nZXRTdGF0ZSgpKTtcbiAgfVxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlZHVjZXI7XG4gIH1cbiAgZ2V0IHN0b3JlKCkge1xuICAgIHJldHVybiB0aGlzW3N5bWJvbHMuc3RvcmVdO1xuICB9XG4gIGdldCBwcmVmaXgoKSB7XG4gICAgcmV0dXJuIHRoaXNbc3ltYm9scy5wcmVmaXhdO1xuICB9XG4gIGdldCBhY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzW3N5bWJvbHMuYWN0aW9uc107XG4gIH1cblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL3JjLW1vZHVsZS5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4vZW51bSc7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZGVzY3JpcHRpb24gSGVscGVyIGNsYXNzIGZvciBjcmVhdGluZyBhIHN5bWJvbCBtYXBwaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5bWJvbE1hcCBleHRlbmRzIEVudW0ge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGtleXMpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0ge307XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBkZWZpbml0aW9uW2tleV0gPSBTeW1ib2woKTtcbiAgICB9KTtcbiAgICBzdXBlcihkZWZpbml0aW9uKTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL3N5bWJvbC1tYXAuanNcbiAqKi8iLCJjb25zdCBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuY29uc3QgREVGSU5JVElPTiA9IFN5bWJvbCgpO1xuY29uc3QgVkFMVUVTID0gU3ltYm9sKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudW0ge1xuICBjb25zdHJ1Y3RvcihkZWZpbml0aW9uKSB7XG4gICAgdGhpc1tERUZJTklUSU9OXSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmluaXRpb24pO1xuICAgIHRoaXNbVkFMVUVTXSA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmluaXRpb24pIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24sIGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0RFRklOSVRJT05dW2tleV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpc1tWQUxVRVNdLmFkZCh0aGlzW0RFRklOSVRJT05dW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgaGFzVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpc1tWQUxVRVNdLmhhcyh2YWx1ZSk7XG4gIH1cbn1cblxuLypcbiAqIC8vd2l0aCBQcm94eSBzdXBwb3J0XG4gKmNvbnN0IGVudW1IYW5kbGVyID0ge1xuICogIGdldCh0YXJnZXQsIGtleSkge1xuICogICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICogIH0sXG4gKiAgc2V0KCkge1xuICogICAgcmV0dXJuO1xuICogIH1cbiAqfTtcbiAqRW51bSA9IGNsYXNzIEVudW0gZXh0ZW5kcyBQcm94eSB7XG4gKiAgY29uc3RydWN0b3IoZGVmaW5pdGlvbikge1xuICogICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgZGVmaW5pdGlvbiksIGVudW1IYW5kbGVyKTtcbiAqICB9XG4gKn1cbiAqL1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvZW51bS5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4vZW51bSc7XG5cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogQGNsYXNzXG4gKiBAZGVzY3JpcHRpb24gaGVscGVyIGNsYXNzIGZvciBjcmVhdGluZyByZWR1eCBhY3Rpb24gZGVmaW5pdGlvbiBtYXBzXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3Rpb25NYXAgZXh0ZW5kcyBFbnVtIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBhY3Rpb25zIC0gbGlzdCBvZiBhY3Rpb24gc3RyaW5nc1xuICAgKiBAZXh0ZW5kcyBFbnVtXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhY3Rpb25zID0gW10sIHByZWZpeCA9ICcnKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHt9O1xuICAgIGFjdGlvbnMuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgZGVmaW5pdGlvblthY3Rpb25dID0gcHJlZml4ICE9PSAnJyA/IGAke3ByZWZpeH0tJHthY3Rpb259YCA6IGFjdGlvbjtcbiAgICB9KTtcbiAgICBzdXBlcihkZWZpbml0aW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIGhlbHBlciBmdW5jdGlvbiB0byByZXR1cm4gYSBwcmVmaXhlZCBhY3Rpb24gZGVmaW5pdGlvbiBtYXBzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVmaXhBY3Rpb25zKGFjdGlvbnMsIHByZWZpeCkge1xuICBpZiAoIXByZWZpeCB8fCBwcmVmaXggPT09ICcnKSByZXR1cm4gYWN0aW9ucztcbiAgY29uc3QgZGVmaW5pdGlvbiA9IHt9O1xuICBmb3IgKGNvbnN0IGFjdGlvbiBpbiBhY3Rpb25zKSB7XG4gICAgaWYgKGFjdGlvbnM6Omhhc093blByb3BlcnR5KGFjdGlvbikpIHtcbiAgICAgIGRlZmluaXRpb25bYWN0aW9uXSA9IGAke3ByZWZpeH0tJHthY3Rpb259YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBFbnVtKGRlZmluaXRpb24pO1xufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvcmVkdXgtaGVscGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBjYWxsYWJsZSA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcblxuICAsIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGRlc2NyaXB0b3IgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH1cblxuICAsIG9uLCBvbmNlLCBvZmYsIGVtaXQsIG1ldGhvZHMsIGRlc2NyaXB0b3JzLCBiYXNlO1xuXG5vbiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkge1xuXHRcdGRhdGEgPSBkZXNjcmlwdG9yLnZhbHVlID0gY3JlYXRlKG51bGwpO1xuXHRcdGRlZmluZVByb3BlcnR5KHRoaXMsICdfX2VlX18nLCBkZXNjcmlwdG9yKTtcblx0XHRkZXNjcmlwdG9yLnZhbHVlID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRkYXRhID0gdGhpcy5fX2VlX187XG5cdH1cblx0aWYgKCFkYXRhW3R5cGVdKSBkYXRhW3R5cGVdID0gbGlzdGVuZXI7XG5cdGVsc2UgaWYgKHR5cGVvZiBkYXRhW3R5cGVdID09PSAnb2JqZWN0JykgZGF0YVt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0ZWxzZSBkYXRhW3R5cGVdID0gW2RhdGFbdHlwZV0sIGxpc3RlbmVyXTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9uY2UgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIG9uY2UsIHNlbGY7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXHRzZWxmID0gdGhpcztcblx0b24uY2FsbCh0aGlzLCB0eXBlLCBvbmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdG9mZi5jYWxsKHNlbGYsIHR5cGUsIG9uY2UpO1xuXHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0pO1xuXG5cdG9uY2UuX19lZU9uY2VMaXN0ZW5lcl9fID0gbGlzdGVuZXI7XG5cdHJldHVybiB0aGlzO1xufTtcblxub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBkYXRhLCBsaXN0ZW5lcnMsIGNhbmRpZGF0ZSwgaTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuIHRoaXM7XG5cdGRhdGEgPSB0aGlzLl9fZWVfXztcblx0aWYgKCFkYXRhW3R5cGVdKSByZXR1cm4gdGhpcztcblx0bGlzdGVuZXJzID0gZGF0YVt0eXBlXTtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRmb3IgKGkgPSAwOyAoY2FuZGlkYXRlID0gbGlzdGVuZXJzW2ldKTsgKytpKSB7XG5cdFx0XHRpZiAoKGNhbmRpZGF0ZSA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdFx0KGNhbmRpZGF0ZS5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMikgZGF0YVt0eXBlXSA9IGxpc3RlbmVyc1tpID8gMCA6IDFdO1xuXHRcdFx0XHRlbHNlIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmICgobGlzdGVuZXJzID09PSBsaXN0ZW5lcikgfHxcblx0XHRcdFx0KGxpc3RlbmVycy5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0ZGVsZXRlIGRhdGFbdHlwZV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0dmFyIGksIGwsIGxpc3RlbmVyLCBsaXN0ZW5lcnMsIGFyZ3M7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuO1xuXHRsaXN0ZW5lcnMgPSB0aGlzLl9fZWVfX1t0eXBlXTtcblx0aWYgKCFsaXN0ZW5lcnMpIHJldHVybjtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuXHRcdGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuXHRcdGZvciAoaSA9IDA7IChsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0YXBwbHkuY2FsbChsaXN0ZW5lciwgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGNhc2UgMTpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJndW1lbnRzWzFdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdH1cblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH1cbn07XG5cbm1ldGhvZHMgPSB7XG5cdG9uOiBvbixcblx0b25jZTogb25jZSxcblx0b2ZmOiBvZmYsXG5cdGVtaXQ6IGVtaXRcbn07XG5cbmRlc2NyaXB0b3JzID0ge1xuXHRvbjogZChvbiksXG5cdG9uY2U6IGQob25jZSksXG5cdG9mZjogZChvZmYpLFxuXHRlbWl0OiBkKGVtaXQpXG59O1xuXG5iYXNlID0gZGVmaW5lUHJvcGVydGllcyh7fSwgZGVzY3JpcHRvcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiAobykge1xuXHRyZXR1cm4gKG8gPT0gbnVsbCkgPyBjcmVhdGUoYmFzZSkgOiBkZWZpbmVQcm9wZXJ0aWVzKE9iamVjdChvKSwgZGVzY3JpcHRvcnMpO1xufTtcbmV4cG9ydHMubWV0aG9kcyA9IG1ldGhvZHM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9ldmVudC1lbWl0dGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvYXNzaWduJylcbiAgLCBub3JtYWxpemVPcHRzID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMnKVxuICAsIGlzQ2FsbGFibGUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZScpXG4gICwgY29udGFpbnMgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMnKVxuXG4gICwgZDtcblxuZCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRzY3IsIHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgdywgb3B0aW9ucywgZGVzYztcblx0aWYgKChhcmd1bWVudHMubGVuZ3RoIDwgMikgfHwgKHR5cGVvZiBkc2NyICE9PSAnc3RyaW5nJykpIHtcblx0XHRvcHRpb25zID0gdmFsdWU7XG5cdFx0dmFsdWUgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB3ID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHRcdHcgPSBjb250YWlucy5jYWxsKGRzY3IsICd3Jyk7XG5cdH1cblxuXHRkZXNjID0geyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSwgd3JpdGFibGU6IHcgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cbmQuZ3MgPSBmdW5jdGlvbiAoZHNjciwgZ2V0LCBzZXQvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCBvcHRpb25zLCBkZXNjO1xuXHRpZiAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSBnZXQ7XG5cdFx0Z2V0ID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzNdO1xuXHR9XG5cdGlmIChnZXQgPT0gbnVsbCkge1xuXHRcdGdldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShnZXQpKSB7XG5cdFx0b3B0aW9ucyA9IGdldDtcblx0XHRnZXQgPSBzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoc2V0ID09IG51bGwpIHtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUoc2V0KSkge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9XG5cdGlmIChkc2NyID09IG51bGwpIHtcblx0XHRjID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHR9XG5cblx0ZGVzYyA9IHsgZ2V0OiBnZXQsIHNldDogc2V0LCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9kL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBPYmplY3QuYXNzaWduXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduLCBvYmo7XG5cdGlmICh0eXBlb2YgYXNzaWduICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdG9iaiA9IHsgZm9vOiAncmF6JyB9O1xuXHRhc3NpZ24ob2JqLCB7IGJhcjogJ2R3YScgfSwgeyB0cnp5OiAndHJ6eScgfSk7XG5cdHJldHVybiAob2JqLmZvbyArIG9iai5iYXIgKyBvYmoudHJ6eSkgPT09ICdyYXpkd2F0cnp5Jztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vaXMtaW1wbGVtZW50ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgID0gcmVxdWlyZSgnLi4va2V5cycpXG4gICwgdmFsdWUgPSByZXF1aXJlKCcuLi92YWxpZC12YWx1ZScpXG5cbiAgLCBtYXggPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVzdCwgc3JjLyosIOKApnNyY24qLykge1xuXHR2YXIgZXJyb3IsIGksIGwgPSBtYXgoYXJndW1lbnRzLmxlbmd0aCwgMiksIGFzc2lnbjtcblx0ZGVzdCA9IE9iamVjdCh2YWx1ZShkZXN0KSk7XG5cdGFzc2lnbiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR0cnkgeyBkZXN0W2tleV0gPSBzcmNba2V5XTsgfSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlO1xuXHRcdH1cblx0fTtcblx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRrZXlzKHNyYykuZm9yRWFjaChhc3NpZ24pO1xuXHR9XG5cdGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnJvcjtcblx0cmV0dXJuIGRlc3Q7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanNcbiAqKiBtb2R1bGUgaWQgPSAxNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IE9iamVjdC5rZXlzXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdE9iamVjdC5rZXlzKCdwcmltaXRpdmUnKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL2lzLWltcGxlbWVudGVkLmpzXG4gKiogbW9kdWxlIGlkID0gMTQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuXHRyZXR1cm4ga2V5cyhvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IE9iamVjdChvYmplY3QpKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL3NoaW0uanNcbiAqKiBtb2R1bGUgaWQgPSAxNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoc3JjLCBvYmopIHtcblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gc3JjKSBvYmpba2V5XSA9IHNyY1trZXldO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucy8qLCDigKZvcHRpb25zKi8pIHtcblx0dmFyIHJlc3VsdCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucyA9PSBudWxsKSByZXR1cm47XG5cdFx0cHJvY2VzcyhPYmplY3Qob3B0aW9ucyksIHJlc3VsdCk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBEZXByZWNhdGVkXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvaXMtY2FsbGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IFN0cmluZy5wcm90b3R5cGUuY29udGFpbnNcblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0ciA9ICdyYXpkd2F0cnp5JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc3RyLmNvbnRhaW5zICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoKHN0ci5jb250YWlucygnZHdhJykgPT09IHRydWUpICYmIChzdHIuY29udGFpbnMoJ2ZvbycpID09PSBmYWxzZSkpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaXMtaW1wbGVtZW50ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluZGV4T2YgPSBTdHJpbmcucHJvdG90eXBlLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZy8qLCBwb3NpdGlvbiovKSB7XG5cdHJldHVybiBpbmRleE9mLmNhbGwodGhpcywgc2VhcmNoU3RyaW5nLCBhcmd1bWVudHNbMV0pID4gLTE7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9zaGltLmpzXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcblx0cmV0dXJuIGZuO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgeyBBY3Rpb25NYXAsIHByZWZpeEFjdGlvbnMgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gJ3JlZHV4JztcblxuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ3JlZHVjZXInLFxuXSk7XG5cbmZ1bmN0aW9uIGdldFNldHRpbmdzUmVkdWNlcihwcmVmaXgpIHtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB7fTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3MgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICAgIHRoaXNbc3ltYm9scy5yZWR1Y2VyXSA9IHtcbiAgICAgIGJhc2U6IGdldFNldHRpbmdzUmVkdWNlcih0aGlzLnByZWZpeCksXG4gICAgfTtcbiAgfVxuICByZWdpc3RlclJlZHVjZXIobmFtZSwgcmVkdWNlcikge1xuICAgIHRoaXNbc3ltYm9scy5yZWR1Y2VyXVtuYW1lXSA9IHJlZHVjZXI7XG4gIH1cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVSZWR1Y2Vycyh0aGlzW3N5bWJvbHMucmVkdWNlcl0pO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3NldHRpbmdzL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb21wb3NlID0gZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBleHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IGV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gZXhwb3J0cy5jcmVhdGVTdG9yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9jcmVhdGVTdG9yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVTdG9yZSk7XG5cbnZhciBfY29tYmluZVJlZHVjZXJzID0gcmVxdWlyZSgnLi9jb21iaW5lUmVkdWNlcnMnKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tYmluZVJlZHVjZXJzKTtcblxudmFyIF9iaW5kQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2JpbmRBY3Rpb25DcmVhdG9ycycpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaW5kQWN0aW9uQ3JlYXRvcnMpO1xuXG52YXIgX2FwcGx5TWlkZGxld2FyZSA9IHJlcXVpcmUoJy4vYXBwbHlNaWRkbGV3YXJlJyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FwcGx5TWlkZGxld2FyZSk7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKlxuKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXG4qIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cbiovXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgaXNDcnVzaGVkLm5hbWUgPT09ICdzdHJpbmcnICYmIGlzQ3J1c2hlZC5uYW1lICE9PSAnaXNDcnVzaGVkJykge1xuICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXFwncHJvZHVjdGlvblxcJy4gJyArICdUaGlzIG1lYW5zIHRoYXQgeW91IGFyZSBydW5uaW5nIGEgc2xvd2VyIGRldmVsb3BtZW50IGJ1aWxkIG9mIFJlZHV4LiAnICsgJ1lvdSBjYW4gdXNlIGxvb3NlLWVudmlmeSAoaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvbG9vc2UtZW52aWZ5KSBmb3IgYnJvd3NlcmlmeSAnICsgJ29yIERlZmluZVBsdWdpbiBmb3Igd2VicGFjayAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDAzMDAzMSkgJyArICd0byBlbnN1cmUgeW91IGhhdmUgdGhlIGNvcnJlY3QgY29kZSBmb3IgeW91ciBwcm9kdWN0aW9uIGJ1aWxkLicpO1xufVxuXG5leHBvcnRzLmNyZWF0ZVN0b3JlID0gX2NyZWF0ZVN0b3JlMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmNvbWJpbmVSZWR1Y2VycyA9IF9jb21iaW5lUmVkdWNlcnMyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gX2JpbmRBY3Rpb25DcmVhdG9yczJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBfYXBwbHlNaWRkbGV3YXJlMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmNvbXBvc2UgPSBfY29tcG9zZTJbXCJkZWZhdWx0XCJdO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHVuZGVmaW5lZDtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY3JlYXRlU3RvcmU7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlID0gcmVxdWlyZSgnc3ltYm9sLW9ic2VydmFibGUnKTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbE9ic2VydmFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciBBY3Rpb25UeXBlcyA9IGV4cG9ydHMuQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6ICdAQHJlZHV4L0lOSVQnXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBbaW5pdGlhbFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmhhbmNlciBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IGluaXRpYWxTdGF0ZTtcbiAgICBpbml0aWFsU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gJyArICdVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiAnICsgJ0hhdmUgeW91IG1pc3NwZWxsZWQgYSBjb25zdGFudD8nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbX3N5bWJvbE9ic2VydmFibGUyW1wiZGVmYXVsdFwiXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9XG5cbiAgLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG4gIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcjogcmVwbGFjZVJlZHVjZXJcbiAgfSwgX3JlZjJbX3N5bWJvbE9ic2VydmFibGUyW1wiZGVmYXVsdFwiXV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc0hvc3RPYmplY3QgPSByZXF1aXJlKCcuL19pc0hvc3RPYmplY3QnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHxcbiAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpICE9IG9iamVjdFRhZyB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuLyoqXG4gKiBHZXRzIHRoZSBgW1tQcm90b3R5cGVdXWAgb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIGBbW1Byb3RvdHlwZV1dYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvdG90eXBlKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVHZXRQcm90b3R5cGUoT2JqZWN0KHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL19nZXRQcm90b3R5cGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNIb3N0T2JqZWN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL19pc0hvc3RPYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC9pc09iamVjdExpa2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BvbnlmaWxsJykoZ2xvYmFsIHx8IHdpbmRvdyB8fCB0aGlzKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N5bWJvbC1vYnNlcnZhYmxlL3BvbnlmaWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbWJpbmVSZWR1Y2VycztcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pIHtcbiAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uVHlwZSAmJiAnXCInICsgYWN0aW9uVHlwZS50b1N0cmluZygpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcblxuICByZXR1cm4gJ0dpdmVuIGFjdGlvbiAnICsgYWN0aW9uTmFtZSArICcsIHJlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZC4gJyArICdUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuJztcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgPyAnaW5pdGlhbFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gJ1RoZSAnICsgYXJndW1lbnROYW1lICsgJyBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFwiJyArIHt9LnRvU3RyaW5nLmNhbGwoaW5wdXRTdGF0ZSkubWF0Y2goL1xccyhbYS16fEEtWl0rKS8pWzFdICsgJ1wiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nICcgKyAoJ2tleXM6IFwiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiJyk7XG4gIH1cblxuICB2YXIgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgfSk7XG5cbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgJyArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgJyAnICsgKCdcIicgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgYXJndW1lbnROYW1lICsgJy4gJykgKyAnRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiAnICsgKCdcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2FuaXR5KHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSAnQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl8nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUICsgJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpICsgJ25hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlICcgKyAnY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgJyArICdpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgJyArICdhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICB2YXIgc2FuaXR5RXJyb3I7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNhbml0eShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNhbml0eUVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHNhbml0eUVycm9yKSB7XG4gICAgICB0aHJvdyBzYW5pdHlFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShzdGF0ZSwgZmluYWxSZWR1Y2VycywgYWN0aW9uKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGZpbmFsUmVkdWNlcktleXNbaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNba2V5XTtcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVba2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVba2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvY29tYmluZVJlZHVjZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMTYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHdhcm5pbmc7XG4vKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMTYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGJpbmRBY3Rpb25DcmVhdG9ycztcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBhcHBseU1pZGRsZXdhcmU7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpO1xuICAgICAgdmFyIF9kaXNwYXRjaCA9IHN0b3JlLmRpc3BhdGNoO1xuICAgICAgdmFyIGNoYWluID0gW107XG5cbiAgICAgIHZhciBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gX2Rpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKTtcbiAgICAgIH0pO1xuICAgICAgX2Rpc3BhdGNoID0gX2NvbXBvc2UyW1wiZGVmYXVsdFwiXS5hcHBseSh1bmRlZmluZWQsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzXG4gKiogbW9kdWxlIGlkID0gMTY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29tcG9zZTtcbi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvclxuICogdGhlIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3MgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQuIEZvciBleGFtcGxlLCBjb21wb3NlKGYsIGcsIGgpIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSkuXG4gKi9cblxuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmVzdCA9IGZ1bmNzLnNsaWNlKDAsIC0xKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHY6IGZ1bmN0aW9uIHYoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3QucmVkdWNlUmlnaHQoZnVuY3Rpb24gKGNvbXBvc2VkLCBmKSB7XG4gICAgICAgICAgICByZXR1cm4gZihjb21wb3NlZCk7XG4gICAgICAgICAgfSwgbGFzdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGlmICh0eXBlb2YgX3JldCA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzXG4gKiogbW9kdWxlIGlkID0gMTY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgYnJhbmRBY3Rpb25zIGZyb20gJy4vYnJhbmQtYWN0aW9ucyc7XG5pbXBvcnQgZ2V0UmVkdWNlciBmcm9tICcuL2JyYW5kLXJlZHVjZXInO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ2luaXRpYWxTdGF0ZScsXG5dKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJhbmQgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZWdpc3RlclN0b3JlSGFuZGxlcixcbiAgICBzdGF0ZU1hcHBlciA9IChzdGF0ZSkgPT4gc3RhdGUuYnJhbmQsXG4gICAgcHJlZml4LFxuICAgIGlkLFxuICAgIG5hbWUsXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcixcbiAgICAgIHN0YXRlTWFwcGVyLFxuICAgICAgcHJlZml4LFxuICAgICAgYWN0aW9uczogYnJhbmRBY3Rpb25zLFxuICAgIH0pO1xuICAgIHRoaXNbc3ltYm9scy5pbml0aWFsU3RhdGVdID0ge1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgIH07XG4gIH1cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIGdldFJlZHVjZXIodGhpc1tzeW1ib2xzLmluaXRpYWxTdGF0ZV0sIHRoaXMucHJlZml4KTtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaWQ7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubmFtZTtcbiAgfVxufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2JyYW5kL2luZGV4LmpzXG4gKiovIiwiaW1wb3J0IHsgQWN0aW9uTWFwIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBBY3Rpb25NYXAoW1xuICAnc2V0QnJhbmQnLFxuXSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2JyYW5kL2JyYW5kLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgYnJhbmRBY3Rpb25zIGZyb20gJy4vYnJhbmQtYWN0aW9ucyc7XG5pbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UmVkdWNlcihpbml0aWFsU3RhdGUsIHByZWZpeCkge1xuICBjb25zdCBhY3Rpb25zID0gcHJlZml4QWN0aW9ucyhicmFuZEFjdGlvbnMsIHByZWZpeCk7XG4gIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcblxuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgY2FzZSBhY3Rpb25zLnNldEJyYW5kOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBuYW1lOiBhY3Rpb24ucGF5bG9hZC5uYW1lLFxuICAgICAgICAgIGlkOiBhY3Rpb24ucGF5bG9hZC5pZCxcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9icmFuZC9icmFuZC1yZWR1Y2VyLmpzXG4gKiovIiwiaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4uLy4uL2xpYi9yYy1tb2R1bGUnO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5pbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgbG9naW5TdGF0dXMgZnJvbSAnLi9sb2dpbi1zdGF0dXMnO1xuaW1wb3J0IGF1dGhBY3Rpb25zIGZyb20gJy4vYXV0aC1hY3Rpb25zJztcbmltcG9ydCBnZXRBdXRoUmVkdWNlciBmcm9tICcuL2F1dGgtcmVkdWNlcic7XG5pbXBvcnQgeyBhdXRoRXZlbnRzLCBhdXRoRXZlbnRUeXBlcyB9IGZyb20gJy4vYXV0aC1ldmVudHMnO1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5cblxuY29uc3Qgc3ltYm9scyA9IG5ldyBTeW1ib2xNYXAoW1xuICAncGxhdGZvcm0nLFxuICAnZW1pdHRlcicsXG4gICdiZWZvcmVMb2dvdXRIYW5kbGVycycsXG5dKTtcblxuY29uc3QgRU5VTVMgPSBuZXcgRW51bSh7XG4gIGxvZ2luU3RhdHVzLFxufSk7XG5cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBkZXNjcmlwdGlvbiBBdXRoZW50aWNhdGlvbiBtb2R1bGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0aCBleHRlbmRzIFJjTW9kdWxlIHtcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhY3Rpb25zOiBhdXRoQWN0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBwbGF0Zm9ybSxcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzW3N5bWJvbHMuYmVmb3JlTG9nb3V0SGFuZGxlcnNdID0gbmV3IFNldCgpO1xuXG4gICAgLy8gbG9hZCBpbmZvIG9uIGxvZ2luXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luU3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dpblN1Y2Nlc3MsXG4gICAgICB9KTtcbiAgICAgIHRoaXM6OmVtaXQoYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXRlLnN0YXR1cyk7XG4gICAgfSk7XG4gICAgLy8gbG9naW5FcnJvclxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dpbkVycm9yLCBlcnJvciA9PiB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmxvZ2luRXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gdW5sb2FkIGluZm8gb24gbG9nb3V0XG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ291dFN1Y2Nlc3MsICgpID0+IHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMubG9nb3V0U3VjY2VzcyxcbiAgICAgIH0pO1xuICAgICAgLy8gdGhpcy5lbWl0KGF1dGhFdmVudHMudXNlckluZm9DbGVhcmVkKTtcbiAgICB9KTtcblxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dvdXRFcnJvciwgZXJyb3IgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dvdXRFcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5yZWZyZXNoRXJyb3IsIGVycm9yID0+IHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMucmVmcmVzaEVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gbG9hZCBpbmZvIGlmIGFscmVhZHkgbG9nZ2VkIGluXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlZEluID0gYXdhaXQgcGxhdGZvcm0ubG9nZ2VkSW4oKTtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuaW5pdCxcbiAgICAgICAgc3RhdHVzOiBsb2dnZWRJbiA/IGxvZ2luU3RhdHVzLmxvZ2dlZEluIDogbG9naW5TdGF0dXMubm90TG9nZ2VkSW4sXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChhdXRoRXZlbnRUeXBlcy5hdXRoRXZlbnRUeXBlcywgdGhpcy5zdGF0ZS5zdGF0dXMpO1xuICAgIH0pKCk7XG4gIH1cblxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZ2V0QXV0aFJlZHVjZXIodGhpcy5wcmVmaXgpO1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBkZXNjcmlwdGlvbiBMb2dpbiBmdW5jdGlvbiB1c2luZyB1c2VybmFtZSBhbmQgcGFzc3dvcmRcbiAgICovXG4gIGFzeW5jIGxvZ2luKHsgdXNlcm5hbWUsIHBhc3N3b3JkLCBleHRlbnNpb24sIHJlbWVtYmVyIH0pIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dpbixcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgdXNlcm5hbWUsXG4gICAgICAgIHBhc3N3b3JkLFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgIHJlbWVtYmVyLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzOjplbWl0KGF1dGhFdmVudFR5cGVzLmxvZ2luU3RhdHVzQ2hhbmdlZCwgYXV0aEV2ZW50cy5sb2dnaW5nSW4pO1xuICAgIHJldHVybiBhd2FpdCB0aGlzW3N5bWJvbHMucGxhdGZvcm1dLmxvZ2luKHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQsXG4gICAgICBleHRlbnNpb24sXG4gICAgICByZW1lbWJlcixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBkZXNjcmlwdGlvbiBBdXRob3JpemUgdXNpbmcgT0FhdXRoIGNvZGVcbiAgICovXG4gIGFzeW5jIGF1dGhvcml6ZSh7IGNvZGUsIHJlZGlyZWN0VXJpIH0pIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dpbixcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgY29kZSxcbiAgICAgICAgcmVkaXJlY3RVcmksXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCBhdXRoRXZlbnRzLmxvZ2dpbmdJbik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0ubG9naW4oe1xuICAgICAgY29kZSxcbiAgICAgIHJlZGlyZWN0VXJpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQGRlc2NyaXB0aW9uIExvZyB0aGUgdXNlciBvdXRcbiAgICovXG4gIGFzeW5jIGxvZ291dCgpIHtcbiAgICAvLyBkZWFsIHdpdGggcmVtb3Zpbmcgc3Vic2NyaXB0aW9uc1xuXG4gICAgdGhpczo6ZW1pdChhdXRoRXZlbnRUeXBlcy5sb2dpblN0YXR1c0NoYW5nZWQsIGF1dGhFdmVudHMubG9nZ2luZ091dCk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBbLi4udGhpc1tzeW1ib2xzLmJlZm9yZUxvZ291dEhhbmRsZXJzXV07XG4gICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB3cmFwcyB3aXRoIGFzeW5jIHNvIGV2ZW4gbm9ybWFsIGZ1bmN0aW9ucyBjYW4gYmUgYXdhaXRlZFxuICAgICAgICAvLyBUT0RPIGNhbmNlbCBsb2dvdXQgaWYgaGFuZGxlciByZXNvbHZlcyB0byBmYWxzZVxuICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4gaGFuZGxlcigpKSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgZW1pdCBlcnJvclxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpc1tzeW1ib2xzLnBsYXRmb3JtXS5sb2dvdXQoKTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKi9cbiAgYWRkQmVmb3JlTG9nb3V0SGFuZGxlcihoYW5kbGVyKSB7XG4gICAgdGhpc1tzeW1ib2xzLmJlZm9yZUxvZ291dEhhbmRsZXJzXS5hZGQoaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXNbc3ltYm9scy5iZWZvcmVMb2dvdXRIYW5kbGVyc10ucmVtb3ZlKGhhbmRsZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZW1vdmVCZWZvcmVMb2dvdXRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICB0aGlzW3N5bWJvbHMuYmVmb3JlTG9nb3V0SGFuZGxlcnNdLnJlbW92ZShoYW5kbGVyKTtcbiAgfVxuXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhdHVzO1xuICB9XG5cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gYXV0aEV2ZW50cztcbiAgfVxuXG4gIGdldCBldmVudFR5cGVzKCkge1xuICAgIHJldHVybiBhdXRoRXZlbnRUeXBlcztcbiAgfVxuXG4gIGdldCBlbnVtcygpIHtcbiAgICByZXR1cm4gRU5VTVM7XG4gIH1cblxuICBhc3luYyBpc0xvZ2dlZEluKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzW3N5bWJvbHMucGxhdGZvcm1dLmxvZ2dlZEluKCk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYXV0aC9pbmRleC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXHJcbiAgLCBjcmVhdGVEZXNjICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgaW5kZXgsIHZhbHVlKXtcclxuICBpZihpbmRleCBpbiBvYmplY3QpJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xyXG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUoKG91dGVyRm4gfHwgR2VuZXJhdG9yKS5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLmFyZykudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8XG4gICAgICAgICAgICAgIChtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBhcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9wcm9taXNlXCIpO1xuXG52YXIgX3Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvbWlzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gc3RlcChrZXksIGFyZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIpO1xuICAgIH0pO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlByb21pc2U7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2xhc3NvZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc2V0UHJvdG8gICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0XG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAxODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgcGVuZGluZzogJ1BFTkRJTkcnLCAvLyBhZnRlciBpbml0LCBiZWZvcmUgc3RhdHVzIGZyb20gcGxhdGZvcm0gaXMgZGV0ZXJtaW5lZFxuICBub3RMb2dnZWRJbjogJ05PVF9MT0dHRURfSU4nLFxuICBsb2dnaW5nSW46ICdMT0dHSU5HX0lOJyxcbiAgbG9nZ2VkSW46ICdMT0dHRURfSU4nLFxuICBsb2dnaW5nT3V0OiAnTE9HR0lOR19PVVQnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEVudW0oZGVmaW5pdGlvbik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2F1dGgvbG9naW4tc3RhdHVzLmpzXG4gKiovIiwiaW1wb3J0IHsgQWN0aW9uTWFwIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBBY3Rpb25NYXAoW1xuICAnbG9naW4nLFxuICAnbG9naW5TdWNjZXNzJyxcbiAgJ2xvZ2luRXJyb3InLFxuICAnbG9nb3V0JyxcbiAgJ2xvZ291dFN1Y2Nlc3MnLFxuICAnbG9nb3V0RXJyb3InLFxuICAncmVmcmVzaCcsXG4gICdyZWZyZXNoU3VjY2VzcycsXG4gICdyZWZyZXNoRXJyb3InLFxuICAnaW5pdCcsXG5dLCAnYXV0aCcpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtYWN0aW9ucy5qc1xuICoqLyIsImltcG9ydCB7IHByZWZpeEFjdGlvbnMgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcbmltcG9ydCBhdXRoQWN0aW9ucyBmcm9tICcuL2F1dGgtYWN0aW9ucyc7XG5pbXBvcnQgbG9naW5TdGF0dXMgZnJvbSAnLi9sb2dpbi1zdGF0dXMnO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIHN0YXR1czogbG9naW5TdGF0dXMucGVuZGluZyxcbiAgYXV0aEVycm9yOiBudWxsLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QXV0aFJlZHVjZXIocHJlZml4KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBwcmVmaXhBY3Rpb25zKGF1dGhBY3Rpb25zLCBwcmVmaXgpO1xuICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgaWYgKCFhY3Rpb24pIHJldHVybiBzdGF0ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICAgIGNhc2UgYWN0aW9ucy5pbml0OlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHsgc3RhdHVzOiBhY3Rpb24uc3RhdHVzIH0pO1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9naW46XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBsb2dpblN0YXR1cy5sb2dnaW5nSW4sXG4gICAgICAgICAgYXV0aEVycm9yOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9naW5TdWNjZXNzOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogbG9naW5TdGF0dXMubG9nZ2VkSW4sXG4gICAgICAgICAgYXV0aEVycm9yOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9nb3V0U3VjY2VzczpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IGxvZ2luU3RhdHVzLm5vdExvZ2dlZEluLFxuICAgICAgICAgIGF1dGhFcnJvcjogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBhY3Rpb25zLmxvZ2luRXJyb3I6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6IGxvZ2luU3RhdHVzLm5vdExvZ2dlZEluLFxuICAgICAgICAgIGF1dGhFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9nb3V0RXJyb3I6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBsb2dpblN0YXR1cy5sb2dnZWRJbixcbiAgICAgICAgICBhdXRoRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYXV0aC9hdXRoLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgbG9naW5TdGF0dXMgZnJvbSAnLi9sb2dpbi1zdGF0dXMnO1xuXG5jb25zdCBldmVudERlZmluaXRpb25zID0ge1xuICAuLi5sb2dpblN0YXR1cyxcbn07XG5cbmV4cG9ydCBjb25zdCBhdXRoRXZlbnRzID0gbmV3IEVudW0oZXZlbnREZWZpbml0aW9ucyk7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb25zID0ge1xuICBsb2dpblN0YXR1c0NoYW5nZWQ6ICdMT0dJTl9TVEFUVVNfQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3QgYXV0aEV2ZW50VHlwZXMgPSBuZXcgRW51bShldmVudFR5cGVEZWZpbml0aW9ucyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2F1dGgvYXV0aC1ldmVudHMuanNcbiAqKi8iLCJleHBvcnQgZnVuY3Rpb24gZXh0cmFjdERhdGEobW9kZWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWwpKSB7XG4gICAgcmV0dXJuIG1vZGVsLm1hcChpdGVtID0+IGV4dHJhY3REYXRhKGl0ZW0pKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZWwgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1vZGVsKSB7XG4gICAgICBpZiAoa2V5WzBdICE9PSAnXycgJiYgbW9kZWwuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkYXRhW2tleV0gPSBleHRyYWN0RGF0YShtb2RlbFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIG1vZGVsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hMaXN0KGZuKSB7XG4gIGxldCBmZXRjaGVkUGFnZXMgPSAwO1xuICBsZXQgdG90YWxQYWdlcyA9IDE7XG4gIGxldCBsaXN0ID0gW107XG4gIHdoaWxlIChmZXRjaGVkUGFnZXMgPCB0b3RhbFBhZ2VzKSB7XG4gICAgZmV0Y2hlZFBhZ2VzKys7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZuKHtcbiAgICAgIHBhZ2U6IGZldGNoZWRQYWdlcyxcbiAgICB9KTtcbiAgICB0b3RhbFBhZ2VzID0gZGF0YS5wYWdpbmcudG90YWxQYWdlcztcbiAgICBsaXN0ID0gbGlzdC5jb25jYXQoZGF0YS5yZWNvcmRzKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQGRlc2NyaXB0aW9uIEhlbHBlciBmdW5jdGlvbiB0byBlbWl0IGV2ZW50VHlwZWQgZXZlbnRzIGFuZCB0aGUgZXZlbnQgaXRzZWxmXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbWl0KGV2ZW50VHlwZSwgZXZlbnQsIC4uLnBheWxvYWRzKSB7XG4gIHRoaXMuZW1pdChldmVudCwgLi4ucGF5bG9hZHMpO1xuICB0aGlzLmVtaXQoZXZlbnRUeXBlLCBldmVudCwgLi4ucGF5bG9hZHMpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKHQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdCk7XG4gIH0pO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL3V0aWxzLmpzXG4gKiovIiwiaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4uLy4uL2xpYi9yYy1tb2R1bGUnO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5pbXBvcnQgc3Vic2NyaXB0aW9uQWN0aW9ucyBmcm9tICcuL3N1YnNjcmlwdGlvbi1hY3Rpb25zJztcbmltcG9ydCBnZXRTdWJzY3JpcHRpb25SZWR1Y2VyIGZyb20gJy4vc3Vic2NyaXB0aW9uLXJlZHVjZXInO1xuaW1wb3J0IHsgc3Vic2NyaXB0aW9uRXZlbnRzLCBzdWJzY3JpcHRpb25FdmVudFR5cGVzIH0gZnJvbSAnLi9zdWJzY3JpcHRpb24tZXZlbnRzJztcbmltcG9ydCBzdWJzY3JpcHRpb25TdGF0dXMgZnJvbSAnLi9zdWJzY3JpcHRpb24tc3RhdHVzJztcbmltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcbmltcG9ydCB7IGVtaXQgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdhdXRoJyxcbiAgJ3NkaycsXG4gICdwbGF0Zm9ybScsXG4gICdzdWJzY3JpcHRpb24nLFxuICAnZmlsdGVyQ2FjaGUnLFxuXSk7XG5cblxuY29uc3QgZmlsdGVyUmVnZXggPSB7XG4gIG1lc3NhZ2U6IC9tZXNzYWdlLXN0b3JlJC8sXG4gIHByZXNlbmNlOiAvcHJlc2VuY2UoXFw/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlKT8kLyxcbiAgdGVsZXBob255OiAvcHJlc2VuY2VcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUkLyxcbiAgbGluZTogL3ByZXNlbmNlXFwvbGluZSQvLFxuICBsaW5lUHJlc2VuY2U6IC9wcmVzZW5jZVxcL2xpbmVcXC9wcmVzZW5jZShcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUpPyQvLFxuICBsaW5lVGVsZXBob255OiAvcHJlc2VuY2VcXC9saW5lXFwvcHJlc2VuY2VcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUkLyxcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgbWVzc2FnZXMgZGVsaXZlcmVkIGJ5IHRoZSBzdWJzY3JpcHRvblxuICovXG5mdW5jdGlvbiBtZXNzYWdlSGFuZGxlcihtZXNzYWdlKSB7XG4gIC8vIGRldGVybWluZSB3aGljaCBldmVudHMgdGhlIG1lc3NhZ2UgZmFsbHMgdW5kZXJcbiAgY29uc3QgZXZlbnRzID0gW107XG4gIGlmIChmaWx0ZXJSZWdleC5tZXNzYWdlLnRlc3QobWVzc2FnZS5ldmVudCkpIHtcbiAgICBldmVudHMucHVzaCgnbWVzc2FnZScpO1xuICB9IGVsc2UgaWYgKGZpbHRlclJlZ2V4LmxpbmUudGVzdChtZXNzYWdlLmV2ZW50KSkge1xuICAgIGV2ZW50cy5wdXNoKCdsaW5lJyk7XG4gIH0gZWxzZSBpZiAoZmlsdGVyUmVnZXgubGluZVByZXNlbmNlLnRlc3QobWVzc2FnZS5ldmVudCkpIHtcbiAgICBldmVudHMucHVzaCgnbGluZVByZXNlbmNlJyk7XG4gICAgaWYgKGZpbHRlclJlZ2V4LmxpbmVUZWxlcGhvbnkudGVzdChtZXNzYWdlLmV2ZW50KSkgZXZlbnRzLnB1c2goJ2xpbmVUZWxlcGhvbnknKTtcbiAgfSBlbHNlIGlmIChmaWx0ZXJSZWdleC5wcmVzZW5jZS50ZXN0KG1lc3NhZ2UuZXZlbnQpKSB7XG4gICAgZXZlbnRzLnB1c2goJ3ByZXNlbmNlJyk7XG4gICAgaWYgKGZpbHRlclJlZ2V4LnRlbGVwaG9ueS50ZXN0KG1lc3NhZ2UuZXZlbnQpKSBldmVudHMucHVzaCgndGVsZXBob255Jyk7XG4gIH1cbiAgLy8gZGlzcGF0Y2ggdGhlIG1lc3NhZ2UgaW4gcmVkdXggbWFubmVyXG4gIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5ub3RpZmljYXRpb24sXG4gICAgZXZlbnRUeXBlczogZXZlbnRzLFxuICAgIHBheWxvYWQ6IG1lc3NhZ2UsXG4gIH0pO1xuICAvLyBlbWl0IHRoZSBtZXNzYWdlcyBhcyBldmVudHNcbiAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5ub3RpZmljYXRpb24sIHN1YnNjcmlwdGlvbkV2ZW50c1tldmVudF0sIG1lc3NhZ2UpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGNvbnN0IHBsYXRmb3JtID0gdGhpc1tzeW1ib2xzLnBsYXRmb3JtXTtcbiAgdGhpc1tzeW1ib2xzLnN1YnNjcmlwdGlvbl0gPSB0aGlzW3N5bWJvbHMuc2RrXS5jcmVhdGVTdWJzY3JpcHRpb24oKTtcbiAgY29uc3Qgb3duZXJJZCA9IHBsYXRmb3JtLmF1dGgoKS5kYXRhKCkub3duZXJfaWQ7XG4gIGxldCBjYWNoZUtleSA9IG51bGw7XG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNhY2hlS2V5ID0gYCR7dGhpcy5wcmVmaXh9LXN1Yi0ke293bmVySWR9YDtcbiAgICBjb25zdCBjYWNoZWRTdWJzY3JpcHRpb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZFN1YnNjcmlwdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5iYXNlLnNldFN1YnNjcmlwdGlvbihKU09OLnBhcnNlKGNhY2hlZFN1YnNjcmlwdGlvbikpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBkbyBub3RoaW5nICovXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICB0aGlzLmJhc2Uuc2V0RXZlbnRGaWx0ZXJzKHRoaXMuZmlsdGVycyk7XG5cbiAgdGhpcy5iYXNlLm9uKHRoaXMuYmFzZS5ldmVudHMubm90aWZpY2F0aW9uLCBtZXNzYWdlID0+IHtcbiAgICB0aGlzOjptZXNzYWdlSGFuZGxlcihtZXNzYWdlKTtcbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnJlbW92ZVN1Y2Nlc3MsICgpID0+IHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5ub3RTdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiBudWxsLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gIH0pO1xuICB0aGlzLmJhc2Uub24odGhpcy5iYXNlLmV2ZW50cy5yZW1vdmVFcnJvciwgKCkgPT4ge1xuICAgIC8vIFRPRE9cbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnJlbmV3U3VjY2VzcywgKCkgPT4ge1xuICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oY2FjaGVLZXksIEpTT04uc3RyaW5naWZ5KHRoaXMuYmFzZS5zdWJzY3JpcHRpb24oKSkpO1xuICAgIH1cbiAgICBjb25zdCBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5zdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiB0aGlzLmJhc2Uuc3Vic2NyaXB0aW9uKCksXG4gICAgfSk7XG4gICAgaWYgKG9sZFN0YXR1cyAhPT0gdGhpcy5zdGF0dXMpIHtcbiAgICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gICAgfVxuICB9KTtcbiAgdGhpcy5iYXNlLm9uKHRoaXMuYmFzZS5ldmVudHMucmVuZXdFcnJvciwgZXJyb3IgPT4ge1xuICAgIC8vIFRPRE8gaGFuZGxlIDQyOVxuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZVN0YXR1cyxcbiAgICAgIHN0YXR1czogc3Vic2NyaXB0aW9uU3RhdHVzLm5vdFN1YnNjcmliZWQsXG4gICAgICBzdWJzY3JpcHRpb246IG51bGwsXG4gICAgfSk7XG4gICAgdGhpczo6ZW1pdChzdWJzY3JpcHRpb25FdmVudFR5cGVzLnN0YXR1c0NoYW5nZWQsIHRoaXMuc3RhdHVzKTtcbiAgICB0aGlzLmJhc2UucmVzZXQoKS5zZXRFdmVudEZpbHRlcnModGhpcy5maWx0ZXJzKS5yZWdpc3RlcigpLmNhdGNoKGUgPT4geyB9KTtcbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnN1YnNjcmliZVN1Y2Nlc3MsICgpID0+IHtcbiAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGNhY2hlS2V5LCBKU09OLnN0cmluZ2lmeSh0aGlzLmJhc2Uuc3Vic2NyaXB0aW9uKCkpKTtcbiAgICB9XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudXBkYXRlU3RhdHVzLFxuICAgICAgc3RhdHVzOiBzdWJzY3JpcHRpb25TdGF0dXMuc3Vic2NyaWJlZCxcbiAgICAgIHN1YnNjcmlwdGlvbjogdGhpcy5iYXNlLnN1YnNjcmlwdGlvbigpLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gIH0pO1xuICB0aGlzLmJhc2Uub24odGhpcy5iYXNlLmV2ZW50cy5zdWJzY3JpYmVFcnJvciwgZXJyb3IgPT4ge1xuICAgIC8vIFRPRE9cbiAgICAvLyBoYW5kbGUgNDI5XG4gICAgLy8gaGFuZGxlIHN1YnNjcmlwdGlvbiBsaW1pdFxuICB9KTtcblxuICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgIHRoaXMuYmFzZS5yZWdpc3RlcigpLmNhdGNoKCgpID0+IHsgLyogZG8gbm90aGluZyAqLyB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJzY3JpcHRpb24gZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBvcHRpb25zLnJlZ2lzdGVyU3RvcmVIYW5kbGVyKHN0b3JlID0+IHtcbiAgICAgICAgICAvLyBzZXQgc3RvcmUgdG8gc2VsZiBmaXJzdFxuICAgICAgICAgIGhhbmRsZXIoc3RvcmUpO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHN0b3JlIHdpdGggY2FjaGVkRmlsdGVyc1xuICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZUZpbHRlcnMsXG4gICAgICAgICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzW3N5bWJvbHMuZmlsdGVyQ2FjaGVdID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYWN0aW9uczogc3Vic2NyaXB0aW9uQWN0aW9ucyxcbiAgICB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGF1dGgsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHNkayxcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzW3N5bWJvbHMuYXV0aF0gPSBhdXRoO1xuICAgIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzW3N5bWJvbHMuc2RrXSA9IHNkaztcbiAgICB0aGlzW3N5bWJvbHMuc3Vic2NyaXB0aW9uXSA9IG51bGw7XG5cbiAgICAvLyBjYWNoZXMgZmlsdGVycyBiZWZvcmUgcmVkdXggc3RvcmUgaXMgY3JlYXRlZFxuICAgIHRoaXNbc3ltYm9scy5maWx0ZXJDYWNoZV0gPSBbXTtcblxuICAgIGF1dGgub24oYXV0aC5ldmVudHMubG9nZ2VkSW4sICgpID0+IHtcbiAgICAgIHRoaXM6OmluaXQoKTtcbiAgICB9KTtcblxuICAgIGF1dGgub24oYXV0aC5ldmVudHMubG9nZ2VkT3V0LCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5iYXNlKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dpblN1Y2Nlc3MsICgpID0+IHtcbiAgICAvLyAgIHRoaXM6OmluaXQoKTtcbiAgICAvLyB9KTtcbiAgICAvLyBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9nb3V0U3VjY2VzcywgYXN5bmMgKCkgPT4ge1xuICAgIC8vICAgaWYgKHRoaXMuYmFzZSkge1xuICAgIC8vICAgICBhd2FpdCB0aGlzLnJlc2V0KCk7XG4gICAgLy8gICB9XG4gICAgLy8gICB0aGlzW3N5bWJvbHMuc3Vic2NyaXB0aW9uXSA9IG51bGw7XG4gICAgLy8gfSk7XG5cbiAgICBhdXRoLmFkZEJlZm9yZUxvZ291dEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXNldCgpO1xuICAgIH0pO1xuXG4gICAgLy8gKGFzeW5jICgpID0+IHtcbiAgICAvLyAgIGlmIChhd2FpdCBwbGF0Zm9ybS5sb2dnZWRJbigpKSB7XG4gICAgLy8gICAgIHRoaXM6OmluaXQoKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9KSgpO1xuICB9XG5cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIGdldFN1YnNjcmlwdGlvblJlZHVjZXIodGhpcy5wcmVmaXgpO1xuICB9XG5cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5zdGF0dXM7XG4gIH1cblxuICBnZXQgZmlsdGVycygpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLmZpbHRlckNhY2hlXSB8fCB0aGlzLnN0YXRlLmZpbHRlcnM7XG4gIH1cblxuICBnZXQgYmFzZSgpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLnN1YnNjcmlwdGlvbl07XG4gIH1cblxuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBzdWJzY3JpcHRpb25FdmVudHM7XG4gIH1cblxuICBnZXQgZXZlbnRUeXBlcygpIHtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uRXZlbnRUeXBlcztcbiAgfVxuXG4gIHN1YnNjcmliZShldmVudCkge1xuICAgIC8vIFRPRE8gbm9ybWFsaXplZCBlcnJvclxuICAgIGlmICghc3Vic2NyaXB0aW9uRXZlbnRzOjpFbnVtLmhhc1ZhbHVlKGV2ZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmVudCBpcyBub3QgcmVjb2duaXplZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbHRlcnMuaW5kZXhPZihldmVudCkgPT09IC0xKSB7XG4gICAgICBjb25zdCBuZXdGaWx0ZXJzID0gdGhpcy5maWx0ZXJzLnNsaWNlKCk7XG4gICAgICBuZXdGaWx0ZXJzLnB1c2goZXZlbnQpO1xuICAgICAgaWYgKHRoaXMuYmFzZSkge1xuICAgICAgICB0aGlzLmJhc2Uuc2V0RXZlbnRGaWx0ZXJzKG5ld0ZpbHRlcnMpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudXBkYXRlRmlsdGVycyxcbiAgICAgICAgICBmaWx0ZXJzOiBuZXdGaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYXNlLnJlZ2lzdGVyKCkuY2F0Y2goKCkgPT4geyAvKiBkbyBub3RoaW5nICovIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tzeW1ib2xzLmZpbHRlckNhY2hlXSA9IG5ld0ZpbHRlcnM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdW5zdWJzY3JpYmUoZXZlbnQpIHtcbiAgICAvLyBUT0RPIG5vcm1hbGl6ZWQgZXJyb3JcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkV2ZW50czo6RW51bS5oYXNWYWx1ZShldmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXZlbnQgaXMgbm90IHJlY29nbml6ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgaWR4ID0gdGhpcy5maWx0ZXJzLmluZGV4T2YoZXZlbnQpO1xuICAgIGlmICh0aGlzLmZpbHRlcnMuaW5kZXhPZihldmVudCkgPiAtMSkge1xuICAgICAgY29uc3QgbmV3RmlsdGVycyA9IHRoaXMuZmlsdGVycy5zbGljZSgpO1xuICAgICAgbmV3RmlsdGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIGlmICh0aGlzLmJhc2UpIHtcbiAgICAgICAgdGhpcy5iYXNlLnNldEV2ZW50RmlsdGVycyhuZXdGaWx0ZXJzKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZUZpbHRlcnMsXG4gICAgICAgICAgZmlsdGVyczogbmV3RmlsdGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdGaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYmFzZS5yZWdpc3RlcigpLmNhdGNoKCgpID0+IHsgLyogZG8gbm90aGluZyAqLyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJhc2UucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbc3ltYm9scy5maWx0ZXJDYWNoZV0gPSBuZXdGaWx0ZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlc2V0KCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5iYXNlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gc3Vic2NyaXB0aW9uU3RhdHVzLnN1YnNjcmliZWQpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmJhc2UucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5iYXNlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIHRoaXNbc3ltYm9scy5zdWJzY3JpcHRpb25dID0gbnVsbDtcbiAgICBjb25zdCBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5ub3RTdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiBudWxsLFxuICAgIH0pO1xuICAgIGlmIChvbGRTdGF0dXMgIT09IHRoaXMuc3RhdHVzKSB7XG4gICAgICB0aGlzOjplbWl0KHN1YnNjcmlwdGlvbkV2ZW50VHlwZXMuc3RhdHVzQ2hhbmdlZCwgdGhpcy5zdGF0dXMpO1xuICAgIH1cbiAgfVxuXG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL2luZGV4LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCB7IEFjdGlvbk1hcCB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgQWN0aW9uTWFwKFtcbiAgJ3VwZGF0ZUZpbHRlcnMnLFxuICAnbm90aWZpY2F0aW9uJyxcblxuICAndXBkYXRlU3RhdHVzJyxcblxuXSwgJ3N1YnNjcmlwdGlvbicpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5pbXBvcnQgc3Vic2NyaXB0aW9uQWN0aW9ucyBmcm9tICcuL3N1YnNjcmlwdGlvbi1hY3Rpb25zJztcbmltcG9ydCB7IHN1YnNjcmlwdGlvbkV2ZW50cyB9IGZyb20gJy4vc3Vic2NyaXB0aW9uLWV2ZW50cyc7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgY2FjaGVLZXk6IG51bGwsXG4gIGZpbHRlcnM6IFtdLFxuICBzdGF0dXM6IHN1YnNjcmlwdGlvbkV2ZW50cy5wZW5kaW5nLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uUmVkdWNlcihwcmVmaXgpIHtcbiAgY29uc3QgYWN0aW9ucyA9IHByZWZpeEFjdGlvbnMoc3Vic2NyaXB0aW9uQWN0aW9ucywgcHJlZml4KTtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgY2FzZSBhY3Rpb25zLnVwZGF0ZVN0YXR1czpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdHVzOiBhY3Rpb24uc3RhdHVzLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiBhY3Rpb25zLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICBjYXNlIGFjdGlvbnMudXBkYXRlRmlsdGVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVyczogYWN0aW9uLmZpbHRlcnMuc2xpY2UoKSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgc3Vic2NyaXB0aW9uU3RhdHVzIGZyb20gJy4vc3Vic2NyaXB0aW9uLXN0YXR1cyc7XG5cblxuY29uc3QgZXZlbnREZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vbWVzc2FnZS1zdG9yZScsXG4gIHByZXNlbmNlOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UnLFxuICB0ZWxlcGhvbnk6ICcvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vfi9wcmVzZW5jZT9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUnLFxuICBsaW5lOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UvbGluZScsXG4gIGxpbmVQcmVzZW5jZTpcbiAgICAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UvbGluZS9wcmVzZW5jZScsXG4gIGxpbmVUZWxlcGhvbnk6XG4gICAgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC9+L2V4dGVuc2lvbi9+L3ByZXNlbmNlL2xpbmUvcHJlc2VuY2U/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlJyxcbiAgLi4uc3Vic2NyaXB0aW9uU3RhdHVzLFxufTtcblxuZXhwb3J0IGNvbnN0IHN1YnNjcmlwdGlvbkV2ZW50cyA9IG5ldyBFbnVtKGV2ZW50RGVmaW5pdGlvbik7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb24gPSB7XG4gIG5vdGlmaWNhdGlvbjogJ05PVElGSUNBVElPTicsXG4gIHN0YXR1c0NoYW5nZWQ6ICdTVEFUVVNfQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3Qgc3Vic2NyaXB0aW9uRXZlbnRUeXBlcyA9IG5ldyBFbnVtKGV2ZW50VHlwZURlZmluaXRpb24pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLWV2ZW50cy5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgcGVuZGluZzogJ1BFTkRJTkcnLFxuICBzdWJzY3JpYmVkOiAnU1VCU0NSSUJFRCcsXG4gIG5vdFN1YnNjcmliZWQ6ICdOT1RfU1VCU0NSSUJFRCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgRW51bShkZWZpbml0aW9uKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1zdGF0dXMuanNcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4uLy4uL2xpYi9zeW1ib2wtbWFwJztcbmltcG9ydCB7IGV4dHJhY3REYXRhLCBmZXRjaExpc3QsIGVtaXQgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHVzZXJBY3Rpb25zIGZyb20gJy4vdXNlci1hY3Rpb25zJztcbmltcG9ydCBnZXRVc2VyUmVkdWNlciBmcm9tICcuL3VzZXItcmVkdWNlcic7XG5pbXBvcnQgeyB1c2VyRXZlbnRzLCB1c2VyRXZlbnRUeXBlcyB9IGZyb20gJy4vdXNlci1ldmVudHMnO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdhcGknLFxuICAncGxhdGZvcm0nLFxuICAnc2V0dGluZ3MnLFxuXSk7XG5cbi8vIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbi8vICAgdGVzdDogdHJ1ZSxcbi8vIH07XG5cbi8vIGZ1bmN0aW9uIGdldFVzZXJTZXR0aW5nc1JlZHVjZXIocHJlZml4KSB7XG4vLyAgIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuLy8gICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcbi8vICAgICBpZiAoIWFjdGlvbikgcmV0dXJuIHN0YXRlO1xuLy8gICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbi8vICAgICAgIGRlZmF1bHQ6XG4vLyAgICAgICAgIHJldHVybiBzdGF0ZTtcbi8vICAgICB9XG4vLyAgIH07XG4vLyB9XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxvYWRGdW5jdGlvbiAtIGFzeW5jIGxvYWRlciBmdW5jdGlvbiByZXR1cm5pbmcgYSBwcm9taXNlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGRlc2NyaXB0aW9uIEdlbmVyaWMgZGF0YSBsb2FkaW5nIGxvZ2ljIHdpdGggZXZlbnRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWREYXRhKGRhdGFUeXBlLCBsb2FkRnVuY3Rpb24pIHtcbiAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1gXSxcbiAgfSk7XG4gIHRoaXMuZW1pdCh1c2VyRXZlbnRzW2Bsb2FkJHtkYXRhVHlwZX1gXSk7XG4gIHRyeSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXM6OmxvYWRGdW5jdGlvbigpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1TdWNjZXNzYF0sXG4gICAgICBwYXlsb2FkLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQodXNlckV2ZW50VHlwZXMudXNlckluZm9DaGFuZ2VkLCB1c2VyRXZlbnRzW2Bsb2FkJHtkYXRhVHlwZX1TdWNjZXNzYF0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1GYWlsZWRgXSxcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQodXNlckV2ZW50c1tgbG9hZCR7ZGF0YVR5cGV9RmFpbGVkYF0pO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59XG4gKiBAZGVzY3JpcHRpb24gRmV0Y2ggYWNjb3VudCBpbmZvIGFuZCBleHRyYWN0IHRoZSBkYXRhXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RBY2NvdW50SW5mbygpIHtcbiAgcmV0dXJuIGV4dHJhY3REYXRhKGF3YWl0IHRoaXNbc3ltYm9scy5hcGldLmFjY291bnQoKS5sb2FkQWNjb3VudCgpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRBY2NvdW50SW5mbygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdBY2NvdW50SW5mbycsIGV4dHJhY3RBY2NvdW50SW5mbyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RFeHRlbnNpb25JbmZvKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpc1tzeW1ib2xzLmFwaV0uZXh0ZW5zaW9uKCkubG9hZEV4dGVuc2lvbkluZm8oKSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkRXh0ZW5zaW9uSW5mbygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdFeHRlbnNpb25JbmZvJywgZXh0cmFjdEV4dGVuc2lvbkluZm8pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0RGlhbGluZ1BsYW5zKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpczo6ZmV0Y2hMaXN0KG9wdGlvbnMgPT4gKFxuICAgIHRoaXNbc3ltYm9scy5hcGldLmFjY291bnQoKS5saXN0RGlhbGluZ1BsYW5zKG9wdGlvbnMpXG4gICkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWREaWFsaW5nUGxhbnMoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzOjpsb2FkRGF0YSgnRGlhbGluZ1BsYW5zJywgZXh0cmFjdERpYWxpbmdQbGFucyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RQaG9uZU51bWJlcnMoKSB7XG4gIHJldHVybiBleHRyYWN0RGF0YShhd2FpdCB0aGlzOjpmZXRjaExpc3Qob3B0aW9ucyA9PiAoXG4gICAgdGhpc1tzeW1ib2xzLmFwaV0uZXh0ZW5zaW9uKCkubGlzdEV4dGVuc2lvblBob25lTnVtYmVycyhvcHRpb25zKVxuICApKSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkUGhvbmVOdW1iZXJzKCkge1xuICByZXR1cm4gYXdhaXQgdGhpczo6bG9hZERhdGEoJ1Bob25lTnVtYmVycycsIGV4dHJhY3RQaG9uZU51bWJlcnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0Rm9yd2FyZGluZ051bWJlcnMoKSB7XG4gIHJldHVybiBleHRyYWN0RGF0YShhd2FpdCB0aGlzOjpmZXRjaExpc3Qob3B0aW9ucyA9PiAoXG4gICAgdGhpc1tzeW1ib2xzLmFwaV0uZm9yd2FyZGluZ051bWJlcnMoKS5saXN0RXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlcnMob3B0aW9ucylcbiAgKSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEZvcndhcmRpbmdOdW1iZXJzKCkge1xuICByZXR1cm4gYXdhaXQgdGhpczo6bG9hZERhdGEoJ0ZvcndhcmRpbmdOdW1iZXJzJywgZXh0cmFjdEZvcndhcmRpbmdOdW1iZXJzKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEJsb2NrZWROdW1iZXJzKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpczo6ZmV0Y2hMaXN0KG9wdGlvbnMgPT4gKFxuICAgIHRoaXNbc3ltYm9scy5hcGldLmJsb2NrZWROdW1iZXJzKCkubGlzdEJsb2NrZWROdW1iZXJzKG9wdGlvbnMpXG4gICkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRCbG9ja2VkTnVtYmVycygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdCbG9ja2VkTnVtYmVycycsIGV4dHJhY3RCbG9ja2VkTnVtYmVycyk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkSW5mbygpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzOjpsb2FkQWNjb3VudEluZm8oKSxcbiAgICAgIHRoaXM6OmxvYWRFeHRlbnNpb25JbmZvKCksXG4gICAgICB0aGlzOjpsb2FkRGlhbGluZ1BsYW5zKCksXG4gICAgICB0aGlzOjpsb2FkUGhvbmVOdW1iZXJzKCksXG4gICAgICB0aGlzOjpsb2FkRm9yd2FyZGluZ051bWJlcnMoKSxcbiAgICAgIHRoaXM6OmxvYWRCbG9ja2VkTnVtYmVycygpLFxuICAgIF0pO1xuICAgIC8vIHRoaXMuZW1pdCh1c2VyRXZlbnRzLnVzZXJJbmZvTG9hZGVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE8gc2VuZCBlcnJvciBvdXRcbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBjbGFzcyBVc2VyXG4gKiBAZXh0ZW5kcyBSY01vZHVsZVxuICogQGRlZmF1bHRcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlciBleHRlbmRzIFJjTW9kdWxlIHtcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhY3Rpb25zOiB1c2VyQWN0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhcGksXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHNldHRpbmdzLFxuICAgIH0gPSBvcHRpb25zO1xuICAgIHRoaXNbc3ltYm9scy5hcGldID0gYXBpO1xuICAgIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzW3N5bWJvbHMuc2V0dGluZ3NdID0gc2V0dGluZ3M7XG5cbiAgICAvLyBzZXR0aW5ncy5yZWdpc3RlclJlZHVjZXIoJ3VzZXInLCBnZXRVc2VyU2V0dGluZ3NSZWR1Y2VyKCkpO1xuXG4gICAgLy8gbG9hZCBpbmZvIG9uIGxvZ2luXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luU3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpczo6bG9hZEluZm8oKTtcbiAgICB9KTtcbiAgICAvLyB1bmxvYWQgaW5mbyBvbiBsb2dvdXRcbiAgICBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9nb3V0U3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jbGVhclVzZXJJbmZvLFxuICAgICAgfSk7XG4gICAgICAvLyB0aGlzLmVtaXQodXNlckV2ZW50cy51c2VySW5mb0NsZWFyZWQpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBsb2FkIGluZm8gaWYgYWxyZWFkeSBsb2dnZWQgaW5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGF3YWl0IHBsYXRmb3JtLmxvZ2dlZEluKCkpIHtcbiAgICAgICAgYXdhaXQgdGhpczo6bG9hZEluZm8oKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogVE9ETzpcbiAgICAgKiAgIDEuIERpYWxpbmcgUGxhbiBDaGVja2luZ1xuICAgICAqL1xuICB9XG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiBnZXRVc2VyUmVkdWNlcih0aGlzLnByZWZpeCk7XG4gIH1cblxuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiB1c2VyRXZlbnRzO1xuICB9XG5cbiAgZ2V0IGV2ZW50VHlwZXMoKSB7XG4gICAgcmV0dXJuIHVzZXJFdmVudFR5cGVzO1xuICB9XG5cbiAgZ2V0IGRpcmVjdE51bWJlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGhvbmVOdW1iZXJzLmZpbHRlcihuID0+IG4udXNhZ2VUeXBlID09PSAnRGlyZWN0TnVtYmVyJyk7XG4gIH1cblxuICBnZXQgbWFpbkNvbXBhbnlOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGhvbmVOdW1iZXJzLmZpbmQobiA9PiBuLnVzYWdlVHlwZSA9PT0gJ01haW5Db21wYW55TnVtYmVyJyk7XG4gIH1cblxuICBnZXQgZGlhbGluZ1BsYW5zKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRpYWxpbmdQbGFucztcbiAgfVxuXG4gIGdldCBleHRlbnNpb25OdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXh0ZW5zaW9uSW5mby5leHRlbnNpb25OdW1iZXI7XG4gIH1cblxuICBnZXQgc21zTnVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5waG9uZU51bWJlcnMuZmlsdGVyKG4gPT4gbi5mZWF0dXJlcy5pbmRleE9mKCdTbXNTZW5kZXInKSA+IC0xKTtcbiAgfVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3VzZXIvaW5kZXguanNcbiAqKi8iLCJpbXBvcnQgeyBBY3Rpb25NYXAgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFjdGlvbk1hcChbXG4gICdjbGVhclVzZXJJbmZvJyxcblxuICAnbG9hZEFjY291bnRJbmZvJyxcbiAgJ2xvYWRBY2NvdW50SW5mb1N1Y2Nlc3MnLFxuICAnbG9hZEFjY291bnRJbmZvRmFpbGVkJyxcblxuICAnbG9hZEV4dGVuc2lvbkluZm8nLFxuICAnbG9hZEV4dGVuc2lvbkluZm9TdWNjZXNzJyxcbiAgJ2xvYWRFeHRlbnNpb25JbmZvRmFpbGVkJyxcblxuICAnbG9hZERpYWxpbmdQbGFucycsXG4gICdsb2FkRGlhbGluZ1BsYW5zU3VjY2VzcycsXG4gICdsb2FkRGlhbGluZ1BsYW5zRmFpbGVkJyxcblxuICAnbG9hZFBob25lTnVtYmVycycsXG4gICdsb2FkUGhvbmVOdW1iZXJzU3VjY2VzcycsXG4gICdsb2FkUGhvbmVOdW1iZXJzRmFpbGVkJyxcblxuICAnbG9hZEZvcndhcmRpbmdOdW1iZXJzJyxcbiAgJ2xvYWRGb3J3YXJkaW5nTnVtYmVyc1N1Y2Nlc3MnLFxuICAnbG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkJyxcblxuICAnbG9hZEJsb2NrZWROdW1iZXJzJyxcbiAgJ2xvYWRCbG9ja2VkTnVtYmVyc1N1Y2Nlc3MnLFxuICAnbG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkJyxcblxuXSwgJ3VzZXInKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvdXNlci91c2VyLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5pbXBvcnQgdXNlckFjdGlvbnMgZnJvbSAnLi91c2VyLWFjdGlvbnMnO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGFjY291bnRJbmZvOiBudWxsLFxuICBhY2NvdW50SW5mb0xvYWRpbmc6IGZhbHNlLFxuICBhY2NvdW50SW5mb0Vycm9yOiBudWxsLFxuXG4gIGV4dGVuc2lvbkluZm86IG51bGwsXG4gIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiBmYWxzZSxcbiAgZXh0ZW5zaW9uSW5mb0Vycm9yOiBudWxsLFxuXG4gIGRpYWxpbmdQbGFuczogW10sXG4gIGRpYWxpbmdQbGFuc0xvYWRpbmc6IGZhbHNlLFxuICBkaWFsaW5nUGxhbnNFcnJvcjogbnVsbCxcblxuICBwaG9uZU51bWJlcnM6IFtdLFxuICBwaG9uZU51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgcGhvbmVOdW1iZXJzRXJyb3I6IG51bGwsXG5cbiAgZm9yd2FyZGluZ051bWJlcnM6IFtdLFxuICBmb3J3YXJkaW5nTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICBmb3J3YXJkaW5nTnVtYmVyc0Vycm9yOiBudWxsLFxuXG4gIGJsb2NrZWROdW1iZXJzOiBbXSxcbiAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgYmxvY2tlZE51bWJlcnNFcnJvcjogbnVsbCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVzZXJSZWR1Y2VyKHByZWZpeCkge1xuICBjb25zdCBhY3Rpb25zID0gcHJlZml4QWN0aW9ucyh1c2VyQWN0aW9ucywgcHJlZml4KTtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG4gICAgICAvLyBhY2NvdW50IGluZm9cbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkQWNjb3VudEluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFjY291bnRJbmZvTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRBY2NvdW50SW5mb1N1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFjY291bnRJbmZvOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICAgIGFjY291bnRJbmZvTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBhY2NvdW50SW5mb0Vycm9yOiBudWxsLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEFjY291bnRJbmZvRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY2NvdW50SW5mb0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYWNjb3VudEluZm9FcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGV4dGVuc2lvbiBpbmZvXG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEV4dGVuc2lvbkluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEV4dGVuc2lvbkluZm9TdWNjZXNzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHRlbnNpb25JbmZvOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9FcnJvcjogbnVsbCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRFeHRlbnNpb25JbmZvRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHRlbnNpb25JbmZvTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBleHRlbnNpb25JbmZvRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICAvLyBkaWFsaW5nIHBsYW5zXG4gICAgICBjYXNlIGFjdGlvbnMubG9hZERpYWxpbmdQbGFuczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGlhbGluZ1BsYW5zTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWREaWFsaW5nUGxhbnNTdWNjZXNzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkaWFsaW5nUGxhbnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGRpYWxpbmdQbGFuczogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgYWN0aW9uLmxvYWREaWFsaW5nUGxhbnNGYWlsZWQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRpYWxpbmdQbGFuc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZGlhbGluZ1BsYW5zRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG5cbiAgICAgIC8vIHBob25lIG51bWJlcnNcbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkUGhvbmVOdW1iZXJzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwaG9uZU51bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZFBob25lTnVtYmVyc1N1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBob25lTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZFBob25lTnVtYmVyc0ZhaWxlZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcGhvbmVOdW1iZXJzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBwaG9uZU51bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGZvcndhcmRpbmcgbnVtYmVyc1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRGb3J3YXJkaW5nTnVtYmVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEZvcndhcmRpbmdOdW1iZXJzU3VjY2VzczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcndhcmRpbmdOdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmb3J3YXJkaW5nTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGJsb2NrZWQgbnVtYmVyc1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRCbG9ja2VkTnVtYmVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEJsb2NrZWROdW1iZXJzU3VjY2VzczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGJsb2NrZWROdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBibG9ja2VkTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgYWN0aW9uLmNsZWFyVXNlckluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvdXNlci91c2VyLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5cbmNvbnN0IGV2ZW50RGVmaW5pdGlvbnMgPSB7XG4gIHVzZXJJbmZvTG9hZGVkOiAnVVNFUl9JTkZPX0xPQURFRCcsXG4gIHVzZXJJbmZvQ2xlYXJlZDogJ1VTRVJfSU5GT19DTEVBUkVEJyxcblxuICBsb2FkQWNjb3VudEluZm86ICdMT0FEX0FDQ09VTlRfSU5GTycsXG4gIGxvYWRBY2NvdW50SW5mb1N1Y2Nlc3M6ICdMT0FEX0FDQ09VTlRfSU5GT19TVUNDRVNTJyxcbiAgbG9hZEFjY291bnRJbmZvRmFpbGVkOiAnTE9BRF9BQ0NPVU5UX0lORk9fRkFJTEVEJyxcblxuICBsb2FkRXh0ZW5zaW9uSW5mbzogJ0xPQURfRVhURU5TSU9OX0lORk8nLFxuICBsb2FkRXh0ZW5zaW9uSW5mb1N1Y2Nlc3M6ICdMT0FEX0VYVEVOU0lPTl9JTkZPX1NVQ0NFU1MnLFxuICBsb2FkRXh0ZW5zaW9uSW5mb0ZhaWxlZDogJ0xPQURfRVhURU5TSU9OX0lORk9fRkFJTEVEJyxcblxuICBsb2FkRGlhbGluZ1BsYW5zOiAnTE9BRF9ESUFMSU5HX1BMQU5TJyxcbiAgbG9hZERpYWxpbmdQbGFuc1N1Y2Nlc3M6ICdMT0FEX0RJQUxJTkdfUExBTlNfU1VDQ0VTUycsXG4gIGxvYWREaWFsaW5nUGxhbnNGYWlsZWQ6ICdMT0FEX0RJQUxJTkdfUExBTlNfRkFJTEVEJyxcblxuICBsb2FkUGhvbmVOdW1iZXJzOiAnTE9BRF9QSE9ORV9OVU1CRVJTJyxcbiAgbG9hZFBob25lTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX1BIT05FX05VTUJFUlNfU1VDQ0VTUycsXG4gIGxvYWRQaG9uZU51bWJlcnNGYWlsZWQ6ICdMT0FEX1BIT05FX05VTUJFUlNfRkFJTEVEJyxcblxuICBsb2FkRm9yd2FyZGluZ051bWJlcnM6ICdMT0FEX0ZPUldBUkRJTkdfTlVNQkVSUycsXG4gIGxvYWRGb3J3YXJkaW5nTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX0ZPUldBUkRJTkdfTlVNQkVSU19TVUNDRVNTJyxcbiAgbG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkOiAnTE9BRF9GT1JXQVJESU5HX05VTUJFUlNfRkFJTEVEJyxcblxuICBsb2FkQmxvY2tlZE51bWJlcnM6ICdMT0FEX0JMT0NLRURfTlVNQkVSUycsXG4gIGxvYWRCbG9ja2VkTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX0JMT0NLRURfTlVNQkVSU19TVUNDRVNTJyxcbiAgbG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkOiAnTE9BRF9CTE9DS0VEX05VTUJFUlNfRkFJTEVEJyxcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VyRXZlbnRzID0gbmV3IEVudW0oZXZlbnREZWZpbml0aW9ucyk7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb25zID0ge1xuICB1c2VySW5mb0NoYW5nZWQ6ICdVU0VSX0lORk9fQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3QgdXNlckV2ZW50VHlwZXMgPSBuZXcgRW51bShldmVudFR5cGVEZWZpbml0aW9ucyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3VzZXIvdXNlci1ldmVudHMuanNcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4uLy4uL2xpYi9zeW1ib2wtbWFwJztcbmltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcbmltcG9ydCB3ZWJwaG9uZUFjdGlvbnMgZnJvbSAnLi93ZWJwaG9uZS1hY3Rpb25zJztcbmltcG9ydCBjYWxsQWN0aW9ucyBmcm9tICcuL2NhbGwtYWN0aW9ucyc7XG5pbXBvcnQgZ2V0UmVkdWNlciBmcm9tICcuL3dlYnBob25lLXJlZHVjZXInO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSAnZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgUmluZ0NlbnRyYWxXZWJwaG9uZSBmcm9tICdyaW5nY2VudHJhbC13ZWItcGhvbmUnO1xuaW1wb3J0IHdlYnBob25lU3RhdHVzIGZyb20gJy4uLy4uL2VudW1zL3dlYnBob25lLXN0YXR1cyc7XG5pbXBvcnQgY2FsbFN0YXR1cyBmcm9tICcuLi8uLi9lbnVtcy9jYWxsLXN0YXR1cyc7XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ2FwaScsXG4gICdwbGF0Zm9ybScsXG4gICdlbWl0dGVyJyxcbiAgJ3NldHRpbmdzJyxcbiAgJ3Bob25lSW5zdGFuY2UnLFxuXSk7XG5cbmNvbnN0IEVOVU1TID0gbmV3IEVudW0oe1xuICB3ZWJwaG9uZVN0YXR1cyxcbiAgY2FsbFN0YXR1cyxcbn0pO1xuXG5hc3luYyBmdW5jdGlvbiBpbml0UGhvbmVJbnN0YW5jZSgpIHtcbiAgY29uc3QgaW5mbyA9IGF3YWl0IHRoaXNbc3ltYm9scy5wbGF0Zm9ybV1cbiAgICAucG9zdCgnL2NsaWVudC1pbmZvL3NpcC1wcm92aXNpb24nLCB7XG4gICAgICBzaXBJbmZvOiBbeyB0cmFuc3BvcnQ6ICdXU1MnIH1dLFxuICAgIH0pXG4gICAgLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpO1xuICByZXR1cm4gbmV3IFJpbmdDZW50cmFsV2VicGhvbmUoaW5mbywge1xuICAgIGxvZ0xldmVsOiAwLFxuICAgIGF1ZGlvSGVscGVyOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICB9LFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVjb3JkKGZsYWcgPSB0cnVlKSB7XG4gIGlmICghZmxhZykge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uc3RvcFJlY29yZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMuc3RvcFJlY29yZCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi5zdGFydFJlY29yZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMucmVjb3JkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBtdXRlKGZsYWcgPSB0cnVlKSB7XG4gIGlmICghZmxhZykge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24udW5tdXRlKCk7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICB0eXBlOiBjYWxsQWN0aW9ucy51bm11dGUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24ubXV0ZSgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMubXV0ZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaG9sZChmbGFnID0gdHJ1ZSkge1xuICBpZiAoIWZsYWcpIHtcbiAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnVuaG9sZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMudW5ob2xkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLmhvbGQoKTtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmhvbGQsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhcmsoKSB7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24ucGFyaygpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLnBhcmssXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zZmVyKG51bWJlcikge1xuICB0aGlzLmNoZWNrU2Vzc2lvbigpO1xuICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnRyYW5zZmVyKG51bWJlcik7XG4gIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgIG9wZXJhdGlvbjoge1xuICAgICAgdHlwZTogY2FsbEFjdGlvbnMudHJhbnNmZXIsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZsaXAobnVtYmVyKSB7XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uZmxpcChudW1iZXIpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmZsaXAsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGR0bWYobnVtYmVyKSB7XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uZHRtZihudW1iZXIpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmR0bWYsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9wZXJhdGlvbnMobmFtZSwgLi4uYXJncykge1xuICBjb25zdCBhY3Rpb25zID0geyByZWNvcmQsIG11dGUsIGhvbGQsIHBhcmssIHRyYW5zZmVyLCBmbGlwLCBkdG1mIH07XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgYWN0aW9uc1tuYW1lXS5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMuZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICAvLyBUT0RPOiBuZWVkZWQ/XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2VicGhvbmUgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYWN0aW9uczogd2VicGhvbmVBY3Rpb25zLFxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFwaSxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgc2V0dGluZ3MsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpc1tzeW1ib2xzLmFwaV0gPSBhcGk7XG4gICAgdGhpc1tzeW1ib2xzLnBsYXRmb3JtXSA9IHBsYXRmb3JtO1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXSA9IG5ldyBFbWl0dGVyKCk7XG4gICAgdGhpc1tzeW1ib2xzLnNldHRpbmdzXSA9IHNldHRpbmdzO1xuXG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICAgIC8vIFRPRE86IGNvbW1lbnRlZCBvdXQgdW50aWwgc2V0dGluZyBtb2R1bGUgY29tcGxldGVkXG4gICAgLy8gc2V0dGluZ3MucmVnaXN0ZXJSZWR1Y2VyKCd3ZWJwaG9uZScsIGdldFdlYnBob25lUmVkdWNlcigpKVxuXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luU3VjY2VzcywgYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpc1tzeW1ib2xzLnBob25lSW5zdGFuY2VdID0gYXdhaXQgdGhpczo6aW5pdFBob25lSW5zdGFuY2UoKTtcbiAgICAgIHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQub24oJ3JlZ2lzdGVyZWQnLCAoKSA9PiB7XG4gICAgICAgIC8vIHNpcCB3aWxsIGZpcmUgbXVsdGlwbGUgcmVnaXN0ZXJlZCBldmVudHMsIG9ubHkgZGlzcGF0Y2ggb25lIHJlZ2lzdGVyIGFjdGlvbiB0byBzdGF0ZS5cbiAgICAgICAgLy8gVE9ETzogaXMgdGhpcyBpc1JlZ2lzdGVyZWQgc3RhdGUgbmVlZGVkIHRvIGJlIHN0b3JlIGFzIGluc3RhbmNlIHZhcmlhYmxlXG4gICAgICAgIC8vICAgICAgIG9yIGp1c3QgY2hlY2sgc3RvcmUgc3RhdGVcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVnaXN0ZXJlZCkge1xuICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnJlZ2lzdGVyU3VjY2VzcyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVnaXN0ZXJlZCA9IHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQuaXNSZWdpc3RlcmVkKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQub24oJ3VucmVnaXN0ZXJlZCcsICgpID0+IHtcbiAgICAgICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50LmlzUmVnaXN0ZXJlZCgpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudW5yZWdpc3RlcixcbiAgICAgICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmNsZWFyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50Lm9uKCdyZWdpc3RyYXRpb25GYWlsZWQnLCAoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnJlZ2lzdGVyRXJyb3IsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50Lm9uKCdpbnZpdGUnLCAoc2Vzc2lvbikgPT4ge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5saXN0ZW5TZXNzaW9uRXZlbnRzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNlc3Npb24pO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbEluY29taW5nLFxuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHJlbW90ZUlkZW50aXR5OiBzZXNzaW9uLnJlbW90ZUlkZW50aXR5LFxuICAgICAgICAgICAgbG9jYWxJZGVudGl0eTogc2Vzc2lvbi5sb2NhbElkZW50aXR5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZ2V0UmVkdWNlcih0aGlzLnByZWZpeCk7XG4gIH1cblxuICBnZXQgZW51bXMoKSB7XG4gICAgcmV0dXJuIEVOVU1TO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBwaG9uZSBjYWxsLCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGluIHJlZ2lzdGVyU3VjY2VzcyBzdGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9OdW1iZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tTnVtYmVyXVxuICAgKiBAcmV0dXJuIHtTZXNzaW9ufVxuICAgKi9cbiAgYXN5bmMgY2FsbCh7IHRvTnVtYmVyLCBmcm9tTnVtYmVyLCBtZWRpYSB9KSB7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbCxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgdG9OdW1iZXIsXG4gICAgICAgIGZyb21OdW1iZXIsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50Lmludml0ZSh0b051bWJlciwge1xuICAgICAgbWVkaWE6IHtcbiAgICAgICAgcmVuZGVyOiBtZWRpYSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5saXN0ZW5TZXNzaW9uRXZlbnRzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb247XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbEVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgYSBwaG9uZSBjYWxsLCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gY2FsbCBpcyBpbmNvbWluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gbWVkaWEsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmluZ2NlbnRyYWwvcmluZ2NlbnRyYWwtd2ViLXBob25lI2FjY2VwdGluZy1pbmNvbWluZy1jYWxsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBhY2NlcHQobWVkaWEpIHtcbiAgICB0aGlzLmNoZWNrU2Vzc2lvbigpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLmFjY2VwdChtZWRpYSk7XG4gIH1cblxuICBhc3luYyBieWUoKSB7XG4gICAgdGhpcy5jaGVja1Nlc3Npb24oKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi50ZXJtaW5hdGUoKTtcbiAgfVxuXG4gIGFzeW5jIHJlY29yZChmbGFnKSB7XG4gICAgb3BlcmF0aW9ucy5jYWxsKHRoaXMsICdyZWNvcmQnLCBmbGFnKTtcbiAgfVxuXG4gIGFzeW5jIG11dGUoZmxhZykge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAnbXV0ZScsIGZsYWcpO1xuICB9XG5cbiAgYXN5bmMgaG9sZChmbGFnKSB7XG4gICAgb3BlcmF0aW9ucy5jYWxsKHRoaXMsICdob2xkJywgZmxhZyk7XG4gIH1cblxuICBhc3luYyBwYXJrKGZsYWcpIHtcbiAgICBvcGVyYXRpb25zLmNhbGwodGhpcywgJ3BhcmsnLCBmbGFnKTtcbiAgfVxuXG4gIGFzeW5jIHRyYW5zZmVyKG51bWJlcikge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAndHJhbnNmZXInLCBudW1iZXIpO1xuICB9XG5cbiAgYXN5bmMgZmxpcChudW1iZXIpIHtcbiAgICBvcGVyYXRpb25zLmNhbGwodGhpcywgJ2ZsaXAnLCBudW1iZXIpO1xuICB9XG5cbiAgYXN5bmMgZHRtZihudW1iZXIpIHtcbiAgICBvcGVyYXRpb25zLmNhbGwodGhpcywgJ2R0bWYnLCBudW1iZXIpO1xuICB9XG5cbiAgY2hlY2tTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50U2Vzc2lvbikge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnNlc3Npb25FcnJvcixcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgRXJyb3IoJ05vIGFjdGl2ZSBzZXNzaW9uJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCBmb3IgbGlzdGVuIHNlc3Npb24gZXZlbnRzXG4gICAqL1xuICBsaXN0ZW5TZXNzaW9uRXZlbnRzKCkge1xuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ2FjY2VwdGVkJywgKHJlc3BvbnNlLCBjYXVzZSkgPT4ge1xuICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgLy8gYWNjZXB0ZWQgZXZlbnQgZm9yIG91dGJvdW5kIGNhbGwgd2lsbCByZXR1cm5lIGEgaW5jb21pbmdSZXNwb25zZVxuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxDb25uZWN0LFxuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHJlbW90ZUlkZW50aXR5OiByZXNwb25zZS50byxcbiAgICAgICAgICAgIGxvY2FsSWRlbnRpdHk6IHJlc3BvbnNlLmZyb20sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAvLyBhY2NlcHRlZCBldmVudCBmb3IgaW5ib3VuZCBjYWxsIHdpbGwgb25seSBjb250YWluIGEgcm93IHNpcCBkYXRhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbEFjY2VwdCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbi5vbigncmVqZWN0ZWQnLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxFbmQsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgIH0pO1xuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ3Rlcm1pbmF0ZWQnLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxFbmQsXG4gICAgICAgIGVycm9yOiBjYXVzZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbi5vbignYnllJywgKHJlcXVlc3QpID0+IHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbEVuZCxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgfSk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvaW5kZXguanNcbiAqKi8iLCJpbXBvcnQgeyBBY3Rpb25NYXAgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFjdGlvbk1hcChbXG4gICdyZWdpc3RlcicsXG4gICdyZWdpc3RlclN1Y2Nlc3MnLFxuICAncmVnaXN0ZXJFcnJvcicsXG4gICd1bnJlZ2lzdGVyJyxcblxuICAvLyBvdXRib3VuZCBjYWxsXG4gICdjYWxsJyxcbiAgJ2NhbGxDb25uZWN0JyxcbiAgLy8gaW5ib3VuZCBjYWxsXG4gICdjYWxsQWNjZXB0JyxcbiAgJ2NhbGxJbmNvbWluZycsXG5cbiAgJ2NhbGxFbmQnLFxuICAnY2FsbEVycm9yJyxcbiAgJ2NhbGxPcGVyYXRpb24nLFxuICAvLyBubyBhY3RpdmUgc2Vzc2lvblxuICAnc2Vzc2lvbkVycm9yJyxcbl0pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS93ZWJwaG9uZS1hY3Rpb25zLmpzXG4gKiovIiwiaW1wb3J0IHsgQWN0aW9uTWFwIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBBY3Rpb25NYXAoW1xuICAvLyBvcGVyYXRpb25hbCBlcnJvclxuICAnZXJyb3InLFxuICAvLyB1bnJlZ2lzdGVyLCBjbGVhciBvcGVyYXRpb25hbCBzdGF0ZVxuICAnY2xlYXInLFxuICAvLyBvcGVyYXRpb25cbiAgJ2ZsaXAnLFxuICAncmVjb3JkJyxcbiAgJ3N0b3BSZWNvcmQnLFxuICAnaG9sZCcsXG4gICd1bmhvbGQnLFxuICAnbXV0ZScsXG4gICd1bm11dGUnLFxuICAncGFyaycsXG4gICd0cmFuc2ZlcicsXG4gICdmb3J3YXJkJyxcbiAgJ2R0bWYnLFxuXSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3dlYnBob25lL2NhbGwtYWN0aW9ucy5qc1xuICoqLyIsImltcG9ydCB7IHByZWZpeEFjdGlvbnMgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcbmltcG9ydCB3ZWJwaG9uZUFjdGlvbnMgZnJvbSAnLi93ZWJwaG9uZS1hY3Rpb25zJztcbmltcG9ydCB3ZWJwaG9uZVN0YXR1cyBmcm9tICcuLi8uLi9lbnVtcy93ZWJwaG9uZS1zdGF0dXMnO1xuXG5pbXBvcnQgY2FsbFJlZHVjZXIgZnJvbSAnLi9jYWxsLXJlZHVjZXInO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIHN0YXR1czogd2VicGhvbmVTdGF0dXMucHJlUmVnaXN0ZXIsXG4gIC8vIGFzc2lnbiBmcm9tIFVJXG4gIHRvTnVtYmVyOiAnJyxcbiAgZnJvbU51bWJlcjogJycsXG4gIC8vIHNpcCBpbmZvIHJldHVybiBmcm9tIHNpcCBzZXJ2ZXJcbiAgcmVtb3RlSWRlbnRpdHk6IG51bGwsXG4gIGxvY2FsSWRlbnRpdHk6IG51bGwsXG4gIG9wZXJhdGlvbjogY2FsbFJlZHVjZXIoKSxcbiAgZXJyb3I6IG51bGwsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSZWR1Y2VyKHByZWZpeCkge1xuICBjb25zdCBhY3Rpb25zID0gcHJlZml4QWN0aW9ucyh3ZWJwaG9uZUFjdGlvbnMsIHByZWZpeCk7XG5cbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG4gICAgICBjYXNlIGFjdGlvbnMucmVnaXN0ZXJTdWNjZXNzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLnJlZ2lzdGVyU3VjY2Vzc2VkLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgYWN0aW9ucy5yZWdpc3RlckVycm9yOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLnJlZ2lzdGVyRmFpbGVkLFxuICAgICAgICAgIGVycm9yOiBhY3Rpb24uZXJyb3IsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBhY3Rpb25zLnVucmVnaXN0ZXI6XG4gICAgICAgIHJldHVybiBpbml0aWFsU3RhdGU7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgICAgc3RhdHVzOiB3ZWJwaG9uZVN0YXR1cy5jYWxsQ29ubmVjdGluZyxcbiAgICAgICAgICB0b051bWJlcjogYWN0aW9uLnBheWxvYWQudG9OdW1iZXIsXG4gICAgICAgICAgZnJvbU51bWJlcjogYWN0aW9uLnBheWxvYWQuZnJvbU51bWJlcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbEluY29taW5nOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxJbmNvbWluZyxcbiAgICAgICAgICByZW1vdGVJZGVudGl0eTogYWN0aW9uLnBheWxvYWQucmVtb3RlSWRlbnRpdHksXG4gICAgICAgICAgbG9jYWxJZGVudGl0eTogYWN0aW9uLnBheWxvYWQubG9jYWxJZGVudGl0eSxcbiAgICAgICAgfSk7XG4gICAgICAvLyBUT0RPOiB1cGRhdGUgZnJvbU51bWJlciwgdG9OdW1iZXJcbiAgICAgIGNhc2UgYWN0aW9ucy5jYWxsQ29ubmVjdDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgICAgc3RhdHVzOiB3ZWJwaG9uZVN0YXR1cy5jYWxsQ29ubmVjdGVkLFxuICAgICAgICAgIHJlbW90ZUlkZW50aXR5OiBhY3Rpb24ucGF5bG9hZC5yZW1vdGVJZGVudGl0eSxcbiAgICAgICAgICBsb2NhbElkZW50aXR5OiBhY3Rpb24ucGF5bG9hZC5sb2NhbElkZW50aXR5LFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgYWN0aW9ucy5jYWxsQWNjZXB0OlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxDb25uZWN0ZWQsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBhY3Rpb25zLmNhbGxFbmQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLnJlZ2lzdGVyU3VjY2Vzc2VkLFxuICAgICAgICAgIG9wZXJhdGlvbjogY2FsbFJlZHVjZXIoKSxcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbEVycm9yOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxGYWlsZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbE9wZXJhdGlvbjpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgICAgb3BlcmF0aW9uOiBjYWxsUmVkdWNlcihzdGF0ZS5vcGVyYXRpb24sIGFjdGlvbi5vcGVyYXRpb24pLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgYWN0aW9ucy5zZXNzaW9uRXJyb3I6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIGVycm9yOiBhY3Rpb24uZXJyb3IsXG4gICAgICAgIH0pO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS93ZWJwaG9uZS1yZWR1Y2VyLmpzXG4gKiovIiwiaW1wb3J0IEVudW0gZnJvbSAnLi4vbGliL2VudW0nO1xuXG5jb25zdCBkZWZpbml0aW9uID0ge1xuICAvLyBGb3IgcmVnaXN0ZXJpbmdcbiAgcHJlUmVnaXN0ZXI6ICdQUkVfUkVHSVNURVInLFxuICByZWdpc3RlclN1Y2Nlc3NlZDogJ1JFR0lTVEVSX1NVQ0NFU1NFRCcsXG4gIHJlZ2lzdGVyRmFpbGVkOiAnUkVHSVNURVJfRkFJTEVEJyxcbiAgLy8gRm9yIGNhbGxvdXQgYW5kIGFjdGl2ZSBjYWxsXG4gIGNhbGxDb25uZWN0aW5nOiAnQ0FMTF9DT05ORUNUSU5HJyxcbiAgY2FsbENvbm5lY3RlZDogJ0NBTExfQ09OTkVDVEVEJyxcbiAgY2FsbEZhaWxlZDogJ0NBTExfRkFJTEVEJyxcbiAgLy8gRm9yIGluY29taW5nIGNhbGxcbiAgY2FsbEluY29taW5nOiAnQ0FMTF9JTkNPTUlORycsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgRW51bShkZWZpbml0aW9uKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2VudW1zL3dlYnBob25lLXN0YXR1cy5qc1xuICoqLyIsImltcG9ydCBjYWxsQWN0aW9ucyBmcm9tICcuL2NhbGwtYWN0aW9ucyc7XG5pbXBvcnQgY2FsbFN0YXR1cyBmcm9tICcuLi8uLi9lbnVtcy9jYWxsLXN0YXR1cyc7XG5cbmZ1bmN0aW9uIGNvbnRhaW4oYXJyLCBlbGUpIHtcbiAgcmV0dXJuIGFyci5pbmRleE9mKGVsZSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGFyciwgZWxlKSB7XG4gIGlmIChjb250YWluKGFyciwgZWxlKSkge1xuICAgIGFyci5zcGxpY2UoYXJyLmluZGV4T2YoZWxlKSwgMSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAvLyBvcGVyYXRpb25zIHdoaWNoIGlzIGVuYWJsZVxuICBzdGF0dXM6IFtdLFxuICAvLyBzb21lIG9wZXJhdGlvbnMgd2lsbCBkaXNhYmxlIGFub3RoZXIsIHN1Y2ggYXMgJ2hvbGQnXG4gIGRpc2FibGVkOiBbXSxcbiAgLy8gc29tZSBvcGVyYXRpb25zIGhhdmUgaW5mb21hdGlvbiBuZWVkIHRvIGJlIHN0b3JlZFxuICB0cmFuc2ZlclRhZ2V0OiBudWxsLFxuICBmbGlwVGFyZ2V0OiBudWxsLFxuICBkdG1mTnVtYmVyOiBudWxsLFxuICAvLyBvcGVyYXRpb24gZXJyb3JcbiAgZXJyb3I6IG51bGwsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblxuICAgIGNhc2UgY2FsbEFjdGlvbnMuZXJyb3I6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuY2xlYXI6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLnJlY29yZDpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLnJlY29yZGluZykgP1xuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzIDpcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cy5jb25jYXQoY2FsbFN0YXR1cy5yZWNvcmRpbmcpLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy5zdG9wUmVjb3JkOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIHN0YXR1czogcmVtb3ZlKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5yZWNvcmRpbmcpLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy5tdXRlOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIHN0YXR1czogY29udGFpbihzdGF0ZS5zdGF0dXMsIGNhbGxTdGF0dXMubXV0ZWQpID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMubXV0ZWQpLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy51bm11dGU6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiByZW1vdmUoc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLm11dGVkKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuaG9sZDpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLmhvbGRpbmcpID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMuaG9sZGluZyksXG4gICAgICAgIGRpc2FibGVkOiBbJ3BhcmsnLCAncmVjb3JkJ10sXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLnVuaG9sZDpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IHJlbW92ZShzdGF0ZS5zdGF0dXMsIGNhbGxTdGF0dXMuaG9sZGluZyksXG4gICAgICAgIGRpc2FibGVkOiBbXSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMucGFyazpcbiAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbGxfcGFya2luZ1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIHN0YXR1czogY29udGFpbihzdGF0ZS5zdGF0dXMsIGNhbGxTdGF0dXMucGFya2VyKSA/XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgOlxuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzLmNvbmNhdChjYWxsU3RhdHVzLnBhcmtlciksXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLnRyYW5zZmVyOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIHN0YXR1czogY29udGFpbihzdGF0ZS5zdGF0dXMsIGNhbGxTdGF0dXMudHJhbnNmZXJlZCkgP1xuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzIDpcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cy5jb25jYXQoY2FsbFN0YXR1cy50cmFuc2ZlcmVkKSxcbiAgICAgICAgdHJhbnNmZXJUYWdldDogYWN0aW9uLnBheWxvYWQubnVtYmVyLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy5mbGlwOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIHN0YXR1czogY29udGFpbihzdGF0ZS5zdGF0dXMsIGNhbGxTdGF0dXMuZmxpcCkgP1xuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzIDpcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cy5jb25jYXQoY2FsbFN0YXR1cy5mbGlwKSxcbiAgICAgICAgZmxpcFRhcmdldDogYWN0aW9uLnBheWxvYWQubnVtYmVyLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy5kdG1mOlxuICAgICAgLy8gVE9ETzogY2xhcmlmeSBwYXJrIGFjdGlvblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIHN0YXR1czogc3RhdGUuc3RhdHVzLmNvbmNhdChjYWxsU3RhdHVzLnBhcmtlZCksXG4gICAgICAgIGR0bWZOdW1iZXI6IGFjdGlvbi5wYXlsb2FkLm51bWJlcixcbiAgICAgIH0pO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS9jYWxsLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi9saWIvZW51bSc7XG5cbmNvbnN0IGRlZmluaXRpb24gPSB7XG4gIGZsaXA6ICdGTElQRUQnLFxuICByZWNvcmRpbmc6ICdSRUNPUkRJTkcnLFxuICBob2xkaW5nOiAnSE9MRElORycsXG4gIG11dGVkOiAnTVVURUQnLFxuICBwYXJrZWQ6ICdQQVJLRUQnLFxuICB0cmFuc2ZlcmVkOiAnVFJBTlNGRVJFRCcsXG4gIGZvcndhcmRlZDogJ0ZPV0FSREVEJyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBFbnVtKGRlZmluaXRpb24pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvZW51bXMvY2FsbC1zdGF0dXMuanNcbiAqKi8iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnc2lwLmpzJ10sIGZ1bmN0aW9uKFNJUCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoU0lQKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnc2lwLmpzJykpO1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7IC8vRVM2XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5SaW5nQ2VudHJhbCA9IHJvb3QuUmluZ0NlbnRyYWwgfHwge307XG4gICAgICAgIHJvb3QuUmluZ0NlbnRyYWwuV2ViUGhvbmUgPSBmYWN0b3J5KHJvb3QuU0lQKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKFNJUCkge1xuXG4gICAgdmFyIG1lc3NhZ2VzID0ge1xuICAgICAgICBwYXJrOiB7cmVxaWQ6IDEsIGNvbW1hbmQ6ICdjYWxscGFyayd9LFxuICAgICAgICBzdGFydFJlY29yZDoge3JlcWlkOiAyLCBjb21tYW5kOiAnc3RhcnRjYWxscmVjb3JkJ30sXG4gICAgICAgIHN0b3BSZWNvcmQ6IHtyZXFpZDogMywgY29tbWFuZDogJ3N0b3BjYWxscmVjb3JkJ30sXG4gICAgICAgIGZsaXA6IHtyZXFpZDogMywgY29tbWFuZDogJ2NhbGxmbGlwJywgdGFyZ2V0OiAnJ30sXG4gICAgICAgIG1vbml0b3I6IHtyZXFpZDogNCwgY29tbWFuZDogJ21vbml0b3InfSxcbiAgICAgICAgYmFyZ2U6IHtyZXFpZDogNSwgY29tbWFuZDogJ2JhcmdlJ30sXG4gICAgICAgIHdoaXNwZXI6IHtyZXFpZDogNiwgY29tbWFuZDogJ3doaXNwZXInfSxcbiAgICAgICAgdGFrZW92ZXI6IHtyZXFpZDogNywgY29tbWFuZDogJ3Rha2VvdmVyJ31cbiAgICB9O1xuXG4gICAgdmFyIHJlc3BvbnNlVGltZW91dCA9IDEwMDAwO1xuXG4gICAgZnVuY3Rpb24gdXVpZCgpIHtcbiAgICAgICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxheShtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGRzdCwgc3JjKSB7XG4gICAgICAgIHNyYyA9IHNyYyB8fCB7fTtcbiAgICAgICAgZHN0ID0gZHN0IHx8IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgZHN0W2tdID0gc3JjW2tdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXVkaW9IZWxwZXIob3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSAhIW9wdGlvbnMuZW5hYmxlZDtcbiAgICAgICAgdGhpcy5faW5jb21pbmcgPSBvcHRpb25zLmluY29taW5nIHx8ICcuLi9hdWRpby9pbmNvbWluZy5vZ2cnO1xuICAgICAgICB0aGlzLl9vdXRnb2luZyA9IG9wdGlvbnMub3V0Z29pbmcgfHwgJy4uL2F1ZGlvL291dGdvaW5nLm9nZyc7XG4gICAgICAgIHRoaXMuX2F1ZGlvID0ge307XG5cbiAgICB9XG5cbiAgICBBdWRpb0hlbHBlci5wcm90b3R5cGUuX3BsYXlTb3VuZCA9IGZ1bmN0aW9uKHVybCwgdmFsLCB2b2x1bWUpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5fYXVkaW9bdXJsXSkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0gPSBuZXcgQXVkaW8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnNyYyA9IHVybDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLmxvb3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0udm9sdW1lID0gdm9sdW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0ucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0uY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0ucGxheSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBBdWRpb0hlbHBlci5wcm90b3R5cGUucGxheUluY29taW5nID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wbGF5U291bmQodGhpcy5faW5jb21pbmcsIHZhbCwgMC41KTtcbiAgICB9O1xuXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLnBsYXlPdXRnb2luZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxheVNvdW5kKHRoaXMuX291dGdvaW5nLCB2YWwsIDEpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZWdEYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy51dWlkXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcHBLZXldXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFwcE5hbWVdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFwcFZlcnNpb25dXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmF1ZGlvSGVscGVyXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vblNlc3Npb25dIGZpcmVkIGVhY2ggdGltZSBVc2VyQWdlbnQgc3RhcnRzIHdvcmtpbmcgd2l0aCBzZXNzaW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gV2ViUGhvbmUocmVnRGF0YSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJlZ0RhdGEgPSByZWdEYXRhIHx8IHt9O1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLnNpcEluZm8gPSByZWdEYXRhLnNpcEluZm9bMF0gfHwgcmVnRGF0YS5zaXBJbmZvO1xuICAgICAgICB0aGlzLnNpcEZsYWdzID0gcmVnRGF0YS5zaXBGbGFncztcblxuICAgICAgICB2YXIgaWQgPSBvcHRpb25zLnV1aWQgfHwgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JjLXdlYlBob25lLXV1aWQnKSB8fCB1dWlkKCk7IC8vVE9ETyBNYWtlIGNvbmZpZ3VyYWJsZVxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncmMtd2ViUGhvbmUtdXVpZCcsIGlkKTtcblxuICAgICAgICB0aGlzLmVuZHBvaW50SGVhZGVyID0gJ1AtcmMtZW5kcG9pbnQtaWQ6ICcgKyBpZDtcblxuICAgICAgICB2YXIgY29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHVyaTogJ3NpcDonICsgdGhpcy5zaXBJbmZvLnVzZXJuYW1lICsgJ0AnICsgdGhpcy5zaXBJbmZvLmRvbWFpbixcbiAgICAgICAgICAgIHdzU2VydmVyczogdGhpcy5zaXBJbmZvLm91dGJvdW5kUHJveHkgJiYgdGhpcy5zaXBJbmZvLnRyYW5zcG9ydFxuICAgICAgICAgICAgICAgID8gdGhpcy5zaXBJbmZvLnRyYW5zcG9ydC50b0xvd2VyQ2FzZSgpICsgJzovLycgKyB0aGlzLnNpcEluZm8ub3V0Ym91bmRQcm94eVxuICAgICAgICAgICAgICAgIDogdGhpcy5zaXBJbmZvLndzU2VydmVycyxcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25Vc2VyOiB0aGlzLnNpcEluZm8uYXV0aG9yaXphdGlvbklkLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMuc2lwSW5mby5wYXNzd29yZCxcbiAgICAgICAgICAgIHRyYWNlU2lwOiB0cnVlLFxuICAgICAgICAgICAgc3R1blNlcnZlcnM6IHRoaXMuc2lwSW5mby5zdHVuU2VydmVycyB8fCBbJ3N0dW46NzQuMTI1LjE5NC4xMjc6MTkzMDInXSwgLy9GSVhNRSBIYXJkY29kZWQ/XG4gICAgICAgICAgICB0dXJuU2VydmVyczogW10sXG4gICAgICAgICAgICBsb2c6IHtcbiAgICAgICAgICAgICAgICBsZXZlbDogb3B0aW9ucy5sb2dMZXZlbCB8fCAxIC8vRklYTUUgTE9HIExFVkVMIDNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb21haW46IHRoaXMuc2lwSW5mby5kb21haW4sXG4gICAgICAgICAgICBhdXRvc3RhcnQ6IHRydWUsXG4gICAgICAgICAgICByZWdpc3RlcjogdHJ1ZSxcbiAgICAgICAgICAgIGljZUdhdGhlcmluZ1RpbWVvdXQ6IHRoaXMuc2lwSW5mby5pY2VHYXRoZXJpbmdUaW1lb3V0IHx8IDMwMDBcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFwcEtleSA9IG9wdGlvbnMuYXBwS2V5O1xuICAgICAgICB0aGlzLmFwcE5hbWUgPSBvcHRpb25zLmFwcE5hbWU7XG4gICAgICAgIHRoaXMuYXBwVmVyc2lvbiA9IG9wdGlvbnMuYXBwVmVyc2lvbjtcbiAgICAgICAgdGhpcy51c2VyQWdlbnRIZWFkZXIgPSAnUkMtVXNlci1BZ2VudDogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMuYXBwTmFtZSA/IChvcHRpb25zLmFwcE5hbWUgKyAob3B0aW9ucy5hcHBWZXJzaW9uID8gJy8nICsgb3B0aW9ucy5hcHBWZXJzaW9uIDogJycpKSArICcgJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1JDV0VCUEhPTkUvJyArIFdlYlBob25lLnZlcnNpb247XG5cbiAgICAgICAgdGhpcy5jbGllbnRJZEhlYWRlciA9ICdDbGllbnQtaWQ6JyArIG9wdGlvbnMuYXBwS2V5O1xuXG4gICAgICAgIHRoaXMudXNlckFnZW50ID0gbmV3IFNJUC5VQShjb25maWd1cmF0aW9uKS5yZWdpc3Rlcih7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnM6IFtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50SGVhZGVyLFxuICAgICAgICAgICAgICAgIHRoaXMudXNlckFnZW50SGVhZGVyLFxuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50SWRIZWFkZXJcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQuZW5kcG9pbnRIZWFkZXIgPSB0aGlzLmVuZHBvaW50SGVhZGVyO1xuICAgICAgICB0aGlzLnVzZXJBZ2VudC51c2VyQWdlbnRIZWFkZXIgPSB0aGlzLnVzZXJBZ2VudEhlYWRlcjtcbiAgICAgICAgdGhpcy51c2VyQWdlbnQuY2xpZW50SWRIZWFkZXIgPSB0aGlzLmNsaWVudElkSGVhZGVyO1xuICAgICAgICB0aGlzLnVzZXJBZ2VudC5zaXBJbmZvID0gdGhpcy5zaXBJbmZvO1xuXG4gICAgICAgIHRoaXMudXNlckFnZW50Ll9faW52aXRlID0gdGhpcy51c2VyQWdlbnQuaW52aXRlO1xuICAgICAgICB0aGlzLnVzZXJBZ2VudC5pbnZpdGUgPSBpbnZpdGU7XG5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQub24oJ2ludml0ZScsIGZ1bmN0aW9uKHNlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMudXNlckFnZW50LmF1ZGlvSGVscGVyLnBsYXlJbmNvbWluZyh0cnVlKTtcbiAgICAgICAgICAgIHBhdGNoU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLnVzZXJBZ2VudC5hdWRpb0hlbHBlciA9IG5ldyBBdWRpb0hlbHBlcihvcHRpb25zLmF1ZGlvSGVscGVyKTtcblxuICAgICAgICB0aGlzLnVzZXJBZ2VudC5vblNlc3Npb24gPSBvcHRpb25zLm9uU2Vzc2lvbiB8fCBudWxsO1xuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICBXZWJQaG9uZS52ZXJzaW9uID0gJzAuMy4xJztcbiAgICBXZWJQaG9uZS51dWlkID0gdXVpZDtcbiAgICBXZWJQaG9uZS5kZWxheSA9IGRlbGF5O1xuICAgIFdlYlBob25lLmV4dGVuZCA9IGV4dGVuZDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgZnVuY3Rpb24gcGF0Y2hTZXNzaW9uKHNlc3Npb24pIHtcblxuICAgICAgICBpZiAoc2Vzc2lvbi5fX3BhdGNoZWQpIHJldHVybiBzZXNzaW9uO1xuXG4gICAgICAgIHNlc3Npb24uX19wYXRjaGVkID0gdHJ1ZTtcblxuICAgICAgICBzZXNzaW9uLl9fc2VuZFJlcXVlc3QgPSBzZXNzaW9uLnNlbmRSZXF1ZXN0O1xuICAgICAgICBzZXNzaW9uLl9fcmVjZWl2ZVJlcXVlc3QgPSBzZXNzaW9uLnJlY2VpdmVSZXF1ZXN0O1xuICAgICAgICBzZXNzaW9uLl9fcmVjZWl2ZUludml0ZVJlc3BvbnNlID0gc2Vzc2lvbi5yZWNlaXZlSW52aXRlUmVzcG9uc2U7XG4gICAgICAgIHNlc3Npb24uX19yZWNlaXZlUmVzcG9uc2UgPSBzZXNzaW9uLnJlY2VpdmVSZXNwb25zZTtcbiAgICAgICAgc2Vzc2lvbi5fX2FjY2VwdCA9IHNlc3Npb24uYWNjZXB0O1xuICAgICAgICBzZXNzaW9uLl9faG9sZCA9IHNlc3Npb24uaG9sZDtcbiAgICAgICAgc2Vzc2lvbi5fX3VuaG9sZCA9IHNlc3Npb24udW5ob2xkO1xuICAgICAgICBzZXNzaW9uLl9fZHRtZiA9IHNlc3Npb24uZHRtZjtcblxuICAgICAgICBzZXNzaW9uLnNlbmRSZXF1ZXN0ID0gc2VuZFJlcXVlc3Q7XG4gICAgICAgIHNlc3Npb24ucmVjZWl2ZVJlcXVlc3QgPSByZWNlaXZlUmVxdWVzdDtcbiAgICAgICAgc2Vzc2lvbi5yZWNlaXZlSW52aXRlUmVzcG9uc2UgPSByZWNlaXZlSW52aXRlUmVzcG9uc2U7XG4gICAgICAgIHNlc3Npb24ucmVjZWl2ZVJlc3BvbnNlID0gcmVjZWl2ZVJlc3BvbnNlO1xuICAgICAgICBzZXNzaW9uLmFjY2VwdCA9IGFjY2VwdDtcbiAgICAgICAgc2Vzc2lvbi5ob2xkID0gaG9sZDtcbiAgICAgICAgc2Vzc2lvbi51bmhvbGQgPSB1bmhvbGQ7XG4gICAgICAgIHNlc3Npb24uZHRtZiA9IGR0bWY7XG5cbiAgICAgICAgc2Vzc2lvbi5ibGluZFRyYW5zZmVyID0gYmxpbmRUcmFuc2ZlcjtcbiAgICAgICAgc2Vzc2lvbi50cmFuc2ZlciA9IHRyYW5zZmVyO1xuICAgICAgICBzZXNzaW9uLnBhcmsgPSBwYXJrO1xuICAgICAgICBzZXNzaW9uLmZvcndhcmQgPSBmb3J3YXJkO1xuICAgICAgICBzZXNzaW9uLnN0YXJ0UmVjb3JkID0gc3RhcnRSZWNvcmQ7XG4gICAgICAgIHNlc3Npb24uc3RvcFJlY29yZCA9IHN0b3BSZWNvcmQ7XG4gICAgICAgIHNlc3Npb24uZmxpcCA9IGZsaXA7XG5cbiAgICAgICAgc2Vzc2lvbi5vbigncmVwbGFjZWQnLCBwYXRjaFNlc3Npb24pO1xuICAgICAgICAvLyBzZXNzaW9uLm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcblxuICAgICAgICAvLyBBdWRpb1xuICAgICAgICBzZXNzaW9uLm9uKCdhY2NlcHRlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5vbigncmVqZWN0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ub24oJ2J5ZScsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5vbigndGVybWluYXRlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5vbignY2FuY2VsJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm9uKCdmYWlsZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ub24oJ3JlcGxhY2VkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm1lZGlhSGFuZGxlci5vbignaWNlQ29ubmVjdGlvbkNvbXBsZXRlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oJ2ljZUNvbm5lY3Rpb25GYWlsZWQnLCBzdG9wUGxheWluZyk7XG5cbiAgICAgICAgZnVuY3Rpb24gc3RvcFBsYXlpbmcoKSB7XG4gICAgICAgICAgICBzZXNzaW9uLnVhLmF1ZGlvSGVscGVyLnBsYXlPdXRnb2luZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXNzaW9uLnVhLmF1ZGlvSGVscGVyLnBsYXlJbmNvbWluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdhY2NlcHRlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ3JlamVjdGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignYnllJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcigndGVybWluYXRlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ2NhbmNlbCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ2ZhaWxlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ3JlcGxhY2VkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5tZWRpYUhhbmRsZXIucmVtb3ZlTGlzdGVuZXIoJ2ljZUNvbm5lY3Rpb25Db21wbGV0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLm1lZGlhSGFuZGxlci5yZW1vdmVMaXN0ZW5lcignaWNlQ29ubmVjdGlvbkZhaWxlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXNzaW9uLnVhLm9uU2Vzc2lvbikgc2Vzc2lvbi51YS5vblNlc3Npb24oc2Vzc2lvbik7XG5cbiAgICAgICAgcmV0dXJuIHNlc3Npb247XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb21tYW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VuZFJlY2VpdmUoc2Vzc2lvbiwgY29tbWFuZCwgb3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGV4dGVuZChjb21tYW5kLCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgY3NlcSA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgICAgICBzZXNzaW9uLnNlbmRSZXF1ZXN0KFNJUC5DLklORk8sIHtcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGNvbW1hbmRcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnVhLnVzZXJBZ2VudEhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi51YS5lbmRwb2ludEhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi51YS5jbGllbnRJZEhlYWRlclxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNfY29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjc2VxID0gcmVzcG9uc2UuY3NlcTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbkluZm8gPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmNzZXEgPT09IGNzZXEpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHJlcXVlc3QgJiYgcmVxdWVzdC5ib2R5IHx8ICd7fSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmo7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5yZXNwb25zZSAmJiBvYmoucmVzcG9uc2UuY29tbWFuZCA9PT0gY29tbWFuZC5jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnJlc3BvbnNlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmoucmVzcG9uc2UucmVzdWx0LmNvZGUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShvYmoucmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG9iai5yZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignUkNfU0lQX0lORk8nLCBvbkluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpOyAvL0ZJWE1FIFdoYXQgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQ6IG5vIHJlcGx5JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ1JDX1NJUF9JTkZPJywgb25JbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlc3BvbnNlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLm9uKCdSQ19TSVBfSU5GTycsIG9uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgSU5GTyByZXNwb25zZSBzdGF0dXMgY29kZSBpczogJyArIHJlc3BvbnNlLnN0YXR1c19jb2RlICsgJyAod2FpdGluZyBmb3IgMjAwKScpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICBmdW5jdGlvbiBzZW5kUmVxdWVzdCh0eXBlLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gU0lQLkMuUFJBQ0spIHtcbiAgICAgICAgICAgIHR5cGUgPSBTSVAuQy5BQ0s7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zZW5kUmVxdWVzdCh0eXBlLCBjb25maWcpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgZWFjaCB0aW1lIGEgcHJvdmlzaW9uYWwgKDEwMC0xOTkpIHJlc3BvbnNlIGlzIHJlY2VpdmVkLlxuICAgICAqIEVhcmx5IG1lZGlhIGlzIHN1cHBvcnRlZCBieSBTSVAuanMgbGlicmFyeVxuICAgICAqIEJ1dCBpbiBjYXNlIGl0IGlzIHNlbnQgd2l0aG91dCAxMDByZWwgc3VwcG9ydCB3ZSBwbGF5IGl0IG1hbnVhbGx5XG4gICAgICogU1RBVFVTX0VBUkxZX01FRElBID09PSAxMSwgaXQgd2lsbCBiZSBzZXQgYnkgU0lQLmpzIGlmIDEwMHJlbCBpcyBzdXBwb3J0ZWRcbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA3MjM4OFxuICAgICAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge2Z1bmNpdG9ufSBjYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhdGNoMTAwcmVsKHNlc3Npb24sIHJlc3BvbnNlLCBjYikge1xuXG4gICAgICAgIC8vRWFybHkgbWVkaWEgaXMgc3VwcG9ydGVkIGJ5IFNJUC5qcyBsaWJyYXJ5XG4gICAgICAgIC8vQnV0IGluIGNhc2UgaXQgaXMgc2VudCB3aXRob3V0IDEwMHJlbCBzdXBwb3J0IHdlIHBsYXkgaXQgbWFudWFsbHlcbiAgICAgICAgLy9TVEFUVVNfRUFSTFlfTUVESUEgPT09IDExLCBpdCB3aWxsIGJlIHNldCBieSBTSVAuanMgaWYgMTAwcmVsIGlzIHN1cHBvcnRlZFxuICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgIT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX0VBUkxZX01FRElBICYmIHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSAxODMgJiYgdHlwZW9mKHJlc3BvbnNlLmJvZHkpID09PSAnc3RyaW5nJyAmJiByZXNwb25zZS5ib2R5LmluZGV4T2YoJ1xcbicpICE9PSAtMSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5oYXNIZWFkZXIoJ3JlcXVpcmUnKSkgcmVzcG9uc2Uuc2V0SGVhZGVyKCdyZXF1aXJlJywgJzEwMHJlbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNiLmNhbGwoc2Vzc2lvbiwgcmVzcG9uc2UpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEBwYXJhbSByZXNwb25zZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjZWl2ZUludml0ZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBwYXRjaDEwMHJlbCh0aGlzLCByZXNwb25zZSwgdGhpcy5fX3JlY2VpdmVJbnZpdGVSZXNwb25zZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEBwYXJhbSByZXNwb25zZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBwYXRjaDEwMHJlbCh0aGlzLCByZXNwb25zZSwgdGhpcy5fX3JlY2VpdmVSZXNwb25zZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWdcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFJlY29yZChzZXNzaW9uLCBmbGFnKSB7XG5cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAhIWZsYWdcbiAgICAgICAgICAgID8gbWVzc2FnZXMuc3RhcnRSZWNvcmRcbiAgICAgICAgICAgIDogbWVzc2FnZXMuc3RvcFJlY29yZDtcblxuICAgICAgICBpZiAoKHNlc3Npb24uX19vblJlY29yZCAmJiAhZmxhZykgfHwgKCFzZXNzaW9uLl9fb25SZWNvcmQgJiYgZmxhZykpIHtcbiAgICAgICAgICAgIHJldHVybiBzZW5kUmVjZWl2ZShzZXNzaW9uLCBtZXNzYWdlKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5fX29uUmVjb3JkID0gISFmbGFnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWdcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEhvbGQoc2Vzc2lvbiwgZmxhZykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VlZGVkOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICBmYWlsZWQ6IHJlamVjdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5fX2hvbGQob3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlc3Npb24uX191bmhvbGQob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlVBfVxuICAgICAqIEBwYXJhbSBudW1iZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1NJUC5TZXNzaW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludml0ZShudW1iZXIsIG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgdWEgPSB0aGlzO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdO1xuXG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2godWEudXNlckFnZW50SGVhZGVyKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCh1YS5lbmRwb2ludEhlYWRlcik7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2godWEuY2xpZW50SWRIZWFkZXIpO1xuXG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goJ1AtQXNzZXJ0ZWQtSWRlbnRpdHk6IHNpcDonICsgKG9wdGlvbnMuZnJvbU51bWJlciB8fCB1YS5zaXBJbmZvLnVzZXJuYW1lKSArICdAJyArIHVhLnNpcEluZm8uZG9tYWluKTsgLy9GSVhNRSBQaG9uZSBOdW1iZXJcblxuICAgICAgICAvL0ZJWE1FIEJhY2tlbmQgc2hvdWxkIGtub3cgaXQgYWxyZWFkeVxuICAgICAgICBpZiAob3B0aW9ucy5ob21lQ291bnRyeUlkKSB7IG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goJ1AtcmMtY291bnRyeS1pZDogJyArIG9wdGlvbnMuaG9tZUNvdW50cnlJZCk7IH1cblxuICAgICAgICBvcHRpb25zLm1lZGlhID0gb3B0aW9ucy5tZWRpYSB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5tZWRpYS5jb25zdHJhaW50cyA9IG9wdGlvbnMubWVkaWEuY29uc3RyYWludHMgfHwge2F1ZGlvOiB0cnVlLCB2aWRlbzogZmFsc2V9O1xuXG4gICAgICAgIG9wdGlvbnMuUlRDQ29uc3RyYWludHMgPSBvcHRpb25zLlJUQ0NvbnN0cmFpbnRzIHx8IHtvcHRpb25hbDogW3tEdGxzU3J0cEtleUFncmVlbWVudDogJ3RydWUnfV19O1xuXG4gICAgICAgIHVhLmF1ZGlvSGVscGVyLnBsYXlPdXRnb2luZyh0cnVlKTtcblxuICAgICAgICByZXR1cm4gcGF0Y2hTZXNzaW9uKHVhLl9faW52aXRlKG51bWJlciwgb3B0aW9ucykpO1xuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY2VpdmVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzO1xuICAgICAgICBzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFNJUC5DLklORk86XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5lbWl0KCdSQ19TSVBfSU5GTycsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIC8vU0lQLmpzIGRvZXMgbm90IHN1cHBvcnQgYXBwbGljYXRpb24vanNvbiBjb250ZW50IHR5cGUsIHNvIHdlIG1vbmtleSBvdmVycmlkZSBpdHMgYmVoYXZpb3VyIGluIHRoaXMgY2FzZVxuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0YXR1cyA9PT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfQ09ORklSTUVEIHx8IHNlc3Npb24uc3RhdHVzID09PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUubWF0Y2goL15hcHBsaWNhdGlvblxcL2pzb24vaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoMjAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy9SZWZyZXNoIGludml0ZSBzaG91bGQgbm90IGJlIHJlamVjdGVkIHdpdGggNDg4XG4gICAgICAgICAgICBjYXNlIFNJUC5DLklOVklURTpcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5jYWxsX2lkICYmIHNlc3Npb24uZGlhbG9nICYmIHNlc3Npb24uZGlhbG9nLmlkICYmIHJlcXVlc3QuY2FsbF9pZCA9PSBzZXNzaW9uLmRpYWxvZy5pZC5jYWxsX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IGNoZWNrIHRoYXQgU0RQIGRpZCBub3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci5sb2coJ3JlLUlOVklURSByZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsU0RQID0gc2Vzc2lvbi5tZWRpYUhhbmRsZXIucGVlckNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMCwgbnVsbCwgWydDb250YWN0OiAnICsgc2Vzc2lvbi5jb250YWN0XSwgbG9jYWxTRFAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uc3RhdHVzID0gU0lQLlNlc3Npb24uQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uc2V0SW52aXRlMnh4VGltZXIocmVxdWVzdCwgbG9jYWxTRFApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uc2V0QUNLVGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9lbHNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCA0ODggYnkgU0lQLmpzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy9XZSBuZWVkIHRvIGFuYWxpemUgTk9USUZZIG1lc3NhZ2VzIHNvbWV0aW1lcywgc28gd2UgZmlyZSBhbiBldmVudFxuICAgICAgICAgICAgY2FzZSBTSVAuQy5OT1RJRlk6XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5lbWl0KCdSQ19TSVBfTk9USUZZJywgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlc3Npb24uX19yZWNlaXZlUmVxdWVzdC5hcHBseShzZXNzaW9uLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhY2NlcHQob3B0aW9ucykge1xuXG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcztcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXTtcblxuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKHNlc3Npb24udWEudXNlckFnZW50SGVhZGVyKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChzZXNzaW9uLnVhLmVuZHBvaW50SGVhZGVyKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChzZXNzaW9uLnVhLmNsaWVudElkSGVhZGVyKTtcblxuICAgICAgICBvcHRpb25zLm1lZGlhID0gb3B0aW9ucy5tZWRpYSB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5tZWRpYS5jb25zdHJhaW50cyA9IG9wdGlvbnMubWVkaWEuY29uc3RyYWludHMgfHwge2F1ZGlvOiB0cnVlLCB2aWRlbzogZmFsc2V9O1xuXG4gICAgICAgIG9wdGlvbnMuUlRDQ29uc3RyYWludHMgPSBvcHRpb25zLlJUQ0NvbnN0cmFpbnRzIHx8IHtvcHRpb25hbDogW3tEdGxzU3J0cEtleUFncmVlbWVudDogJ3RydWUnfV19O1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gb25BbnN3ZXJlZCgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ2ZhaWxlZCcsIG9uRmFpbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uRmFpbChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ2FjY2VwdGVkJywgb25BbnN3ZXJlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vVE9ETyBNb3JlIGV2ZW50cz9cbiAgICAgICAgICAgIHNlc3Npb24ub25jZSgnYWNjZXB0ZWQnLCBvbkFuc3dlcmVkKTtcbiAgICAgICAgICAgIHNlc3Npb24ub25jZSgnZmFpbGVkJywgb25GYWlsKTtcblxuICAgICAgICAgICAgc2Vzc2lvbi5fX2FjY2VwdChvcHRpb25zKTtcblxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGR0bWZcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGR0bWYoZHRtZiwgZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzO1xuICAgICAgICBkdXJhdGlvbiA9IHBhcnNlSW50KGR1cmF0aW9uKSB8fCAxMDAwO1xuICAgICAgICB2YXIgcGVlciA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLnBlZXJDb25uZWN0aW9uO1xuICAgICAgICB2YXIgc3RyZWFtID0gc2Vzc2lvbi5nZXRMb2NhbFN0cmVhbXMoKVswXTtcbiAgICAgICAgdmFyIGR0bWZTZW5kZXIgPSBwZWVyLmNyZWF0ZURUTUZTZW5kZXIoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0pO1xuICAgICAgICBpZiAoZHRtZlNlbmRlciAhPT0gdW5kZWZpbmVkICYmIGR0bWZTZW5kZXIuY2FuSW5zZXJ0RFRNRikge1xuICAgICAgICAgICAgcmV0dXJuIGR0bWZTZW5kZXIuaW5zZXJ0RFRNRihkdG1mLCBkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZW5kIERUTUYgZmFpbGVkOiAnICsgKCFkdG1mU2VuZGVyID8gJ25vIHNlbmRlcicgOiAoIWR0bWZTZW5kZXIuY2FuSW5zZXJ0RFRNRiA/ICdjYW5cXCd0IGluc2VydCBEVE1GJyA6ICdVbmtub3duJykpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaG9sZCgpIHtcbiAgICAgICAgcmV0dXJuIHNldEhvbGQodGhpcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaG9sZCgpIHtcbiAgICAgICAgcmV0dXJuIHNldEhvbGQodGhpcywgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBibGluZFRyYW5zZmVyKHRhcmdldCwgb3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcztcbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdO1xuICAgICAgICB2YXIgb3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy9CbGluZCBUcmFuc2ZlciBpcyB0YWtlbiBmcm9tIFNJUC5qcyBzb3VyY2VcblxuICAgICAgICAgICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0YXR1cyAhPT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHNlc3Npb24uc3RhdHVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm9ybWFsaXplVGFyZ2V0IGFsbG93cyBpbnN0YW5jZXMgb2YgU0lQLlVSSSB0byBwYXNzIHRocm91Z2ggdW5hbHRlcmVkLFxuICAgICAgICAgICAgLy8gc28gdHJ5IHRvIG1ha2Ugb25lIGFoZWFkIG9mIHRpbWVcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gU0lQLkdyYW1tYXIucGFyc2UodGFyZ2V0LCAnUmVmZXJfVG8nKS51cmkgfHwgdGFyZ2V0O1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLmRlYnVnKFwiLnJlZmVyKCkgY2Fubm90IHBhcnNlIFJlZmVyX1RvIGZyb21cIiwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci5kZWJ1ZyhcIi4uLmZhbGxpbmcgdGhyb3VnaCB0byBub3JtYWxpemVUYXJnZXQoKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGFyZ2V0IHZhbGlkaXR5XG4gICAgICAgICAgICB0YXJnZXQgPSBzZXNzaW9uLnVhLm5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRhcmdldDogJyArIG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcgKyBzZXNzaW9uLmNvbnRhY3QpO1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnICsgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JlZmVyLVRvOiAnICsgdGFyZ2V0KTtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKHNlc3Npb24udWEudXNlckFnZW50SGVhZGVyKTtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKHNlc3Npb24udWEuZW5kcG9pbnRIZWFkZXIpO1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goc2Vzc2lvbi51YS5jbGllbnRJZEhlYWRlcik7XG5cbiAgICAgICAgICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIHNlc3Npb24uc2VuZFJlcXVlc3QoU0lQLkMuUkVGRVIsIHtcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNfY29kZSA9PT0gMjAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbElkID0gcmVzcG9uc2UuY2FsbF9pZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uTm90aWZ5ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmNhbGxfaWQgPT09IGNhbGxJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHJlcXVlc3QgJiYgcmVxdWVzdC5ib2R5IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgLzFbMC05XXsyfS8udGVzdChib2R5KTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIC8yWzAtOV17Mn0vLnRlc3QoYm9keSk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignUkNfU0lQX05PVElGWScsIG9uTm90aWZ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQ6IG5vIHJlcGx5JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ1JDX1NJUF9OT1RJRlknLCBvbk5vdGlmeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZXNwb25zZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5vbignUkNfU0lQX05PVElGWScsIG9uTm90aWZ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSByZXNwb25zZSBzdGF0dXMgY29kZSBpczogJyArIHJlc3BvbnNlLnN0YXR1c19jb2RlICsgJyAod2FpdGluZyBmb3IgMjAyKScpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmZXIodGFyZ2V0LCBvcHRpb25zKSB7XG5cbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoc2Vzc2lvbi5pc09uSG9sZCgpID8gUHJvbWlzZS5yZXNvbHZlKG51bGwpIDogc2Vzc2lvbi5ob2xkKCkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIGRlbGF5KDMwMCk7IH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbi5ibGluZFRyYW5zZmVyKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNjZXB0T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdHJhbnNmZXJPcHRpb25zXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yd2FyZCh0YXJnZXQsIGFjY2VwdE9wdGlvbnMsIHRyYW5zZmVyT3B0aW9ucykge1xuXG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG51bGwsXG4gICAgICAgICAgICBzZXNzaW9uID0gdGhpcztcblxuICAgICAgICByZXR1cm4gc2Vzc2lvbi5hY2NlcHQoYWNjZXB0T3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ubXV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2Vzc2lvbi50cmFuc2Zlcih0YXJnZXQsIHRyYW5zZmVyT3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDcwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0UmVjb3JkKCkge1xuICAgICAgICByZXR1cm4gc2V0UmVjb3JkKHRoaXMsIHRydWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcFJlY29yZCgpIHtcbiAgICAgICAgcmV0dXJuIHNldFJlY29yZCh0aGlzLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHRhcmdldFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxpcCh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHNlbmRSZWNlaXZlKHRoaXMsIG1lc3NhZ2VzLmZsaXAsIHt0YXJnZXQ6IHRhcmdldH0pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyaygpIHtcbiAgICAgICAgcmV0dXJuIHNlbmRSZWNlaXZlKHRoaXMsIG1lc3NhZ2VzLnBhcmspO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgcmV0dXJuIFdlYlBob25lO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmluZ2NlbnRyYWwtd2ViLXBob25lL3NyYy9yaW5nY2VudHJhbC13ZWItcGhvbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1NJUCcpKHJlcXVpcmUoJy4vZW52aXJvbm1lbnQnKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBuYW1lIFNJUFxuICogQG5hbWVzcGFjZVxuICovXG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcblxudmFyIHBrZyA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuXG52YXIgU0lQID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe30sIHtcbiAgdmVyc2lvbjoge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHBrZy52ZXJzaW9uOyB9XG4gIH0sXG4gIG5hbWU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBwa2cudGl0bGU7IH1cbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vVXRpbHMnKShTSVAsIGVudmlyb25tZW50KTtcblNJUC5Mb2dnZXJGYWN0b3J5ID0gcmVxdWlyZSgnLi9Mb2dnZXJGYWN0b3J5JykoZW52aXJvbm1lbnQuY29uc29sZSk7XG5TSVAuRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9FdmVudEVtaXR0ZXInKShlbnZpcm9ubWVudC5jb25zb2xlKTtcblNJUC5DID0gcmVxdWlyZSgnLi9Db25zdGFudHMnKShTSVAubmFtZSwgU0lQLnZlcnNpb24pO1xuU0lQLkV4Y2VwdGlvbnMgPSByZXF1aXJlKCcuL0V4Y2VwdGlvbnMnKTtcblNJUC5UaW1lcnMgPSByZXF1aXJlKCcuL1RpbWVycycpKGVudmlyb25tZW50LnRpbWVycyk7XG5TSVAuVHJhbnNwb3J0ID0gZW52aXJvbm1lbnQuVHJhbnNwb3J0KFNJUCwgZW52aXJvbm1lbnQuV2ViU29ja2V0KTtcbnJlcXVpcmUoJy4vUGFyc2VyJykoU0lQKTtcbnJlcXVpcmUoJy4vU0lQTWVzc2FnZScpKFNJUCk7XG5yZXF1aXJlKCcuL1VSSScpKFNJUCk7XG5yZXF1aXJlKCcuL05hbWVBZGRySGVhZGVyJykoU0lQKTtcbnJlcXVpcmUoJy4vVHJhbnNhY3Rpb25zJykoU0lQKTtcbnJlcXVpcmUoJy4vRGlhbG9ncycpKFNJUCk7XG5yZXF1aXJlKCcuL1JlcXVlc3RTZW5kZXInKShTSVApO1xucmVxdWlyZSgnLi9SZWdpc3RlckNvbnRleHQnKShTSVApO1xuU0lQLk1lZGlhSGFuZGxlciA9IHJlcXVpcmUoJy4vTWVkaWFIYW5kbGVyJykoU0lQLkV2ZW50RW1pdHRlcik7XG5yZXF1aXJlKCcuL0NsaWVudENvbnRleHQnKShTSVApO1xucmVxdWlyZSgnLi9TZXJ2ZXJDb250ZXh0JykoU0lQKTtcbnJlcXVpcmUoJy4vU2Vzc2lvbicpKFNJUCwgZW52aXJvbm1lbnQpO1xucmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKShTSVApO1xuU0lQLldlYlJUQyA9IHJlcXVpcmUoJy4vV2ViUlRDJykoU0lQLCBlbnZpcm9ubWVudCk7XG5yZXF1aXJlKCcuL1VBJykoU0lQLCBlbnZpcm9ubWVudCk7XG5TSVAuSGFja3MgPSByZXF1aXJlKCcuL0hhY2tzJykoU0lQKTtcbnJlcXVpcmUoJy4vU2FuaXR5Q2hlY2snKShTSVApO1xuU0lQLkRpZ2VzdEF1dGhlbnRpY2F0aW9uID0gcmVxdWlyZSgnLi9EaWdlc3RBdXRoZW50aWNhdGlvbicpKFNJUC5VdGlscyk7XG5TSVAuR3JhbW1hciA9IHJlcXVpcmUoJy4vR3JhbW1hcicpKFNJUCk7XG5cbnJldHVybiBTSVA7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TSVAuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcIl9hcmdzXCI6IFtcblx0XHRbXG5cdFx0XHRcInNpcC5qc0AwLjcuNVwiLFxuXHRcdFx0XCIvVXNlcnMvaG93YXJkLnpoYW5nL1NpdGVzL3JpbmdjZW50cmFsLWpzLWludGVncmF0aW9uLWNvbW1vbnMvbm9kZV9tb2R1bGVzL3JpbmdjZW50cmFsLXdlYi1waG9uZVwiXG5cdFx0XVxuXHRdLFxuXHRcIl9mcm9tXCI6IFwic2lwLmpzQDAuNy41XCIsXG5cdFwiX2lkXCI6IFwic2lwLmpzQDAuNy41XCIsXG5cdFwiX2luQ2FjaGVcIjogdHJ1ZSxcblx0XCJfaW5zdGFsbGFibGVcIjogdHJ1ZSxcblx0XCJfbG9jYXRpb25cIjogXCIvc2lwLmpzXCIsXG5cdFwiX25vZGVWZXJzaW9uXCI6IFwiNC40LjNcIixcblx0XCJfbnBtT3BlcmF0aW9uYWxJbnRlcm5hbFwiOiB7XG5cdFx0XCJob3N0XCI6IFwicGFja2FnZXMtMTItd2VzdC5pbnRlcm5hbC5ucG1qcy5jb21cIixcblx0XHRcInRtcFwiOiBcInRtcC9zaXAuanMtMC43LjUudGd6XzE0NjE1OTQ0MTg2OTBfMC41ODM5OTMzMTI0MzcwODczXCJcblx0fSxcblx0XCJfbnBtVXNlclwiOiB7XG5cdFx0XCJlbWFpbFwiOiBcIjEyMTJqdHJhY2V1ckBnbWFpbC5jb21cIixcblx0XHRcIm5hbWVcIjogXCJqb3NlcGhmcmF6aWVyXCJcblx0fSxcblx0XCJfbnBtVmVyc2lvblwiOiBcIjIuMTUuMVwiLFxuXHRcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG5cdFwiX3JlcXVlc3RlZFwiOiB7XG5cdFx0XCJuYW1lXCI6IFwic2lwLmpzXCIsXG5cdFx0XCJyYXdcIjogXCJzaXAuanNAMC43LjVcIixcblx0XHRcInJhd1NwZWNcIjogXCIwLjcuNVwiLFxuXHRcdFwic2NvcGVcIjogbnVsbCxcblx0XHRcInNwZWNcIjogXCIwLjcuNVwiLFxuXHRcdFwidHlwZVwiOiBcInZlcnNpb25cIlxuXHR9LFxuXHRcIl9yZXF1aXJlZEJ5XCI6IFtcblx0XHRcIi9yaW5nY2VudHJhbC13ZWItcGhvbmVcIlxuXHRdLFxuXHRcIl9yZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3NpcC5qcy8tL3NpcC5qcy0wLjcuNS50Z3pcIixcblx0XCJfc2hhc3VtXCI6IFwiODZhY2U3MDUxNTk0ZjkxYjQ1NTFiZGI4MTIwYTE2YzQ0OTYyZDNhMlwiLFxuXHRcIl9zaHJpbmt3cmFwXCI6IG51bGwsXG5cdFwiX3NwZWNcIjogXCJzaXAuanNAMC43LjVcIixcblx0XCJfd2hlcmVcIjogXCIvVXNlcnMvaG93YXJkLnpoYW5nL1NpdGVzL3JpbmdjZW50cmFsLWpzLWludGVncmF0aW9uLWNvbW1vbnMvbm9kZV9tb2R1bGVzL3JpbmdjZW50cmFsLXdlYi1waG9uZVwiLFxuXHRcImF1dGhvclwiOiB7XG5cdFx0XCJlbWFpbFwiOiBcImRldmVsb3BlckBvbnNpcC5jb21cIixcblx0XHRcIm5hbWVcIjogXCJPblNJUFwiLFxuXHRcdFwidXJsXCI6IFwiaHR0cDovL3NpcGpzLmNvbS9hdXRob3JzL1wiXG5cdH0sXG5cdFwiYnJvd3NlclwiOiB7XG5cdFx0XCIuL3NyYy9lbnZpcm9ubWVudC5qc1wiOiBcIi4vc3JjL2Vudmlyb25tZW50X2Jyb3dzZXIuanNcIlxuXHR9LFxuXHRcImJ1Z3NcIjoge1xuXHRcdFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL29uc2lwL1NJUC5qcy9pc3N1ZXNcIlxuXHR9LFxuXHRcImNvbnRyaWJ1dG9yc1wiOiBbXG5cdFx0e1xuXHRcdFx0XCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vb25zaXAvU0lQLmpzL2Jsb2IvbWFzdGVyL1RIQU5LUy5tZFwiXG5cdFx0fVxuXHRdLFxuXHRcImRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJwcm9taXNjdW91c1wiOiBcIl4wLjYuMFwiLFxuXHRcdFwid3NcIjogXCJeMC42LjRcIlxuXHR9LFxuXHRcImRlc2NyaXB0aW9uXCI6IFwiQSBzaW1wbGUsIGludHVpdGl2ZSwgYW5kIHBvd2VyZnVsIEphdmFTY3JpcHQgc2lnbmFsaW5nIGxpYnJhcnlcIixcblx0XCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwiYmVlZnlcIjogXCJeMi4xLjVcIixcblx0XHRcImJyb3dzZXJpZnlcIjogXCJeNC4xLjhcIixcblx0XHRcImdydW50XCI6IFwifjAuNC4wXCIsXG5cdFx0XCJncnVudC1icm93c2VyaWZ5XCI6IFwiXjQuMC4xXCIsXG5cdFx0XCJncnVudC1jbGlcIjogXCJ+MC4xLjZcIixcblx0XHRcImdydW50LWNvbnRyaWItY29weVwiOiBcIl4wLjUuMFwiLFxuXHRcdFwiZ3J1bnQtY29udHJpYi1qYXNtaW5lXCI6IFwiXjAuOS4yXCIsXG5cdFx0XCJncnVudC1jb250cmliLWpzaGludFwiOiBcIj4wLjUuMFwiLFxuXHRcdFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJ+MC4yLjBcIixcblx0XHRcImdydW50LXBlZ1wiOiBcIn4xLjMuMVwiLFxuXHRcdFwiZ3J1bnQtdHJpbXRyYWlsaW5nc3BhY2VzXCI6IFwiXjAuNC4wXCIsXG5cdFx0XCJwZWdqc1wiOiBcIl4wLjguMFwiXG5cdH0sXG5cdFwiZGlyZWN0b3JpZXNcIjoge30sXG5cdFwiZGlzdFwiOiB7XG5cdFx0XCJzaGFzdW1cIjogXCI4NmFjZTcwNTE1OTRmOTFiNDU1MWJkYjgxMjBhMTZjNDQ5NjJkM2EyXCIsXG5cdFx0XCJ0YXJiYWxsXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvc2lwLmpzLy0vc2lwLmpzLTAuNy41LnRnelwiXG5cdH0sXG5cdFwiZW5naW5lc1wiOiB7XG5cdFx0XCJub2RlXCI6IFwiPj0wLjhcIlxuXHR9LFxuXHRcImdpdEhlYWRcIjogXCJiYWU0NGJkMDM1OWY0ZDcwZGVkMzA5YTMyMzYxZjA0YTA0ZTc4ZDZlXCIsXG5cdFwiaG9tZXBhZ2VcIjogXCJodHRwOi8vc2lwanMuY29tXCIsXG5cdFwia2V5d29yZHNcIjogW1xuXHRcdFwic2lwXCIsXG5cdFx0XCJ3ZWJzb2NrZXRcIixcblx0XHRcIndlYnJ0Y1wiLFxuXHRcdFwibGlicmFyeVwiLFxuXHRcdFwiamF2YXNjcmlwdFwiXG5cdF0sXG5cdFwibGljZW5zZVwiOiBcIk1JVFwiLFxuXHRcIm1haW5cIjogXCJzcmMvaW5kZXguanNcIixcblx0XCJtYWludGFpbmVyc1wiOiBbXG5cdFx0e1xuXHRcdFx0XCJlbWFpbFwiOiBcImVyaWMuZ3JlZW5Ab25zaXAuY29tXCIsXG5cdFx0XHRcIm5hbWVcIjogXCJlZ3JlZW5fb25zaXBcIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJlbWFpbFwiOiBcImphbWVzQG9uc2lwLmNvbVwiLFxuXHRcdFx0XCJuYW1lXCI6IFwiamFtZXMtY3Jpc2N1b2xvXCJcblx0XHR9LFxuXHRcdHtcblx0XHRcdFwiZW1haWxcIjogXCIxMjEyanRyYWNldXJAZ21haWwuY29tXCIsXG5cdFx0XHRcIm5hbWVcIjogXCJqb3NlcGhmcmF6aWVyXCJcblx0XHR9XG5cdF0sXG5cdFwibmFtZVwiOiBcInNpcC5qc1wiLFxuXHRcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcInByb21pc2N1b3VzXCI6IFwiXjAuNi4wXCJcblx0fSxcblx0XCJyZWFkbWVcIjogXCJFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhXCIsXG5cdFwicmVwb3NpdG9yeVwiOiB7XG5cdFx0XCJ0eXBlXCI6IFwiZ2l0XCIsXG5cdFx0XCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL29uc2lwL1NJUC5qcy5naXRcIlxuXHR9LFxuXHRcInNjcmlwdHNcIjoge1xuXHRcdFwiYnVpbGRcIjogXCJncnVudCBidWlsZFwiLFxuXHRcdFwicHJlcHVibGlzaFwiOiBcImNkIHNyYy9HcmFtbWFyICYmIG1rZGlyIC1wIGRpc3QgJiYgcGVnanMgLS1leHRyYS1vcHRpb25zLWZpbGUgcGVnLmpzb24gc3JjL0dyYW1tYXIucGVnanMgZGlzdC9HcmFtbWFyLmpzXCIsXG5cdFx0XCJyZXBsXCI6IFwiYmVlZnkgdGVzdC9yZXBsLmpzIC0tb3BlblwiLFxuXHRcdFwidGVzdFwiOiBcImdydW50IHRyYXZpcyAtLXZlcmJvc2VcIlxuXHR9LFxuXHRcInRpdGxlXCI6IFwiU0lQLmpzXCIsXG5cdFwidmVyc2lvblwiOiBcIjAuNy41XCJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3BhY2thZ2UuanNvblxuICoqIG1vZHVsZSBpZCA9IDIxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVAsIGVudmlyb25tZW50KSB7XG52YXIgVXRpbHM7XG5cblV0aWxzPSB7XG5cbiAgUHJvbWlzZTogZW52aXJvbm1lbnQuUHJvbWlzZSxcblxuICBkZWZlcjogZnVuY3Rpb24gZGVmZXIgKCkge1xuICAgIHZhciBkZWZlcnJlZCA9IHt9O1xuICAgIGRlZmVycmVkLnByb21pc2UgPSBuZXcgVXRpbHMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIGRlZmVycmVkLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH0sXG5cbiAgcHJvbWlzaWZ5OiBmdW5jdGlvbiBwcm9taXNpZnkgKG9iamVjdCwgbWV0aG9kTmFtZSwgY2FsbGJhY2tzRmlyc3QpIHtcbiAgICB2YXIgb2xkTWV0aG9kID0gb2JqZWN0W21ldGhvZE5hbWVdO1xuICAgIHJldHVybiBmdW5jdGlvbiBwcm9taXNpZmllZE1ldGhvZCAoYXJnLCBvblN1Y2Nlc3MsIG9uRmFpbHVyZSkge1xuICAgICAgcmV0dXJuIG5ldyBVdGlscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIG9sZEFyZ3MgPSBbYXJnLCByZXNvbHZlLCByZWplY3RdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzRmlyc3QpIHtcbiAgICAgICAgICBvbGRBcmdzID0gW3Jlc29sdmUsIHJlamVjdCwgYXJnXTtcbiAgICAgICAgfVxuICAgICAgICBvbGRNZXRob2QuYXBwbHkob2JqZWN0LCBvbGRBcmdzKTtcbiAgICAgIH0pLnRoZW4ob25TdWNjZXNzLCBvbkZhaWx1cmUpO1xuICAgIH07XG4gIH0sXG5cbiAgYXVnbWVudDogZnVuY3Rpb24gKG9iamVjdCwgY29uc3RydWN0b3IsIGFyZ3MsIG92ZXJyaWRlKSB7XG4gICAgdmFyIGlkeCwgcHJvdG87XG5cbiAgICAvLyBBZGQgcHVibGljIHByb3BlcnRpZXMgZnJvbSBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZSBvbnRvIG9iamVjdFxuICAgIHByb3RvID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIGZvciAoaWR4IGluIHByb3RvKSB7XG4gICAgICBpZiAob3ZlcnJpZGUgfHwgb2JqZWN0W2lkeF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmplY3RbaWR4XSA9IHByb3RvW2lkeF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBvYmplY3QgYXMgdGhvdWdoIGl0IHdlcmUganVzdCBjcmVhdGVkIGJ5IGNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3IuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgfSxcblxuICBvcHRpb25zT3ZlcnJpZGU6IGZ1bmN0aW9uIChvcHRpb25zLCB3aW5uZXIsIGxvc2VyLCBpc0RlcHJlY2F0ZWQsIGxvZ2dlciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGlzRGVwcmVjYXRlZCAmJiBvcHRpb25zW2xvc2VyXSkge1xuICAgICAgbG9nZ2VyLndhcm4obG9zZXIgKyAnIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgJyArIHdpbm5lciArICcgaW5zdGVhZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zW3dpbm5lcl0gJiYgb3B0aW9uc1tsb3Nlcl0pIHtcbiAgICAgIGxvZ2dlci53YXJuKHdpbm5lciArICcgb3ZlcnJpZGluZyAnICsgbG9zZXIpO1xuICAgIH1cblxuICAgIG9wdGlvbnNbd2lubmVyXSA9IG9wdGlvbnNbd2lubmVyXSB8fCBvcHRpb25zW2xvc2VyXSB8fCBkZWZhdWx0VmFsdWU7XG4gIH0sXG5cbiAgc3RyX3V0ZjhfbGVuZ3RoOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykucmVwbGFjZSgvJVtBLUZcXGRdezJ9L2csICdVJykubGVuZ3RoO1xuICB9LFxuXG4gIGdlbmVyYXRlRmFrZVNEUDogZnVuY3Rpb24oYm9keSkge1xuICAgIGlmICghYm9keSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IGJvZHkuaW5kZXhPZignbz0nKTtcbiAgICB2YXIgZW5kID0gYm9keS5pbmRleE9mKCdcXHJcXG4nLCBzdGFydCk7XG5cbiAgICByZXR1cm4gJ3Y9MFxcclxcbicgKyBib2R5LnNsaWNlKHN0YXJ0LCBlbmQpICsgJ1xcclxcbnM9LVxcclxcbnQ9MCAwXFxyXFxuYz1JTiBJUDQgMC4wLjAuMCc7XG4gIH0sXG5cbiAgaXNGdW5jdGlvbjogZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoZm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmbikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgaXNEZWNpbWFsOiBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuICFpc05hTihudW0pICYmIChwYXJzZUZsb2F0KG51bSkgPT09IHBhcnNlSW50KG51bSwxMCkpO1xuICB9LFxuXG4gIGNyZWF0ZVJhbmRvbVRva2VuOiBmdW5jdGlvbihzaXplLCBiYXNlKSB7XG4gICAgdmFyIGksIHIsXG4gICAgICB0b2tlbiA9ICcnO1xuXG4gICAgYmFzZSA9IGJhc2UgfHwgMzI7XG5cbiAgICBmb3IoIGk9MDsgaSA8IHNpemU7IGkrKyApIHtcbiAgICAgIHIgPSBNYXRoLnJhbmRvbSgpICogYmFzZXwwO1xuICAgICAgdG9rZW4gKz0gci50b1N0cmluZyhiYXNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW47XG4gIH0sXG5cbiAgbmV3VGFnOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gU0lQLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKFNJUC5VQS5DLlRBR19MRU5HVEgpO1xuICB9LFxuXG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy8xMDk1MzgvYnJvb2ZhXG4gIG5ld1VVSUQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBVVUlEID0gICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpKjE2fDAsIHYgPSBjID09PSAneCcgPyByIDogKHImMHgzfDB4OCk7XG4gICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gVVVJRDtcbiAgfSxcblxuICBob3N0VHlwZTogZnVuY3Rpb24oaG9zdCkge1xuICAgIGlmICghaG9zdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBob3N0ID0gU0lQLkdyYW1tYXIucGFyc2UoaG9zdCwnaG9zdCcpO1xuICAgICAgaWYgKGhvc3QgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBob3N0Lmhvc3RfdHlwZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogTm9ybWFsaXplIFNJUCBVUkkuXG4gICogTk9URTogSXQgZG9lcyBub3QgYWxsb3cgYSBTSVAgVVJJIHdpdGhvdXQgdXNlcm5hbWUuXG4gICogQWNjZXB0cyAnc2lwJywgJ3NpcHMnIGFuZCAndGVsJyBVUklzIGFuZCBjb252ZXJ0IHRoZW0gaW50byAnc2lwJy5cbiAgKiBEZXRlY3RzIHRoZSBkb21haW4gcGFydCAoaWYgZ2l2ZW4pIGFuZCBwcm9wZXJseSBoZXgtZXNjYXBlcyB0aGUgdXNlciBwb3J0aW9uLlxuICAqIElmIHRoZSB1c2VyIHBvcnRpb24gaGFzIG9ubHkgJ3RlbCcgbnVtYmVyIHN5bWJvbHMgdGhlIHVzZXIgcG9ydGlvbiBpcyBjbGVhbiBvZiAndGVsJyB2aXN1YWwgc2VwYXJhdG9ycy5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAgKiBAcGFyYW0ge1N0cmluZ30gW2RvbWFpbl1cbiAgKi9cbiAgbm9ybWFsaXplVGFyZ2V0OiBmdW5jdGlvbih0YXJnZXQsIGRvbWFpbikge1xuICAgIHZhciB1cmksIHRhcmdldF9hcnJheSwgdGFyZ2V0X3VzZXIsIHRhcmdldF9kb21haW47XG5cbiAgICAvLyBJZiBubyB0YXJnZXQgaXMgZ2l2ZW4gdGhlbiByYWlzZSBhbiBlcnJvci5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIC8vIElmIGEgU0lQLlVSSSBpbnN0YW5jZSBpcyBnaXZlbiB0aGVuIHJldHVybiBpdC5cbiAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNJUC5VUkkpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG5cbiAgICAvLyBJZiBhIHN0cmluZyBpcyBnaXZlbiBzcGxpdCBpdCBieSAnQCc6XG4gICAgLy8gLSBMYXN0IGZyYWdtZW50IGlzIHRoZSBkZXNpcmVkIGRvbWFpbi5cbiAgICAvLyAtIE90aGVyd2lzZSBhcHBlbmQgdGhlIGdpdmVuIGRvbWFpbiBhcmd1bWVudC5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0YXJnZXRfYXJyYXkgPSB0YXJnZXQuc3BsaXQoJ0AnKTtcblxuICAgICAgc3dpdGNoKHRhcmdldF9hcnJheS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmICghZG9tYWluKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldF91c2VyID0gdGFyZ2V0O1xuICAgICAgICAgIHRhcmdldF9kb21haW4gPSBkb21haW47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0YXJnZXRfdXNlciA9IHRhcmdldF9hcnJheVswXTtcbiAgICAgICAgICB0YXJnZXRfZG9tYWluID0gdGFyZ2V0X2FycmF5WzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRhcmdldF91c2VyID0gdGFyZ2V0X2FycmF5LnNsaWNlKDAsIHRhcmdldF9hcnJheS5sZW5ndGgtMSkuam9pbignQCcpO1xuICAgICAgICAgIHRhcmdldF9kb21haW4gPSB0YXJnZXRfYXJyYXlbdGFyZ2V0X2FycmF5Lmxlbmd0aC0xXTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBVUkkgc2NoZW1lIChpZiBwcmVzZW50KS5cbiAgICAgIHRhcmdldF91c2VyID0gdGFyZ2V0X3VzZXIucmVwbGFjZSgvXihzaXBzP3x0ZWwpOi9pLCAnJyk7XG5cbiAgICAgIC8vIFJlbW92ZSAndGVsJyB2aXN1YWwgc2VwYXJhdG9ycyBpZiB0aGUgdXNlciBwb3J0aW9uIGp1c3QgY29udGFpbnMgJ3RlbCcgbnVtYmVyIHN5bWJvbHMuXG4gICAgICBpZiAoL15bXFwtXFwuXFwoXFwpXSpcXCs/WzAtOVxcLVxcLlxcKFxcKV0rJC8udGVzdCh0YXJnZXRfdXNlcikpIHtcbiAgICAgICAgdGFyZ2V0X3VzZXIgPSB0YXJnZXRfdXNlci5yZXBsYWNlKC9bXFwtXFwuXFwoXFwpXS9nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJ1aWxkIHRoZSBjb21wbGV0ZSBTSVAgVVJJLlxuICAgICAgdGFyZ2V0ID0gU0lQLkMuU0lQICsgJzonICsgU0lQLlV0aWxzLmVzY2FwZVVzZXIodGFyZ2V0X3VzZXIpICsgJ0AnICsgdGFyZ2V0X2RvbWFpbjtcblxuICAgICAgLy8gRmluYWxseSBwYXJzZSB0aGUgcmVzdWx0aW5nIFVSSS5cbiAgICAgIGlmICh1cmkgPSBTSVAuVVJJLnBhcnNlKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBIZXgtZXNjYXBlIGEgU0lQIFVSSSB1c2VyLlxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAgKi9cbiAgZXNjYXBlVXNlcjogZnVuY3Rpb24odXNlcikge1xuICAgIC8vIERvbid0IGhleC1lc2NhcGUgJzonICglM0EpLCAnKycgKCUyQiksICc/JyAoJTNGXCIpLCAnLycgKCUyRikuXG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXNlcikpLnJlcGxhY2UoLyUzQS9pZywgJzonKS5yZXBsYWNlKC8lMkIvaWcsICcrJykucmVwbGFjZSgvJTNGL2lnLCAnPycpLnJlcGxhY2UoLyUyRi9pZywgJy8nKTtcbiAgfSxcblxuICBoZWFkZXJpemU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBleGNlcHRpb25zID0ge1xuICAgICAgJ0NhbGwtSWQnOiAnQ2FsbC1JRCcsXG4gICAgICAnQ3NlcSc6ICdDU2VxJyxcbiAgICAgICdNaW4tU2UnOiAnTWluLVNFJyxcbiAgICAgICdSYWNrJzogJ1JBY2snLFxuICAgICAgJ1JzZXEnOiAnUlNlcScsXG4gICAgICAnV3d3LUF1dGhlbnRpY2F0ZSc6ICdXV1ctQXV0aGVudGljYXRlJ1xuICAgICAgfSxcbiAgICAgIG5hbWUgPSBzdHJpbmcudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9fL2csJy0nKS5zcGxpdCgnLScpLFxuICAgICAgaG5hbWUgPSAnJyxcbiAgICAgIHBhcnRzID0gbmFtZS5sZW5ndGgsIHBhcnQ7XG5cbiAgICBmb3IgKHBhcnQgPSAwOyBwYXJ0IDwgcGFydHM7IHBhcnQrKykge1xuICAgICAgaWYgKHBhcnQgIT09IDApIHtcbiAgICAgICAgaG5hbWUgKz0nLSc7XG4gICAgICB9XG4gICAgICBobmFtZSArPSBuYW1lW3BhcnRdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK25hbWVbcGFydF0uc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAoZXhjZXB0aW9uc1tobmFtZV0pIHtcbiAgICAgIGhuYW1lID0gZXhjZXB0aW9uc1tobmFtZV07XG4gICAgfVxuICAgIHJldHVybiBobmFtZTtcbiAgfSxcblxuICBzaXBFcnJvckNhdXNlOiBmdW5jdGlvbihzdGF0dXNfY29kZSkge1xuICAgIHZhciBjYXVzZTtcblxuICAgIGZvciAoY2F1c2UgaW4gU0lQLkMuU0lQX0VSUk9SX0NBVVNFUykge1xuICAgICAgaWYgKFNJUC5DLlNJUF9FUlJPUl9DQVVTRVNbY2F1c2VdLmluZGV4T2Yoc3RhdHVzX2NvZGUpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gU0lQLkMuY2F1c2VzW2NhdXNlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gU0lQLkMuY2F1c2VzLlNJUF9GQUlMVVJFX0NPREU7XG4gIH0sXG5cbiAgZ2V0UmVhc29uUGhyYXNlOiBmdW5jdGlvbiBnZXRSZWFzb25QaHJhc2UgKGNvZGUsIHNwZWNpZmljKSB7XG4gICAgcmV0dXJuIHNwZWNpZmljIHx8IFNJUC5DLlJFQVNPTl9QSFJBU0VbY29kZV0gfHwgJyc7XG4gIH0sXG5cbiAgZ2V0UmVhc29uSGVhZGVyVmFsdWU6IGZ1bmN0aW9uIGdldFJlYXNvbkhlYWRlclZhbHVlIChjb2RlLCByZWFzb24pIHtcbiAgICByZWFzb24gPSBTSVAuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKGNvZGUsIHJlYXNvbik7XG4gICAgcmV0dXJuICdTSVAgO2NhdXNlPScgKyBjb2RlICsgJyA7dGV4dD1cIicgKyByZWFzb24gKyAnXCInO1xuICB9LFxuXG4gIGdldENhbmNlbFJlYXNvbjogZnVuY3Rpb24gZ2V0Q2FuY2VsUmVhc29uIChjb2RlLCByZWFzb24pIHtcbiAgICBpZiAoY29kZSAmJiBjb2RlIDwgMjAwIHx8IGNvZGUgPiA2OTkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzX2NvZGU6ICcgKyBjb2RlKTtcbiAgICB9IGVsc2UgaWYgKGNvZGUpIHtcbiAgICAgIHJldHVybiBTSVAuVXRpbHMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoY29kZSwgcmVhc29uKTtcbiAgICB9XG4gIH0sXG5cbiAgYnVpbGRTdGF0dXNMaW5lOiBmdW5jdGlvbiBidWlsZFN0YXR1c0xpbmUgKGNvZGUsIHJlYXNvbikge1xuICAgIGNvZGUgPSBjb2RlIHx8IG51bGw7XG4gICAgcmVhc29uID0gcmVhc29uIHx8IG51bGw7XG5cbiAgICAvLyBWYWxpZGF0ZSBjb2RlIGFuZCByZWFzb24gdmFsdWVzXG4gICAgaWYgKCFjb2RlIHx8IChjb2RlIDwgMTAwIHx8IGNvZGUgPiA2OTkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0YXR1c19jb2RlOiAnKyBjb2RlKTtcbiAgICB9IGVsc2UgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uICE9PSAnc3RyaW5nJyAmJiAhKHJlYXNvbiBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcmVhc29uX3BocmFzZTogJysgcmVhc29uKTtcbiAgICB9XG5cbiAgICByZWFzb24gPSBVdGlscy5nZXRSZWFzb25QaHJhc2UoY29kZSwgcmVhc29uKTtcblxuICAgIHJldHVybiAnU0lQLzIuMCAnICsgY29kZSArICcgJyArIHJlYXNvbiArICdcXHJcXG4nO1xuICB9LFxuXG4gIC8qKlxuICAqIEdlbmVyYXRlIGEgcmFuZG9tIFRlc3QtTmV0IElQIChodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1NzM1KVxuICAqIEBwcml2YXRlXG4gICovXG4gIGdldFJhbmRvbVRlc3ROZXRJUDogZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZ2V0T2N0ZXQoZnJvbSx0bykge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoodG8tZnJvbSsxKStmcm9tKTtcbiAgICB9XG4gICAgcmV0dXJuICcxOTIuMC4yLicgKyBnZXRPY3RldCgxLCAyNTQpO1xuICB9LFxuXG4gIC8vIE1ENSAoTWVzc2FnZS1EaWdlc3QgQWxnb3JpdGhtKSBodHRwOi8vd3d3LndlYnRvb2xraXQuaW5mb1xuICBjYWxjdWxhdGVNRDU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGZ1bmN0aW9uIFJvdGF0ZUxlZnQobFZhbHVlLCBpU2hpZnRCaXRzKSB7XG4gICAgICByZXR1cm4gKGxWYWx1ZTw8aVNoaWZ0Qml0cykgfCAobFZhbHVlPj4+KDMyLWlTaGlmdEJpdHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBZGRVbnNpZ25lZChsWCxsWSkge1xuICAgICAgdmFyIGxYNCxsWTQsbFg4LGxZOCxsUmVzdWx0O1xuICAgICAgbFg4ID0gKGxYICYgMHg4MDAwMDAwMCk7XG4gICAgICBsWTggPSAobFkgJiAweDgwMDAwMDAwKTtcbiAgICAgIGxYNCA9IChsWCAmIDB4NDAwMDAwMDApO1xuICAgICAgbFk0ID0gKGxZICYgMHg0MDAwMDAwMCk7XG4gICAgICBsUmVzdWx0ID0gKGxYICYgMHgzRkZGRkZGRikrKGxZICYgMHgzRkZGRkZGRik7XG4gICAgICBpZiAobFg0ICYgbFk0KSB7XG4gICAgICAgIHJldHVybiAobFJlc3VsdCBeIDB4ODAwMDAwMDAgXiBsWDggXiBsWTgpO1xuICAgICAgfVxuICAgICAgaWYgKGxYNCB8IGxZNCkge1xuICAgICAgICBpZiAobFJlc3VsdCAmIDB4NDAwMDAwMDApIHtcbiAgICAgICAgICByZXR1cm4gKGxSZXN1bHQgXiAweEMwMDAwMDAwIF4gbFg4IF4gbFk4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gKGxSZXN1bHQgXiAweDQwMDAwMDAwIF4gbFg4IF4gbFk4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChsUmVzdWx0IF4gbFg4IF4gbFk4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBGKHgseSx6KSB7XG4gICAgICByZXR1cm4gKHggJiB5KSB8ICgofngpICYgeik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRyh4LHkseikge1xuICAgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmICh+eikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEgoeCx5LHopIHtcbiAgICAgIHJldHVybiAoeCBeIHkgXiB6KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJKHgseSx6KSB7XG4gICAgICByZXR1cm4gKHkgXiAoeCB8ICh+eikpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBGRihhLGIsYyxkLHgscyxhYykge1xuICAgICAgYSA9IEFkZFVuc2lnbmVkKGEsIEFkZFVuc2lnbmVkKEFkZFVuc2lnbmVkKEYoYiwgYywgZCksIHgpLCBhYykpO1xuICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEdHKGEsYixjLGQseCxzLGFjKSB7XG4gICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoRyhiLCBjLCBkKSwgeCksIGFjKSk7XG4gICAgICByZXR1cm4gQWRkVW5zaWduZWQoUm90YXRlTGVmdChhLCBzKSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSEgoYSxiLGMsZCx4LHMsYWMpIHtcbiAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChIKGIsIGMsIGQpLCB4KSwgYWMpKTtcbiAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJSShhLGIsYyxkLHgscyxhYykge1xuICAgICAgYSA9IEFkZFVuc2lnbmVkKGEsIEFkZFVuc2lnbmVkKEFkZFVuc2lnbmVkKEkoYiwgYywgZCksIHgpLCBhYykpO1xuICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnZlcnRUb1dvcmRBcnJheShzdHJpbmcpIHtcbiAgICAgIHZhciBsV29yZENvdW50O1xuICAgICAgdmFyIGxNZXNzYWdlTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHZhciBsTnVtYmVyT2ZXb3Jkc190ZW1wMT1sTWVzc2FnZUxlbmd0aCArIDg7XG4gICAgICB2YXIgbE51bWJlck9mV29yZHNfdGVtcDI9KGxOdW1iZXJPZldvcmRzX3RlbXAxLShsTnVtYmVyT2ZXb3Jkc190ZW1wMSAlIDY0KSkvNjQ7XG4gICAgICB2YXIgbE51bWJlck9mV29yZHMgPSAobE51bWJlck9mV29yZHNfdGVtcDIrMSkqMTY7XG4gICAgICB2YXIgbFdvcmRBcnJheT1BcnJheShsTnVtYmVyT2ZXb3Jkcy0xKTtcbiAgICAgIHZhciBsQnl0ZVBvc2l0aW9uID0gMDtcbiAgICAgIHZhciBsQnl0ZUNvdW50ID0gMDtcbiAgICAgIHdoaWxlICggbEJ5dGVDb3VudCA8IGxNZXNzYWdlTGVuZ3RoICkge1xuICAgICAgICBsV29yZENvdW50ID0gKGxCeXRlQ291bnQtKGxCeXRlQ291bnQgJSA0KSkvNDtcbiAgICAgICAgbEJ5dGVQb3NpdGlvbiA9IChsQnl0ZUNvdW50ICUgNCkqODtcbiAgICAgICAgbFdvcmRBcnJheVtsV29yZENvdW50XSA9IChsV29yZEFycmF5W2xXb3JkQ291bnRdIHwgKHN0cmluZy5jaGFyQ29kZUF0KGxCeXRlQ291bnQpPDxsQnl0ZVBvc2l0aW9uKSk7XG4gICAgICAgIGxCeXRlQ291bnQrKztcbiAgICAgIH1cbiAgICAgIGxXb3JkQ291bnQgPSAobEJ5dGVDb3VudC0obEJ5dGVDb3VudCAlIDQpKS80O1xuICAgICAgbEJ5dGVQb3NpdGlvbiA9IChsQnl0ZUNvdW50ICUgNCkqODtcbiAgICAgIGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gPSBsV29yZEFycmF5W2xXb3JkQ291bnRdIHwgKDB4ODA8PGxCeXRlUG9zaXRpb24pO1xuICAgICAgbFdvcmRBcnJheVtsTnVtYmVyT2ZXb3Jkcy0yXSA9IGxNZXNzYWdlTGVuZ3RoPDwzO1xuICAgICAgbFdvcmRBcnJheVtsTnVtYmVyT2ZXb3Jkcy0xXSA9IGxNZXNzYWdlTGVuZ3RoPj4+Mjk7XG4gICAgICByZXR1cm4gbFdvcmRBcnJheTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXb3JkVG9IZXgobFZhbHVlKSB7XG4gICAgICB2YXIgV29yZFRvSGV4VmFsdWU9XCJcIixXb3JkVG9IZXhWYWx1ZV90ZW1wPVwiXCIsbEJ5dGUsbENvdW50O1xuICAgICAgZm9yIChsQ291bnQgPSAwO2xDb3VudDw9MztsQ291bnQrKykge1xuICAgICAgICBsQnl0ZSA9IChsVmFsdWU+Pj4obENvdW50KjgpKSAmIDI1NTtcbiAgICAgICAgV29yZFRvSGV4VmFsdWVfdGVtcCA9IFwiMFwiICsgbEJ5dGUudG9TdHJpbmcoMTYpO1xuICAgICAgICBXb3JkVG9IZXhWYWx1ZSA9IFdvcmRUb0hleFZhbHVlICsgV29yZFRvSGV4VmFsdWVfdGVtcC5zdWJzdHIoV29yZFRvSGV4VmFsdWVfdGVtcC5sZW5ndGgtMiwyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBXb3JkVG9IZXhWYWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVdGY4RW5jb2RlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1xcclxcbi9nLFwiXFxuXCIpO1xuICAgICAgdmFyIHV0ZnRleHQgPSBcIlwiO1xuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHN0cmluZy5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xuXG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoKGMgPiAxMjcpICYmIChjIDwgMjA0OCkpIHtcbiAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgPj4gNikgfCAxOTIpO1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDYzKSB8IDEyOCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjID4+IDEyKSB8IDIyNCk7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyA+PiA2KSAmIDYzKSB8IDEyOCk7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgNjMpIHwgMTI4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHV0ZnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIHg9W107XG4gICAgdmFyIGssQUEsQkIsQ0MsREQsYSxiLGMsZDtcbiAgICB2YXIgUzExPTcsIFMxMj0xMiwgUzEzPTE3LCBTMTQ9MjI7XG4gICAgdmFyIFMyMT01LCBTMjI9OSAsIFMyMz0xNCwgUzI0PTIwO1xuICAgIHZhciBTMzE9NCwgUzMyPTExLCBTMzM9MTYsIFMzND0yMztcbiAgICB2YXIgUzQxPTYsIFM0Mj0xMCwgUzQzPTE1LCBTNDQ9MjE7XG5cbiAgICBzdHJpbmcgPSBVdGY4RW5jb2RlKHN0cmluZyk7XG5cbiAgICB4ID0gQ29udmVydFRvV29yZEFycmF5KHN0cmluZyk7XG5cbiAgICBhID0gMHg2NzQ1MjMwMTsgYiA9IDB4RUZDREFCODk7IGMgPSAweDk4QkFEQ0ZFOyBkID0gMHgxMDMyNTQ3NjtcblxuICAgIGZvciAoaz0wO2s8eC5sZW5ndGg7ays9MTYpIHtcbiAgICAgIEFBPWE7IEJCPWI7IENDPWM7IEREPWQ7XG4gICAgICBhPUZGKGEsYixjLGQseFtrKzBdLCBTMTEsMHhENzZBQTQ3OCk7XG4gICAgICBkPUZGKGQsYSxiLGMseFtrKzFdLCBTMTIsMHhFOEM3Qjc1Nik7XG4gICAgICBjPUZGKGMsZCxhLGIseFtrKzJdLCBTMTMsMHgyNDIwNzBEQik7XG4gICAgICBiPUZGKGIsYyxkLGEseFtrKzNdLCBTMTQsMHhDMUJEQ0VFRSk7XG4gICAgICBhPUZGKGEsYixjLGQseFtrKzRdLCBTMTEsMHhGNTdDMEZBRik7XG4gICAgICBkPUZGKGQsYSxiLGMseFtrKzVdLCBTMTIsMHg0Nzg3QzYyQSk7XG4gICAgICBjPUZGKGMsZCxhLGIseFtrKzZdLCBTMTMsMHhBODMwNDYxMyk7XG4gICAgICBiPUZGKGIsYyxkLGEseFtrKzddLCBTMTQsMHhGRDQ2OTUwMSk7XG4gICAgICBhPUZGKGEsYixjLGQseFtrKzhdLCBTMTEsMHg2OTgwOThEOCk7XG4gICAgICBkPUZGKGQsYSxiLGMseFtrKzldLCBTMTIsMHg4QjQ0RjdBRik7XG4gICAgICBjPUZGKGMsZCxhLGIseFtrKzEwXSxTMTMsMHhGRkZGNUJCMSk7XG4gICAgICBiPUZGKGIsYyxkLGEseFtrKzExXSxTMTQsMHg4OTVDRDdCRSk7XG4gICAgICBhPUZGKGEsYixjLGQseFtrKzEyXSxTMTEsMHg2QjkwMTEyMik7XG4gICAgICBkPUZGKGQsYSxiLGMseFtrKzEzXSxTMTIsMHhGRDk4NzE5Myk7XG4gICAgICBjPUZGKGMsZCxhLGIseFtrKzE0XSxTMTMsMHhBNjc5NDM4RSk7XG4gICAgICBiPUZGKGIsYyxkLGEseFtrKzE1XSxTMTQsMHg0OUI0MDgyMSk7XG4gICAgICBhPUdHKGEsYixjLGQseFtrKzFdLCBTMjEsMHhGNjFFMjU2Mik7XG4gICAgICBkPUdHKGQsYSxiLGMseFtrKzZdLCBTMjIsMHhDMDQwQjM0MCk7XG4gICAgICBjPUdHKGMsZCxhLGIseFtrKzExXSxTMjMsMHgyNjVFNUE1MSk7XG4gICAgICBiPUdHKGIsYyxkLGEseFtrKzBdLCBTMjQsMHhFOUI2QzdBQSk7XG4gICAgICBhPUdHKGEsYixjLGQseFtrKzVdLCBTMjEsMHhENjJGMTA1RCk7XG4gICAgICBkPUdHKGQsYSxiLGMseFtrKzEwXSxTMjIsMHgyNDQxNDUzKTtcbiAgICAgIGM9R0coYyxkLGEsYix4W2srMTVdLFMyMywweEQ4QTFFNjgxKTtcbiAgICAgIGI9R0coYixjLGQsYSx4W2srNF0sIFMyNCwweEU3RDNGQkM4KTtcbiAgICAgIGE9R0coYSxiLGMsZCx4W2srOV0sIFMyMSwweDIxRTFDREU2KTtcbiAgICAgIGQ9R0coZCxhLGIsYyx4W2srMTRdLFMyMiwweEMzMzcwN0Q2KTtcbiAgICAgIGM9R0coYyxkLGEsYix4W2srM10sIFMyMywweEY0RDUwRDg3KTtcbiAgICAgIGI9R0coYixjLGQsYSx4W2srOF0sIFMyNCwweDQ1NUExNEVEKTtcbiAgICAgIGE9R0coYSxiLGMsZCx4W2srMTNdLFMyMSwweEE5RTNFOTA1KTtcbiAgICAgIGQ9R0coZCxhLGIsYyx4W2srMl0sIFMyMiwweEZDRUZBM0Y4KTtcbiAgICAgIGM9R0coYyxkLGEsYix4W2srN10sIFMyMywweDY3NkYwMkQ5KTtcbiAgICAgIGI9R0coYixjLGQsYSx4W2srMTJdLFMyNCwweDhEMkE0QzhBKTtcbiAgICAgIGE9SEgoYSxiLGMsZCx4W2srNV0sIFMzMSwweEZGRkEzOTQyKTtcbiAgICAgIGQ9SEgoZCxhLGIsYyx4W2srOF0sIFMzMiwweDg3NzFGNjgxKTtcbiAgICAgIGM9SEgoYyxkLGEsYix4W2srMTFdLFMzMywweDZEOUQ2MTIyKTtcbiAgICAgIGI9SEgoYixjLGQsYSx4W2srMTRdLFMzNCwweEZERTUzODBDKTtcbiAgICAgIGE9SEgoYSxiLGMsZCx4W2srMV0sIFMzMSwweEE0QkVFQTQ0KTtcbiAgICAgIGQ9SEgoZCxhLGIsYyx4W2srNF0sIFMzMiwweDRCREVDRkE5KTtcbiAgICAgIGM9SEgoYyxkLGEsYix4W2srN10sIFMzMywweEY2QkI0QjYwKTtcbiAgICAgIGI9SEgoYixjLGQsYSx4W2srMTBdLFMzNCwweEJFQkZCQzcwKTtcbiAgICAgIGE9SEgoYSxiLGMsZCx4W2srMTNdLFMzMSwweDI4OUI3RUM2KTtcbiAgICAgIGQ9SEgoZCxhLGIsYyx4W2srMF0sIFMzMiwweEVBQTEyN0ZBKTtcbiAgICAgIGM9SEgoYyxkLGEsYix4W2srM10sIFMzMywweEQ0RUYzMDg1KTtcbiAgICAgIGI9SEgoYixjLGQsYSx4W2srNl0sIFMzNCwweDQ4ODFEMDUpO1xuICAgICAgYT1ISChhLGIsYyxkLHhbays5XSwgUzMxLDB4RDlENEQwMzkpO1xuICAgICAgZD1ISChkLGEsYixjLHhbaysxMl0sUzMyLDB4RTZEQjk5RTUpO1xuICAgICAgYz1ISChjLGQsYSxiLHhbaysxNV0sUzMzLDB4MUZBMjdDRjgpO1xuICAgICAgYj1ISChiLGMsZCxhLHhbaysyXSwgUzM0LDB4QzRBQzU2NjUpO1xuICAgICAgYT1JSShhLGIsYyxkLHhbayswXSwgUzQxLDB4RjQyOTIyNDQpO1xuICAgICAgZD1JSShkLGEsYixjLHhbays3XSwgUzQyLDB4NDMyQUZGOTcpO1xuICAgICAgYz1JSShjLGQsYSxiLHhbaysxNF0sUzQzLDB4QUI5NDIzQTcpO1xuICAgICAgYj1JSShiLGMsZCxhLHhbays1XSwgUzQ0LDB4RkM5M0EwMzkpO1xuICAgICAgYT1JSShhLGIsYyxkLHhbaysxMl0sUzQxLDB4NjU1QjU5QzMpO1xuICAgICAgZD1JSShkLGEsYixjLHhbayszXSwgUzQyLDB4OEYwQ0NDOTIpO1xuICAgICAgYz1JSShjLGQsYSxiLHhbaysxMF0sUzQzLDB4RkZFRkY0N0QpO1xuICAgICAgYj1JSShiLGMsZCxhLHhbaysxXSwgUzQ0LDB4ODU4NDVERDEpO1xuICAgICAgYT1JSShhLGIsYyxkLHhbays4XSwgUzQxLDB4NkZBODdFNEYpO1xuICAgICAgZD1JSShkLGEsYixjLHhbaysxNV0sUzQyLDB4RkUyQ0U2RTApO1xuICAgICAgYz1JSShjLGQsYSxiLHhbays2XSwgUzQzLDB4QTMwMTQzMTQpO1xuICAgICAgYj1JSShiLGMsZCxhLHhbaysxM10sUzQ0LDB4NEUwODExQTEpO1xuICAgICAgYT1JSShhLGIsYyxkLHhbays0XSwgUzQxLDB4Rjc1MzdFODIpO1xuICAgICAgZD1JSShkLGEsYixjLHhbaysxMV0sUzQyLDB4QkQzQUYyMzUpO1xuICAgICAgYz1JSShjLGQsYSxiLHhbaysyXSwgUzQzLDB4MkFEN0QyQkIpO1xuICAgICAgYj1JSShiLGMsZCxhLHhbays5XSwgUzQ0LDB4RUI4NkQzOTEpO1xuICAgICAgYT1BZGRVbnNpZ25lZChhLEFBKTtcbiAgICAgIGI9QWRkVW5zaWduZWQoYixCQik7XG4gICAgICBjPUFkZFVuc2lnbmVkKGMsQ0MpO1xuICAgICAgZD1BZGRVbnNpZ25lZChkLEREKTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcCA9IFdvcmRUb0hleChhKStXb3JkVG9IZXgoYikrV29yZFRvSGV4KGMpK1dvcmRUb0hleChkKTtcblxuICAgIHJldHVybiB0ZW1wLnRvTG93ZXJDYXNlKCk7XG4gIH1cbn07XG5cblNJUC5VdGlscyA9IFV0aWxzO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxldmVscyA9IHtcbiAgJ2Vycm9yJzogMCxcbiAgJ3dhcm4nOiAxLFxuICAnbG9nJzogMixcbiAgJ2RlYnVnJzogM1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uc29sZSkge1xuXG52YXIgTG9nZ2VyRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvZ2dlcixcbiAgICBsZXZlbCA9IDIsXG4gICAgYnVpbHRpbkVuYWJsZWQgPSB0cnVlLFxuICAgIGNvbm5lY3RvciA9IG51bGw7XG5cbiAgICB0aGlzLmxvZ2dlcnMgPSB7fTtcblxuICAgIGxvZ2dlciA9IHRoaXMuZ2V0TG9nZ2VyKCdzaXAubG9nZ2VyZmFjdG9yeScpO1xuXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIGJ1aWx0aW5FbmFibGVkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBidWlsdGluRW5hYmxlZDsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBidWlsdGluRW5hYmxlZCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignaW52YWxpZCBcImJ1aWx0aW5FbmFibGVkXCIgcGFyYW1ldGVyIHZhbHVlOiAnKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGxldmVsOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge3JldHVybiBsZXZlbDsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPD0zKSB7XG4gICAgICAgICAgbGV2ZWwgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+IDMpIHtcbiAgICAgICAgICBsZXZlbCA9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAobGV2ZWxzLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgIGxldmVsID0gbGV2ZWxzW3ZhbHVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ2ludmFsaWQgXCJsZXZlbFwiIHBhcmFtZXRlciB2YWx1ZTogJysgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb25uZWN0b3I6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7cmV0dXJuIGNvbm5lY3RvcjsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICBpZih2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29ubmVjdG9yID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25uZWN0b3IgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ2ludmFsaWQgXCJjb25uZWN0b3JcIiBwYXJhbWV0ZXIgdmFsdWU6ICcrIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuTG9nZ2VyRmFjdG9yeS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbih0YXJnZXQsIGNhdGVnb3J5LCBsYWJlbCwgY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHByZWZpeCA9IFtuZXcgRGF0ZSgpLCBjYXRlZ29yeV07XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBwcmVmaXgucHVzaChsYWJlbCk7XG4gICAgfVxuICAgIGNvbnRlbnQgPSBwcmVmaXguY29uY2F0KGNvbnRlbnQpLmpvaW4oJyB8ICcpO1xuICB9XG4gIHRhcmdldC5jYWxsKGNvbnNvbGUsIGNvbnRlbnQpO1xufTtcblxuZnVuY3Rpb24gTG9nZ2VyIChsb2dnZXIsIGNhdGVnb3J5LCBsYWJlbCkge1xuICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgdGhpcy5jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICB0aGlzLmxhYmVsID0gbGFiZWw7XG59XG5cbk9iamVjdC5rZXlzKGxldmVscykuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0TmFtZSkge1xuICBMb2dnZXIucHJvdG90eXBlW3RhcmdldE5hbWVdID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICB0aGlzLmxvZ2dlclt0YXJnZXROYW1lXSh0aGlzLmNhdGVnb3J5LCB0aGlzLmxhYmVsLCBjb250ZW50KTtcbiAgfTtcblxuICBMb2dnZXJGYWN0b3J5LnByb3RvdHlwZVt0YXJnZXROYW1lXSA9IGZ1bmN0aW9uIChjYXRlZ29yeSwgbGFiZWwsIGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5sZXZlbCA+PSBsZXZlbHNbdGFyZ2V0TmFtZV0pIHtcbiAgICAgIGlmICh0aGlzLmJ1aWx0aW5FbmFibGVkKSB7XG4gICAgICAgIHRoaXMucHJpbnQoY29uc29sZVt0YXJnZXROYW1lXSwgY2F0ZWdvcnksIGxhYmVsLCBjb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29ubmVjdG9yKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yKHRhcmdldE5hbWUsIGNhdGVnb3J5LCBsYWJlbCwgY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSk7XG5cbkxvZ2dlckZhY3RvcnkucHJvdG90eXBlLmdldExvZ2dlciA9IGZ1bmN0aW9uKGNhdGVnb3J5LCBsYWJlbCkge1xuICB2YXIgbG9nZ2VyO1xuXG4gIGlmIChsYWJlbCAmJiB0aGlzLmxldmVsID09PSAzKSB7XG4gICAgcmV0dXJuIG5ldyBMb2dnZXIodGhpcywgY2F0ZWdvcnksIGxhYmVsKTtcbiAgfSBlbHNlIGlmICh0aGlzLmxvZ2dlcnNbY2F0ZWdvcnldKSB7XG4gICAgcmV0dXJuIHRoaXMubG9nZ2Vyc1tjYXRlZ29yeV07XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyID0gbmV3IExvZ2dlcih0aGlzLCBjYXRlZ29yeSk7XG4gICAgdGhpcy5sb2dnZXJzW2NhdGVnb3J5XSA9IGxvZ2dlcjtcbiAgICByZXR1cm4gbG9nZ2VyO1xuICB9XG59O1xuXG5yZXR1cm4gTG9nZ2VyRmFjdG9yeTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0xvZ2dlckZhY3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE5vZGVFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnNvbGUpIHtcblxuLy8gRG9uJ3QgdXNlIGBuZXcgU0lQLkV2ZW50RW1pdHRlcigpYCBmb3IgaW5oZXJpdGluZy5cbi8vIFVzZSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90b3lwZSk7XG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIgKCkge1xuICBOb2RlRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGVFdmVudEVtaXR0ZXIucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IEV2ZW50RW1pdHRlcixcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciB3YXJuaW5nID0gJyc7XG4gIHdhcm5pbmcgKz0gJ1NJUC5FdmVudEVtaXR0ZXIjb2ZmIGlzIGRlcHJlY2F0ZWQgYW5kIG1heSBiZSByZW1vdmVkIGluIGZ1dHVyZSBTSVAuanMgdmVyc2lvbnMuXFxuJztcbiAgd2FybmluZyArPSAnUGxlYXNlIHVzZSByZW1vdmVMaXN0ZW5lciBvciByZW1vdmVBbGxMaXN0ZW5lcnMgaW5zdGVhZC5cXG4nO1xuICB3YXJuaW5nICs9ICdTZWUgaGVyZSBmb3IgbW9yZSBkZXRhaWxzOlxcbic7XG4gIHdhcm5pbmcgKz0gJ2h0dHA6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNldmVudHNfZW1pdHRlcl9yZW1vdmVsaXN0ZW5lcl9ldmVudF9saXN0ZW5lcic7XG4gIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxufTtcblxucmV0dXJuIEV2ZW50RW1pdHRlcjtcblxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvRXZlbnRFbWl0dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9ldmVudHMvZXZlbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMjE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgQ29uc3RhbnRzXG4gKi9cblxuLyoqXG4gKiBTSVAgQ29uc3RhbnRzLlxuICogQGF1Z21lbnRzIFNJUFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUsIHZlcnNpb24pIHtcbnJldHVybiB7XG4gIFVTRVJfQUdFTlQ6IG5hbWUgKycvJysgdmVyc2lvbixcblxuICAvLyBTSVAgc2NoZW1lXG4gIFNJUDogICdzaXAnLFxuICBTSVBTOiAnc2lwcycsXG5cbiAgLy8gRW5kIGFuZCBGYWlsdXJlIGNhdXNlc1xuICBjYXVzZXM6IHtcbiAgICAvLyBHZW5lcmljIGVycm9yIGNhdXNlc1xuICAgIENPTk5FQ1RJT05fRVJST1I6ICAgICAgICAgJ0Nvbm5lY3Rpb24gRXJyb3InLFxuICAgIFJFUVVFU1RfVElNRU9VVDogICAgICAgICAgJ1JlcXVlc3QgVGltZW91dCcsXG4gICAgU0lQX0ZBSUxVUkVfQ09ERTogICAgICAgICAnU0lQIEZhaWx1cmUgQ29kZScsXG4gICAgSU5URVJOQUxfRVJST1I6ICAgICAgICAgICAnSW50ZXJuYWwgRXJyb3InLFxuXG4gICAgLy8gU0lQIGVycm9yIGNhdXNlc1xuICAgIEJVU1k6ICAgICAgICAgICAgICAgICAgICAgJ0J1c3knLFxuICAgIFJFSkVDVEVEOiAgICAgICAgICAgICAgICAgJ1JlamVjdGVkJyxcbiAgICBSRURJUkVDVEVEOiAgICAgICAgICAgICAgICdSZWRpcmVjdGVkJyxcbiAgICBVTkFWQUlMQUJMRTogICAgICAgICAgICAgICdVbmF2YWlsYWJsZScsXG4gICAgTk9UX0ZPVU5EOiAgICAgICAgICAgICAgICAnTm90IEZvdW5kJyxcbiAgICBBRERSRVNTX0lOQ09NUExFVEU6ICAgICAgICdBZGRyZXNzIEluY29tcGxldGUnLFxuICAgIElOQ09NUEFUSUJMRV9TRFA6ICAgICAgICAgJ0luY29tcGF0aWJsZSBTRFAnLFxuICAgIEFVVEhFTlRJQ0FUSU9OX0VSUk9SOiAgICAgJ0F1dGhlbnRpY2F0aW9uIEVycm9yJyxcbiAgICBESUFMT0dfRVJST1I6ICAgICAgICAgICAgICdEaWFsb2cgRXJyb3InLFxuXG4gICAgLy8gU2Vzc2lvbiBlcnJvciBjYXVzZXNcbiAgICBXRUJSVENfTk9UX1NVUFBPUlRFRDogICAgICdXZWJSVEMgTm90IFN1cHBvcnRlZCcsXG4gICAgV0VCUlRDX0VSUk9SOiAgICAgICAgICAgICAnV2ViUlRDIEVycm9yJyxcbiAgICBDQU5DRUxFRDogICAgICAgICAgICAgICAgICdDYW5jZWxlZCcsXG4gICAgTk9fQU5TV0VSOiAgICAgICAgICAgICAgICAnTm8gQW5zd2VyJyxcbiAgICBFWFBJUkVTOiAgICAgICAgICAgICAgICAgICdFeHBpcmVzJyxcbiAgICBOT19BQ0s6ICAgICAgICAgICAgICAgICAgICdObyBBQ0snLFxuICAgIE5PX1BSQUNLOiAgICAgICAgICAgICAgICAgJ05vIFBSQUNLJyxcbiAgICBVU0VSX0RFTklFRF9NRURJQV9BQ0NFU1M6ICdVc2VyIERlbmllZCBNZWRpYSBBY2Nlc3MnLFxuICAgIEJBRF9NRURJQV9ERVNDUklQVElPTjogICAgJ0JhZCBNZWRpYSBEZXNjcmlwdGlvbicsXG4gICAgUlRQX1RJTUVPVVQ6ICAgICAgICAgICAgICAnUlRQIFRpbWVvdXQnXG4gIH0sXG5cbiAgc3VwcG9ydGVkOiB7XG4gICAgVU5TVVBQT1JURUQ6ICAgICAgICAnbm9uZScsXG4gICAgU1VQUE9SVEVEOiAgICAgICAgICAnc3VwcG9ydGVkJyxcbiAgICBSRVFVSVJFRDogICAgICAgICAgICdyZXF1aXJlZCdcbiAgfSxcblxuICBTSVBfRVJST1JfQ0FVU0VTOiB7XG4gICAgUkVESVJFQ1RFRDogWzMwMCwzMDEsMzAyLDMwNSwzODBdLFxuICAgIEJVU1k6IFs0ODYsNjAwXSxcbiAgICBSRUpFQ1RFRDogWzQwMyw2MDNdLFxuICAgIE5PVF9GT1VORDogWzQwNCw2MDRdLFxuICAgIFVOQVZBSUxBQkxFOiBbNDgwLDQxMCw0MDgsNDMwXSxcbiAgICBBRERSRVNTX0lOQ09NUExFVEU6IFs0ODRdLFxuICAgIElOQ09NUEFUSUJMRV9TRFA6IFs0ODgsNjA2XSxcbiAgICBBVVRIRU5USUNBVElPTl9FUlJPUjpbNDAxLDQwN11cbiAgfSxcblxuICAvLyBTSVAgTWV0aG9kc1xuICBBQ0s6ICAgICAgICAnQUNLJyxcbiAgQllFOiAgICAgICAgJ0JZRScsXG4gIENBTkNFTDogICAgICdDQU5DRUwnLFxuICBJTkZPOiAgICAgICAnSU5GTycsXG4gIElOVklURTogICAgICdJTlZJVEUnLFxuICBNRVNTQUdFOiAgICAnTUVTU0FHRScsXG4gIE5PVElGWTogICAgICdOT1RJRlknLFxuICBPUFRJT05TOiAgICAnT1BUSU9OUycsXG4gIFJFR0lTVEVSOiAgICdSRUdJU1RFUicsXG4gIFVQREFURTogICAgICdVUERBVEUnLFxuICBTVUJTQ1JJQkU6ICAnU1VCU0NSSUJFJyxcbiAgUkVGRVI6ICAgICAgJ1JFRkVSJyxcbiAgUFJBQ0s6ICAgICAgJ1BSQUNLJyxcblxuICAvKiBTSVAgUmVzcG9uc2UgUmVhc29uc1xuICAgKiBET0M6IGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvc2lwLXBhcmFtZXRlcnNcbiAgICogQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3ZlcnNhdGljYS9PdmVyU0lQL2Jsb2IvbWFzdGVyL2xpYi9vdmVyc2lwL3NpcC9jb25zdGFudHMucmIjTDdcbiAgICovXG4gIFJFQVNPTl9QSFJBU0U6IHtcbiAgICAxMDA6ICdUcnlpbmcnLFxuICAgIDE4MDogJ1JpbmdpbmcnLFxuICAgIDE4MTogJ0NhbGwgSXMgQmVpbmcgRm9yd2FyZGVkJyxcbiAgICAxODI6ICdRdWV1ZWQnLFxuICAgIDE4MzogJ1Nlc3Npb24gUHJvZ3Jlc3MnLFxuICAgIDE5OTogJ0Vhcmx5IERpYWxvZyBUZXJtaW5hdGVkJywgIC8vIGRyYWZ0LWlldGYtc2lwY29yZS0xOTlcbiAgICAyMDA6ICdPSycsXG4gICAgMjAyOiAnQWNjZXB0ZWQnLCAgLy8gUkZDIDMyNjVcbiAgICAyMDQ6ICdObyBOb3RpZmljYXRpb24nLCAgLy9SRkMgNTgzOVxuICAgIDMwMDogJ011bHRpcGxlIENob2ljZXMnLFxuICAgIDMwMTogJ01vdmVkIFBlcm1hbmVudGx5JyxcbiAgICAzMDI6ICdNb3ZlZCBUZW1wb3JhcmlseScsXG4gICAgMzA1OiAnVXNlIFByb3h5JyxcbiAgICAzODA6ICdBbHRlcm5hdGl2ZSBTZXJ2aWNlJyxcbiAgICA0MDA6ICdCYWQgUmVxdWVzdCcsXG4gICAgNDAxOiAnVW5hdXRob3JpemVkJyxcbiAgICA0MDI6ICdQYXltZW50IFJlcXVpcmVkJyxcbiAgICA0MDM6ICdGb3JiaWRkZW4nLFxuICAgIDQwNDogJ05vdCBGb3VuZCcsXG4gICAgNDA1OiAnTWV0aG9kIE5vdCBBbGxvd2VkJyxcbiAgICA0MDY6ICdOb3QgQWNjZXB0YWJsZScsXG4gICAgNDA3OiAnUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWQnLFxuICAgIDQwODogJ1JlcXVlc3QgVGltZW91dCcsXG4gICAgNDEwOiAnR29uZScsXG4gICAgNDEyOiAnQ29uZGl0aW9uYWwgUmVxdWVzdCBGYWlsZWQnLCAgLy8gUkZDIDM5MDNcbiAgICA0MTM6ICdSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2UnLFxuICAgIDQxNDogJ1JlcXVlc3QtVVJJIFRvbyBMb25nJyxcbiAgICA0MTU6ICdVbnN1cHBvcnRlZCBNZWRpYSBUeXBlJyxcbiAgICA0MTY6ICdVbnN1cHBvcnRlZCBVUkkgU2NoZW1lJyxcbiAgICA0MTc6ICdVbmtub3duIFJlc291cmNlLVByaW9yaXR5JywgIC8vIFJGQyA0NDEyXG4gICAgNDIwOiAnQmFkIEV4dGVuc2lvbicsXG4gICAgNDIxOiAnRXh0ZW5zaW9uIFJlcXVpcmVkJyxcbiAgICA0MjI6ICdTZXNzaW9uIEludGVydmFsIFRvbyBTbWFsbCcsICAvLyBSRkMgNDAyOFxuICAgIDQyMzogJ0ludGVydmFsIFRvbyBCcmllZicsXG4gICAgNDI4OiAnVXNlIElkZW50aXR5IEhlYWRlcicsICAvLyBSRkMgNDQ3NFxuICAgIDQyOTogJ1Byb3ZpZGUgUmVmZXJyZXIgSWRlbnRpdHknLCAgLy8gUkZDIDM4OTJcbiAgICA0MzA6ICdGbG93IEZhaWxlZCcsICAvLyBSRkMgNTYyNlxuICAgIDQzMzogJ0Fub255bWl0eSBEaXNhbGxvd2VkJywgIC8vIFJGQyA1MDc5XG4gICAgNDM2OiAnQmFkIElkZW50aXR5LUluZm8nLCAgLy8gUkZDIDQ0NzRcbiAgICA0Mzc6ICdVbnN1cHBvcnRlZCBDZXJ0aWZpY2F0ZScsICAvLyBSRkMgNDc0NFxuICAgIDQzODogJ0ludmFsaWQgSWRlbnRpdHkgSGVhZGVyJywgIC8vIFJGQyA0NzQ0XG4gICAgNDM5OiAnRmlyc3QgSG9wIExhY2tzIE91dGJvdW5kIFN1cHBvcnQnLCAgLy8gUkZDIDU2MjZcbiAgICA0NDA6ICdNYXgtQnJlYWR0aCBFeGNlZWRlZCcsICAvLyBSRkMgNTM5M1xuICAgIDQ2OTogJ0JhZCBJbmZvIFBhY2thZ2UnLCAgLy8gZHJhZnQtaWV0Zi1zaXBjb3JlLWluZm8tZXZlbnRzXG4gICAgNDcwOiAnQ29uc2VudCBOZWVkZWQnLCAgLy8gUkZDIDUzNjBcbiAgICA0Nzg6ICdVbnJlc29sdmFibGUgRGVzdGluYXRpb24nLCAgLy8gQ3VzdG9tIGNvZGUgY29waWVkIGZyb20gS2FtYWlsaW8uXG4gICAgNDgwOiAnVGVtcG9yYXJpbHkgVW5hdmFpbGFibGUnLFxuICAgIDQ4MTogJ0NhbGwvVHJhbnNhY3Rpb24gRG9lcyBOb3QgRXhpc3QnLFxuICAgIDQ4MjogJ0xvb3AgRGV0ZWN0ZWQnLFxuICAgIDQ4MzogJ1RvbyBNYW55IEhvcHMnLFxuICAgIDQ4NDogJ0FkZHJlc3MgSW5jb21wbGV0ZScsXG4gICAgNDg1OiAnQW1iaWd1b3VzJyxcbiAgICA0ODY6ICdCdXN5IEhlcmUnLFxuICAgIDQ4NzogJ1JlcXVlc3QgVGVybWluYXRlZCcsXG4gICAgNDg4OiAnTm90IEFjY2VwdGFibGUgSGVyZScsXG4gICAgNDg5OiAnQmFkIEV2ZW50JywgIC8vIFJGQyAzMjY1XG4gICAgNDkxOiAnUmVxdWVzdCBQZW5kaW5nJyxcbiAgICA0OTM6ICdVbmRlY2lwaGVyYWJsZScsXG4gICAgNDk0OiAnU2VjdXJpdHkgQWdyZWVtZW50IFJlcXVpcmVkJywgIC8vIFJGQyAzMzI5XG4gICAgNTAwOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJyxcbiAgICA1MDE6ICdOb3QgSW1wbGVtZW50ZWQnLFxuICAgIDUwMjogJ0JhZCBHYXRld2F5JyxcbiAgICA1MDM6ICdTZXJ2aWNlIFVuYXZhaWxhYmxlJyxcbiAgICA1MDQ6ICdTZXJ2ZXIgVGltZS1vdXQnLFxuICAgIDUwNTogJ1ZlcnNpb24gTm90IFN1cHBvcnRlZCcsXG4gICAgNTEzOiAnTWVzc2FnZSBUb28gTGFyZ2UnLFxuICAgIDU4MDogJ1ByZWNvbmRpdGlvbiBGYWlsdXJlJywgIC8vIFJGQyAzMzEyXG4gICAgNjAwOiAnQnVzeSBFdmVyeXdoZXJlJyxcbiAgICA2MDM6ICdEZWNsaW5lJyxcbiAgICA2MDQ6ICdEb2VzIE5vdCBFeGlzdCBBbnl3aGVyZScsXG4gICAgNjA2OiAnTm90IEFjY2VwdGFibGUnXG4gIH0sXG5cbiAgLyogU0lQIE9wdGlvbiBUYWdzXG4gICAqIERPQzogaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9zaXAtcGFyYW1ldGVycy9zaXAtcGFyYW1ldGVycy54aHRtbCNzaXAtcGFyYW1ldGVycy00XG4gICAqL1xuICBPUFRJT05fVEFHUzoge1xuICAgICcxMDByZWwnOiAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDMyNjJcbiAgICAxOTk6ICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA2MjI4XG4gICAgYW5zd2VybW9kZTogICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNTM3M1xuICAgICdlYXJseS1zZXNzaW9uJzogICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDM5NTlcbiAgICBldmVudGxpc3Q6ICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA0NjYyXG4gICAgZXhwbGljaXRzdWI6ICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMtaWV0Zi1zaXBjb3JlLXJlZmVyLWV4cGxpY2l0LXN1YnNjcmlwdGlvbi0wM1xuICAgICdmcm9tLWNoYW5nZSc6ICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQ5MTZcbiAgICAnZ2VvbG9jYXRpb24taHR0cCc6ICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA2NDQyXG4gICAgJ2dlb2xvY2F0aW9uLXNpcCc6ICAgICAgICAgIHRydWUsICAvLyBSRkMgNjQ0MlxuICAgIGdpbjogICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDYxNDBcbiAgICBncnV1OiAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1NjI3XG4gICAgaGlzdGluZm86ICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNzA0NFxuICAgIGljZTogICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDU3NjhcbiAgICBqb2luOiAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzOTExXG4gICAgJ211bHRpcGxlLXJlZmVyJzogICAgICAgICAgIHRydWUsICAvLyBSRkMgNTM2OFxuICAgIG5vcmVmZXJzdWI6ICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQ0ODhcbiAgICBub3N1YjogICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQy1pZXRmLXNpcGNvcmUtcmVmZXItZXhwbGljaXQtc3Vic2NyaXB0aW9uLTAzXG4gICAgb3V0Ym91bmQ6ICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNTYyNlxuICAgIHBhdGg6ICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDMzMjdcbiAgICBwb2xpY3k6ICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA2Nzk0XG4gICAgcHJlY29uZGl0aW9uOiAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzMxMlxuICAgIHByZWY6ICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDM4NDBcbiAgICBwcml2YWN5OiAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzMzIzXG4gICAgJ3JlY2lwaWVudC1saXN0LWludml0ZSc6ICAgIHRydWUsICAvLyBSRkMgNTM2NlxuICAgICdyZWNpcGllbnQtbGlzdC1tZXNzYWdlJzogICB0cnVlLCAgLy8gUkZDIDUzNjVcbiAgICAncmVjaXBpZW50LWxpc3Qtc3Vic2NyaWJlJzogdHJ1ZSwgIC8vIFJGQyA1MzY3XG4gICAgcmVwbGFjZXM6ICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzg5MVxuICAgICdyZXNvdXJjZS1wcmlvcml0eSc6ICAgICAgICB0cnVlLCAgLy8gUkZDIDQ0MTJcbiAgICAnc2RwLWFuYXQnOiAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA0MDkyXG4gICAgJ3NlYy1hZ3JlZSc6ICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzMyOVxuICAgIHRkaWFsb2c6ICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQ1MzhcbiAgICB0aW1lcjogICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA0MDI4XG4gICAgdXVpOiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgICAvLyBSRkMgNzQzM1xuICB9XG59O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvQ29uc3RhbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMjE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBFeGNlcHRpb25zXG4gKi9cblxuLyoqXG4gKiBTSVAgRXhjZXB0aW9ucy5cbiAqIEBhdWdtZW50cyBTSVBcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENvbmZpZ3VyYXRpb25FcnJvcjogKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IGZ1bmN0aW9uKHBhcmFtZXRlciwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY29kZSA9IDE7XG4gICAgICB0aGlzLm5hbWUgPSAnQ09ORklHVVJBVElPTl9FUlJPUic7XG4gICAgICB0aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMubWVzc2FnZSA9ICghdGhpcy52YWx1ZSk/ICdNaXNzaW5nIHBhcmFtZXRlcjogJysgdGhpcy5wYXJhbWV0ZXIgOiAnSW52YWxpZCB2YWx1ZSAnKyBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlKSArJyBmb3IgcGFyYW1ldGVyIFwiJysgdGhpcy5wYXJhbWV0ZXIgKydcIic7XG4gICAgfTtcbiAgICBleGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgcmV0dXJuIGV4Y2VwdGlvbjtcbiAgfSgpKSxcblxuICBJbnZhbGlkU3RhdGVFcnJvcjogKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgdGhpcy5jb2RlID0gMjtcbiAgICAgIHRoaXMubmFtZSA9ICdJTlZBTElEX1NUQVRFX0VSUk9SJztcbiAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgdGhpcy5tZXNzYWdlID0gJ0ludmFsaWQgc3RhdHVzOiAnICsgc3RhdHVzO1xuICAgIH07XG4gICAgZXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgIHJldHVybiBleGNlcHRpb247XG4gIH0oKSksXG5cbiAgTm90U3VwcG9ydGVkRXJyb3I6IChmdW5jdGlvbigpe1xuICAgIHZhciBleGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICB0aGlzLmNvZGUgPSAzO1xuICAgICAgdGhpcy5uYW1lID0gJ05PVF9TVVBQT1JURURfRVJST1InO1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9O1xuICAgIGV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICByZXR1cm4gZXhjZXB0aW9uO1xuICB9KCkpLFxuXG4gIEdldERlc2NyaXB0aW9uRXJyb3I6IChmdW5jdGlvbigpe1xuICAgIHZhciBleGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICB0aGlzLmNvZGUgPSA0O1xuICAgICAgdGhpcy5uYW1lID0gJ0dFVF9ERVNDUklQVElPTl9FUlJPUic7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH07XG4gICAgZXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgIHJldHVybiBleGNlcHRpb247XG4gIH0oKSlcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0V4Y2VwdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBUSU1FUlNcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqL1xudmFyXG4gIFQxID0gNTAwLFxuICBUMiA9IDQwMDAsXG4gIFQ0ID0gNTAwMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRpbWVycykge1xuICB2YXIgVGltZXJzID0ge1xuICAgIFQxOiBUMSxcbiAgICBUMjogVDIsXG4gICAgVDQ6IFQ0LFxuICAgIFRJTUVSX0I6IDY0ICogVDEsXG4gICAgVElNRVJfRDogMCAgKiBUMSxcbiAgICBUSU1FUl9GOiA2NCAqIFQxLFxuICAgIFRJTUVSX0g6IDY0ICogVDEsXG4gICAgVElNRVJfSTogMCAgKiBUMSxcbiAgICBUSU1FUl9KOiAwICAqIFQxLFxuICAgIFRJTUVSX0s6IDAgICogVDQsXG4gICAgVElNRVJfTDogNjQgKiBUMSxcbiAgICBUSU1FUl9NOiA2NCAqIFQxLFxuICAgIFRJTUVSX046IDY0ICogVDEsXG4gICAgUFJPVklTSU9OQUxfUkVTUE9OU0VfSU5URVJWQUw6IDYwMDAwICAvLyBTZWUgUkZDIDMyNjEgU2VjdGlvbiAxMy4zLjEuMVxuICB9O1xuXG4gIFsnc2V0VGltZW91dCcsICdjbGVhclRpbWVvdXQnLCAnc2V0SW50ZXJ2YWwnLCAnY2xlYXJJbnRlcnZhbCddXG4gIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8gY2FuJ3QganVzdCB1c2UgdGltZXJzW25hbWVdLmJpbmQodGltZXJzKSBzaW5jZSBpdCBieXBhc3NlcyBqYXNtaW5lJ3NcbiAgICAvLyBjbG9jay1tb2NraW5nXG4gICAgVGltZXJzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRpbWVyc1tuYW1lXS5hcHBseSh0aW1lcnMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIFRpbWVycztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1RpbWVycy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIE1lc3NhZ2UgUGFyc2VyXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IGFuZCBwYXJzZSBldmVyeSBoZWFkZXIgb2YgYSBTSVAgbWVzc2FnZS5cbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBuYW1lc3BhY2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgUGFyc2VyO1xuXG5mdW5jdGlvbiBnZXRIZWFkZXIoZGF0YSwgaGVhZGVyU3RhcnQpIHtcbiAgdmFyXG4gICAgLy8gJ3N0YXJ0JyBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyLlxuICAgIHN0YXJ0ID0gaGVhZGVyU3RhcnQsXG4gICAgLy8gJ2VuZCcgcG9zaXRpb24gb2YgdGhlIGhlYWRlci5cbiAgICBlbmQgPSAwLFxuICAgIC8vICdwYXJ0aWFsIGVuZCcgcG9zaXRpb24gb2YgdGhlIGhlYWRlci5cbiAgICBwYXJ0aWFsRW5kID0gMDtcblxuICAvL0VuZCBvZiBtZXNzYWdlLlxuICBpZiAoZGF0YS5zdWJzdHJpbmcoc3RhcnQsIHN0YXJ0ICsgMikubWF0Y2goLyheXFxyXFxuKS8pKSB7XG4gICAgcmV0dXJuIC0yO1xuICB9XG5cbiAgd2hpbGUoZW5kID09PSAwKSB7XG4gICAgLy8gUGFydGlhbCBFbmQgb2YgSGVhZGVyLlxuICAgIHBhcnRpYWxFbmQgPSBkYXRhLmluZGV4T2YoJ1xcclxcbicsIHN0YXJ0KTtcblxuICAgIC8vICdpbmRleE9mJyByZXR1cm5zIC0xIGlmIHRoZSB2YWx1ZSB0byBiZSBmb3VuZCBuZXZlciBvY2N1cnMuXG4gICAgaWYgKHBhcnRpYWxFbmQgPT09IC0xKSB7XG4gICAgICByZXR1cm4gcGFydGlhbEVuZDtcbiAgICB9XG5cbiAgICBpZighZGF0YS5zdWJzdHJpbmcocGFydGlhbEVuZCArIDIsIHBhcnRpYWxFbmQgKyA0KS5tYXRjaCgvKF5cXHJcXG4pLykgJiYgZGF0YS5jaGFyQXQocGFydGlhbEVuZCArIDIpLm1hdGNoKC8oXlxccyspLykpIHtcbiAgICAgIC8vIE5vdCB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlLiBDb250aW51ZSBmcm9tIHRoZSBuZXh0IHBvc2l0aW9uLlxuICAgICAgc3RhcnQgPSBwYXJ0aWFsRW5kICsgMjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gcGFydGlhbEVuZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW5kO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcihtZXNzYWdlLCBkYXRhLCBoZWFkZXJTdGFydCwgaGVhZGVyRW5kKSB7XG4gIHZhciBoZWFkZXIsIGlkeCwgbGVuZ3RoLCBwYXJzZWQsXG4gICAgaGNvbG9uSW5kZXggPSBkYXRhLmluZGV4T2YoJzonLCBoZWFkZXJTdGFydCksXG4gICAgaGVhZGVyTmFtZSA9IGRhdGEuc3Vic3RyaW5nKGhlYWRlclN0YXJ0LCBoY29sb25JbmRleCkudHJpbSgpLFxuICAgIGhlYWRlclZhbHVlID0gZGF0YS5zdWJzdHJpbmcoaGNvbG9uSW5kZXggKyAxLCBoZWFkZXJFbmQpLnRyaW0oKTtcblxuICAvLyBJZiBoZWFkZXItZmllbGQgaXMgd2VsbC1rbm93biwgcGFyc2UgaXQuXG4gIHN3aXRjaChoZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICd2aWEnOlxuICAgIGNhc2UgJ3YnOlxuICAgICAgbWVzc2FnZS5hZGRIZWFkZXIoJ3ZpYScsIGhlYWRlclZhbHVlKTtcbiAgICAgIGlmKG1lc3NhZ2UuZ2V0SGVhZGVycygndmlhJykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ1ZpYScpO1xuICAgICAgICBpZihwYXJzZWQpIHtcbiAgICAgICAgICBtZXNzYWdlLnZpYSA9IHBhcnNlZDtcbiAgICAgICAgICBtZXNzYWdlLnZpYV9icmFuY2ggPSBwYXJzZWQuYnJhbmNoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQgPSAwO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZnJvbSc6XG4gICAgY2FzZSAnZic6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcignZnJvbScsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2Zyb20nKTtcbiAgICAgIGlmKHBhcnNlZCkge1xuICAgICAgICBtZXNzYWdlLmZyb20gPSBwYXJzZWQ7XG4gICAgICAgIG1lc3NhZ2UuZnJvbV90YWcgPSBwYXJzZWQuZ2V0UGFyYW0oJ3RhZycpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndG8nOlxuICAgIGNhc2UgJ3QnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ3RvJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcigndG8nKTtcbiAgICAgIGlmKHBhcnNlZCkge1xuICAgICAgICBtZXNzYWdlLnRvID0gcGFyc2VkO1xuICAgICAgICBtZXNzYWdlLnRvX3RhZyA9IHBhcnNlZC5nZXRQYXJhbSgndGFnJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWNvcmQtcm91dGUnOlxuICAgICAgcGFyc2VkID0gU0lQLkdyYW1tYXIucGFyc2UoaGVhZGVyVmFsdWUsICdSZWNvcmRfUm91dGUnKTtcblxuICAgICAgaWYgKHBhcnNlZCA9PT0gLTEpIHtcbiAgICAgICAgcGFyc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoID0gcGFyc2VkLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBoZWFkZXIgPSBwYXJzZWRbaWR4XTtcbiAgICAgICAgbWVzc2FnZS5hZGRIZWFkZXIoJ3JlY29yZC1yb3V0ZScsIGhlYWRlclZhbHVlLnN1YnN0cmluZyhoZWFkZXIucG9zaXRpb24sIGhlYWRlci5vZmZzZXQpKTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJzWydSZWNvcmQtUm91dGUnXVttZXNzYWdlLmdldEhlYWRlcnMoJ3JlY29yZC1yb3V0ZScpLmxlbmd0aCAtIDFdLnBhcnNlZCA9IGhlYWRlci5wYXJzZWQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjYWxsLWlkJzpcbiAgICBjYXNlICdpJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdjYWxsLWlkJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignY2FsbC1pZCcpO1xuICAgICAgaWYocGFyc2VkKSB7XG4gICAgICAgIG1lc3NhZ2UuY2FsbF9pZCA9IGhlYWRlclZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY29udGFjdCc6XG4gICAgY2FzZSAnbSc6XG4gICAgICBwYXJzZWQgPSBTSVAuR3JhbW1hci5wYXJzZShoZWFkZXJWYWx1ZSwgJ0NvbnRhY3QnKTtcblxuICAgICAgaWYgKHBhcnNlZCA9PT0gLTEpIHtcbiAgICAgICAgcGFyc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoID0gcGFyc2VkLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBoZWFkZXIgPSBwYXJzZWRbaWR4XTtcbiAgICAgICAgbWVzc2FnZS5hZGRIZWFkZXIoJ2NvbnRhY3QnLCBoZWFkZXJWYWx1ZS5zdWJzdHJpbmcoaGVhZGVyLnBvc2l0aW9uLCBoZWFkZXIub2Zmc2V0KSk7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyc1snQ29udGFjdCddW21lc3NhZ2UuZ2V0SGVhZGVycygnY29udGFjdCcpLmxlbmd0aCAtIDFdLnBhcnNlZCA9IGhlYWRlci5wYXJzZWQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb250ZW50LWxlbmd0aCc6XG4gICAgY2FzZSAnbCc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcignY29udGVudC1sZW5ndGgnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdjb250ZW50LWxlbmd0aCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY29udGVudC10eXBlJzpcbiAgICBjYXNlICdjJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NzZXEnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ2NzZXEnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdjc2VxJyk7XG4gICAgICBpZihwYXJzZWQpIHtcbiAgICAgICAgbWVzc2FnZS5jc2VxID0gcGFyc2VkLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYobWVzc2FnZSBpbnN0YW5jZW9mIFNJUC5JbmNvbWluZ1Jlc3BvbnNlKSB7XG4gICAgICAgIG1lc3NhZ2UubWV0aG9kID0gcGFyc2VkLm1ldGhvZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21heC1mb3J3YXJkcyc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcignbWF4LWZvcndhcmRzJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignbWF4LWZvcndhcmRzJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3d3ctYXV0aGVudGljYXRlJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCd3d3ctYXV0aGVudGljYXRlJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignd3d3LWF1dGhlbnRpY2F0ZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHJveHktYXV0aGVudGljYXRlJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdwcm94eS1hdXRoZW50aWNhdGUnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdwcm94eS1hdXRoZW50aWNhdGUnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlZmVyLXRvJzpcbiAgICBjYXNlICdyJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdyZWZlci10bycsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ3JlZmVyLXRvJyk7XG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIG1lc3NhZ2UucmVmZXJfdG8gPSBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRG8gbm90IHBhcnNlIHRoaXMgaGVhZGVyLlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gMDtcbiAgfVxuXG4gIGlmIChwYXJzZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogJ2Vycm9yIHBhcnNpbmcgaGVhZGVyIFwiJysgaGVhZGVyTmFtZSArJ1wiJ1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqIFBhcnNlIFNJUCBNZXNzYWdlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFNJUCBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGxvZ2dlciBvYmplY3QuXG4gKiBAcmV0dXJucyB7U0lQLkluY29taW5nUmVxdWVzdHxTSVAuSW5jb21pbmdSZXNwb25zZXx1bmRlZmluZWR9XG4gKi9cblBhcnNlciA9IHt9O1xuUGFyc2VyLnBhcnNlTWVzc2FnZSA9IGZ1bmN0aW9uKGRhdGEsIHVhKSB7XG4gIHZhciBtZXNzYWdlLCBmaXJzdExpbmUsIGNvbnRlbnRMZW5ndGgsIGJvZHlTdGFydCwgcGFyc2VkLFxuICAgIGhlYWRlclN0YXJ0ID0gMCxcbiAgICBoZWFkZXJFbmQgPSBkYXRhLmluZGV4T2YoJ1xcclxcbicpLFxuICAgIGxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnBhcnNlcicpO1xuXG4gIGlmKGhlYWRlckVuZCA9PT0gLTEpIHtcbiAgICBsb2dnZXIud2Fybignbm8gQ1JMRiBmb3VuZCwgbm90IGEgU0lQIG1lc3NhZ2UsIGRpc2NhcmRlZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFBhcnNlIGZpcnN0IGxpbmUuIENoZWNrIGlmIGl0IGlzIGEgUmVxdWVzdCBvciBhIFJlcGx5LlxuICBmaXJzdExpbmUgPSBkYXRhLnN1YnN0cmluZygwLCBoZWFkZXJFbmQpO1xuICBwYXJzZWQgPSBTSVAuR3JhbW1hci5wYXJzZShmaXJzdExpbmUsICdSZXF1ZXN0X1Jlc3BvbnNlJyk7XG5cbiAgaWYocGFyc2VkID09PSAtMSkge1xuICAgIGxvZ2dlci53YXJuKCdlcnJvciBwYXJzaW5nIGZpcnN0IGxpbmUgb2YgU0lQIG1lc3NhZ2U6IFwiJyArIGZpcnN0TGluZSArICdcIicpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmKCFwYXJzZWQuc3RhdHVzX2NvZGUpIHtcbiAgICBtZXNzYWdlID0gbmV3IFNJUC5JbmNvbWluZ1JlcXVlc3QodWEpO1xuICAgIG1lc3NhZ2UubWV0aG9kID0gcGFyc2VkLm1ldGhvZDtcbiAgICBtZXNzYWdlLnJ1cmkgPSBwYXJzZWQudXJpO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UgPSBuZXcgU0lQLkluY29taW5nUmVzcG9uc2UodWEpO1xuICAgIG1lc3NhZ2Uuc3RhdHVzX2NvZGUgPSBwYXJzZWQuc3RhdHVzX2NvZGU7XG4gICAgbWVzc2FnZS5yZWFzb25fcGhyYXNlID0gcGFyc2VkLnJlYXNvbl9waHJhc2U7XG4gIH1cblxuICBtZXNzYWdlLmRhdGEgPSBkYXRhO1xuICBoZWFkZXJTdGFydCA9IGhlYWRlckVuZCArIDI7XG5cbiAgLyogTG9vcCBvdmVyIGV2ZXJ5IGxpbmUgaW4gZGF0YS4gRGV0ZWN0IHRoZSBlbmQgb2YgZWFjaCBoZWFkZXIgYW5kIHBhcnNlXG4gICogaXQgb3Igc2ltcGx5IGFkZCB0byB0aGUgaGVhZGVycyBjb2xsZWN0aW9uLlxuICAqL1xuICB3aGlsZSh0cnVlKSB7XG4gICAgaGVhZGVyRW5kID0gZ2V0SGVhZGVyKGRhdGEsIGhlYWRlclN0YXJ0KTtcblxuICAgIC8vIFRoZSBTSVAgbWVzc2FnZSBoYXMgbm9ybWFsbHkgZmluaXNoZWQuXG4gICAgaWYoaGVhZGVyRW5kID09PSAtMikge1xuICAgICAgYm9keVN0YXJ0ID0gaGVhZGVyU3RhcnQgKyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIGRhdGEuaW5kZXhPZiByZXR1cm5lZCAtMSBkdWUgdG8gYSBtYWxmb3JtZWQgbWVzc2FnZS5cbiAgICBlbHNlIGlmKGhlYWRlckVuZCA9PT0gLTEpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignbWFsZm9ybWVkIG1lc3NhZ2UnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwYXJzZWQgPSBwYXJzZUhlYWRlcihtZXNzYWdlLCBkYXRhLCBoZWFkZXJTdGFydCwgaGVhZGVyRW5kKTtcblxuICAgIGlmKHBhcnNlZCAhPT0gdHJ1ZSkge1xuICAgICAgbG9nZ2VyLmVycm9yKHBhcnNlZC5lcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGVhZGVyU3RhcnQgPSBoZWFkZXJFbmQgKyAyO1xuICB9XG5cbiAgLyogUkZDMzI2MSAxOC4zLlxuICAgKiBJZiB0aGVyZSBhcmUgYWRkaXRpb25hbCBieXRlcyBpbiB0aGUgdHJhbnNwb3J0IHBhY2tldFxuICAgKiBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgYm9keSwgdGhleSBNVVNUIGJlIGRpc2NhcmRlZC5cbiAgICovXG4gIGlmKG1lc3NhZ2UuaGFzSGVhZGVyKCdjb250ZW50LWxlbmd0aCcpKSB7XG4gICAgY29udGVudExlbmd0aCA9IG1lc3NhZ2UuZ2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcpO1xuICAgIG1lc3NhZ2UuYm9keSA9IGRhdGEuc3Vic3RyKGJvZHlTdGFydCwgY29udGVudExlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZS5ib2R5ID0gZGF0YS5zdWJzdHJpbmcoYm9keVN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlO1xufTtcblxuU0lQLlBhcnNlciA9IFBhcnNlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1BhcnNlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIE1lc3NhZ2VcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhclxuICBPdXRnb2luZ1JlcXVlc3QsXG4gIEluY29taW5nTWVzc2FnZSxcbiAgSW5jb21pbmdSZXF1ZXN0LFxuICBJbmNvbWluZ1Jlc3BvbnNlO1xuXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRIZWFkZXIgKHJlcXVlc3QpIHtcbiAgdmFyIGFsbG93VW5yZWdpc3RlcmVkID0gcmVxdWVzdC51YS5jb25maWd1cmF0aW9uLmhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3M7XG4gIHZhciBvcHRpb25UYWdzID0gW107XG4gIHZhciBvcHRpb25UYWdTZXQgPSB7fTtcblxuICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFNJUC5DLlJFR0lTVEVSKSB7XG4gICAgb3B0aW9uVGFncy5wdXNoKCdwYXRoJywgJ2dydXUnKTtcbiAgfSBlbHNlIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gU0lQLkMuSU5WSVRFICYmXG4gICAgICAgICAgICAgKHJlcXVlc3QudWEuY29udGFjdC5wdWJfZ3J1dSB8fCByZXF1ZXN0LnVhLmNvbnRhY3QudGVtcF9ncnV1KSkge1xuICAgIG9wdGlvblRhZ3MucHVzaCgnZ3J1dScpO1xuICB9XG5cbiAgaWYgKHJlcXVlc3QudWEuY29uZmlndXJhdGlvbi5yZWwxMDAgPT09IFNJUC5DLnN1cHBvcnRlZC5TVVBQT1JURUQpIHtcbiAgICBvcHRpb25UYWdzLnB1c2goJzEwMHJlbCcpO1xuICB9XG4gIGlmIChyZXF1ZXN0LnVhLmNvbmZpZ3VyYXRpb24ucmVwbGFjZXMgPT09IFNJUC5DLnN1cHBvcnRlZC5TVVBQT1JURUQpIHtcbiAgICBvcHRpb25UYWdzLnB1c2goJ3JlcGxhY2VzJyk7XG4gIH1cblxuICBvcHRpb25UYWdzLnB1c2goJ291dGJvdW5kJyk7XG5cbiAgb3B0aW9uVGFncyA9IG9wdGlvblRhZ3MuY29uY2F0KHJlcXVlc3QudWEuY29uZmlndXJhdGlvbi5leHRyYVN1cHBvcnRlZCk7XG5cbiAgb3B0aW9uVGFncyA9IG9wdGlvblRhZ3MuZmlsdGVyKGZ1bmN0aW9uKG9wdGlvblRhZykge1xuICAgIHZhciByZWdpc3RlcmVkID0gU0lQLkMuT1BUSU9OX1RBR1Nbb3B0aW9uVGFnXTtcbiAgICB2YXIgdW5pcXVlID0gIW9wdGlvblRhZ1NldFtvcHRpb25UYWddO1xuICAgIG9wdGlvblRhZ1NldFtvcHRpb25UYWddID0gdHJ1ZTtcbiAgICByZXR1cm4gKHJlZ2lzdGVyZWQgfHwgYWxsb3dVbnJlZ2lzdGVyZWQpICYmIHVuaXF1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuICdTdXBwb3J0ZWQ6ICcgKyBvcHRpb25UYWdzLmpvaW4oJywgJykgKyAnXFxyXFxuJztcbn1cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgZm9yIG91dGdvaW5nIFNJUCByZXF1ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCByZXF1ZXN0IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHJ1cmkgcmVxdWVzdCB1cmlcbiAqIEBwYXJhbSB7U0lQLlVBfSB1YVxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBoYXZlIHByaW9yaXR5IG92ZXIgdWEuY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICogPGJyPlxuICogIC0gY3NlcSwgY2FsbF9pZCwgZnJvbV90YWcsIGZyb21fdXJpLCBmcm9tX2Rpc3BsYXlOYW1lLCB0b191cmksIHRvX3RhZywgcm91dGVfc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gW2hlYWRlcnNdIGV4dHJhIGhlYWRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbYm9keV1cbiAqL1xuT3V0Z29pbmdSZXF1ZXN0ID0gZnVuY3Rpb24obWV0aG9kLCBydXJpLCB1YSwgcGFyYW1zLCBleHRyYUhlYWRlcnMsIGJvZHkpIHtcbiAgdmFyXG4gICAgdG8sXG4gICAgZnJvbSxcbiAgICBjYWxsX2lkLFxuICAgIGNzZXEsXG4gICAgdG9fdXJpLFxuICAgIGZyb21fdXJpO1xuXG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAvLyBNYW5kYXRvcnkgcGFyYW1ldGVycyBjaGVja1xuICBpZighbWV0aG9kIHx8ICFydXJpIHx8ICF1YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5zaXBtZXNzYWdlJyk7XG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy5oZWFkZXJzID0ge307XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnJ1cmkgPSBydXJpO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuICB0aGlzLmV4dHJhSGVhZGVycyA9IChleHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gIHRoaXMuc3RhdHVzQ29kZSA9IHBhcmFtcy5zdGF0dXNfY29kZTtcbiAgdGhpcy5yZWFzb25QaHJhc2UgPSBwYXJhbXMucmVhc29uX3BocmFzZTtcblxuICAvLyBGaWxsIHRoZSBDb21tb24gU0lQIFJlcXVlc3QgSGVhZGVyc1xuXG4gIC8vIFJvdXRlXG4gIGlmIChwYXJhbXMucm91dGVfc2V0KSB7XG4gICAgdGhpcy5zZXRIZWFkZXIoJ3JvdXRlJywgcGFyYW1zLnJvdXRlX3NldCk7XG4gIH0gZWxzZSBpZiAodWEuY29uZmlndXJhdGlvbi51c2VQcmVsb2FkZWRSb3V0ZSl7XG4gICAgdGhpcy5zZXRIZWFkZXIoJ3JvdXRlJywgdWEudHJhbnNwb3J0LnNlcnZlci5zaXBfdXJpKTtcbiAgfVxuXG4gIC8vIFZpYVxuICAvLyBFbXB0eSBWaWEgaGVhZGVyLiBXaWxsIGJlIGZpbGxlZCBieSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uLlxuICB0aGlzLnNldEhlYWRlcigndmlhJywgJycpO1xuXG4gIC8vIE1heC1Gb3J3YXJkc1xuICB0aGlzLnNldEhlYWRlcignbWF4LWZvcndhcmRzJywgU0lQLlVBLkMuTUFYX0ZPUldBUkRTKTtcblxuICAvLyBUb1xuICB0b191cmkgPSBwYXJhbXMudG9fdXJpIHx8IHJ1cmk7XG4gIHRvID0gKHBhcmFtcy50b19kaXNwbGF5TmFtZSB8fCBwYXJhbXMudG9fZGlzcGxheU5hbWUgPT09IDApID8gJ1wiJyArIHBhcmFtcy50b19kaXNwbGF5TmFtZSArICdcIiAnIDogJyc7XG4gIHRvICs9ICc8JyArICh0b191cmkgJiYgdG9fdXJpLnRvUmF3ID8gdG9fdXJpLnRvUmF3KCkgOiB0b191cmkpICsgJz4nO1xuICB0byArPSBwYXJhbXMudG9fdGFnID8gJzt0YWc9JyArIHBhcmFtcy50b190YWcgOiAnJztcbiAgdGhpcy50byA9IG5ldyBTSVAuTmFtZUFkZHJIZWFkZXIucGFyc2UodG8pO1xuICB0aGlzLnNldEhlYWRlcigndG8nLCB0byk7XG5cbiAgLy8gRnJvbVxuICBmcm9tX3VyaSA9IHBhcmFtcy5mcm9tX3VyaSB8fCB1YS5jb25maWd1cmF0aW9uLnVyaTtcbiAgaWYgKHBhcmFtcy5mcm9tX2Rpc3BsYXlOYW1lIHx8IHBhcmFtcy5mcm9tX2Rpc3BsYXlOYW1lID09PSAwKSB7XG4gICAgZnJvbSA9ICdcIicgKyBwYXJhbXMuZnJvbV9kaXNwbGF5TmFtZSArICdcIiAnO1xuICB9IGVsc2UgaWYgKHVhLmNvbmZpZ3VyYXRpb24uZGlzcGxheU5hbWUpIHtcbiAgICBmcm9tID0gJ1wiJyArIHVhLmNvbmZpZ3VyYXRpb24uZGlzcGxheU5hbWUgKyAnXCIgJztcbiAgfSBlbHNlIHtcbiAgICBmcm9tID0gJyc7XG4gIH1cbiAgZnJvbSArPSAnPCcgKyAoZnJvbV91cmkgJiYgZnJvbV91cmkudG9SYXcgPyBmcm9tX3VyaS50b1JhdygpIDogZnJvbV91cmkpICsgJz47dGFnPSc7XG4gIGZyb20gKz0gcGFyYW1zLmZyb21fdGFnIHx8IFNJUC5VdGlscy5uZXdUYWcoKTtcbiAgdGhpcy5mcm9tID0gbmV3IFNJUC5OYW1lQWRkckhlYWRlci5wYXJzZShmcm9tKTtcbiAgdGhpcy5zZXRIZWFkZXIoJ2Zyb20nLCBmcm9tKTtcblxuICAvLyBDYWxsLUlEXG4gIGNhbGxfaWQgPSBwYXJhbXMuY2FsbF9pZCB8fCAodWEuY29uZmlndXJhdGlvbi5zaXBqc0lkICsgU0lQLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDE1KSk7XG4gIHRoaXMuY2FsbF9pZCA9IGNhbGxfaWQ7XG4gIHRoaXMuc2V0SGVhZGVyKCdjYWxsLWlkJywgY2FsbF9pZCk7XG5cbiAgLy8gQ1NlcVxuICBjc2VxID0gcGFyYW1zLmNzZXEgfHwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICB0aGlzLmNzZXEgPSBjc2VxO1xuICB0aGlzLnNldEhlYWRlcignY3NlcScsIGNzZXEgKyAnICcgKyBtZXRob2QpO1xufTtcblxuT3V0Z29pbmdSZXF1ZXN0LnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIHRoZSBnaXZlbiBoZWFkZXIgYnkgdGhlIGdpdmVuIHZhbHVlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSB2YWx1ZSBoZWFkZXIgdmFsdWVcbiAgICovXG4gIHNldEhlYWRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV0gPSAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGhlYWRlciBuYW1lIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge1N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIHNwZWNpZmllZCBoZWFkZXIsIHVuZGVmaW5lZCBpZiBoZWFkZXIgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGdldEhlYWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciByZWdleHAsIGlkeCxcbiAgICAgIGxlbmd0aCA9IHRoaXMuZXh0cmFIZWFkZXJzLmxlbmd0aCxcbiAgICAgIGhlYWRlciA9IHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXTtcblxuICAgIGlmKGhlYWRlcikge1xuICAgICAgaWYoaGVhZGVyWzBdKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXJbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ15cXFxccyonICsgbmFtZSArICdcXFxccyo6JywnaScpO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGhlYWRlciA9IHRoaXMuZXh0cmFIZWFkZXJzW2lkeF07XG4gICAgICAgIGlmIChyZWdleHAudGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGhlYWRlci5zdWJzdHJpbmcoaGVhZGVyLmluZGV4T2YoJzonKSsxKS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGVhZGVyL3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgd2l0aCBhbGwgdGhlIGhlYWRlcnMgb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgKi9cbiAgZ2V0SGVhZGVyczogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpZHgsIGxlbmd0aCwgcmVnZXhwLFxuICAgICAgaGVhZGVyID0gdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgICBpZihoZWFkZXIpIHtcbiAgICAgIGxlbmd0aCA9IGhlYWRlci5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goaGVhZGVyW2lkeF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdGhpcy5leHRyYUhlYWRlcnMubGVuZ3RoO1xuICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxzKicgKyBuYW1lICsgJ1xcXFxzKjonLCdpJyk7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaGVhZGVyID0gdGhpcy5leHRyYUhlYWRlcnNbaWR4XTtcbiAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChoZWFkZXIuc3Vic3RyaW5nKGhlYWRlci5pbmRleE9mKCc6JykrMSkudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGUgZXhpc3RlbmNlIG9mIHRoZSBnaXZlbiBoZWFkZXIuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGhlYWRlciB3aXRoIGdpdmVuIG5hbWUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIGhhc0hlYWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciByZWdleHAsIGlkeCxcbiAgICAgIGxlbmd0aCA9IHRoaXMuZXh0cmFIZWFkZXJzLmxlbmd0aDtcblxuICAgIGlmICh0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWdleHAgPSBuZXcgUmVnRXhwKCdeXFxcXHMqJyArIG5hbWUgKyAnXFxcXHMqOicsJ2knKTtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAocmVnZXhwLnRlc3QodGhpcy5leHRyYUhlYWRlcnNbaWR4XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1zZyA9ICcnLCBoZWFkZXIsIGxlbmd0aCwgaWR4O1xuXG4gICAgbXNnICs9IHRoaXMubWV0aG9kICsgJyAnICsgKHRoaXMucnVyaS50b1JhdyA/IHRoaXMucnVyaS50b1JhdygpIDogdGhpcy5ydXJpKSArICcgU0lQLzIuMFxcclxcbic7XG5cbiAgICBmb3IgKGhlYWRlciBpbiB0aGlzLmhlYWRlcnMpIHtcbiAgICAgIGxlbmd0aCA9IHRoaXMuaGVhZGVyc1toZWFkZXJdLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBtc2cgKz0gaGVhZGVyICsgJzogJyArIHRoaXMuaGVhZGVyc1toZWFkZXJdW2lkeF0gKyAnXFxyXFxuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW5ndGggPSB0aGlzLmV4dHJhSGVhZGVycy5sZW5ndGg7XG4gICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICBtc2cgKz0gdGhpcy5leHRyYUhlYWRlcnNbaWR4XS50cmltKCkgKydcXHJcXG4nO1xuICAgIH1cblxuICAgIG1zZyArPSBnZXRTdXBwb3J0ZWRIZWFkZXIodGhpcyk7XG4gICAgbXNnICs9ICdVc2VyLUFnZW50OiAnICsgdGhpcy51YS5jb25maWd1cmF0aW9uLnVzZXJBZ2VudFN0cmluZyArJ1xcclxcbic7XG5cbiAgICBpZih0aGlzLmJvZHkpIHtcbiAgICAgIGxlbmd0aCA9IFNJUC5VdGlscy5zdHJfdXRmOF9sZW5ndGgodGhpcy5ib2R5KTtcbiAgICAgIG1zZyArPSAnQ29udGVudC1MZW5ndGg6ICcgKyBsZW5ndGggKyAnXFxyXFxuXFxyXFxuJztcbiAgICAgIG1zZyArPSB0aGlzLmJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1zZyArPSAnQ29udGVudC1MZW5ndGg6IDBcXHJcXG5cXHJcXG4nO1xuICAgIH1cblxuICAgIHJldHVybiBtc2c7XG4gIH1cbn07XG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGZvciBpbmNvbWluZyBTSVAgbWVzc2FnZS5cbiAqL1xuSW5jb21pbmdNZXNzYWdlID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5kYXRhID0gbnVsbDtcbiAgdGhpcy5oZWFkZXJzID0gbnVsbDtcbiAgdGhpcy5tZXRob2QgPSAgbnVsbDtcbiAgdGhpcy52aWEgPSBudWxsO1xuICB0aGlzLnZpYV9icmFuY2ggPSBudWxsO1xuICB0aGlzLmNhbGxfaWQgPSBudWxsO1xuICB0aGlzLmNzZXEgPSBudWxsO1xuICB0aGlzLmZyb20gPSBudWxsO1xuICB0aGlzLmZyb21fdGFnID0gbnVsbDtcbiAgdGhpcy50byA9IG51bGw7XG4gIHRoaXMudG9fdGFnID0gbnVsbDtcbiAgdGhpcy5ib2R5ID0gbnVsbDtcbn07XG5cbkluY29taW5nTWVzc2FnZS5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAqIEluc2VydCBhIGhlYWRlciBvZiB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUgaW50byB0aGUgbGFzdCBwb3NpdGlvbiBvZiB0aGVcbiAgKiBoZWFkZXIgYXJyYXkuXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgaGVhZGVyIHZhbHVlXG4gICovXG4gIGFkZEhlYWRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaGVhZGVyID0geyByYXc6IHZhbHVlIH07XG5cbiAgICBuYW1lID0gU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKTtcblxuICAgIGlmKHRoaXMuaGVhZGVyc1tuYW1lXSkge1xuICAgICAgdGhpcy5oZWFkZXJzW25hbWVdLnB1c2goaGVhZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzW25hbWVdID0gW2hlYWRlcl07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBoZWFkZXIgbmFtZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtTdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgaGVhZGVyLCBudWxsIGlmIGhlYWRlciBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZ2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXTtcblxuICAgIGlmKGhlYWRlcikge1xuICAgICAgaWYoaGVhZGVyWzBdKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXJbMF0ucmF3O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhlYWRlci9zIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IHdpdGggYWxsIHRoZSBoZWFkZXJzIG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICovXG4gIGdldEhlYWRlcnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaWR4LCBsZW5ndGgsXG4gICAgICBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV0sXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgIGlmKCFoZWFkZXIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZW5ndGggPSBoZWFkZXIubGVuZ3RoO1xuICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgcmVzdWx0LnB1c2goaGVhZGVyW2lkeF0ucmF3KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBoZWFkZXIgd2l0aCBnaXZlbiBuYW1lIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBoYXNIZWFkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4odGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldKSA/IHRydWUgOiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIG9uIHRoZSBnaXZlbiBpbmRleC5cbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAqIEBwYXJhbSB7TnVtYmVyfSBbaWR4PTBdIGhlYWRlciBpbmRleFxuICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfSBQYXJzZWQgaGVhZGVyIG9iamVjdCwgdW5kZWZpbmVkIGlmIHRoZSBoZWFkZXIgaXMgbm90IHByZXNlbnQgb3IgaW4gY2FzZSBvZiBhIHBhcnNpbmcgZXJyb3IuXG4gICovXG4gIHBhcnNlSGVhZGVyOiBmdW5jdGlvbihuYW1lLCBpZHgpIHtcbiAgICB2YXIgaGVhZGVyLCB2YWx1ZSwgcGFyc2VkO1xuXG4gICAgbmFtZSA9IFNJUC5VdGlscy5oZWFkZXJpemUobmFtZSk7XG5cbiAgICBpZHggPSBpZHggfHwgMDtcblxuICAgIGlmKCF0aGlzLmhlYWRlcnNbbmFtZV0pIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnaGVhZGVyIFwiJyArIG5hbWUgKyAnXCIgbm90IHByZXNlbnQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYoaWR4ID49IHRoaXMuaGVhZGVyc1tuYW1lXS5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnbm90IHNvIG1hbnkgXCInICsgbmFtZSArICdcIiBoZWFkZXJzIHByZXNlbnQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbbmFtZV1baWR4XTtcbiAgICB2YWx1ZSA9IGhlYWRlci5yYXc7XG5cbiAgICBpZihoZWFkZXIucGFyc2VkKSB7XG4gICAgICByZXR1cm4gaGVhZGVyLnBhcnNlZDtcbiAgICB9XG5cbiAgICAvL3N1YnN0aXR1dGUgJy0nIGJ5ICdfJyBmb3IgZ3JhbW1hciBydWxlIG1hdGNoaW5nLlxuICAgIHBhcnNlZCA9IFNJUC5HcmFtbWFyLnBhcnNlKHZhbHVlLCBuYW1lLnJlcGxhY2UoLy0vZywgJ18nKSk7XG5cbiAgICBpZihwYXJzZWQgPT09IC0xKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbmFtZV0uc3BsaWNlKGlkeCwgMSk7IC8vZGVsZXRlIGZyb20gaGVhZGVyc1xuICAgICAgdGhpcy5sb2dnZXIud2FybignZXJyb3IgcGFyc2luZyBcIicgKyBuYW1lICsgJ1wiIGhlYWRlciBmaWVsZCB3aXRoIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiJyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlci5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTWVzc2FnZSBIZWFkZXIgYXR0cmlidXRlIHNlbGVjdG9yLiBBbGlhcyBvZiBwYXJzZUhlYWRlci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpZHg9MF0gaGVhZGVyIGluZGV4XG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfSBQYXJzZWQgaGVhZGVyIG9iamVjdCwgdW5kZWZpbmVkIGlmIHRoZSBoZWFkZXIgaXMgbm90IHByZXNlbnQgb3IgaW4gY2FzZSBvZiBhIHBhcnNpbmcgZXJyb3IuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG1lc3NhZ2UucygndmlhJywzKS5wb3J0XG4gICAqL1xuICBzOiBmdW5jdGlvbihuYW1lLCBpZHgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUhlYWRlcihuYW1lLCBpZHgpO1xuICB9LFxuXG4gIC8qKlxuICAqIFJlcGxhY2UgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBoZWFkZXIgYnkgdGhlIHZhbHVlLlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGhlYWRlciB2YWx1ZVxuICAqL1xuICBzZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGhlYWRlciA9IHsgcmF3OiB2YWx1ZSB9O1xuICAgIHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSA9IFtoZWFkZXJdO1xuICB9LFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBhdWdtZW50cyBJbmNvbWluZ01lc3NhZ2VcbiAqIEBjbGFzcyBDbGFzcyBmb3IgaW5jb21pbmcgU0lQIHJlcXVlc3QuXG4gKi9cbkluY29taW5nUmVxdWVzdCA9IGZ1bmN0aW9uKHVhKSB7XG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuc2lwbWVzc2FnZScpO1xuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMuaGVhZGVycyA9IHt9O1xuICB0aGlzLnJ1cmkgPSBudWxsO1xuICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIHRoaXMuc2VydmVyX3RyYW5zYWN0aW9uID0gbnVsbDtcbn07XG5JbmNvbWluZ1JlcXVlc3QucHJvdG90eXBlID0gbmV3IEluY29taW5nTWVzc2FnZSgpO1xuXG4vKipcbiogU3RhdGVmdWwgcmVwbHkuXG4qIEBwYXJhbSB7TnVtYmVyfSBjb2RlIHN0YXR1cyBjb2RlXG4qIEBwYXJhbSB7U3RyaW5nfSByZWFzb24gcmVhc29uIHBocmFzZVxuKiBAcGFyYW0ge09iamVjdH0gaGVhZGVycyBleHRyYSBoZWFkZXJzXG4qIEBwYXJhbSB7U3RyaW5nfSBib2R5IGJvZHlcbiogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gb25TdWNjZXNzIGNhbGxiYWNrXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtvbkZhaWx1cmVdIG9uRmFpbHVyZSBjYWxsYmFja1xuKi9cbkluY29taW5nUmVxdWVzdC5wcm90b3R5cGUucmVwbHkgPSBmdW5jdGlvbihjb2RlLCByZWFzb24sIGV4dHJhSGVhZGVycywgYm9keSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgdmFyIHJyLCB2aWFzLCBsZW5ndGgsIGlkeCwgcmVzcG9uc2UsXG4gICAgdG8gPSB0aGlzLmdldEhlYWRlcignVG8nKSxcbiAgICByID0gMCxcbiAgICB2ID0gMDtcblxuICByZXNwb25zZSA9IFNJUC5VdGlscy5idWlsZFN0YXR1c0xpbmUoY29kZSwgcmVhc29uKTtcbiAgZXh0cmFIZWFkZXJzID0gKGV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcblxuICBpZih0aGlzLm1ldGhvZCA9PT0gU0lQLkMuSU5WSVRFICYmIGNvZGUgPiAxMDAgJiYgY29kZSA8PSAyMDApIHtcbiAgICByciA9IHRoaXMuZ2V0SGVhZGVycygncmVjb3JkLXJvdXRlJyk7XG4gICAgbGVuZ3RoID0gcnIubGVuZ3RoO1xuXG4gICAgZm9yKHI7IHIgPCBsZW5ndGg7IHIrKykge1xuICAgICAgcmVzcG9uc2UgKz0gJ1JlY29yZC1Sb3V0ZTogJyArIHJyW3JdICsgJ1xcclxcbic7XG4gICAgfVxuICB9XG5cbiAgdmlhcyA9IHRoaXMuZ2V0SGVhZGVycygndmlhJyk7XG4gIGxlbmd0aCA9IHZpYXMubGVuZ3RoO1xuXG4gIGZvcih2OyB2IDwgbGVuZ3RoOyB2KyspIHtcbiAgICByZXNwb25zZSArPSAnVmlhOiAnICsgdmlhc1t2XSArICdcXHJcXG4nO1xuICB9XG5cbiAgaWYoIXRoaXMudG9fdGFnICYmIGNvZGUgPiAxMDApIHtcbiAgICB0byArPSAnO3RhZz0nICsgU0lQLlV0aWxzLm5ld1RhZygpO1xuICB9IGVsc2UgaWYodGhpcy50b190YWcgJiYgIXRoaXMucygndG8nKS5oYXNQYXJhbSgndGFnJykpIHtcbiAgICB0byArPSAnO3RhZz0nICsgdGhpcy50b190YWc7XG4gIH1cblxuICByZXNwb25zZSArPSAnVG86ICcgKyB0byArICdcXHJcXG4nO1xuICByZXNwb25zZSArPSAnRnJvbTogJyArIHRoaXMuZ2V0SGVhZGVyKCdGcm9tJykgKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0NhbGwtSUQ6ICcgKyB0aGlzLmNhbGxfaWQgKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0NTZXE6ICcgKyB0aGlzLmNzZXEgKyAnICcgKyB0aGlzLm1ldGhvZCArICdcXHJcXG4nO1xuXG4gIGxlbmd0aCA9IGV4dHJhSGVhZGVycy5sZW5ndGg7XG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgIHJlc3BvbnNlICs9IGV4dHJhSGVhZGVyc1tpZHhdLnRyaW0oKSArJ1xcclxcbic7XG4gIH1cblxuICByZXNwb25zZSArPSBnZXRTdXBwb3J0ZWRIZWFkZXIodGhpcyk7XG4gIHJlc3BvbnNlICs9ICdVc2VyLUFnZW50OiAnICsgdGhpcy51YS5jb25maWd1cmF0aW9uLnVzZXJBZ2VudFN0cmluZyArJ1xcclxcbic7XG5cbiAgaWYoYm9keSkge1xuICAgIGxlbmd0aCA9IFNJUC5VdGlscy5zdHJfdXRmOF9sZW5ndGgoYm9keSk7XG4gICAgcmVzcG9uc2UgKz0gJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vc2RwXFxyXFxuJztcbiAgICByZXNwb25zZSArPSAnQ29udGVudC1MZW5ndGg6ICcgKyBsZW5ndGggKyAnXFxyXFxuXFxyXFxuJztcbiAgICByZXNwb25zZSArPSBib2R5O1xuICB9IGVsc2Uge1xuICAgIHJlc3BvbnNlICs9ICdDb250ZW50LUxlbmd0aDogJyArIDAgKyAnXFxyXFxuXFxyXFxuJztcbiAgfVxuXG4gIHRoaXMuc2VydmVyX3RyYW5zYWN0aW9uLnJlY2VpdmVSZXNwb25zZShjb2RlLCByZXNwb25zZSkudGhlbihvblN1Y2Nlc3MsIG9uRmFpbHVyZSk7XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcblxuLyoqXG4qIFN0YXRlbGVzcyByZXBseS5cbiogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgc3RhdHVzIGNvZGVcbiogQHBhcmFtIHtTdHJpbmd9IHJlYXNvbiByZWFzb24gcGhyYXNlXG4qL1xuSW5jb21pbmdSZXF1ZXN0LnByb3RvdHlwZS5yZXBseV9zbCA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICB2YXIgdG8sIHJlc3BvbnNlLFxuICAgIHYgPSAwLFxuICAgIHZpYXMgPSB0aGlzLmdldEhlYWRlcnMoJ3ZpYScpLFxuICAgIGxlbmd0aCA9IHZpYXMubGVuZ3RoO1xuXG4gIHJlc3BvbnNlID0gU0lQLlV0aWxzLmJ1aWxkU3RhdHVzTGluZShjb2RlLCByZWFzb24pO1xuXG4gIGZvcih2OyB2IDwgbGVuZ3RoOyB2KyspIHtcbiAgICByZXNwb25zZSArPSAnVmlhOiAnICsgdmlhc1t2XSArICdcXHJcXG4nO1xuICB9XG5cbiAgdG8gPSB0aGlzLmdldEhlYWRlcignVG8nKTtcblxuICBpZighdGhpcy50b190YWcgJiYgY29kZSA+IDEwMCkge1xuICAgIHRvICs9ICc7dGFnPScgKyBTSVAuVXRpbHMubmV3VGFnKCk7XG4gIH0gZWxzZSBpZih0aGlzLnRvX3RhZyAmJiAhdGhpcy5zKCd0bycpLmhhc1BhcmFtKCd0YWcnKSkge1xuICAgIHRvICs9ICc7dGFnPScgKyB0aGlzLnRvX3RhZztcbiAgfVxuXG4gIHJlc3BvbnNlICs9ICdUbzogJyArIHRvICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdGcm9tOiAnICsgdGhpcy5nZXRIZWFkZXIoJ0Zyb20nKSArICdcXHJcXG4nO1xuICByZXNwb25zZSArPSAnQ2FsbC1JRDogJyArIHRoaXMuY2FsbF9pZCArICdcXHJcXG4nO1xuICByZXNwb25zZSArPSAnQ1NlcTogJyArIHRoaXMuY3NlcSArICcgJyArIHRoaXMubWV0aG9kICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdVc2VyLUFnZW50OiAnICsgdGhpcy51YS5jb25maWd1cmF0aW9uLnVzZXJBZ2VudFN0cmluZyArJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdDb250ZW50LUxlbmd0aDogJyArIDAgKyAnXFxyXFxuXFxyXFxuJztcblxuICB0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKTtcbn07XG5cblxuLyoqXG4gKiBAYXVnbWVudHMgSW5jb21pbmdNZXNzYWdlXG4gKiBAY2xhc3MgQ2xhc3MgZm9yIGluY29taW5nIFNJUCByZXNwb25zZS5cbiAqL1xuSW5jb21pbmdSZXNwb25zZSA9IGZ1bmN0aW9uKHVhKSB7XG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuc2lwbWVzc2FnZScpO1xuICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgdGhpcy5zdGF0dXNfY29kZSA9IG51bGw7XG4gIHRoaXMucmVhc29uX3BocmFzZSA9IG51bGw7XG59O1xuSW5jb21pbmdSZXNwb25zZS5wcm90b3R5cGUgPSBuZXcgSW5jb21pbmdNZXNzYWdlKCk7XG5cblNJUC5PdXRnb2luZ1JlcXVlc3QgPSBPdXRnb2luZ1JlcXVlc3Q7XG5TSVAuSW5jb21pbmdSZXF1ZXN0ID0gSW5jb21pbmdSZXF1ZXN0O1xuU0lQLkluY29taW5nUmVzcG9uc2UgPSBJbmNvbWluZ1Jlc3BvbnNlO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvU0lQTWVzc2FnZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIFVSSVxuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGEgU0lQIFVSSS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NjaGVtZV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbdXNlcl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBob3N0XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BvcnRdXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW2hlYWRlcnNdXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBVUkk7XG5cblVSSSA9IGZ1bmN0aW9uKHNjaGVtZSwgdXNlciwgaG9zdCwgcG9ydCwgcGFyYW1ldGVycywgaGVhZGVycykge1xuICB2YXIgcGFyYW0sIGhlYWRlciwgcmF3LCBub3JtYWw7XG5cbiAgLy8gQ2hlY2tzXG4gIGlmKCFob3N0KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBvciBpbnZhbGlkIFwiaG9zdFwiIHBhcmFtZXRlcicpO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYXJhbWV0ZXJzXG4gIHNjaGVtZSA9IHNjaGVtZSB8fCBTSVAuQy5TSVA7XG4gIHRoaXMucGFyYW1ldGVycyA9IHt9O1xuICB0aGlzLmhlYWRlcnMgPSB7fTtcblxuICBmb3IgKHBhcmFtIGluIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnNldFBhcmFtKHBhcmFtLCBwYXJhbWV0ZXJzW3BhcmFtXSk7XG4gIH1cblxuICBmb3IgKGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgdGhpcy5zZXRIZWFkZXIoaGVhZGVyLCBoZWFkZXJzW2hlYWRlcl0pO1xuICB9XG5cbiAgLy8gUmF3IFVSSVxuICByYXcgPSB7XG4gICAgc2NoZW1lOiBzY2hlbWUsXG4gICAgdXNlcjogdXNlcixcbiAgICBob3N0OiBob3N0LFxuICAgIHBvcnQ6IHBvcnRcbiAgfTtcblxuICAvLyBOb3JtYWxpemVkIFVSSVxuICBub3JtYWwgPSB7XG4gICAgc2NoZW1lOiBzY2hlbWUudG9Mb3dlckNhc2UoKSxcbiAgICB1c2VyOiB1c2VyLFxuICAgIGhvc3Q6IGhvc3QudG9Mb3dlckNhc2UoKSxcbiAgICBwb3J0OiBwb3J0XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIF9ub3JtYWw6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWw7IH1cbiAgICB9LFxuXG4gICAgX3Jhdzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHJhdzsgfVxuICAgIH0sXG5cbiAgICBzY2hlbWU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWwuc2NoZW1lOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByYXcuc2NoZW1lID0gdmFsdWU7XG4gICAgICAgIG5vcm1hbC5zY2hlbWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1c2VyOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsLnVzZXI7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG5vcm1hbC51c2VyID0gcmF3LnVzZXIgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaG9zdDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbC5ob3N0OyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByYXcuaG9zdCA9IHZhbHVlO1xuICAgICAgICBub3JtYWwuaG9zdCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFvcjoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbC51c2VyICsgJ0AnICsgbm9ybWFsLmhvc3Q7IH1cbiAgICB9LFxuXG4gICAgcG9ydDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbC5wb3J0OyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBub3JtYWwucG9ydCA9IHJhdy5wb3J0ID0gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IChwYXJzZUludCh2YWx1ZSwxMCkgfHwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cblVSSS5wcm90b3R5cGUgPSB7XG4gIHNldFBhcmFtOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYoa2V5KSB7XG4gICAgICB0aGlzLnBhcmFtZXRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpID8gbnVsbCA6IHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0UGFyYW06IGZ1bmN0aW9uKGtleSkge1xuICAgIGlmKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICB9LFxuXG4gIGhhc1BhcmFtOiBmdW5jdGlvbihrZXkpIHtcbiAgICBpZihrZXkpIHtcbiAgICAgIHJldHVybiAodGhpcy5wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KGtleS50b0xvd2VyQ2FzZSgpKSAmJiB0cnVlKSB8fCBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgZGVsZXRlUGFyYW06IGZ1bmN0aW9uKHBhcmFtZXRlcikge1xuICAgIHZhciB2YWx1ZTtcbiAgICBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXIudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KHBhcmFtZXRlcikpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl07XG4gICAgICBkZWxldGUgdGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl07XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIGNsZWFyUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7fTtcbiAgfSxcblxuICBzZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldID0gKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpID8gdmFsdWUgOiBbdmFsdWVdO1xuICB9LFxuXG4gIGdldEhlYWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIGlmKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV07XG4gICAgfVxuICB9LFxuXG4gIGhhc0hlYWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIGlmKG5hbWUpIHtcbiAgICAgIHJldHVybiAodGhpcy5oZWFkZXJzLmhhc093blByb3BlcnR5KFNJUC5VdGlscy5oZWFkZXJpemUobmFtZSkpICYmIHRydWUpIHx8IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBkZWxldGVIZWFkZXI6IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgIHZhciB2YWx1ZTtcbiAgICBoZWFkZXIgPSBTSVAuVXRpbHMuaGVhZGVyaXplKGhlYWRlcik7XG4gICAgaWYodGhpcy5oZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5oZWFkZXJzW2hlYWRlcl07XG4gICAgICBkZWxldGUgdGhpcy5oZWFkZXJzW2hlYWRlcl07XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIGNsZWFySGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5oZWFkZXJzID0ge307XG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgVVJJKFxuICAgICAgdGhpcy5fcmF3LnNjaGVtZSxcbiAgICAgIHRoaXMuX3Jhdy51c2VyLFxuICAgICAgdGhpcy5fcmF3Lmhvc3QsXG4gICAgICB0aGlzLl9yYXcucG9ydCxcbiAgICAgIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJhbWV0ZXJzKSksXG4gICAgICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuaGVhZGVycykpKTtcbiAgfSxcblxuICB0b1JhdzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvU3RyaW5nKHRoaXMuX3Jhdyk7XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90b1N0cmluZyh0aGlzLl9ub3JtYWwpO1xuICB9LFxuXG4gIF90b1N0cmluZzogZnVuY3Rpb24odXJpKSB7XG4gICAgdmFyIGhlYWRlciwgcGFyYW1ldGVyLCBpZHgsIHVyaVN0cmluZywgaGVhZGVycyA9IFtdO1xuXG4gICAgdXJpU3RyaW5nICA9IHVyaS5zY2hlbWUgKyAnOic7XG4gICAgLy8gYWRkIHNsYXNoZXMgaWYgaXQncyBub3QgYSBzaXAocykgVVJJXG4gICAgaWYgKCF1cmkuc2NoZW1lLnRvTG93ZXJDYXNlKCkubWF0Y2goXCJec2lwcz8kXCIpKSB7XG4gICAgICB1cmlTdHJpbmcgKz0gXCIvL1wiO1xuICAgIH1cbiAgICBpZiAodXJpLnVzZXIpIHtcbiAgICAgIHVyaVN0cmluZyArPSBTSVAuVXRpbHMuZXNjYXBlVXNlcih1cmkudXNlcikgKyAnQCc7XG4gICAgfVxuICAgIHVyaVN0cmluZyArPSB1cmkuaG9zdDtcbiAgICBpZiAodXJpLnBvcnQgfHwgdXJpLnBvcnQgPT09IDApIHtcbiAgICAgIHVyaVN0cmluZyArPSAnOicgKyB1cmkucG9ydDtcbiAgICB9XG5cbiAgICBmb3IgKHBhcmFtZXRlciBpbiB0aGlzLnBhcmFtZXRlcnMpIHtcbiAgICAgIHVyaVN0cmluZyArPSAnOycgKyBwYXJhbWV0ZXI7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXSAhPT0gbnVsbCkge1xuICAgICAgICB1cmlTdHJpbmcgKz0gJz0nKyB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoaGVhZGVyIGluIHRoaXMuaGVhZGVycykge1xuICAgICAgZm9yKGlkeCBpbiB0aGlzLmhlYWRlcnNbaGVhZGVyXSkge1xuICAgICAgICBoZWFkZXJzLnB1c2goaGVhZGVyICsgJz0nICsgdGhpcy5oZWFkZXJzW2hlYWRlcl1baWR4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdXJpU3RyaW5nICs9ICc/JyArIGhlYWRlcnMuam9pbignJicpO1xuICAgIH1cblxuICAgIHJldHVybiB1cmlTdHJpbmc7XG4gIH1cbn07XG5cblxuLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyBhIFNJUC5VUkkgaW5zdGFuY2Ugb3IgdW5kZWZpbmVkIGlmXG4gICogaXQgaXMgYW4gaW52YWxpZCBVUkkuXG4gICogQHB1YmxpY1xuICAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAgKi9cblVSSS5wYXJzZSA9IGZ1bmN0aW9uKHVyaSkge1xuICB1cmkgPSBTSVAuR3JhbW1hci5wYXJzZSh1cmksJ1NJUF9VUkknKTtcblxuICBpZiAodXJpICE9PSAtMSkge1xuICAgIHJldHVybiB1cmk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuU0lQLlVSSSA9IFVSSTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1VSSS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIE5hbWVBZGRySGVhZGVyXG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSBOYW1lIEFkZHJlc3MgU0lQIGhlYWRlci5cbiAqXG4gKiBAcGFyYW0ge1NJUC5VUkl9IHVyaVxuICogQHBhcmFtIHtTdHJpbmd9IFtkaXNwbGF5TmFtZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVyc11cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIE5hbWVBZGRySGVhZGVyO1xuXG5OYW1lQWRkckhlYWRlciA9IGZ1bmN0aW9uKHVyaSwgZGlzcGxheU5hbWUsIHBhcmFtZXRlcnMpIHtcbiAgdmFyIHBhcmFtO1xuXG4gIC8vIENoZWNrc1xuICBpZighdXJpIHx8ICEodXJpIGluc3RhbmNlb2YgU0lQLlVSSSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIG9yIGludmFsaWQgXCJ1cmlcIiBwYXJhbWV0ZXInKTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgcGFyYW1ldGVyc1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5wYXJhbWV0ZXJzID0ge307XG5cbiAgZm9yIChwYXJhbSBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5zZXRQYXJhbShwYXJhbSwgcGFyYW1ldGVyc1twYXJhbV0pO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIGZyaWVuZGx5TmFtZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGlzcGxheU5hbWUgfHwgdXJpLmFvcjsgfVxuICAgIH0sXG5cbiAgICBkaXNwbGF5TmFtZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGRpc3BsYXlOYW1lOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBkaXNwbGF5TmFtZSA9ICh2YWx1ZSA9PT0gMCkgPyAnMCcgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbk5hbWVBZGRySGVhZGVyLnByb3RvdHlwZSA9IHtcbiAgc2V0UGFyYW06IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYoa2V5KSB7XG4gICAgICB0aGlzLnBhcmFtZXRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpID8gbnVsbCA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9LFxuICBnZXRQYXJhbTogU0lQLlVSSS5wcm90b3R5cGUuZ2V0UGFyYW0sXG4gIGhhc1BhcmFtOiBTSVAuVVJJLnByb3RvdHlwZS5oYXNQYXJhbSxcbiAgZGVsZXRlUGFyYW06IFNJUC5VUkkucHJvdG90eXBlLmRlbGV0ZVBhcmFtLFxuICBjbGVhclBhcmFtczogU0lQLlVSSS5wcm90b3R5cGUuY2xlYXJQYXJhbXMsXG5cbiAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTmFtZUFkZHJIZWFkZXIoXG4gICAgICB0aGlzLnVyaS5jbG9uZSgpLFxuICAgICAgdGhpcy5kaXNwbGF5TmFtZSxcbiAgICAgIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJhbWV0ZXJzKSkpO1xuICB9LFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm9keSwgcGFyYW1ldGVyO1xuXG4gICAgYm9keSAgPSAodGhpcy5kaXNwbGF5TmFtZSB8fCB0aGlzLmRpc3BsYXlOYW1lID09PSAwKSA/ICdcIicgKyB0aGlzLmRpc3BsYXlOYW1lICsgJ1wiICcgOiAnJztcbiAgICBib2R5ICs9ICc8JyArIHRoaXMudXJpLnRvU3RyaW5nKCkgKyAnPic7XG5cbiAgICBmb3IgKHBhcmFtZXRlciBpbiB0aGlzLnBhcmFtZXRlcnMpIHtcbiAgICAgIGJvZHkgKz0gJzsnICsgcGFyYW1ldGVyO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl0gIT09IG51bGwpIHtcbiAgICAgICAgYm9keSArPSAnPScrIHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBib2R5O1xuICB9XG59O1xuXG5cbi8qKlxuICAqIFBhcnNlIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgYSBTSVAuTmFtZUFkZHJIZWFkZXIgaW5zdGFuY2Ugb3IgdW5kZWZpbmVkIGlmXG4gICogaXQgaXMgYW4gaW52YWxpZCBOYW1lQWRkckhlYWRlci5cbiAgKiBAcHVibGljXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVfYWRkcl9oZWFkZXJcbiAgKi9cbk5hbWVBZGRySGVhZGVyLnBhcnNlID0gZnVuY3Rpb24obmFtZV9hZGRyX2hlYWRlcikge1xuICBuYW1lX2FkZHJfaGVhZGVyID0gU0lQLkdyYW1tYXIucGFyc2UobmFtZV9hZGRyX2hlYWRlciwnTmFtZV9BZGRyX0hlYWRlcicpO1xuXG4gIGlmIChuYW1lX2FkZHJfaGVhZGVyICE9PSAtMSkge1xuICAgIHJldHVybiBuYW1lX2FkZHJfaGVhZGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cblNJUC5OYW1lQWRkckhlYWRlciA9IE5hbWVBZGRySGVhZGVyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvTmFtZUFkZHJIZWFkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBUcmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNJUCBUcmFuc2FjdGlvbnMgbW9kdWxlLlxuICogQGF1Z21lbnRzIFNJUFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhclxuICBDID0ge1xuICAgIC8vIFRyYW5zYWN0aW9uIHN0YXRlc1xuICAgIFNUQVRVU19UUllJTkc6ICAgICAxLFxuICAgIFNUQVRVU19QUk9DRUVESU5HOiAyLFxuICAgIFNUQVRVU19DQUxMSU5HOiAgICAzLFxuICAgIFNUQVRVU19BQ0NFUFRFRDogICA0LFxuICAgIFNUQVRVU19DT01QTEVURUQ6ICA1LFxuICAgIFNUQVRVU19URVJNSU5BVEVEOiA2LFxuICAgIFNUQVRVU19DT05GSVJNRUQ6ICA3LFxuXG4gICAgLy8gVHJhbnNhY3Rpb24gdHlwZXNcbiAgICBOT05fSU5WSVRFX0NMSUVOVDogJ25pY3QnLFxuICAgIE5PTl9JTlZJVEVfU0VSVkVSOiAnbmlzdCcsXG4gICAgSU5WSVRFX0NMSUVOVDogJ2ljdCcsXG4gICAgSU5WSVRFX1NFUlZFUjogJ2lzdCdcbiAgfTtcblxuZnVuY3Rpb24gYnVpbGRWaWFIZWFkZXIgKHJlcXVlc3Rfc2VuZGVyLCB0cmFuc3BvcnQsIGlkKSB7XG4gIHZhciB2aWE7XG4gIHZpYSA9ICdTSVAvMi4wLycgKyAocmVxdWVzdF9zZW5kZXIudWEuY29uZmlndXJhdGlvbi5oYWNrVmlhVGNwID8gJ1RDUCcgOiB0cmFuc3BvcnQuc2VydmVyLnNjaGVtZSk7XG4gIHZpYSArPSAnICcgKyByZXF1ZXN0X3NlbmRlci51YS5jb25maWd1cmF0aW9uLnZpYUhvc3QgKyAnO2JyYW5jaD0nICsgaWQ7XG4gIGlmIChyZXF1ZXN0X3NlbmRlci51YS5jb25maWd1cmF0aW9uLmZvcmNlUnBvcnQpIHtcbiAgICB2aWEgKz0gJztycG9ydCc7XG4gIH1cbiAgcmV0dXJuIHZpYTtcbn1cblxuLyoqXG4qIEBhdWdtZW50cyBTSVAuVHJhbnNhY3Rpb25zXG4qIEBjbGFzcyBOb24gSW52aXRlIENsaWVudCBUcmFuc2FjdGlvblxuKiBAcGFyYW0ge1NJUC5SZXF1ZXN0U2VuZGVyfSByZXF1ZXN0X3NlbmRlclxuKiBAcGFyYW0ge1NJUC5PdXRnb2luZ1JlcXVlc3R9IHJlcXVlc3RcbiogQHBhcmFtIHtTSVAuVHJhbnNwb3J0fSB0cmFuc3BvcnRcbiovXG52YXIgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24gPSBmdW5jdGlvbihyZXF1ZXN0X3NlbmRlciwgcmVxdWVzdCwgdHJhbnNwb3J0KSB7XG4gIHZhciB2aWE7XG5cbiAgdGhpcy50eXBlID0gQy5OT05fSU5WSVRFX0NMSUVOVDtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMuaWQgPSAnejloRzRiSycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIgPSByZXF1ZXN0X3NlbmRlcjtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcblxuICB0aGlzLmxvZ2dlciA9IHJlcXVlc3Rfc2VuZGVyLnVhLmdldExvZ2dlcignc2lwLnRyYW5zYWN0aW9uLm5pY3QnLCB0aGlzLmlkKTtcblxuICB2aWEgPSBidWlsZFZpYUhlYWRlcihyZXF1ZXN0X3NlbmRlciwgdHJhbnNwb3J0LCB0aGlzLmlkKTtcbiAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcigndmlhJywgdmlhKTtcblxuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLm5ld1RyYW5zYWN0aW9uKHRoaXMpO1xufTtcbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuc3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB0aGlzLmVtaXQoJ3N0YXRlQ2hhbmdlZCcpO1xufTtcblxuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRyID0gdGhpcztcblxuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19UUllJTkcpO1xuICB0aGlzLkYgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfRi5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9GKTtcblxuICBpZighdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLnJlcXVlc3QpKSB7XG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cbn07XG5cbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygndHJhbnNwb3J0IGVycm9yIG9jY3VycmVkLCBkZWxldGluZyBub24tSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuRik7XG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuSyk7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci5vblRyYW5zcG9ydEVycm9yKCk7XG59O1xuXG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfRiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ1RpbWVyIEYgZXhwaXJlZCBmb3Igbm9uLUlOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIub25SZXF1ZXN0VGltZW91dCgpO1xufTtcblxuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0sgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xufTtcblxuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIHZhclxuICAgIHRyID0gdGhpcyxcbiAgICBzdGF0dXNfY29kZSA9IHJlc3BvbnNlLnN0YXR1c19jb2RlO1xuXG4gIGlmKHN0YXR1c19jb2RlIDwgMjAwKSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfVFJZSU5HOlxuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19QUk9DRUVESU5HKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfVFJZSU5HOlxuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19DT01QTEVURUQpO1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkYpO1xuXG4gICAgICAgIGlmKHN0YXR1c19jb2RlID09PSA0MDgpIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLksgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfSy5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9LKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuU1RBVFVTX0NPTVBMRVRFRDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLyoqXG4qIEBhdWdtZW50cyBTSVAuVHJhbnNhY3Rpb25zXG4qIEBjbGFzcyBJbnZpdGUgQ2xpZW50IFRyYW5zYWN0aW9uXG4qIEBwYXJhbSB7U0lQLlJlcXVlc3RTZW5kZXJ9IHJlcXVlc3Rfc2VuZGVyXG4qIEBwYXJhbSB7U0lQLk91dGdvaW5nUmVxdWVzdH0gcmVxdWVzdFxuKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydFxuKi9cbnZhciBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHJlcXVlc3Rfc2VuZGVyLCByZXF1ZXN0LCB0cmFuc3BvcnQpIHtcbiAgdmFyIHZpYSxcbiAgICB0ciA9IHRoaXM7XG5cbiAgdGhpcy50eXBlID0gQy5JTlZJVEVfQ0xJRU5UO1xuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdGhpcy5pZCA9ICd6OWhHNGJLJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlciA9IHJlcXVlc3Rfc2VuZGVyO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuXG4gIHRoaXMubG9nZ2VyID0gcmVxdWVzdF9zZW5kZXIudWEuZ2V0TG9nZ2VyKCdzaXAudHJhbnNhY3Rpb24uaWN0JywgdGhpcy5pZCk7XG5cbiAgdmlhID0gYnVpbGRWaWFIZWFkZXIocmVxdWVzdF9zZW5kZXIsIHRyYW5zcG9ydCwgdGhpcy5pZCk7XG4gIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoJ3ZpYScsIHZpYSk7XG5cbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5uZXdUcmFuc2FjdGlvbih0aGlzKTtcblxuICAvLyBBZGQgdGhlIGNhbmNlbCBwcm9wZXJ0eSB0byB0aGUgcmVxdWVzdC5cbiAgLy9XaWxsIGJlIGNhbGxlZCBmcm9tIHRoZSByZXF1ZXN0IGluc3RhbmNlLCBub3QgdGhlIHRyYW5zYWN0aW9uIGl0c2VsZi5cbiAgdGhpcy5yZXF1ZXN0LmNhbmNlbCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIHRyLmNhbmNlbF9yZXF1ZXN0KHRyLCByZWFzb24pO1xuICB9O1xufTtcbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuc3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB0aGlzLmVtaXQoJ3N0YXRlQ2hhbmdlZCcpO1xufTtcblxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRyID0gdGhpcztcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQ0FMTElORyk7XG4gIHRoaXMuQiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9CLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0IpO1xuXG4gIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMucmVxdWVzdCkpIHtcbiAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxufTtcblxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCd0cmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQsIGRlbGV0aW5nIElOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkIpO1xuICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkQpO1xuICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLk0pO1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG5cbiAgaWYgKHRoaXMuc3RhdGUgIT09IEMuU1RBVFVTX0FDQ0VQVEVEKSB7XG4gICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cbn07XG5cbi8vIFJGQyA2MDI2IDcuMlxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX00gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCdUaW1lciBNIGV4cGlyZWQgZm9yIElOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuXG4gIGlmKHRoaXMuc3RhdGUgPT09IEMuU1RBVFVTX0FDQ0VQVEVEKSB7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5CKTtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbiAgfVxufTtcblxuLy8gUkZDIDMyNjEgMTcuMS4xXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfQiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ1RpbWVyIEIgZXhwaXJlZCBmb3IgSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIGlmKHRoaXMuc3RhdGUgPT09IEMuU1RBVFVTX0NBTExJTkcpIHtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbiAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgfVxufTtcblxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCdUaW1lciBEIGV4cGlyZWQgZm9yIElOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkIpO1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2VuZEFDSyA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIHZhciB0ciA9IHRoaXM7XG5cbiAgdGhpcy5hY2sgPSAnQUNLICcgKyB0aGlzLnJlcXVlc3QucnVyaSArICcgU0lQLzIuMFxcclxcbic7XG4gIHRoaXMuYWNrICs9ICdWaWE6ICcgKyB0aGlzLnJlcXVlc3QuaGVhZGVyc1snVmlhJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuXG4gIGlmKHRoaXMucmVxdWVzdC5oZWFkZXJzWydSb3V0ZSddKSB7XG4gICAgdGhpcy5hY2sgKz0gJ1JvdXRlOiAnICsgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1JvdXRlJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB9XG5cbiAgdGhpcy5hY2sgKz0gJ1RvOiAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCd0bycpICsgJ1xcclxcbic7XG4gIHRoaXMuYWNrICs9ICdGcm9tOiAnICsgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0Zyb20nXS50b1N0cmluZygpICsgJ1xcclxcbic7XG4gIHRoaXMuYWNrICs9ICdDYWxsLUlEOiAnICsgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0NhbGwtSUQnXS50b1N0cmluZygpICsgJ1xcclxcbic7XG4gIHRoaXMuYWNrICs9ICdDb250ZW50LUxlbmd0aDogMFxcclxcbic7XG4gIHRoaXMuYWNrICs9ICdDU2VxOiAnICsgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0NTZXEnXS50b1N0cmluZygpLnNwbGl0KCcgJylbMF07XG4gIHRoaXMuYWNrICs9ICcgQUNLXFxyXFxuXFxyXFxuJztcblxuICB0aGlzLkQgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfRC5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9EKTtcblxuICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMuYWNrKTtcbn07XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5jYW5jZWxfcmVxdWVzdCA9IGZ1bmN0aW9uKHRyLCByZWFzb24pIHtcbiAgdmFyIHJlcXVlc3QgPSB0ci5yZXF1ZXN0O1xuXG4gIHRoaXMuY2FuY2VsID0gU0lQLkMuQ0FOQ0VMICsgJyAnICsgcmVxdWVzdC5ydXJpICsgJyBTSVAvMi4wXFxyXFxuJztcbiAgdGhpcy5jYW5jZWwgKz0gJ1ZpYTogJyArIHJlcXVlc3QuaGVhZGVyc1snVmlhJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuXG4gIGlmKHRoaXMucmVxdWVzdC5oZWFkZXJzWydSb3V0ZSddKSB7XG4gICAgdGhpcy5jYW5jZWwgKz0gJ1JvdXRlOiAnICsgcmVxdWVzdC5oZWFkZXJzWydSb3V0ZSddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgfVxuXG4gIHRoaXMuY2FuY2VsICs9ICdUbzogJyArIHJlcXVlc3QuaGVhZGVyc1snVG8nXS50b1N0cmluZygpICsgJ1xcclxcbic7XG4gIHRoaXMuY2FuY2VsICs9ICdGcm9tOiAnICsgcmVxdWVzdC5oZWFkZXJzWydGcm9tJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB0aGlzLmNhbmNlbCArPSAnQ2FsbC1JRDogJyArIHJlcXVlc3QuaGVhZGVyc1snQ2FsbC1JRCddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgdGhpcy5jYW5jZWwgKz0gJ0NTZXE6ICcgKyByZXF1ZXN0LmhlYWRlcnNbJ0NTZXEnXS50b1N0cmluZygpLnNwbGl0KCcgJylbMF0gK1xuICAnIENBTkNFTFxcclxcbic7XG5cbiAgaWYocmVhc29uKSB7XG4gICAgdGhpcy5jYW5jZWwgKz0gJ1JlYXNvbjogJyArIHJlYXNvbiArICdcXHJcXG4nO1xuICB9XG5cbiAgdGhpcy5jYW5jZWwgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAwXFxyXFxuXFxyXFxuJztcblxuICAvLyBTZW5kIG9ubHkgaWYgYSBwcm92aXNpb25hbCByZXNwb25zZSAoPjEwMCkgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gIGlmKHRoaXMuc3RhdGUgPT09IEMuU1RBVFVTX1BST0NFRURJTkcpIHtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMuY2FuY2VsKTtcbiAgfVxufTtcblxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIHZhclxuICB0ciA9IHRoaXMsXG4gIHN0YXR1c19jb2RlID0gcmVzcG9uc2Uuc3RhdHVzX2NvZGU7XG5cbiAgaWYoc3RhdHVzX2NvZGUgPj0gMTAwICYmIHN0YXR1c19jb2RlIDw9IDE5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX0NBTExJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1BST0NFRURJTkcpO1xuICAgICAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGlmKHRoaXMuY2FuY2VsKSB7XG4gICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLmNhbmNlbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2UgaWYoc3RhdHVzX2NvZGUgPj0gMjAwICYmIHN0YXR1c19jb2RlIDw9IDI5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX0NBTExJTkc6XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX0FDQ0VQVEVEKTtcbiAgICAgICAgdGhpcy5NID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX00uYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfTSk7XG4gICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuU1RBVFVTX0FDQ0VQVEVEOlxuICAgICAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIGlmKHN0YXR1c19jb2RlID49IDMwMCAmJiBzdGF0dXNfY29kZSA8PSA2OTkpIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19DQUxMSU5HOlxuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19DT01QTEVURUQpO1xuICAgICAgICB0aGlzLnNlbmRBQ0socmVzcG9uc2UpO1xuICAgICAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlNUQVRVU19DT01QTEVURUQ6XG4gICAgICAgIHRoaXMuc2VuZEFDSyhyZXNwb25zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIEBhdWdtZW50cyBTSVAuVHJhbnNhY3Rpb25zXG4gKiBAY2xhc3MgQUNLIENsaWVudCBUcmFuc2FjdGlvblxuICogQHBhcmFtIHtTSVAuUmVxdWVzdFNlbmRlcn0gcmVxdWVzdF9zZW5kZXJcbiAqIEBwYXJhbSB7U0lQLk91dGdvaW5nUmVxdWVzdH0gcmVxdWVzdFxuICogQHBhcmFtIHtTSVAuVHJhbnNwb3J0fSB0cmFuc3BvcnRcbiAqL1xudmFyIEFja0NsaWVudFRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocmVxdWVzdF9zZW5kZXIsIHJlcXVlc3QsIHRyYW5zcG9ydCkge1xuICB2YXIgdmlhO1xuXG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLmlkID0gJ3o5aEc0YksnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyID0gcmVxdWVzdF9zZW5kZXI7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgdGhpcy5sb2dnZXIgPSByZXF1ZXN0X3NlbmRlci51YS5nZXRMb2dnZXIoJ3NpcC50cmFuc2FjdGlvbi5uaWN0JywgdGhpcy5pZCk7XG5cbiAgdmlhID0gYnVpbGRWaWFIZWFkZXIocmVxdWVzdF9zZW5kZXIsIHRyYW5zcG9ydCwgdGhpcy5pZCk7XG4gIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoJ3ZpYScsIHZpYSk7XG59O1xuQWNrQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkFja0NsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oKSB7XG4gIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMucmVxdWVzdCkpIHtcbiAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxufTtcblxuQWNrQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCd0cmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQsIGZvciBhbiBBQ0sgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci5vblRyYW5zcG9ydEVycm9yKCk7XG59O1xuXG5cbi8qKlxuKiBAYXVnbWVudHMgU0lQLlRyYW5zYWN0aW9uc1xuKiBAY2xhc3MgTm9uIEludml0ZSBTZXJ2ZXIgVHJhbnNhY3Rpb25cbiogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0XG4qIEBwYXJhbSB7U0lQLlVBfSB1YVxuKi9cbnZhciBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHJlcXVlc3QsIHVhKSB7XG4gIHRoaXMudHlwZSA9IEMuTk9OX0lOVklURV9TRVJWRVI7XG4gIHRoaXMuaWQgPSByZXF1ZXN0LnZpYV9icmFuY2g7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHRoaXMudHJhbnNwb3J0ID0gcmVxdWVzdC50cmFuc3BvcnQ7XG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy5sYXN0X3Jlc3BvbnNlID0gJyc7XG4gIHJlcXVlc3Quc2VydmVyX3RyYW5zYWN0aW9uID0gdGhpcztcblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnRyYW5zYWN0aW9uLm5pc3QnLCB0aGlzLmlkKTtcblxuICB0aGlzLnN0YXRlID0gQy5TVEFUVVNfVFJZSU5HO1xuXG4gIHVhLm5ld1RyYW5zYWN0aW9uKHRoaXMpO1xufTtcbk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUuc3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB0aGlzLmVtaXQoJ3N0YXRlQ2hhbmdlZCcpO1xufTtcblxuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0ogPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCdUaW1lciBKIGV4cGlyZWQgZm9yIG5vbi1JTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xufTtcblxuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnRyYW5zcG9ydEVycm9yKSB7XG4gICAgdGhpcy50cmFuc3BvcnRFcnJvciA9IHRydWU7XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ3RyYW5zcG9ydCBlcnJvciBvY2N1cnJlZCwgZGVsZXRpbmcgbm9uLUlOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuXG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5KKTtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgICB0aGlzLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbiAgfVxufTtcblxuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uKHN0YXR1c19jb2RlLCByZXNwb25zZSkge1xuICB2YXIgdHIgPSB0aGlzO1xuICB2YXIgZGVmZXJyZWQgPSBTSVAuVXRpbHMuZGVmZXIoKTtcblxuICBpZihzdGF0dXNfY29kZSA9PT0gMTAwKSB7XG4gICAgLyogUkZDIDQzMjAgNC4xXG4gICAgICogJ0EgU0lQIGVsZW1lbnQgTVVTVCBOT1RcbiAgICAgKiBzZW5kIGFueSBwcm92aXNpb25hbCByZXNwb25zZSB3aXRoIGFcbiAgICAgKiBTdGF0dXMtQ29kZSBvdGhlciB0aGFuIDEwMCB0byBhIG5vbi1JTlZJVEUgcmVxdWVzdC4nXG4gICAgICovXG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfVFJZSU5HOlxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19QUk9DRUVESU5HKTtcbiAgICAgICAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpKSAge1xuICAgICAgICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICB0aGlzLmxhc3RfcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIGlmKHN0YXR1c19jb2RlID49IDIwMCAmJiBzdGF0dXNfY29kZSA8PSA2OTkpIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19UUllJTkc6XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX0NPTVBMRVRFRCk7XG4gICAgICAgIHRoaXMubGFzdF9yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLkogPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfSi5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9KKTtcbiAgICAgICAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlNUQVRVU19DT01QTEVURUQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4qIEBhdWdtZW50cyBTSVAuVHJhbnNhY3Rpb25zXG4qIEBjbGFzcyBJbnZpdGUgU2VydmVyIFRyYW5zYWN0aW9uXG4qIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdH0gcmVxdWVzdFxuKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiovXG52YXIgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24gPSBmdW5jdGlvbihyZXF1ZXN0LCB1YSkge1xuICB0aGlzLnR5cGUgPSBDLklOVklURV9TRVJWRVI7XG4gIHRoaXMuaWQgPSByZXF1ZXN0LnZpYV9icmFuY2g7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHRoaXMudHJhbnNwb3J0ID0gcmVxdWVzdC50cmFuc3BvcnQ7XG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy5sYXN0X3Jlc3BvbnNlID0gJyc7XG4gIHJlcXVlc3Quc2VydmVyX3RyYW5zYWN0aW9uID0gdGhpcztcblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnRyYW5zYWN0aW9uLmlzdCcsIHRoaXMuaWQpO1xuXG4gIHRoaXMuc3RhdGUgPSBDLlNUQVRVU19QUk9DRUVESU5HO1xuXG4gIHVhLm5ld1RyYW5zYWN0aW9uKHRoaXMpO1xuXG4gIHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciA9IG51bGw7XG5cbiAgcmVxdWVzdC5yZXBseSgxMDApO1xufTtcbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUuc3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB0aGlzLmVtaXQoJ3N0YXRlQ2hhbmdlZCcpO1xufTtcblxuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0ggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCdUaW1lciBIIGV4cGlyZWQgZm9yIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuXG4gIGlmKHRoaXMuc3RhdGUgPT09IEMuU1RBVFVTX0NPTVBMRVRFRCkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ3RyYW5zYWN0aW9ucycsICdBQ0sgZm9yIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gd2FzIG5ldmVyIHJlY2VpdmVkLCBjYWxsIHdpbGwgYmUgdGVybWluYXRlZCcpO1xuICB9XG5cbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xufTtcblxuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xufTtcblxuLy8gUkZDIDYwMjYgNy4xXG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfTCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ1RpbWVyIEwgZXhwaXJlZCBmb3IgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG5cbiAgaWYodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfQUNDRVBURUQpIHtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgICB0aGlzLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbiAgfVxufTtcblxuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnRyYW5zcG9ydEVycm9yKSB7XG4gICAgdGhpcy50cmFuc3BvcnRFcnJvciA9IHRydWU7XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ3RyYW5zcG9ydCBlcnJvciBvY2N1cnJlZCwgZGVsZXRpbmcgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG5cbiAgICBpZiAodGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyICE9PSBudWxsKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyKTtcbiAgICAgIHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5MKTtcbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkgpO1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuSSk7XG5cbiAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgICB0aGlzLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbiAgfVxufTtcblxuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlc2VuZF9wcm92aXNpb25hbCA9IGZ1bmN0aW9uKCkge1xuICBpZighdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLmxhc3RfcmVzcG9uc2UpKSB7XG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cbn07XG5cbi8vIElOVklURSBTZXJ2ZXIgVHJhbnNhY3Rpb24gUkZDIDMyNjEgMTcuMi4xXG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24oc3RhdHVzX2NvZGUsIHJlc3BvbnNlKSB7XG4gIHZhciB0ciA9IHRoaXM7XG4gIHZhciBkZWZlcnJlZCA9IFNJUC5VdGlscy5kZWZlcigpO1xuXG4gIGlmKHN0YXR1c19jb2RlID49IDEwMCAmJiBzdGF0dXNfY29kZSA8PSAxOTkpIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICBpZighdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSkpIHtcbiAgICAgICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RfcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYoc3RhdHVzX2NvZGUgPiAxMDAgJiYgc3RhdHVzX2NvZGUgPD0gMTk5ICYmIHRoaXMuc3RhdGUgPT09IEMuU1RBVFVTX1BST0NFRURJTkcpIHtcbiAgICAvLyBUcmlnZ2VyIHRoZSByZXNlbmRQcm92aXNpb25hbFRpbWVyIG9ubHkgZm9yIHRoZSBmaXJzdCBub24gMTAwIHByb3Zpc2lvbmFsIHJlc3BvbnNlLlxuICAgIGlmKHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lciA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyID0gU0lQLlRpbWVycy5zZXRJbnRlcnZhbCh0ci5yZXNlbmRfcHJvdmlzaW9uYWwuYmluZCh0ciksXG4gICAgICAgIFNJUC5UaW1lcnMuUFJPVklTSU9OQUxfUkVTUE9OU0VfSU5URVJWQUwpO1xuICAgIH1cbiAgfSBlbHNlIGlmKHN0YXR1c19jb2RlID49IDIwMCAmJiBzdGF0dXNfY29kZSA8PSAyOTkpIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19BQ0NFUFRFRCk7XG4gICAgICAgIHRoaXMubGFzdF9yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLkwgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfTC5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9MKTtcblxuICAgICAgICBpZiAodGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgU0lQLlRpbWVycy5jbGVhckludGVydmFsKHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lcik7XG4gICAgICAgICAgdGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgQy5TVEFUVVNfQUNDRVBURUQ6XG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgcG9pbnQgd2lsbCBiZSByZWFjaGVkIGZvciBwcm9jZWVkaW5nIHRyLnN0YXRlIGFsc28uXG4gICAgICAgICAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIGlmKHN0YXR1c19jb2RlID49IDMwMCAmJiBzdGF0dXNfY29kZSA8PSA2OTkpIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICBpZiAodGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgU0lQLlRpbWVycy5jbGVhckludGVydmFsKHRoaXMucmVzZW5kUHJvdmlzaW9uYWxUaW1lcik7XG4gICAgICAgICAgdGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKSkge1xuICAgICAgICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX0NPTVBMRVRFRCk7XG4gICAgICAgICAgdGhpcy5IID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0guYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfSCk7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U0lQLlVBfSB1YVxuICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0XG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIElOVklURTpcbiAqICBfdHJ1ZV8gaWYgcmV0cmFuc21pc3Npb25cbiAqICBfZmFsc2VfIG5ldyByZXF1ZXN0XG4gKlxuICogQUNLOlxuICogIF90cnVlXyAgQUNLIHRvIG5vbjJ4eCByZXNwb25zZVxuICogIF9mYWxzZV8gQUNLIG11c3QgYmUgcGFzc2VkIHRvIFRVIChhY2NlcHRlZCBzdGF0ZSlcbiAqICAgICAgICAgIEFDSyB0byAyeHggcmVzcG9uc2VcbiAqXG4gKiBDQU5DRUw6XG4gKiAgX3RydWVfICBubyBtYXRjaGluZyBpbnZpdGUgdHJhbnNhY3Rpb25cbiAqICBfZmFsc2VfIG1hdGNoaW5nIGludml0ZSB0cmFuc2FjdGlvbiBhbmQgbm8gZmluYWwgcmVzcG9uc2Ugc2VudFxuICpcbiAqIE9USEVSOlxuICogIF90cnVlXyAgcmV0cmFuc21pc3Npb25cbiAqICBfZmFsc2VfIG5ldyByZXF1ZXN0XG4gKi9cbnZhciBjaGVja1RyYW5zYWN0aW9uID0gZnVuY3Rpb24odWEsIHJlcXVlc3QpIHtcbiAgdmFyIHRyO1xuXG4gIHN3aXRjaChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgIGNhc2UgU0lQLkMuSU5WSVRFOlxuICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMuaXN0W3JlcXVlc3QudmlhX2JyYW5jaF07XG4gICAgICBpZih0cikge1xuICAgICAgICBzd2l0Y2godHIuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgICAgICB0ci50cmFuc3BvcnQuc2VuZCh0ci5sYXN0X3Jlc3BvbnNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBSRkMgNjAyNiA3LjEgSW52aXRlIHJldHJhbnNtaXNzaW9uXG4gICAgICAgICAgICAvL3JlY2VpdmVkIHdoaWxlIGluIEMuU1RBVFVTX0FDQ0VQVEVEIHN0YXRlLiBBYnNvcmIgaXQuXG4gICAgICAgICAgY2FzZSBDLlNUQVRVU19BQ0NFUFRFRDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSVAuQy5BQ0s6XG4gICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5pc3RbcmVxdWVzdC52aWFfYnJhbmNoXTtcblxuICAgICAgLy8gUkZDIDYwMjYgNy4xXG4gICAgICBpZih0cikge1xuICAgICAgICBpZih0ci5zdGF0ZSA9PT0gQy5TVEFUVVNfQUNDRVBURUQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZih0ci5zdGF0ZSA9PT0gQy5TVEFUVVNfQ09NUExFVEVEKSB7XG4gICAgICAgICAgdHIuc3RhdGUgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgdHIuSSA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9JLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0kpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFDSyB0byAyWFggUmVzcG9uc2UuXG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSVAuQy5DQU5DRUw6XG4gICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5pc3RbcmVxdWVzdC52aWFfYnJhbmNoXTtcbiAgICAgIGlmKHRyKSB7XG4gICAgICAgIHJlcXVlc3QucmVwbHlfc2woMjAwKTtcbiAgICAgICAgaWYodHIuc3RhdGUgPT09IEMuU1RBVFVTX1BST0NFRURJTkcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3QucmVwbHlfc2woNDgxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuXG4gICAgICAvLyBOb24tSU5WSVRFIFNlcnZlciBUcmFuc2FjdGlvbiBSRkMgMzI2MSAxNy4yLjJcbiAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLm5pc3RbcmVxdWVzdC52aWFfYnJhbmNoXTtcbiAgICAgIGlmKHRyKSB7XG4gICAgICAgIHN3aXRjaCh0ci5zdGF0ZSkge1xuICAgICAgICAgIGNhc2UgQy5TVEFUVVNfVFJZSU5HOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBDLlNUQVRVU19QUk9DRUVESU5HOlxuICAgICAgICAgIGNhc2UgQy5TVEFUVVNfQ09NUExFVEVEOlxuICAgICAgICAgICAgdHIudHJhbnNwb3J0LnNlbmQodHIubGFzdF9yZXNwb25zZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5TSVAuVHJhbnNhY3Rpb25zID0ge1xuICBDOiBDLFxuICBjaGVja1RyYW5zYWN0aW9uOiBjaGVja1RyYW5zYWN0aW9uLFxuICBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbjogTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sXG4gIEludml0ZUNsaWVudFRyYW5zYWN0aW9uOiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbixcbiAgQWNrQ2xpZW50VHJhbnNhY3Rpb246IEFja0NsaWVudFRyYW5zYWN0aW9uLFxuICBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbjogTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sXG4gIEludml0ZVNlcnZlclRyYW5zYWN0aW9uOiBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvblxufTtcblxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvVHJhbnNhY3Rpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgRGlhbG9nXG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSBTSVAgZGlhbG9nLlxuICogQHBhcmFtIHtTSVAuUlRDU2Vzc2lvbn0gb3duZXJcbiAqIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdHxTSVAuSW5jb21pbmdSZXNwb25zZX0gbWVzc2FnZVxuICogQHBhcmFtIHtFbnVtfSB0eXBlIFVBQyAvIFVBU1xuICogQHBhcmFtIHtFbnVtfSBzdGF0ZSBTSVAuRGlhbG9nLkMuU1RBVFVTX0VBUkxZIC8gU0lQLkRpYWxvZy5DLlNUQVRVU19DT05GSVJNRURcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG5cbnZhciBSZXF1ZXN0U2VuZGVyID0gcmVxdWlyZSgnLi9EaWFsb2cvUmVxdWVzdFNlbmRlcicpKFNJUCk7XG5cbnZhciBEaWFsb2csXG4gIEMgPSB7XG4gICAgLy8gRGlhbG9nIHN0YXRlc1xuICAgIFNUQVRVU19FQVJMWTogICAgICAgMSxcbiAgICBTVEFUVVNfQ09ORklSTUVEOiAgIDJcbiAgfTtcblxuLy8gUkZDIDMyNjEgMTIuMVxuRGlhbG9nID0gZnVuY3Rpb24ob3duZXIsIG1lc3NhZ2UsIHR5cGUsIHN0YXRlKSB7XG4gIHZhciBjb250YWN0O1xuXG4gIHRoaXMudWFjX3BlbmRpbmdfcmVwbHkgPSBmYWxzZTtcbiAgdGhpcy51YXNfcGVuZGluZ19yZXBseSA9IGZhbHNlO1xuXG4gIGlmKCFtZXNzYWdlLmhhc0hlYWRlcignY29udGFjdCcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiAndW5hYmxlIHRvIGNyZWF0ZSBhIERpYWxvZyB3aXRob3V0IENvbnRhY3QgaGVhZGVyIGZpZWxkJ1xuICAgIH07XG4gIH1cblxuICBpZihtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVzcG9uc2UpIHtcbiAgICBzdGF0ZSA9IChtZXNzYWdlLnN0YXR1c19jb2RlIDwgMjAwKSA/IEMuU1RBVFVTX0VBUkxZIDogQy5TVEFUVVNfQ09ORklSTUVEO1xuICB9IGVsc2Uge1xuICAgIC8vIENyZWF0ZSBjb25maXJtZWQgZGlhbG9nIGlmIHN0YXRlIGlzIG5vdCBkZWZpbmVkXG4gICAgc3RhdGUgPSBzdGF0ZSB8fCBDLlNUQVRVU19DT05GSVJNRUQ7XG4gIH1cblxuICBjb250YWN0ID0gbWVzc2FnZS5wYXJzZUhlYWRlcignY29udGFjdCcpO1xuXG4gIC8vIFJGQyAzMjYxIDEyLjEuMVxuICBpZih0eXBlID09PSAnVUFTJykge1xuICAgIHRoaXMuaWQgPSB7XG4gICAgICBjYWxsX2lkOiBtZXNzYWdlLmNhbGxfaWQsXG4gICAgICBsb2NhbF90YWc6IG1lc3NhZ2UudG9fdGFnLFxuICAgICAgcmVtb3RlX3RhZzogbWVzc2FnZS5mcm9tX3RhZyxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbF9pZCArIHRoaXMubG9jYWxfdGFnICsgdGhpcy5yZW1vdGVfdGFnO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMucmVtb3RlX3NlcW51bSA9IG1lc3NhZ2UuY3NlcTtcbiAgICB0aGlzLmxvY2FsX3VyaSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ3RvJykudXJpO1xuICAgIHRoaXMucmVtb3RlX3VyaSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2Zyb20nKS51cmk7XG4gICAgdGhpcy5yZW1vdGVfdGFyZ2V0ID0gY29udGFjdC51cmk7XG4gICAgdGhpcy5yb3V0ZV9zZXQgPSBtZXNzYWdlLmdldEhlYWRlcnMoJ3JlY29yZC1yb3V0ZScpO1xuICAgIHRoaXMuaW52aXRlX3NlcW51bSA9IG1lc3NhZ2UuY3NlcTtcbiAgICB0aGlzLmxvY2FsX3NlcW51bSA9IG1lc3NhZ2UuY3NlcTtcbiAgfVxuICAvLyBSRkMgMzI2MSAxMi4xLjJcbiAgZWxzZSBpZih0eXBlID09PSAnVUFDJykge1xuICAgIHRoaXMuaWQgPSB7XG4gICAgICBjYWxsX2lkOiBtZXNzYWdlLmNhbGxfaWQsXG4gICAgICBsb2NhbF90YWc6IG1lc3NhZ2UuZnJvbV90YWcsXG4gICAgICByZW1vdGVfdGFnOiBtZXNzYWdlLnRvX3RhZyxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbF9pZCArIHRoaXMubG9jYWxfdGFnICsgdGhpcy5yZW1vdGVfdGFnO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuaW52aXRlX3NlcW51bSA9IG1lc3NhZ2UuY3NlcTtcbiAgICB0aGlzLmxvY2FsX3NlcW51bSA9IG1lc3NhZ2UuY3NlcTtcbiAgICB0aGlzLmxvY2FsX3VyaSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2Zyb20nKS51cmk7XG4gICAgdGhpcy5wcmFja2VkID0gW107XG4gICAgdGhpcy5yZW1vdGVfdXJpID0gbWVzc2FnZS5wYXJzZUhlYWRlcigndG8nKS51cmk7XG4gICAgdGhpcy5yZW1vdGVfdGFyZ2V0ID0gY29udGFjdC51cmk7XG4gICAgdGhpcy5yb3V0ZV9zZXQgPSBtZXNzYWdlLmdldEhlYWRlcnMoJ3JlY29yZC1yb3V0ZScpLnJldmVyc2UoKTtcblxuICAgIC8vUkVOREVSQk9EWVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDLlNUQVRVU19FQVJMWSAmJiAoIW93bmVyLmhhc09mZmVyKSkge1xuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIgPSBvd25lci5tZWRpYUhhbmRsZXJGYWN0b3J5KG93bmVyKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmxvZ2dlciA9IG93bmVyLnVhLmdldExvZ2dlcignc2lwLmRpYWxvZycsIHRoaXMuaWQudG9TdHJpbmcoKSk7XG4gIHRoaXMub3duZXIgPSBvd25lcjtcbiAgb3duZXIudWEuZGlhbG9nc1t0aGlzLmlkLnRvU3RyaW5nKCldID0gdGhpcztcbiAgdGhpcy5sb2dnZXIubG9nKCduZXcgJyArIHR5cGUgKyAnIGRpYWxvZyBjcmVhdGVkIHdpdGggc3RhdHVzICcgKyAodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfRUFSTFkgPyAnRUFSTFknOiAnQ09ORklSTUVEJykpO1xuICBvd25lci5lbWl0KCdkaWFsb2cnLCB0aGlzKTtcbn07XG5cbkRpYWxvZy5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1NJUC5JbmNvbWluZ01lc3NhZ2V9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtFbnVtfSBVQUMvVUFTXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICB0aGlzLnN0YXRlID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKCdkaWFsb2cgJysgdGhpcy5pZC50b1N0cmluZygpICsnICBjaGFuZ2VkIHRvIENPTkZJUk1FRCBzdGF0ZScpO1xuXG4gICAgaWYodHlwZSA9PT0gJ1VBQycpIHtcbiAgICAgIC8vIFJGQyAzMjYxIDEzLjIuMi40XG4gICAgICB0aGlzLnJvdXRlX3NldCA9IG1lc3NhZ2UuZ2V0SGVhZGVycygncmVjb3JkLXJvdXRlJykucmV2ZXJzZSgpO1xuICAgIH1cbiAgfSxcblxuICB0ZXJtaW5hdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnZGlhbG9nICcgKyB0aGlzLmlkLnRvU3RyaW5nKCkgKyAnIGRlbGV0ZWQnKTtcbiAgICBpZiAodGhpcy5tZWRpYUhhbmRsZXIgJiYgdGhpcy5zdGF0ZSAhPT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aGlzLm1lZGlhSGFuZGxlci5wZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5vd25lci51YS5kaWFsb2dzW3RoaXMuaWQudG9TdHJpbmcoKV07XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCByZXF1ZXN0IG1ldGhvZFxuICAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYUhlYWRlcnMgZXh0cmEgaGVhZGVyc1xuICAqIEByZXR1cm5zIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fVxuICAqL1xuXG4gIC8vIFJGQyAzMjYxIDEyLjIuMS4xXG4gIGNyZWF0ZVJlcXVlc3Q6IGZ1bmN0aW9uKG1ldGhvZCwgZXh0cmFIZWFkZXJzLCBib2R5KSB7XG4gICAgdmFyIGNzZXEsIHJlcXVlc3Q7XG4gICAgZXh0cmFIZWFkZXJzID0gKGV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcblxuICAgIGlmKCF0aGlzLmxvY2FsX3NlcW51bSkgeyB0aGlzLmxvY2FsX3NlcW51bSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTsgfVxuXG4gICAgY3NlcSA9IChtZXRob2QgPT09IFNJUC5DLkNBTkNFTCB8fCBtZXRob2QgPT09IFNJUC5DLkFDSykgPyB0aGlzLmludml0ZV9zZXFudW0gOiB0aGlzLmxvY2FsX3NlcW51bSArPSAxO1xuXG4gICAgcmVxdWVzdCA9IG5ldyBTSVAuT3V0Z29pbmdSZXF1ZXN0KFxuICAgICAgbWV0aG9kLFxuICAgICAgdGhpcy5yZW1vdGVfdGFyZ2V0LFxuICAgICAgdGhpcy5vd25lci51YSwge1xuICAgICAgICAnY3NlcSc6IGNzZXEsXG4gICAgICAgICdjYWxsX2lkJzogdGhpcy5pZC5jYWxsX2lkLFxuICAgICAgICAnZnJvbV91cmknOiB0aGlzLmxvY2FsX3VyaSxcbiAgICAgICAgJ2Zyb21fdGFnJzogdGhpcy5pZC5sb2NhbF90YWcsXG4gICAgICAgICd0b191cmknOiB0aGlzLnJlbW90ZV91cmksXG4gICAgICAgICd0b190YWcnOiB0aGlzLmlkLnJlbW90ZV90YWcsXG4gICAgICAgICdyb3V0ZV9zZXQnOiB0aGlzLnJvdXRlX3NldFxuICAgICAgfSwgZXh0cmFIZWFkZXJzLCBib2R5KTtcblxuICAgIHJlcXVlc3QuZGlhbG9nID0gdGhpcztcblxuICAgIHJldHVybiByZXF1ZXN0O1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdH0gcmVxdWVzdFxuICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAqL1xuXG4gIC8vIFJGQyAzMjYxIDEyLjIuMlxuICBjaGVja0luRGlhbG9nUmVxdWVzdDogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmKCF0aGlzLnJlbW90ZV9zZXFudW0pIHtcbiAgICAgIHRoaXMucmVtb3RlX3NlcW51bSA9IHJlcXVlc3QuY3NlcTtcbiAgICB9IGVsc2UgaWYocmVxdWVzdC5jc2VxIDwgdGhpcy5yZW1vdGVfc2VxbnVtKSB7XG4gICAgICAgIC8vRG8gbm90IHRyeSB0byByZXBseSB0byBhbiBBQ0sgcmVxdWVzdC5cbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSBTSVAuQy5BQ0spIHtcbiAgICAgICAgICByZXF1ZXN0LnJlcGx5KDUwMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QuY3NlcSA9PT0gdGhpcy5pbnZpdGVfc2VxbnVtKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZihyZXF1ZXN0LmNzZXEgPiB0aGlzLnJlbW90ZV9zZXFudW0pIHtcbiAgICAgIHRoaXMucmVtb3RlX3NlcW51bSA9IHJlcXVlc3QuY3NlcTtcbiAgICB9XG5cbiAgICBzd2l0Y2gocmVxdWVzdC5tZXRob2QpIHtcbiAgICAgIC8vIFJGQzMyNjEgMTQuMiBNb2RpZnlpbmcgYW4gRXhpc3RpbmcgU2Vzc2lvbiAtVUFTIEJFSEFWSU9SLVxuICAgICAgY2FzZSBTSVAuQy5JTlZJVEU6XG4gICAgICAgIGlmICh0aGlzLnVhY19wZW5kaW5nX3JlcGx5ID09PSB0cnVlKSB7XG4gICAgICAgICAgcmVxdWVzdC5yZXBseSg0OTEpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudWFzX3BlbmRpbmdfcmVwbHkgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgcmV0cnlBZnRlciA9IChNYXRoLnJhbmRvbSgpICogMTAgfCAwKSArIDE7XG4gICAgICAgICAgcmVxdWVzdC5yZXBseSg1MDAsIG51bGwsIFsnUmV0cnktQWZ0ZXI6JyArIHJldHJ5QWZ0ZXJdKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51YXNfcGVuZGluZ19yZXBseSA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24ub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZCgpe1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfQUNDRVBURUQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX0NPTVBMRVRFRCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuXG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3N0YXRlQ2hhbmdlZCcsIHN0YXRlQ2hhbmdlZCk7XG4gICAgICAgICAgICAgIHNlbGYudWFzX3BlbmRpbmdfcmVwbHkgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAoc2VsZi51YWNfcGVuZGluZ19yZXBseSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm93bmVyLm9uUmVhZHlUb1JlaW52aXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJGQzMyNjEgMTIuMi4yIFJlcGxhY2UgdGhlIGRpYWxvZ2BzIHJlbW90ZSB0YXJnZXQgVVJJIGlmIHRoZSByZXF1ZXN0IGlzIGFjY2VwdGVkXG4gICAgICAgIGlmKHJlcXVlc3QuaGFzSGVhZGVyKCdjb250YWN0JykpIHtcbiAgICAgICAgICByZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbi5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX0FDQ0VQVEVEKSB7XG4gICAgICAgICAgICAgIHNlbGYucmVtb3RlX3RhcmdldCA9IHJlcXVlc3QucGFyc2VIZWFkZXIoJ2NvbnRhY3QnKS51cmk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLk5PVElGWTpcbiAgICAgICAgLy8gUkZDNjY2NSAzLjIgUmVwbGFjZSB0aGUgZGlhbG9nYHMgcmVtb3RlIHRhcmdldCBVUkkgaWYgdGhlIHJlcXVlc3QgaXMgYWNjZXB0ZWRcbiAgICAgICAgaWYocmVxdWVzdC5oYXNIZWFkZXIoJ2NvbnRhY3QnKSkge1xuICAgICAgICAgIHJlcXVlc3Quc2VydmVyX3RyYW5zYWN0aW9uLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfQ09NUExFVEVEKSB7XG4gICAgICAgICAgICAgIHNlbGYucmVtb3RlX3RhcmdldCA9IHJlcXVlc3QucGFyc2VIZWFkZXIoJ2NvbnRhY3QnKS51cmk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgc2VuZFJlcXVlc3Q6IGZ1bmN0aW9uKGFwcGxpY2FudCwgbWV0aG9kLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXJcbiAgICAgIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSxcbiAgICAgIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgbnVsbCxcbiAgICAgIHJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QobWV0aG9kLCBleHRyYUhlYWRlcnMsIGJvZHkpLFxuICAgICAgcmVxdWVzdF9zZW5kZXIgPSBuZXcgUmVxdWVzdFNlbmRlcih0aGlzLCBhcHBsaWNhbnQsIHJlcXVlc3QpO1xuXG4gICAgcmVxdWVzdF9zZW5kZXIuc2VuZCgpO1xuXG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0XG4gICovXG4gIHJlY2VpdmVSZXF1ZXN0OiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgLy9DaGVjayBpbi1kaWFsb2cgcmVxdWVzdFxuICAgIGlmKCF0aGlzLmNoZWNrSW5EaWFsb2dSZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vd25lci5yZWNlaXZlUmVxdWVzdChyZXF1ZXN0KTtcbiAgfVxufTtcblxuRGlhbG9nLkMgPSBDO1xuU0lQLkRpYWxvZyA9IERpYWxvZztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0RpYWxvZ3MuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSW4tRGlhbG9nIFJlcXVlc3QgU2VuZGVyXG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQLkRpYWxvZ1xuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGFuIEluLWRpYWxvZyByZXF1ZXN0IHNlbmRlci5cbiAqIEBwYXJhbSB7U0lQLkRpYWxvZ30gZGlhbG9nXG4gKiBAcGFyYW0ge09iamVjdH0gYXBwbGljYW50XG4gKiBAcGFyYW0ge1NJUC5PdXRnb2luZ1JlcXVlc3R9IHJlcXVlc3RcbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGluLURpYWxvZyBSZXF1ZXN0IFNlbmRlclxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIFJlcXVlc3RTZW5kZXI7XG5cblJlcXVlc3RTZW5kZXIgPSBmdW5jdGlvbihkaWFsb2csIGFwcGxpY2FudCwgcmVxdWVzdCkge1xuXG4gIHRoaXMuZGlhbG9nID0gZGlhbG9nO1xuICB0aGlzLmFwcGxpY2FudCA9IGFwcGxpY2FudDtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcblxuICAvLyBSRkMzMjYxIDE0LjEgTW9kaWZ5aW5nIGFuIEV4aXN0aW5nIFNlc3Npb24uIFVBQyBCZWhhdmlvci5cbiAgdGhpcy5yZWF0dGVtcHQgPSBmYWxzZTtcbiAgdGhpcy5yZWF0dGVtcHRUaW1lciA9IG51bGw7XG59O1xuXG5SZXF1ZXN0U2VuZGVyLnByb3RvdHlwZSA9IHtcbiAgc2VuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgcmVxdWVzdF9zZW5kZXIgPSBuZXcgU0lQLlJlcXVlc3RTZW5kZXIodGhpcywgdGhpcy5kaWFsb2cub3duZXIudWEpO1xuXG4gICAgICByZXF1ZXN0X3NlbmRlci5zZW5kKCk7XG5cbiAgICAvLyBSRkMzMjYxIDE0LjIgTW9kaWZ5aW5nIGFuIEV4aXN0aW5nIFNlc3Npb24gLVVBQyBCRUhBVklPUi1cbiAgICBpZiAodGhpcy5yZXF1ZXN0Lm1ldGhvZCA9PT0gU0lQLkMuSU5WSVRFICYmIHJlcXVlc3Rfc2VuZGVyLmNsaWVudFRyYW5zYWN0aW9uLnN0YXRlICE9PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZGlhbG9nLnVhY19wZW5kaW5nX3JlcGx5ID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3Rfc2VuZGVyLmNsaWVudFRyYW5zYWN0aW9uLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoKXtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfQUNDRVBURUQgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfQ09NUExFVEVEIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX1RFUk1JTkFURUQpIHtcblxuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3N0YXRlQ2hhbmdlZCcsIHN0YXRlQ2hhbmdlZCk7XG4gICAgICAgICAgc2VsZi5kaWFsb2cudWFjX3BlbmRpbmdfcmVwbHkgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChzZWxmLmRpYWxvZy51YXNfcGVuZGluZ19yZXBseSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHNlbGYuZGlhbG9nLm93bmVyLm9uUmVhZHlUb1JlaW52aXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hcHBsaWNhbnQub25SZXF1ZXN0VGltZW91dCgpO1xuICB9LFxuXG4gIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXBwbGljYW50Lm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfSxcblxuICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gUkZDMzI2MSAxMi4yLjEuMiA0MDggb3IgNDgxIGlzIHJlY2VpdmVkIGZvciBhIHJlcXVlc3Qgd2l0aGluIGEgZGlhbG9nLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNfY29kZSA9PT0gNDA4IHx8IHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSA0ODEpIHtcbiAgICAgIHRoaXMuYXBwbGljYW50Lm9uRGlhbG9nRXJyb3IocmVzcG9uc2UpO1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2UubWV0aG9kID09PSBTSVAuQy5JTlZJVEUgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDQ5MSkge1xuICAgICAgaWYgKHRoaXMucmVhdHRlbXB0KSB7XG4gICAgICAgIHRoaXMuYXBwbGljYW50LnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcXVlc3QuY3NlcS52YWx1ZSA9IHRoaXMuZGlhbG9nLmxvY2FsX3NlcW51bSArPSAxO1xuICAgICAgICB0aGlzLnJlYXR0ZW1wdFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuYXBwbGljYW50Lm93bmVyLnN0YXR1cyAhPT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgICBzZWxmLnJlYXR0ZW1wdCA9IHRydWU7XG4gICAgICAgICAgICAgIHNlbGYucmVxdWVzdF9zZW5kZXIuc2VuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhpcy5nZXRSZWF0dGVtcHRUaW1lb3V0KClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBsaWNhbnQucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gIH1cbn07XG5cbnJldHVybiBSZXF1ZXN0U2VuZGVyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvRGlhbG9nL1JlcXVlc3RTZW5kZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWVzdCBTZW5kZXJcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIHJlcXVlc3Qgc2VuZGVyLlxuICogQHBhcmFtIHtPYmplY3R9IGFwcGxpY2FudFxuICogQHBhcmFtIHtTSVAuVUF9IHVhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIFJlcXVlc3RTZW5kZXI7XG5cblJlcXVlc3RTZW5kZXIgPSBmdW5jdGlvbihhcHBsaWNhbnQsIHVhKSB7XG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAucmVxdWVzdHNlbmRlcicpO1xuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMuYXBwbGljYW50ID0gYXBwbGljYW50O1xuICB0aGlzLm1ldGhvZCA9IGFwcGxpY2FudC5yZXF1ZXN0Lm1ldGhvZDtcbiAgdGhpcy5yZXF1ZXN0ID0gYXBwbGljYW50LnJlcXVlc3Q7XG4gIHRoaXMuY3JlZGVudGlhbHMgPSBudWxsO1xuICB0aGlzLmNoYWxsZW5nZWQgPSBmYWxzZTtcbiAgdGhpcy5zdGFsZWQgPSBmYWxzZTtcblxuICAvLyBJZiB1YSBpcyBpbiBjbG9zaW5nIHByb2Nlc3Mgb3IgZXZlbiBjbG9zZWQganVzdCBhbGxvdyBzZW5kaW5nIEJ5ZSBhbmQgQUNLXG4gIGlmICh1YS5zdGF0dXMgPT09IFNJUC5VQS5DLlNUQVRVU19VU0VSX0NMT1NFRCAmJiAodGhpcy5tZXRob2QgIT09IFNJUC5DLkJZRSB8fCB0aGlzLm1ldGhvZCAhPT0gU0lQLkMuQUNLKSkge1xuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG59O1xuXG4vKipcbiogQ3JlYXRlIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gYW5kIHNlbmQgdGhlIG1lc3NhZ2UuXG4qL1xuUmVxdWVzdFNlbmRlci5wcm90b3R5cGUgPSB7XG4gIHNlbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCh0aGlzLm1ldGhvZCkge1xuICAgICAgY2FzZSBcIklOVklURVwiOlxuICAgICAgICB0aGlzLmNsaWVudFRyYW5zYWN0aW9uID0gbmV3IFNJUC5UcmFuc2FjdGlvbnMuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24odGhpcywgdGhpcy5yZXF1ZXN0LCB0aGlzLnVhLnRyYW5zcG9ydCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFDS1wiOlxuICAgICAgICB0aGlzLmNsaWVudFRyYW5zYWN0aW9uID0gbmV3IFNJUC5UcmFuc2FjdGlvbnMuQWNrQ2xpZW50VHJhbnNhY3Rpb24odGhpcywgdGhpcy5yZXF1ZXN0LCB0aGlzLnVhLnRyYW5zcG9ydCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5jbGllbnRUcmFuc2FjdGlvbiA9IG5ldyBTSVAuVHJhbnNhY3Rpb25zLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uKHRoaXMsIHRoaXMucmVxdWVzdCwgdGhpcy51YS50cmFuc3BvcnQpO1xuICAgIH1cbiAgICB0aGlzLmNsaWVudFRyYW5zYWN0aW9uLnNlbmQoKTtcblxuICAgIHJldHVybiB0aGlzLmNsaWVudFRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gcmVjZWl2aW5nIGEgcmVxdWVzdCB0aW1lb3V0IGVycm9yIGZyb20gdGhlIGNsaWVudCB0cmFuc2FjdGlvbi5cbiAgKiBUbyBiZSByZS1kZWZpbmVkIGJ5IHRoZSBhcHBsaWNhbnQuXG4gICogQGV2ZW50XG4gICovXG4gIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXBwbGljYW50Lm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgfSxcblxuICAvKipcbiAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHJlY2VpdmluZyBhIHRyYW5zcG9ydCBlcnJvciBmcm9tIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24uXG4gICogVG8gYmUgcmUtZGVmaW5lZCBieSB0aGUgYXBwbGljYW50LlxuICAqIEBldmVudFxuICAqL1xuICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFwcGxpY2FudC5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH0sXG5cbiAgLyoqXG4gICogQ2FsbGVkIGZyb20gY2xpZW50IHRyYW5zYWN0aW9uIHdoZW4gcmVjZWl2aW5nIGEgY29ycmVjdCByZXNwb25zZSB0byB0aGUgcmVxdWVzdC5cbiAgKiBBdXRoZW50aWNhdGUgcmVxdWVzdCBpZiBuZWVkZWQgb3IgcGFzcyB0aGUgcmVzcG9uc2UgYmFjayB0byB0aGUgYXBwbGljYW50LlxuICAqIEBwYXJhbSB7U0lQLkluY29taW5nUmVzcG9uc2V9IHJlc3BvbnNlXG4gICovXG4gIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB2YXIgY3NlcSwgY2hhbGxlbmdlLCBhdXRob3JpemF0aW9uX2hlYWRlcl9uYW1lLFxuICAgICAgc3RhdHVzX2NvZGUgPSByZXNwb25zZS5zdGF0dXNfY29kZTtcblxuICAgIC8qXG4gICAgKiBBdXRoZW50aWNhdGlvblxuICAgICogQXV0aGVudGljYXRlIG9uY2UuIF9jaGFsbGVuZ2VkXyBmbGFnIHVzZWQgdG8gYXZvaWQgaW5maW5pdGUgYXV0aGVudGljYXRpb25zLlxuICAgICovXG4gICAgaWYgKHN0YXR1c19jb2RlID09PSA0MDEgfHwgc3RhdHVzX2NvZGUgPT09IDQwNykge1xuXG4gICAgICAvLyBHZXQgYW5kIHBhcnNlIHRoZSBhcHByb3ByaWF0ZSBXV1ctQXV0aGVudGljYXRlIG9yIFByb3h5LUF1dGhlbnRpY2F0ZSBoZWFkZXIuXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDQwMSkge1xuICAgICAgICBjaGFsbGVuZ2UgPSByZXNwb25zZS5wYXJzZUhlYWRlcignd3d3LWF1dGhlbnRpY2F0ZScpO1xuICAgICAgICBhdXRob3JpemF0aW9uX2hlYWRlcl9uYW1lID0gJ2F1dGhvcml6YXRpb24nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbGxlbmdlID0gcmVzcG9uc2UucGFyc2VIZWFkZXIoJ3Byb3h5LWF1dGhlbnRpY2F0ZScpO1xuICAgICAgICBhdXRob3JpemF0aW9uX2hlYWRlcl9uYW1lID0gJ3Byb3h5LWF1dGhvcml6YXRpb24nO1xuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZnkgaXQgc2VlbXMgYSB2YWxpZCBjaGFsbGVuZ2UuXG4gICAgICBpZiAoISBjaGFsbGVuZ2UpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihyZXNwb25zZS5zdGF0dXNfY29kZSArICcgd2l0aCB3cm9uZyBvciBtaXNzaW5nIGNoYWxsZW5nZSwgY2Fubm90IGF1dGhlbnRpY2F0ZScpO1xuICAgICAgICB0aGlzLmFwcGxpY2FudC5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jaGFsbGVuZ2VkIHx8ICghdGhpcy5zdGFsZWQgJiYgY2hhbGxlbmdlLnN0YWxlID09PSB0cnVlKSkge1xuICAgICAgICBpZiAoIXRoaXMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gdGhpcy51YS5jb25maWd1cmF0aW9uLmF1dGhlbnRpY2F0aW9uRmFjdG9yeSh0aGlzLnVhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjaGFsbGVuZ2UgaXMgcmVhbGx5IHZhbGlkLlxuICAgICAgICBpZiAoIXRoaXMuY3JlZGVudGlhbHMuYXV0aGVudGljYXRlKHRoaXMucmVxdWVzdCwgY2hhbGxlbmdlKSkge1xuICAgICAgICAgIHRoaXMuYXBwbGljYW50LnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbGxlbmdlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKGNoYWxsZW5nZS5zdGFsZSkge1xuICAgICAgICAgIHRoaXMuc3RhbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwb25zZS5tZXRob2QgPT09IFNJUC5DLlJFR0lTVEVSKSB7XG4gICAgICAgICAgY3NlcSA9IHRoaXMuYXBwbGljYW50LmNzZXEgKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlcXVlc3QuZGlhbG9nKXtcbiAgICAgICAgICBjc2VxID0gdGhpcy5yZXF1ZXN0LmRpYWxvZy5sb2NhbF9zZXFudW0gKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjc2VxID0gdGhpcy5yZXF1ZXN0LmNzZXEgKyAxO1xuICAgICAgICAgIHRoaXMucmVxdWVzdC5jc2VxID0gY3NlcTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKCdjc2VxJywgY3NlcSArJyAnKyB0aGlzLm1ldGhvZCk7XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcihhdXRob3JpemF0aW9uX2hlYWRlcl9uYW1lLCB0aGlzLmNyZWRlbnRpYWxzLnRvU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLnNlbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwbGljYW50LnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbGljYW50LnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfVxuICB9XG59O1xuXG5TSVAuUmVxdWVzdFNlbmRlciA9IFJlcXVlc3RTZW5kZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9SZXF1ZXN0U2VuZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuXG52YXIgUmVnaXN0ZXJDb250ZXh0O1xuXG5SZWdpc3RlckNvbnRleHQgPSBmdW5jdGlvbiAodWEpIHtcbiAgdmFyIHBhcmFtcyA9IHt9LFxuICAgICAgcmVnSWQgPSAxO1xuXG4gIHRoaXMucmVnaXN0cmFyID0gdWEuY29uZmlndXJhdGlvbi5yZWdpc3RyYXJTZXJ2ZXI7XG4gIHRoaXMuZXhwaXJlcyA9IHVhLmNvbmZpZ3VyYXRpb24ucmVnaXN0ZXJFeHBpcmVzO1xuXG5cbiAgLy8gQ29udGFjdCBoZWFkZXJcbiAgdGhpcy5jb250YWN0ID0gdWEuY29udGFjdC50b1N0cmluZygpO1xuXG4gIGlmKHJlZ0lkKSB7XG4gICAgdGhpcy5jb250YWN0ICs9ICc7cmVnLWlkPScrIHJlZ0lkO1xuICAgIHRoaXMuY29udGFjdCArPSAnOytzaXAuaW5zdGFuY2U9XCI8dXJuOnV1aWQ6JysgdWEuY29uZmlndXJhdGlvbi5pbnN0YW5jZUlkKyc+XCInO1xuICB9XG5cbiAgLy8gQ2FsbC1JRCBhbmQgQ1NlcSB2YWx1ZXMgUkZDMzI2MSAxMC4yXG4gIHRoaXMuY2FsbF9pZCA9IFNJUC5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbigyMik7XG4gIHRoaXMuY3NlcSA9IDgwO1xuXG4gIHRoaXMudG9fdXJpID0gdWEuY29uZmlndXJhdGlvbi51cmk7XG5cbiAgcGFyYW1zLnRvX3VyaSA9IHRoaXMudG9fdXJpO1xuICBwYXJhbXMudG9fZGlzcGxheU5hbWUgPSB1YS5jb25maWd1cmF0aW9uLmRpc3BsYXlOYW1lO1xuICBwYXJhbXMuY2FsbF9pZCA9IHRoaXMuY2FsbF9pZDtcbiAgcGFyYW1zLmNzZXEgPSB0aGlzLmNzZXE7XG5cbiAgLy8gRXh0ZW5kcyBDbGllbnRDb250ZXh0XG4gIFNJUC5VdGlscy5hdWdtZW50KHRoaXMsIFNJUC5DbGllbnRDb250ZXh0LCBbdWEsICdSRUdJU1RFUicsIHRoaXMucmVnaXN0cmFyLCB7cGFyYW1zOiBwYXJhbXN9XSk7XG5cbiAgdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IG51bGw7XG4gIHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gbnVsbDtcblxuICAvLyBTZXQgc3RhdHVzXG4gIHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAucmVnaXN0ZXJjb250ZXh0Jyk7XG59O1xuXG5SZWdpc3RlckNvbnRleHQucHJvdG90eXBlID0ge1xuICByZWdpc3RlcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsIGV4dHJhSGVhZGVycztcblxuICAgIC8vIEhhbmRsZSBPcHRpb25zXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBleHRyYUhlYWRlcnMgPSAodGhpcy5vcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJyArIHRoaXMuY29udGFjdCArICc7ZXhwaXJlcz0nICsgdGhpcy5leHBpcmVzKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcgKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG5cbiAgICAvLyBTYXZlIG9yaWdpbmFsIGV4dHJhSGVhZGVycyB0byBiZSB1c2VkIGluIC5jbG9zZVxuICAgIHRoaXMuY2xvc2VIZWFkZXJzID0gdGhpcy5vcHRpb25zLmNsb3NlV2l0aEhlYWRlcnMgP1xuICAgICAgKHRoaXMub3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCkgOiBbXTtcblxuICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHZhciBjb250YWN0LCBleHBpcmVzLFxuICAgICAgICBjb250YWN0cyA9IHJlc3BvbnNlLmdldEhlYWRlcnMoJ2NvbnRhY3QnKS5sZW5ndGgsXG4gICAgICAgIGNhdXNlO1xuXG4gICAgICAvLyBEaXNjYXJkIHJlc3BvbnNlcyB0byBvbGRlciBSRUdJU1RFUi91bi1SRUdJU1RFUiByZXF1ZXN0cy5cbiAgICAgIGlmKHJlc3BvbnNlLmNzZXEgIT09IHRoaXMuY3NlcSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIHJlZ2lzdHJhdGlvbiB0aW1lclxuICAgICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWdpc3RyYXRpb25UaW1lcik7XG4gICAgICAgIHRoaXMucmVnaXN0cmF0aW9uVGltZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2godHJ1ZSkge1xuICAgICAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICAgIHRoaXMuZW1pdCgnYWNjZXB0ZWQnLCByZXNwb25zZSk7XG5cbiAgICAgICAgICBpZihyZXNwb25zZS5oYXNIZWFkZXIoJ2V4cGlyZXMnKSkge1xuICAgICAgICAgICAgZXhwaXJlcyA9IHJlc3BvbnNlLmdldEhlYWRlcignZXhwaXJlcycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlYXJjaCB0aGUgQ29udGFjdCBwb2ludGluZyB0byB1cyBhbmQgdXBkYXRlIHRoZSBleHBpcmVzIHZhbHVlIGFjY29yZGluZ2x5LlxuICAgICAgICAgIGlmICghY29udGFjdHMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ25vIENvbnRhY3QgaGVhZGVyIGluIHJlc3BvbnNlIHRvIFJFR0lTVEVSLCByZXNwb25zZSBpZ25vcmVkJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZShjb250YWN0cy0tKSB7XG4gICAgICAgICAgICBjb250YWN0ID0gcmVzcG9uc2UucGFyc2VIZWFkZXIoJ2NvbnRhY3QnLCBjb250YWN0cyk7XG4gICAgICAgICAgICBpZihjb250YWN0LnVyaS51c2VyID09PSB0aGlzLnVhLmNvbnRhY3QudXJpLnVzZXIpIHtcbiAgICAgICAgICAgICAgZXhwaXJlcyA9IGNvbnRhY3QuZ2V0UGFyYW0oJ2V4cGlyZXMnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250YWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNvbnRhY3QpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ25vIENvbnRhY3QgaGVhZGVyIHBvaW50aW5nIHRvIHVzLCByZXNwb25zZSBpZ25vcmVkJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZighZXhwaXJlcykge1xuICAgICAgICAgICAgZXhwaXJlcyA9IHRoaXMuZXhwaXJlcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZS1SZWdpc3RlciBiZWZvcmUgdGhlIGV4cGlyYXRpb24gaW50ZXJ2YWwgaGFzIGVsYXBzZWQuXG4gICAgICAgICAgLy8gRm9yIHRoYXQsIGRlY3JlYXNlIHRoZSBleHBpcmVzIHZhbHVlLiBpZTogMyBzZWNvbmRzXG4gICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucmVnaXN0cmF0aW9uVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5yZWdpc3RlcihzZWxmLm9wdGlvbnMpO1xuICAgICAgICAgIH0sIChleHBpcmVzICogMTAwMCkgLSAzMDAwKTtcbiAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmxvZ2dlci53YXJuKCdyZWdpc3RyYXRpb24gZXhwaXJlZCcpO1xuICAgICAgICAgICAgaWYgKHNlbGYucmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgICBzZWxmLnVucmVnaXN0ZXJlZChudWxsLCBTSVAuQy5jYXVzZXMuRVhQSVJFUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZXhwaXJlcyAqIDEwMDApO1xuXG4gICAgICAgICAgLy9TYXZlIGdydXUgdmFsdWVzXG4gICAgICAgICAgaWYgKGNvbnRhY3QuaGFzUGFyYW0oJ3RlbXAtZ3J1dScpKSB7XG4gICAgICAgICAgICB0aGlzLnVhLmNvbnRhY3QudGVtcF9ncnV1ID0gU0lQLlVSSS5wYXJzZShjb250YWN0LmdldFBhcmFtKCd0ZW1wLWdydXUnKS5yZXBsYWNlKC9cIi9nLCcnKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb250YWN0Lmhhc1BhcmFtKCdwdWItZ3J1dScpKSB7XG4gICAgICAgICAgICB0aGlzLnVhLmNvbnRhY3QucHViX2dydXUgPSBTSVAuVVJJLnBhcnNlKGNvbnRhY3QuZ2V0UGFyYW0oJ3B1Yi1ncnV1JykucmVwbGFjZSgvXCIvZywnJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbWl0KCdyZWdpc3RlcmVkJywgcmVzcG9uc2UgfHwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEludGVydmFsIHRvbyBicmllZiBSRkMzMjYxIDEwLjIuOFxuICAgICAgICBjYXNlIC9eNDIzJC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgICAgaWYocmVzcG9uc2UuaGFzSGVhZGVyKCdtaW4tZXhwaXJlcycpKSB7XG4gICAgICAgICAgICAvLyBJbmNyZWFzZSBvdXIgcmVnaXN0cmF0aW9uIGludGVydmFsIHRvIHRoZSBzdWdnZXN0ZWQgbWluaW11bVxuICAgICAgICAgICAgdGhpcy5leHBpcmVzID0gcmVzcG9uc2UuZ2V0SGVhZGVyKCdtaW4tZXhwaXJlcycpO1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0aGUgcmVnaXN0cmF0aW9uIGFnYWluIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIHsgLy9UaGlzIHJlc3BvbnNlIE1VU1QgY29udGFpbiBhIE1pbi1FeHBpcmVzIGhlYWRlciBmaWVsZFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignNDIzIHJlc3BvbnNlIHJlY2VpdmVkIGZvciBSRUdJU1RFUiB3aXRob3V0IE1pbi1FeHBpcmVzJyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbkZhaWx1cmUocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5TSVBfRkFJTFVSRV9DT0RFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2F1c2UgPSBTSVAuVXRpbHMuc2lwRXJyb3JDYXVzZShyZXNwb25zZS5zdGF0dXNfY29kZSk7XG4gICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25GYWlsdXJlKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25GYWlsdXJlKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uRmFpbHVyZShudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfTtcblxuICAgIHRoaXMuY3NlcSsrO1xuICAgIHRoaXMucmVxdWVzdC5jc2VxID0gdGhpcy5jc2VxO1xuICAgIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoJ2NzZXEnLCB0aGlzLmNzZXEgKyAnIFJFR0lTVEVSJyk7XG4gICAgdGhpcy5yZXF1ZXN0LmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcbiAgICB0aGlzLnNlbmQoKTtcbiAgfSxcblxuICByZWdpc3RyYXRpb25GYWlsdXJlOiBmdW5jdGlvbiAocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgdGhpcy5lbWl0KCdmYWlsZWQnLCByZXNwb25zZSB8fCBudWxsLCBjYXVzZSB8fCBudWxsKTtcbiAgfSxcblxuICBvblRyYW5zcG9ydENsb3NlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkX2JlZm9yZSA9IHRoaXMucmVnaXN0ZXJlZDtcbiAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25UaW1lciAhPT0gbnVsbCkge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWdpc3RyYXRpb25UaW1lcik7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgIT09IG51bGwpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyKTtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZih0aGlzLnJlZ2lzdGVyZWQpIHtcbiAgICAgIHRoaXMudW5yZWdpc3RlcmVkKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9XG4gIH0sXG5cbiAgb25UcmFuc3BvcnRDb25uZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVnaXN0ZXIodGhpcy5vcHRpb25zKTtcbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhbGw6IGZhbHNlLFxuICAgICAgZXh0cmFIZWFkZXJzOiB0aGlzLmNsb3NlSGVhZGVyc1xuICAgIH07XG5cbiAgICB0aGlzLnJlZ2lzdGVyZWRfYmVmb3JlID0gdGhpcy5yZWdpc3RlcmVkO1xuICAgIHRoaXMudW5yZWdpc3RlcihvcHRpb25zKTtcbiAgfSxcblxuICB1bnJlZ2lzdGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGV4dHJhSGVhZGVycztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYoIXRoaXMucmVnaXN0ZXJlZCAmJiAhb3B0aW9ucy5hbGwpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2FscmVhZHkgdW5yZWdpc3RlcmVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuXG4gICAgdGhpcy5yZWdpc3RlcmVkID0gZmFsc2U7XG5cbiAgICAvLyBDbGVhciB0aGUgcmVnaXN0cmF0aW9uIHRpbWVyLlxuICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyICE9PSBudWxsKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyKTtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmKG9wdGlvbnMuYWxsKSB7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogKicpO1xuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0V4cGlyZXM6IDAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcrIHRoaXMuY29udGFjdCArICc7ZXhwaXJlcz0wJyk7XG4gICAgfVxuXG5cbiAgICB0aGlzLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB2YXIgY2F1c2U7XG5cbiAgICAgIHN3aXRjaCh0cnVlKSB7XG4gICAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgICAgdGhpcy5lbWl0KCdhY2NlcHRlZCcsIHJlc3BvbnNlKTtcbiAgICAgICAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51bnJlZ2lzdGVyZWQocmVzcG9uc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhdXNlID0gU0lQLlV0aWxzLnNpcEVycm9yQ2F1c2UocmVzcG9uc2Uuc3RhdHVzX2NvZGUpO1xuICAgICAgICAgIHRoaXMudW5yZWdpc3RlcmVkKHJlc3BvbnNlLGNhdXNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBOb3QgYWN0dWFsbHkgdW5yZWdpc3RlcmVkLi4uXG4gICAgICAvL3RoaXMudW5yZWdpc3RlcmVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIE5vdCBhY3R1YWxseSB1bnJlZ2lzdGVyZWQuLi5cbiAgICAgIC8vdGhpcy51bnJlZ2lzdGVyZWQobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH07XG5cbiAgICB0aGlzLmNzZXErKztcbiAgICB0aGlzLnJlcXVlc3QuY3NlcSA9IHRoaXMuY3NlcTtcbiAgICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKCdjc2VxJywgdGhpcy5jc2VxICsgJyBSRUdJU1RFUicpO1xuICAgIHRoaXMucmVxdWVzdC5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG5cbiAgICB0aGlzLnNlbmQoKTtcbiAgfSxcblxuICB1bnJlZ2lzdGVyZWQ6IGZ1bmN0aW9uKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgIHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgndW5yZWdpc3RlcmVkJywgcmVzcG9uc2UgfHwgbnVsbCwgY2F1c2UgfHwgbnVsbCk7XG4gIH1cblxufTtcblxuXG5TSVAuUmVnaXN0ZXJDb250ZXh0ID0gUmVnaXN0ZXJDb250ZXh0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvUmVnaXN0ZXJDb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMjI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBNZWRpYUhhbmRsZXJcbiAqL1xuXG4vKiBNZWRpYUhhbmRsZXJcbiAqIEBjbGFzcyBQZWVyQ29ubmVjdGlvbiBoZWxwZXIgQ2xhc3MuXG4gKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEV2ZW50RW1pdHRlcikge1xudmFyIE1lZGlhSGFuZGxlciA9IGZ1bmN0aW9uKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgLy8ga2VlcCBqc2hpbnQgaGFwcHlcbiAgc2Vzc2lvbiA9IHNlc3Npb247XG4gIG9wdGlvbnMgPSBvcHRpb25zO1xufTtcblxuTWVkaWFIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSwge1xuICBpc1JlYWR5OiB7dmFsdWU6IGZ1bmN0aW9uIGlzUmVhZHkgKCkge319LFxuXG4gIGNsb3NlOiB7dmFsdWU6IGZ1bmN0aW9uIGNsb3NlICgpIHt9fSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IFttZWRpYUhpbnRdIEEgY3VzdG9tIG9iamVjdCBkZXNjcmliaW5nIHRoZSBtZWRpYSB0byBiZSB1c2VkIGR1cmluZyB0aGlzIHNlc3Npb24uXG4gICAqL1xuICBnZXREZXNjcmlwdGlvbjoge3ZhbHVlOiBmdW5jdGlvbiBnZXREZXNjcmlwdGlvbiAobWVkaWFIaW50KSB7XG4gICAgLy8ga2VlcCBqc2hpbnQgaGFwcHlcbiAgICBtZWRpYUhpbnQgPSBtZWRpYUhpbnQ7XG4gIH19LFxuXG4gIC8qKlxuICAqIE1lc3NhZ2UgcmVjZXB0aW9uLlxuICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uXG4gICovXG4gIHNldERlc2NyaXB0aW9uOiB7dmFsdWU6IGZ1bmN0aW9uIHNldERlc2NyaXB0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIC8vIGtlZXAganNoaW50IGhhcHB5XG4gICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgfX1cbn0pO1xuXG5yZXR1cm4gTWVkaWFIYW5kbGVyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvTWVkaWFIYW5kbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIENsaWVudENvbnRleHQ7XG5cbkNsaWVudENvbnRleHQgPSBmdW5jdGlvbiAodWEsIG1ldGhvZCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciBvcmlnaW5hbFRhcmdldCA9IHRhcmdldDtcblxuICAvLyBWYWxpZGF0ZSBhcmd1bWVudHNcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgfVxuXG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5jbGllbnRjb250ZXh0Jyk7XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0YXJnZXQgPSB1YS5ub3JtYWxpemVUYXJnZXQodGFyZ2V0KTtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRhcmdldDogJyArIG9yaWdpbmFsVGFyZ2V0KTtcbiAgfVxuXG4gIC8qIE9wdGlvbnNcbiAgICogLSBleHRyYUhlYWRlcnNcbiAgICogLSBwYXJhbXNcbiAgICogLSBjb250ZW50VHlwZVxuICAgKiAtIGJvZHlcbiAgICovXG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuXG4gIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlKSB7XG4gICAgdGhpcy5jb250ZW50VHlwZSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiAnICsgdGhpcy5jb250ZW50VHlwZSk7XG4gIH1cblxuICAvLyBCdWlsZCB0aGUgcmVxdWVzdFxuICB0aGlzLnJlcXVlc3QgPSBuZXcgU0lQLk91dGdvaW5nUmVxdWVzdCh0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMpO1xuICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgdGhpcy5ib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgIHRoaXMucmVxdWVzdC5ib2R5ID0gdGhpcy5ib2R5O1xuICB9XG5cbiAgLyogU2V0IG90aGVyIHByb3BlcnRpZXMgZnJvbSB0aGUgcmVxdWVzdCAqL1xuICB0aGlzLmxvY2FsSWRlbnRpdHkgPSB0aGlzLnJlcXVlc3QuZnJvbTtcbiAgdGhpcy5yZW1vdGVJZGVudGl0eSA9IHRoaXMucmVxdWVzdC50bztcblxuICB0aGlzLmRhdGEgPSB7fTtcbn07XG5DbGllbnRDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG5DbGllbnRDb250ZXh0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAobmV3IFNJUC5SZXF1ZXN0U2VuZGVyKHRoaXMsIHRoaXMudWEpKS5zZW5kKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQ2xpZW50Q29udGV4dC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGNhbmNlbF9yZWFzb24gPSBTSVAuVXRpbHMuZ2V0Q2FuY2VsUmVhc29uKG9wdGlvbnMuc3RhdHVzX2NvZGUsIG9wdGlvbnMucmVhc29uX3BocmFzZSk7XG4gIHRoaXMucmVxdWVzdC5jYW5jZWwoY2FuY2VsX3JlYXNvbik7XG5cbiAgdGhpcy5lbWl0KCdjYW5jZWwnKTtcbn07XG5cbkNsaWVudENvbnRleHQucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICB2YXIgY2F1c2UgPSBTSVAuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHJlc3BvbnNlLnN0YXR1c19jb2RlKTtcblxuICBzd2l0Y2godHJ1ZSkge1xuICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICBpZih0aGlzLnVhLmFwcGxpY2FudHNbdGhpc10pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudWEuYXBwbGljYW50c1t0aGlzXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgnYWNjZXB0ZWQnLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYodGhpcy51YS5hcHBsaWNhbnRzW3RoaXNdKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVhLmFwcGxpY2FudHNbdGhpc107XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ3JlamVjdGVkJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIHRoaXMuZW1pdCgnZmFpbGVkJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbn07XG5cbkNsaWVudENvbnRleHQucHJvdG90eXBlLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgbnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG59O1xuXG5DbGllbnRDb250ZXh0LnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbn07XG5cblNJUC5DbGllbnRDb250ZXh0ID0gQ2xpZW50Q29udGV4dDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0NsaWVudENvbnRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgU2VydmVyQ29udGV4dDtcblxuU2VydmVyQ29udGV4dCA9IGZ1bmN0aW9uICh1YSwgcmVxdWVzdCkge1xuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuc2VydmVyY29udGV4dCcpO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFNJUC5DLklOVklURSkge1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSBuZXcgU0lQLlRyYW5zYWN0aW9ucy5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbihyZXF1ZXN0LCB1YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyBTSVAuVHJhbnNhY3Rpb25zLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uKHJlcXVlc3QsIHVhKTtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmJvZHkpIHtcbiAgICB0aGlzLmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gIH1cbiAgaWYgKHJlcXVlc3QuaGFzSGVhZGVyKCdDb250ZW50LVR5cGUnKSkge1xuICAgIHRoaXMuY29udGVudFR5cGUgPSByZXF1ZXN0LmdldEhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gIH1cbiAgdGhpcy5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcblxuICB0aGlzLmRhdGEgPSB7fTtcblxuICB0aGlzLmxvY2FsSWRlbnRpdHkgPSByZXF1ZXN0LnRvO1xuICB0aGlzLnJlbW90ZUlkZW50aXR5ID0gcmVxdWVzdC5mcm9tO1xufTtcblxuU2VydmVyQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuU2VydmVyQ29udGV4dC5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICBvcHRpb25zLnN0YXR1c0NvZGUgfHwgKG9wdGlvbnMuc3RhdHVzQ29kZSA9IDE4MCk7XG4gIG9wdGlvbnMubWluQ29kZSA9IDEwMDtcbiAgb3B0aW9ucy5tYXhDb2RlID0gMTk5O1xuICBvcHRpb25zLmV2ZW50cyA9IFsncHJvZ3Jlc3MnXTtcbiAgcmV0dXJuIHRoaXMucmVwbHkob3B0aW9ucyk7XG59O1xuXG5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICBvcHRpb25zLnN0YXR1c0NvZGUgfHwgKG9wdGlvbnMuc3RhdHVzQ29kZSA9IDIwMCk7XG4gIG9wdGlvbnMubWluQ29kZSA9IDIwMDtcbiAgb3B0aW9ucy5tYXhDb2RlID0gMjk5O1xuICBvcHRpb25zLmV2ZW50cyA9IFsnYWNjZXB0ZWQnXTtcbiAgcmV0dXJuIHRoaXMucmVwbHkob3B0aW9ucyk7XG59O1xuXG5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICBvcHRpb25zLnN0YXR1c0NvZGUgfHwgKG9wdGlvbnMuc3RhdHVzQ29kZSA9IDQ4MCk7XG4gIG9wdGlvbnMubWluQ29kZSA9IDMwMDtcbiAgb3B0aW9ucy5tYXhDb2RlID0gNjk5O1xuICBvcHRpb25zLmV2ZW50cyA9IFsncmVqZWN0ZWQnLCAnZmFpbGVkJ107XG4gIHJldHVybiB0aGlzLnJlcGx5KG9wdGlvbnMpO1xufTtcblxuU2VydmVyQ29udGV4dC5wcm90b3R5cGUucmVwbHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gVGhpcyBpcyBva2F5LCBzbyBsb25nIGFzIHdlIHRyZWF0IG9wdGlvbnMgYXMgcmVhZC1vbmx5IGluIHRoaXMgbWV0aG9kXG4gIHZhclxuICAgIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMTAwLFxuICAgIG1pbkNvZGUgPSBvcHRpb25zLm1pbkNvZGUgfHwgMTAwLFxuICAgIG1heENvZGUgPSBvcHRpb25zLm1heENvZGUgfHwgNjk5LFxuICAgIHJlYXNvblBocmFzZSA9IFNJUC5VdGlscy5nZXRSZWFzb25QaHJhc2Uoc3RhdHVzQ29kZSwgb3B0aW9ucy5yZWFzb25QaHJhc2UpLFxuICAgIGV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdLFxuICAgIGJvZHkgPSBvcHRpb25zLmJvZHksXG4gICAgZXZlbnRzID0gb3B0aW9ucy5ldmVudHMgfHwgW10sXG4gICAgcmVzcG9uc2U7XG5cbiAgaWYgKHN0YXR1c0NvZGUgPCBtaW5Db2RlIHx8IHN0YXR1c0NvZGUgPiBtYXhDb2RlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNDb2RlOiAnICsgc3RhdHVzQ29kZSk7XG4gIH1cbiAgcmVzcG9uc2UgPSB0aGlzLnJlcXVlc3QucmVwbHkoc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlLCBleHRyYUhlYWRlcnMsIGJvZHkpO1xuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLmVtaXQoZXZlbnQsIHJlc3BvbnNlLCByZWFzb25QaHJhc2UpO1xuICB9LCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgbnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG59O1xuXG5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbn07XG5cblNJUC5TZXJ2ZXJDb250ZXh0ID0gU2VydmVyQ29udGV4dDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1NlcnZlckNvbnRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQLCBlbnZpcm9ubWVudCkge1xuXG52YXIgRFRNRiA9IHJlcXVpcmUoJy4vU2Vzc2lvbi9EVE1GJykoU0lQKTtcblxudmFyIFNlc3Npb24sIEludml0ZVNlcnZlckNvbnRleHQsIEludml0ZUNsaWVudENvbnRleHQsXG4gQyA9IHtcbiAgICAvL1Nlc3Npb24gc3RhdGVzXG4gICAgU1RBVFVTX05VTEw6ICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICBTVEFUVVNfSU5WSVRFX1NFTlQ6ICAgICAgICAgICAgICAgICAxLFxuICAgIFNUQVRVU18xWFhfUkVDRUlWRUQ6ICAgICAgICAgICAgICAgIDIsXG4gICAgU1RBVFVTX0lOVklURV9SRUNFSVZFRDogICAgICAgICAgICAgMyxcbiAgICBTVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSOiAgICAgICAgICA0LFxuICAgIFNUQVRVU19BTlNXRVJFRDogICAgICAgICAgICAgICAgICAgIDUsXG4gICAgU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLOiAgICAgICAgICAgNixcbiAgICBTVEFUVVNfV0FJVElOR19GT1JfQUNLOiAgICAgICAgICAgICA3LFxuICAgIFNUQVRVU19DQU5DRUxFRDogICAgICAgICAgICAgICAgICAgIDgsXG4gICAgU1RBVFVTX1RFUk1JTkFURUQ6ICAgICAgICAgICAgICAgICAgOSxcbiAgICBTVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0s6IDEwLFxuICAgIFNUQVRVU19FQVJMWV9NRURJQTogICAgICAgICAgICAgICAgMTEsXG4gICAgU1RBVFVTX0NPTkZJUk1FRDogICAgICAgICAgICAgICAgICAxMlxuICB9O1xuXG4vKlxuICogQHBhcmFtIHtmdW5jdGlvbiByZXR1cm5pbmcgU0lQLk1lZGlhSGFuZGxlcn0gW21lZGlhSGFuZGxlckZhY3RvcnldXG4gKiAgICAgICAgKFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIG1lZGlhSGFuZGxlckZhY3RvcnkgYXJndW1lbnQgb2YgdGhlIFVBIGNvbnN0cnVjdG9yLilcbiAqL1xuU2Vzc2lvbiA9IGZ1bmN0aW9uIChtZWRpYUhhbmRsZXJGYWN0b3J5KSB7XG4gIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfTlVMTDtcbiAgdGhpcy5kaWFsb2cgPSBudWxsO1xuICB0aGlzLmVhcmx5RGlhbG9ncyA9IHt9O1xuICB0aGlzLm1lZGlhSGFuZGxlckZhY3RvcnkgPSBtZWRpYUhhbmRsZXJGYWN0b3J5IHx8IFNJUC5XZWJSVEMuTWVkaWFIYW5kbGVyLmRlZmF1bHRGYWN0b3J5O1xuICAvLyB0aGlzLm1lZGlhSGFuZGxlciBnZXRzIHNldCBieSBJQ0MvSVNDIGNvbnN0cnVjdG9yc1xuICB0aGlzLmhhc09mZmVyID0gZmFsc2U7XG4gIHRoaXMuaGFzQW5zd2VyID0gZmFsc2U7XG5cbiAgLy8gU2Vzc2lvbiBUaW1lcnNcbiAgdGhpcy50aW1lcnMgPSB7XG4gICAgYWNrVGltZXI6IG51bGwsXG4gICAgZXhwaXJlc1RpbWVyOiBudWxsLFxuICAgIGludml0ZTJ4eFRpbWVyOiBudWxsLFxuICAgIHVzZXJOb0Fuc3dlclRpbWVyOiBudWxsLFxuICAgIHJlbDF4eFRpbWVyOiBudWxsLFxuICAgIHByYWNrVGltZXI6IG51bGxcbiAgfTtcblxuICAvLyBTZXNzaW9uIGluZm9cbiAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICB0aGlzLmVuZFRpbWUgPSBudWxsO1xuICB0aGlzLnRvbmVzID0gbnVsbDtcblxuICAvLyBNdXRlL0hvbGQgc3RhdGVcbiAgdGhpcy5sb2NhbF9ob2xkID0gZmFsc2U7XG4gIHRoaXMucmVtb3RlX2hvbGQgPSBmYWxzZTtcblxuICB0aGlzLnBlbmRpbmdfYWN0aW9ucyA9IHtcbiAgICBhY3Rpb25zOiBbXSxcblxuICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3Rpb25zLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgaXNQZW5kaW5nOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIHZhclxuICAgICAgaWR4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHRoaXMuYWN0aW9ucy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaWR4OyBpZHg8bGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25zW2lkeF0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHNoaWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFjdGlvbnMuc2hpZnQoKTtcbiAgICB9LFxuXG4gICAgcHVzaDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5hY3Rpb25zLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcG9wOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXJcbiAgICAgIGlkeCA9IDAsXG4gICAgICBsZW5ndGggPSB0aGlzLmFjdGlvbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGlkeDsgaWR4PGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpZHhdLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0aGlzLmFjdGlvbnMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgICBsZW5ndGggLS07XG4gICAgICAgICAgaWR4LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICB9O1xuXG4gIHRoaXMuZWFybHlfc2RwID0gbnVsbDtcbiAgdGhpcy5yZWwxMDAgPSBTSVAuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQ7XG59O1xuXG5TZXNzaW9uLnByb3RvdHlwZSA9IHtcbiAgZHRtZjogZnVuY3Rpb24odG9uZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgdG9uZSwgZHRtZnMgPSBbXSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICh0b25lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19DT05GSVJNRUQgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0b25lc1xuICAgIGlmICgodHlwZW9mIHRvbmVzICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdG9uZXMgIT09ICdudW1iZXInKSB8fCAhdG9uZXMudG9TdHJpbmcoKS5tYXRjaCgvXlswLTlBLUQjKixdKyQvaSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdG9uZXM6ICcrIHRvbmVzKTtcbiAgICB9XG5cbiAgICB0b25lcyA9IHRvbmVzLnRvU3RyaW5nKCkuc3BsaXQoJycpO1xuXG4gICAgd2hpbGUgKHRvbmVzLmxlbmd0aCA+IDApIHsgZHRtZnMucHVzaChuZXcgRFRNRih0aGlzLCB0b25lcy5zaGlmdCgpLCBvcHRpb25zKSk7IH1cblxuICAgIGlmICh0aGlzLnRvbmVzKSB7XG4gICAgICAvLyBUb25lcyBhcmUgYWxyZWFkeSBxdWV1ZWQsIGp1c3QgYWRkIHRvIHRoZSBxdWV1ZVxuICAgICAgdGhpcy50b25lcyA9ICB0aGlzLnRvbmVzLmNvbmNhdChkdG1mcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc2VuZERUTUYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZHRtZiwgdGltZW91dDtcblxuICAgICAgaWYgKHNlbGYuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEIHx8ICFzZWxmLnRvbmVzIHx8IHNlbGYudG9uZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFN0b3Agc2VuZGluZyBEVE1GXG4gICAgICAgIHNlbGYudG9uZXMgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZHRtZiA9IHNlbGYudG9uZXMuc2hpZnQoKTtcblxuICAgICAgaWYgKHRvbmUgPT09ICcsJykge1xuICAgICAgICB0aW1lb3V0ID0gMjAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR0bWYub24oJ2ZhaWxlZCcsIGZ1bmN0aW9uKCl7c2VsZi50b25lcyA9IG51bGw7fSk7XG4gICAgICAgIGR0bWYuc2VuZChvcHRpb25zKTtcbiAgICAgICAgdGltZW91dCA9IGR0bWYuZHVyYXRpb24gKyBkdG1mLmludGVyVG9uZUdhcDtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRpbWVvdXQgZm9yIHRoZSBuZXh0IHRvbmVcbiAgICAgIFNJUC5UaW1lcnMuc2V0VGltZW91dChzZW5kRFRNRiwgdGltZW91dCk7XG4gICAgfTtcblxuICAgIHRoaXMudG9uZXMgPSBkdG1mcztcbiAgICBzZW5kRFRNRigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGJ5ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgdmFyIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGU7XG5cbiAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0Vycm9yOiBBdHRlbXB0ZWQgdG8gc2VuZCBCWUUgaW4gYSB0ZXJtaW5hdGVkIHNlc3Npb24uJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ3Rlcm1pbmF0aW5nIFNlc3Npb24nKTtcblxuICAgIGlmIChzdGF0dXNDb2RlICYmIChzdGF0dXNDb2RlIDwgMjAwIHx8IHN0YXR1c0NvZGUgPj0gNzAwKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNDb2RlOiAnKyBzdGF0dXNDb2RlKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgcmV0dXJuIHRoaXMuXG4gICAgICBzZW5kUmVxdWVzdChTSVAuQy5CWUUsIG9wdGlvbnMpLlxuICAgICAgdGVybWluYXRlZCgpO1xuICB9LFxuXG4gIHJlZmVyOiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpLFxuICAgICAgICB3aXRoUmVwbGFjZXMgPVxuICAgICAgICAgIHRhcmdldCBpbnN0YW5jZW9mIFNJUC5JbnZpdGVTZXJ2ZXJDb250ZXh0IHx8XG4gICAgICAgICAgdGFyZ2V0IGluc3RhbmNlb2YgU0lQLkludml0ZUNsaWVudENvbnRleHQsXG4gICAgICAgIG9yaWdpbmFsVGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgfVxuXG4gICAgLy8gdHJhbnNmb3JtIGB0YXJnZXRgIHNvIHRoYXQgaXQgY2FuIGJlIGEgUmVmZXItVG8gaGVhZGVyIHZhbHVlXG4gICAgaWYgKHdpdGhSZXBsYWNlcykge1xuICAgICAgLy9BdHRlbmRlZCBUcmFuc2ZlclxuICAgICAgLy8gQi50cmFuc2ZlcihDKVxuICAgICAgdGFyZ2V0ID0gJ1wiJyArIHRhcmdldC5yZW1vdGVJZGVudGl0eS5mcmllbmRseU5hbWUgKyAnXCIgJyArXG4gICAgICAgICc8JyArIHRhcmdldC5kaWFsb2cucmVtb3RlX3RhcmdldC50b1N0cmluZygpICtcbiAgICAgICAgJz9SZXBsYWNlcz0nICsgdGFyZ2V0LmRpYWxvZy5pZC5jYWxsX2lkICtcbiAgICAgICAgJyUzQnRvLXRhZyUzRCcgKyB0YXJnZXQuZGlhbG9nLmlkLnJlbW90ZV90YWcgK1xuICAgICAgICAnJTNCZnJvbS10YWclM0QnICsgdGFyZ2V0LmRpYWxvZy5pZC5sb2NhbF90YWcgKyAnPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vQmxpbmQgVHJhbnNmZXJcbiAgICAgIC8vIG5vcm1hbGl6ZVRhcmdldCBhbGxvd3MgaW5zdGFuY2VzIG9mIFNJUC5VUkkgdG8gcGFzcyB0aHJvdWdoIHVuYWx0ZXJlZCxcbiAgICAgIC8vIHNvIHRyeSB0byBtYWtlIG9uZSBhaGVhZCBvZiB0aW1lXG4gICAgICB0cnkge1xuICAgICAgICB0YXJnZXQgPSBTSVAuR3JhbW1hci5wYXJzZSh0YXJnZXQsICdSZWZlcl9UbycpLnVyaSB8fCB0YXJnZXQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiLnJlZmVyKCkgY2Fubm90IHBhcnNlIFJlZmVyX1RvIGZyb21cIiwgdGFyZ2V0KTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCIuLi5mYWxsaW5nIHRocm91Z2ggdG8gbm9ybWFsaXplVGFyZ2V0KClcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHRhcmdldCB2YWxpZGl0eVxuICAgICAgdGFyZ2V0ID0gdGhpcy51YS5ub3JtYWxpemVUYXJnZXQodGFyZ2V0KTtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGFyZ2V0OiAnICsgb3JpZ2luYWxUYXJnZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnKyB0aGlzLmNvbnRhY3QpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJysgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCkpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZWZlci1UbzogJysgdGFyZ2V0KTtcblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLlJFRkVSLCB7XG4gICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICggISAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpICkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5nIHVwIG9ubHkgaWYgd2UgdHJhbnNmZXJyZWQgdG8gYSBTSVAgYWRkcmVzc1xuICAgICAgICBpZiAod2l0aFJlcGxhY2VzIHx8ICh0YXJnZXQuc2NoZW1lICYmIHRhcmdldC5zY2hlbWUubWF0Y2goXCJec2lwcz8kXCIpKSkge1xuICAgICAgICAgIHRoaXMudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGZvbGxvd1JlZmVyOiBmdW5jdGlvbiBmb2xsb3dSZWZlciAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVmZXJMaXN0ZW5lciAoY2FsbGJhY2ssIHJlcXVlc3QpIHtcbiAgICAgIC8vIG9wZW4gbm9uLVNJUCBVUklzIGlmIHBvc3NpYmxlIGFuZCBrZWVwIHNlc3Npb24gb3BlblxuICAgICAgdmFyIHJlZmVyVG8gPSByZXF1ZXN0LnBhcnNlSGVhZGVyKCdyZWZlci10bycpO1xuICAgICAgdmFyIHRhcmdldCA9IHJlZmVyVG8udXJpO1xuICAgICAgaWYgKCF0YXJnZXQuc2NoZW1lLm1hdGNoKFwiXnNpcHM/JFwiKSkge1xuICAgICAgICB2YXIgdGFyZ2V0U3RyaW5nID0gdGFyZ2V0LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0eXBlb2YgZW52aXJvbm1lbnQub3BlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZW52aXJvbm1lbnQub3Blbih0YXJnZXRTdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJyZWZlcnJlZCB0byBub24tU0lQIFVSSSBidXQgYG9wZW5gIGlzbid0IGluIHRoZSBlbnZpcm9ubWVudDogXCIgKyB0YXJnZXRTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IFtdO1xuXG4gICAgICAvKiBDb3B5IHRoZSBSZXBsYWNlcyBxdWVyeSBpbnRvIGEgUmVwbGFjZXMgaGVhZGVyICovXG4gICAgICAvKiBUT0RPIC0gbWFrZSBzdXJlIHdlIGRvbid0IGNvcHkgYSBwb29ybHkgZm9ybWF0dGVkIGhlYWRlcj8gKi9cbiAgICAgIHZhciByZXBsYWNlcyA9IHRhcmdldC5nZXRIZWFkZXIoJ1JlcGxhY2VzJyk7XG4gICAgICBpZiAocmVwbGFjZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVwbGFjZXM6ICcgKyBkZWNvZGVVUklDb21wb25lbnQocmVwbGFjZXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gZG9uJ3QgZW1iZWQgaGVhZGVycyBpbnRvIFJlcXVlc3QtVVJJIG9mIElOVklURVxuICAgICAgdGFyZ2V0LmNsZWFySGVhZGVycygpO1xuXG4gICAgICAvKlxuICAgICAgICBIYXJtbGVzcyByYWNlIGNvbmRpdGlvbi4gIEJvdGggc2lkZXMgb2YgUkVGRVJcbiAgICAgICAgbWF5IHNlbmQgYSBCWUUsIGJ1dCBpbiB0aGUgZW5kIHRoZSBkaWFsb2dzIGFyZSBkZXN0cm95ZWQuXG4gICAgICAqL1xuICAgICAgdmFyIGdldFJlZmVyTWVkaWEgPSB0aGlzLm1lZGlhSGFuZGxlci5nZXRSZWZlck1lZGlhO1xuICAgICAgdmFyIG1lZGlhSGludCA9IGdldFJlZmVyTWVkaWEgPyBnZXRSZWZlck1lZGlhLmNhbGwodGhpcy5tZWRpYUhhbmRsZXIpIDogdGhpcy5tZWRpYUhpbnQ7XG5cbiAgICAgIFNJUC5IYWNrcy5DaHJvbWUuZ2V0c0NvbmZ1c2VkQWJvdXRHVU0odGhpcyk7XG5cbiAgICAgIHZhciByZWZlclNlc3Npb24gPSB0aGlzLnVhLmludml0ZSh0YXJnZXQsIHtcbiAgICAgICAgbWVkaWE6IG1lZGlhSGludCxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgdG9fZGlzcGxheU5hbWU6IHJlZmVyVG8uZnJpZW5kbHlOYW1lXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzXG4gICAgICB9KTtcblxuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCByZXF1ZXN0LCByZWZlclNlc3Npb24pO1xuXG4gICAgICB0aGlzLnRlcm1pbmF0ZSgpO1xuICAgIH0uYmluZCh0aGlzLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgc2VuZFJlcXVlc3Q6IGZ1bmN0aW9uKG1ldGhvZCxvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgU0lQLk91dGdvaW5nUmVxdWVzdChcbiAgICAgIG1ldGhvZCxcbiAgICAgIHRoaXMuZGlhbG9nLnJlbW90ZV90YXJnZXQsXG4gICAgICB0aGlzLnVhLFxuICAgICAge1xuICAgICAgICBjc2VxOiBvcHRpb25zLmNzZXEgfHwgKHRoaXMuZGlhbG9nLmxvY2FsX3NlcW51bSArPSAxKSxcbiAgICAgICAgY2FsbF9pZDogdGhpcy5kaWFsb2cuaWQuY2FsbF9pZCxcbiAgICAgICAgZnJvbV91cmk6IHRoaXMuZGlhbG9nLmxvY2FsX3VyaSxcbiAgICAgICAgZnJvbV90YWc6IHRoaXMuZGlhbG9nLmlkLmxvY2FsX3RhZyxcbiAgICAgICAgdG9fdXJpOiB0aGlzLmRpYWxvZy5yZW1vdGVfdXJpLFxuICAgICAgICB0b190YWc6IHRoaXMuZGlhbG9nLmlkLnJlbW90ZV90YWcsXG4gICAgICAgIHJvdXRlX3NldDogdGhpcy5kaWFsb2cucm91dGVfc2V0LFxuICAgICAgICBzdGF0dXNDb2RlOiBvcHRpb25zLnN0YXR1c0NvZGUsXG4gICAgICAgIHJlYXNvblBocmFzZTogb3B0aW9ucy5yZWFzb25QaHJhc2VcbiAgICAgIH0sXG4gICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSxcbiAgICAgIG9wdGlvbnMuYm9keVxuICAgICk7XG5cbiAgICBuZXcgU0lQLlJlcXVlc3RTZW5kZXIoe1xuICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgICAgIH0sXG4gICAgICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICB9LFxuICAgICAgcmVjZWl2ZVJlc3BvbnNlOiBvcHRpb25zLnJlY2VpdmVSZXNwb25zZSB8fCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBzZWxmLnJlY2VpdmVOb25JbnZpdGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy51YSkuc2VuZCgpO1xuXG4gICAgLy8gRW1pdCB0aGUgcmVxdWVzdCBldmVudFxuICAgIHRoaXMuZW1pdChtZXRob2QudG9Mb3dlckNhc2UoKSwgcmVxdWVzdCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkeDtcblxuICAgIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ2Nsb3NpbmcgSU5WSVRFIHNlc3Npb24gJyArIHRoaXMuaWQpO1xuXG4gICAgLy8gMXN0IFN0ZXAuIFRlcm1pbmF0ZSBtZWRpYS5cbiAgICBpZiAodGhpcy5tZWRpYUhhbmRsZXIpe1xuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuY2xvc2UoKTtcbiAgICB9XG5cbiAgICAvLyAybmQgU3RlcC4gVGVybWluYXRlIHNpZ25hbGluZy5cblxuICAgIC8vIENsZWFyIHNlc3Npb24gdGltZXJzXG4gICAgZm9yKGlkeCBpbiB0aGlzLnRpbWVycykge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnNbaWR4XSk7XG4gICAgfVxuXG4gICAgLy8gVGVybWluYXRlIGRpYWxvZ3NcblxuICAgIC8vIFRlcm1pbmF0ZSBjb25maXJtZWQgZGlhbG9nXG4gICAgaWYodGhpcy5kaWFsb2cpIHtcbiAgICAgIHRoaXMuZGlhbG9nLnRlcm1pbmF0ZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuZGlhbG9nO1xuICAgIH1cblxuICAgIC8vIFRlcm1pbmF0ZSBlYXJseSBkaWFsb2dzXG4gICAgZm9yKGlkeCBpbiB0aGlzLmVhcmx5RGlhbG9ncykge1xuICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWR4XS50ZXJtaW5hdGUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmVhcmx5RGlhbG9nc1tpZHhdO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfVEVSTUlOQVRFRDtcblxuICAgIGRlbGV0ZSB0aGlzLnVhLnNlc3Npb25zW3RoaXMuaWRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNyZWF0ZURpYWxvZzogZnVuY3Rpb24obWVzc2FnZSwgdHlwZSwgZWFybHkpIHtcbiAgICB2YXIgZGlhbG9nLCBlYXJseV9kaWFsb2csXG4gICAgICBsb2NhbF90YWcgPSBtZXNzYWdlWyh0eXBlID09PSAnVUFTJykgPyAndG9fdGFnJyA6ICdmcm9tX3RhZyddLFxuICAgICAgcmVtb3RlX3RhZyA9IG1lc3NhZ2VbKHR5cGUgPT09ICdVQVMnKSA/ICdmcm9tX3RhZycgOiAndG9fdGFnJ10sXG4gICAgICBpZCA9IG1lc3NhZ2UuY2FsbF9pZCArIGxvY2FsX3RhZyArIHJlbW90ZV90YWc7XG5cbiAgICBlYXJseV9kaWFsb2cgPSB0aGlzLmVhcmx5RGlhbG9nc1tpZF07XG5cbiAgICAvLyBFYXJseSBEaWFsb2dcbiAgICBpZiAoZWFybHkpIHtcbiAgICAgIGlmIChlYXJseV9kaWFsb2cpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYXJseV9kaWFsb2cgPSBuZXcgU0lQLkRpYWxvZyh0aGlzLCBtZXNzYWdlLCB0eXBlLCBTSVAuRGlhbG9nLkMuU1RBVFVTX0VBUkxZKTtcblxuICAgICAgICAvLyBEaWFsb2cgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQuXG4gICAgICAgIGlmKGVhcmx5X2RpYWxvZy5lcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVhcmx5X2RpYWxvZy5lcnJvcik7XG4gICAgICAgICAgdGhpcy5mYWlsZWQobWVzc2FnZSwgU0lQLkMuY2F1c2VzLklOVEVSTkFMX0VSUk9SKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdID0gZWFybHlfZGlhbG9nO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENvbmZpcm1lZCBEaWFsb2dcbiAgICBlbHNlIHtcbiAgICAgIC8vIEluIGNhc2UgdGhlIGRpYWxvZyBpcyBpbiBfZWFybHlfIHN0YXRlLCB1cGRhdGUgaXRcbiAgICAgIGlmIChlYXJseV9kaWFsb2cpIHtcbiAgICAgICAgZWFybHlfZGlhbG9nLnVwZGF0ZShtZXNzYWdlLCB0eXBlKTtcbiAgICAgICAgdGhpcy5kaWFsb2cgPSBlYXJseV9kaWFsb2c7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVhcmx5RGlhbG9nc1tpZF07XG4gICAgICAgIGZvciAodmFyIGRpYSBpbiB0aGlzLmVhcmx5RGlhbG9ncykge1xuICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2RpYV0udGVybWluYXRlKCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuZWFybHlEaWFsb2dzW2RpYV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGEgX2NvbmZpcm1lZF8gZGlhbG9nXG4gICAgICBkaWFsb2cgPSBuZXcgU0lQLkRpYWxvZyh0aGlzLCBtZXNzYWdlLCB0eXBlKTtcblxuICAgICAgaWYoZGlhbG9nLmVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGRpYWxvZy5lcnJvcik7XG4gICAgICAgIHRoaXMuZmFpbGVkKG1lc3NhZ2UsIFNJUC5DLmNhdXNlcy5JTlRFUk5BTF9FUlJPUik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9fdGFnID0gbWVzc2FnZS50b190YWc7XG4gICAgICAgIHRoaXMuZGlhbG9nID0gZGlhbG9nO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQ2hlY2sgaWYgU2Vzc2lvbiBpcyByZWFkeSBmb3IgYSByZS1JTlZJVEVcbiAgKlxuICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAqL1xuICBpc1JlYWR5VG9SZWludml0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVkaWFIYW5kbGVyLmlzUmVhZHkoKSAmJlxuICAgICAgIXRoaXMuZGlhbG9nLnVhY19wZW5kaW5nX3JlcGx5ICYmXG4gICAgICAhdGhpcy5kaWFsb2cudWFzX3BlbmRpbmdfcmVwbHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE11dGVcbiAgICovXG4gIG11dGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy5tZWRpYUhhbmRsZXIubXV0ZShvcHRpb25zKTtcbiAgICBpZiAocmV0KSB7XG4gICAgICB0aGlzLm9ubXV0ZShyZXQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVW5tdXRlXG4gICAqL1xuICB1bm11dGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy5tZWRpYUhhbmRsZXIudW5tdXRlKG9wdGlvbnMpO1xuICAgIGlmIChyZXQpIHtcbiAgICAgIHRoaXMub251bm11dGUocmV0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhvbGRcbiAgICovXG4gIGhvbGQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLICYmIHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgfVxuXG4gICAgdGhpcy5tZWRpYUhhbmRsZXIuaG9sZCgpO1xuXG4gICAgLy8gQ2hlY2sgaWYgUlRDU2Vzc2lvbiBpcyByZWFkeSB0byBzZW5kIGEgcmVJTlZJVEVcbiAgICBpZiAoIXRoaXMuaXNSZWFkeVRvUmVpbnZpdGUoKSkge1xuICAgICAgLyogSWYgdGhlcmUgaXMgYSBwZW5kaW5nICd1bmhvbGQnIGFjdGlvbiwgY2FuY2VsIGl0IGFuZCBkb24ndCBxdWV1ZSB0aGlzIG9uZVxuICAgICAgICogRWxzZSwgaWYgdGhlcmUgaXNuJ3QgYW55ICdob2xkJyBhY3Rpb24sIGFkZCB0aGlzIG9uZSB0byB0aGUgcXVldWVcbiAgICAgICAqIEVsc2UsIGlmIHRoZXJlIGlzIGFscmVhZHkgYSAnaG9sZCcgYWN0aW9uLCBza2lwXG4gICAgICAgKi9cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdfYWN0aW9ucy5pc1BlbmRpbmcoJ3VuaG9sZCcpKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ19hY3Rpb25zLnBvcCgndW5ob2xkJyk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLnBlbmRpbmdfYWN0aW9ucy5pc1BlbmRpbmcoJ2hvbGQnKSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdfYWN0aW9ucy5wdXNoKCdob2xkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLmxvY2FsX2hvbGQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub25ob2xkKCdsb2NhbCcpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5tYW5nbGUgPSBmdW5jdGlvbihib2R5KXtcblxuICAgICAgLy8gRG9uJ3QgcmVjZWl2ZSBtZWRpYVxuICAgICAgLy8gVE9ETyAtIFRoaXMgd2lsbCBicmVhayBmb3IgbWVkaWEgc3RyZWFtcyB3aXRoIGRpZmZlcmVudCBkaXJlY3Rpb25zLlxuICAgICAgaWYgKCEoL2E9KHNlbmRyZWN2fHNlbmRvbmx5fHJlY3Zvbmx5fGluYWN0aXZlKS8pLnRlc3QoYm9keSkpIHtcbiAgICAgICAgYm9keSA9IGJvZHkucmVwbGFjZSgvKG09W15cXHJdKlxcclxcbikvZywgJyQxYT1zZW5kb25seVxcclxcbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm9keSA9IGJvZHkucmVwbGFjZSgvYT1zZW5kcmVjdlxcclxcbi9nLCAnYT1zZW5kb25seVxcclxcbicpO1xuICAgICAgICBib2R5ID0gYm9keS5yZXBsYWNlKC9hPXJlY3Zvbmx5XFxyXFxuL2csICdhPWluYWN0aXZlXFxyXFxuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBib2R5O1xuICAgIH07XG5cbiAgICB0aGlzLnNlbmRSZWludml0ZShvcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5ob2xkXG4gICAqL1xuICB1bmhvbGQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLICYmIHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgfVxuXG4gICAgdGhpcy5tZWRpYUhhbmRsZXIudW5ob2xkKCk7XG5cbiAgICBpZiAoIXRoaXMuaXNSZWFkeVRvUmVpbnZpdGUoKSkge1xuICAgICAgLyogSWYgdGhlcmUgaXMgYSBwZW5kaW5nICdob2xkJyBhY3Rpb24sIGNhbmNlbCBpdCBhbmQgZG9uJ3QgcXVldWUgdGhpcyBvbmVcbiAgICAgICAqIEVsc2UsIGlmIHRoZXJlIGlzbid0IGFueSAndW5ob2xkJyBhY3Rpb24sIGFkZCB0aGlzIG9uZSB0byB0aGUgcXVldWVcbiAgICAgICAqIEVsc2UsIGlmIHRoZXJlIGlzIGFscmVhZHkgYSAndW5ob2xkJyBhY3Rpb24sIHNraXBcbiAgICAgICAqL1xuICAgICAgaWYgKHRoaXMucGVuZGluZ19hY3Rpb25zLmlzUGVuZGluZygnaG9sZCcpKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ19hY3Rpb25zLnBvcCgnaG9sZCcpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5wZW5kaW5nX2FjdGlvbnMuaXNQZW5kaW5nKCd1bmhvbGQnKSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdfYWN0aW9ucy5wdXNoKCd1bmhvbGQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxfaG9sZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9udW5ob2xkKCdsb2NhbCcpO1xuXG4gICAgdGhpcy5zZW5kUmVpbnZpdGUob3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGlzT25Ib2xkXG4gICAqL1xuICBpc09uSG9sZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2FsOiB0aGlzLmxvY2FsX2hvbGQsXG4gICAgICByZW1vdGU6IHRoaXMucmVtb3RlX2hvbGRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbiBkaWFsb2cgSU5WSVRFIFJlY2VwdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVjZWl2ZVJlaW52aXRlOiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFyZXF1ZXN0LmJvZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpICE9PSAnYXBwbGljYXRpb24vc2RwJykge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaW52YWxpZCBDb250ZW50LVR5cGUnKTtcbiAgICAgIHJlcXVlc3QucmVwbHkoNDE1KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXF1ZXN0LmJvZHkpXG4gICAgLnRoZW4odGhpcy5tZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24uYmluZCh0aGlzLm1lZGlhSGFuZGxlciwgdGhpcy5tZWRpYUhpbnQpKVxuICAgIC50aGVuKGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHJlcXVlc3QucmVwbHkoMjAwLCBudWxsLCBbJ0NvbnRhY3Q6ICcgKyBzZWxmLmNvbnRhY3RdLCBib2R5LFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLnN0YXR1cyA9IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSztcbiAgICAgICAgICBzZWxmLnNldEludml0ZTJ4eFRpbWVyKHJlcXVlc3QsIGJvZHkpO1xuICAgICAgICAgIHNlbGYuc2V0QUNLVGltZXIoKTtcblxuICAgICAgICAgIC8vIEFyZSB3ZSBob2xkaW5nP1xuICAgICAgICAgIHZhciBob2xkID0gKC9hPShzZW5kb25seXxpbmFjdGl2ZSkvKS50ZXN0KHJlcXVlc3QuYm9keSk7XG5cbiAgICAgICAgICBpZiAoc2VsZi5yZW1vdGVfaG9sZCAmJiAhaG9sZCkge1xuICAgICAgICAgICAgc2VsZi5vbnVuaG9sZCgncmVtb3RlJyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghc2VsZi5yZW1vdGVfaG9sZCAmJiBob2xkKSB7XG4gICAgICAgICAgICBzZWxmLm9uaG9sZCgncmVtb3RlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC5jYXRjaChmdW5jdGlvbiBvbkZhaWx1cmUgKGUpIHtcbiAgICAgIHZhciBzdGF0dXNDb2RlO1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTSVAuRXhjZXB0aW9ucy5HZXREZXNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSA1MDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgc3RhdHVzQ29kZSA9IDQ4ODtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3QucmVwbHkoc3RhdHVzQ29kZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgc2VuZFJlaW52aXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXJcbiAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpLFxuICAgICAgZXZlbnRIYW5kbGVycyA9IG9wdGlvbnMuZXZlbnRIYW5kbGVycyB8fCB7fSxcbiAgICAgIG1hbmdsZSA9IG9wdGlvbnMubWFuZ2xlIHx8IG51bGwsXG4gICAgICBzdWNjZWVkZWQ7XG5cbiAgICBpZiAoZXZlbnRIYW5kbGVycy5zdWNjZWVkZWQpIHtcbiAgICAgIHN1Y2NlZWRlZCA9IGV2ZW50SGFuZGxlcnMuc3VjY2VlZGVkO1xuICAgIH1cbiAgICB0aGlzLnJlaW52aXRlU3VjY2VlZGVkID0gZnVuY3Rpb24oKXtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHNlbGYudGltZXJzLmFja1RpbWVyKTtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHNlbGYudGltZXJzLmludml0ZTJ4eFRpbWVyKTtcbiAgICAgIHNlbGYuc3RhdHVzID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgc3VjY2VlZGVkICYmIHN1Y2NlZWRlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgaWYgKGV2ZW50SGFuZGxlcnMuZmFpbGVkKSB7XG4gICAgICB0aGlzLnJlaW52aXRlRmFpbGVkID0gZXZlbnRIYW5kbGVycy5mYWlsZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVpbnZpdGVGYWlsZWQgPSBmdW5jdGlvbigpe307XG4gICAgfVxuXG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcgKyB0aGlzLmNvbnRhY3QpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJysgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCkpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL3NkcCcpO1xuXG4gICAgdGhpcy5yZWNlaXZlUmVzcG9uc2UgPSB0aGlzLnJlY2VpdmVSZWludml0ZVJlc3BvbnNlO1xuICAgIC8vUkVWSVNJVFxuICAgIHRoaXMubWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uKHNlbGYubWVkaWFIaW50KVxuICAgIC50aGVuKG1hbmdsZSlcbiAgICAudGhlbihcbiAgICAgIGZ1bmN0aW9uKGJvZHkpe1xuICAgICAgICBzZWxmLmRpYWxvZy5zZW5kUmVxdWVzdChzZWxmLCBTSVAuQy5JTlZJVEUsIHtcbiAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2VsZi5pc1JlYWR5VG9SZWludml0ZSgpKSB7XG4gICAgICAgICAgc2VsZi5vblJlYWR5VG9SZWludml0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYucmVpbnZpdGVGYWlsZWQoKTtcbiAgICAgIH1cbiAgICApO1xuICB9LFxuXG4gIHJlY2VpdmVSZXF1ZXN0OiBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgIHN3aXRjaCAocmVxdWVzdC5tZXRob2QpIHtcbiAgICAgIGNhc2UgU0lQLkMuQllFOlxuICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMCk7XG4gICAgICAgIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2J5ZScsIHJlcXVlc3QpO1xuICAgICAgICAgIHRoaXMudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQllFKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuSU5WSVRFOlxuICAgICAgICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdyZS1JTlZJVEUgcmVjZWl2ZWQnKTtcbiAgICAgICAgICB0aGlzLnJlY2VpdmVSZWludml0ZShyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuSU5GTzpcbiAgICAgICAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCB8fCB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgICAgdmFyIGJvZHksIHRvbmUsIGR1cmF0aW9uLFxuICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSxcbiAgICAgICAgICAgICAgcmVnX3RvbmUgPSAvXihTaWduYWxcXHMqPz1cXHMqPykoWzAtOUEtRCMqXXsxfSkoXFxzKT8uKi8sXG4gICAgICAgICAgICAgIHJlZ19kdXJhdGlvbiA9IC9eKER1cmF0aW9uXFxzPz1cXHM/KShbMC05XXsxLDR9KShcXHMpPy4qLztcblxuICAgICAgICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlLm1hdGNoKC9eYXBwbGljYXRpb25cXC9kdG1mLXJlbGF5L2kpKSB7XG4gICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gcmVxdWVzdC5ib2R5LnNwbGl0KCdcXHJcXG4nLCAyKTtcbiAgICAgICAgICAgICAgICBpZiAoYm9keS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZWdfdG9uZS50ZXN0KGJvZHlbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbmUgPSBib2R5WzBdLnJlcGxhY2UocmVnX3RvbmUsXCIkMlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChyZWdfZHVyYXRpb24udGVzdChib2R5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHBhcnNlSW50KGJvZHlbMV0ucmVwbGFjZShyZWdfZHVyYXRpb24sXCIkMlwiKSwgMTApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5ldyBEVE1GKHRoaXMsIHRvbmUsIHtkdXJhdGlvbjogZHVyYXRpb259KS5pbml0X2luY29taW5nKHJlcXVlc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5yZXBseSg0MTUsIG51bGwsIFtcIkFjY2VwdDogYXBwbGljYXRpb24vZHRtZi1yZWxheVwiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5SRUZFUjpcbiAgICAgICAgaWYodGhpcy5zdGF0dXMgPT09ICBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ1JFRkVSIHJlY2VpdmVkJyk7XG4gICAgICAgICAgdmFyIGhhc1JlZmVyTGlzdGVuZXIgPSB0aGlzLmxpc3RlbmVycygncmVmZXInKS5sZW5ndGgsXG4gICAgICAgICAgICAgIG5vdGlmeUJvZHk7XG5cbiAgICAgICAgICBpZiAoaGFzUmVmZXJMaXN0ZW5lcikge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXBseSgyMDIsICdBY2NlcHRlZCcpO1xuICAgICAgICAgICAgbm90aWZ5Qm9keSA9ICdTSVAvMi4wIDEwMCBUcnlpbmcnO1xuXG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLk5PVElGWSwge1xuICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6W1xuICAgICAgICAgICAgICAgICdFdmVudDogcmVmZXInLFxuICAgICAgICAgICAgICAgICdTdWJzY3JpcHRpb24tU3RhdGU6IHRlcm1pbmF0ZWQnLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGU6IG1lc3NhZ2Uvc2lwZnJhZydcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgYm9keTogbm90aWZ5Qm9keSxcbiAgICAgICAgICAgICAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbigpIHt9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWZlcicsIHJlcXVlc3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSRkMgMzUxNS4yLjQuMjogJ3RoZSBVQSBNQVkgZGVjbGluZSB0aGUgcmVxdWVzdC4nXG4gICAgICAgICAgICByZXF1ZXN0LnJlcGx5KDYwMywgJ0RlY2xpbmVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5OT1RJRlk6XG4gICAgICAgIHJlcXVlc3QucmVwbHkoMjAwLCAnT0snKTtcbiAgICAgICAgdGhpcy5lbWl0KCdub3RpZnknLCByZXF1ZXN0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNlcHRpb24gb2YgUmVzcG9uc2UgZm9yIGluLWRpYWxvZyBJTlZJVEVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlY2VpdmVSZWludml0ZVJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY29udGVudFR5cGUgPSByZXNwb25zZS5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoKHRydWUpIHtcbiAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuXG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuQUNLLHtjc2VxOnJlc3BvbnNlLmNzZXF9KTtcblxuICAgICAgICBpZighcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgIHRoaXMucmVpbnZpdGVGYWlsZWQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZW50VHlwZSAhPT0gJ2FwcGxpY2F0aW9uL3NkcCcpIHtcbiAgICAgICAgICB0aGlzLnJlaW52aXRlRmFpbGVkKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvL1JFVklTSVRcbiAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVzcG9uc2UuYm9keSlcbiAgICAgICAgLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzICgpIHtcbiAgICAgICAgICAgIHNlbGYucmVpbnZpdGVTdWNjZWVkZWQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSAoKSB7XG4gICAgICAgICAgICBzZWxmLnJlaW52aXRlRmFpbGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmVpbnZpdGVGYWlsZWQoKTtcbiAgICB9XG4gIH0sXG5cbiAgYWNjZXB0QW5kVGVybWluYXRlOiBmdW5jdGlvbihyZXNwb25zZSwgc3RhdHVzX2NvZGUsIHJlYXNvbl9waHJhc2UpIHtcbiAgICB2YXIgZXh0cmFIZWFkZXJzID0gW107XG5cbiAgICBpZiAoc3RhdHVzX2NvZGUpIHtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZWFzb246ICcgKyBTSVAuVXRpbHMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoc3RhdHVzX2NvZGUsIHJlYXNvbl9waHJhc2UpKTtcbiAgICB9XG5cbiAgICAvLyBBbiBlcnJvciBvbiBkaWFsb2cgY3JlYXRpb24gd2lsbCBmaXJlICdmYWlsZWQnIGV2ZW50XG4gICAgaWYgKHRoaXMuZGlhbG9nIHx8IHRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJykpIHtcbiAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuQUNLLHtjc2VxOiByZXNwb25zZS5jc2VxfSk7XG4gICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkJZRSwge1xuICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVyc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJGQzMyNjEgMTMuMy4xLjRcbiAgICogUmVzcG9uc2UgcmV0cmFuc21pc3Npb25zIGNhbm5vdCBiZSBhY2NvbXBsaXNoZWQgYnkgdHJhbnNhY3Rpb24gbGF5ZXJcbiAgICogIHNpbmNlIGl0IGlzIGRlc3Ryb3llZCB3aGVuIHJlY2VpdmluZyB0aGUgZmlyc3QgMnh4IGFuc3dlclxuICAgKi9cbiAgc2V0SW52aXRlMnh4VGltZXI6IGZ1bmN0aW9uKHJlcXVlc3QsIGJvZHkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHRpbWVvdXQgPSBTSVAuVGltZXJzLlQxO1xuXG4gICAgdGhpcy50aW1lcnMuaW52aXRlMnh4VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24gaW52aXRlMnh4UmV0cmFuc21pc3Npb24oKSB7XG4gICAgICBpZiAoc2VsZi5zdGF0dXMgIT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYubG9nZ2VyLmxvZygnbm8gQUNLIHJlY2VpdmVkLCBhdHRlbXB0aW5nIHRvIHJldHJhbnNtaXQgT0snKTtcblxuICAgICAgcmVxdWVzdC5yZXBseSgyMDAsIG51bGwsIFsnQ29udGFjdDogJyArIHNlbGYuY29udGFjdF0sIGJvZHkpO1xuXG4gICAgICB0aW1lb3V0ID0gTWF0aC5taW4odGltZW91dCAqIDIsIFNJUC5UaW1lcnMuVDIpO1xuXG4gICAgICBzZWxmLnRpbWVycy5pbnZpdGUyeHhUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChpbnZpdGUyeHhSZXRyYW5zbWlzc2lvbiwgdGltZW91dCk7XG4gICAgfSwgdGltZW91dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJGQzMyNjEgMTQuMlxuICAgKiBJZiBhIFVBUyBnZW5lcmF0ZXMgYSAyeHggcmVzcG9uc2UgYW5kIG5ldmVyIHJlY2VpdmVzIGFuIEFDSyxcbiAgICogIGl0IFNIT1VMRCBnZW5lcmF0ZSBhIEJZRSB0byB0ZXJtaW5hdGUgdGhlIGRpYWxvZy5cbiAgICovXG4gIHNldEFDS1RpbWVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnRpbWVycy5hY2tUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmKHNlbGYuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICAgICAgc2VsZi5sb2dnZXIubG9nKCdubyBBQ0sgcmVjZWl2ZWQgZm9yIGFuIGV4dGVuZGVkIHBlcmlvZCBvZiB0aW1lLCB0ZXJtaW5hdGluZyB0aGUgY2FsbCcpO1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dChzZWxmLnRpbWVycy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICAgIHNlbGYuc2VuZFJlcXVlc3QoU0lQLkMuQllFKTtcbiAgICAgICAgc2VsZi50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5OT19BQ0spO1xuICAgICAgfVxuICAgIH0sIFNJUC5UaW1lcnMuVElNRVJfSCk7XG4gIH0sXG5cbiAgLypcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uUmVhZHlUb1JlaW52aXRlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYWN0aW9uID0gdGhpcy5wZW5kaW5nX2FjdGlvbnMuc2hpZnQoKTtcblxuICAgIGlmICghYWN0aW9uIHx8ICF0aGlzW2FjdGlvbi5uYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXNbYWN0aW9uLm5hbWVdKCk7XG4gIH0sXG5cbiAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19DT05GSVJNRUQgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9XG4gIH0sXG5cbiAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9XG4gIH0sXG5cbiAgb25EaWFsb2dFcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuRElBTE9HX0VSUk9SKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5ESUFMT0dfRVJST1IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uaG9sZDogZnVuY3Rpb24ob3JpZ2luYXRvcikge1xuICAgIHRoaXNbb3JpZ2luYXRvciA9PT0gJ2xvY2FsJyA/ICdsb2NhbF9ob2xkJyA6ICdyZW1vdGVfaG9sZCddID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ2hvbGQnLCB7IG9yaWdpbmF0b3I6IG9yaWdpbmF0b3IgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbnVuaG9sZDogZnVuY3Rpb24ob3JpZ2luYXRvcikge1xuICAgIHRoaXNbb3JpZ2luYXRvciA9PT0gJ2xvY2FsJyA/ICdsb2NhbF9ob2xkJyA6ICdyZW1vdGVfaG9sZCddID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCd1bmhvbGQnLCB7IG9yaWdpbmF0b3I6IG9yaWdpbmF0b3IgfSk7XG4gIH0sXG5cbiAgLypcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9ubXV0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuZW1pdCgnbXV0ZWQnLCB7XG4gICAgICBhdWRpbzogb3B0aW9ucy5hdWRpbyxcbiAgICAgIHZpZGVvOiBvcHRpb25zLnZpZGVvXG4gICAgfSk7XG4gIH0sXG5cbiAgLypcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9udW5tdXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5lbWl0KCd1bm11dGVkJywge1xuICAgICAgYXVkaW86IG9wdGlvbnMuYXVkaW8sXG4gICAgICB2aWRlbzogb3B0aW9ucy52aWRlb1xuICAgIH0pO1xuICB9LFxuXG4gIGZhaWxlZDogZnVuY3Rpb24ocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdmYWlsZWQnLCByZXNwb25zZSB8fCBudWxsLCBjYXVzZSB8fCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZWplY3RlZDogZnVuY3Rpb24ocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgdGhpcy5lbWl0KCdyZWplY3RlZCcsXG4gICAgICByZXNwb25zZSB8fCBudWxsLFxuICAgICAgY2F1c2UgfHwgbnVsbFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2FuY2VsZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZW1pdCgnY2FuY2VsJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYWNjZXB0ZWQ6IGZ1bmN0aW9uKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgIGNhdXNlID0gU0lQLlV0aWxzLmdldFJlYXNvblBocmFzZShyZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXNfY29kZSwgY2F1c2UpO1xuXG4gICAgdGhpcy5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgaWYgKHRoaXMucmVwbGFjZWUpIHtcbiAgICAgIHRoaXMucmVwbGFjZWUuZW1pdCgncmVwbGFjZWQnLCB0aGlzKTtcbiAgICAgIHRoaXMucmVwbGFjZWUudGVybWluYXRlKCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnYWNjZXB0ZWQnLCByZXNwb25zZSwgY2F1c2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHRlcm1pbmF0ZWQ6IGZ1bmN0aW9uKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIHRoaXMuZW1pdCgndGVybWluYXRlZCcsXG4gICAgICBtZXNzYWdlIHx8IG51bGwsXG4gICAgICBjYXVzZSB8fCBudWxsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjb25uZWN0aW5nOiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJywgeyByZXF1ZXN0OiByZXF1ZXN0IH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5TZXNzaW9uLmRlc3VnYXIgPSBmdW5jdGlvbiBkZXN1Z2FyKG9wdGlvbnMpIHtcbiAgaWYgKGVudmlyb25tZW50LkhUTUxNZWRpYUVsZW1lbnQgJiYgb3B0aW9ucyBpbnN0YW5jZW9mIGVudmlyb25tZW50LkhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbWVkaWE6IHtcbiAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICBhdWRpbzogdHJ1ZSxcbiAgICAgICAgICB2aWRlbzogb3B0aW9ucy50YWdOYW1lID09PSAnVklERU8nXG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcjoge1xuICAgICAgICAgIHJlbW90ZTogb3B0aW9uc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucyB8fCB7fTtcbn07XG5cblxuU2Vzc2lvbi5DID0gQztcblNJUC5TZXNzaW9uID0gU2Vzc2lvbjtcblxuXG5JbnZpdGVTZXJ2ZXJDb250ZXh0ID0gZnVuY3Rpb24odWEsIHJlcXVlc3QpIHtcbiAgdmFyIGV4cGlyZXMsXG4gICAgc2VsZiA9IHRoaXMsXG4gICAgY29udGVudFR5cGUgPSByZXF1ZXN0LmdldEhlYWRlcignQ29udGVudC1UeXBlJyksXG4gICAgY29udGVudERpc3AgPSByZXF1ZXN0LnBhcnNlSGVhZGVyKCdDb250ZW50LURpc3Bvc2l0aW9uJyk7XG5cbiAgLy8gQ2hlY2sgYm9keSBhbmQgY29udGVudCB0eXBlXG4gIGlmICgoIWNvbnRlbnREaXNwICYmIGNvbnRlbnRUeXBlICE9PSAnYXBwbGljYXRpb24vc2RwJykgfHwgKGNvbnRlbnREaXNwICYmIGNvbnRlbnREaXNwLnR5cGUgPT09ICdyZW5kZXInKSkge1xuICAgIHRoaXMucmVuZGVyYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgICB0aGlzLnJlbmRlcnR5cGUgPSBjb250ZW50VHlwZTtcbiAgfSBlbHNlIGlmIChjb250ZW50VHlwZSAhPT0gJ2FwcGxpY2F0aW9uL3NkcCcgJiYgKGNvbnRlbnREaXNwICYmIGNvbnRlbnREaXNwLnR5cGUgPT09ICdzZXNzaW9uJykpIHtcbiAgICByZXF1ZXN0LnJlcGx5KDQxNSk7XG4gICAgLy9UT0RPOiBpbnN0ZWFkIG9mIDQxNSwgcGFzcyBvZmYgdG8gdGhlIG1lZGlhIGhhbmRsZXIsIHdobyBjYW4gdGhlbiBkZWNpZGUgaWYgd2UgY2FuIHVzZSBpdFxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vVE9ETzogbW92ZSB0aGlzIGludG8gbWVkaWEgaGFuZGxlclxuICBTSVAuSGFja3MuRmlyZWZveC5jYW5ub3RIYW5kbGVFeHRyYVdoaXRlc3BhY2UocmVxdWVzdCk7XG4gIFNJUC5IYWNrcy5BbGxCcm93c2Vycy5tYXNrRHRscyhyZXF1ZXN0KTtcblxuICBTSVAuVXRpbHMuYXVnbWVudCh0aGlzLCBTSVAuU2VydmVyQ29udGV4dCwgW3VhLCByZXF1ZXN0XSk7XG4gIFNJUC5VdGlscy5hdWdtZW50KHRoaXMsIFNJUC5TZXNzaW9uLCBbdWEuY29uZmlndXJhdGlvbi5tZWRpYUhhbmRsZXJGYWN0b3J5XSk7XG5cbiAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19JTlZJVEVfUkVDRUlWRUQ7XG4gIHRoaXMuZnJvbV90YWcgPSByZXF1ZXN0LmZyb21fdGFnO1xuICB0aGlzLmlkID0gcmVxdWVzdC5jYWxsX2lkICsgdGhpcy5mcm9tX3RhZztcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgdGhpcy5jb250YWN0ID0gdGhpcy51YS5jb250YWN0LnRvU3RyaW5nKCk7XG5cbiAgdGhpcy5yZWNlaXZlTm9uSW52aXRlUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7fTsgLy8gaW50ZW50aW9uYWwgbm8tb3BcblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLmludml0ZXNlcnZlcmNvbnRleHQnLCB0aGlzLmlkKTtcblxuICAvL1NhdmUgdGhlIHNlc3Npb24gaW50byB0aGUgdWEgc2Vzc2lvbnMgY29sbGVjdGlvbi5cbiAgdGhpcy51YS5zZXNzaW9uc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgLy9HZXQgdGhlIEV4cGlyZXMgaGVhZGVyIHZhbHVlIGlmIGV4aXN0c1xuICBpZihyZXF1ZXN0Lmhhc0hlYWRlcignZXhwaXJlcycpKSB7XG4gICAgZXhwaXJlcyA9IHJlcXVlc3QuZ2V0SGVhZGVyKCdleHBpcmVzJykgKiAxMDAwO1xuICB9XG5cbiAgLy9TZXQgMTAwcmVsIGlmIG5lY2Vzc2FyeVxuICBmdW5jdGlvbiBzZXQxMDByZWwoaCxjKSB7XG4gICAgaWYgKHJlcXVlc3QuaGFzSGVhZGVyKGgpICYmIHJlcXVlc3QuZ2V0SGVhZGVyKGgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignMTAwcmVsJykgPj0gMCkge1xuICAgICAgc2VsZi5yZWwxMDAgPSBjO1xuICAgIH1cbiAgfVxuICBzZXQxMDByZWwoJ3JlcXVpcmUnLCBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpO1xuICBzZXQxMDByZWwoJ3N1cHBvcnRlZCcsIFNJUC5DLnN1cHBvcnRlZC5TVVBQT1JURUQpO1xuXG4gIC8qIFNldCB0aGUgdG9fdGFnIGJlZm9yZVxuICAgKiByZXBseWluZyBhIHJlc3BvbnNlIGNvZGUgdGhhdCB3aWxsIGNyZWF0ZSBhIGRpYWxvZy5cbiAgICovXG4gIHJlcXVlc3QudG9fdGFnID0gU0lQLlV0aWxzLm5ld1RhZygpO1xuXG4gIC8vIEFuIGVycm9yIG9uIGRpYWxvZyBjcmVhdGlvbiB3aWxsIGZpcmUgJ2ZhaWxlZCcgZXZlbnRcbiAgaWYoIXRoaXMuY3JlYXRlRGlhbG9nKHJlcXVlc3QsICdVQVMnLCB0cnVlKSkge1xuICAgIHJlcXVlc3QucmVwbHkoNTAwLCAnTWlzc2luZyBDb250YWN0IGhlYWRlciBmaWVsZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vSW5pdGlhbGl6ZSBNZWRpYSBTZXNzaW9uXG4gIHRoaXMubWVkaWFIYW5kbGVyID0gdGhpcy5tZWRpYUhhbmRsZXJGYWN0b3J5KHRoaXMsIHtcbiAgICBSVENDb25zdHJhaW50czoge1wib3B0aW9uYWxcIjogW3snRHRsc1NydHBLZXlBZ3JlZW1lbnQnOiAndHJ1ZSd9XX1cbiAgfSk7XG5cbiAgaWYgKHRoaXMubWVkaWFIYW5kbGVyICYmIHRoaXMubWVkaWFIYW5kbGVyLmdldFJlbW90ZVN0cmVhbXMpIHtcbiAgICB0aGlzLmdldFJlbW90ZVN0cmVhbXMgPSB0aGlzLm1lZGlhSGFuZGxlci5nZXRSZW1vdGVTdHJlYW1zLmJpbmQodGhpcy5tZWRpYUhhbmRsZXIpO1xuICAgIHRoaXMuZ2V0TG9jYWxTdHJlYW1zID0gdGhpcy5tZWRpYUhhbmRsZXIuZ2V0TG9jYWxTdHJlYW1zLmJpbmQodGhpcy5tZWRpYUhhbmRsZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZU5ld1Nlc3Npb24oKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7ZXh0cmFIZWFkZXJzOiBbJ0NvbnRhY3Q6ICcgKyBzZWxmLmNvbnRhY3RdfTtcblxuICAgIGlmIChzZWxmLnJlbDEwMCAhPT0gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSB7XG4gICAgICBzZWxmLnByb2dyZXNzKG9wdGlvbnMpO1xuICAgIH1cbiAgICBzZWxmLnN0YXR1cyA9IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUjtcblxuICAgIC8vIFNldCB1c2VyTm9BbnN3ZXJUaW1lclxuICAgIHNlbGYudGltZXJzLnVzZXJOb0Fuc3dlclRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgcmVxdWVzdC5yZXBseSg0MDgpO1xuICAgICAgc2VsZi5mYWlsZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLk5PX0FOU1dFUik7XG4gICAgICBzZWxmLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLk5PX0FOU1dFUik7XG4gICAgfSwgc2VsZi51YS5jb25maWd1cmF0aW9uLm5vQW5zd2VyVGltZW91dCk7XG5cbiAgICAvKiBTZXQgZXhwaXJlc1RpbWVyXG4gICAgICogUkZDMzI2MSAxMy4zLjFcbiAgICAgKi9cbiAgICBpZiAoZXhwaXJlcykge1xuICAgICAgc2VsZi50aW1lcnMuZXhwaXJlc1RpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZihzZWxmLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSKSB7XG4gICAgICAgICAgcmVxdWVzdC5yZXBseSg0ODcpO1xuICAgICAgICAgIHNlbGYuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5FWFBJUkVTKTtcbiAgICAgICAgICBzZWxmLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkVYUElSRVMpO1xuICAgICAgICB9XG4gICAgICB9LCBleHBpcmVzKTtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ2ludml0ZScscmVxdWVzdCk7XG4gIH1cblxuICBpZiAoIXJlcXVlc3QuYm9keSB8fCB0aGlzLnJlbmRlcmJvZHkpIHtcbiAgICBTSVAuVGltZXJzLnNldFRpbWVvdXQoZmlyZU5ld1Nlc3Npb24sIDApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaGFzT2ZmZXIgPSB0cnVlO1xuICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlcXVlc3QuYm9keSlcbiAgICAudGhlbihcbiAgICAgIGZpcmVOZXdTZXNzaW9uLFxuICAgICAgZnVuY3Rpb24gb25GYWlsdXJlIChlKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oJ2ludmFsaWQgU0RQJyk7XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgIHJlcXVlc3QucmVwbHkoNDg4KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG59O1xuXG5JbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgcmVqZWN0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIubG9nKCdyZWplY3RpbmcgUlRDU2Vzc2lvbicpO1xuXG4gICAgU0lQLlNlcnZlckNvbnRleHQucHJvdG90eXBlLnJlamVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnRlcm1pbmF0ZWQoKTtcbiAgfSxcblxuICB0ZXJtaW5hdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhclxuICAgIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSxcbiAgICBib2R5ID0gb3B0aW9ucy5ib2R5LFxuICAgIGRpYWxvZyxcbiAgICBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLICYmXG4gICAgICAgdGhpcy5yZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbi5zdGF0ZSAhPT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICBkaWFsb2cgPSB0aGlzLmRpYWxvZztcblxuICAgICAgdGhpcy5yZWNlaXZlUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5BQ0spIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3QoU0lQLkMuQllFLCB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkaWFsb2cudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMucmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24ub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3QgPSBuZXcgU0lQLk91dGdvaW5nUmVxdWVzdChcbiAgICAgICAgICAgIFNJUC5DLkJZRSxcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nLnJlbW90ZV90YXJnZXQsXG4gICAgICAgICAgICB0aGlzLnVhLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAnY3NlcSc6IHRoaXMuZGlhbG9nLmxvY2FsX3NlcW51bSs9MSxcbiAgICAgICAgICAgICAgJ2NhbGxfaWQnOiB0aGlzLmRpYWxvZy5pZC5jYWxsX2lkLFxuICAgICAgICAgICAgICAnZnJvbV91cmknOiB0aGlzLmRpYWxvZy5sb2NhbF91cmksXG4gICAgICAgICAgICAgICdmcm9tX3RhZyc6IHRoaXMuZGlhbG9nLmlkLmxvY2FsX3RhZyxcbiAgICAgICAgICAgICAgJ3RvX3VyaSc6IHRoaXMuZGlhbG9nLnJlbW90ZV91cmksXG4gICAgICAgICAgICAgICd0b190YWcnOiB0aGlzLmRpYWxvZy5pZC5yZW1vdGVfdGFnLFxuICAgICAgICAgICAgICAncm91dGVfc2V0JzogdGhpcy5kaWFsb2cucm91dGVfc2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBuZXcgU0lQLlJlcXVlc3RTZW5kZXIoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMucmVxdWVzdCxcbiAgICAgICAgICAgICAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXMudWFcbiAgICAgICAgICApLnNlbmQoKTtcbiAgICAgICAgICBkaWFsb2cudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmVtaXQoJ2J5ZScsIHRoaXMucmVxdWVzdCk7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQoKTtcblxuICAgICAgLy8gUmVzdG9yZSB0aGUgZGlhbG9nIGludG8gJ3RoaXMnIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gc2VuZCB0aGUgaW4tZGlhbG9nIEJZRSA6LSlcbiAgICAgIHRoaXMuZGlhbG9nID0gZGlhbG9nO1xuXG4gICAgICAvLyBSZXN0b3JlIHRoZSBkaWFsb2cgaW50byAndWEnIHNvIHRoZSBBQ0sgY2FuIHJlYWNoICd0aGlzJyBzZXNzaW9uXG4gICAgICB0aGlzLnVhLmRpYWxvZ3NbZGlhbG9nLmlkLnRvU3RyaW5nKCldID0gZGlhbG9nO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aGlzLmJ5ZShvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWplY3Qob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLypcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1lZGlhXSBnZXRzIHBhc3NlZCB0byBTSVAuTWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uIGFzIG1lZGlhSGludFxuICAgKi9cbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyXG4gICAgICBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDE4MCxcbiAgICAgIHJlYXNvblBocmFzZSA9IG9wdGlvbnMucmVhc29uUGhyYXNlLFxuICAgICAgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpLFxuICAgICAgaWNlU2VydmVycyxcbiAgICAgIHN0dW5TZXJ2ZXJzID0gb3B0aW9ucy5zdHVuU2VydmVycyB8fCBudWxsLFxuICAgICAgdHVyblNlcnZlcnMgPSBvcHRpb25zLnR1cm5TZXJ2ZXJzIHx8IG51bGwsXG4gICAgICBib2R5ID0gb3B0aW9ucy5ib2R5LFxuICAgICAgcmVzcG9uc2U7XG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDEwMCB8fCBzdGF0dXNDb2RlID4gMTk5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0YXR1c0NvZGU6ICcgKyBzdGF0dXNDb2RlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NhbmNlbGVkIHx8IHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoc3R1blNlcnZlcnMgfHwgdHVyblNlcnZlcnMpIHtcbiAgICAgIGlmIChzdHVuU2VydmVycykge1xuICAgICAgICBpY2VTZXJ2ZXJzID0gU0lQLlVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbJ3N0dW5TZXJ2ZXJzJ10oc3R1blNlcnZlcnMpO1xuICAgICAgICBpZiAoIWljZVNlcnZlcnMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0dW5TZXJ2ZXJzOiAnKyBzdHVuU2VydmVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdHVuU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR1cm5TZXJ2ZXJzKSB7XG4gICAgICAgIGljZVNlcnZlcnMgPSBTSVAuVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFsndHVyblNlcnZlcnMnXSh0dXJuU2VydmVycyk7XG4gICAgICAgIGlmICghaWNlU2VydmVycykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdHVyblNlcnZlcnM6ICcrIHR1cm5TZXJ2ZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnR1cm5TZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1lZGlhSGFuZGxlci51cGRhdGVJY2VTZXJ2ZXJzKHtcbiAgICAgICAgc3R1blNlcnZlcnM6IHRoaXMuc3R1blNlcnZlcnMsXG4gICAgICAgIHR1cm5TZXJ2ZXJzOiB0aGlzLnR1cm5TZXJ2ZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkbzEwMHJlbCgpIHtcbiAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgICAgIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMTgzO1xuXG4gICAgICAvLyBTZXQgc3RhdHVzIGFuZCBhZGQgZXh0cmEgaGVhZGVyc1xuICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSztcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnKyB0aGlzLmNvbnRhY3QpO1xuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JlcXVpcmU6IDEwMHJlbCcpO1xuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JTZXE6ICcgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkpO1xuXG4gICAgICAvLyBTYXZlIG1lZGlhIGhpbnQgZm9yIGxhdGVyIChyZWZlcnJlZCBzZXNzaW9ucylcbiAgICAgIHRoaXMubWVkaWFIaW50ID0gb3B0aW9ucy5tZWRpYTtcblxuICAgICAgLy8gR2V0IHRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uIHRvIGFkZCB0byBwcmVhY2NlcHQgd2l0aFxuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24ob3B0aW9ucy5tZWRpYSlcbiAgICAgIC50aGVuKFxuICAgICAgICBmdW5jdGlvbiBvblN1Y2Nlc3MgKGJvZHkpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGVkIHx8IHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5lYXJseV9zZHAgPSBib2R5O1xuICAgICAgICAgIHRoaXNbdGhpcy5oYXNPZmZlciA/ICdoYXNBbnN3ZXInIDogJ2hhc09mZmVyJ10gPSB0cnVlO1xuXG4gICAgICAgICAgLy8gUmV0cmFuc21pdCB1bnRpbCB3ZSBnZXQgYSByZXNwb25zZSBvciB3ZSB0aW1lIG91dCAoc2VlIHByYWNrVGltZXIgYmVsb3cpXG4gICAgICAgICAgdmFyIHRpbWVvdXQgPSBTSVAuVGltZXJzLlQxO1xuICAgICAgICAgIHRoaXMudGltZXJzLnJlbDF4eFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uIHJlbDF4eFJldHJhbnNtaXNzaW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LnJlcGx5KHN0YXR1c0NvZGUsIG51bGwsIGV4dHJhSGVhZGVycywgYm9keSk7XG4gICAgICAgICAgICB0aW1lb3V0ICo9IDI7XG4gICAgICAgICAgICB0aGlzLnRpbWVycy5yZWwxeHhUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChyZWwxeHhSZXRyYW5zbWlzc2lvbi5iaW5kKHRoaXMpLCB0aW1lb3V0KTtcbiAgICAgICAgICB9LmJpbmQodGhpcyksIHRpbWVvdXQpO1xuXG4gICAgICAgICAgLy8gVGltZW91dCBhbmQgcmVqZWN0IElOVklURSBpZiBubyByZXNwb25zZVxuICAgICAgICAgIHRoaXMudGltZXJzLnByYWNrVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygnbm8gUFJBQ0sgcmVjZWl2ZWQsIHJlamVjdGluZyB0aGUgY2FsbCcpO1xuICAgICAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMucmVsMXh4VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LnJlcGx5KDUwNCk7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLk5PX1BSQUNLKTtcbiAgICAgICAgICB9LmJpbmQodGhpcyksIFNJUC5UaW1lcnMuVDEgKiA2NCk7XG5cbiAgICAgICAgICAvLyBTZW5kIHRoZSBpbml0aWFsIHJlc3BvbnNlXG4gICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLnJlcXVlc3QucmVwbHkoc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlLCBleHRyYUhlYWRlcnMsIGJvZHkpO1xuICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSwgcmVhc29uUGhyYXNlKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLFxuXG4gICAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSAoKSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0LnJlcGx5KDQ4MCk7XG4gICAgICAgICAgdGhpcy5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICk7XG4gICAgfSAvLyBlbmQgZG8xMDByZWxcblxuICAgIGZ1bmN0aW9uIG5vcm1hbFJlcGx5KCkge1xuICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICByZXNwb25zZSA9IHRoaXMucmVxdWVzdC5yZXBseShzdGF0dXNDb2RlLCByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVycywgYm9keSk7XG4gICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UsIHJlYXNvblBocmFzZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhdHVzQ29kZSAhPT0gMTAwICYmXG4gICAgICAgICh0aGlzLnJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEIHx8XG4gICAgICAgICAodGhpcy5yZWwxMDAgPT09IFNJUC5DLnN1cHBvcnRlZC5TVVBQT1JURUQgJiYgb3B0aW9ucy5yZWwxMDApIHx8XG4gICAgICAgICAodGhpcy5yZWwxMDAgPT09IFNJUC5DLnN1cHBvcnRlZC5TVVBQT1JURUQgJiYgKHRoaXMudWEuY29uZmlndXJhdGlvbi5yZWwxMDAgPT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCkpKSkge1xuICAgICAgZG8xMDByZWwuYXBwbHkodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbFJlcGx5LmFwcGx5KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWVkaWFdIGdldHMgcGFzc2VkIHRvIFNJUC5NZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24gYXMgbWVkaWFIaW50XG4gICAqL1xuICBhY2NlcHQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShTZXNzaW9uLmRlc3VnYXIob3B0aW9ucykpO1xuICAgIFNJUC5VdGlscy5vcHRpb25zT3ZlcnJpZGUob3B0aW9ucywgJ21lZGlhJywgJ21lZGlhQ29uc3RyYWludHMnLCB0cnVlLCB0aGlzLmxvZ2dlciwgdGhpcy51YS5jb25maWd1cmF0aW9uLm1lZGlhKTtcbiAgICB0aGlzLm1lZGlhSGludCA9IG9wdGlvbnMubWVkaWE7XG5cbiAgICAvLyBjb21tZW50ZWQgb3V0IG5vdy11bnVzZWQgaG9sZC1yZWxhdGVkIHZhcmlhYmxlcyBmb3IganNoaW50LiBTZWUgYmVsb3cuIEpNRiAyMDE0LTEtMjFcbiAgICB2YXJcbiAgICAgIC8vaWR4LCBsZW5ndGgsIGhhc0F1ZGlvLCBoYXNWaWRlbyxcbiAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgcmVxdWVzdCA9IHRoaXMucmVxdWVzdCxcbiAgICAgIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSxcbiAgICAvL21lZGlhU3RyZWFtID0gb3B0aW9ucy5tZWRpYVN0cmVhbSB8fCBudWxsLFxuICAgICAgaWNlU2VydmVycyxcbiAgICAgIHN0dW5TZXJ2ZXJzID0gb3B0aW9ucy5zdHVuU2VydmVycyB8fCBudWxsLFxuICAgICAgdHVyblNlcnZlcnMgPSBvcHRpb25zLnR1cm5TZXJ2ZXJzIHx8IG51bGwsXG4gICAgICBzZHBDcmVhdGlvblN1Y2NlZWRlZCA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgLy8gcnVuIGZvciByZXBseSBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICAgICAgcmVwbHlTdWNjZWVkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdHVzID0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLO1xuXG4gICAgICAgICAgICBzZWxmLnNldEludml0ZTJ4eFRpbWVyKHJlcXVlc3QsIGJvZHkpO1xuICAgICAgICAgICAgc2VsZi5zZXRBQ0tUaW1lcigpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBydW4gZm9yIHJlcGx5IGZhaWx1cmUgY2FsbGJhY2tcbiAgICAgICAgICByZXBseUZhaWxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgICAgICAgICAgc2VsZi50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIENocm9tZSBtaWdodCBjYWxsIG9uYWRkc3RyZWFtIGJlZm9yZSBhY2NlcHQoKSBpcyBjYWxsZWQsIHdoaWNoIG1lYW5zXG4gICAgICAgIC8vIG1lZGlhSGFuZGxlci5yZW5kZXIoKSB3YXMgY2FsbGVkIHdpdGhvdXQgYSByZW5kZXJIaW50LCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHJlLXJlbmRlciBub3cgdGhhdCBtZWRpYUhpbnQucmVuZGVyIGhhcyBiZWVuIHNldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQ2hyb21lIHNlZW1zIHRvIGJlIGluIHRoZSByaWdodCByZWdhcmRpbmcgdGhpcywgc2VlXG4gICAgICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnLzIwMTEvd2VicnRjL2VkaXRvci93ZWJydGMuaHRtbCN3aWRsLVJUQ1BlZXJDb25uZWN0aW9uLW9uYWRkc3RyZWFtXG4gICAgICAgIHNlbGYubWVkaWFIYW5kbGVyLnJlbmRlcigpO1xuXG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnICsgc2VsZi5jb250YWN0KTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnICsgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgIGlmKCFzZWxmLmhhc09mZmVyKSB7XG4gICAgICAgICAgc2VsZi5oYXNPZmZlciA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3BvbnNlID0gcmVxdWVzdC5yZXBseSgyMDAsIG51bGwsIGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGx5U3VjY2VlZGVkLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RmFpbGVkXG4gICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICBpZiAoc2VsZi5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHsgLy8gRGlkbid0IGZhaWxcbiAgICAgICAgICBzZWxmLmFjY2VwdGVkKHJlc3BvbnNlLCBTSVAuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKDIwMCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzZHBDcmVhdGlvbkZhaWxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2VsZi5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyAtIGZhaWwgb3V0IG9uIGVycm9yXG4gICAgICAgIHNlbGYucmVxdWVzdC5yZXBseSg0ODApO1xuICAgICAgICAvL3NlbGYuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuVVNFUl9ERU5JRURfTUVESUFfQUNDRVNTKTtcbiAgICAgICAgc2VsZi5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgIHNlbGYudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgIH07XG5cbiAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0s7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVIpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfQU5TV0VSRUQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfRUFSTFlfTUVESUEpIHtcbiAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgfVxuXG4gICAgaWYgKChzdHVuU2VydmVycyB8fCB0dXJuU2VydmVycykgJiZcbiAgICAgICAgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19FQVJMWV9NRURJQSAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0spKSB7XG4gICAgICBpZiAoc3R1blNlcnZlcnMpIHtcbiAgICAgICAgaWNlU2VydmVycyA9IFNJUC5VQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsWydzdHVuU2VydmVycyddKHN0dW5TZXJ2ZXJzKTtcbiAgICAgICAgaWYgKCFpY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdHVuU2VydmVyczogJysgc3R1blNlcnZlcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3R1blNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0dXJuU2VydmVycykge1xuICAgICAgICBpY2VTZXJ2ZXJzID0gU0lQLlVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbJ3R1cm5TZXJ2ZXJzJ10odHVyblNlcnZlcnMpO1xuICAgICAgICBpZiAoIWljZVNlcnZlcnMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHR1cm5TZXJ2ZXJzOiAnKyB0dXJuU2VydmVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50dXJuU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIudXBkYXRlSWNlU2VydmVycyh7XG4gICAgICAgIHN0dW5TZXJ2ZXJzOiB0aGlzLnN0dW5TZXJ2ZXJzLFxuICAgICAgICB0dXJuU2VydmVyczogdGhpcy50dXJuU2VydmVyc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQW4gZXJyb3Igb24gZGlhbG9nIGNyZWF0aW9uIHdpbGwgZmlyZSAnZmFpbGVkJyBldmVudFxuICAgIGlmKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXF1ZXN0LCAnVUFTJykpIHtcbiAgICAgIHJlcXVlc3QucmVwbHkoNTAwLCAnTWlzc2luZyBDb250YWN0IGhlYWRlciBmaWVsZCcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMudXNlck5vQW5zd2VyVGltZXIpO1xuXG4gICAgLy8gdGhpcyBob2xkLXJlbGF0ZWQgY29kZSBicmVha3MgRkYgYWNjZXB0aW5nIG5ldyBjYWxscyAtIEpNRiAyMDE0LTEtMjFcbiAgICAvKlxuICAgIGxlbmd0aCA9IHRoaXMuZ2V0UmVtb3RlU3RyZWFtcygpLmxlbmd0aDtcblxuICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKHRoaXMubWVkaWFIYW5kbGVyLmdldFJlbW90ZVN0cmVhbXMoKVtpZHhdLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICBoYXNWaWRlbyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVtb3RlU3RyZWFtcygpW2lkeF0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGhhc0F1ZGlvID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhc0F1ZGlvICYmIHRoaXMubWVkaWFDb25zdHJhaW50cy5hdWRpbyA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5tZWRpYUNvbnN0cmFpbnRzLmF1ZGlvID0gZmFsc2U7XG4gICAgICBpZiAobWVkaWFTdHJlYW0pIHtcbiAgICAgICAgbGVuZ3RoID0gbWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGg7XG4gICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbaWR4XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhc1ZpZGVvICYmIHRoaXMubWVkaWFDb25zdHJhaW50cy52aWRlbyA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5tZWRpYUNvbnN0cmFpbnRzLnZpZGVvID0gZmFsc2U7XG4gICAgICBpZiAobWVkaWFTdHJlYW0pIHtcbiAgICAgICAgbGVuZ3RoID0gbWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGg7XG4gICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbaWR4XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgKi9cblxuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfRUFSTFlfTUVESUEpIHtcbiAgICAgIHNkcENyZWF0aW9uU3VjY2VlZGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uKHNlbGYubWVkaWFIaW50KVxuICAgICAgLnRoZW4oXG4gICAgICAgIHNkcENyZWF0aW9uU3VjY2VlZGVkLFxuICAgICAgICBzZHBDcmVhdGlvbkZhaWxlZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZWNlaXZlUmVxdWVzdDogZnVuY3Rpb24ocmVxdWVzdCkge1xuXG4gICAgLy8gSVNDIFJFQ0VJVkUgUkVRVUVTVFxuXG4gICAgZnVuY3Rpb24gY29uZmlybVNlc3Npb24oKSB7XG4gICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBjb250ZW50VHlwZTtcblxuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuYWNrVGltZXIpO1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuaW52aXRlMnh4VGltZXIpO1xuICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICB0aGlzLnVubXV0ZSgpO1xuXG4gICAgICAvLyBUT0RPIC0gdGhpcyBsb2dpYyBhc3N1bWVzIENvbnRlbnQtRGlzcG9zaXRpb24gZGVmYXVsdHNcbiAgICAgIGNvbnRlbnRUeXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgaWYgKGNvbnRlbnRUeXBlICE9PSAnYXBwbGljYXRpb24vc2RwJykge1xuICAgICAgICB0aGlzLnJlbmRlcmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIHRoaXMucmVuZGVydHlwZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgIGNhc2UgU0lQLkMuQ0FOQ0VMOlxuICAgICAgLyogUkZDMzI2MSAxNSBTdGF0ZXMgdGhhdCBhIFVBUyBtYXkgaGF2ZSBhY2NlcHRlZCBhbiBpbnZpdGF0aW9uIHdoaWxlIGEgQ0FOQ0VMXG4gICAgICAgKiB3YXMgaW4gcHJvZ3Jlc3MgYW5kIHRoYXQgdGhlIFVBQyBNQVkgY29udGludWUgd2l0aCB0aGUgc2Vzc2lvbiBlc3RhYmxpc2hlZCBieVxuICAgICAgICogYW55IDJ4eCByZXNwb25zZSwgb3IgTUFZIHRlcm1pbmF0ZSB3aXRoIEJZRS4gU0lQIGRvZXMgY29udGludWUgd2l0aCB0aGVcbiAgICAgICAqIGVzdGFibGlzaGVkIHNlc3Npb24uIFNvIHRoZSBDQU5DRUwgaXMgcHJvY2Vzc2VkIG9ubHkgaWYgdGhlIHNlc3Npb24gaXMgbm90IHlldFxuICAgICAgICogZXN0YWJsaXNoZWQuXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgICAqIFRlcm1pbmF0ZSB0aGUgd2hvbGUgc2Vzc2lvbiBpbiBjYXNlIHRoZSB1c2VyIGRpZG4ndCBhY2NlcHQgKG9yIHlldCB0byBzZW5kIHRoZSBhbnN3ZXIpIG5vciByZWplY3QgdGhlXG4gICAgICAgKnJlcXVlc3Qgb3BlbmluZyB0aGUgc2Vzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUiB8fFxuICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLIHx8XG4gICAgICAgICB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0sgfHxcbiAgICAgICAgIHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19FQVJMWV9NRURJQSB8fFxuICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0FOU1dFUkVEKSB7XG5cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19DQU5DRUxFRDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0LnJlcGx5KDQ4Nyk7XG4gICAgICAgIHRoaXMuY2FuY2VsZWQocmVxdWVzdCk7XG4gICAgICAgIHRoaXMucmVqZWN0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkNBTkNFTEVEKTtcbiAgICAgICAgdGhpcy5mYWlsZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkNBTkNFTEVEKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5DQU5DRUxFRCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNJUC5DLkFDSzpcbiAgICAgIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0Fuc3dlcikge1xuICAgICAgICAgIGlmKHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmdldEhlYWRlcignY29udGVudC10eXBlJykgPT09ICdhcHBsaWNhdGlvbi9zZHAnKSB7XG4gICAgICAgICAgICAvLyBBQ0sgY29udGFpbnMgYW5zd2VyIHRvIGFuIElOVklURSB3L28gU0RQIG5lZ290aWF0aW9uXG4gICAgICAgICAgICBTSVAuSGFja3MuRmlyZWZveC5jYW5ub3RIYW5kbGVFeHRyYVdoaXRlc3BhY2UocmVxdWVzdCk7XG4gICAgICAgICAgICBTSVAuSGFja3MuQWxsQnJvd3NlcnMubWFza0R0bHMocmVxdWVzdCk7XG5cbiAgICAgICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlcXVlc3QuYm9keSlcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICBjb25maXJtU2Vzc2lvbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUgKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMudGVybWluYXRlKHtcbiAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6ICc0ODgnLFxuICAgICAgICAgICAgICAgICAgcmVhc29uUGhyYXNlOiAnQmFkIE1lZGlhIERlc2NyaXB0aW9uJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgIHRoaXMudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5lYXJseV9zZHApIHtcbiAgICAgICAgICAgIGNvbmZpcm1TZXNzaW9uLmFwcGx5KHRoaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL1RPRE86IFBhc3MgdG8gbWVkaWFoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uZmlybVNlc3Npb24uYXBwbHkodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0lQLkMuUFJBQ0s6XG4gICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLIHx8IHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgICAvL2xvY2FsTWVkaWEgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhO1xuICAgICAgICBpZighdGhpcy5oYXNBbnN3ZXIpIHtcbiAgICAgICAgICBpZihyZXF1ZXN0LmJvZHkgJiYgcmVxdWVzdC5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpID09PSAnYXBwbGljYXRpb24vc2RwJykge1xuICAgICAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVxdWVzdC5ib2R5KVxuICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyAoKSB7XG4gICAgICAgICAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMucmVsMXh4VGltZXIpO1xuICAgICAgICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnByYWNrVGltZXIpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoMjAwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgICAgICAgdGhpcy5hY2NlcHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgICAgICAvL1JFVklTSVRcbiAgICAgICAgICAgICAgICB0aGlzLm11dGUoKTtcbiAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUgKGUpIHtcbiAgICAgICAgICAgICAgICAvL1RPRE86IFNlbmQgdG8gbWVkaWEgaGFuZGxlclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUoe1xuICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogJzQ4OCcsXG4gICAgICAgICAgICAgICAgICByZWFzb25QaHJhc2U6ICdCYWQgTWVkaWEgRGVzY3JpcHRpb24nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlKHtcbiAgICAgICAgICAgICAgc3RhdHVzQ29kZTogJzQ4OCcsXG4gICAgICAgICAgICAgIHJlYXNvblBocmFzZTogJ0JhZCBNZWRpYSBEZXNjcmlwdGlvbidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnJlbDF4eFRpbWVyKTtcbiAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5wcmFja1RpbWVyKTtcbiAgICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgdGhpcy5hY2NlcHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAvL1JFVklTSVRcbiAgICAgICAgICB0aGlzLm11dGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19FQVJMWV9NRURJQSkge1xuICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgU2Vzc2lvbi5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QuYXBwbHkodGhpcywgW3JlcXVlc3RdKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH1cbiAgfSxcblxuICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5TSVAuSW52aXRlU2VydmVyQ29udGV4dCA9IEludml0ZVNlcnZlckNvbnRleHQ7XG5cbkludml0ZUNsaWVudENvbnRleHQgPSBmdW5jdGlvbih1YSwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKFNlc3Npb24uZGVzdWdhcihvcHRpb25zKSk7XG4gIG9wdGlvbnMucGFyYW1zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zLnBhcmFtcyB8fCBPYmplY3QucHJvdG90eXBlKTtcblxuICB2YXIgaWNlU2VydmVycyxcbiAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgc3R1blNlcnZlcnMgPSBvcHRpb25zLnN0dW5TZXJ2ZXJzIHx8IG51bGwsXG4gICAgdHVyblNlcnZlcnMgPSBvcHRpb25zLnR1cm5TZXJ2ZXJzIHx8IG51bGwsXG4gICAgbWVkaWFIYW5kbGVyRmFjdG9yeSA9IG9wdGlvbnMubWVkaWFIYW5kbGVyRmFjdG9yeSB8fCB1YS5jb25maWd1cmF0aW9uLm1lZGlhSGFuZGxlckZhY3RvcnksXG4gICAgaXNNZWRpYVN1cHBvcnRlZCA9IG1lZGlhSGFuZGxlckZhY3RvcnkuaXNTdXBwb3J0ZWQ7XG5cbiAgLy8gQ2hlY2sgV2ViUlRDIHN1cHBvcnRcbiAgaWYgKGlzTWVkaWFTdXBwb3J0ZWQgJiYgIWlzTWVkaWFTdXBwb3J0ZWQoKSkge1xuICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5Ob3RTdXBwb3J0ZWRFcnJvcignTWVkaWEgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgdGhpcy5SVENDb25zdHJhaW50cyA9IG9wdGlvbnMuUlRDQ29uc3RyYWludHMgfHwge307XG4gIHRoaXMuaW52aXRlV2l0aG91dFNkcCA9IG9wdGlvbnMuaW52aXRlV2l0aG91dFNkcCB8fCBmYWxzZTtcblxuICAvLyBTZXQgYW5vbnltb3VzIHByb3BlcnR5XG4gIHRoaXMuYW5vbnltb3VzID0gb3B0aW9ucy5hbm9ueW1vdXMgfHwgZmFsc2U7XG5cbiAgLy8gQ3VzdG9tIGRhdGEgdG8gYmUgc2VudCBlaXRoZXIgaW4gSU5WSVRFIG9yIGluIEFDS1xuICB0aGlzLnJlbmRlcmJvZHkgPSBvcHRpb25zLnJlbmRlcmJvZHkgfHwgbnVsbDtcbiAgdGhpcy5yZW5kZXJ0eXBlID0gb3B0aW9ucy5yZW5kZXJ0eXBlIHx8ICd0ZXh0L3BsYWluJztcblxuICBvcHRpb25zLnBhcmFtcy5mcm9tX3RhZyA9IHRoaXMuZnJvbV90YWc7XG5cbiAgLyogRG8gbm90IGFkZCA7b2IgaW4gaW5pdGlhbCBmb3JtaW5nIGRpYWxvZyByZXF1ZXN0cyBpZiB0aGUgcmVnaXN0cmF0aW9uIG92ZXJcbiAgICogIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gZ290IGEgR1JVVSBVUkkuXG4gICAqL1xuICB0aGlzLmNvbnRhY3QgPSB1YS5jb250YWN0LnRvU3RyaW5nKHtcbiAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuICAgIG91dGJvdW5kOiB0aGlzLmFub255bW91cyA/ICF1YS5jb250YWN0LnRlbXBfZ3J1dSA6ICF1YS5jb250YWN0LnB1Yl9ncnV1XG4gIH0pO1xuXG4gIGlmICh0aGlzLmFub255bW91cykge1xuICAgIG9wdGlvbnMucGFyYW1zLmZyb21fZGlzcGxheU5hbWUgPSAnQW5vbnltb3VzJztcbiAgICBvcHRpb25zLnBhcmFtcy5mcm9tX3VyaSA9ICdzaXA6YW5vbnltb3VzQGFub255bW91cy5pbnZhbGlkJztcblxuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdQLVByZWZlcnJlZC1JZGVudGl0eTogJysgdWEuY29uZmlndXJhdGlvbi51cmkudG9TdHJpbmcoKSk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ1ByaXZhY3k6IGlkJyk7XG4gIH1cbiAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcrIHRoaXMuY29udGFjdCk7XG4gIGV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJysgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCkpO1xuICBpZiAoIXRoaXMuaW52aXRlV2l0aG91dFNkcCkge1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL3NkcCcpO1xuICB9IGVsc2UgaWYgKHRoaXMucmVuZGVyYm9keSkge1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6ICcgKyB0aGlzLnJlbmRlcnR5cGUpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LURpc3Bvc2l0aW9uOiByZW5kZXI7aGFuZGxpbmc9b3B0aW9uYWwnKTtcbiAgfVxuXG4gIGlmICh1YS5jb25maWd1cmF0aW9uLnJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSB7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JlcXVpcmU6IDEwMHJlbCcpO1xuICB9XG4gIGlmICh1YS5jb25maWd1cmF0aW9uLnJlcGxhY2VzID09PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpIHtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVxdWlyZTogcmVwbGFjZXMnKTtcbiAgfVxuXG4gIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuXG4gIFNJUC5VdGlscy5hdWdtZW50KHRoaXMsIFNJUC5DbGllbnRDb250ZXh0LCBbdWEsIFNJUC5DLklOVklURSwgdGFyZ2V0LCBvcHRpb25zXSk7XG4gIFNJUC5VdGlscy5hdWdtZW50KHRoaXMsIFNJUC5TZXNzaW9uLCBbbWVkaWFIYW5kbGVyRmFjdG9yeV0pO1xuXG4gIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfTlVMTCkge1xuICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gIH1cblxuICAvLyBTZXNzaW9uIHBhcmFtZXRlciBpbml0aWFsaXphdGlvblxuICB0aGlzLmZyb21fdGFnID0gU0lQLlV0aWxzLm5ld1RhZygpO1xuXG4gIC8vIE91dGdvaW5nU2Vzc2lvbiBzcGVjaWZpYyBwYXJhbWV0ZXJzXG4gIHRoaXMuaXNDYW5jZWxlZCA9IGZhbHNlO1xuICB0aGlzLnJlY2VpdmVkXzEwMCA9IGZhbHNlO1xuXG4gIHRoaXMubWV0aG9kID0gU0lQLkMuSU5WSVRFO1xuXG4gIHRoaXMucmVjZWl2ZU5vbkludml0ZVJlc3BvbnNlID0gdGhpcy5yZWNlaXZlUmVzcG9uc2U7XG4gIHRoaXMucmVjZWl2ZVJlc3BvbnNlID0gdGhpcy5yZWNlaXZlSW52aXRlUmVzcG9uc2U7XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5pbnZpdGVjbGllbnRjb250ZXh0Jyk7XG5cbiAgaWYgKHN0dW5TZXJ2ZXJzKSB7XG4gICAgaWNlU2VydmVycyA9IFNJUC5VQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsWydzdHVuU2VydmVycyddKHN0dW5TZXJ2ZXJzKTtcbiAgICBpZiAoIWljZVNlcnZlcnMpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3R1blNlcnZlcnM6ICcrIHN0dW5TZXJ2ZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdHVuU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR1cm5TZXJ2ZXJzKSB7XG4gICAgaWNlU2VydmVycyA9IFNJUC5VQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsWyd0dXJuU2VydmVycyddKHR1cm5TZXJ2ZXJzKTtcbiAgICBpZiAoIWljZVNlcnZlcnMpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdHVyblNlcnZlcnM6ICcrIHR1cm5TZXJ2ZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50dXJuU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgfVxuICB9XG5cbiAgdWEuYXBwbGljYW50c1t0aGlzXSA9IHRoaXM7XG5cbiAgdGhpcy5pZCA9IHRoaXMucmVxdWVzdC5jYWxsX2lkICsgdGhpcy5mcm9tX3RhZztcblxuICAvL0luaXRpYWxpemUgTWVkaWEgU2Vzc2lvblxuICB0aGlzLm1lZGlhSGFuZGxlciA9IHRoaXMubWVkaWFIYW5kbGVyRmFjdG9yeSh0aGlzLCB7XG4gICAgUlRDQ29uc3RyYWludHM6IHRoaXMuUlRDQ29uc3RyYWludHMsXG4gICAgc3R1blNlcnZlcnM6IHRoaXMuc3R1blNlcnZlcnMsXG4gICAgdHVyblNlcnZlcnM6IHRoaXMudHVyblNlcnZlcnNcbiAgfSk7XG5cbiAgaWYgKHRoaXMubWVkaWFIYW5kbGVyICYmIHRoaXMubWVkaWFIYW5kbGVyLmdldFJlbW90ZVN0cmVhbXMpIHtcbiAgICB0aGlzLmdldFJlbW90ZVN0cmVhbXMgPSB0aGlzLm1lZGlhSGFuZGxlci5nZXRSZW1vdGVTdHJlYW1zLmJpbmQodGhpcy5tZWRpYUhhbmRsZXIpO1xuICAgIHRoaXMuZ2V0TG9jYWxTdHJlYW1zID0gdGhpcy5tZWRpYUhhbmRsZXIuZ2V0TG9jYWxTdHJlYW1zLmJpbmQodGhpcy5tZWRpYUhhbmRsZXIpO1xuICB9XG5cbiAgU0lQLlV0aWxzLm9wdGlvbnNPdmVycmlkZShvcHRpb25zLCAnbWVkaWEnLCAnbWVkaWFDb25zdHJhaW50cycsIHRydWUsIHRoaXMubG9nZ2VyLCB0aGlzLnVhLmNvbmZpZ3VyYXRpb24ubWVkaWEpO1xuICB0aGlzLm1lZGlhSGludCA9IG9wdGlvbnMubWVkaWE7XG59O1xuXG5JbnZpdGVDbGllbnRDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgaW52aXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy9TYXZlIHRoZSBzZXNzaW9uIGludG8gdGhlIHVhIHNlc3Npb25zIGNvbGxlY3Rpb24uXG4gICAgLy9Ob3RlOiBwbGFjaW5nIGluIGNvbnN0cnVjdG9yIGJyZWFrcyBjYWxsIHRvIHJlcXVlc3QuY2FuY2VsIG9uIGNsb3NlLi4uIFVzZXIgZG9lcyBub3QgbmVlZCB0aGlzIGFueXdheVxuICAgIHRoaXMudWEuc2Vzc2lvbnNbdGhpcy5pZF0gPSB0aGlzO1xuXG4gICAgLy9Ob3RlOiBkdWUgdG8gdGhlIHdheSBGaXJlZm94IGhhbmRsZXMgZ1VNIGNhbGxzLCBpdCBpcyByZWNvbW1lbmRlZCB0byBtYWtlIHRoZSBnVU0gY2FsbCBhdCB0aGUgYXBwIGxldmVsXG4gICAgLy8gYW5kIGhhbmQgc2lwLmpzIGEgc3RyZWFtIGFzIHRoZSBtZWRpYUhpbnRcbiAgICBpZiAodGhpcy5pbnZpdGVXaXRob3V0U2RwKSB7XG4gICAgICAvL2p1c3Qgc2VuZCBhbiBpbnZpdGUgd2l0aCBubyBzZHAuLi5cbiAgICAgIHRoaXMucmVxdWVzdC5ib2R5ID0gc2VsZi5yZW5kZXJib2R5O1xuICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19JTlZJVEVfU0VOVDtcbiAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbihzZWxmLm1lZGlhSGludClcbiAgICAgIC50aGVuKFxuICAgICAgICBmdW5jdGlvbiBvblN1Y2Nlc3Mob2ZmZXIpIHtcbiAgICAgICAgICBpZiAoc2VsZi5pc0NhbmNlbGVkIHx8IHNlbGYuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuaGFzT2ZmZXIgPSB0cnVlO1xuICAgICAgICAgIHNlbGYucmVxdWVzdC5ib2R5ID0gb2ZmZXI7XG4gICAgICAgICAgc2VsZi5zdGF0dXMgPSBDLlNUQVRVU19JTlZJVEVfU0VOVDtcbiAgICAgICAgICBzZWxmLnNlbmQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlKCkge1xuICAgICAgICAgIGlmIChzZWxmLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUT0RPLi4uZmFpbCBvdXRcbiAgICAgICAgICAvL3NlbGYuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5VU0VSX0RFTklFRF9NRURJQV9BQ0NFU1MpO1xuICAgICAgICAgIC8vc2VsZi5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgc2VsZi5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgc2VsZi50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlY2VpdmVJbnZpdGVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB2YXIgY2F1c2UsIC8vbG9jYWxNZWRpYSxcbiAgICAgIHNlc3Npb24gPSB0aGlzLFxuICAgICAgaWQgPSByZXNwb25zZS5jYWxsX2lkICsgcmVzcG9uc2UuZnJvbV90YWcgKyByZXNwb25zZS50b190YWcsXG4gICAgICBleHRyYUhlYWRlcnMgPSBbXSxcbiAgICAgIG9wdGlvbnMgPSB7fTtcblxuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCB8fCByZXNwb25zZS5tZXRob2QgIT09IFNJUC5DLklOVklURSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpYWxvZyAmJiAocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1c19jb2RlIDw9IDI5OSkpIHtcbiAgICAgIGlmIChpZCAhPT0gdGhpcy5kaWFsb2cuaWQudG9TdHJpbmcoKSApIHtcbiAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycsIHRydWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5zZW5kUmVxdWVzdCh0aGlzLCBTSVAuQy5BQ0ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IFNJUC5VdGlscy5nZW5lcmF0ZUZha2VTRFAocmVzcG9uc2UuYm9keSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0uc2VuZFJlcXVlc3QodGhpcywgU0lQLkMuQllFKTtcblxuICAgICAgICAvKiBOT1RFOiBUaGlzIGZhaWxzIGJlY2F1c2UgdGhlIGZvcmtpbmcgcHJveHkgZG9lcyBub3QgcmVjb2duaXplIHRoYXQgYW4gdW5hbnN3ZXJhYmxlXG4gICAgICAgICAqIGxlZyAoZHVlIHRvIHBlZXJDb25uZWN0aW9uIGxpbWl0YXRpb25zKSBoYXMgYmVlbiBhbnN3ZXJlZCBmaXJzdC4gSWYgeW91ciBmb3JraW5nXG4gICAgICAgICAqIHByb3h5IGRvZXMgbm90IGhhbmcgdXAgYWxsIHVuYW5zd2VyZWQgYnJhbmNoZXMgb24gdGhlIGZpcnN0IGJyYW5jaCBhbnN3ZXJlZCwgcmVtb3ZlIHRoaXMuXG4gICAgICAgICAqL1xuICAgICAgICBpZih0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgIHRoaXMudGVybWluYXRlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuQUNLLHtjc2VxOiByZXNwb25zZS5jc2VxfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzQW5zd2VyKSB7XG4gICAgICAgIC8vIGludml0ZSB3L28gc2RwIGlzIHdhaXRpbmcgZm9yIGNhbGxiYWNrXG4gICAgICAgIC8vYW4gaW52aXRlIHdpdGggc2RwIG11c3QgZ28gb24sIGFuZCBoYXNBbnN3ZXIgaXMgdHJ1ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlhbG9nICYmIHJlc3BvbnNlLnN0YXR1c19jb2RlIDwgMjAwKSB7XG4gICAgICAvKlxuICAgICAgICBFYXJseSBtZWRpYSBoYXMgYmVlbiBzZXQgdXAgd2l0aCBhdCBsZWFzdCBvbmUgb3RoZXIgZGlmZmVyZW50IGJyYW5jaCxcbiAgICAgICAgYnV0IGEgZmluYWwgMnh4IHJlc3BvbnNlIGhhc24ndCBiZWVuIHJlY2VpdmVkXG4gICAgICAqL1xuICAgICAgaWYgKHRoaXMuZGlhbG9nLnByYWNrZWQuaW5kZXhPZihyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSkgIT09IC0xIHx8XG4gICAgICAgICAgKHRoaXMuZGlhbG9nLnByYWNrZWRbdGhpcy5kaWFsb2cucHJhY2tlZC5sZW5ndGgtMV0gPj0gcmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykgJiYgdGhpcy5kaWFsb2cucHJhY2tlZC5sZW5ndGggPiAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5lYXJseURpYWxvZ3NbaWRdICYmICF0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycsIHRydWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLmluZGV4T2YocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpICE9PSAtMSB8fFxuICAgICAgICAgICh0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZFt0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5sZW5ndGgtMV0gPj0gcmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykgJiYgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnUkFjazogJyArIHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICsgJyAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdjc2VxJykpO1xuICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQucHVzaChyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSk7XG5cbiAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5zZW5kUmVxdWVzdCh0aGlzLCBTSVAuQy5QUkFDSywge1xuICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgYm9keTogU0lQLlV0aWxzLmdlbmVyYXRlRmFrZVNEUChyZXNwb25zZS5ib2R5KVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJvY2VlZCB0byBjYW5jZWxsYXRpb24gaWYgdGhlIHVzZXIgcmVxdWVzdGVkLlxuICAgIGlmKHRoaXMuaXNDYW5jZWxlZCkge1xuICAgICAgaWYocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPj0gMTAwICYmIHJlc3BvbnNlLnN0YXR1c19jb2RlIDwgMjAwKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdC5jYW5jZWwodGhpcy5jYW5jZWxSZWFzb24pO1xuICAgICAgICB0aGlzLmNhbmNlbGVkKG51bGwpO1xuICAgICAgfSBlbHNlIGlmKHJlc3BvbnNlLnN0YXR1c19jb2RlID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA8IDI5OSkge1xuICAgICAgICB0aGlzLmFjY2VwdEFuZFRlcm1pbmF0ZShyZXNwb25zZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnYnllJywgdGhpcy5yZXF1ZXN0KTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPj0gMzAwKSB7XG4gICAgICAgIGNhdXNlID0gU0lQLkMuUkVBU09OX1BIUkFTRVtyZXNwb25zZS5zdGF0dXNfY29kZV0gfHwgU0lQLkMuY2F1c2VzLkNBTkNFTEVEO1xuICAgICAgICB0aGlzLnJlamVjdGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgIHRoaXMudGVybWluYXRlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCh0cnVlKSB7XG4gICAgICBjYXNlIC9eMTAwJC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgIHRoaXMucmVjZWl2ZWRfMTAwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICgvXjFbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpKTpcbiAgICAgICAgLy8gRG8gbm90aGluZyB3aXRoIDF4eCByZXNwb25zZXMgd2l0aG91dCBUbyB0YWcuXG4gICAgICAgIGlmKCFyZXNwb25zZS50b190YWcpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCcxeHggcmVzcG9uc2UgcmVjZWl2ZWQgd2l0aG91dCB0byB0YWcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBFYXJseSBEaWFsb2cgaWYgMVhYIGNvbWVzIHdpdGggY29udGFjdFxuICAgICAgICBpZihyZXNwb25zZS5oYXNIZWFkZXIoJ2NvbnRhY3QnKSkge1xuICAgICAgICAgIC8vIEFuIGVycm9yIG9uIGRpYWxvZyBjcmVhdGlvbiB3aWxsIGZpcmUgJ2ZhaWxlZCcgZXZlbnRcbiAgICAgICAgICBpZiAoIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfMVhYX1JFQ0VJVkVEO1xuXG4gICAgICAgIGlmKHJlc3BvbnNlLmhhc0hlYWRlcigncmVxdWlyZScpICYmXG4gICAgICAgICAgIHJlc3BvbnNlLmdldEhlYWRlcigncmVxdWlyZScpLmluZGV4T2YoJzEwMHJlbCcpICE9PSAtMSkge1xuXG4gICAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGlzLmRpYWxvZyBpcyBhbHJlYWR5IGNvbmZpcm1lZFxuICAgICAgICAgIGlmICh0aGlzLmRpYWxvZyB8fCAhdGhpcy5lYXJseURpYWxvZ3NbaWRdKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQuaW5kZXhPZihyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICh0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZFt0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5sZW5ndGgtMV0gPj0gcmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykgJiYgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBTSVAuSGFja3MuRmlyZWZveC5jYW5ub3RIYW5kbGVFeHRyYVdoaXRlc3BhY2UocmVzcG9uc2UpO1xuICAgICAgICAgIFNJUC5IYWNrcy5BbGxCcm93c2Vycy5tYXNrRHRscyhyZXNwb25zZSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSQWNrOiAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykgKyAnICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ2NzZXEnKSk7XG4gICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5wdXNoKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKTtcbiAgICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5zZW5kUmVxdWVzdCh0aGlzLCBTSVAuQy5QUkFDSywge1xuICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc09mZmVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpYWxvZy5wcmFja2VkLnB1c2gocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpO1xuXG4gICAgICAgICAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5ib2R5KVxuICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyAoKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JBY2s6ICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSArICcgJyArIHJlc3BvbnNlLmdldEhlYWRlcignY3NlcScpKTtcblxuICAgICAgICAgICAgICAgIHNlc3Npb24uc2VuZFJlcXVlc3QoU0lQLkMuUFJBQ0ssIHtcbiAgICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbigpIHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5zdGF0dXMgPSBDLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLm11dGUoKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSBDLlNUQVRVU19FQVJMWV9NRURJQSkge1xuICAgICAgICAgICAgICAgICAgbG9jYWxNZWRpYSA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWE7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpWzBdLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKClbMF0uZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUgKGUpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uYWNjZXB0QW5kVGVybWluYXRlKHJlc3BvbnNlLCA0ODgsICdOb3QgQWNjZXB0YWJsZSBIZXJlJyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZWFybHlEaWFsb2cgPSB0aGlzLmVhcmx5RGlhbG9nc1tpZF07XG4gICAgICAgICAgICB2YXIgZWFybHlNZWRpYSA9IGVhcmx5RGlhbG9nLm1lZGlhSGFuZGxlcjtcblxuICAgICAgICAgICAgZWFybHlEaWFsb2cucHJhY2tlZC5wdXNoKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKTtcblxuICAgICAgICAgICAgZWFybHlNZWRpYS5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5ib2R5KVxuICAgICAgICAgICAgLnRoZW4oZWFybHlNZWRpYS5nZXREZXNjcmlwdGlvbi5iaW5kKGVhcmx5TWVkaWEsIHNlc3Npb24ubWVkaWFIaW50KSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIG9uU3VjY2VzcyhzZHApIHtcbiAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vc2RwJyk7XG4gICAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSQWNrOiAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykgKyAnICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ2NzZXEnKSk7XG4gICAgICAgICAgICAgIGVhcmx5RGlhbG9nLnNlbmRSZXF1ZXN0KHNlc3Npb24sIFNJUC5DLlBSQUNLLCB7XG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogc2RwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZXNzaW9uLnN0YXR1cyA9IEMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgICBzZXNzaW9uLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiBvbkZhaWx1cmUoZSkge1xuICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNJUC5FeGNlcHRpb25zLkdldERlc2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlYXJseURpYWxvZy5wcmFja2VkLnB1c2gocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpO1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gZmFpbCBvdXQgb24gZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBzZXNzaW9uLmZhaWxlZChndW0gZXJyb3IpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24udGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlYXJseURpYWxvZy5wcmFja2VkLnNwbGljZShlYXJseURpYWxvZy5wcmFja2VkLmluZGV4T2YocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpLCAxKTtcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBub3Qgc2V0IHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oJ2ludmFsaWQgU0RQJyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgIHZhciBjc2VxID0gdGhpcy5yZXF1ZXN0LmNzZXEgKyAnICcgKyB0aGlzLnJlcXVlc3QubWV0aG9kO1xuICAgICAgICBpZiAoY3NlcSAhPT0gcmVzcG9uc2UuZ2V0SGVhZGVyKCdjc2VxJykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfRUFSTFlfTUVESUEgJiYgdGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgICAgICB0aGlzLnVubXV0ZSgpO1xuICAgICAgICAgIC8qbG9jYWxNZWRpYSA9IHRoaXMubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWE7XG4gICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH0qL1xuICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJib2R5KSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiAnICsgdGhpcy5yZW5kZXJ0eXBlKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gdGhpcy5yZW5kZXJib2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHRpb25zLmNzZXEgPSByZXNwb25zZS5jc2VxO1xuICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuQUNLLCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLmFjY2VwdGVkKHJlc3BvbnNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoaXMuZGlhbG9nIGlzIGFscmVhZHkgY29uZmlybWVkXG4gICAgICAgIGlmICh0aGlzLmRpYWxvZykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgU0lQLkhhY2tzLkZpcmVmb3guY2Fubm90SGFuZGxlRXh0cmFXaGl0ZXNwYWNlKHJlc3BvbnNlKTtcbiAgICAgICAgU0lQLkhhY2tzLkFsbEJyb3dzZXJzLm1hc2tEdGxzKHJlc3BvbnNlKTtcblxuICAgICAgICAvLyBUaGlzIGlzIGFuIGludml0ZSB3aXRob3V0IHNkcFxuICAgICAgICBpZiAoIXRoaXMuaGFzT2ZmZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5lYXJseURpYWxvZ3NbaWRdICYmIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5tZWRpYUhhbmRsZXIubG9jYWxNZWRpYSkge1xuICAgICAgICAgICAgLy9SRVZJU0lUXG4gICAgICAgICAgICB0aGlzLmhhc09mZmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFIYW5kbGVyID0gdGhpcy5lYXJseURpYWxvZ3NbaWRdLm1lZGlhSGFuZGxlcjtcbiAgICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5BQ0ssIHtjc2VxOnJlc3BvbnNlLmNzZXF9KTtcblxuICAgICAgICAgICAgdGhpcy51bm11dGUoKTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBsb2NhbE1lZGlhID0gc2Vzc2lvbi5tZWRpYUhhbmRsZXIubG9jYWxNZWRpYTtcbiAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICB0aGlzLmFjY2VwdGVkKHJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY2NlcHRBbmRUZXJtaW5hdGUocmVzcG9uc2UsIDQwMCwgJ01pc3Npbmcgc2Vzc2lvbiBkZXNjcmlwdGlvbicpO1xuICAgICAgICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYXNPZmZlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5ib2R5KVxuICAgICAgICAgICAgLnRoZW4odGhpcy5tZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24uYmluZCh0aGlzLm1lZGlhSGFuZGxlciwgdGhpcy5tZWRpYUhpbnQpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gb25TdWNjZXNzKHNkcCkge1xuICAgICAgICAgICAgICAvL3ZhciBsb2NhbE1lZGlhO1xuICAgICAgICAgICAgICBpZihzZXNzaW9uLmlzQ2FuY2VsZWQgfHwgc2Vzc2lvbi5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZHAgPSBTSVAuSGFja3MuRmlyZWZveC5oYXNNaXNzaW5nQ0xpbmVJblNEUChzZHApO1xuXG4gICAgICAgICAgICAgIHNlc3Npb24uc3RhdHVzID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgICAgICAgICBzZXNzaW9uLmhhc0Fuc3dlciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgc2Vzc2lvbi51bm11dGUoKTtcbiAgICAgICAgICAgICAgLypsb2NhbE1lZGlhID0gc2Vzc2lvbi5tZWRpYUhhbmRsZXIubG9jYWxNZWRpYTtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgIHNlc3Npb24uc2VuZFJlcXVlc3QoU0lQLkMuQUNLLHtcbiAgICAgICAgICAgICAgICBib2R5OiBzZHAsXG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOlsnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9zZHAnXSxcbiAgICAgICAgICAgICAgICBjc2VxOnJlc3BvbnNlLmNzZXFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNlc3Npb24uYWNjZXB0ZWQocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiBvbkZhaWx1cmUoZSkge1xuICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNJUC5FeGNlcHRpb25zLkdldERlc2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGRvIHNvbWV0aGluZyBoZXJlXG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIud2FybihcInRoZXJlIHdhcyBhIHByb2JsZW1cIik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIud2FybignaW52YWxpZCBTRFAnKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlcGx5KDQ4OCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0Fuc3dlcil7XG4gICAgICAgICAgaWYgKHRoaXMucmVuZGVyYm9keSkge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogJyArIHNlc3Npb24ucmVuZGVydHlwZSk7XG4gICAgICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcbiAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IHRoaXMucmVuZGVyYm9keTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5BQ0ssIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICB0aGlzLmFjY2VwdEFuZFRlcm1pbmF0ZShyZXNwb25zZSwgNDAwLCAnTWlzc2luZyBzZXNzaW9uIGRlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICBmdW5jdGlvbiBvblN1Y2Nlc3MgKCkge1xuICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9Oy8vLGxvY2FsTWVkaWE7XG4gICAgICAgICAgICAgIHNlc3Npb24uc3RhdHVzID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgICAgICAgICBzZXNzaW9uLnVubXV0ZSgpO1xuICAgICAgICAgICAgICAvKmxvY2FsTWVkaWEgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhO1xuICAgICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgaWYgKHNlc3Npb24ucmVuZGVyYm9keSkge1xuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6ICcgKyBzZXNzaW9uLnJlbmRlcnR5cGUpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IHNlc3Npb24ucmVuZGVyYm9keTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcHRpb25zLmNzZXEgPSByZXNwb25zZS5jc2VxO1xuICAgICAgICAgICAgICBzZXNzaW9uLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIHNlc3Npb24uYWNjZXB0ZWQocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSAoZSkge1xuICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgICBzZXNzaW9uLmFjY2VwdEFuZFRlcm1pbmF0ZShyZXNwb25zZSwgNDg4LCAnTm90IEFjY2VwdGFibGUgSGVyZScpO1xuICAgICAgICAgICAgICBzZXNzaW9uLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhdXNlID0gU0lQLlV0aWxzLnNpcEVycm9yQ2F1c2UocmVzcG9uc2Uuc3RhdHVzX2NvZGUpO1xuICAgICAgICB0aGlzLnJlamVjdGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgIHRoaXMudGVybWluYXRlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgIH1cbiAgfSxcblxuICBjYW5jZWw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEIHx8IHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIubG9nKCdjYW5jZWxpbmcgUlRDU2Vzc2lvbicpO1xuXG4gICAgdmFyIGNhbmNlbF9yZWFzb24gPSBTSVAuVXRpbHMuZ2V0Q2FuY2VsUmVhc29uKG9wdGlvbnMuc3RhdHVzX2NvZGUsIG9wdGlvbnMucmVhc29uX3BocmFzZSk7XG5cbiAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfTlVMTCB8fFxuICAgICAgICAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0lOVklURV9TRU5UICYmICF0aGlzLnJlY2VpdmVkXzEwMCkpIHtcbiAgICAgIHRoaXMuaXNDYW5jZWxlZCA9IHRydWU7XG4gICAgICB0aGlzLmNhbmNlbFJlYXNvbiA9IGNhbmNlbF9yZWFzb247XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfSU5WSVRFX1NFTlQgfHxcbiAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU18xWFhfUkVDRUlWRUQgfHxcbiAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19FQVJMWV9NRURJQSkge1xuICAgICAgdGhpcy5yZXF1ZXN0LmNhbmNlbChjYW5jZWxfcmVhc29uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jYW5jZWxlZCgpO1xuICB9LFxuXG4gIHRlcm1pbmF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0sgfHwgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhpcy5ieWUob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FuY2VsKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlY2VpdmVSZXF1ZXN0OiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgLy8gSUNDIFJFQ0VJVkUgUkVRVUVTVFxuXG4gICAgLy8gUmVqZWN0IENBTkNFTHNcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFNJUC5DLkNBTkNFTCkge1xuICAgICAgLy8gVE9ETzsgbWFrZSB0aGlzIGEgc3dpdGNoIHdoZW4gaXQgZ2V0cyBhZGRlZFxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gU0lQLkMuQUNLICYmIHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmFja1RpbWVyKTtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmludml0ZTJ4eFRpbWVyKTtcbiAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgdGhpcy51bm11dGUoKTtcblxuICAgICAgdGhpcy5hY2NlcHRlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBTZXNzaW9uLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdC5hcHBseSh0aGlzLCBbcmVxdWVzdF0pO1xuICB9LFxuXG4gIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEICYmIHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfVxuICB9LFxuXG4gIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfVxuICB9XG5cbn07XG5cblNJUC5JbnZpdGVDbGllbnRDb250ZXh0ID0gSW52aXRlQ2xpZW50Q29udGV4dDtcblxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvU2Vzc2lvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRFRNRlxuICovXG5cbi8qKlxuICogQGNsYXNzIERUTUZcbiAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG5cbnZhciBEVE1GLFxuICBDID0ge1xuICAgIE1JTl9EVVJBVElPTjogICAgICAgICAgICA3MCxcbiAgICBNQVhfRFVSQVRJT046ICAgICAgICAgICAgNjAwMCxcbiAgICBERUZBVUxUX0RVUkFUSU9OOiAgICAgICAgMTAwLFxuICAgIE1JTl9JTlRFUl9UT05FX0dBUDogICAgICA1MCxcbiAgICBERUZBVUxUX0lOVEVSX1RPTkVfR0FQOiAgNTAwXG4gIH07XG5cbkRUTUYgPSBmdW5jdGlvbihzZXNzaW9uLCB0b25lLCBvcHRpb25zKSB7XG4gIHZhciBkdXJhdGlvbiwgaW50ZXJUb25lR2FwO1xuXG4gIGlmICh0b25lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICB9XG5cbiAgdGhpcy5sb2dnZXIgPSBzZXNzaW9uLnVhLmdldExvZ2dlcignc2lwLmludml0ZWNvbnRleHQuZHRtZicsIHNlc3Npb24uaWQpO1xuICB0aGlzLm93bmVyID0gc2Vzc2lvbjtcbiAgdGhpcy5kaXJlY3Rpb24gPSBudWxsO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgbnVsbDtcbiAgaW50ZXJUb25lR2FwID0gb3B0aW9ucy5pbnRlclRvbmVHYXAgfHwgbnVsbDtcblxuICAvLyBDaGVjayB0b25lIHR5cGVcbiAgaWYgKHR5cGVvZiB0b25lID09PSAnc3RyaW5nJyApIHtcbiAgICB0b25lID0gdG9uZS50b1VwcGVyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0b25lID09PSAnbnVtYmVyJykge1xuICAgIHRvbmUgPSB0b25lLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0b25lOiAnKyB0b25lKTtcbiAgfVxuXG4gIC8vIENoZWNrIHRvbmUgdmFsdWVcbiAgaWYgKCF0b25lLm1hdGNoKC9eWzAtOUEtRCMqXSQvKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdG9uZTogJysgdG9uZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b25lID0gdG9uZTtcbiAgfVxuXG4gIC8vIENoZWNrIGR1cmF0aW9uXG4gIGlmIChkdXJhdGlvbiAmJiAhU0lQLlV0aWxzLmlzRGVjaW1hbChkdXJhdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRvbmUgZHVyYXRpb246ICcrIGR1cmF0aW9uKTtcbiAgfSBlbHNlIGlmICghZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiA9IERUTUYuQy5ERUZBVUxUX0RVUkFUSU9OO1xuICB9IGVsc2UgaWYgKGR1cmF0aW9uIDwgRFRNRi5DLk1JTl9EVVJBVElPTikge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ1wiZHVyYXRpb25cIiB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBtaW5pbXVtIGFsbG93ZWQsIHNldHRpbmcgaXQgdG8gJysgRFRNRi5DLk1JTl9EVVJBVElPTisgJyBtaWxsaXNlY29uZHMnKTtcbiAgICBkdXJhdGlvbiA9IERUTUYuQy5NSU5fRFVSQVRJT047XG4gIH0gZWxzZSBpZiAoZHVyYXRpb24gPiBEVE1GLkMuTUFYX0RVUkFUSU9OKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignXCJkdXJhdGlvblwiIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkLCBzZXR0aW5nIGl0IHRvICcrIERUTUYuQy5NQVhfRFVSQVRJT04gKycgbWlsbGlzZWNvbmRzJyk7XG4gICAgZHVyYXRpb24gPSBEVE1GLkMuTUFYX0RVUkFUSU9OO1xuICB9IGVsc2Uge1xuICAgIGR1cmF0aW9uID0gTWF0aC5hYnMoZHVyYXRpb24pO1xuICB9XG4gIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcblxuICAvLyBDaGVjayBpbnRlclRvbmVHYXBcbiAgaWYgKGludGVyVG9uZUdhcCAmJiAhU0lQLlV0aWxzLmlzRGVjaW1hbChpbnRlclRvbmVHYXApKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBpbnRlclRvbmVHYXA6ICcrIGludGVyVG9uZUdhcCk7XG4gIH0gZWxzZSBpZiAoIWludGVyVG9uZUdhcCkge1xuICAgIGludGVyVG9uZUdhcCA9IERUTUYuQy5ERUZBVUxUX0lOVEVSX1RPTkVfR0FQO1xuICB9IGVsc2UgaWYgKGludGVyVG9uZUdhcCA8IERUTUYuQy5NSU5fSU5URVJfVE9ORV9HQVApIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdcImludGVyVG9uZUdhcFwiIHZhbHVlIGlzIGxvd2VyIHRoYW4gdGhlIG1pbmltdW0gYWxsb3dlZCwgc2V0dGluZyBpdCB0byAnKyBEVE1GLkMuTUlOX0lOVEVSX1RPTkVfR0FQICsnIG1pbGxpc2Vjb25kcycpO1xuICAgIGludGVyVG9uZUdhcCA9IERUTUYuQy5NSU5fSU5URVJfVE9ORV9HQVA7XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJUb25lR2FwID0gTWF0aC5hYnMoaW50ZXJUb25lR2FwKTtcbiAgfVxuICB0aGlzLmludGVyVG9uZUdhcCA9IGludGVyVG9uZUdhcDtcbn07XG5EVE1GLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG5cbkRUTUYucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBleHRyYUhlYWRlcnMsIGJvZHk7XG5cbiAgdGhpcy5kaXJlY3Rpb24gPSAnb3V0Z29pbmcnO1xuXG4gIC8vIENoZWNrIFJUQ1Nlc3Npb24gU3RhdHVzXG4gIGlmICh0aGlzLm93bmVyLnN0YXR1cyAhPT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfQ09ORklSTUVEICYmXG4gICAgdGhpcy5vd25lci5zdGF0dXMgIT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLm93bmVyLnN0YXR1cyk7XG4gIH1cblxuICAvLyBHZXQgRFRNRiBvcHRpb25zXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBleHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyA/IG9wdGlvbnMuZXh0cmFIZWFkZXJzLnNsaWNlKCkgOiBbXTtcblxuICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9kdG1mLXJlbGF5Jyk7XG5cbiAgYm9keSA9IFwiU2lnbmFsPSBcIiArIHRoaXMudG9uZSArIFwiXFxyXFxuXCI7XG4gIGJvZHkgKz0gXCJEdXJhdGlvbj0gXCIgKyB0aGlzLmR1cmF0aW9uO1xuXG4gIHRoaXMucmVxdWVzdCA9IHRoaXMub3duZXIuZGlhbG9nLnNlbmRSZXF1ZXN0KHRoaXMsIFNJUC5DLklORk8sIHtcbiAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICBib2R5OiBib2R5XG4gIH0pO1xuXG4gIHRoaXMub3duZXIuZW1pdCgnZHRtZicsIHRoaXMucmVxdWVzdCwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkRUTUYucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIHZhciBjYXVzZTtcblxuICBzd2l0Y2godHJ1ZSkge1xuICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgIC8vIElnbm9yZSBwcm92aXNpb25hbCByZXNwb25zZXMuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgIHRoaXMuZW1pdCgnc3VjY2VlZGVkJywge1xuICAgICAgICBvcmlnaW5hdG9yOiAncmVtb3RlJyxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNhdXNlID0gU0lQLlV0aWxzLnNpcEVycm9yQ2F1c2UocmVzcG9uc2Uuc3RhdHVzX2NvZGUpO1xuICAgICAgdGhpcy5lbWl0KCdmYWlsZWQnLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRFRNRi5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICB0aGlzLm93bmVyLm9uUmVxdWVzdFRpbWVvdXQoKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRFRNRi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgdGhpcy5vd25lci5vblRyYW5zcG9ydEVycm9yKCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkRUTUYucHJvdG90eXBlLm9uRGlhbG9nRXJyb3IgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuRElBTE9HX0VSUk9SKTtcbiAgdGhpcy5vd25lci5vbkRpYWxvZ0Vycm9yKHJlc3BvbnNlKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRFRNRi5wcm90b3R5cGUuaW5pdF9pbmNvbWluZyA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgdGhpcy5kaXJlY3Rpb24gPSAnaW5jb21pbmcnO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuXG4gIHJlcXVlc3QucmVwbHkoMjAwKTtcblxuICBpZiAoIXRoaXMudG9uZSB8fCAhdGhpcy5kdXJhdGlvbikge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ2ludmFsaWQgSU5GTyBEVE1GIHJlY2VpdmVkLCBkaXNjYXJkZWQnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm93bmVyLmVtaXQoJ2R0bWYnLCByZXF1ZXN0LCB0aGlzKTtcbiAgfVxufTtcblxuRFRNRi5DID0gQztcbnJldHVybiBEVE1GO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvU2Vzc2lvbi9EVE1GLmpzXG4gKiogbW9kdWxlIGlkID0gMjM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBTdWJzY3JpYmVyIChTSVAtU3BlY2lmaWMgRXZlbnQgTm90aWZpY2F0aW9ucyBSRkM2NjY1KVxuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGEgU0lQIFN1YnNjcmlwdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG5TSVAuU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHVhLCB0YXJnZXQsIGV2ZW50LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgdGhpcy5pZCA9IG51bGw7XG4gIHRoaXMuc3RhdGUgPSAnaW5pdCc7XG5cbiAgaWYgKCFldmVudCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V2ZW50IG5lY2Vzc2FyeSB0byBjcmVhdGUgYSBzdWJzY3JpcHRpb24uJyk7XG4gIH0gZWxzZSB7XG4gICAgLy9UT0RPOiBjaGVjayBmb3IgdmFsaWQgZXZlbnRzIGhlcmUgcHJvYmFibHkgbWFrZSBhIGxpc3QgaW4gU0lQLkM7IG9yIGxlYXZlIGl0IHVwIHRvIGFwcCB0byBjaGVjaz9cbiAgICAvL1RoZSBjaGVjayBtYXkgbmVlZCB0by9zaG91bGQgcHJvYmFibHkgb2NjdXIgb24gdGhlIG90aGVyIHNpZGUsXG4gICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICB9XG5cbiAgaWYodHlwZW9mIG9wdGlvbnMuZXhwaXJlcyAhPT0gJ251bWJlcicpe1xuICAgIHVhLmxvZ2dlci53YXJuKCdleHBpcmVzIG11c3QgYmUgYSBudW1iZXIuIFVzaW5nIGRlZmF1bHQgb2YgMzYwMC4nKTtcbiAgICB0aGlzLmV4cGlyZXMgPSAzNjAwO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXhwaXJlcyA9IG9wdGlvbnMuZXhwaXJlcztcbiAgfVxuXG4gIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goJ0V2ZW50OiAnICsgdGhpcy5ldmVudCk7XG4gIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goJ0V4cGlyZXM6ICcgKyB0aGlzLmV4cGlyZXMpO1xuXG4gIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICB0aGlzLmJvZHkgPSBvcHRpb25zLmJvZHk7XG4gIH1cblxuICB0aGlzLmNvbnRhY3QgPSB1YS5jb250YWN0LnRvU3RyaW5nKCk7XG5cbiAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJysgdGhpcy5jb250YWN0KTtcbiAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcrIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcblxuICBTSVAuVXRpbHMuYXVnbWVudCh0aGlzLCBTSVAuQ2xpZW50Q29udGV4dCwgW3VhLCBTSVAuQy5TVUJTQ1JJQkUsIHRhcmdldCwgb3B0aW9uc10pO1xuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuc3Vic2NyaXB0aW9uJyk7XG5cbiAgdGhpcy5kaWFsb2cgPSBudWxsO1xuICB0aGlzLnRpbWVycyA9IHtOOiBudWxsLCBzdWJfZHVyYXRpb246IG51bGx9O1xuICB0aGlzLmVycm9yQ29kZXMgID0gWzQwNCw0MDUsNDEwLDQxNiw0ODAsNDgxLDQ4Miw0ODMsNDg0LDQ4NSw0ODksNTAxLDYwNF07XG59O1xuXG5TSVAuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHtcbiAgc3Vic2NyaWJlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3ViID0gdGhpcztcblxuICAgICAvL3RoZXNlIHN0YXRlcyBwb2ludCB0byBhbiBleGlzdGluZyBzdWJzY3JpcHRpb24sIG5vIHN1YnNjcmliZSBpcyBuZWNlc3NhcnlcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2FjdGl2ZScpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnbm90aWZ5X3dhaXQnKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zdWJfZHVyYXRpb24pO1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLk4pO1xuICAgIHRoaXMudGltZXJzLk4gPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoc3ViLnRpbWVyX2ZpcmUuYmluZChzdWIpLCBTSVAuVGltZXJzLlRJTUVSX04pO1xuXG4gICAgdGhpcy5zZW5kKCk7XG5cbiAgICB0aGlzLnN0YXRlID0gJ25vdGlmeV93YWl0JztcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3Rlcm1pbmF0ZWQnIHx8IHRoaXMuc3RhdGUgPT09ICdwZW5kaW5nJyB8fCB0aGlzLnN0YXRlID09PSAnbm90aWZ5X3dhaXQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kaWFsb2cuc2VuZFJlcXVlc3QodGhpcywgU0lQLkMuU1VCU0NSSUJFLCB7XG4gICAgICBleHRyYUhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzLFxuICAgICAgYm9keTogdGhpcy5ib2R5XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHZhciBleHBpcmVzLCBzdWIgPSB0aGlzLFxuICAgICAgICBjYXVzZSA9IFNJUC5VdGlscy5nZXRSZWFzb25QaHJhc2UocmVzcG9uc2Uuc3RhdHVzX2NvZGUpO1xuXG4gICAgaWYgKCh0aGlzLnN0YXRlID09PSAnbm90aWZ5X3dhaXQnICYmIHJlc3BvbnNlLnN0YXR1c19jb2RlID49IDMwMCkgfHxcbiAgICAgICAgKHRoaXMuc3RhdGUgIT09ICdub3RpZnlfd2FpdCcgJiYgdGhpcy5lcnJvckNvZGVzLmluZGV4T2YocmVzcG9uc2Uuc3RhdHVzX2NvZGUpICE9PSAtMSkpIHtcbiAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBudWxsKTtcbiAgICB9IGVsc2UgaWYgKC9eMlswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSkpe1xuICAgICAgZXhwaXJlcyA9IHJlc3BvbnNlLmdldEhlYWRlcignRXhwaXJlcycpO1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuTik7XG5cbiAgICAgIGlmICh0aGlzLmNyZWF0ZUNvbmZpcm1lZERpYWxvZyhyZXNwb25zZSwnVUFDJykpIHtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuZGlhbG9nLmlkLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMudWEuc3Vic2NyaXB0aW9uc1t0aGlzLmlkXSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdCgnYWNjZXB0ZWQnLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAvLyBVUERBVEUgUk9VVEUgU0VUIFRPIEJFIEJBQ0tXQVJEUyBDT01QQVRJQkxFP1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhwaXJlcyAmJiBleHBpcmVzIDw9IHRoaXMuZXhwaXJlcykge1xuICAgICAgICAvLyBQcmVzZXJ2ZSBuZXcgZXhwaXJlcyB2YWx1ZSBmb3Igc3Vic2VxdWVudCByZXF1ZXN0c1xuICAgICAgICB0aGlzLmV4cGlyZXMgPSBleHBpcmVzO1xuICAgICAgICB0aGlzLnRpbWVycy5zdWJfZHVyYXRpb24gPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoc3ViLnJlZnJlc2guYmluZChzdWIpLCBleHBpcmVzICogOTAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZXhwaXJlcykge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0V4cGlyZXMgaGVhZGVyIG1pc3NpbmcgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gU1VCU0NSSUJFJyk7XG4gICAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLkVYUElSRVNfSEVBREVSX01JU1NJTkcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0V4cGlyZXMgaGVhZGVyIGluIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIFNVQlNDUklCRSB3aXRoIGEgaGlnaGVyIHZhbHVlIHRoYW4gdGhlIG9uZSBpbiB0aGUgcmVxdWVzdCcpO1xuICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5JTlZBTElEX0VYUElSRVNfSEVBREVSKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy9Vc2VkIHRvIGp1c3QgaWdub3JlIHByb3Zpc2lvbmFsIHJlc3BvbnNlczsgbm93IGlnbm9yZXMgZXZlcnl0aGluZyBleGNlcHQgZXJyb3JDb2RlcyBhbmQgMnh4XG4gIH0sXG5cbiAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXSwgc3ViID0gdGhpcztcblxuICAgIHRoaXMuc3RhdGUgPSAndGVybWluYXRlZCc7XG5cbiAgICBleHRyYUhlYWRlcnMucHVzaCgnRXZlbnQ6ICcgKyB0aGlzLmV2ZW50KTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnRXhwaXJlczogMCcpO1xuXG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcrIHRoaXMuY29udGFjdCk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG5cbiAgICAvL21ha2VzIHN1cmUgZXhwaXJlcyBpc24ndCBzZXQsIGFuZCBvdGhlciB0eXBpY2FsIHJlc3Vic2NyaWJlIGJlaGF2aW9yXG4gICAgdGhpcy5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbigpe307XG5cbiAgICB0aGlzLmRpYWxvZy5zZW5kUmVxdWVzdCh0aGlzLCB0aGlzLm1ldGhvZCwge1xuICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICBib2R5OiB0aGlzLmJvZHlcbiAgICB9KTtcblxuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbik7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuTik7XG4gICAgdGhpcy50aW1lcnMuTiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChzdWIudGltZXJfZmlyZS5iaW5kKHN1YiksIFNJUC5UaW1lcnMuVElNRVJfTik7XG4gIH0sXG5cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKi9cbiAgdGltZXJfZmlyZTogZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3Rlcm1pbmF0ZWQnKSB7XG4gICAgICB0aGlzLnRlcm1pbmF0ZURpYWxvZygpO1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuTik7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zdWJfZHVyYXRpb24pO1xuXG4gICAgICBkZWxldGUgdGhpcy51YS5zdWJzY3JpcHRpb25zW3RoaXMuaWRdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ3BlbmRpbmcnIHx8IHRoaXMuc3RhdGUgPT09ICdub3RpZnlfd2FpdCcpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICovXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLnN0YXRlICE9PSAnbm90aWZ5X3dhaXQnICYmIHRoaXMuc3RhdGUgIT09ICd0ZXJtaW5hdGVkJykge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBjcmVhdGVDb25maXJtZWREaWFsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICB2YXIgZGlhbG9nO1xuXG4gICAgdGhpcy50ZXJtaW5hdGVEaWFsb2coKTtcbiAgICBkaWFsb2cgPSBuZXcgU0lQLkRpYWxvZyh0aGlzLCBtZXNzYWdlLCB0eXBlKTtcblxuICAgIGlmKCFkaWFsb2cuZXJyb3IpIHtcbiAgICAgIHRoaXMuZGlhbG9nID0gZGlhbG9nO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIERpYWxvZyBub3QgY3JlYXRlZCBkdWUgdG8gYW4gZXJyb3JcbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKi9cbiAgdGVybWluYXRlRGlhbG9nOiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLmRpYWxvZykge1xuICAgICAgZGVsZXRlIHRoaXMudWEuc3Vic2NyaXB0aW9uc1t0aGlzLmlkXTtcbiAgICAgIHRoaXMuZGlhbG9nLnRlcm1pbmF0ZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuZGlhbG9nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICByZWNlaXZlUmVxdWVzdDogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHZhciBzdWJfc3RhdGUsIHN1YiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBzZXRFeHBpcmVzVGltZW91dCgpIHtcbiAgICAgIGlmIChzdWJfc3RhdGUuZXhwaXJlcykge1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dChzdWIudGltZXJzLnN1Yl9kdXJhdGlvbik7XG4gICAgICAgIHN1Yl9zdGF0ZS5leHBpcmVzID0gTWF0aC5taW4oc3ViLmV4cGlyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoc3ViX3N0YXRlLmV4cGlyZXMsIDApKTtcbiAgICAgICAgc3ViLnRpbWVycy5zdWJfZHVyYXRpb24gPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoc3ViLnJlZnJlc2guYmluZChzdWIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yl9zdGF0ZS5leHBpcmVzICogOTAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubWF0Y2hFdmVudChyZXF1ZXN0KSkgeyAvL2NoZWNrcyBldmVudCBhbmQgc3Vic2NyaXB0aW9uX3N0YXRlIGhlYWRlcnNcbiAgICAgIHJlcXVlc3QucmVwbHkoNDg5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdWJfc3RhdGUgPSByZXF1ZXN0LnBhcnNlSGVhZGVyKCdTdWJzY3JpcHRpb24tU3RhdGUnKTtcblxuICAgIHJlcXVlc3QucmVwbHkoMjAwLCBTSVAuQy5SRUFTT05fMjAwKTtcblxuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLk4pO1xuXG4gICAgdGhpcy5lbWl0KCdub3RpZnknLCB7cmVxdWVzdDogcmVxdWVzdH0pO1xuXG4gICAgLy8gaWYgd2UndmUgc2V0IHN0YXRlIHRvIHRlcm1pbmF0ZWQsIG5vIGZ1cnRoZXIgcHJvY2Vzc2luZyBzaG91bGQgdGFrZSBwbGFjZVxuICAgIC8vIGFuZCB3ZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIGNsZWFuaW5nIHVwIGFmdGVyIHRoZSBhcHByb3ByaWF0ZSBOT1RJRllcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3Rlcm1pbmF0ZWQnKSB7XG4gICAgICBpZiAoc3ViX3N0YXRlLnN0YXRlID09PSAndGVybWluYXRlZCcpIHtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVEaWFsb2coKTtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuTik7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbik7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMudWEuc3Vic2NyaXB0aW9uc1t0aGlzLmlkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHN1Yl9zdGF0ZS5zdGF0ZSkge1xuICAgICAgY2FzZSAnYWN0aXZlJzpcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdhY3RpdmUnO1xuICAgICAgICBzZXRFeHBpcmVzVGltZW91dCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ25vdGlmeV93YWl0Jykge1xuICAgICAgICAgIHNldEV4cGlyZXNUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdwZW5kaW5nJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXJtaW5hdGVkJzpcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uKTtcbiAgICAgICAgaWYgKHN1Yl9zdGF0ZS5yZWFzb24pIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3Rlcm1pbmF0aW5nIHN1YnNjcmlwdGlvbiB3aXRoIHJlYXNvbiAnKyBzdWJfc3RhdGUucmVhc29uKTtcbiAgICAgICAgICBzd2l0Y2ggKHN1Yl9zdGF0ZS5yZWFzb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2RlYWN0aXZhdGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3RpbWVvdXQnOlxuICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdwcm9iYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnZ2l2ZXVwJzpcbiAgICAgICAgICAgICAgaWYoc3ViX3N0YXRlLnBhcmFtcyAmJiBzdWJfc3RhdGUucGFyYW1zWydyZXRyeS1hZnRlciddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHN1Yi5zdWJzY3JpYmUuYmluZChzdWIpLCBzdWJfc3RhdGUucGFyYW1zWydyZXRyeS1hZnRlciddKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ25vcmVzb3VyY2UnOlxuICAgICAgICAgICAgY2FzZSAnaW52YXJpYW50JzpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIGZhaWxlZDogZnVuY3Rpb24ocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIHRoaXMuZW1pdCgnZmFpbGVkJywgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvbkRpYWxvZ0Vycm9yOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuRElBTE9HX0VSUk9SKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBtYXRjaEV2ZW50OiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgdmFyIGV2ZW50O1xuXG4gICAgLy8gQ2hlY2sgbWFuZGF0b3J5IGhlYWRlciBFdmVudFxuICAgIGlmICghcmVxdWVzdC5oYXNIZWFkZXIoJ0V2ZW50JykpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ21pc3NpbmcgRXZlbnQgaGVhZGVyJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIENoZWNrIG1hbmRhdG9yeSBoZWFkZXIgU3Vic2NyaXB0aW9uLVN0YXRlXG4gICAgaWYgKCFyZXF1ZXN0Lmhhc0hlYWRlcignU3Vic2NyaXB0aW9uLVN0YXRlJykpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ21pc3NpbmcgU3Vic2NyaXB0aW9uLVN0YXRlIGhlYWRlcicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGV2ZW50IGluIE5PVElGWSBtYXRjaGVzIHRoZSBldmVudCBpbiBTVUJTQ1JJQkVcbiAgICBldmVudCA9IHJlcXVlc3QucGFyc2VIZWFkZXIoJ2V2ZW50JykuZXZlbnQ7XG5cbiAgICBpZiAodGhpcy5ldmVudCAhPT0gZXZlbnQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2V2ZW50IG1hdGNoIGZhaWxlZCcpO1xuICAgICAgcmVxdWVzdC5yZXBseSg0ODEsICdFdmVudCBNYXRjaCBGYWlsZWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvU3Vic2NyaXB0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBXZWJSVENcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVAsIGVudmlyb25tZW50KSB7XG52YXIgV2ViUlRDO1xuXG5XZWJSVEMgPSB7fTtcblxuV2ViUlRDLk1lZGlhSGFuZGxlciA9IHJlcXVpcmUoJy4vV2ViUlRDL01lZGlhSGFuZGxlcicpKFNJUCk7XG5XZWJSVEMuTWVkaWFTdHJlYW1NYW5hZ2VyID0gcmVxdWlyZSgnLi9XZWJSVEMvTWVkaWFTdHJlYW1NYW5hZ2VyJykoU0lQLCBlbnZpcm9ubWVudCk7XG5cbnZhciBfaXNTdXBwb3J0ZWQ7XG5cbldlYlJUQy5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1N1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIF9pc1N1cHBvcnRlZDtcbiAgfVxuXG4gIFdlYlJUQy5NZWRpYVN0cmVhbSA9IGVudmlyb25tZW50Lk1lZGlhU3RyZWFtO1xuICBXZWJSVEMuZ2V0VXNlck1lZGlhID0gZW52aXJvbm1lbnQuZ2V0VXNlck1lZGlhO1xuICBXZWJSVEMuUlRDUGVlckNvbm5lY3Rpb24gPSBlbnZpcm9ubWVudC5SVENQZWVyQ29ubmVjdGlvbjtcbiAgV2ViUlRDLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IGVudmlyb25tZW50LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbjtcblxuICBpZiAoV2ViUlRDLlJUQ1BlZXJDb25uZWN0aW9uICYmIFdlYlJUQy5SVENTZXNzaW9uRGVzY3JpcHRpb24pIHtcbiAgICBpZiAoV2ViUlRDLmdldFVzZXJNZWRpYSkge1xuICAgICAgV2ViUlRDLmdldFVzZXJNZWRpYSA9IFNJUC5VdGlscy5wcm9taXNpZnkoZW52aXJvbm1lbnQsICdnZXRVc2VyTWVkaWEnKTtcbiAgICB9XG4gICAgX2lzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBfaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gX2lzU3VwcG9ydGVkO1xufTtcblxucmV0dXJuIFdlYlJUQztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1dlYlJUQy5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWVkaWFIYW5kbGVyXG4gKi9cblxuLyogTWVkaWFIYW5kbGVyXG4gKiBAY2xhc3MgUGVlckNvbm5lY3Rpb24gaGVscGVyIENsYXNzLlxuICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTSVAuV2ViUlRDLk1lZGlhU3RyZWFtTWFuYWdlcn0gW29wdGlvbnMubWVkaWFTdHJlYW1NYW5hZ2VyXVxuICogICAgICAgIFRoZSBNZWRpYVN0cmVhbU1hbmFnZXIgdG8gYWNxdWlyZS9yZWxlYXNlIHN0cmVhbXMgZnJvbS90by5cbiAqICAgICAgICBJZiBub3QgcHJvdmlkZWQsIGEgZGVmYXVsdCBNZWRpYVN0cmVhbU1hbmFnZXIgd2lsbCBiZSB1c2VkLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblxudmFyIE1lZGlhSGFuZGxlciA9IGZ1bmN0aW9uKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5sb2dnZXIgPSBzZXNzaW9uLnVhLmdldExvZ2dlcignc2lwLmludml0ZWNvbnRleHQubWVkaWFoYW5kbGVyJywgc2Vzc2lvbi5pZCk7XG4gIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gIHRoaXMubG9jYWxNZWRpYSA9IG51bGw7XG4gIHRoaXMucmVhZHkgPSB0cnVlO1xuICB0aGlzLm1lZGlhU3RyZWFtTWFuYWdlciA9IG9wdGlvbnMubWVkaWFTdHJlYW1NYW5hZ2VyIHx8IG5ldyBTSVAuV2ViUlRDLk1lZGlhU3RyZWFtTWFuYWdlcih0aGlzLmxvZ2dlcik7XG4gIHRoaXMuYXVkaW9NdXRlZCA9IGZhbHNlO1xuICB0aGlzLnZpZGVvTXV0ZWQgPSBmYWxzZTtcblxuICAvLyBvbGQgaW5pdCgpIGZyb20gaGVyZSBvblxuICB2YXIgc2VydmVycyA9IHRoaXMucHJlcGFyZUljZVNlcnZlcnMob3B0aW9ucy5zdHVuU2VydmVycywgb3B0aW9ucy50dXJuU2VydmVycyk7XG4gIHRoaXMuUlRDQ29uc3RyYWludHMgPSBvcHRpb25zLlJUQ0NvbnN0cmFpbnRzIHx8IHt9O1xuXG4gIHRoaXMuaW5pdFBlZXJDb25uZWN0aW9uKHNlcnZlcnMsIHRoaXMuUlRDQ29uc3RyYWludHMpO1xuXG4gIGZ1bmN0aW9uIHNlbGZFbWl0KG1oLCBldmVudCkge1xuICAgIGlmIChtaC5tZWRpYVN0cmVhbU1hbmFnZXIub24pIHtcbiAgICAgIG1oLm1lZGlhU3RyZWFtTWFuYWdlci5vbihldmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBtaC5lbWl0LmFwcGx5KG1oLCBbZXZlbnRdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBzZWxmRW1pdCh0aGlzLCAndXNlck1lZGlhUmVxdWVzdCcpO1xuICBzZWxmRW1pdCh0aGlzLCAndXNlck1lZGlhJyk7XG4gIHNlbGZFbWl0KHRoaXMsICd1c2VyTWVkaWFGYWlsZWQnKTtcbn07XG5cbk1lZGlhSGFuZGxlci5kZWZhdWx0RmFjdG9yeSA9IGZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChzZXNzaW9uLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgTWVkaWFIYW5kbGVyKHNlc3Npb24sIG9wdGlvbnMpO1xufTtcbk1lZGlhSGFuZGxlci5kZWZhdWx0RmFjdG9yeS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFNJUC5XZWJSVEMuaXNTdXBwb3J0ZWQoKTtcbn07XG5cbk1lZGlhSGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5NZWRpYUhhbmRsZXIucHJvdG90eXBlLCB7XG4vLyBGdW5jdGlvbnMgdGhlIHNlc3Npb24gY2FuIHVzZVxuICBpc1JlYWR5OiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBpc1JlYWR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkeTtcbiAgfX0sXG5cbiAgY2xvc2U6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ2Nsb3NpbmcgUGVlckNvbm5lY3Rpb24nKTtcbiAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gW107XG4gICAgLy8gaGF2ZSB0byBjaGVjayBzaWduYWxpbmdTdGF0ZSBzaW5jZSB0aGlzLmNsb3NlKCkgZ2V0cyBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAgICAvLyBUT0RPIGZpZ3VyZSBvdXQgd2h5IHRoYXQgaGFwcGVuc1xuICAgIGlmKHRoaXMucGVlckNvbm5lY3Rpb24gJiYgdGhpcy5wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcblxuICAgICAgaWYodGhpcy5sb2NhbE1lZGlhKSB7XG4gICAgICAgIHRoaXMubWVkaWFTdHJlYW1NYW5hZ2VyLnJlbGVhc2UodGhpcy5sb2NhbE1lZGlhKTtcbiAgICAgIH1cbiAgICB9XG4gIH19LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NJUC5XZWJSVEMuTWVkaWFTdHJlYW0gfCAoZ2V0VXNlck1lZGlhIGNvbnN0cmFpbnRzKX0gW21lZGlhSGludF1cbiAgICogICAgICAgIHRoZSBNZWRpYVN0cmVhbSAob3IgdGhlIGNvbnN0cmFpbnRzIGRlc2NyaWJpbmcgaXQpIHRvIGJlIHVzZWQgZm9yIHRoZSBzZXNzaW9uXG4gICAqL1xuICBnZXREZXNjcmlwdGlvbjoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVzY3JpcHRpb24gKG1lZGlhSGludCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWNxdWlyZSA9IHNlbGYubWVkaWFTdHJlYW1NYW5hZ2VyLmFjcXVpcmU7XG4gICAgaWYgKGFjcXVpcmUubGVuZ3RoID4gMSkge1xuICAgICAgYWNxdWlyZSA9IFNJUC5VdGlscy5wcm9taXNpZnkodGhpcy5tZWRpYVN0cmVhbU1hbmFnZXIsICdhY3F1aXJlJywgdHJ1ZSk7XG4gICAgfVxuICAgIG1lZGlhSGludCA9IG1lZGlhSGludCB8fCB7fTtcbiAgICBpZiAobWVkaWFIaW50LmRhdGFDaGFubmVsID09PSB0cnVlKSB7XG4gICAgICBtZWRpYUhpbnQuZGF0YUNoYW5uZWwgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5tZWRpYUhpbnQgPSBtZWRpYUhpbnQ7XG5cbiAgICAvKlxuICAgICAqIDEuIGFjcXVpcmUgc3RyZWFtcyAoc2tpcCBpZiBNZWRpYVN0cmVhbXMgcGFzc2VkIGluKVxuICAgICAqIDIuIGFkZFN0cmVhbXNcbiAgICAgKiAzLiBjcmVhdGVPZmZlci9jcmVhdGVBbnN3ZXJcbiAgICAgKi9cblxuICAgIHZhciBzdHJlYW1Qcm9taXNlO1xuICAgIGlmIChzZWxmLmxvY2FsTWVkaWEpIHtcbiAgICAgIHNlbGYubG9nZ2VyLmxvZygnYWxyZWFkeSBoYXZlIGxvY2FsIG1lZGlhJyk7XG4gICAgICBzdHJlYW1Qcm9taXNlID0gU0lQLlV0aWxzLlByb21pc2UucmVzb2x2ZShzZWxmLmxvY2FsTWVkaWEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNlbGYubG9nZ2VyLmxvZygnYWNxdWlyaW5nIGxvY2FsIG1lZGlhJyk7XG4gICAgICBzdHJlYW1Qcm9taXNlID0gYWNxdWlyZS5jYWxsKHNlbGYubWVkaWFTdHJlYW1NYW5hZ2VyLCBtZWRpYUhpbnQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIGFjcXVpcmVTdWNjZWVkZWQoc3RyZWFtcykge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmxvZygnYWNxdWlyZWQgbG9jYWwgbWVkaWEgc3RyZWFtcycpO1xuICAgICAgICAgIHNlbGYubG9jYWxNZWRpYSA9IHN0cmVhbXM7XG4gICAgICAgICAgc2VsZi5zZXNzaW9uLmNvbm5lY3RpbmcoKTtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtcztcbiAgICAgICAgfSwgZnVuY3Rpb24gYWNxdWlyZUZhaWxlZChlcnIpIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcigndW5hYmxlIHRvIGFjcXVpcmUgc3RyZWFtcycpO1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgc2VsZi5zZXNzaW9uLmNvbm5lY3RpbmcoKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKHRoaXMuYWRkU3RyZWFtcy5iaW5kKHRoaXMpKVxuICAgICAgO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJlYW1Qcm9taXNlXG4gICAgICAudGhlbihmdW5jdGlvbiBzdHJlYW1BZGRpdGlvblN1Y2NlZWRlZCgpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzT2ZmZXIoJ3JlbW90ZScpKSB7XG4gICAgICAgICAgc2VsZi5wZWVyQ29ubmVjdGlvbi5vbmRhdGFjaGFubmVsID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgc2VsZi5kYXRhQ2hhbm5lbCA9IGV2dC5jaGFubmVsO1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdkYXRhQ2hhbm5lbCcsIHNlbGYuZGF0YUNoYW5uZWwpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWFIaW50LmRhdGFDaGFubmVsICYmXG4gICAgICAgICAgICAgICAgICAgc2VsZi5wZWVyQ29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbCkge1xuICAgICAgICAgIHNlbGYuZGF0YUNoYW5uZWwgPSBzZWxmLnBlZXJDb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKFxuICAgICAgICAgICAgJ3NpcGpzJyxcbiAgICAgICAgICAgIG1lZGlhSGludC5kYXRhQ2hhbm5lbFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdkYXRhQ2hhbm5lbCcsIHNlbGYuZGF0YUNoYW5uZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuY3JlYXRlT2ZmZXJPckFuc3dlcihzZWxmLlJUQ0NvbnN0cmFpbnRzKTtcbiAgICAgIH0pXG4gICAgO1xuICB9fSxcblxuICAvKipcbiAgKiBNZXNzYWdlIHJlY2VwdGlvbi5cbiAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBzZHBcbiAgKi9cbiAgc2V0RGVzY3JpcHRpb246IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHNldERlc2NyaXB0aW9uIChzZHApIHtcbiAgICB2YXIgcmF3RGVzY3JpcHRpb24gPSB7XG4gICAgICB0eXBlOiB0aGlzLmhhc09mZmVyKCdsb2NhbCcpID8gJ2Fuc3dlcicgOiAnb2ZmZXInLFxuICAgICAgc2RwOiBzZHBcbiAgICB9O1xuXG4gICAgdGhpcy5lbWl0KCdzZXREZXNjcmlwdGlvbicsIHJhd0Rlc2NyaXB0aW9uKTtcblxuICAgIHZhciBkZXNjcmlwdGlvbiA9IG5ldyBTSVAuV2ViUlRDLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbihyYXdEZXNjcmlwdGlvbik7XG4gICAgcmV0dXJuIFNJUC5VdGlscy5wcm9taXNpZnkodGhpcy5wZWVyQ29ubmVjdGlvbiwgJ3NldFJlbW90ZURlc2NyaXB0aW9uJykoZGVzY3JpcHRpb24pO1xuICB9fSxcblxuICAvKipcbiAgICogSWYgdGhlIFNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgTWVkaWFIYW5kbGVyIHdlcmUgdG8gYmUgcmVmZXJyZWQsXG4gICAqIHdoYXQgbWVkaWFIaW50IHNob3VsZCBiZSBwcm92aWRlZCB0byB0aGUgVUEncyBpbnZpdGUgbWV0aG9kP1xuICAgKi9cbiAgZ2V0UmVmZXJNZWRpYToge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVmZXJNZWRpYSAoKSB7XG4gICAgZnVuY3Rpb24gaGFzVHJhY2tzICh0cmFja0dldHRlciwgc3RyZWFtKSB7XG4gICAgICByZXR1cm4gc3RyZWFtW3RyYWNrR2V0dGVyXSgpLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYm90aEhhdmVUcmFja3MgKHRyYWNrR2V0dGVyKSB7XG4gICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHJldHVybiB0aGlzLmdldExvY2FsU3RyZWFtcygpLnNvbWUoaGFzVHJhY2tzLmJpbmQobnVsbCwgdHJhY2tHZXR0ZXIpKSAmJlxuICAgICAgICAgICAgIHRoaXMuZ2V0UmVtb3RlU3RyZWFtcygpLnNvbWUoaGFzVHJhY2tzLmJpbmQobnVsbCwgdHJhY2tHZXR0ZXIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgYXVkaW86IGJvdGhIYXZlVHJhY2tzLmNhbGwodGhpcywgJ2dldEF1ZGlvVHJhY2tzJyksXG4gICAgICAgIHZpZGVvOiBib3RoSGF2ZVRyYWNrcy5jYWxsKHRoaXMsICdnZXRWaWRlb1RyYWNrcycpXG4gICAgICB9XG4gICAgfTtcbiAgfX0sXG5cbiAgdXBkYXRlSWNlU2VydmVyczoge3dyaXRlYWJsZTp0cnVlLCB2YWx1ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VydmVycyA9IHRoaXMucHJlcGFyZUljZVNlcnZlcnMob3B0aW9ucy5zdHVuU2VydmVycywgb3B0aW9ucy50dXJuU2VydmVycyk7XG4gICAgdGhpcy5SVENDb25zdHJhaW50cyA9IG9wdGlvbnMuUlRDQ29uc3RyYWludHMgfHwgdGhpcy5SVENDb25zdHJhaW50cztcblxuICAgIHRoaXMuaW5pdFBlZXJDb25uZWN0aW9uKHNlcnZlcnMsIHRoaXMuUlRDQ29uc3RyYWludHMpO1xuXG4gICAgLyogb25jZSB1cGRhdGVJY2UgaXMgaW1wbGVtZW50ZWQgY29ycmVjdGx5LCB0aGlzIGlzIGJldHRlciB0aGFuIGFib3ZlXG4gICAgLy9ubyBvcCBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhpc1xuICAgIGlmICghdGhpcy5wZWVyQ29ubmVjdGlvbi51cGRhdGVJY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLnVwZGF0ZUljZSh7J2ljZVNlcnZlcnMnOiBzZXJ2ZXJzfSwgdGhpcy5SVENDb25zdHJhaW50cyk7XG4gICAgKi9cbiAgfX0sXG5cbi8vIEZ1bmN0aW9ucyB0aGUgc2Vzc2lvbiBjYW4gdXNlLCBidXQgb25seSBiZWNhdXNlIGl0J3MgY29udmVuaWVudCBmb3IgdGhlIGFwcGxpY2F0aW9uXG4gIGlzTXV0ZWQ6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGlzTXV0ZWQgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhdWRpbzogdGhpcy5hdWRpb011dGVkLFxuICAgICAgdmlkZW86IHRoaXMudmlkZW9NdXRlZFxuICAgIH07XG4gIH19LFxuXG4gIG11dGU6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIG11dGUgKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5nZXRMb2NhbFN0cmVhbXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICBhdWRpbzogdGhpcy5nZXRMb2NhbFN0cmVhbXMoKVswXS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDAsXG4gICAgICB2aWRlbzogdGhpcy5nZXRMb2NhbFN0cmVhbXMoKVswXS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDBcbiAgICB9O1xuXG4gICAgdmFyIGF1ZGlvTXV0ZWQgPSBmYWxzZSxcbiAgICAgICAgdmlkZW9NdXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYXVkaW8gJiYgIXRoaXMuYXVkaW9NdXRlZCkge1xuICAgICAgYXVkaW9NdXRlZCA9IHRydWU7XG4gICAgICB0aGlzLmF1ZGlvTXV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy50b2dnbGVNdXRlQXVkaW8odHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudmlkZW8gJiYgIXRoaXMudmlkZW9NdXRlZCkge1xuICAgICAgdmlkZW9NdXRlZCA9IHRydWU7XG4gICAgICB0aGlzLnZpZGVvTXV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy50b2dnbGVNdXRlVmlkZW8odHJ1ZSk7XG4gICAgfVxuXG4gICAgLy9SRVZJU0lUXG4gICAgaWYgKGF1ZGlvTXV0ZWQgfHwgdmlkZW9NdXRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW86IGF1ZGlvTXV0ZWQsXG4gICAgICAgIHZpZGVvOiB2aWRlb011dGVkXG4gICAgICB9O1xuICAgICAgLyp0aGlzLnNlc3Npb24ub25tdXRlKHtcbiAgICAgICAgYXVkaW86IGF1ZGlvTXV0ZWQsXG4gICAgICAgIHZpZGVvOiB2aWRlb011dGVkXG4gICAgICB9KTsqL1xuICAgIH1cbiAgfX0sXG5cbiAgdW5tdXRlOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiB1bm11dGUgKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5nZXRMb2NhbFN0cmVhbXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICBhdWRpbzogdGhpcy5nZXRMb2NhbFN0cmVhbXMoKVswXS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDAsXG4gICAgICB2aWRlbzogdGhpcy5nZXRMb2NhbFN0cmVhbXMoKVswXS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDBcbiAgICB9O1xuXG4gICAgdmFyIGF1ZGlvVW5NdXRlZCA9IGZhbHNlLFxuICAgICAgICB2aWRlb1VuTXV0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmF1ZGlvICYmIHRoaXMuYXVkaW9NdXRlZCkge1xuICAgICAgYXVkaW9Vbk11dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuYXVkaW9NdXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy50b2dnbGVNdXRlQXVkaW8oZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnZpZGVvICYmIHRoaXMudmlkZW9NdXRlZCkge1xuICAgICAgdmlkZW9Vbk11dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudmlkZW9NdXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy50b2dnbGVNdXRlVmlkZW8oZmFsc2UpO1xuICAgIH1cblxuICAgIC8vUkVWSVNJVFxuICAgIGlmIChhdWRpb1VuTXV0ZWQgfHwgdmlkZW9Vbk11dGVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdWRpbzogYXVkaW9Vbk11dGVkLFxuICAgICAgICB2aWRlbzogdmlkZW9Vbk11dGVkXG4gICAgICB9O1xuICAgICAgLyp0aGlzLnNlc3Npb24ub251bm11dGUoe1xuICAgICAgICBhdWRpbzogYXVkaW9Vbk11dGVkLFxuICAgICAgICB2aWRlbzogdmlkZW9Vbk11dGVkXG4gICAgICB9KTsqL1xuICAgIH1cbiAgfX0sXG5cbiAgaG9sZDoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gaG9sZCAoKSB7XG4gICAgdGhpcy50b2dnbGVNdXRlQXVkaW8odHJ1ZSk7XG4gICAgdGhpcy50b2dnbGVNdXRlVmlkZW8odHJ1ZSk7XG4gIH19LFxuXG4gIHVuaG9sZDoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gdW5ob2xkICgpIHtcbiAgICBpZiAoIXRoaXMuYXVkaW9NdXRlZCkge1xuICAgICAgdGhpcy50b2dnbGVNdXRlQXVkaW8oZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy52aWRlb011dGVkKSB7XG4gICAgICB0aGlzLnRvZ2dsZU11dGVWaWRlbyhmYWxzZSk7XG4gICAgfVxuICB9fSxcblxuLy8gRnVuY3Rpb25zIHRoZSBhcHBsaWNhdGlvbiBjYW4gdXNlLCBidXQgbm90IHRoZSBzZXNzaW9uXG4gIGdldExvY2FsU3RyZWFtczoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zICgpIHtcbiAgICB2YXIgcGMgPSB0aGlzLnBlZXJDb25uZWN0aW9uO1xuICAgIGlmIChwYyAmJiBwYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ3BlZXJDb25uZWN0aW9uIGlzIGNsb3NlZCwgZ2V0TG9jYWxTdHJlYW1zIHJldHVybmluZyBbXScpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gKHBjLmdldExvY2FsU3RyZWFtcyAmJiBwYy5nZXRMb2NhbFN0cmVhbXMoKSkgfHxcbiAgICAgIHBjLmxvY2FsU3RyZWFtcyB8fCBbXTtcbiAgfX0sXG5cbiAgZ2V0UmVtb3RlU3RyZWFtczoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVtb3RlU3RyZWFtcyAoKSB7XG4gICAgdmFyIHBjID0gdGhpcy5wZWVyQ29ubmVjdGlvbjtcbiAgICBpZiAocGMgJiYgcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdwZWVyQ29ubmVjdGlvbiBpcyBjbG9zZWQsIGdldFJlbW90ZVN0cmVhbXMgcmV0dXJuaW5nIHRoaXMuX3JlbW90ZVN0cmVhbXMnKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVTdHJlYW1zO1xuICAgIH1cbiAgICByZXR1cm4ocGMuZ2V0UmVtb3RlU3RyZWFtcyAmJiBwYy5nZXRSZW1vdGVTdHJlYW1zKCkpIHx8XG4gICAgICBwYy5yZW1vdGVTdHJlYW1zIHx8IFtdO1xuICB9fSxcblxuICByZW5kZXI6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlciAocmVuZGVySGludCkge1xuICAgIHJlbmRlckhpbnQgPSByZW5kZXJIaW50IHx8ICh0aGlzLm1lZGlhSGludCAmJiB0aGlzLm1lZGlhSGludC5yZW5kZXIpO1xuICAgIGlmICghcmVuZGVySGludCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgc3RyZWFtR2V0dGVycyA9IHtcbiAgICAgIGxvY2FsOiAnZ2V0TG9jYWxTdHJlYW1zJyxcbiAgICAgIHJlbW90ZTogJ2dldFJlbW90ZVN0cmVhbXMnXG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhzdHJlYW1HZXR0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChsb2MpIHtcbiAgICAgIHZhciBzdHJlYW1HZXR0ZXIgPSBzdHJlYW1HZXR0ZXJzW2xvY107XG4gICAgICB2YXIgc3RyZWFtcyA9IHRoaXNbc3RyZWFtR2V0dGVyXSgpO1xuICAgICAgU0lQLldlYlJUQy5NZWRpYVN0cmVhbU1hbmFnZXIucmVuZGVyKHN0cmVhbXMsIHJlbmRlckhpbnRbbG9jXSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfX0sXG5cbi8vIEludGVybmFsIGZ1bmN0aW9uc1xuICBoYXNPZmZlcjoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gaGFzT2ZmZXIgKHdoZXJlKSB7XG4gICAgdmFyIG9mZmVyU3RhdGUgPSAnaGF2ZS0nICsgd2hlcmUgKyAnLW9mZmVyJztcbiAgICByZXR1cm4gdGhpcy5wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gb2ZmZXJTdGF0ZTtcbiAgICAvLyBUT0RPIGNvbnNpZGVyIHNpZ25hbGluZ1N0YXRlcyB3aXRoICdwcmFuc3dlcic/XG4gIH19LFxuXG4gIHByZXBhcmVJY2VTZXJ2ZXJzOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlSWNlU2VydmVycyAoc3R1blNlcnZlcnMsIHR1cm5TZXJ2ZXJzKSB7XG4gICAgdmFyIHNlcnZlcnMgPSBbXSxcbiAgICAgIGNvbmZpZyA9IHRoaXMuc2Vzc2lvbi51YS5jb25maWd1cmF0aW9uO1xuXG4gICAgc3R1blNlcnZlcnMgPSBzdHVuU2VydmVycyB8fCBjb25maWcuc3R1blNlcnZlcnM7XG4gICAgdHVyblNlcnZlcnMgPSB0dXJuU2VydmVycyB8fCBjb25maWcudHVyblNlcnZlcnM7XG5cbiAgICBbXS5jb25jYXQoc3R1blNlcnZlcnMpLmZvckVhY2goZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgc2VydmVycy5wdXNoKHsndXJscyc6IHNlcnZlcn0pO1xuICAgIH0pO1xuXG4gICAgW10uY29uY2F0KHR1cm5TZXJ2ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICAgIHNlcnZlcnMucHVzaCh7XG4gICAgICAgICd1cmxzJzogc2VydmVyLnVybHMsXG4gICAgICAgICd1c2VybmFtZSc6IHNlcnZlci51c2VybmFtZSxcbiAgICAgICAgJ2NyZWRlbnRpYWwnOiBzZXJ2ZXIucGFzc3dvcmRcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlcnZlcnM7XG4gIH19LFxuXG4gIGluaXRQZWVyQ29ubmVjdGlvbjoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gaW5pdFBlZXJDb25uZWN0aW9uKHNlcnZlcnMsIFJUQ0NvbnN0cmFpbnRzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgY29uZmlnID0gdGhpcy5zZXNzaW9uLnVhLmNvbmZpZ3VyYXRpb247XG5cbiAgICB0aGlzLm9uSWNlQ29tcGxldGVkID0gU0lQLlV0aWxzLmRlZmVyKCk7XG4gICAgdGhpcy5vbkljZUNvbXBsZXRlZC5wcm9taXNlLnRoZW4oZnVuY3Rpb24ocGMpIHtcbiAgICAgIHNlbGYuZW1pdCgnaWNlR2F0aGVyaW5nQ29tcGxldGUnLCBwYyk7XG4gICAgICBpZiAoc2VsZi5pY2VDaGVja2luZ1RpbWVyKSB7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHNlbGYuaWNlQ2hlY2tpbmdUaW1lcik7XG4gICAgICAgIHNlbGYuaWNlQ2hlY2tpbmdUaW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5wZWVyQ29ubmVjdGlvbikge1xuICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24gPSBuZXcgU0lQLldlYlJUQy5SVENQZWVyQ29ubmVjdGlvbih7J2ljZVNlcnZlcnMnOiBzZXJ2ZXJzfSwgUlRDQ29uc3RyYWludHMpO1xuXG4gICAgLy8gRmlyZWZveCAoMzUuMC4xKSBzb21ldGltZXMgdGhyb3dzIG9uIGNhbGxzIHRvIHBlZXJDb25uZWN0aW9uLmdldFJlbW90ZVN0cmVhbXNcbiAgICAvLyBldmVuIGlmIHBlZXJDb25uZWN0aW9uLm9uYWRkc3RyZWFtIHdhcyBqdXN0IGNhbGxlZC4gSW4gb3JkZXIgdG8gbWFrZVxuICAgIC8vIE1lZGlhSGFuZGxlci5wcm90b3R5cGUuZ2V0UmVtb3RlU3RyZWFtcyB3b3JrLCBrZWVwIHRyYWNrIG9mIHRoZW0gbWFudWFsbHlcbiAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gW107XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uYWRkc3RyZWFtID0gZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5sb2dnZXIubG9nKCdzdHJlYW0gYWRkZWQ6ICcrIGUuc3RyZWFtLmlkKTtcbiAgICAgIHNlbGYuX3JlbW90ZVN0cmVhbXMucHVzaChlLnN0cmVhbSk7XG4gICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgc2VsZi5lbWl0KCdhZGRTdHJlYW0nLCBlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbnJlbW92ZXN0cmVhbSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHNlbGYubG9nZ2VyLmxvZygnc3RyZWFtIHJlbW92ZWQ6ICcrIGUuc3RyZWFtLmlkKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdGFydEljZUNoZWNraW5nVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNlbGYuaWNlQ2hlY2tpbmdUaW1lcikge1xuICAgICAgICBzZWxmLmljZUNoZWNraW5nVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIubG9nKCdSVENJY2VDaGVja2luZyBUaW1lb3V0IFRyaWdnZXJlZCBhZnRlciAnK2NvbmZpZy5pY2VDaGVja2luZ1RpbWVvdXQrJyBtaWxsaXNlY29uZHMnKTtcbiAgICAgICAgICBzZWxmLm9uSWNlQ29tcGxldGVkLnJlc29sdmUodGhpcyk7XG4gICAgICAgIH0uYmluZCh0aGlzLnBlZXJDb25uZWN0aW9uKSwgY29uZmlnLmljZUNoZWNraW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICBzZWxmLmVtaXQoJ2ljZUNhbmRpZGF0ZScsIGUpO1xuICAgICAgaWYgKGUuY2FuZGlkYXRlKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLmxvZygnSUNFIGNhbmRpZGF0ZSByZWNlaXZlZDogJysgKGUuY2FuZGlkYXRlLmNhbmRpZGF0ZSA9PT0gbnVsbCA/IG51bGwgOiBlLmNhbmRpZGF0ZS5jYW5kaWRhdGUudHJpbSgpKSk7XG4gICAgICAgIHNlbGYuc3RhcnRJY2VDaGVja2luZ1RpbWVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLm9uSWNlQ29tcGxldGVkLnJlc29sdmUodGhpcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYubG9nZ2VyLmxvZygnUlRDSWNlR2F0aGVyaW5nU3RhdGUgY2hhbmdlZDogJyArIHRoaXMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgaWYgKHRoaXMuaWNlR2F0aGVyaW5nU3RhdGUgPT09ICdnYXRoZXJpbmcnKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnaWNlR2F0aGVyaW5nJywgdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pY2VHYXRoZXJpbmdTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBzZWxmLm9uSWNlQ29tcGxldGVkLnJlc29sdmUodGhpcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHsgIC8vbmVlZCBlIGZvciBjb21tZW50ZWQgb3V0IGNhc2VcbiAgICAgIHZhciBzdGF0ZUV2ZW50O1xuXG4gICAgICBpZiAodGhpcy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjaGVja2luZycpIHtcbiAgICAgICAgc2VsZi5zdGFydEljZUNoZWNraW5nVGltZXIoKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgY2FzZSAnbmV3JzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjaGVja2luZyc6XG4gICAgICAgIHN0YXRlRXZlbnQgPSAnaWNlQ29ubmVjdGlvbkNoZWNraW5nJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb25Db25uZWN0ZWQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgIHN0YXRlRXZlbnQgPSAnaWNlQ29ubmVjdGlvbkNvbXBsZXRlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uRmFpbGVkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0ZWQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Nsb3NlZCc6XG4gICAgICAgIHN0YXRlRXZlbnQgPSAnaWNlQ29ubmVjdGlvbkNsb3NlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2VsZi5sb2dnZXIud2FybignVW5rbm93biBpY2VDb25uZWN0aW9uIHN0YXRlOicsIHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZi5lbWl0KHN0YXRlRXZlbnQsIHRoaXMpO1xuXG4gICAgICAvL0JyaWEgc3RhdGUgY2hhbmdlcyBhcmUgYWx3YXlzIGNvbm5lY3RlZCAtPiBkaXNjb25uZWN0ZWQgLT4gY29ubmVjdGVkIG9uIGFjY2VwdCwgc28gc2Vzc2lvbiBnZXRzIHRlcm1pbmF0ZWRcbiAgICAgIC8vbm9ybWFsIGNhbGxzIHN3aXRjaCBmcm9tIGZhaWxlZCB0byBjb25uZWN0ZWQgaW4gc29tZSBjYXNlcywgc28gY2hlY2tpbmcgZm9yIGZhaWxlZCBhbmQgdGVybWluYXRlZFxuICAgICAgLyppZiAodGhpcy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgIHNlbGYuc2Vzc2lvbi50ZXJtaW5hdGUoe1xuICAgICAgICBjYXVzZTogU0lQLkMuY2F1c2VzLlJUUF9USU1FT1VULFxuICAgICAgICBzdGF0dXNfY29kZTogMjAwLFxuICAgICAgICByZWFzb25fcGhyYXNlOiBTSVAuQy5jYXVzZXMuUlRQX1RJTUVPVVRcbiAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChlLmN1cnJlbnRUYXJnZXQuaWNlR2F0aGVyaW5nU3RhdGUgPT09ICdjb21wbGV0ZScgJiYgdGhpcy5pY2VDb25uZWN0aW9uU3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICBzZWxmLm9uSWNlQ29tcGxldGVkKHRoaXMpO1xuICAgICAgfSovXG4gICAgfTtcblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5sb2dnZXIubG9nKCdQZWVyQ29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkIHRvIFwiJysgdGhpcy5yZWFkeVN0YXRlICsnXCInKTtcbiAgICB9O1xuICB9fSxcblxuICBjcmVhdGVPZmZlck9yQW5zd2VyOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVPZmZlck9yQW5zd2VyIChjb25zdHJhaW50cykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbWV0aG9kTmFtZTtcbiAgICB2YXIgcGMgPSBzZWxmLnBlZXJDb25uZWN0aW9uO1xuXG4gICAgc2VsZi5yZWFkeSA9IGZhbHNlO1xuICAgIG1ldGhvZE5hbWUgPSBzZWxmLmhhc09mZmVyKCdyZW1vdGUnKSA/ICdjcmVhdGVBbnN3ZXInIDogJ2NyZWF0ZU9mZmVyJztcblxuICAgIHJldHVybiBTSVAuVXRpbHMucHJvbWlzaWZ5KHBjLCBtZXRob2ROYW1lLCB0cnVlKShjb25zdHJhaW50cylcbiAgICAgIC50aGVuKFNJUC5VdGlscy5wcm9taXNpZnkocGMsICdzZXRMb2NhbERlc2NyaXB0aW9uJykpXG4gICAgICAudGhlbihmdW5jdGlvbiBvblNldExvY2FsRGVzY3JpcHRpb25TdWNjZXNzKCkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBTSVAuVXRpbHMuZGVmZXIoKTtcbiAgICAgICAgaWYgKHBjLmljZUdhdGhlcmluZ1N0YXRlID09PSAnY29tcGxldGUnICYmIChwYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnIHx8IHBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpKSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYub25JY2VDb21wbGV0ZWQucHJvbWlzZS50aGVuKGRlZmVycmVkLnJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uIHJlYWR5U3VjY2VzcyAoKSB7XG4gICAgICAgIHZhciBzZHAgPSBwYy5sb2NhbERlc2NyaXB0aW9uLnNkcDtcblxuICAgICAgICBzZHAgPSBTSVAuSGFja3MuQ2hyb21lLm5lZWRzRXhwbGljaXRseUluYWN0aXZlU0RQKHNkcCk7XG4gICAgICAgIHNkcCA9IFNJUC5IYWNrcy5BbGxCcm93c2Vycy51bm1hc2tEdGxzKHNkcCk7XG5cbiAgICAgICAgdmFyIHNkcFdyYXBwZXIgPSB7XG4gICAgICAgICAgdHlwZTogbWV0aG9kTmFtZSA9PT0gJ2NyZWF0ZU9mZmVyJyA/ICdvZmZlcicgOiAnYW5zd2VyJyxcbiAgICAgICAgICBzZHA6IHNkcFxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuZW1pdCgnZ2V0RGVzY3JpcHRpb24nLCBzZHBXcmFwcGVyKTtcblxuICAgICAgICBzZWxmLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHNkcFdyYXBwZXIuc2RwO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbiBtZXRob2RGYWlsZWQgKGUpIHtcbiAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoZSk7XG4gICAgICAgIHNlbGYucmVhZHkgPSB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuR2V0RGVzY3JpcHRpb25FcnJvcihlKTtcbiAgICAgIH0pXG4gICAgO1xuICB9fSxcblxuICBhZGRTdHJlYW1zOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBhZGRTdHJlYW1zIChzdHJlYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0cmVhbXMgPSBbXS5jb25jYXQoc3RyZWFtcyk7XG4gICAgICBzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmFkZFN0cmVhbShzdHJlYW0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignZXJyb3IgYWRkaW5nIHN0cmVhbScpO1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgICByZXR1cm4gU0lQLlV0aWxzLlByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cblxuICAgIHJldHVybiBTSVAuVXRpbHMuUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH19LFxuXG4gIHRvZ2dsZU11dGVIZWxwZXI6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZU11dGVIZWxwZXIgKHRyYWNrR2V0dGVyLCBtdXRlKSB7XG4gICAgdGhpcy5nZXRMb2NhbFN0cmVhbXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIHN0cmVhbVt0cmFja0dldHRlcl0oKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB0cmFjay5lbmFibGVkID0gIW11dGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfX0sXG5cbiAgdG9nZ2xlTXV0ZUF1ZGlvOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNdXRlQXVkaW8gKG11dGUpIHtcbiAgICB0aGlzLnRvZ2dsZU11dGVIZWxwZXIoJ2dldEF1ZGlvVHJhY2tzJywgbXV0ZSk7XG4gIH19LFxuXG4gIHRvZ2dsZU11dGVWaWRlbzoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlTXV0ZVZpZGVvIChtdXRlKSB7XG4gICAgdGhpcy50b2dnbGVNdXRlSGVscGVyKCdnZXRWaWRlb1RyYWNrcycsIG11dGUpO1xuICB9fVxufSk7XG5cbi8vIFJldHVybiBzaW5jZSBpdCB3aWxsIGJlIGFzc2lnbmVkIHRvIGEgdmFyaWFibGUuXG5yZXR1cm4gTWVkaWFIYW5kbGVyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvV2ViUlRDL01lZGlhSGFuZGxlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWVkaWFTdHJlYW1NYW5hZ2VyXG4gKi9cblxuLyogTWVkaWFTdHJlYW1NYW5hZ2VyXG4gKiBAY2xhc3MgTWFuYWdlcyB0aGUgYWNxdWlzaXRpb24gYW5kIHJlbGVhc2Ugb2YgTWVkaWFTdHJlYW1zLlxuICogQHBhcmFtIHttZWRpYUhpbnR9IFtkZWZhdWx0TWVkaWFIaW50XSBUaGUgbWVkaWFIaW50IHRvIHVzZSBpZiBub25lIGlzIHByb3ZpZGVkIHRvIGFjcXVpcmUoKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVAsIGVudmlyb25tZW50KSB7XG5cbi8vIERlZmF1bHQgTWVkaWFTdHJlYW1NYW5hZ2VyIHByb3ZpZGVzIHNpbmdsZS11c2Ugc3RyZWFtcyBjcmVhdGVkIHdpdGggZ2V0VXNlck1lZGlhXG52YXIgTWVkaWFTdHJlYW1NYW5hZ2VyID0gZnVuY3Rpb24gTWVkaWFTdHJlYW1NYW5hZ2VyIChsb2dnZXIsIGRlZmF1bHRNZWRpYUhpbnQpIHtcbiAgaWYgKCFTSVAuV2ViUlRDLmlzU3VwcG9ydGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuTm90U3VwcG9ydGVkRXJyb3IoJ01lZGlhIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIHRoaXMubWVkaWFIaW50ID0gZGVmYXVsdE1lZGlhSGludCB8fCB7XG4gICAgY29uc3RyYWludHM6IHthdWRpbzogdHJ1ZSwgdmlkZW86IHRydWV9XG4gIH07XG5cbiAgLy8gbWFwIG9mIHN0cmVhbXMgdG8gYWNxdWlzaXRpb24gbWFubmVyOlxuICAvLyB0cnVlIC0+IHBhc3NlZCBpbiBhcyBtZWRpYUhpbnQuc3RyZWFtXG4gIC8vIGZhbHNlIC0+IGdldFVzZXJNZWRpYVxuICB0aGlzLmFjcXVpc2l0aW9ucyA9IHt9O1xufTtcbk1lZGlhU3RyZWFtTWFuYWdlci5zdHJlYW1JZCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmNvbmNhdChzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKSlcbiAgICAubWFwKGZ1bmN0aW9uIHRyYWNrSWQgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2suaWQ7XG4gICAgfSlcbiAgICAuam9pbignJyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7KEFycmF5IG9mKSBNZWRpYVN0cmVhbX0gc3RyZWFtcyAtIFRoZSBzdHJlYW1zIHRvIHJlbmRlclxuICpcbiAqIEBwYXJhbSB7KEFycmF5IG9mKSBIVE1MTWVkaWFFbGVtZW50fSBlbGVtZW50c1xuICogICAgICAgIC0gVGhlIDxhdWRpbz4vPHZpZGVvPiBlbGVtZW50KHMpIHRoYXQgc2hvdWxkIHJlbmRlciB0aGUgc3RyZWFtc1xuICpcbiAqIEVhY2ggc3RyZWFtIGluIHN0cmVhbXMgcmVuZGVycyB0byB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50IGluIGVsZW1lbnRzLFxuICogd3JhcHBpbmcgYXJvdW5kIGVsZW1lbnRzIGlmIG5lZWRlZC5cbiAqL1xuTWVkaWFTdHJlYW1NYW5hZ2VyLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoc3RyZWFtcywgZWxlbWVudHMpIHtcbiAgaWYgKCFlbGVtZW50cykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50cykgJiYgIWVsZW1lbnRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VsZW1lbnRzIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBhdHRhY2hNZWRpYVN0cmVhbShlbGVtZW50LCBzdHJlYW0pIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQuc3JjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZW52aXJvbm1lbnQucmV2b2tlT2JqZWN0VVJMKGVsZW1lbnQuc3JjKTtcbiAgICAgIGVsZW1lbnQuc3JjID0gZW52aXJvbm1lbnQuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKGVsZW1lbnQuc3JjT2JqZWN0IHx8IGVsZW1lbnQubW96U3JjT2JqZWN0KSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gZWxlbWVudC5tb3pTcmNPYmplY3QgPSBzdHJlYW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZU1lZGlhUGxheWluZyAobWVkaWFFbGVtZW50KSB7XG4gICAgdmFyIGludGVydmFsID0gMTAwO1xuICAgIG1lZGlhRWxlbWVudC5lbnN1cmVQbGF5aW5nSW50ZXJ2YWxJZCA9IFNJUC5UaW1lcnMuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1lZGlhRWxlbWVudC5wYXVzZWQpIHtcbiAgICAgICAgbWVkaWFFbGVtZW50LnBsYXkoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFySW50ZXJ2YWwobWVkaWFFbGVtZW50LmVuc3VyZVBsYXlpbmdJbnRlcnZhbElkKTtcbiAgICAgIH1cbiAgICB9LCBpbnRlcnZhbCk7XG4gIH1cblxuICBmdW5jdGlvbiBhdHRhY2hBbmRQbGF5IChlbGVtZW50cywgc3RyZWFtLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgZWxlbWVudHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMoKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleCAlIGVsZW1lbnRzLmxlbmd0aF07XG4gICAgKGVudmlyb25tZW50LmF0dGFjaE1lZGlhU3RyZWFtIHx8IGF0dGFjaE1lZGlhU3RyZWFtKShlbGVtZW50LCBzdHJlYW0pO1xuICAgIGVuc3VyZU1lZGlhUGxheWluZyhlbGVtZW50KTtcbiAgfVxuXG4gIC8vIFtdLmNvbmNhdCBcImNhc3RzXCIgYGVsZW1lbnRzYCBpbnRvIGFuIGFycmF5XG4gIC8vIHNvIGZvckVhY2ggd29ya3MgZXZlbiBpZiBgZWxlbWVudHNgIHdhcyBhIHNpbmdsZSBlbGVtZW50XG4gIGVsZW1lbnRzID0gW10uY29uY2F0KGVsZW1lbnRzKTtcbiAgW10uY29uY2F0KHN0cmVhbXMpLmZvckVhY2goYXR0YWNoQW5kUGxheS5iaW5kKG51bGwsIGVsZW1lbnRzKSk7XG59O1xuXG5NZWRpYVN0cmVhbU1hbmFnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSwge1xuICAnYWNxdWlyZSc6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGFjcXVpcmUgKG1lZGlhSGludCkge1xuICAgIG1lZGlhSGludCA9IE9iamVjdC5rZXlzKG1lZGlhSGludCB8fCB7fSkubGVuZ3RoID8gbWVkaWFIaW50IDogdGhpcy5tZWRpYUhpbnQ7XG5cbiAgICB2YXIgc2F2ZVN1Y2Nlc3MgPSBmdW5jdGlvbiAoaXNIaW50U3RyZWFtLCBzdHJlYW1zKSB7XG4gICAgICBzdHJlYW1zID0gW10uY29uY2F0KHN0cmVhbXMpO1xuICAgICAgc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgdmFyIHN0cmVhbUlkID0gTWVkaWFTdHJlYW1NYW5hZ2VyLnN0cmVhbUlkKHN0cmVhbSk7XG4gICAgICAgIHRoaXMuYWNxdWlzaXRpb25zW3N0cmVhbUlkXSA9ICEhaXNIaW50U3RyZWFtO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICByZXR1cm4gU0lQLlV0aWxzLlByb21pc2UucmVzb2x2ZShzdHJlYW1zKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBpZiAobWVkaWFIaW50LnN0cmVhbSkge1xuICAgICAgcmV0dXJuIHNhdmVTdWNjZXNzKHRydWUsIG1lZGlhSGludC5zdHJlYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBhdWRpby92aWRlbyBlbmFibGVkIGlmIG5vIG1lZGlhSGludCBjYW4gYmUgZm91bmQuXG4gICAgICB2YXIgY29uc3RyYWludHMgPSBtZWRpYUhpbnQuY29uc3RyYWludHMgfHxcbiAgICAgICAgKHRoaXMubWVkaWFIaW50ICYmIHRoaXMubWVkaWFIaW50LmNvbnN0cmFpbnRzKSB8fFxuICAgICAgICB7YXVkaW86IHRydWUsIHZpZGVvOiB0cnVlfTtcblxuICAgICAgdmFyIGRlZmVycmVkID0gU0lQLlV0aWxzLmRlZmVyKCk7XG5cbiAgICAgIC8qXG4gICAgICAgKiBNYWtlIHRoZSBjYWxsIGFzeW5jaHJvbm91cywgc28gdGhhdCBJQ0NzIGhhdmUgYSBjaGFuY2VcbiAgICAgICAqIHRvIGRlZmluZSBjYWxsYmFja3MgdG8gYHVzZXJNZWRpYVJlcXVlc3RgXG4gICAgICAgKi9cbiAgICAgIFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgndXNlck1lZGlhUmVxdWVzdCcsIGNvbnN0cmFpbnRzKTtcblxuICAgICAgICB2YXIgZW1pdFRoZW5DYWxsID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2tBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgICAvLyBFbWl0IHdpdGggYWxsIG9mIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgcmVhbCBjYWxsYmFjay5cbiAgICAgICAgICB2YXIgbmV3QXJncyA9IFtldmVudE5hbWVdLmNvbmNhdChjYWxsYmFja0FyZ3MpO1xuXG4gICAgICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGNhbGxiYWNrQXJncyk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICBpZiAoY29uc3RyYWludHMuYXVkaW8gfHwgY29uc3RyYWludHMudmlkZW8pIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKFxuICAgICAgICAgICAgU0lQLldlYlJUQy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgZW1pdFRoZW5DYWxsLmJpbmQodGhpcywgJ3VzZXJNZWRpYScsIHNhdmVTdWNjZXNzLmJpbmQobnVsbCwgZmFsc2UpKSxcbiAgICAgICAgICAgICAgZW1pdFRoZW5DYWxsLmJpbmQodGhpcywgJ3VzZXJNZWRpYUZhaWxlZCcsIGZ1bmN0aW9uKGUpe3Rocm93IGU7fSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExvY2FsIHN0cmVhbXMgd2VyZSBleHBsaWNpdGx5IGV4Y2x1ZGVkLlxuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoW10pO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyksIDApO1xuXG4gICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gIH19LFxuXG4gICdyZWxlYXNlJzoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZSAoc3RyZWFtcykge1xuICAgIHN0cmVhbXMgPSBbXS5jb25jYXQoc3RyZWFtcyk7XG4gICAgc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIHZhciBzdHJlYW1JZCA9IE1lZGlhU3RyZWFtTWFuYWdlci5zdHJlYW1JZChzdHJlYW0pO1xuICAgICAgaWYgKHRoaXMuYWNxdWlzaXRpb25zW3N0cmVhbUlkXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLmFjcXVpc2l0aW9uc1tzdHJlYW1JZF07XG4gICAgfSwgdGhpcyk7XG4gIH19LFxufSk7XG5cbi8vIFJldHVybiBzaW5jZSBpdCB3aWxsIGJlIGFzc2lnbmVkIHRvIGEgdmFyaWFibGUuXG5yZXR1cm4gTWVkaWFTdHJlYW1NYW5hZ2VyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvV2ViUlRDL01lZGlhU3RyZWFtTWFuYWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIFNJUCBVc2VyIEFnZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbiByZXR1cm5pbmcgU0lQLk1lZGlhSGFuZGxlcn0gW2NvbmZpZ3VyYXRpb24ubWVkaWFIYW5kbGVyRmFjdG9yeV1cbiAqICAgICAgICBBIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBieSBlYWNoIG9mIHRoZSBVQSdzIFNlc3Npb25zIHRvIGJ1aWxkIHRoZSBNZWRpYUhhbmRsZXIgZm9yIHRoYXQgU2Vzc2lvbi5cbiAqICAgICAgICBJZiBubyAob3IgYSBmYWxzeSkgdmFsdWUgaXMgcHJvdmlkZWQsIGVhY2ggU2Vzc2lvbiB3aWxsIHVzZSBhIGRlZmF1bHQgKFdlYlJUQykgTWVkaWFIYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlndXJhdGlvbi5tZWRpYV0gZ2V0cyBwYXNzZWQgdG8gU0lQLk1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbiBhcyBtZWRpYUhpbnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQLCBlbnZpcm9ubWVudCkge1xudmFyIFVBLFxuICBDID0ge1xuICAgIC8vIFVBIHN0YXR1cyBjb2Rlc1xuICAgIFNUQVRVU19JTklUOiAgICAgICAgICAgICAgICAwLFxuICAgIFNUQVRVU19TVEFSVElORzogICAgICAgICAgICAxLFxuICAgIFNUQVRVU19SRUFEWTogICAgICAgICAgICAgICAyLFxuICAgIFNUQVRVU19VU0VSX0NMT1NFRDogICAgICAgICAzLFxuICAgIFNUQVRVU19OT1RfUkVBRFk6ICAgICAgICAgICA0LFxuXG4gICAgLy8gVUEgZXJyb3IgY29kZXNcbiAgICBDT05GSUdVUkFUSU9OX0VSUk9SOiAgMSxcbiAgICBORVRXT1JLX0VSUk9SOiAgICAgICAgMixcblxuICAgIEFMTE9XRURfTUVUSE9EUzogW1xuICAgICAgJ0FDSycsXG4gICAgICAnQ0FOQ0VMJyxcbiAgICAgICdJTlZJVEUnLFxuICAgICAgJ01FU1NBR0UnLFxuICAgICAgJ0JZRScsXG4gICAgICAnT1BUSU9OUycsXG4gICAgICAnSU5GTycsXG4gICAgICAnTk9USUZZJyxcbiAgICAgICdSRUZFUidcbiAgICBdLFxuXG4gICAgQUNDRVBURURfQk9EWV9UWVBFUzogW1xuICAgICAgJ2FwcGxpY2F0aW9uL3NkcCcsXG4gICAgICAnYXBwbGljYXRpb24vZHRtZi1yZWxheSdcbiAgICBdLFxuXG4gICAgTUFYX0ZPUldBUkRTOiA3MCxcbiAgICBUQUdfTEVOR1RIOiAxMFxuICB9O1xuXG5VQSA9IGZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZm9yd2FyZGluZyBldmVudHNcbiAgZnVuY3Rpb24gc2VsZkVtaXQodHlwZSkge1xuICAgIC8vcmVnaXN0cmF0aW9uRmFpbGVkIGhhbmRsZXIgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHMuIEFsbG93IGV2ZW50IGhhbmRsZXJzIHRvIGJlIGludm9rZWQgd2l0aCBhIHZhcmlhYmxlIG5vLiBvZiBhcmd1bWVudHNcbiAgICByZXR1cm4gc2VsZi5lbWl0LmJpbmQoc2VsZiwgdHlwZSk7XG4gIH1cblxuICAvLyBTZXQgQWNjZXB0ZWQgQm9keSBUeXBlc1xuICBDLkFDQ0VQVEVEX0JPRFlfVFlQRVMgPSBDLkFDQ0VQVEVEX0JPRFlfVFlQRVMudG9TdHJpbmcoKTtcblxuICB0aGlzLmxvZyA9IG5ldyBTSVAuTG9nZ2VyRmFjdG9yeSgpO1xuICB0aGlzLmxvZ2dlciA9IHRoaXMuZ2V0TG9nZ2VyKCdzaXAudWEnKTtcblxuICB0aGlzLmNhY2hlID0ge1xuICAgIGNyZWRlbnRpYWxzOiB7fVxuICB9O1xuXG4gIHRoaXMuY29uZmlndXJhdGlvbiA9IHt9O1xuICB0aGlzLmRpYWxvZ3MgPSB7fTtcblxuICAvL1VzZXIgYWN0aW9ucyBvdXRzaWRlIGFueSBzZXNzaW9uL2RpYWxvZyAoTUVTU0FHRSlcbiAgdGhpcy5hcHBsaWNhbnRzID0ge307XG5cbiAgdGhpcy5kYXRhID0ge307XG4gIHRoaXMuc2Vzc2lvbnMgPSB7fTtcbiAgdGhpcy5zdWJzY3JpcHRpb25zID0ge307XG4gIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgdGhpcy5jb250YWN0ID0gbnVsbDtcbiAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19JTklUO1xuICB0aGlzLmVycm9yID0gbnVsbDtcbiAgdGhpcy50cmFuc2FjdGlvbnMgPSB7XG4gICAgbmlzdDoge30sXG4gICAgbmljdDoge30sXG4gICAgaXN0OiB7fSxcbiAgICBpY3Q6IHt9XG4gIH07XG5cbiAgdGhpcy50cmFuc3BvcnRSZWNvdmVyQXR0ZW1wdHMgPSAwO1xuICB0aGlzLnRyYW5zcG9ydFJlY292ZXJ5VGltZXIgPSBudWxsO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICB0cmFuc2FjdGlvbnNDb3VudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHR5cGUsXG4gICAgICAgICAgdHJhbnNhY3Rpb25zID0gWyduaXN0JywnbmljdCcsJ2lzdCcsJ2ljdCddLFxuICAgICAgICAgIGNvdW50ID0gMDtcblxuICAgICAgICBmb3IgKHR5cGUgaW4gdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgY291bnQgKz0gT2JqZWN0LmtleXModGhpcy50cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25zW3R5cGVdXSkubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuaWN0VHJhbnNhY3Rpb25zQ291bnQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRyYW5zYWN0aW9uc1snbmljdCddKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG5pc3RUcmFuc2FjdGlvbnNDb3VudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhbnNhY3Rpb25zWyduaXN0J10pLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaWN0VHJhbnNhY3Rpb25zQ291bnQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRyYW5zYWN0aW9uc1snaWN0J10pLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXN0VHJhbnNhY3Rpb25zQ291bnQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRyYW5zYWN0aW9uc1snaXN0J10pLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBMb2FkIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHRocm93cyB7U0lQLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yfVxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICAqL1xuXG4gIGlmKGNvbmZpZ3VyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbiA9PT0gJ3N0cmluZycgfHwgY29uZmlndXJhdGlvbiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIGNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICB1cmk6IGNvbmZpZ3VyYXRpb25cbiAgICB9O1xuICB9XG5cbiAgLy8gQXBwbHkgbG9nIGNvbmZpZ3VyYXRpb24gaWYgcHJlc2VudFxuICBpZiAoY29uZmlndXJhdGlvbi5sb2cpIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbi5sb2cuaGFzT3duUHJvcGVydHkoJ2J1aWx0aW5FbmFibGVkJykpIHtcbiAgICAgIHRoaXMubG9nLmJ1aWx0aW5FbmFibGVkID0gY29uZmlndXJhdGlvbi5sb2cuYnVpbHRpbkVuYWJsZWQ7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24ubG9nLmhhc093blByb3BlcnR5KCdsZXZlbCcpKSB7XG4gICAgICB0aGlzLmxvZy5sZXZlbCA9IGNvbmZpZ3VyYXRpb24ubG9nLmxldmVsO1xuICAgIH1cblxuICAgIGlmIChjb25maWd1cmF0aW9uLmxvZy5oYXNPd25Qcm9wZXJ0eSgnY29ubmVjdG9yJykpIHtcbiAgICAgIHRoaXMubG9nLmNvbm5lY3RvciA9IGNvbmZpZ3VyYXRpb24ubG9nLmNvbm5lY3RvcjtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMubG9hZENvbmZpZyhjb25maWd1cmF0aW9uKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19OT1RfUkVBRFk7XG4gICAgdGhpcy5lcnJvciA9IEMuQ09ORklHVVJBVElPTl9FUlJPUjtcbiAgICB0aHJvdyBlO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSByZWdpc3RlckNvbnRleHRcbiAgdGhpcy5yZWdpc3RlckNvbnRleHQgPSBuZXcgU0lQLlJlZ2lzdGVyQ29udGV4dCh0aGlzKTtcbiAgdGhpcy5yZWdpc3RlckNvbnRleHQub24oJ2ZhaWxlZCcsIHNlbGZFbWl0KCdyZWdpc3RyYXRpb25GYWlsZWQnKSk7XG4gIHRoaXMucmVnaXN0ZXJDb250ZXh0Lm9uKCdyZWdpc3RlcmVkJywgc2VsZkVtaXQoJ3JlZ2lzdGVyZWQnKSk7XG4gIHRoaXMucmVnaXN0ZXJDb250ZXh0Lm9uKCd1bnJlZ2lzdGVyZWQnLCBzZWxmRW1pdCgndW5yZWdpc3RlcmVkJykpO1xuXG4gIGlmKHRoaXMuY29uZmlndXJhdGlvbi5hdXRvc3RhcnQpIHtcbiAgICB0aGlzLnN0YXJ0KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudmlyb25tZW50LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBHb29nbGUgQ2hyb21lIFBhY2thZ2VkIEFwcHMgZG9uJ3QgYWxsb3cgJ3VubG9hZCcgbGlzdGVuZXJzOlxuICAgIC8vIHVubG9hZCBpcyBub3QgYXZhaWxhYmxlIGluIHBhY2thZ2VkIGFwcHNcbiAgICBpZiAoIShnbG9iYWwuY2hyb21lICYmIGdsb2JhbC5jaHJvbWUuYXBwICYmIGdsb2JhbC5jaHJvbWUuYXBwLnJ1bnRpbWUpKSB7XG4gICAgICBlbnZpcm9ubWVudC5hZGRFdmVudExpc3RlbmVyKCd1bmxvYWQnLCB0aGlzLnN0b3AuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG59O1xuVUEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8vPT09PT09PT09PT09PT09PT1cbi8vICBIaWdoIExldmVsIEFQSVxuLy89PT09PT09PT09PT09PT09PVxuXG5VQS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMuY29uZmlndXJhdGlvbi5yZWdpc3RlciA9IHRydWU7XG4gIHRoaXMucmVnaXN0ZXJDb250ZXh0LnJlZ2lzdGVyKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVbnJlZ2lzdGVyLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbF0gdW5yZWdpc3RlciBhbGwgdXNlciBiaW5kaW5ncy5cbiAqXG4gKi9cblVBLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLmNvbmZpZ3VyYXRpb24ucmVnaXN0ZXIgPSBmYWxzZTtcblxuICB2YXIgY29udGV4dCA9IHRoaXMucmVnaXN0ZXJDb250ZXh0O1xuICB0aGlzLmFmdGVyQ29ubmVjdGVkKGNvbnRleHQudW5yZWdpc3Rlci5iaW5kKGNvbnRleHQsIG9wdGlvbnMpKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cblVBLnByb3RvdHlwZS5pc1JlZ2lzdGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucmVnaXN0ZXJDb250ZXh0LnJlZ2lzdGVyZWQ7XG59O1xuXG4vKipcbiAqIENvbm5lY3Rpb24gc3RhdGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59XG4gKi9cblVBLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50cmFuc3BvcnQgPyB0aGlzLnRyYW5zcG9ydC5jb25uZWN0ZWQgOiBmYWxzZTtcbn07XG5cblVBLnByb3RvdHlwZS5hZnRlckNvbm5lY3RlZCA9IGZ1bmN0aW9uIGFmdGVyQ29ubmVjdGVkIChjYWxsYmFjaykge1xuICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9uY2UoJ2Nvbm5lY3RlZCcsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYWtlIGFuIG91dGdvaW5nIGNhbGwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IHZpZXdzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWVkaWFdIGdldHMgcGFzc2VkIHRvIFNJUC5NZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24gYXMgbWVkaWFIaW50XG4gKlxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICpcbiAqL1xuVUEucHJvdG90eXBlLmludml0ZSA9IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICB2YXIgY29udGV4dCA9IG5ldyBTSVAuSW52aXRlQ2xpZW50Q29udGV4dCh0aGlzLCB0YXJnZXQsIG9wdGlvbnMpO1xuXG4gIHRoaXMuYWZ0ZXJDb25uZWN0ZWQoY29udGV4dC5pbnZpdGUuYmluZChjb250ZXh0KSk7XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuVUEucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHN1YiA9IG5ldyBTSVAuU3Vic2NyaXB0aW9uKHRoaXMsIHRhcmdldCwgZXZlbnQsIG9wdGlvbnMpO1xuXG4gIHRoaXMuYWZ0ZXJDb25uZWN0ZWQoc3ViLnN1YnNjcmliZS5iaW5kKHN1YikpO1xuICByZXR1cm4gc3ViO1xufTtcblxuLyoqXG4gKiBTZW5kIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICpcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqXG4gKi9cblVBLnByb3RvdHlwZS5tZXNzYWdlID0gZnVuY3Rpb24odGFyZ2V0LCBib2R5LCBvcHRpb25zKSB7XG4gIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICB9XG5cbiAgLy8gVGhlcmUgaXMgbm8gTWVzc2FnZSBtb2R1bGUsIHNvIGl0IGlzIG9rYXkgdGhhdCB0aGUgVUEgaGFuZGxlcyBkZWZhdWx0cyBoZXJlLlxuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICBvcHRpb25zLmNvbnRlbnRUeXBlIHx8IChvcHRpb25zLmNvbnRlbnRUeXBlID0gJ3RleHQvcGxhaW4nKTtcbiAgb3B0aW9ucy5ib2R5ID0gYm9keTtcblxuICByZXR1cm4gdGhpcy5yZXF1ZXN0KFNJUC5DLk1FU1NBR0UsIHRhcmdldCwgb3B0aW9ucyk7XG59O1xuXG5VQS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHRhcmdldCwgb3B0aW9ucykge1xuICB2YXIgcmVxID0gbmV3IFNJUC5DbGllbnRDb250ZXh0KHRoaXMsIG1ldGhvZCwgdGFyZ2V0LCBvcHRpb25zKTtcblxuICB0aGlzLmFmdGVyQ29ubmVjdGVkKHJlcS5zZW5kLmJpbmQocmVxKSk7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEdyYWNlZnVsbHkgY2xvc2UuXG4gKlxuICovXG5VQS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2Vzc2lvbiwgc3Vic2NyaXB0aW9uLCBhcHBsaWNhbnQsXG4gICAgdWEgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIHRyYW5zYWN0aW9uc0xpc3RlbmVyKCkge1xuICAgIGlmICh1YS5uaXN0VHJhbnNhY3Rpb25zQ291bnQgPT09IDAgJiYgdWEubmljdFRyYW5zYWN0aW9uc0NvdW50ID09PSAwKSB7XG4gICAgICAgIHVhLnJlbW92ZUxpc3RlbmVyKCd0cmFuc2FjdGlvbkRlc3Ryb3llZCcsIHRyYW5zYWN0aW9uc0xpc3RlbmVyKTtcbiAgICAgICAgdWEudHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmxvZ2dlci5sb2coJ3VzZXIgcmVxdWVzdGVkIGNsb3N1cmUuLi4nKTtcblxuICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVVNFUl9DTE9TRUQpIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdVQSBhbHJlYWR5IGNsb3NlZCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQ2xlYXIgdHJhbnNwb3J0UmVjb3ZlcnlUaW1lclxuICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRyYW5zcG9ydFJlY292ZXJ5VGltZXIpO1xuXG4gIC8vIENsb3NlIHJlZ2lzdGVyQ29udGV4dFxuICB0aGlzLmxvZ2dlci5sb2coJ2Nsb3NpbmcgcmVnaXN0ZXJDb250ZXh0Jyk7XG4gIHRoaXMucmVnaXN0ZXJDb250ZXh0LmNsb3NlKCk7XG5cbiAgLy8gUnVuICBfdGVybWluYXRlXyBvbiBldmVyeSBTZXNzaW9uXG4gIGZvcihzZXNzaW9uIGluIHRoaXMuc2Vzc2lvbnMpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ2Nsb3Npbmcgc2Vzc2lvbiAnICsgc2Vzc2lvbik7XG4gICAgdGhpcy5zZXNzaW9uc1tzZXNzaW9uXS50ZXJtaW5hdGUoKTtcbiAgfVxuXG4gIC8vUnVuIF9jbG9zZV8gb24gZXZlcnkgU3Vic2NyaXB0aW9uXG4gIGZvcihzdWJzY3JpcHRpb24gaW4gdGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCd1bnN1YnNjcmliaW5nIGZyb20gc3Vic2NyaXB0aW9uICcgKyBzdWJzY3JpcHRpb24pO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tzdWJzY3JpcHRpb25dLmNsb3NlKCk7XG4gIH1cblxuICAvLyBSdW4gIF9jbG9zZV8gb24gZXZlcnkgYXBwbGljYW50XG4gIGZvcihhcHBsaWNhbnQgaW4gdGhpcy5hcHBsaWNhbnRzKSB7XG4gICAgdGhpcy5hcHBsaWNhbnRzW2FwcGxpY2FudF0uY2xvc2UoKTtcbiAgfVxuXG4gIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfVVNFUl9DTE9TRUQ7XG5cbiAgLypcbiAgICogSWYgdGhlIHJlbWFpbmluZyB0cmFuc2FjdGlvbnMgYXJlIGFsbCBJTlZJVEUgdHJhbnNhY3Rpb25zLCB0aGVyZSBpcyBubyBuZWVkIHRvXG4gICAqIHdhaXQgYW55bW9yZSBiZWNhdXNlIGV2ZXJ5IHNlc3Npb24gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnkgdGhpcyBtZXRob2QuXG4gICAqIC0gbG9jYWxseSBvcmlnaW5hdGVkIHNlc3Npb25zIHdoZXJlIHRlcm1pbmF0ZWQgKENBTkNFTCBvciBCWUUpXG4gICAqIC0gcmVtb3RlbHkgb3JpZ2luYXRlZCBzZXNzaW9ucyB3aGVyZSByZWplY3RlZCAoNFhYKSBvciB0ZXJtaW5hdGVkIChCWUUpXG4gICAqIFJlbWFpbmluZyBJTlZJVEUgdHJhbnNhY3Rpb25zIGJlbG9uZyB0aG8gc2Vzc2lvbnMgdGhhdCB3aGVyZSBhbnN3ZXJlZC4gVGhpcyBhcmUgaW5cbiAgICogJ2FjY2VwdGVkJyBzdGF0ZSBkdWUgdG8gdGltZXJzICdMJyBhbmQgJ00nIGRlZmluZWQgaW4gW1JGQyA2MDI2XVxuICAgKi9cbiAgaWYgKHRoaXMubmlzdFRyYW5zYWN0aW9uc0NvdW50ID09PSAwICYmIHRoaXMubmljdFRyYW5zYWN0aW9uc0NvdW50ID09PSAwKSB7XG4gICAgdGhpcy50cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub24oJ3RyYW5zYWN0aW9uRGVzdHJveWVkJywgdHJhbnNhY3Rpb25zTGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbm5lY3QgdG8gdGhlIFdTIHNlcnZlciBpZiBzdGF0dXMgPSBTVEFUVVNfSU5JVC5cbiAqIFJlc3VtZSBVQSBhZnRlciBiZWluZyBjbG9zZWQuXG4gKlxuICovXG5VQS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlcnZlcjtcblxuICB0aGlzLmxvZ2dlci5sb2coJ3VzZXIgcmVxdWVzdGVkIHN0YXJ0dXAuLi4nKTtcbiAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19JTklUKSB7XG4gICAgc2VydmVyID0gdGhpcy5nZXROZXh0V3NTZXJ2ZXIoKTtcbiAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX1NUQVJUSU5HO1xuICAgIG5ldyBTSVAuVHJhbnNwb3J0KHRoaXMsIHNlcnZlcik7XG4gIH0gZWxzZSBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVVNFUl9DTE9TRUQpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ3Jlc3VtaW5nJyk7XG4gICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19SRUFEWTtcbiAgICB0aGlzLnRyYW5zcG9ydC5jb25uZWN0KCk7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1NUQVJUSU5HKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdVQSBpcyBpbiBTVEFSVElORyBzdGF0dXMsIG5vdCBvcGVuaW5nIG5ldyBjb25uZWN0aW9uJyk7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1JFQURZKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdVQSBpcyBpbiBSRUFEWSBzdGF0dXMsIG5vdCByZXN1bWluZycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubG9nZ2VyLmVycm9yKCdDb25uZWN0aW9uIGlzIGRvd24uIEF1dG8tUmVjb3Zlcnkgc3lzdGVtIGlzIHRyeWluZyB0byBjb25uZWN0Jyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgc3RyaW5nIGludG8gYSB2YWxpZCBTSVAgcmVxdWVzdCBVUklcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0XG4gKlxuICogQHJldHVybnMge1NJUC5VUkl8dW5kZWZpbmVkfVxuICovXG5VQS5wcm90b3R5cGUubm9ybWFsaXplVGFyZ2V0ID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gIHJldHVybiBTSVAuVXRpbHMubm9ybWFsaXplVGFyZ2V0KHRhcmdldCwgdGhpcy5jb25maWd1cmF0aW9uLmhvc3Rwb3J0UGFyYW1zKTtcbn07XG5cblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAgUHJpdmF0ZSAoRm9yIGludGVybmFsIHVzZSlcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5VQS5wcm90b3R5cGUuc2F2ZUNyZWRlbnRpYWxzID0gZnVuY3Rpb24oY3JlZGVudGlhbHMpIHtcbiAgdGhpcy5jYWNoZS5jcmVkZW50aWFsc1tjcmVkZW50aWFscy5yZWFsbV0gPSB0aGlzLmNhY2hlLmNyZWRlbnRpYWxzW2NyZWRlbnRpYWxzLnJlYWxtXSB8fCB7fTtcbiAgdGhpcy5jYWNoZS5jcmVkZW50aWFsc1tjcmVkZW50aWFscy5yZWFsbV1bY3JlZGVudGlhbHMudXJpXSA9IGNyZWRlbnRpYWxzO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuVUEucHJvdG90eXBlLmdldENyZWRlbnRpYWxzID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICB2YXIgcmVhbG0sIGNyZWRlbnRpYWxzO1xuXG4gIHJlYWxtID0gcmVxdWVzdC5ydXJpLmhvc3Q7XG5cbiAgaWYgKHRoaXMuY2FjaGUuY3JlZGVudGlhbHNbcmVhbG1dICYmIHRoaXMuY2FjaGUuY3JlZGVudGlhbHNbcmVhbG1dW3JlcXVlc3QucnVyaV0pIHtcbiAgICBjcmVkZW50aWFscyA9IHRoaXMuY2FjaGUuY3JlZGVudGlhbHNbcmVhbG1dW3JlcXVlc3QucnVyaV07XG4gICAgY3JlZGVudGlhbHMubWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gIH1cblxuICByZXR1cm4gY3JlZGVudGlhbHM7XG59O1xuXG5VQS5wcm90b3R5cGUuZ2V0TG9nZ2VyID0gZnVuY3Rpb24oY2F0ZWdvcnksIGxhYmVsKSB7XG4gIHJldHVybiB0aGlzLmxvZy5nZXRMb2dnZXIoY2F0ZWdvcnksIGxhYmVsKTtcbn07XG5cblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEV2ZW50IEhhbmRsZXJzXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFRyYW5zcG9ydCBDbG9zZSBldmVudFxuICogQHByaXZhdGVcbiAqIEBldmVudFxuICogQHBhcmFtIHtTSVAuVHJhbnNwb3J0fSB0cmFuc3BvcnQuXG4gKi9cblVBLnByb3RvdHlwZS5vblRyYW5zcG9ydENsb3NlZCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuICAvLyBSdW4gX29uVHJhbnNwb3J0RXJyb3JfIGNhbGxiYWNrIG9uIGV2ZXJ5IGNsaWVudCB0cmFuc2FjdGlvbiB1c2luZyBfdHJhbnNwb3J0X1xuICB2YXIgdHlwZSwgaWR4LCBsZW5ndGgsXG4gICAgY2xpZW50X3RyYW5zYWN0aW9ucyA9IFsnbmljdCcsICdpY3QnLCAnbmlzdCcsICdpc3QnXTtcblxuICB0cmFuc3BvcnQuc2VydmVyLnN0YXR1cyA9IFNJUC5UcmFuc3BvcnQuQy5TVEFUVVNfRElTQ09OTkVDVEVEO1xuICB0aGlzLmxvZ2dlci5sb2coJ2Nvbm5lY3Rpb24gc3RhdGUgc2V0IHRvICcrIFNJUC5UcmFuc3BvcnQuQy5TVEFUVVNfRElTQ09OTkVDVEVEKTtcblxuICBsZW5ndGggPSBjbGllbnRfdHJhbnNhY3Rpb25zLmxlbmd0aDtcbiAgZm9yICh0eXBlID0gMDsgdHlwZSA8IGxlbmd0aDsgdHlwZSsrKSB7XG4gICAgZm9yKGlkeCBpbiB0aGlzLnRyYW5zYWN0aW9uc1tjbGllbnRfdHJhbnNhY3Rpb25zW3R5cGVdXSkge1xuICAgICAgdGhpcy50cmFuc2FjdGlvbnNbY2xpZW50X3RyYW5zYWN0aW9uc1t0eXBlXV1baWR4XS5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2xvc2Ugc2Vzc2lvbnMgaWYgR1JVVSBpcyBub3QgYmVpbmcgdXNlZFxuICBpZiAoIXRoaXMuY29udGFjdC5wdWJfZ3J1dSkge1xuICAgIHRoaXMuY2xvc2VTZXNzaW9uc09uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIFVucmVjb3ZlcmFibGUgdHJhbnNwb3J0IGV2ZW50LlxuICogQ29ubmVjdGlvbiByZWF0dGVtcHQgbG9naWMgaGFzIGJlZW4gZG9uZSBhbmQgZGlkbid0IHN1Y2Nlc3MuXG4gKiBAcHJpdmF0ZVxuICogQGV2ZW50XG4gKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydC5cbiAqL1xuVUEucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcbiAgdmFyIHNlcnZlcjtcblxuICB0aGlzLmxvZ2dlci5sb2coJ3RyYW5zcG9ydCAnICsgdHJhbnNwb3J0LnNlcnZlci53c191cmkgKyAnIGZhaWxlZCB8IGNvbm5lY3Rpb24gc3RhdGUgc2V0IHRvICcrIFNJUC5UcmFuc3BvcnQuQy5TVEFUVVNfRVJST1IpO1xuXG4gIC8vIENsb3NlIHNlc3Npb25zLlxuICAvL01hcmsgdGhpcyB0cmFuc3BvcnQgYXMgJ2Rvd24nXG4gIHRyYW5zcG9ydC5zZXJ2ZXIuc3RhdHVzID0gU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19FUlJPUjtcblxuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcsIHtcbiAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydFxuICB9KTtcblxuICAvLyB0cnkgdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSBVQSBpc24ndCBjbG9zZWRcbiAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1VTRVJfQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2VydmVyID0gdGhpcy5nZXROZXh0V3NTZXJ2ZXIoKTtcblxuICBpZihzZXJ2ZXIpIHtcbiAgICBuZXcgU0lQLlRyYW5zcG9ydCh0aGlzLCBzZXJ2ZXIpO1xuICB9ZWxzZSB7XG4gICAgdGhpcy5jbG9zZVNlc3Npb25zT25UcmFuc3BvcnRFcnJvcigpO1xuICAgIGlmICghdGhpcy5lcnJvciB8fCB0aGlzLmVycm9yICE9PSBDLk5FVFdPUktfRVJST1IpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfTk9UX1JFQURZO1xuICAgICAgdGhpcy5lcnJvciA9IEMuTkVUV09SS19FUlJPUjtcbiAgICB9XG4gICAgLy8gVHJhbnNwb3J0IFJlY292ZXJ5IHByb2Nlc3NcbiAgICB0aGlzLnJlY292ZXJUcmFuc3BvcnQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgY29ubmVjdGlvbiBldmVudC5cbiAqIEBwcml2YXRlXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0LlxuICovXG5VQS5wcm90b3R5cGUub25UcmFuc3BvcnRDb25uZWN0ZWQgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgLy8gUmVzZXQgdHJhbnNwb3J0IHJlY292ZXJ5IGNvdW50ZXJcbiAgdGhpcy50cmFuc3BvcnRSZWNvdmVyQXR0ZW1wdHMgPSAwO1xuXG4gIHRyYW5zcG9ydC5zZXJ2ZXIuc3RhdHVzID0gU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19SRUFEWTtcbiAgdGhpcy5sb2dnZXIubG9nKCdjb25uZWN0aW9uIHN0YXRlIHNldCB0byAnKyBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX1JFQURZKTtcblxuICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVVNFUl9DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX1JFQURZO1xuICB0aGlzLmVycm9yID0gbnVsbDtcblxuICBpZih0aGlzLmNvbmZpZ3VyYXRpb24ucmVnaXN0ZXIpIHtcbiAgICB0aGlzLmNvbmZpZ3VyYXRpb24uYXV0aGVudGljYXRpb25GYWN0b3J5LmluaXRpYWxpemUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJDb250ZXh0Lm9uVHJhbnNwb3J0Q29ubmVjdGVkKCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHRoaXMuZW1pdCgnY29ubmVjdGVkJywge1xuICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFRyYW5zcG9ydCBjb25uZWN0aW5nIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTSVAuVHJhbnNwb3J0fSB0cmFuc3BvcnQuXG4gKiAjcGFyYW0ge0ludGVnZXJ9IGF0dGVtcHRzLlxuICovXG4gIFVBLnByb3RvdHlwZS5vblRyYW5zcG9ydENvbm5lY3RpbmcgPSBmdW5jdGlvbih0cmFuc3BvcnQsIGF0dGVtcHRzKSB7XG4gICAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJywge1xuICAgICAgdHJhbnNwb3J0OiB0cmFuc3BvcnQsXG4gICAgICBhdHRlbXB0czogYXR0ZW1wdHNcbiAgICB9KTtcbiAgfTtcblxuXG4vKipcbiAqIG5ldyBUcmFuc2FjdGlvblxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U0lQLlRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbi5cbiAqL1xuVUEucHJvdG90eXBlLm5ld1RyYW5zYWN0aW9uID0gZnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgdGhpcy50cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb24udHlwZV1bdHJhbnNhY3Rpb24uaWRdID0gdHJhbnNhY3Rpb247XG4gIHRoaXMuZW1pdCgnbmV3VHJhbnNhY3Rpb24nLCB7dHJhbnNhY3Rpb246IHRyYW5zYWN0aW9ufSk7XG59O1xuXG5cbi8qKlxuICogZGVzdHJveSBUcmFuc2FjdGlvblxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U0lQLlRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbi5cbiAqL1xuVUEucHJvdG90eXBlLmRlc3Ryb3lUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIGRlbGV0ZSB0aGlzLnRyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbi50eXBlXVt0cmFuc2FjdGlvbi5pZF07XG4gIHRoaXMuZW1pdCgndHJhbnNhY3Rpb25EZXN0cm95ZWQnLCB7XG4gICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG4gIH0pO1xufTtcblxuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIHJlY2VpdmVSZXF1ZXN0XG4vLz09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBSZXF1ZXN0IHJlY2VwdGlvblxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdH0gcmVxdWVzdC5cbiAqL1xuVUEucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICB2YXIgZGlhbG9nLCBzZXNzaW9uLCBtZXNzYWdlLFxuICAgIG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kLFxuICAgIHRyYW5zYWN0aW9uLFxuICAgIHJlcGxhY2VzLFxuICAgIHJlcGxhY2VkRGlhbG9nLFxuICAgIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIHJ1cmlNYXRjaGVzICh1cmkpIHtcbiAgICByZXR1cm4gdXJpICYmIHVyaS51c2VyID09PSByZXF1ZXN0LnJ1cmkudXNlcjtcbiAgfVxuXG4gIC8vIENoZWNrIHRoYXQgcmVxdWVzdCBVUkkgcG9pbnRzIHRvIHVzXG4gIGlmKCEocnVyaU1hdGNoZXModGhpcy5jb25maWd1cmF0aW9uLnVyaSkgfHxcbiAgICAgICBydXJpTWF0Y2hlcyh0aGlzLmNvbnRhY3QudXJpKSB8fFxuICAgICAgIHJ1cmlNYXRjaGVzKHRoaXMuY29udGFjdC5wdWJfZ3J1dSkgfHxcbiAgICAgICBydXJpTWF0Y2hlcyh0aGlzLmNvbnRhY3QudGVtcF9ncnV1KSkpIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdSZXF1ZXN0LVVSSSBkb2VzIG5vdCBwb2ludCB0byB1cycpO1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gU0lQLkMuQUNLKSB7XG4gICAgICByZXF1ZXN0LnJlcGx5X3NsKDQwNCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENoZWNrIHJlcXVlc3QgVVJJIHNjaGVtZVxuICBpZihyZXF1ZXN0LnJ1cmkuc2NoZW1lID09PSBTSVAuQy5TSVBTKSB7XG4gICAgcmVxdWVzdC5yZXBseV9zbCg0MTYpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENoZWNrIHRyYW5zYWN0aW9uXG4gIGlmKFNJUC5UcmFuc2FjdGlvbnMuY2hlY2tUcmFuc2FjdGlvbih0aGlzLCByZXF1ZXN0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qIFJGQzMyNjEgMTIuMi4yXG4gICAqIFJlcXVlc3RzIHRoYXQgZG8gbm90IGNoYW5nZSBpbiBhbnkgd2F5IHRoZSBzdGF0ZSBvZiBhIGRpYWxvZyBtYXkgYmVcbiAgICogcmVjZWl2ZWQgd2l0aGluIGEgZGlhbG9nIChmb3IgZXhhbXBsZSwgYW4gT1BUSU9OUyByZXF1ZXN0KS5cbiAgICogVGhleSBhcmUgcHJvY2Vzc2VkIGFzIGlmIHRoZXkgaGFkIGJlZW4gcmVjZWl2ZWQgb3V0c2lkZSB0aGUgZGlhbG9nLlxuICAgKi9cbiAgaWYobWV0aG9kID09PSBTSVAuQy5PUFRJT05TKSB7XG4gICAgbmV3IFNJUC5UcmFuc2FjdGlvbnMuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ocmVxdWVzdCwgdGhpcyk7XG4gICAgcmVxdWVzdC5yZXBseSgyMDAsIG51bGwsIFtcbiAgICAgICdBbGxvdzogJysgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCksXG4gICAgICAnQWNjZXB0OiAnKyBDLkFDQ0VQVEVEX0JPRFlfVFlQRVNcbiAgICBdKTtcbiAgfSBlbHNlIGlmIChtZXRob2QgPT09IFNJUC5DLk1FU1NBR0UpIHtcbiAgICBtZXNzYWdlID0gbmV3IFNJUC5TZXJ2ZXJDb250ZXh0KHRoaXMsIHJlcXVlc3QpO1xuICAgIG1lc3NhZ2UuYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgICBtZXNzYWdlLmNvbnRlbnRfdHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKSB8fCAndGV4dC9wbGFpbic7XG5cbiAgICByZXF1ZXN0LnJlcGx5KDIwMCwgbnVsbCk7XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gIH0gZWxzZSBpZiAobWV0aG9kICE9PSBTSVAuQy5JTlZJVEUgJiZcbiAgICAgICAgICAgICBtZXRob2QgIT09IFNJUC5DLkFDSykge1xuICAgIC8vIExldCB0aG9zZSBtZXRob2RzIHBhc3MgdGhyb3VnaCB0byBub3JtYWwgcHJvY2Vzc2luZyBmb3Igbm93LlxuICAgIHRyYW5zYWN0aW9uID0gbmV3IFNJUC5TZXJ2ZXJDb250ZXh0KHRoaXMsIHJlcXVlc3QpO1xuICB9XG5cbiAgLy8gSW5pdGlhbCBSZXF1ZXN0XG4gIGlmKCFyZXF1ZXN0LnRvX3RhZykge1xuICAgIHN3aXRjaChtZXRob2QpIHtcbiAgICAgIGNhc2UgU0lQLkMuSU5WSVRFOlxuICAgICAgICByZXBsYWNlcyA9XG4gICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnJlcGxhY2VzICE9PSBTSVAuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQgJiZcbiAgICAgICAgICByZXF1ZXN0LnBhcnNlSGVhZGVyKCdyZXBsYWNlcycpO1xuXG4gICAgICAgIGlmIChyZXBsYWNlcykge1xuICAgICAgICAgIHJlcGxhY2VkRGlhbG9nID0gdGhpcy5kaWFsb2dzW3JlcGxhY2VzLmNhbGxfaWQgKyByZXBsYWNlcy5yZXBsYWNlc190b190YWcgKyByZXBsYWNlcy5yZXBsYWNlc19mcm9tX3RhZ107XG5cbiAgICAgICAgICBpZiAoIXJlcGxhY2VkRGlhbG9nKSB7XG4gICAgICAgICAgICAvL1JlcGxhY2VkIGhlYWRlciB3aXRob3V0IGEgbWF0Y2hpbmcgZGlhbG9nLCByZWplY3RcbiAgICAgICAgICAgIHJlcXVlc3QucmVwbHlfc2woNDgxLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcGxhY2VkRGlhbG9nLm93bmVyLnN0YXR1cyA9PT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXBseV9zbCg2MDMsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVwbGFjZWREaWFsb2cuc3RhdGUgPT09IFNJUC5EaWFsb2cuQy5TVEFUVVNfQ09ORklSTUVEICYmIHJlcGxhY2VzLmVhcmx5X29ubHkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVwbHlfc2woNDg2LCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNNZWRpYVN1cHBvcnRlZCA9IHRoaXMuY29uZmlndXJhdGlvbi5tZWRpYUhhbmRsZXJGYWN0b3J5LmlzU3VwcG9ydGVkO1xuICAgICAgICBpZighaXNNZWRpYVN1cHBvcnRlZCB8fCBpc01lZGlhU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICBzZXNzaW9uID0gbmV3IFNJUC5JbnZpdGVTZXJ2ZXJDb250ZXh0KHRoaXMsIHJlcXVlc3QpO1xuICAgICAgICAgIHNlc3Npb24ucmVwbGFjZWUgPSByZXBsYWNlZERpYWxvZyAmJiByZXBsYWNlZERpYWxvZy5vd25lcjtcbiAgICAgICAgICBzZXNzaW9uLm9uKCdpbnZpdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnaW52aXRlJywgdGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybignSU5WSVRFIHJlY2VpdmVkIGJ1dCBXZWJSVEMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgIHJlcXVlc3QucmVwbHkoNDg4KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuQllFOlxuICAgICAgICAvLyBPdXQgb2YgZGlhbG9nIEJZRSByZWNlaXZlZFxuICAgICAgICByZXF1ZXN0LnJlcGx5KDQ4MSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5DQU5DRUw6XG4gICAgICAgIHNlc3Npb24gPSB0aGlzLmZpbmRTZXNzaW9uKHJlcXVlc3QpO1xuICAgICAgICBpZihzZXNzaW9uKSB7XG4gICAgICAgICAgc2Vzc2lvbi5yZWNlaXZlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdyZWNlaXZlZCBDQU5DRUwgcmVxdWVzdCBmb3IgYSBub24gZXhpc3RlbnQgc2Vzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5BQ0s6XG4gICAgICAgIC8qIEFic29yYiBpdC5cbiAgICAgICAgICogQUNLIHJlcXVlc3Qgd2l0aG91dCBhIGNvcnJlc3BvbmRpbmcgSW52aXRlIFRyYW5zYWN0aW9uXG4gICAgICAgICAqIGFuZCB3aXRob3V0IFRvIHRhZy5cbiAgICAgICAgICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVxdWVzdC5yZXBseSg0MDUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLy8gSW4tZGlhbG9nIHJlcXVlc3RcbiAgZWxzZSB7XG4gICAgZGlhbG9nID0gdGhpcy5maW5kRGlhbG9nKHJlcXVlc3QpO1xuXG4gICAgaWYoZGlhbG9nKSB7XG4gICAgICBpZiAobWV0aG9kID09PSBTSVAuQy5JTlZJVEUpIHtcbiAgICAgICAgbmV3IFNJUC5UcmFuc2FjdGlvbnMuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ocmVxdWVzdCwgdGhpcyk7XG4gICAgICB9XG4gICAgICBkaWFsb2cucmVjZWl2ZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFNJUC5DLk5PVElGWSkge1xuICAgICAgc2Vzc2lvbiA9IHRoaXMuZmluZFNlc3Npb24ocmVxdWVzdCk7XG4gICAgICBpZihzZXNzaW9uKSB7XG4gICAgICAgIHNlc3Npb24ucmVjZWl2ZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdyZWNlaXZlZCBOT1RJRlkgcmVxdWVzdCBmb3IgYSBub24gZXhpc3RlbnQgc2Vzc2lvbicpO1xuICAgICAgICByZXF1ZXN0LnJlcGx5KDQ4MSwgJ1N1YnNjcmlwdGlvbiBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBSRkMzMjYxIDEyLjIuMlxuICAgICAqIFJlcXVlc3Qgd2l0aCB0byB0YWcsIGJ1dCBubyBtYXRjaGluZyBkaWFsb2cgZm91bmQuXG4gICAgICogRXhjZXB0aW9uOiBBQ0sgZm9yIGFuIEludml0ZSByZXF1ZXN0IGZvciB3aGljaCBhIGRpYWxvZyBoYXMgbm90XG4gICAgICogYmVlbiBjcmVhdGVkLlxuICAgICAqL1xuICAgIGVsc2Uge1xuICAgICAgaWYobWV0aG9kICE9PSBTSVAuQy5BQ0spIHtcbiAgICAgICAgcmVxdWVzdC5yZXBseSg0ODEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy89PT09PT09PT09PT09PT09PVxuLy8gVXRpbHNcbi8vPT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBHZXQgdGhlIHNlc3Npb24gdG8gd2hpY2ggdGhlIHJlcXVlc3QgYmVsb25ncyB0bywgaWYgYW55LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdH0gcmVxdWVzdC5cbiAqIEByZXR1cm5zIHtTSVAuT3V0Z29pbmdTZXNzaW9ufFNJUC5JbmNvbWluZ1Nlc3Npb258bnVsbH1cbiAqL1xuVUEucHJvdG90eXBlLmZpbmRTZXNzaW9uID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICByZXR1cm4gdGhpcy5zZXNzaW9uc1tyZXF1ZXN0LmNhbGxfaWQgKyByZXF1ZXN0LmZyb21fdGFnXSB8fFxuICAgICAgICAgIHRoaXMuc2Vzc2lvbnNbcmVxdWVzdC5jYWxsX2lkICsgcmVxdWVzdC50b190YWddIHx8XG4gICAgICAgICAgbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBkaWFsb2cgdG8gd2hpY2ggdGhlIHJlcXVlc3QgYmVsb25ncyB0bywgaWYgYW55LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U0lQLkluY29taW5nUmVxdWVzdH1cbiAqIEByZXR1cm5zIHtTSVAuRGlhbG9nfG51bGx9XG4gKi9cblVBLnByb3RvdHlwZS5maW5kRGlhbG9nID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICByZXR1cm4gdGhpcy5kaWFsb2dzW3JlcXVlc3QuY2FsbF9pZCArIHJlcXVlc3QuZnJvbV90YWcgKyByZXF1ZXN0LnRvX3RhZ10gfHxcbiAgICAgICAgICB0aGlzLmRpYWxvZ3NbcmVxdWVzdC5jYWxsX2lkICsgcmVxdWVzdC50b190YWcgKyByZXF1ZXN0LmZyb21fdGFnXSB8fFxuICAgICAgICAgIG51bGw7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBuZXh0IHNlcnZlciB0byB3aGljaCBjb25uZWN0LlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IHdzX3NlcnZlclxuICovXG5VQS5wcm90b3R5cGUuZ2V0TmV4dFdzU2VydmVyID0gZnVuY3Rpb24oKSB7XG4gIC8vIE9yZGVyIHNlcnZlcnMgYnkgd2VpZ2h0XG4gIHZhciBpZHgsIGxlbmd0aCwgd3Nfc2VydmVyLFxuICAgIGNhbmRpZGF0ZXMgPSBbXTtcblxuICBsZW5ndGggPSB0aGlzLmNvbmZpZ3VyYXRpb24ud3NTZXJ2ZXJzLmxlbmd0aDtcbiAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgd3Nfc2VydmVyID0gdGhpcy5jb25maWd1cmF0aW9uLndzU2VydmVyc1tpZHhdO1xuXG4gICAgaWYgKHdzX3NlcnZlci5zdGF0dXMgPT09IFNJUC5UcmFuc3BvcnQuQy5TVEFUVVNfRVJST1IpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbmRpZGF0ZXMucHVzaCh3c19zZXJ2ZXIpO1xuICAgIH0gZWxzZSBpZiAod3Nfc2VydmVyLndlaWdodCA+IGNhbmRpZGF0ZXNbMF0ud2VpZ2h0KSB7XG4gICAgICBjYW5kaWRhdGVzID0gW3dzX3NlcnZlcl07XG4gICAgfSBlbHNlIGlmICh3c19zZXJ2ZXIud2VpZ2h0ID09PSBjYW5kaWRhdGVzWzBdLndlaWdodCkge1xuICAgICAgY2FuZGlkYXRlcy5wdXNoKHdzX3NlcnZlcik7XG4gICAgfVxuICB9XG5cbiAgaWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2FuZGlkYXRlcy5sZW5ndGgpO1xuXG4gIHJldHVybiBjYW5kaWRhdGVzW2lkeF07XG59O1xuXG4vKipcbiAqIENsb3NlIGFsbCBzZXNzaW9ucyBvbiB0cmFuc3BvcnQgZXJyb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5VQS5wcm90b3R5cGUuY2xvc2VTZXNzaW9uc09uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlkeDtcblxuICAvLyBSdW4gX3RyYW5zcG9ydEVycm9yXyBmb3IgZXZlcnkgU2Vzc2lvblxuICBmb3IoaWR4IGluIHRoaXMuc2Vzc2lvbnMpIHtcbiAgICB0aGlzLnNlc3Npb25zW2lkeF0ub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG4gIC8vIENhbGwgcmVnaXN0ZXJDb250ZXh0IF9vblRyYW5zcG9ydENsb3NlZF9cbiAgdGhpcy5yZWdpc3RlckNvbnRleHQub25UcmFuc3BvcnRDbG9zZWQoKTtcbn07XG5cblVBLnByb3RvdHlwZS5yZWNvdmVyVHJhbnNwb3J0ID0gZnVuY3Rpb24odWEpIHtcbiAgdmFyIGlkeCwgbGVuZ3RoLCBrLCBuZXh0UmV0cnksIGNvdW50LCBzZXJ2ZXI7XG5cbiAgdWEgPSB1YSB8fCB0aGlzO1xuICBjb3VudCA9IHVhLnRyYW5zcG9ydFJlY292ZXJBdHRlbXB0cztcblxuICBsZW5ndGggPSB1YS5jb25maWd1cmF0aW9uLndzU2VydmVycy5sZW5ndGg7XG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgIHVhLmNvbmZpZ3VyYXRpb24ud3NTZXJ2ZXJzW2lkeF0uc3RhdHVzID0gMDtcbiAgfVxuXG4gIHNlcnZlciA9IHVhLmdldE5leHRXc1NlcnZlcigpO1xuXG4gIGsgPSBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMixjb3VudCkpICsxKTtcbiAgbmV4dFJldHJ5ID0gayAqIHVhLmNvbmZpZ3VyYXRpb24uY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWw7XG5cbiAgaWYgKG5leHRSZXRyeSA+IHVhLmNvbmZpZ3VyYXRpb24uY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWwpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ3RpbWUgZm9yIG5leHQgY29ubmVjdGlvbiBhdHRlbXB0IGV4Y2VlZHMgY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWwsIHJlc2V0dGluZyBjb3VudGVyJyk7XG4gICAgbmV4dFJldHJ5ID0gdWEuY29uZmlndXJhdGlvbi5jb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbDtcbiAgICBjb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLmxvZ2dlci5sb2coJ25leHQgY29ubmVjdGlvbiBhdHRlbXB0IGluICcrIG5leHRSZXRyeSArJyBzZWNvbmRzJyk7XG5cbiAgdGhpcy50cmFuc3BvcnRSZWNvdmVyeVRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KFxuICAgIGZ1bmN0aW9uKCl7XG4gICAgICB1YS50cmFuc3BvcnRSZWNvdmVyQXR0ZW1wdHMgPSBjb3VudCArIDE7XG4gICAgICBuZXcgU0lQLlRyYW5zcG9ydCh1YSwgc2VydmVyKTtcbiAgICB9LCBuZXh0UmV0cnkgKiAxMDAwKTtcbn07XG5cbmZ1bmN0aW9uIGNoZWNrQXV0aGVudGljYXRpb25GYWN0b3J5IChhdXRoZW50aWNhdGlvbkZhY3RvcnkpIHtcbiAgaWYgKCEoYXV0aGVudGljYXRpb25GYWN0b3J5IGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghYXV0aGVudGljYXRpb25GYWN0b3J5LmluaXRpYWxpemUpIHtcbiAgICBhdXRoZW50aWNhdGlvbkZhY3RvcnkuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIGluaXRpYWxpemUgKCkge1xuICAgICAgcmV0dXJuIFNJUC5VdGlscy5Qcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBhdXRoZW50aWNhdGlvbkZhY3Rvcnk7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBsb2FkLlxuICogQHByaXZhdGVcbiAqIHJldHVybnMge0Jvb2xlYW59XG4gKi9cblVBLnByb3RvdHlwZS5sb2FkQ29uZmlnID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbikge1xuICAvLyBTZXR0aW5ncyBhbmQgZGVmYXVsdCB2YWx1ZXNcbiAgdmFyIHBhcmFtZXRlciwgdmFsdWUsIGNoZWNrZWRfdmFsdWUsIGhvc3Rwb3J0UGFyYW1zLCByZWdpc3RyYXJTZXJ2ZXIsXG4gICAgc2V0dGluZ3MgPSB7XG4gICAgICAvKiBIb3N0IGFkZHJlc3NcbiAgICAgICogVmFsdWUgdG8gYmUgc2V0IGluIFZpYSBzZW50X2J5IGFuZCBob3N0IHBhcnQgb2YgQ29udGFjdCBGUUROXG4gICAgICAqL1xuICAgICAgdmlhSG9zdDogU0lQLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDEyKSArICcuaW52YWxpZCcsXG5cbiAgICAgIHVyaTogbmV3IFNJUC5VUkkoJ3NpcCcsICdhbm9ueW1vdXMuJyArIFNJUC5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbig2KSwgJ2Fub255bW91cy5pbnZhbGlkJywgbnVsbCwgbnVsbCksXG4gICAgICB3c1NlcnZlcnM6IFt7XG4gICAgICAgIHNjaGVtZTogJ1dTUycsXG4gICAgICAgIHNpcF91cmk6ICc8c2lwOmVkZ2Uuc2lwLm9uc2lwLmNvbTt0cmFuc3BvcnQ9d3M7bHI+JyxcbiAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICB3ZWlnaHQ6IDAsXG4gICAgICAgIHdzX3VyaTogJ3dzczovL2VkZ2Uuc2lwLm9uc2lwLmNvbSdcbiAgICAgIH1dLFxuXG4gICAgICAvLyBQYXNzd29yZFxuICAgICAgcGFzc3dvcmQ6IG51bGwsXG5cbiAgICAgIC8vIFJlZ2lzdHJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICByZWdpc3RlckV4cGlyZXM6IDYwMCxcbiAgICAgIHJlZ2lzdGVyOiB0cnVlLFxuICAgICAgcmVnaXN0cmFyU2VydmVyOiBudWxsLFxuXG4gICAgICAvLyBUcmFuc3BvcnQgcmVsYXRlZCBwYXJhbWV0ZXJzXG4gICAgICB3c1NlcnZlck1heFJlY29ubmVjdGlvbjogMyxcbiAgICAgIHdzU2VydmVyUmVjb25uZWN0aW9uVGltZW91dDogNCxcblxuICAgICAgY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWw6IDIsXG4gICAgICBjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbDogMzAsXG5cbiAgICAgIGtlZXBBbGl2ZUludGVydmFsOiAwLFxuXG4gICAgICBleHRyYVN1cHBvcnRlZDogW10sXG5cbiAgICAgIHVzZVByZWxvYWRlZFJvdXRlOiBmYWxzZSxcblxuICAgICAgLy9zdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgaW50byBVc2VyLUFnZW50IHJlcXVlc3QgaGVhZGVyXG4gICAgICB1c2VyQWdlbnRTdHJpbmc6IFNJUC5DLlVTRVJfQUdFTlQsXG5cbiAgICAgIC8vIFNlc3Npb24gcGFyYW1ldGVyc1xuICAgICAgaWNlQ2hlY2tpbmdUaW1lb3V0OiA1MDAwLFxuICAgICAgbm9BbnN3ZXJUaW1lb3V0OiA2MCxcbiAgICAgIHN0dW5TZXJ2ZXJzOiBbJ3N0dW46c3R1bi5sLmdvb2dsZS5jb206MTkzMDInXSxcbiAgICAgIHR1cm5TZXJ2ZXJzOiBbXSxcblxuICAgICAgLy8gTG9nZ2luZyBwYXJhbWV0ZXJzXG4gICAgICB0cmFjZVNpcDogZmFsc2UsXG5cbiAgICAgIC8vIEhhY2tzXG4gICAgICBoYWNrVmlhVGNwOiBmYWxzZSxcbiAgICAgIGhhY2tJcEluQ29udGFjdDogZmFsc2UsXG4gICAgICBoYWNrV3NzSW5UcmFuc3BvcnQ6IGZhbHNlLFxuICAgICAgaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFnczogZmFsc2UsXG5cbiAgICAgIGNvbnRhY3RUcmFuc3BvcnQ6ICd3cycsXG4gICAgICBmb3JjZVJwb3J0OiBmYWxzZSxcblxuICAgICAgLy9hdXRvc3RhcnRpbmdcbiAgICAgIGF1dG9zdGFydDogdHJ1ZSxcblxuICAgICAgLy9SZWxpYWJsZSBQcm92aXNpb25hbCBSZXNwb25zZXNcbiAgICAgIHJlbDEwMDogU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVELFxuXG4gICAgICAvLyBSZXBsYWNlcyBoZWFkZXIgKFJGQyAzODkxKVxuICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzg5MVxuICAgICAgcmVwbGFjZXM6IFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRCxcblxuICAgICAgbWVkaWFIYW5kbGVyRmFjdG9yeTogU0lQLldlYlJUQy5NZWRpYUhhbmRsZXIuZGVmYXVsdEZhY3RvcnksXG5cbiAgICAgIGF1dGhlbnRpY2F0aW9uRmFjdG9yeTogY2hlY2tBdXRoZW50aWNhdGlvbkZhY3RvcnkoZnVuY3Rpb24gYXV0aGVudGljYXRpb25GYWN0b3J5ICh1YSkge1xuICAgICAgICByZXR1cm4gbmV3IFNJUC5EaWdlc3RBdXRoZW50aWNhdGlvbih1YSk7XG4gICAgICB9KVxuICAgIH07XG5cbiAgLy8gUHJlLUNvbmZpZ3VyYXRpb25cbiAgZnVuY3Rpb24gYWxpYXNVbmRlcnNjb3JlZCAocGFyYW1ldGVyLCBsb2dnZXIpIHtcbiAgICB2YXIgdW5kZXJzY29yZWQgPSBwYXJhbWV0ZXIucmVwbGFjZSgvKFthLXpdW0EtWl0pL2csIGZ1bmN0aW9uIChtKSB7XG4gICAgICByZXR1cm4gbVswXSArICdfJyArIG1bMV0udG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIGlmIChwYXJhbWV0ZXIgPT09IHVuZGVyc2NvcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhhc1BhcmFtZXRlciA9IGNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKTtcbiAgICBpZiAoY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eSh1bmRlcnNjb3JlZCkpIHtcbiAgICAgIGxvZ2dlci53YXJuKHVuZGVyc2NvcmVkICsgJyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlICcgKyBwYXJhbWV0ZXIpO1xuICAgICAgaWYgKGhhc1BhcmFtZXRlcikge1xuICAgICAgICBsb2dnZXIud2FybihwYXJhbWV0ZXIgKyAnIG92ZXJyaWRpbmcgJyArIHVuZGVyc2NvcmVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25maWd1cmF0aW9uW3BhcmFtZXRlcl0gPSBoYXNQYXJhbWV0ZXIgPyBjb25maWd1cmF0aW9uW3BhcmFtZXRlcl0gOiBjb25maWd1cmF0aW9uW3VuZGVyc2NvcmVkXTtcbiAgfVxuXG4gIC8vIENoZWNrIE1hbmRhdG9yeSBwYXJhbWV0ZXJzXG4gIGZvcihwYXJhbWV0ZXIgaW4gVUEuY29uZmlndXJhdGlvbl9jaGVjay5tYW5kYXRvcnkpIHtcbiAgICBhbGlhc1VuZGVyc2NvcmVkKHBhcmFtZXRlciwgdGhpcy5sb2dnZXIpO1xuICAgIGlmKCFjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KHBhcmFtZXRlcikpIHtcbiAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IocGFyYW1ldGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBjb25maWd1cmF0aW9uW3BhcmFtZXRlcl07XG4gICAgICBjaGVja2VkX3ZhbHVlID0gVUEuY29uZmlndXJhdGlvbl9jaGVjay5tYW5kYXRvcnlbcGFyYW1ldGVyXSh2YWx1ZSk7XG4gICAgICBpZiAoY2hlY2tlZF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldHRpbmdzW3BhcmFtZXRlcl0gPSBjaGVja2VkX3ZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcihwYXJhbWV0ZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBTSVAuVXRpbHMub3B0aW9uc092ZXJyaWRlKGNvbmZpZ3VyYXRpb24sICdyZWwxMDAnLCAncmVsaWFibGUnLCB0cnVlLCB0aGlzLmxvZ2dlciwgU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEKTtcblxuICB2YXIgZW1wdHlBcnJheXNBbGxvd2VkID0gWydzdHVuU2VydmVycycsICd0dXJuU2VydmVycyddO1xuXG4gIC8vIENoZWNrIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgZm9yKHBhcmFtZXRlciBpbiBVQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsKSB7XG4gICAgYWxpYXNVbmRlcnNjb3JlZChwYXJhbWV0ZXIsIHRoaXMubG9nZ2VyKTtcbiAgICBpZihjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KHBhcmFtZXRlcikpIHtcbiAgICAgIHZhbHVlID0gY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdO1xuXG4gICAgICAvLyBJZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIGFuIGVtcHR5IGFycmF5LCBidXQgc2hvdWxkbid0IGJlLCBhcHBseSBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCAmJiBlbXB0eUFycmF5c0FsbG93ZWQuaW5kZXhPZihwYXJhbWV0ZXIpIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgICAvLyBJZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG51bGwsIGVtcHR5IHN0cmluZywgb3IgdW5kZWZpbmVkIHRoZW4gYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICBpZih2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7IGNvbnRpbnVlOyB9XG4gICAgICAvLyBJZiBpdCdzIGEgbnVtYmVyIHdpdGggTmFOIHZhbHVlIHRoZW4gYWxzbyBhcHBseSBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgIC8vIE5PVEU6IEpTIGRvZXMgbm90IGFsbG93IFwidmFsdWUgPT09IE5hTlwiLCB0aGUgZm9sbG93aW5nIGRvZXMgdGhlIHdvcms6XG4gICAgICBlbHNlIGlmKHR5cGVvZih2YWx1ZSkgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICBjaGVja2VkX3ZhbHVlID0gVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFtwYXJhbWV0ZXJdKHZhbHVlKTtcbiAgICAgIGlmIChjaGVja2VkX3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0dGluZ3NbcGFyYW1ldGVyXSA9IGNoZWNrZWRfdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlciwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNhbml0eSBDaGVja3NcblxuICAvLyBDb25uZWN0aW9uIHJlY292ZXJ5IGludGVydmFsc1xuICBpZihzZXR0aW5ncy5jb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCA8IHNldHRpbmdzLmNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsKSB7XG4gICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcignY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWwnLCBzZXR0aW5ncy5jb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCk7XG4gIH1cblxuICAvLyBQb3N0IENvbmZpZ3VyYXRpb24gUHJvY2Vzc1xuXG4gIC8vIEFsbG93IHBhc3NpbmcgMCBudW1iZXIgYXMgZGlzcGxheU5hbWUuXG4gIGlmIChzZXR0aW5ncy5kaXNwbGF5TmFtZSA9PT0gMCkge1xuICAgIHNldHRpbmdzLmRpc3BsYXlOYW1lID0gJzAnO1xuICB9XG5cbiAgLy8gSW5zdGFuY2UtaWQgZm9yIEdSVVVcbiAgaWYgKCFzZXR0aW5ncy5pbnN0YW5jZUlkKSB7XG4gICAgc2V0dGluZ3MuaW5zdGFuY2VJZCA9IFNJUC5VdGlscy5uZXdVVUlEKCk7XG4gIH1cblxuICAvLyBzaXBqc0lkIGluc3RhbmNlIHBhcmFtZXRlci4gU3RhdGljIHJhbmRvbSB0YWcgb2YgbGVuZ3RoIDVcbiAgc2V0dGluZ3Muc2lwanNJZCA9IFNJUC5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbig1KTtcblxuICAvLyBTdHJpbmcgY29udGFpbmluZyBzZXR0aW5ncy51cmkgd2l0aG91dCBzY2hlbWUgYW5kIHVzZXIuXG4gIGhvc3Rwb3J0UGFyYW1zID0gc2V0dGluZ3MudXJpLmNsb25lKCk7XG4gIGhvc3Rwb3J0UGFyYW1zLnVzZXIgPSBudWxsO1xuICBzZXR0aW5ncy5ob3N0cG9ydFBhcmFtcyA9IGhvc3Rwb3J0UGFyYW1zLnRvUmF3KCkucmVwbGFjZSgvXnNpcDovaSwgJycpO1xuXG4gIC8qIENoZWNrIHdoZXRoZXIgYXV0aG9yaXphdGlvblVzZXIgaXMgZXhwbGljaXRseSBkZWZpbmVkLlxuICAgKiBUYWtlICdzZXR0aW5ncy51cmkudXNlcicgdmFsdWUgaWYgbm90LlxuICAgKi9cbiAgaWYgKCFzZXR0aW5ncy5hdXRob3JpemF0aW9uVXNlcikge1xuICAgIHNldHRpbmdzLmF1dGhvcml6YXRpb25Vc2VyID0gc2V0dGluZ3MudXJpLnVzZXI7XG4gIH1cblxuICAvKiBJZiBubyAncmVnaXN0cmFyU2VydmVyJyBpcyBzZXQgdXNlIHRoZSAndXJpJyB2YWx1ZSB3aXRob3V0IHVzZXIgcG9ydGlvbi4gKi9cbiAgaWYgKCFzZXR0aW5ncy5yZWdpc3RyYXJTZXJ2ZXIpIHtcbiAgICByZWdpc3RyYXJTZXJ2ZXIgPSBzZXR0aW5ncy51cmkuY2xvbmUoKTtcbiAgICByZWdpc3RyYXJTZXJ2ZXIudXNlciA9IG51bGw7XG4gICAgc2V0dGluZ3MucmVnaXN0cmFyU2VydmVyID0gcmVnaXN0cmFyU2VydmVyO1xuICB9XG5cbiAgLy8gVXNlciBub0Fuc3dlclRpbWVvdXRcbiAgc2V0dGluZ3Mubm9BbnN3ZXJUaW1lb3V0ID0gc2V0dGluZ3Mubm9BbnN3ZXJUaW1lb3V0ICogMTAwMDtcblxuICAvLyBWaWEgSG9zdFxuICBpZiAoc2V0dGluZ3MuaGFja0lwSW5Db250YWN0KSB7XG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5oYWNrSXBJbkNvbnRhY3QgPT09ICdib29sZWFuJykge1xuICAgICAgc2V0dGluZ3MudmlhSG9zdCA9IFNJUC5VdGlscy5nZXRSYW5kb21UZXN0TmV0SVAoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNldHRpbmdzLmhhY2tJcEluQ29udGFjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNldHRpbmdzLnZpYUhvc3QgPSBzZXR0aW5ncy5oYWNrSXBJbkNvbnRhY3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29udGFjdCB0cmFuc3BvcnQgcGFyYW1ldGVyXG4gIGlmIChzZXR0aW5ncy5oYWNrV3NzSW5UcmFuc3BvcnQpIHtcbiAgICBzZXR0aW5ncy5jb250YWN0VHJhbnNwb3J0ID0gJ3dzcyc7XG4gIH1cblxuICB0aGlzLmNvbnRhY3QgPSB7XG4gICAgcHViX2dydXU6IG51bGwsXG4gICAgdGVtcF9ncnV1OiBudWxsLFxuICAgIHVyaTogbmV3IFNJUC5VUkkoJ3NpcCcsIFNJUC5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbig4KSwgc2V0dGluZ3MudmlhSG9zdCwgbnVsbCwge3RyYW5zcG9ydDogc2V0dGluZ3MuY29udGFjdFRyYW5zcG9ydH0pLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihvcHRpb25zKXtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICB2YXJcbiAgICAgICAgYW5vbnltb3VzID0gb3B0aW9ucy5hbm9ueW1vdXMgfHwgbnVsbCxcbiAgICAgICAgb3V0Ym91bmQgPSBvcHRpb25zLm91dGJvdW5kIHx8IG51bGwsXG4gICAgICAgIGNvbnRhY3QgPSAnPCc7XG5cbiAgICAgIGlmIChhbm9ueW1vdXMpIHtcbiAgICAgICAgY29udGFjdCArPSAodGhpcy50ZW1wX2dydXUgfHwgKCdzaXA6YW5vbnltb3VzQGFub255bW91cy5pbnZhbGlkO3RyYW5zcG9ydD0nK3NldHRpbmdzLmNvbnRhY3RUcmFuc3BvcnQpKS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFjdCArPSAodGhpcy5wdWJfZ3J1dSB8fCB0aGlzLnVyaSkudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG91dGJvdW5kKSB7XG4gICAgICAgIGNvbnRhY3QgKz0gJztvYic7XG4gICAgICB9XG5cbiAgICAgIGNvbnRhY3QgKz0gJz4nO1xuXG4gICAgICByZXR1cm4gY29udGFjdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gbWVkaWEgb3ZlcnJpZGVzIG1lZGlhQ29uc3RyYWludHNcbiAgU0lQLlV0aWxzLm9wdGlvbnNPdmVycmlkZShzZXR0aW5ncywgJ21lZGlhJywgJ21lZGlhQ29uc3RyYWludHMnLCB0cnVlLCB0aGlzLmxvZ2dlcik7XG5cbiAgLy8gRmlsbCB0aGUgdmFsdWUgb2YgdGhlIGNvbmZpZ3VyYXRpb25fc2tlbGV0b25cbiAgZm9yKHBhcmFtZXRlciBpbiBzZXR0aW5ncykge1xuICAgIFVBLmNvbmZpZ3VyYXRpb25fc2tlbGV0b25bcGFyYW1ldGVyXS52YWx1ZSA9IHNldHRpbmdzW3BhcmFtZXRlcl07XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLmNvbmZpZ3VyYXRpb24sIFVBLmNvbmZpZ3VyYXRpb25fc2tlbGV0b24pO1xuXG4gIC8vIENsZWFuIFVBLmNvbmZpZ3VyYXRpb25fc2tlbGV0b25cbiAgZm9yKHBhcmFtZXRlciBpbiBzZXR0aW5ncykge1xuICAgIFVBLmNvbmZpZ3VyYXRpb25fc2tlbGV0b25bcGFyYW1ldGVyXS52YWx1ZSA9ICcnO1xuICB9XG5cbiAgdGhpcy5sb2dnZXIubG9nKCdjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgYWZ0ZXIgdmFsaWRhdGlvbjonKTtcbiAgZm9yKHBhcmFtZXRlciBpbiBzZXR0aW5ncykge1xuICAgIHN3aXRjaChwYXJhbWV0ZXIpIHtcbiAgICAgIGNhc2UgJ3VyaSc6XG4gICAgICBjYXNlICdyZWdpc3RyYXJTZXJ2ZXInOlxuICAgICAgY2FzZSAnbWVkaWFIYW5kbGVyRmFjdG9yeSc6XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnwrcgJyArIHBhcmFtZXRlciArICc6ICcgKyBzZXR0aW5nc1twYXJhbWV0ZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwYXNzd29yZCc6XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnwrcgJyArIHBhcmFtZXRlciArICc6ICcgKyAnTk9UIFNIT1dOJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCfCtyAnICsgcGFyYW1ldGVyICsgJzogJyArIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzW3BhcmFtZXRlcl0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm47XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gT2JqZWN0IHNrZWxldG9uLlxuICogQHByaXZhdGVcbiAqL1xuVUEuY29uZmlndXJhdGlvbl9za2VsZXRvbiA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGlkeCwgIHBhcmFtZXRlcixcbiAgICBza2VsZXRvbiA9IHt9LFxuICAgIHBhcmFtZXRlcnMgPSBbXG4gICAgICAvLyBJbnRlcm5hbCBwYXJhbWV0ZXJzXG4gICAgICBcInNpcGpzSWRcIixcbiAgICAgIFwiaG9zdHBvcnRQYXJhbXNcIixcblxuICAgICAgLy8gT3B0aW9uYWwgdXNlciBjb25maWd1cmFibGUgcGFyYW1ldGVyc1xuICAgICAgXCJ1cmlcIixcbiAgICAgIFwid3NTZXJ2ZXJzXCIsXG4gICAgICBcImF1dGhvcml6YXRpb25Vc2VyXCIsXG4gICAgICBcImNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsXCIsXG4gICAgICBcImNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsXCIsXG4gICAgICBcImtlZXBBbGl2ZUludGVydmFsXCIsXG4gICAgICBcImV4dHJhU3VwcG9ydGVkXCIsXG4gICAgICBcImRpc3BsYXlOYW1lXCIsXG4gICAgICBcImhhY2tWaWFUY3BcIiwgLy8gZmFsc2UuXG4gICAgICBcImhhY2tJcEluQ29udGFjdFwiLCAvL2ZhbHNlXG4gICAgICBcImhhY2tXc3NJblRyYW5zcG9ydFwiLCAvL2ZhbHNlXG4gICAgICBcImhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3NcIiwgLy9mYWxzZVxuICAgICAgXCJjb250YWN0VHJhbnNwb3J0XCIsIC8vICd3cydcbiAgICAgIFwiZm9yY2VScG9ydFwiLCAvLyBmYWxzZVxuICAgICAgXCJpY2VDaGVja2luZ1RpbWVvdXRcIixcbiAgICAgIFwiaW5zdGFuY2VJZFwiLFxuICAgICAgXCJub0Fuc3dlclRpbWVvdXRcIiwgLy8gMzAgc2Vjb25kcy5cbiAgICAgIFwicGFzc3dvcmRcIixcbiAgICAgIFwicmVnaXN0ZXJFeHBpcmVzXCIsIC8vIDYwMCBzZWNvbmRzLlxuICAgICAgXCJyZWdpc3RyYXJTZXJ2ZXJcIixcbiAgICAgIFwicmVsaWFibGVcIixcbiAgICAgIFwicmVsMTAwXCIsXG4gICAgICBcInJlcGxhY2VzXCIsXG4gICAgICBcInVzZXJBZ2VudFN0cmluZ1wiLCAvL1NJUC5DLlVTRVJfQUdFTlRcbiAgICAgIFwiYXV0b3N0YXJ0XCIsXG4gICAgICBcInN0dW5TZXJ2ZXJzXCIsXG4gICAgICBcInRyYWNlU2lwXCIsXG4gICAgICBcInR1cm5TZXJ2ZXJzXCIsXG4gICAgICBcInVzZVByZWxvYWRlZFJvdXRlXCIsXG4gICAgICBcIndzU2VydmVyTWF4UmVjb25uZWN0aW9uXCIsXG4gICAgICBcIndzU2VydmVyUmVjb25uZWN0aW9uVGltZW91dFwiLFxuICAgICAgXCJtZWRpYUhhbmRsZXJGYWN0b3J5XCIsXG4gICAgICBcIm1lZGlhXCIsXG4gICAgICBcIm1lZGlhQ29uc3RyYWludHNcIixcbiAgICAgIFwiYXV0aGVudGljYXRpb25GYWN0b3J5XCIsXG5cbiAgICAgIC8vIFBvc3QtY29uZmlndXJhdGlvbiBnZW5lcmF0ZWQgcGFyYW1ldGVyc1xuICAgICAgXCJ2aWFfY29yZV92YWx1ZVwiLFxuICAgICAgXCJ2aWFIb3N0XCJcbiAgICBdO1xuXG4gIGZvcihpZHggaW4gcGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlciA9IHBhcmFtZXRlcnNbaWR4XTtcbiAgICBza2VsZXRvbltwYXJhbWV0ZXJdID0ge1xuICAgICAgdmFsdWU6ICcnLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBza2VsZXRvblsncmVnaXN0ZXInXSA9IHtcbiAgICB2YWx1ZTogJycsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9O1xuXG4gIHJldHVybiBza2VsZXRvbjtcbn0oKSk7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBjaGVja2VyLlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblVBLmNvbmZpZ3VyYXRpb25fY2hlY2sgPSB7XG4gIG1hbmRhdG9yeToge1xuICB9LFxuXG4gIG9wdGlvbmFsOiB7XG5cbiAgICB1cmk6IGZ1bmN0aW9uKHVyaSkge1xuICAgICAgdmFyIHBhcnNlZDtcblxuICAgICAgaWYgKCEoL15zaXA6L2kpLnRlc3QodXJpKSkge1xuICAgICAgICB1cmkgPSBTSVAuQy5TSVAgKyAnOicgKyB1cmk7XG4gICAgICB9XG4gICAgICBwYXJzZWQgPSBTSVAuVVJJLnBhcnNlKHVyaSk7XG5cbiAgICAgIGlmKCFwYXJzZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmKCFwYXJzZWQudXNlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvL05vdGU6IHRoaXMgZnVuY3Rpb24gdXNlZCB0byBjYWxsICd0aGlzLmxvZ2dlci5lcnJvcicgYnV0IGNhbGxpbmcgJ3RoaXMnIHdpdGggYW55dGhpbmcgaGVyZSBpcyBpbnZhbGlkXG4gICAgd3NTZXJ2ZXJzOiBmdW5jdGlvbih3c1NlcnZlcnMpIHtcbiAgICAgIHZhciBpZHgsIGxlbmd0aCwgdXJsO1xuXG4gICAgICAvKiBBbGxvdyBkZWZpbmluZyB3c1NlcnZlcnMgcGFyYW1ldGVyIGFzOlxuICAgICAgICogIFN0cmluZzogXCJob3N0XCJcbiAgICAgICAqICBBcnJheSBvZiBTdHJpbmdzOiBbXCJob3N0MVwiLCBcImhvc3QyXCJdXG4gICAgICAgKiAgQXJyYXkgb2YgT2JqZWN0czogW3t3c191cmk6XCJob3N0MVwiLCB3ZWlnaHQ6MX0sIHt3c191cmk6XCJob3N0MlwiLCB3ZWlnaHQ6MH1dXG4gICAgICAgKiAgQXJyYXkgb2YgT2JqZWN0cyBhbmQgU3RyaW5nczogW3t3c191cmk6XCJob3N0MVwifSwgXCJob3N0MlwiXVxuICAgICAgICovXG4gICAgICBpZiAodHlwZW9mIHdzU2VydmVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgd3NTZXJ2ZXJzID0gW3t3c191cmk6IHdzU2VydmVyc31dO1xuICAgICAgfSBlbHNlIGlmICh3c1NlcnZlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBsZW5ndGggPSB3c1NlcnZlcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdzU2VydmVyc1tpZHhdID09PSAnc3RyaW5nJyl7XG4gICAgICAgICAgICB3c1NlcnZlcnNbaWR4XSA9IHt3c191cmk6IHdzU2VydmVyc1tpZHhdfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHdzU2VydmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSB3c1NlcnZlcnMubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmICghd3NTZXJ2ZXJzW2lkeF0ud3NfdXJpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3c1NlcnZlcnNbaWR4XS53ZWlnaHQgJiYgIU51bWJlcih3c1NlcnZlcnNbaWR4XS53ZWlnaHQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsID0gU0lQLkdyYW1tYXIucGFyc2Uod3NTZXJ2ZXJzW2lkeF0ud3NfdXJpLCAnYWJzb2x1dGVVUkknKTtcblxuICAgICAgICBpZih1cmwgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYoWyd3c3MnLCAnd3MnLCAndWRwJ10uaW5kZXhPZih1cmwuc2NoZW1lKSA8IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd3NTZXJ2ZXJzW2lkeF0uc2lwX3VyaSA9ICc8c2lwOicgKyB1cmwuaG9zdCArICh1cmwucG9ydCA/ICc6JyArIHVybC5wb3J0IDogJycpICsgJzt0cmFuc3BvcnQ9JyArIHVybC5zY2hlbWUucmVwbGFjZSgvXndzcyQvaSwgJ3dzJykgKyAnO2xyPic7XG5cbiAgICAgICAgICBpZiAoIXdzU2VydmVyc1tpZHhdLndlaWdodCkge1xuICAgICAgICAgICAgd3NTZXJ2ZXJzW2lkeF0ud2VpZ2h0ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3c1NlcnZlcnNbaWR4XS5zdGF0dXMgPSAwO1xuICAgICAgICAgIHdzU2VydmVyc1tpZHhdLnNjaGVtZSA9IHVybC5zY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHdzU2VydmVycztcbiAgICB9LFxuXG4gICAgYXV0aG9yaXphdGlvblVzZXI6IGZ1bmN0aW9uKGF1dGhvcml6YXRpb25Vc2VyKSB7XG4gICAgICBpZihTSVAuR3JhbW1hci5wYXJzZSgnXCInKyBhdXRob3JpemF0aW9uVXNlciArJ1wiJywgJ3F1b3RlZF9zdHJpbmcnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF1dGhvcml6YXRpb25Vc2VyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbDogZnVuY3Rpb24oY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmKFNJUC5VdGlscy5pc0RlY2ltYWwoY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWwpKSB7XG4gICAgICAgIHZhbHVlID0gTnVtYmVyKGNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsKTtcbiAgICAgICAgaWYodmFsdWUgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsOiBmdW5jdGlvbihjb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbCkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYoU0lQLlV0aWxzLmlzRGVjaW1hbChjb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbCkpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIoY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWwpO1xuICAgICAgICBpZih2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uKGRpc3BsYXlOYW1lKSB7XG4gICAgICBpZihTSVAuR3JhbW1hci5wYXJzZSgnXCInICsgZGlzcGxheU5hbWUgKyAnXCInLCAnZGlzcGxheU5hbWUnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYWNrVmlhVGNwOiBmdW5jdGlvbihoYWNrVmlhVGNwKSB7XG4gICAgICBpZiAodHlwZW9mIGhhY2tWaWFUY3AgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gaGFja1ZpYVRjcDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFja0lwSW5Db250YWN0OiBmdW5jdGlvbihoYWNrSXBJbkNvbnRhY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFja0lwSW5Db250YWN0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGhhY2tJcEluQ29udGFjdDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBoYWNrSXBJbkNvbnRhY3QgPT09ICdzdHJpbmcnICYmIFNJUC5HcmFtbWFyLnBhcnNlKGhhY2tJcEluQ29udGFjdCwgJ2hvc3QnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGhhY2tJcEluQ29udGFjdDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaWNlQ2hlY2tpbmdUaW1lb3V0OiBmdW5jdGlvbihpY2VDaGVja2luZ1RpbWVvdXQpIHtcbiAgICAgIGlmKFNJUC5VdGlscy5pc0RlY2ltYWwoaWNlQ2hlY2tpbmdUaW1lb3V0KSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoNTAwLCBpY2VDaGVja2luZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYWNrV3NzSW5UcmFuc3BvcnQ6IGZ1bmN0aW9uKGhhY2tXc3NJblRyYW5zcG9ydCkge1xuICAgICAgaWYgKHR5cGVvZiBoYWNrV3NzSW5UcmFuc3BvcnQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gaGFja1dzc0luVHJhbnNwb3J0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzOiBmdW5jdGlvbihoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzKSB7XG4gICAgICBpZiAodHlwZW9mIGhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3MgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29udGFjdFRyYW5zcG9ydDogZnVuY3Rpb24oY29udGFjdFRyYW5zcG9ydCkge1xuICAgICAgaWYgKHR5cGVvZiBjb250YWN0VHJhbnNwb3J0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY29udGFjdFRyYW5zcG9ydDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZm9yY2VScG9ydDogZnVuY3Rpb24oZm9yY2VScG9ydCkge1xuICAgICAgaWYgKHR5cGVvZiBmb3JjZVJwb3J0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlUnBvcnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluc3RhbmNlSWQ6IGZ1bmN0aW9uKGluc3RhbmNlSWQpIHtcbiAgICAgIGlmKHR5cGVvZiBpbnN0YW5jZUlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICgoL151dWlkOi9pLnRlc3QoaW5zdGFuY2VJZCkpKSB7XG4gICAgICAgIGluc3RhbmNlSWQgPSBpbnN0YW5jZUlkLnN1YnN0cig1KTtcbiAgICAgIH1cblxuICAgICAgaWYoU0lQLkdyYW1tYXIucGFyc2UoaW5zdGFuY2VJZCwgJ3V1aWQnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlSWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGtlZXBBbGl2ZUludGVydmFsOiBmdW5jdGlvbihrZWVwQWxpdmVJbnRlcnZhbCkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKFNJUC5VdGlscy5pc0RlY2ltYWwoa2VlcEFsaXZlSW50ZXJ2YWwpKSB7XG4gICAgICAgIHZhbHVlID0gTnVtYmVyKGtlZXBBbGl2ZUludGVydmFsKTtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBleHRyYVN1cHBvcnRlZDogZnVuY3Rpb24ob3B0aW9uVGFncykge1xuICAgICAgdmFyIGlkeCwgbGVuZ3RoO1xuXG4gICAgICBpZiAoIShvcHRpb25UYWdzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoID0gb3B0aW9uVGFncy5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25UYWdzW2lkeF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25UYWdzO1xuICAgIH0sXG5cbiAgICBub0Fuc3dlclRpbWVvdXQ6IGZ1bmN0aW9uKG5vQW5zd2VyVGltZW91dCkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKFNJUC5VdGlscy5pc0RlY2ltYWwobm9BbnN3ZXJUaW1lb3V0KSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcihub0Fuc3dlclRpbWVvdXQpO1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHBhc3N3b3JkOiBmdW5jdGlvbihwYXNzd29yZCkge1xuICAgICAgcmV0dXJuIFN0cmluZyhwYXNzd29yZCk7XG4gICAgfSxcblxuICAgIHJlbDEwMDogZnVuY3Rpb24ocmVsMTAwKSB7XG4gICAgICBpZihyZWwxMDAgPT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgICAgICByZXR1cm4gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEO1xuICAgICAgfSBlbHNlIGlmIChyZWwxMDAgPT09IFNJUC5DLnN1cHBvcnRlZC5TVVBQT1JURUQpIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLnN1cHBvcnRlZC5TVVBQT1JURUQ7XG4gICAgICB9IGVsc2UgIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVwbGFjZXM6IGZ1bmN0aW9uKHJlcGxhY2VzKSB7XG4gICAgICBpZihyZXBsYWNlcyA9PT0gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSB7XG4gICAgICAgIHJldHVybiBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQ7XG4gICAgICB9IGVsc2UgaWYgKHJlcGxhY2VzID09PSBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgICAgIHJldHVybiBTSVAuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEO1xuICAgICAgfSBlbHNlICB7XG4gICAgICAgIHJldHVybiBTSVAuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihyZWdpc3Rlcikge1xuICAgICAgaWYgKHR5cGVvZiByZWdpc3RlciA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiByZWdpc3RlcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJFeHBpcmVzOiBmdW5jdGlvbihyZWdpc3RlckV4cGlyZXMpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChTSVAuVXRpbHMuaXNEZWNpbWFsKHJlZ2lzdGVyRXhwaXJlcykpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIocmVnaXN0ZXJFeHBpcmVzKTtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZWdpc3RyYXJTZXJ2ZXI6IGZ1bmN0aW9uKHJlZ2lzdHJhclNlcnZlcikge1xuICAgICAgdmFyIHBhcnNlZDtcblxuICAgICAgaWYodHlwZW9mIHJlZ2lzdHJhclNlcnZlciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIS9ec2lwOi9pLnRlc3QocmVnaXN0cmFyU2VydmVyKSkge1xuICAgICAgICByZWdpc3RyYXJTZXJ2ZXIgPSBTSVAuQy5TSVAgKyAnOicgKyByZWdpc3RyYXJTZXJ2ZXI7XG4gICAgICB9XG4gICAgICBwYXJzZWQgPSBTSVAuVVJJLnBhcnNlKHJlZ2lzdHJhclNlcnZlcik7XG5cbiAgICAgIGlmKCFwYXJzZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmKHBhcnNlZC51c2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0dW5TZXJ2ZXJzOiBmdW5jdGlvbihzdHVuU2VydmVycykge1xuICAgICAgdmFyIGlkeCwgbGVuZ3RoLCBzdHVuX3NlcnZlcjtcblxuICAgICAgaWYgKHR5cGVvZiBzdHVuU2VydmVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3R1blNlcnZlcnMgPSBbc3R1blNlcnZlcnNdO1xuICAgICAgfSBlbHNlIGlmICghKHN0dW5TZXJ2ZXJzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoID0gc3R1blNlcnZlcnMubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHN0dW5fc2VydmVyID0gc3R1blNlcnZlcnNbaWR4XTtcbiAgICAgICAgaWYgKCEoL15zdHVucz86Ly50ZXN0KHN0dW5fc2VydmVyKSkpIHtcbiAgICAgICAgICBzdHVuX3NlcnZlciA9ICdzdHVuOicgKyBzdHVuX3NlcnZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKFNJUC5HcmFtbWFyLnBhcnNlKHN0dW5fc2VydmVyLCAnc3R1bl9VUkknKSA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R1blNlcnZlcnNbaWR4XSA9IHN0dW5fc2VydmVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R1blNlcnZlcnM7XG4gICAgfSxcblxuICAgIHRyYWNlU2lwOiBmdW5jdGlvbih0cmFjZVNpcCkge1xuICAgICAgaWYgKHR5cGVvZiB0cmFjZVNpcCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB0cmFjZVNpcDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdHVyblNlcnZlcnM6IGZ1bmN0aW9uKHR1cm5TZXJ2ZXJzKSB7XG4gICAgICB2YXIgaWR4LCBqZHgsIGxlbmd0aCwgdHVybl9zZXJ2ZXIsIG51bV90dXJuX3NlcnZlcl91cmxzLCB1cmw7XG5cbiAgICAgIGlmICh0dXJuU2VydmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR1cm5TZXJ2ZXJzID0gW3R1cm5TZXJ2ZXJzXTtcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoID0gdHVyblNlcnZlcnMubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHR1cm5fc2VydmVyID0gdHVyblNlcnZlcnNbaWR4XTtcbiAgICAgICAgLy9CYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogQWxsb3cgZGVmaW5pbmcgdGhlIHR1cm5fc2VydmVyIHVybCB3aXRoIHRoZSAnc2VydmVyJyBwcm9wZXJ0eS5cbiAgICAgICAgaWYgKHR1cm5fc2VydmVyLnNlcnZlcikge1xuICAgICAgICAgIHR1cm5fc2VydmVyLnVybHMgPSBbdHVybl9zZXJ2ZXIuc2VydmVyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHVybl9zZXJ2ZXIudXJscyB8fCAhdHVybl9zZXJ2ZXIudXNlcm5hbWUgfHwgIXR1cm5fc2VydmVyLnBhc3N3b3JkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR1cm5fc2VydmVyLnVybHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIG51bV90dXJuX3NlcnZlcl91cmxzID0gdHVybl9zZXJ2ZXIudXJscy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHVybl9zZXJ2ZXIudXJscyA9IFt0dXJuX3NlcnZlci51cmxzXTtcbiAgICAgICAgICBudW1fdHVybl9zZXJ2ZXJfdXJscyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGpkeCA9IDA7IGpkeCA8IG51bV90dXJuX3NlcnZlcl91cmxzOyBqZHgrKykge1xuICAgICAgICAgIHVybCA9IHR1cm5fc2VydmVyLnVybHNbamR4XTtcblxuICAgICAgICAgIGlmICghKC9edHVybnM/Oi8udGVzdCh1cmwpKSkge1xuICAgICAgICAgICAgdXJsID0gJ3R1cm46JyArIHVybDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZihTSVAuR3JhbW1hci5wYXJzZSh1cmwsICd0dXJuX1VSSScpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHR1cm5TZXJ2ZXJzO1xuICAgIH0sXG5cbiAgICB1c2VyQWdlbnRTdHJpbmc6IGZ1bmN0aW9uKHVzZXJBZ2VudFN0cmluZykge1xuICAgICAgaWYgKHR5cGVvZiB1c2VyQWdlbnRTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB1c2VyQWdlbnRTdHJpbmc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVzZVByZWxvYWRlZFJvdXRlOiBmdW5jdGlvbih1c2VQcmVsb2FkZWRSb3V0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB1c2VQcmVsb2FkZWRSb3V0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB1c2VQcmVsb2FkZWRSb3V0ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgd3NTZXJ2ZXJNYXhSZWNvbm5lY3Rpb246IGZ1bmN0aW9uKHdzU2VydmVyTWF4UmVjb25uZWN0aW9uKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAoU0lQLlV0aWxzLmlzRGVjaW1hbCh3c1NlcnZlck1heFJlY29ubmVjdGlvbikpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIod3NTZXJ2ZXJNYXhSZWNvbm5lY3Rpb24pO1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHdzU2VydmVyUmVjb25uZWN0aW9uVGltZW91dDogZnVuY3Rpb24od3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0KSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAoU0lQLlV0aWxzLmlzRGVjaW1hbCh3c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXQpKSB7XG4gICAgICAgIHZhbHVlID0gTnVtYmVyKHdzU2VydmVyUmVjb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXV0b3N0YXJ0OiBmdW5jdGlvbihhdXRvc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgYXV0b3N0YXJ0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGF1dG9zdGFydDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVkaWFIYW5kbGVyRmFjdG9yeTogZnVuY3Rpb24obWVkaWFIYW5kbGVyRmFjdG9yeSkge1xuICAgICAgaWYgKG1lZGlhSGFuZGxlckZhY3RvcnkgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICB2YXIgcHJvbWlzaWZpZWRGYWN0b3J5ID0gZnVuY3Rpb24gcHJvbWlzaWZpZWRGYWN0b3J5ICgpIHtcbiAgICAgICAgICB2YXIgbWVkaWFIYW5kbGVyID0gbWVkaWFIYW5kbGVyRmFjdG9yeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gcGF0Y2hNZXRob2QgKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBtZWRpYUhhbmRsZXJbbWV0aG9kTmFtZV07XG4gICAgICAgICAgICBpZiAobWV0aG9kLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrc0ZpcnN0ID0gbWV0aG9kTmFtZSA9PT0gJ2dldERlc2NyaXB0aW9uJztcbiAgICAgICAgICAgICAgbWVkaWFIYW5kbGVyW21ldGhvZE5hbWVdID0gU0lQLlV0aWxzLnByb21pc2lmeShtZWRpYUhhbmRsZXIsIG1ldGhvZE5hbWUsIGNhbGxiYWNrc0ZpcnN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRjaE1ldGhvZCgnZ2V0RGVzY3JpcHRpb24nKTtcbiAgICAgICAgICBwYXRjaE1ldGhvZCgnc2V0RGVzY3JpcHRpb24nKTtcblxuICAgICAgICAgIHJldHVybiBtZWRpYUhhbmRsZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJvbWlzaWZpZWRGYWN0b3J5LmlzU3VwcG9ydGVkID0gbWVkaWFIYW5kbGVyRmFjdG9yeS5pc1N1cHBvcnRlZDtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmaWVkRmFjdG9yeTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXV0aGVudGljYXRpb25GYWN0b3J5OiBjaGVja0F1dGhlbnRpY2F0aW9uRmFjdG9yeVxuICB9XG59O1xuXG5VQS5DID0gQztcblNJUC5VQSA9IFVBO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvVUEuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEhhY2tzIC0gVGhpcyBmaWxlIGNvbnRhaW5zIGFsbCBvZiB0aGUgdGhpbmdzIHdlXG4gKiB3aXNoIHdlIGRpZG4ndCBoYXZlIHRvIGRvLCBqdXN0IGZvciBpbnRlcm9wLiAgSXQgaXMgc2ltaWxhciB0b1xuICogVXRpbHMsIHdoaWNoIHByb3ZpZGVzIGFjdHVhbGx5IHVzZWZ1bCBhbmQgcmVsZXZhbnQgZnVuY3Rpb25zIGZvclxuICogYSBTSVAgbGlicmFyeS4gTWV0aG9kcyBpbiB0aGlzIGZpbGUgYXJlIGdyb3VwZWQgYnkgdmVuZG9yLCBzb1xuICogYXMgdG8gbW9zdCBlYXNpbHkgdHJhY2sgd2hlbiBwYXJ0aWN1bGFyIGhhY2tzIG1heSBub3QgYmUgbmVjZXNzYXJ5IGFueW1vcmUuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG5cbi8va2VlcCB0byBxdWlldCBqc2hpbnQsIGFuZCByZW1haW4gY29uc2lzdGVudCB3aXRoIG90aGVyIGZpbGVzXG5TSVAgPSBTSVA7XG5cbnZhciBIYWNrcyA9IHtcbiAgQWxsQnJvd3NlcnM6IHtcbiAgICBtYXNrRHRsczogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmIChtZXNzYWdlLmJvZHkpIHtcbiAgICAgICAgbWVzc2FnZS5ib2R5ID0gbWVzc2FnZS5ib2R5LnJlcGxhY2UoLyBVRFBcXC9UTFNcXC9SVFBcXC9TQVZQL2dtaSwgXCIgUlRQL1NBVlBcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICB1bm1hc2tEdGxzOiBmdW5jdGlvbiAoc2RwKSB7XG4gICAgICAvKipcbiAgICAgICAqIENocm9tZSBkb2VzIG5vdCBoYW5kbGUgRFRMUyBjb3JyZWN0bHkgKENhbmFyYXkgZG9lcywgYnV0IG5vdCBwcm9kdWN0aW9uKVxuICAgICAgICoga2VlcGluZyBDaHJvbWUgYXMgU0RFUyB1bnRpbCBEVExTIGlzIGZpeGVkIChjb21tZW50IG91dCAnaXNfb3BlcmEnIGNvbmRpdGlvbilcbiAgICAgICAqXG4gICAgICAgKiBVUERBVEU6IE1heSAyMSwgMjAxNFxuICAgICAgICogQ2hyb21lIDM1IG5vdyBwcm9wZXJseSBkZWZhdWx0cyB0byBEVExTLiAgT25seSBPcGVyYSByZW1haW5zIHVzaW5nIFNERVNcbiAgICAgICAqXG4gICAgICAgKiBVUERBVEU6IDIwMTQtMDktMjRcbiAgICAgICAqIE9wZXJhIG5vdyBzdXBwb3J0cyBEVExTIGJ5IGRlZmF1bHQgYXMgd2VsbC5cbiAgICAgICAqXG4gICAgICAgKiovXG4gICAgICByZXR1cm4gc2RwLnJlcGxhY2UoLyBSVFBcXC9TQVZQL2dtaSwgXCIgVURQL1RMUy9SVFAvU0FWUFwiKTtcbiAgICB9XG4gIH0sXG4gIEZpcmVmb3g6IHtcbiAgICAvKiBDb25kaXRpb24gdG8gZGV0ZWN0IGlmIGhhY2tzIGFyZSBhcHBsaWNhYmxlICovXG4gICAgaXNGaXJlZm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG1velJUQ1BlZXJDb25uZWN0aW9uICE9PSAndW5kZWZpbmVkJztcbiAgICB9LFxuXG4gICAgY2Fubm90SGFuZGxlRXh0cmFXaGl0ZXNwYWNlOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgaWYgKHRoaXMuaXNGaXJlZm94KCkgJiYgbWVzc2FnZS5ib2R5KSB7XG4gICAgICAgIG1lc3NhZ2UuYm9keSA9IG1lc3NhZ2UuYm9keS5yZXBsYWNlKC8gXFxyXFxuL2csIFwiXFxyXFxuXCIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYXNNaXNzaW5nQ0xpbmVJblNEUDogZnVuY3Rpb24gKHNkcCkge1xuICAgICAgLypcbiAgICAgICAqIFRoaXMgaXMgYSBGaXJlZm94IGhhY2sgdG8gaW5zZXJ0IHZhbGlkIHNkcCB3aGVuIGdldERlc2NyaXB0aW9uIGlzXG4gICAgICAgKiBjYWxsZWQgd2l0aCB0aGUgY29uc3RyYWludCBvZmZlclRvUmVjZWl2ZVZpZGVvID0gZmFsc2UuXG4gICAgICAgKiBXZSBzZWFyY2ggZm9yIGVpdGhlciBhIGMtbGluZSBhdCB0aGUgdG9wIG9mIHRoZSBzZHAgYWJvdmUgYWxsXG4gICAgICAgKiBtLWxpbmVzLiBJZiB0aGF0IGRvZXMgbm90IGV4aXN0IHRoZW4gd2Ugc2VhcmNoIGZvciBhIGMtbGluZVxuICAgICAgICogYmVuZWF0aCBlYWNoIG0tbGluZS4gSWYgaXQgaXMgbWlzc2luZyBhIGMtbGluZSwgd2UgaW5zZXJ0XG4gICAgICAgKiBhIGZha2UgYy1saW5lIHdpdGggdGhlIGlwIGFkZHJlc3MgMC4wLjAuMC4gVGhpcyBpcyB0aGVuIHZhbGlkXG4gICAgICAgKiBzZHAgYW5kIG5vIG1lZGlhIHdpbGwgYmUgc2VudCBmb3IgdGhhdCBtLWxpbmUuXG4gICAgICAgKlxuICAgICAgICogVmFsaWQgU0RQIGlzOlxuICAgICAgICogbT1cbiAgICAgICAqIGk9XG4gICAgICAgKiBjPVxuICAgICAgICovXG4gICAgICB2YXIgaW5zZXJ0QXQsIG1saW5lcztcbiAgICAgIGlmIChzZHAuaW5kZXhPZignYz0nKSA+IHNkcC5pbmRleE9mKCdtPScpKSB7XG5cbiAgICAgICAgLy8gRmluZCBhbGwgbT0gbGluZXNcbiAgICAgICAgbWxpbmVzID0gc2RwLm1hdGNoKC9tPS4qXFxyXFxuLiovZyk7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxtbGluZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgIC8vIElmIGl0IGhhcyBhbiBpPSBsaW5lLCBjaGVjayBpZiB0aGUgbmV4dCBsaW5lIGlzIHRoZSBjPSBsaW5lXG4gICAgICAgICAgaWYgKG1saW5lc1tpXS50b1N0cmluZygpLnNlYXJjaCgvaT0uKi8pID49IDApIHtcbiAgICAgICAgICAgIGluc2VydEF0ID0gc2RwLmluZGV4T2YobWxpbmVzW2ldLnRvU3RyaW5nKCkpK21saW5lc1tpXS50b1N0cmluZygpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzZHAuc3Vic3RyKGluc2VydEF0LDIpIT09J2M9Jykge1xuICAgICAgICAgICAgICBzZHAgPSBzZHAuc3Vic3RyKDAsaW5zZXJ0QXQpICsgJ1xcclxcbmM9SU4gSVA0IDAuMC4wLjAnICsgc2RwLnN1YnN0cihpbnNlcnRBdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlbHNlIGFkZCB0aGUgQyBsaW5lIGlmIGl0J3MgbWlzc2luZ1xuICAgICAgICAgIH0gZWxzZSBpZiAobWxpbmVzW2ldLnRvU3RyaW5nKCkuc2VhcmNoKC9jPS4qLykgPCAwKSB7XG4gICAgICAgICAgICBpbnNlcnRBdCA9IHNkcC5pbmRleE9mKG1saW5lc1tpXS50b1N0cmluZygpLm1hdGNoKC8uKi8pKSttbGluZXNbaV0udG9TdHJpbmcoKS5tYXRjaCgvLiovKS50b1N0cmluZygpLmxlbmd0aDtcbiAgICAgICAgICAgIHNkcCA9IHNkcC5zdWJzdHIoMCxpbnNlcnRBdCkgKyAnXFxyXFxuYz1JTiBJUDQgMC4wLjAuMCcgKyBzZHAuc3Vic3RyKGluc2VydEF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZHA7XG4gICAgfSxcbiAgfSxcblxuICBDaHJvbWU6IHtcbiAgICBuZWVkc0V4cGxpY2l0bHlJbmFjdGl2ZVNEUDogZnVuY3Rpb24gKHNkcCkge1xuICAgICAgdmFyIHN1YiwgaW5kZXg7XG5cbiAgICAgIGlmIChIYWNrcy5GaXJlZm94LmlzRmlyZWZveCgpKSB7IC8vIEZpeCB0aGlzIGluIEZpcmVmb3ggYmVmb3JlIHNlbmRpbmdcbiAgICAgICAgaW5kZXggPSBzZHAuaW5kZXhPZignbT12aWRlbyAwJyk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBzdWIgPSBzZHAuc3Vic3RyKGluZGV4KTtcbiAgICAgICAgICBzdWIgPSBzdWIucmVwbGFjZSgvXFxyXFxuYz1JTiBJUDQuKlxcclxcbiQvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXHJcXG5jPUlOIElQNCAwLjAuMC4wXFxyXFxuYT1pbmFjdGl2ZVxcclxcbicpO1xuICAgICAgICAgIHJldHVybiBzZHAuc3Vic3RyKDAsIGluZGV4KSArIHN1YjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNkcDtcbiAgICB9LFxuXG4gICAgZ2V0c0NvbmZ1c2VkQWJvdXRHVU06IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICBpZiAoc2Vzc2lvbi5tZWRpYUhhbmRsZXIpIHtcbiAgICAgICAgc2Vzc2lvbi5tZWRpYUhhbmRsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5yZXR1cm4gSGFja3M7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvSGFja3MuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEluY29taW5nIFNJUCBNZXNzYWdlIFNhbml0eSBDaGVja1xuICovXG5cbi8qKlxuICogU0lQIG1lc3NhZ2Ugc2FuaXR5IGNoZWNrLlxuICogQGF1Z21lbnRzIFNJUFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1NJUC5JbmNvbWluZ01lc3NhZ2V9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7U0lQLlVBfSB1YVxuICogQHBhcmFtIHtTSVAuVHJhbnNwb3J0fSB0cmFuc3BvcnRcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBzYW5pdHlDaGVjayxcbiBsb2dnZXIsXG4gbWVzc2FnZSwgdWEsIHRyYW5zcG9ydCxcbiByZXF1ZXN0cyA9IFtdLFxuIHJlc3BvbnNlcyA9IFtdLFxuIGFsbCA9IFtdO1xuXG4vLyBSZXBseVxuZnVuY3Rpb24gcmVwbHkoc3RhdHVzX2NvZGUpIHtcbiAgdmFyIHRvLFxuICAgIHJlc3BvbnNlID0gU0lQLlV0aWxzLmJ1aWxkU3RhdHVzTGluZShzdGF0dXNfY29kZSksXG4gICAgdmlhcyA9IG1lc3NhZ2UuZ2V0SGVhZGVycygndmlhJyksXG4gICAgbGVuZ3RoID0gdmlhcy5sZW5ndGgsXG4gICAgaWR4ID0gMDtcblxuICBmb3IoaWR4OyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgcmVzcG9uc2UgKz0gXCJWaWE6IFwiICsgdmlhc1tpZHhdICsgXCJcXHJcXG5cIjtcbiAgfVxuXG4gIHRvID0gbWVzc2FnZS5nZXRIZWFkZXIoJ1RvJyk7XG5cbiAgaWYoIW1lc3NhZ2UudG9fdGFnKSB7XG4gICAgdG8gKz0gJzt0YWc9JyArIFNJUC5VdGlscy5uZXdUYWcoKTtcbiAgfVxuXG4gIHJlc3BvbnNlICs9IFwiVG86IFwiICsgdG8gKyBcIlxcclxcblwiO1xuICByZXNwb25zZSArPSBcIkZyb206IFwiICsgbWVzc2FnZS5nZXRIZWFkZXIoJ0Zyb20nKSArIFwiXFxyXFxuXCI7XG4gIHJlc3BvbnNlICs9IFwiQ2FsbC1JRDogXCIgKyBtZXNzYWdlLmNhbGxfaWQgKyBcIlxcclxcblwiO1xuICByZXNwb25zZSArPSBcIkNTZXE6IFwiICsgbWVzc2FnZS5jc2VxICsgXCIgXCIgKyBtZXNzYWdlLm1ldGhvZCArIFwiXFxyXFxuXCI7XG4gIHJlc3BvbnNlICs9IFwiXFxyXFxuXCI7XG5cbiAgdHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpO1xufVxuXG4vKlxuICogU2FuaXR5IENoZWNrIGZvciBpbmNvbWluZyBNZXNzYWdlc1xuICpcbiAqIFJlcXVlc3RzOlxuICogIC0gX3JmYzMyNjFfOF8yXzJfMV8gUmVjZWl2ZSBhIFJlcXVlc3Qgd2l0aCBhIG5vbiBzdXBwb3J0ZWQgVVJJIHNjaGVtZVxuICogIC0gX3JmYzMyNjFfMTZfM180XyBSZWNlaXZlIGEgUmVxdWVzdCBhbHJlYWR5IHNlbnQgYnkgdXNcbiAqICAgRG9lcyBub3QgbG9vayBhdCB2aWEgc2VudC1ieSBidXQgYXQgc2lwanNJZCwgd2hpY2ggaXMgaW5zZXJ0ZWQgYXNcbiAqICAgYSBwcmVmaXggaW4gYWxsIGluaXRpYWwgcmVxdWVzdHMgZ2VuZXJhdGVkIGJ5IHRoZSB1YVxuICogIC0gX3JmYzMyNjFfMThfM19yZXF1ZXN0XyBCb2R5IENvbnRlbnQtTGVuZ3RoXG4gKiAgLSBfcmZjMzI2MV84XzJfMl8yXyBNZXJnZWQgUmVxdWVzdHNcbiAqXG4gKiBSZXNwb25zZXM6XG4gKiAgLSBfcmZjMzI2MV84XzFfM18zXyBNdWx0aXBsZSBWaWEgaGVhZGVyc1xuICogIC0gX3JmYzMyNjFfMThfMV8yXyBzZW50LWJ5IG1pc21hdGNoXG4gKiAgLSBfcmZjMzI2MV8xOF8zX3Jlc3BvbnNlXyBCb2R5IENvbnRlbnQtTGVuZ3RoXG4gKlxuICogQWxsOlxuICogIC0gTWluaW11bSBoZWFkZXJzIGluIGEgU0lQIG1lc3NhZ2VcbiAqL1xuXG4vLyBTYW5pdHkgQ2hlY2sgZnVuY3Rpb25zIGZvciByZXF1ZXN0c1xuZnVuY3Rpb24gcmZjMzI2MV84XzJfMl8xKCkge1xuICBpZighbWVzc2FnZS5ydXJpIHx8IG1lc3NhZ2UucnVyaS5zY2hlbWUgIT09ICdzaXAnKSB7XG4gICAgcmVwbHkoNDE2KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmZjMzI2MV8xNl8zXzQoKSB7XG4gIGlmKCFtZXNzYWdlLnRvX3RhZykge1xuICAgIGlmKG1lc3NhZ2UuY2FsbF9pZC5zdWJzdHIoMCwgNSkgPT09IHVhLmNvbmZpZ3VyYXRpb24uc2lwanNJZCkge1xuICAgICAgcmVwbHkoNDgyKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmZjMzI2MV8xOF8zX3JlcXVlc3QoKSB7XG4gIHZhciBsZW4gPSBTSVAuVXRpbHMuc3RyX3V0ZjhfbGVuZ3RoKG1lc3NhZ2UuYm9keSksXG4gIGNvbnRlbnRMZW5ndGggPSBtZXNzYWdlLmdldEhlYWRlcignY29udGVudC1sZW5ndGgnKTtcblxuICBpZihsZW4gPCBjb250ZW50TGVuZ3RoKSB7XG4gICAgcmVwbHkoNDAwKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmZjMzI2MV84XzJfMl8yKCkge1xuICB2YXIgdHIsIGlkeCxcbiAgICBmcm9tVGFnID0gbWVzc2FnZS5mcm9tX3RhZyxcbiAgICBjYWxsX2lkID0gbWVzc2FnZS5jYWxsX2lkLFxuICAgIGNzZXEgPSBtZXNzYWdlLmNzZXE7XG5cbiAgaWYoIW1lc3NhZ2UudG9fdGFnKSB7XG4gICAgaWYobWVzc2FnZS5tZXRob2QgPT09IFNJUC5DLklOVklURSkge1xuICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMuaXN0W21lc3NhZ2UudmlhX2JyYW5jaF07XG4gICAgICBpZih0cikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IoaWR4IGluIHVhLnRyYW5zYWN0aW9ucy5pc3QpIHtcbiAgICAgICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5pc3RbaWR4XTtcbiAgICAgICAgICBpZih0ci5yZXF1ZXN0LmZyb21fdGFnID09PSBmcm9tVGFnICYmIHRyLnJlcXVlc3QuY2FsbF9pZCA9PT0gY2FsbF9pZCAmJiB0ci5yZXF1ZXN0LmNzZXEgPT09IGNzZXEpIHtcbiAgICAgICAgICAgIHJlcGx5KDQ4Mik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLm5pc3RbbWVzc2FnZS52aWFfYnJhbmNoXTtcbiAgICAgIGlmKHRyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcihpZHggaW4gdWEudHJhbnNhY3Rpb25zLm5pc3QpIHtcbiAgICAgICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5uaXN0W2lkeF07XG4gICAgICAgICAgaWYodHIucmVxdWVzdC5mcm9tX3RhZyA9PT0gZnJvbVRhZyAmJiB0ci5yZXF1ZXN0LmNhbGxfaWQgPT09IGNhbGxfaWQgJiYgdHIucmVxdWVzdC5jc2VxID09PSBjc2VxKSB7XG4gICAgICAgICAgICByZXBseSg0ODIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBTYW5pdHkgQ2hlY2sgZnVuY3Rpb25zIGZvciByZXNwb25zZXNcbmZ1bmN0aW9uIHJmYzMyNjFfOF8xXzNfMygpIHtcbiAgaWYobWVzc2FnZS5nZXRIZWFkZXJzKCd2aWEnKS5sZW5ndGggPiAxKSB7XG4gICAgbG9nZ2VyLndhcm4oJ01vcmUgdGhhbiBvbmUgVmlhIGhlYWRlciBmaWVsZCBwcmVzZW50IGluIHRoZSByZXNwb25zZS4gRHJvcHBpbmcgdGhlIHJlc3BvbnNlJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJmYzMyNjFfMThfMV8yKCkge1xuICB2YXIgdmlhSG9zdCA9IHVhLmNvbmZpZ3VyYXRpb24udmlhSG9zdDtcbiAgaWYobWVzc2FnZS52aWEuaG9zdCAhPT0gdmlhSG9zdCB8fCBtZXNzYWdlLnZpYS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBsb2dnZXIud2FybignVmlhIHNlbnQtYnkgaW4gdGhlIHJlc3BvbnNlIGRvZXMgbm90IG1hdGNoIFVBIFZpYSBob3N0IHZhbHVlLiBEcm9wcGluZyB0aGUgcmVzcG9uc2UnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmZjMzI2MV8xOF8zX3Jlc3BvbnNlKCkge1xuICB2YXJcbiAgICBsZW4gPSBTSVAuVXRpbHMuc3RyX3V0ZjhfbGVuZ3RoKG1lc3NhZ2UuYm9keSksXG4gICAgY29udGVudExlbmd0aCA9IG1lc3NhZ2UuZ2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcpO1xuXG4gICAgaWYobGVuIDwgY29udGVudExlbmd0aCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ01lc3NhZ2UgYm9keSBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgdmFsdWUgaW4gQ29udGVudC1MZW5ndGggaGVhZGVyIGZpZWxkLiBEcm9wcGluZyB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIFNhbml0eSBDaGVjayBmdW5jdGlvbnMgZm9yIHJlcXVlc3RzIGFuZCByZXNwb25zZXNcbmZ1bmN0aW9uIG1pbmltdW1IZWFkZXJzKCkge1xuICB2YXJcbiAgICBtYW5kYXRvcnlIZWFkZXJzID0gWydmcm9tJywgJ3RvJywgJ2NhbGxfaWQnLCAnY3NlcScsICd2aWEnXSxcbiAgICBpZHggPSBtYW5kYXRvcnlIZWFkZXJzLmxlbmd0aDtcblxuICB3aGlsZShpZHgtLSkge1xuICAgIGlmKCFtZXNzYWdlLmhhc0hlYWRlcihtYW5kYXRvcnlIZWFkZXJzW2lkeF0pKSB7XG4gICAgICBsb2dnZXIud2FybignTWlzc2luZyBtYW5kYXRvcnkgaGVhZGVyIGZpZWxkIDogJysgbWFuZGF0b3J5SGVhZGVyc1tpZHhdICsnLiBEcm9wcGluZyB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxucmVxdWVzdHMucHVzaChyZmMzMjYxXzhfMl8yXzEpO1xucmVxdWVzdHMucHVzaChyZmMzMjYxXzE2XzNfNCk7XG5yZXF1ZXN0cy5wdXNoKHJmYzMyNjFfMThfM19yZXF1ZXN0KTtcbnJlcXVlc3RzLnB1c2gocmZjMzI2MV84XzJfMl8yKTtcblxucmVzcG9uc2VzLnB1c2gocmZjMzI2MV84XzFfM18zKTtcbnJlc3BvbnNlcy5wdXNoKHJmYzMyNjFfMThfMV8yKTtcbnJlc3BvbnNlcy5wdXNoKHJmYzMyNjFfMThfM19yZXNwb25zZSk7XG5cbmFsbC5wdXNoKG1pbmltdW1IZWFkZXJzKTtcblxuc2FuaXR5Q2hlY2sgPSBmdW5jdGlvbihtLCB1LCB0KSB7XG4gIHZhciBsZW4sIHBhc3M7XG5cbiAgbWVzc2FnZSA9IG07XG4gIHVhID0gdTtcbiAgdHJhbnNwb3J0ID0gdDtcblxuICBsb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5zYW5pdHljaGVjaycpO1xuXG4gIGxlbiA9IGFsbC5sZW5ndGg7XG4gIHdoaWxlKGxlbi0tKSB7XG4gICAgcGFzcyA9IGFsbFtsZW5dKG1lc3NhZ2UpO1xuICAgIGlmKHBhc3MgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYobWVzc2FnZSBpbnN0YW5jZW9mIFNJUC5JbmNvbWluZ1JlcXVlc3QpIHtcbiAgICBsZW4gPSByZXF1ZXN0cy5sZW5ndGg7XG4gICAgd2hpbGUobGVuLS0pIHtcbiAgICAgIHBhc3MgPSByZXF1ZXN0c1tsZW5dKG1lc3NhZ2UpO1xuICAgICAgaWYocGFzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2UgaWYobWVzc2FnZSBpbnN0YW5jZW9mIFNJUC5JbmNvbWluZ1Jlc3BvbnNlKSB7XG4gICAgbGVuID0gcmVzcG9uc2VzLmxlbmd0aDtcbiAgICB3aGlsZShsZW4tLSkge1xuICAgICAgcGFzcyA9IHJlc3BvbnNlc1tsZW5dKG1lc3NhZ2UpO1xuICAgICAgaWYocGFzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vRXZlcnl0aGluZyBpcyBPS1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblNJUC5zYW5pdHlDaGVjayA9IHNhbml0eUNoZWNrO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvU2FuaXR5Q2hlY2suanNcbiAqKiBtb2R1bGUgaWQgPSAyNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIERpZ2VzdCBBdXRoZW50aWNhdGlvblxuICovXG5cbi8qKlxuICogU0lQIERpZ2VzdCBBdXRoZW50aWNhdGlvbi5cbiAqIEBhdWdtZW50cyBTSVAuXG4gKiBAZnVuY3Rpb24gRGlnZXN0IEF1dGhlbnRpY2F0aW9uXG4gKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVXRpbHMpIHtcbnZhciBEaWdlc3RBdXRoZW50aWNhdGlvbjtcblxuRGlnZXN0QXV0aGVudGljYXRpb24gPSBmdW5jdGlvbih1YSkge1xuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwanMuZGlnZXN0YXV0aGVudGljYXRpb24nKTtcbiAgdGhpcy51c2VybmFtZSA9IHVhLmNvbmZpZ3VyYXRpb24uYXV0aG9yaXphdGlvblVzZXI7XG4gIHRoaXMucGFzc3dvcmQgPSB1YS5jb25maWd1cmF0aW9uLnBhc3N3b3JkO1xuICB0aGlzLmNub25jZSA9IG51bGw7XG4gIHRoaXMubmMgPSAwO1xuICB0aGlzLm5jSGV4ID0gJzAwMDAwMDAwJztcbiAgdGhpcy5yZXNwb25zZSA9IG51bGw7XG59O1xuXG5cbi8qKlxuKiBQZXJmb3JtcyBEaWdlc3QgYXV0aGVudGljYXRpb24gZ2l2ZW4gYSBTSVAgcmVxdWVzdCBhbmQgdGhlIGNoYWxsZW5nZVxuKiByZWNlaXZlZCBpbiBhIHJlc3BvbnNlIHRvIHRoYXQgcmVxdWVzdC5cbiogUmV0dXJucyB0cnVlIGlmIGNyZWRlbnRpYWxzIHdlcmUgc3VjY2Vzc2Z1bGx5IGdlbmVyYXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuKlxuKiBAcGFyYW0ge1NJUC5PdXRnb2luZ1JlcXVlc3R9IHJlcXVlc3RcbiogQHBhcmFtIHtPYmplY3R9IGNoYWxsZW5nZVxuKi9cbkRpZ2VzdEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5hdXRoZW50aWNhdGUgPSBmdW5jdGlvbihyZXF1ZXN0LCBjaGFsbGVuZ2UpIHtcbiAgLy8gSW5zcGVjdCBhbmQgdmFsaWRhdGUgdGhlIGNoYWxsZW5nZS5cblxuICB0aGlzLmFsZ29yaXRobSA9IGNoYWxsZW5nZS5hbGdvcml0aG07XG4gIHRoaXMucmVhbG0gPSBjaGFsbGVuZ2UucmVhbG07XG4gIHRoaXMubm9uY2UgPSBjaGFsbGVuZ2Uubm9uY2U7XG4gIHRoaXMub3BhcXVlID0gY2hhbGxlbmdlLm9wYXF1ZTtcbiAgdGhpcy5zdGFsZSA9IGNoYWxsZW5nZS5zdGFsZTtcblxuICBpZiAodGhpcy5hbGdvcml0aG0pIHtcbiAgICBpZiAodGhpcy5hbGdvcml0aG0gIT09ICdNRDUnKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdjaGFsbGVuZ2Ugd2l0aCBEaWdlc3QgYWxnb3JpdGhtIGRpZmZlcmVudCB0aGFuIFwiTUQ1XCIsIGF1dGhlbnRpY2F0aW9uIGFib3J0ZWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hbGdvcml0aG0gPSAnTUQ1JztcbiAgfVxuXG4gIGlmICghIHRoaXMucmVhbG0pIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdjaGFsbGVuZ2Ugd2l0aG91dCBEaWdlc3QgcmVhbG0sIGF1dGhlbnRpY2F0aW9uIGFib3J0ZWQnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoISB0aGlzLm5vbmNlKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignY2hhbGxlbmdlIHdpdGhvdXQgRGlnZXN0IG5vbmNlLCBhdXRoZW50aWNhdGlvbiBhYm9ydGVkJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gJ3FvcCcgY2FuIGNvbnRhaW4gYSBsaXN0IG9mIHZhbHVlcyAoQXJyYXkpLiBMZXQncyBjaG9vc2UganVzdCBvbmUuXG4gIGlmIChjaGFsbGVuZ2UucW9wKSB7XG4gICAgaWYgKGNoYWxsZW5nZS5xb3AuaW5kZXhPZignYXV0aCcpID4gLTEpIHtcbiAgICAgIHRoaXMucW9wID0gJ2F1dGgnO1xuICAgIH0gZWxzZSBpZiAoY2hhbGxlbmdlLnFvcC5pbmRleE9mKCdhdXRoLWludCcpID4gLTEpIHtcbiAgICAgIHRoaXMucW9wID0gJ2F1dGgtaW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlICdxb3AnIGlzIHByZXNlbnQgYnV0IGRvZXMgbm90IGNvbnRhaW4gJ2F1dGgnIG9yICdhdXRoLWludCcsIHNvIGFib3J0IGhlcmUuXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdjaGFsbGVuZ2Ugd2l0aG91dCBEaWdlc3QgcW9wIGRpZmZlcmVudCB0aGFuIFwiYXV0aFwiIG9yIFwiYXV0aC1pbnRcIiwgYXV0aGVudGljYXRpb24gYWJvcnRlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnFvcCA9IG51bGw7XG4gIH1cblxuICAvLyBGaWxsIG90aGVyIGF0dHJpYnV0ZXMuXG5cbiAgdGhpcy5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgdGhpcy51cmkgPSByZXF1ZXN0LnJ1cmk7XG4gIHRoaXMuY25vbmNlID0gVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oMTIpO1xuICB0aGlzLm5jICs9IDE7XG4gIHRoaXMudXBkYXRlTmNIZXgoKTtcblxuICAvLyBuYy12YWx1ZSA9IDhMSEVYLiBNYXggdmFsdWUgPSAnRkZGRkZGRkYnLlxuICBpZiAodGhpcy5uYyA9PT0gNDI5NDk2NzI5Nikge1xuICAgIHRoaXMubmMgPSAxO1xuICAgIHRoaXMubmNIZXggPSAnMDAwMDAwMDEnO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBEaWdlc3QgXCJyZXNwb25zZVwiIHZhbHVlLlxuICB0aGlzLmNhbGN1bGF0ZVJlc3BvbnNlKCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuKiBHZW5lcmF0ZSBEaWdlc3QgJ3Jlc3BvbnNlJyB2YWx1ZS5cbiogQHByaXZhdGVcbiovXG5EaWdlc3RBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuY2FsY3VsYXRlUmVzcG9uc2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhhMSwgaGEyO1xuXG4gIC8vIEhBMSA9IE1ENShBMSkgPSBNRDUodXNlcm5hbWU6cmVhbG06cGFzc3dvcmQpXG4gIGhhMSA9IFV0aWxzLmNhbGN1bGF0ZU1ENSh0aGlzLnVzZXJuYW1lICsgXCI6XCIgKyB0aGlzLnJlYWxtICsgXCI6XCIgKyB0aGlzLnBhc3N3b3JkKTtcblxuICBpZiAodGhpcy5xb3AgPT09ICdhdXRoJykge1xuICAgIC8vIEhBMiA9IE1ENShBMikgPSBNRDUobWV0aG9kOmRpZ2VzdFVSSSlcbiAgICBoYTIgPSBVdGlscy5jYWxjdWxhdGVNRDUodGhpcy5tZXRob2QgKyBcIjpcIiArIHRoaXMudXJpKTtcbiAgICAvLyByZXNwb25zZSA9IE1ENShIQTE6bm9uY2U6bm9uY2VDb3VudDpjcmVkZW50aWFsc05vbmNlOnFvcDpIQTIpXG4gICAgdGhpcy5yZXNwb25zZSA9IFV0aWxzLmNhbGN1bGF0ZU1ENShoYTEgKyBcIjpcIiArIHRoaXMubm9uY2UgKyBcIjpcIiArIHRoaXMubmNIZXggKyBcIjpcIiArIHRoaXMuY25vbmNlICsgXCI6YXV0aDpcIiArIGhhMik7XG5cbiAgfSBlbHNlIGlmICh0aGlzLnFvcCA9PT0gJ2F1dGgtaW50Jykge1xuICAgIC8vIEhBMiA9IE1ENShBMikgPSBNRDUobWV0aG9kOmRpZ2VzdFVSSTpNRDUoZW50aXR5Qm9keSkpXG4gICAgaGEyID0gVXRpbHMuY2FsY3VsYXRlTUQ1KHRoaXMubWV0aG9kICsgXCI6XCIgKyB0aGlzLnVyaSArIFwiOlwiICsgVXRpbHMuY2FsY3VsYXRlTUQ1KHRoaXMuYm9keSA/IHRoaXMuYm9keSA6IFwiXCIpKTtcbiAgICAvLyByZXNwb25zZSA9IE1ENShIQTE6bm9uY2U6bm9uY2VDb3VudDpjcmVkZW50aWFsc05vbmNlOnFvcDpIQTIpXG4gICAgdGhpcy5yZXNwb25zZSA9IFV0aWxzLmNhbGN1bGF0ZU1ENShoYTEgKyBcIjpcIiArIHRoaXMubm9uY2UgKyBcIjpcIiArIHRoaXMubmNIZXggKyBcIjpcIiArIHRoaXMuY25vbmNlICsgXCI6YXV0aC1pbnQ6XCIgKyBoYTIpO1xuXG4gIH0gZWxzZSBpZiAodGhpcy5xb3AgPT09IG51bGwpIHtcbiAgICAvLyBIQTIgPSBNRDUoQTIpID0gTUQ1KG1ldGhvZDpkaWdlc3RVUkkpXG4gICAgaGEyID0gVXRpbHMuY2FsY3VsYXRlTUQ1KHRoaXMubWV0aG9kICsgXCI6XCIgKyB0aGlzLnVyaSk7XG4gICAgLy8gcmVzcG9uc2UgPSBNRDUoSEExOm5vbmNlOkhBMilcbiAgICB0aGlzLnJlc3BvbnNlID0gVXRpbHMuY2FsY3VsYXRlTUQ1KGhhMSArIFwiOlwiICsgdGhpcy5ub25jZSArIFwiOlwiICsgaGEyKTtcbiAgfVxufTtcblxuXG4vKipcbiogUmV0dXJuIHRoZSBQcm94eS1BdXRob3JpemF0aW9uIG9yIFdXVy1BdXRob3JpemF0aW9uIGhlYWRlciB2YWx1ZS5cbiovXG5EaWdlc3RBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGhfcGFyYW1zID0gW107XG5cbiAgaWYgKCEgdGhpcy5yZXNwb25zZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVzcG9uc2UgZmllbGQgZG9lcyBub3QgZXhpc3QsIGNhbm5vdCBnZW5lcmF0ZSBBdXRob3JpemF0aW9uIGhlYWRlcicpO1xuICB9XG5cbiAgYXV0aF9wYXJhbXMucHVzaCgnYWxnb3JpdGhtPScgKyB0aGlzLmFsZ29yaXRobSk7XG4gIGF1dGhfcGFyYW1zLnB1c2goJ3VzZXJuYW1lPVwiJyArIHRoaXMudXNlcm5hbWUgKyAnXCInKTtcbiAgYXV0aF9wYXJhbXMucHVzaCgncmVhbG09XCInICsgdGhpcy5yZWFsbSArICdcIicpO1xuICBhdXRoX3BhcmFtcy5wdXNoKCdub25jZT1cIicgKyB0aGlzLm5vbmNlICsgJ1wiJyk7XG4gIGF1dGhfcGFyYW1zLnB1c2goJ3VyaT1cIicgKyB0aGlzLnVyaSArICdcIicpO1xuICBhdXRoX3BhcmFtcy5wdXNoKCdyZXNwb25zZT1cIicgKyB0aGlzLnJlc3BvbnNlICsgJ1wiJyk7XG4gIGlmICh0aGlzLm9wYXF1ZSkge1xuICAgIGF1dGhfcGFyYW1zLnB1c2goJ29wYXF1ZT1cIicgKyB0aGlzLm9wYXF1ZSArICdcIicpO1xuICB9XG4gIGlmICh0aGlzLnFvcCkge1xuICAgIGF1dGhfcGFyYW1zLnB1c2goJ3FvcD0nICsgdGhpcy5xb3ApO1xuICAgIGF1dGhfcGFyYW1zLnB1c2goJ2Nub25jZT1cIicgKyB0aGlzLmNub25jZSArICdcIicpO1xuICAgIGF1dGhfcGFyYW1zLnB1c2goJ25jPScgKyB0aGlzLm5jSGV4KTtcbiAgfVxuXG4gIHJldHVybiAnRGlnZXN0ICcgKyBhdXRoX3BhcmFtcy5qb2luKCcsICcpO1xufTtcblxuXG4vKipcbiogR2VuZXJhdGUgdGhlICduYycgdmFsdWUgYXMgcmVxdWlyZWQgYnkgRGlnZXN0IGluIHRoaXMubmNIZXggYnkgcmVhZGluZyB0aGlzLm5jLlxuKiBAcHJpdmF0ZVxuKi9cbkRpZ2VzdEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS51cGRhdGVOY0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGV4ID0gTnVtYmVyKHRoaXMubmMpLnRvU3RyaW5nKDE2KTtcbiAgdGhpcy5uY0hleCA9ICcwMDAwMDAwMCcuc3Vic3RyKDAsIDgtaGV4Lmxlbmd0aCkgKyBoZXg7XG59O1xuXG5yZXR1cm4gRGlnZXN0QXV0aGVudGljYXRpb247XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9EaWdlc3RBdXRoZW50aWNhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgR3JhbW1hciA9IHJlcXVpcmUoJy4vR3JhbW1hci9kaXN0L0dyYW1tYXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG5cbnJldHVybiB7XG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZUN1c3RvbSAoaW5wdXQsIHN0YXJ0UnVsZSkge1xuICAgIHZhciBvcHRpb25zID0ge3N0YXJ0UnVsZTogc3RhcnRSdWxlLCBTSVA6IFNJUH07XG4gICAgdHJ5IHtcbiAgICAgIEdyYW1tYXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9wdGlvbnMuZGF0YSA9IC0xO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5kYXRhO1xuICB9XG59O1xuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9HcmFtbWFyLmpzXG4gKiogbW9kdWxlIGlkID0gMjQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgLypcbiAgICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjguMC5cbiAgICpcbiAgICogaHR0cDovL3BlZ2pzLm1hamRhLmN6L1xuICAgKi9cblxuICBmdW5jdGlvbiBwZWckc3ViY2xhc3MoY2hpbGQsIHBhcmVudCkge1xuICAgIGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfVxuICAgIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gU3ludGF4RXJyb3IobWVzc2FnZSwgZXhwZWN0ZWQsIGZvdW5kLCBvZmZzZXQsIGxpbmUsIGNvbHVtbikge1xuICAgIHRoaXMubWVzc2FnZSAgPSBtZXNzYWdlO1xuICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICB0aGlzLmZvdW5kICAgID0gZm91bmQ7XG4gICAgdGhpcy5vZmZzZXQgICA9IG9mZnNldDtcbiAgICB0aGlzLmxpbmUgICAgID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiAgID0gY29sdW1uO1xuXG4gICAgdGhpcy5uYW1lICAgICA9IFwiU3ludGF4RXJyb3JcIjtcbiAgfVxuXG4gIHBlZyRzdWJjbGFzcyhTeW50YXhFcnJvciwgRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuXG4gICAgICAgIHBlZyRGQUlMRUQgPSB7fSxcblxuICAgICAgICBwZWckc3RhcnRSdWxlSW5kaWNlcyA9IHsgQ29udGFjdDogMTE4LCBOYW1lX0FkZHJfSGVhZGVyOiAxNTUsIFJlY29yZF9Sb3V0ZTogMTc1LCBSZXF1ZXN0X1Jlc3BvbnNlOiA4MSwgU0lQX1VSSTogNDUsIFN1YnNjcmlwdGlvbl9TdGF0ZTogMTg1LCBTdXBwb3J0ZWQ6IDE5MCwgUmVxdWlyZTogMTgxLCBWaWE6IDE5MywgYWJzb2x1dGVVUkk6IDg0LCBDYWxsX0lEOiAxMTcsIENvbnRlbnRfRGlzcG9zaXRpb246IDEyOSwgQ29udGVudF9MZW5ndGg6IDEzNCwgQ29udGVudF9UeXBlOiAxMzUsIENTZXE6IDE0NSwgZGlzcGxheU5hbWU6IDEyMSwgRXZlbnQ6IDE0OCwgRnJvbTogMTUwLCBob3N0OiA1MiwgTWF4X0ZvcndhcmRzOiAxNTMsIE1pbl9TRTogMjEyLCBQcm94eV9BdXRoZW50aWNhdGU6IDE1NiwgcXVvdGVkX3N0cmluZzogNDAsIFJlZmVyX1RvOiAxNzcsIFJlcGxhY2VzOiAxNzgsIFNlc3Npb25fRXhwaXJlczogMjA5LCBzdHVuX1VSSTogMjE2LCBUbzogMTkxLCB0dXJuX1VSSTogMjIzLCB1dWlkOiAyMjYsIFdXV19BdXRoZW50aWNhdGU6IDIwOCwgY2hhbGxlbmdlOiAxNTcgfSxcbiAgICAgICAgcGVnJHN0YXJ0UnVsZUluZGV4ICAgPSAxMTgsXG5cbiAgICAgICAgcGVnJGNvbnN0cyA9IFtcbiAgICAgICAgICBcIlxcclxcblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcclxcblwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXHJcXFxcblxcXCJcIiB9LFxuICAgICAgICAgIC9eWzAtOV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC05XVwiLCBkZXNjcmlwdGlvbjogXCJbMC05XVwiIH0sXG4gICAgICAgICAgL15bYS16QS1aXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlthLXpBLVpdXCIsIGRlc2NyaXB0aW9uOiBcIlthLXpBLVpdXCIgfSxcbiAgICAgICAgICAvXlswLTlhLWZBLUZdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzAtOWEtZkEtRl1cIiwgZGVzY3JpcHRpb246IFwiWzAtOWEtZkEtRl1cIiB9LFxuICAgICAgICAgIC9eW1xcMC1cXHhGRl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcXDAtXFxcXHhGRl1cIiwgZGVzY3JpcHRpb246IFwiW1xcXFwwLVxcXFx4RkZdXCIgfSxcbiAgICAgICAgICAvXltcIl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcIl1cIiwgZGVzY3JpcHRpb246IFwiW1xcXCJdXCIgfSxcbiAgICAgICAgICBcIiBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIgXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIgXFxcIlwiIH0sXG4gICAgICAgICAgXCJcXHRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXHRcIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFx0XFxcIlwiIH0sXG4gICAgICAgICAgL15bYS16QS1aMC05XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlthLXpBLVowLTldXCIsIGRlc2NyaXB0aW9uOiBcIlthLXpBLVowLTldXCIgfSxcbiAgICAgICAgICBcIjtcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI7XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI7XFxcIlwiIH0sXG4gICAgICAgICAgXCIvXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiL1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiL1xcXCJcIiB9LFxuICAgICAgICAgIFwiP1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj9cIiwgZGVzY3JpcHRpb246IFwiXFxcIj9cXFwiXCIgfSxcbiAgICAgICAgICBcIjpcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI6XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI6XFxcIlwiIH0sXG4gICAgICAgICAgXCJAXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiQFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiQFxcXCJcIiB9LFxuICAgICAgICAgIFwiJlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiZcIiwgZGVzY3JpcHRpb246IFwiXFxcIiZcXFwiXCIgfSxcbiAgICAgICAgICBcIj1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI9XFxcIlwiIH0sXG4gICAgICAgICAgXCIrXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiK1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiK1xcXCJcIiB9LFxuICAgICAgICAgIFwiJFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiRcIiwgZGVzY3JpcHRpb246IFwiXFxcIiRcXFwiXCIgfSxcbiAgICAgICAgICBcIixcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIsXFxcIlwiIH0sXG4gICAgICAgICAgXCItXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiLVxcXCJcIiB9LFxuICAgICAgICAgIFwiX1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIl9cIiwgZGVzY3JpcHRpb246IFwiXFxcIl9cXFwiXCIgfSxcbiAgICAgICAgICBcIi5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIuXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIuXFxcIlwiIH0sXG4gICAgICAgICAgXCIhXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiIVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiIVxcXCJcIiB9LFxuICAgICAgICAgIFwiflwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIn5cIiwgZGVzY3JpcHRpb246IFwiXFxcIn5cXFwiXCIgfSxcbiAgICAgICAgICBcIipcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIqXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIqXFxcIlwiIH0sXG4gICAgICAgICAgXCInXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiJ1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiJ1xcXCJcIiB9LFxuICAgICAgICAgIFwiKFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIihcIiwgZGVzY3JpcHRpb246IFwiXFxcIihcXFwiXCIgfSxcbiAgICAgICAgICBcIilcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIpXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIpXFxcIlwiIH0sXG4gICAgICAgICAgcGVnJEZBSUxFRCxcbiAgICAgICAgICBcIiVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIlXFxcIlwiIH0sXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBbXSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCIgXCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuICc6JzsgfSxcbiAgICAgICAgICAvXlshLX5dLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyEtfl1cIiwgZGVzY3JpcHRpb246IFwiWyEtfl1cIiB9LFxuICAgICAgICAgIC9eW1xceDgwLVxcdUZGRkZdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFx4ODAtXFxcXHVGRkZGXVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcXHg4MC1cXFxcdUZGRkZdXCIgfSxcbiAgICAgICAgICAvXltcXHg4MC1cXHhCRl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcXHg4MC1cXFxceEJGXVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcXHg4MC1cXFxceEJGXVwiIH0sXG4gICAgICAgICAgL15bYS1mXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlthLWZdXCIsIGRlc2NyaXB0aW9uOiBcIlthLWZdXCIgfSxcbiAgICAgICAgICBcImBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJgXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJgXFxcIlwiIH0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPFxcXCJcIiB9LFxuICAgICAgICAgIFwiPlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj5cIiwgZGVzY3JpcHRpb246IFwiXFxcIj5cXFwiXCIgfSxcbiAgICAgICAgICBcIlxcXFxcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcXFxcXCJcIiB9LFxuICAgICAgICAgIFwiW1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIltcIiwgZGVzY3JpcHRpb246IFwiXFxcIltcXFwiXCIgfSxcbiAgICAgICAgICBcIl1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJdXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJdXFxcIlwiIH0sXG4gICAgICAgICAgXCJ7XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwie1wiLCBkZXNjcmlwdGlvbjogXCJcXFwie1xcXCJcIiB9LFxuICAgICAgICAgIFwifVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIn1cIiwgZGVzY3JpcHRpb246IFwiXFxcIn1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCIqXCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiL1wiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIj1cIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCIoXCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiKVwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIj5cIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCI8XCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiLFwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIjtcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCI6XCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiXFxcIlwiOyB9LFxuICAgICAgICAgIC9eWyEtJ10vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbIS0nXVwiLCBkZXNjcmlwdGlvbjogXCJbIS0nXVwiIH0sXG4gICAgICAgICAgL15bKi1bXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsqLVtdXCIsIGRlc2NyaXB0aW9uOiBcIlsqLVtdXCIgfSxcbiAgICAgICAgICAvXltcXF0tfl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcXF0tfl1cIiwgZGVzY3JpcHRpb246IFwiW1xcXFxdLX5dXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihjb250ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50czsgfSxcbiAgICAgICAgICAvXlsjLVtdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyMtW11cIiwgZGVzY3JpcHRpb246IFwiWyMtW11cIiB9LFxuICAgICAgICAgIC9eW1xcMC1cXHRdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFwwLVxcXFx0XVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcXDAtXFxcXHRdXCIgfSxcbiAgICAgICAgICAvXltcXHgwQi1cXGZdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFx4MEItXFxcXGZdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxceDBCLVxcXFxmXVwiIH0sXG4gICAgICAgICAgL15bXFx4MEUtf10vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcXHgwRS1/XVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcXHgwRS1/XVwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaSA9IG5ldyBvcHRpb25zLlNJUC5VUkkob3B0aW9ucy5kYXRhLnNjaGVtZSwgb3B0aW9ucy5kYXRhLnVzZXIsIG9wdGlvbnMuZGF0YS5ob3N0LCBvcHRpb25zLmRhdGEucG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5zY2hlbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaSA9IG5ldyBvcHRpb25zLlNJUC5VUkkob3B0aW9ucy5kYXRhLnNjaGVtZSwgb3B0aW9ucy5kYXRhLnVzZXIsIG9wdGlvbnMuZGF0YS5ob3N0LCBvcHRpb25zLmRhdGEucG9ydCwgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMsIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5zY2hlbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnU0lQX1VSSScpIHsgb3B0aW9ucy5kYXRhID0gb3B0aW9ucy5kYXRhLnVyaTt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzaXBzXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic2lwc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwic2lwc1xcXCJcIiB9LFxuICAgICAgICAgIFwic2lwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic2lwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzaXBcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih1cmlfc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuc2NoZW1lID0gdXJpX3NjaGVtZTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51c2VyID0gZGVjb2RlVVJJQ29tcG9uZW50KHRleHQoKS5zbGljZSgwLCAtMSkpO30sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFzc3dvcmQgPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdCA9IHRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRhdGEuaG9zdDsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdF90eXBlID0gJ2RvbWFpbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQoKTsgfSxcbiAgICAgICAgICAvXlthLXpBLVowLTlfXFwtXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlthLXpBLVowLTlfXFxcXC1dXCIsIGRlc2NyaXB0aW9uOiBcIlthLXpBLVowLTlfXFxcXC1dXCIgfSxcbiAgICAgICAgICAvXlthLXpBLVowLTlcXC1dLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2EtekEtWjAtOVxcXFwtXVwiLCBkZXNjcmlwdGlvbjogXCJbYS16QS1aMC05XFxcXC1dXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGUgPSAnSVB2Nic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCgpOyB9LFxuICAgICAgICAgIFwiOjpcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI6OlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiOjpcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdF90eXBlID0gJ0lQdjYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0KCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdF90eXBlID0gJ0lQdjQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQoKTsgfSxcbiAgICAgICAgICBcIjI1XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiMjVcIiwgZGVzY3JpcHRpb246IFwiXFxcIjI1XFxcIlwiIH0sXG4gICAgICAgICAgL15bMC01XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlswLTVdXCIsIGRlc2NyaXB0aW9uOiBcIlswLTVdXCIgfSxcbiAgICAgICAgICBcIjJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIyXFxcIlwiIH0sXG4gICAgICAgICAgL15bMC00XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlswLTRdXCIsIGRlc2NyaXB0aW9uOiBcIlswLTRdXCIgfSxcbiAgICAgICAgICBcIjFcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIxXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIxXFxcIlwiIH0sXG4gICAgICAgICAgL15bMS05XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsxLTldXCIsIGRlc2NyaXB0aW9uOiBcIlsxLTldXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0ID0gcGFyc2VJbnQocG9ydC5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucG9ydCA9IHBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9ydDsgfSxcbiAgICAgICAgICBcInRyYW5zcG9ydD1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0cmFuc3BvcnQ9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0cmFuc3BvcnQ9XFxcIlwiIH0sXG4gICAgICAgICAgXCJ1ZHBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ1ZHBcIiwgZGVzY3JpcHRpb246IFwiXFxcInVkcFxcXCJcIiB9LFxuICAgICAgICAgIFwidGNwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidGNwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0Y3BcXFwiXCIgfSxcbiAgICAgICAgICBcInNjdHBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzY3RwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzY3RwXFxcIlwiIH0sXG4gICAgICAgICAgXCJ0bHNcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0bHNcIiwgZGVzY3JpcHRpb246IFwiXFxcInRsc1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zPXt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1sndHJhbnNwb3J0J10gPSB0cmFuc3BvcnQudG9Mb3dlckNhc2UoKTsgfSxcbiAgICAgICAgICBcInVzZXI9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidXNlcj1cIiwgZGVzY3JpcHRpb246IFwiXFxcInVzZXI9XFxcIlwiIH0sXG4gICAgICAgICAgXCJwaG9uZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInBob25lXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJwaG9uZVxcXCJcIiB9LFxuICAgICAgICAgIFwiaXBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJpcFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiaXBcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWyd1c2VyJ10gPSB1c2VyLnRvTG93ZXJDYXNlKCk7IH0sXG4gICAgICAgICAgXCJtZXRob2Q9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibWV0aG9kPVwiLCBkZXNjcmlwdGlvbjogXCJcXFwibWV0aG9kPVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zPXt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1snbWV0aG9kJ10gPSBtZXRob2Q7IH0sXG4gICAgICAgICAgXCJ0dGw9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidHRsPVwiLCBkZXNjcmlwdGlvbjogXCJcXFwidHRsPVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHR0bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnBhcmFtcykgb3B0aW9ucy5kYXRhLnBhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtc1sndHRsJ10gPSB0dGw7IH0sXG4gICAgICAgICAgXCJtYWRkcj1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtYWRkcj1cIiwgZGVzY3JpcHRpb246IFwiXFxcIm1hZGRyPVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG1hZGRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWydtYWRkciddID0gbWFkZHI7IH0sXG4gICAgICAgICAgXCJsclwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImxyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJsclxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zPXt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1snbHInXSA9IHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICBmdW5jdGlvbihwYXJhbSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbcGFyYW0udG9Mb3dlckNhc2UoKV0gPSB2YWx1ZSAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpO30sXG4gICAgICAgICAgZnVuY3Rpb24oaG5hbWUsIGh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBobmFtZSA9IGhuYW1lLmpvaW4oJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh2YWx1ZSA9IGh2YWx1ZS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfaGVhZGVycykgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzW2huYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVyc1tobmFtZV0gPSBbaHZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnNbaG5hbWVdLnB1c2goaHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvdHMgb2YgdGVzdHMgZmFpbCBpZiB0aGlzIGlzbid0IGd1YXJkZWQuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnUmVmZXJfVG8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaSA9IG5ldyBvcHRpb25zLlNJUC5VUkkob3B0aW9ucy5kYXRhLnNjaGVtZSwgb3B0aW9ucy5kYXRhLnVzZXIsIG9wdGlvbnMuZGF0YS5ob3N0LCBvcHRpb25zLmRhdGEucG9ydCwgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMsIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5zY2hlbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwiLy9cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIvL1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiLy9cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zY2hlbWU9IHRleHQoKTsgfSxcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJTSVBcIiwgZGVzY3JpcHRpb246IFwiXFxcIlNJUFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNpcF92ZXJzaW9uID0gdGV4dCgpOyB9LFxuICAgICAgICAgIFwiSU5WSVRFXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiSU5WSVRFXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJJTlZJVEVcXFwiXCIgfSxcbiAgICAgICAgICBcIkFDS1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIkFDS1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiQUNLXFxcIlwiIH0sXG4gICAgICAgICAgXCJWWEFDSFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlZYQUNIXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJWWEFDSFxcXCJcIiB9LFxuICAgICAgICAgIFwiT1BUSU9OU1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIk9QVElPTlNcIiwgZGVzY3JpcHRpb246IFwiXFxcIk9QVElPTlNcXFwiXCIgfSxcbiAgICAgICAgICBcIkJZRVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIkJZRVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiQllFXFxcIlwiIH0sXG4gICAgICAgICAgXCJDQU5DRUxcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJDQU5DRUxcIiwgZGVzY3JpcHRpb246IFwiXFxcIkNBTkNFTFxcXCJcIiB9LFxuICAgICAgICAgIFwiUkVHSVNURVJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJSRUdJU1RFUlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiUkVHSVNURVJcXFwiXCIgfSxcbiAgICAgICAgICBcIlNVQlNDUklCRVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlNVQlNDUklCRVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiU1VCU0NSSUJFXFxcIlwiIH0sXG4gICAgICAgICAgXCJOT1RJRllcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJOT1RJRllcIiwgZGVzY3JpcHRpb246IFwiXFxcIk5PVElGWVxcXCJcIiB9LFxuICAgICAgICAgIFwiUkVGRVJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJSRUZFUlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiUkVGRVJcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm1ldGhvZCA9IHRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRhdGEubWV0aG9kOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHN0YXR1c19jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnN0YXR1c19jb2RlID0gcGFyc2VJbnQoc3RhdHVzX2NvZGUuam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZWFzb25fcGhyYXNlID0gdGV4dCgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gdGV4dCgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHgsIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyW2lkeF0ucGFyc2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyKSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IG5ldyBvcHRpb25zLlNJUC5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51cmk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyLnB1c2goIHsgJ3Bvc2l0aW9uJzogcGVnJGN1cnJQb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0Jzogb2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyc2VkJzogaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7fSxcbiAgICAgICAgICBmdW5jdGlvbihkaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gdGV4dCgpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcGxheU5hbWVbMF0gPT09ICdcXFwiJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZS5zdWJzdHJpbmcoMSwgZGlzcGxheU5hbWUubGVuZ3RoLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTsgfSxcbiAgICAgICAgICBcInFcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJxXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJxXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEucGFyYW1zKSBvcHRpb25zLmRhdGEucGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtc1sncSddID0gcTsgfSxcbiAgICAgICAgICBcImV4cGlyZXNcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJleHBpcmVzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJleHBpcmVzXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXhwaXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEucGFyYW1zKSBvcHRpb25zLmRhdGEucGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtc1snZXhwaXJlcyddID0gZXhwaXJlczsgfSxcbiAgICAgICAgICBmdW5jdGlvbihkZWx0YV9zZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGRlbHRhX3NlY29uZHMuam9pbignJykpOyB9LFxuICAgICAgICAgIFwiMFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjBcIiwgZGVzY3JpcHRpb246IFwiXFxcIjBcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0ZXh0KCkpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHBhcmFtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEucGFyYW1zKSBvcHRpb25zLmRhdGEucGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXNbcGFyYW0udG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTt9LFxuICAgICAgICAgIFwicmVuZGVyXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVuZGVyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyZW5kZXJcXFwiXCIgfSxcbiAgICAgICAgICBcInNlc3Npb25cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzZXNzaW9uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzZXNzaW9uXFxcIlwiIH0sXG4gICAgICAgICAgXCJpY29uXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiaWNvblwiLCBkZXNjcmlwdGlvbjogXCJcXFwiaWNvblxcXCJcIiB9LFxuICAgICAgICAgIFwiYWxlcnRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhbGVydFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYWxlcnRcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnQ29udGVudF9EaXNwb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudHlwZSA9IHRleHQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwiaGFuZGxpbmdcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJoYW5kbGluZ1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiaGFuZGxpbmdcXFwiXCIgfSxcbiAgICAgICAgICBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwib3B0aW9uYWxcIiwgZGVzY3JpcHRpb246IFwiXFxcIm9wdGlvbmFsXFxcIlwiIH0sXG4gICAgICAgICAgXCJyZXF1aXJlZFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJlcXVpcmVkXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyZXF1aXJlZFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHBhcnNlSW50KGxlbmd0aC5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gdGV4dCgpOyB9LFxuICAgICAgICAgIFwidGV4dFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRleHRcIiwgZGVzY3JpcHRpb246IFwiXFxcInRleHRcXFwiXCIgfSxcbiAgICAgICAgICBcImltYWdlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiaW1hZ2VcIiwgZGVzY3JpcHRpb246IFwiXFxcImltYWdlXFxcIlwiIH0sXG4gICAgICAgICAgXCJhdWRpb1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImF1ZGlvXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhdWRpb1xcXCJcIiB9LFxuICAgICAgICAgIFwidmlkZW9cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ2aWRlb1wiLCBkZXNjcmlwdGlvbjogXCJcXFwidmlkZW9cXFwiXCIgfSxcbiAgICAgICAgICBcImFwcGxpY2F0aW9uXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYXBwbGljYXRpb25cIiwgZGVzY3JpcHRpb246IFwiXFxcImFwcGxpY2F0aW9uXFxcIlwiIH0sXG4gICAgICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibWVzc2FnZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwibWVzc2FnZVxcXCJcIiB9LFxuICAgICAgICAgIFwibXVsdGlwYXJ0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibXVsdGlwYXJ0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtdWx0aXBhcnRcXFwiXCIgfSxcbiAgICAgICAgICBcIngtXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwieC1cIiwgZGVzY3JpcHRpb246IFwiXFxcIngtXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oY3NlcV92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS52YWx1ZT1wYXJzZUludChjc2VxX3ZhbHVlLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihleHBpcmVzKSB7b3B0aW9ucy5kYXRhID0gZXhwaXJlczsgfSxcbiAgICAgICAgICBmdW5jdGlvbihldmVudF90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuZXZlbnQgPSBldmVudF90eXBlLnRvTG93ZXJDYXNlKCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSBvcHRpb25zLmRhdGEudGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG5ldyBvcHRpb25zLlNJUC5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWcpIHtvcHRpb25zLmRhdGEuc2V0UGFyYW0oJ3RhZycsdGFnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcInRhZ1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRhZ1wiLCBkZXNjcmlwdGlvbjogXCJcXFwidGFnXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odGFnKSB7b3B0aW9ucy5kYXRhLnRhZyA9IHRhZzsgfSxcbiAgICAgICAgICBmdW5jdGlvbihmb3J3YXJkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHBhcnNlSW50KGZvcndhcmRzLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihtaW5fZXhwaXJlcykge29wdGlvbnMuZGF0YSA9IG1pbl9leHBpcmVzOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG5ldyBvcHRpb25zLlNJUC5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGlnZXN0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiRGlnZXN0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJEaWdlc3RcXFwiXCIgfSxcbiAgICAgICAgICBcInJlYWxtXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVhbG1cIiwgZGVzY3JpcHRpb246IFwiXFxcInJlYWxtXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocmVhbG0pIHsgb3B0aW9ucy5kYXRhLnJlYWxtID0gcmVhbG07IH0sXG4gICAgICAgICAgXCJkb21haW5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJkb21haW5cIiwgZGVzY3JpcHRpb246IFwiXFxcImRvbWFpblxcXCJcIiB9LFxuICAgICAgICAgIFwibm9uY2VcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJub25jZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwibm9uY2VcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihub25jZSkgeyBvcHRpb25zLmRhdGEubm9uY2U9bm9uY2U7IH0sXG4gICAgICAgICAgXCJvcGFxdWVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJvcGFxdWVcIiwgZGVzY3JpcHRpb246IFwiXFxcIm9wYXF1ZVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG9wYXF1ZSkgeyBvcHRpb25zLmRhdGEub3BhcXVlPW9wYXF1ZTsgfSxcbiAgICAgICAgICBcInN0YWxlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic3RhbGVcIiwgZGVzY3JpcHRpb246IFwiXFxcInN0YWxlXFxcIlwiIH0sXG4gICAgICAgICAgXCJ0cnVlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidHJ1ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwidHJ1ZVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyBvcHRpb25zLmRhdGEuc3RhbGU9dHJ1ZTsgfSxcbiAgICAgICAgICBcImZhbHNlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZmFsc2VcIiwgZGVzY3JpcHRpb246IFwiXFxcImZhbHNlXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IG9wdGlvbnMuZGF0YS5zdGFsZT1mYWxzZTsgfSxcbiAgICAgICAgICBcImFsZ29yaXRobVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImFsZ29yaXRobVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYWxnb3JpdGhtXFxcIlwiIH0sXG4gICAgICAgICAgXCJtZDVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJNRDVcIiwgZGVzY3JpcHRpb246IFwiXFxcIk1ENVxcXCJcIiB9LFxuICAgICAgICAgIFwibWQ1LXNlc3NcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJNRDUtc2Vzc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiTUQ1LXNlc3NcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihhbGdvcml0aG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmFsZ29yaXRobT1hbGdvcml0aG0udG9VcHBlckNhc2UoKTsgfSxcbiAgICAgICAgICBcInFvcFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInFvcFwiLCBkZXNjcmlwdGlvbjogXCJcXFwicW9wXFxcIlwiIH0sXG4gICAgICAgICAgXCJhdXRoLWludFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImF1dGgtaW50XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhdXRoLWludFxcXCJcIiB9LFxuICAgICAgICAgIFwiYXV0aFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImF1dGhcIiwgZGVzY3JpcHRpb246IFwiXFxcImF1dGhcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihxb3BfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucW9wIHx8IChvcHRpb25zLmRhdGEucW9wPVtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucW9wLnB1c2gocW9wX3ZhbHVlLnRvTG93ZXJDYXNlKCkpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHJhY2tfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudmFsdWU9cGFyc2VJbnQocmFja192YWx1ZS5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCwgbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXJbaWR4XS5wYXJzZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIpIG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbmV3IG9wdGlvbnMuU0lQLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIucHVzaCggeyAncG9zaXRpb24nOiBwZWckY3VyclBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvZmZzZXQnOiBvZmZzZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwYXJzZWQnOiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTt9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IG9wdGlvbnMuU0lQLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEob3B0aW9ucy5kYXRhLnJlcGxhY2VzX2Zyb21fdGFnICYmIG9wdGlvbnMuZGF0YS5yZXBsYWNlc190b190YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsX2lkOiBvcHRpb25zLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJmcm9tLXRhZ1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImZyb20tdGFnXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJmcm9tLXRhZ1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGZyb21fdGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZXBsYWNlc19mcm9tX3RhZyA9IGZyb21fdGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcInRvLXRhZ1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRvLXRhZ1wiLCBkZXNjcmlwdGlvbjogXCJcXFwidG8tdGFnXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odG9fdGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZXBsYWNlc190b190YWcgPSB0b190YWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwiZWFybHktb25seVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImVhcmx5LW9ubHlcIiwgZGVzY3JpcHRpb246IFwiXFxcImVhcmx5LW9ubHlcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmVhcmx5X29ubHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihyKSB7cmV0dXJuIHI7fSxcbiAgICAgICAgICBmdW5jdGlvbihmaXJzdCwgcmVzdCkgeyByZXR1cm4gbGlzdChmaXJzdCwgcmVzdCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnUmVxdWlyZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB2YWx1ZSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihyc2VxX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnZhbHVlPXBhcnNlSW50KHJzZXFfdmFsdWUuam9pbignJykpOyB9LFxuICAgICAgICAgIFwiYWN0aXZlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYWN0aXZlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhY3RpdmVcXFwiXCIgfSxcbiAgICAgICAgICBcInBlbmRpbmdcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJwZW5kaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJwZW5kaW5nXFxcIlwiIH0sXG4gICAgICAgICAgXCJ0ZXJtaW5hdGVkXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidGVybWluYXRlZFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidGVybWluYXRlZFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zdGF0ZSA9IHRleHQoKTsgfSxcbiAgICAgICAgICBcInJlYXNvblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJlYXNvblwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVhc29uXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFzb24gIT09ICd1bmRlZmluZWQnKSBvcHRpb25zLmRhdGEucmVhc29uID0gcmVhc29uOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGV4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cGlyZXMgIT09ICd1bmRlZmluZWQnKSBvcHRpb25zLmRhdGEuZXhwaXJlcyA9IGV4cGlyZXM7IH0sXG4gICAgICAgICAgXCJyZXRyeV9hZnRlclwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJldHJ5X2FmdGVyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyZXRyeV9hZnRlclxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHJldHJ5X2FmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXRyeV9hZnRlciAhPT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMuZGF0YS5yZXRyeV9hZnRlciA9IHJldHJ5X2FmdGVyOyB9LFxuICAgICAgICAgIFwiZGVhY3RpdmF0ZWRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJkZWFjdGl2YXRlZFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZGVhY3RpdmF0ZWRcXFwiXCIgfSxcbiAgICAgICAgICBcInByb2JhdGlvblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInByb2JhdGlvblwiLCBkZXNjcmlwdGlvbjogXCJcXFwicHJvYmF0aW9uXFxcIlwiIH0sXG4gICAgICAgICAgXCJyZWplY3RlZFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJlamVjdGVkXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyZWplY3RlZFxcXCJcIiB9LFxuICAgICAgICAgIFwidGltZW91dFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRpbWVvdXRcIiwgZGVzY3JpcHRpb246IFwiXFxcInRpbWVvdXRcXFwiXCIgfSxcbiAgICAgICAgICBcImdpdmV1cFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImdpdmV1cFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZ2l2ZXVwXFxcIlwiIH0sXG4gICAgICAgICAgXCJub3Jlc291cmNlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibm9yZXNvdXJjZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwibm9yZXNvdXJjZVxcXCJcIiB9LFxuICAgICAgICAgIFwiaW52YXJpYW50XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiaW52YXJpYW50XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJpbnZhcmlhbnRcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdTdXBwb3J0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gdmFsdWUgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gb3B0aW9ucy5kYXRhLnRhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IG9wdGlvbnMuU0lQLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWcpIHtvcHRpb25zLmRhdGEuc2V0UGFyYW0oJ3RhZycsdGFnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0dGxcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0dGxcIiwgZGVzY3JpcHRpb246IFwiXFxcInR0bFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZpYV90dGxfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnR0bCA9IHZpYV90dGxfdmFsdWU7IH0sXG4gICAgICAgICAgXCJtYWRkclwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1hZGRyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtYWRkclxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZpYV9tYWRkcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEubWFkZHIgPSB2aWFfbWFkZHI7IH0sXG4gICAgICAgICAgXCJyZWNlaXZlZFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJlY2VpdmVkXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyZWNlaXZlZFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZpYV9yZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmVjZWl2ZWQgPSB2aWFfcmVjZWl2ZWQ7IH0sXG4gICAgICAgICAgXCJicmFuY2hcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJicmFuY2hcIiwgZGVzY3JpcHRpb246IFwiXFxcImJyYW5jaFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZpYV9icmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmJyYW5jaCA9IHZpYV9icmFuY2g7IH0sXG4gICAgICAgICAgXCJycG9ydFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJwb3J0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJycG9ydFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgcmVzcG9uc2VfcG9ydCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJwb3J0ID0gcmVzcG9uc2VfcG9ydC5qb2luKCcnKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbih2aWFfcHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnByb3RvY29sID0gdmlhX3Byb3RvY29sOyB9LFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlVEUFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiVURQXFxcIlwiIH0sXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiVENQXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJUQ1BcXFwiXCIgfSxcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJUTFNcIiwgZGVzY3JpcHRpb246IFwiXFxcIlRMU1xcXCJcIiB9LFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlNDVFBcIiwgZGVzY3JpcHRpb246IFwiXFxcIlNDVFBcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih2aWFfdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS50cmFuc3BvcnQgPSB2aWFfdHJhbnNwb3J0OyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdCA9IHRleHQoKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbih2aWFfc2VudF9ieV9wb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wb3J0ID0gcGFyc2VJbnQodmlhX3NlbnRfYnlfcG9ydC5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24odHRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0dGwuam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGRlbHRhU2Vjb25kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdTZXNzaW9uX0V4cGlyZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmRlbHRhU2Vjb25kcyA9IGRlbHRhU2Vjb25kcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcInJlZnJlc2hlclwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJlZnJlc2hlclwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVmcmVzaGVyXFxcIlwiIH0sXG4gICAgICAgICAgXCJ1YXNcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ1YXNcIiwgZGVzY3JpcHRpb246IFwiXFxcInVhc1xcXCJcIiB9LFxuICAgICAgICAgIFwidWFjXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidWFjXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ1YWNcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdTZXNzaW9uX0V4cGlyZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlZnJlc2hlciA9IGVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGRlbHRhU2Vjb25kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdNaW5fU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gZGVsdGFTZWNvbmRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwic3R1bnNcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzdHVuc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwic3R1bnNcXFwiXCIgfSxcbiAgICAgICAgICBcInN0dW5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzdHVuXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzdHVuXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zY2hlbWUgPSBzY2hlbWU7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oaG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdCA9IGhvc3Q7IH0sXG4gICAgICAgICAgXCI/dHJhbnNwb3J0PVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj90cmFuc3BvcnQ9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI/dHJhbnNwb3J0PVxcXCJcIiB9LFxuICAgICAgICAgIFwidHVybnNcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0dXJuc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwidHVybnNcXFwiXCIgfSxcbiAgICAgICAgICBcInR1cm5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0dXJuXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0dXJuXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gdGV4dCgpOyB9XG4gICAgICAgIF0sXG5cbiAgICAgICAgcGVnJGJ5dGVjb2RlID0gW1xuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuIFxcXCJcXFwiMiAzIVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMFxcXCJcXFwiXFxcIjEhMyNcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjAkXFxcIlxcXCIxITMlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwJlxcXCJcXFwiMSEzJ1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNycqIyBcXFwiNyhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjAoXFxcIlxcXCIxITMpXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwKlxcXCJcXFwiMSEzK1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLixcXFwiXFxcIjIsMy1cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi4uXFxcIlxcXCIyLjMvXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwMFxcXCJcXFwiMSEzMVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLjJcXFwiXFxcIjIyMzMqXFx4ODkgXFxcIi40XFxcIlxcXCIyNDM1Kn0gXFxcIi42XFxcIlxcXCIyNjM3KnEgXFxcIi44XFxcIlxcXCIyODM5KmUgXFxcIi46XFxcIlxcXCIyOjM7KlkgXFxcIi48XFxcIlxcXCIyPDM9Kk0gXFxcIi4+XFxcIlxcXCIyPjM/KkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5CXFxcIlxcXCIyQjNDKikgXFxcIi5EXFxcIlxcXCIyRDNFXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3KSojIFxcXCI3LFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLkZcXFwiXFxcIjJGM0cqfSBcXFwiLkhcXFwiXFxcIjJIM0kqcSBcXFwiLkpcXFwiXFxcIjJKM0sqZSBcXFwiLkxcXFwiXFxcIjJMM00qWSBcXFwiLk5cXFwiXFxcIjJOM08qTSBcXFwiLlBcXFwiXFxcIjJQM1EqQSBcXFwiLlJcXFwiXFxcIjJSM1MqNSBcXFwiLlRcXFwiXFxcIjJUM1UqKSBcXFwiLlZcXFwiXFxcIjJWM1dcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhLllcXFwiXFxcIjJZM1orNyQ3IystJTcjKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISEgXFxcXDckLCMmNyRcXFwiKy0kNyArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrQCQgXFxcXDckKyYkLCMmNyRcXFwiXFxcIlxcXCIgWCsnJTRcXFwiNl1cXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcuKiMgXFxcIiBbXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3JyojIFxcXCI3KCwpJjcnKiMgXFxcIjcoXFxcIitBJC44XFxcIlxcXCIyODM5KzElNy8rJyU0IzZeIyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhIFxcXFw3MismJCwjJjcyXFxcIlxcXCJcXFwiIFgrbyQgXFxcXCEgXFxcXDcuLCMmNy5cXFwiKy0kNzIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsQCYhIFxcXFw3LiwjJjcuXFxcIistJDcyKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwX1xcXCJcXFwiMSEzYCojIFxcXCI3M1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMGFcXFwiXFxcIjEhM2JcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjBjXFxcIlxcXCIxITNkXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3ISopIFxcXCIwZVxcXCJcXFwiMSEzZlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNykqXFx4OTUgXFxcIi5GXFxcIlxcXCIyRjNHKlxceDg5IFxcXCIuSlxcXCJcXFwiMkozSyp9IFxcXCIuTFxcXCJcXFwiMkwzTSpxIFxcXCIuWVxcXCJcXFwiMlkzWiplIFxcXCIuUFxcXCJcXFwiMlAzUSpZIFxcXCIuSFxcXCJcXFwiMkgzSSpNIFxcXCIuQFxcXCJcXFwiMkAzQSpBIFxcXCIuZ1xcXCJcXFwiMmczaCo1IFxcXCIuUlxcXCJcXFwiMlIzUyopIFxcXCIuTlxcXCJcXFwiMk4zTytcXHg5RSQsXFx4OUImNykqXFx4OTUgXFxcIi5GXFxcIlxcXCIyRjNHKlxceDg5IFxcXCIuSlxcXCJcXFwiMkozSyp9IFxcXCIuTFxcXCJcXFwiMkwzTSpxIFxcXCIuWVxcXCJcXFwiMlkzWiplIFxcXCIuUFxcXCJcXFwiMlAzUSpZIFxcXCIuSFxcXCJcXFwiMkgzSSpNIFxcXCIuQFxcXCJcXFwiMkAzQSpBIFxcXCIuZ1xcXCJcXFwiMmczaCo1IFxcXCIuUlxcXCJcXFwiMlIzUyopIFxcXCIuTlxcXCJcXFwiMk4zT1xcXCJcXFwiXFxcIiBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDcpKlxceDg5IFxcXCIuRlxcXCJcXFwiMkYzRyp9IFxcXCIuTFxcXCJcXFwiMkwzTSpxIFxcXCIuWVxcXCJcXFwiMlkzWiplIFxcXCIuUFxcXCJcXFwiMlAzUSpZIFxcXCIuSFxcXCJcXFwiMkgzSSpNIFxcXCIuQFxcXCJcXFwiMkAzQSpBIFxcXCIuZ1xcXCJcXFwiMmczaCo1IFxcXCIuUlxcXCJcXFwiMlIzUyopIFxcXCIuTlxcXCJcXFwiMk4zTytcXHg5MiQsXFx4OEYmNykqXFx4ODkgXFxcIi5GXFxcIlxcXCIyRjNHKn0gXFxcIi5MXFxcIlxcXCIyTDNNKnEgXFxcIi5ZXFxcIlxcXCIyWTNaKmUgXFxcIi5QXFxcIlxcXCIyUDNRKlkgXFxcIi5IXFxcIlxcXCIySDNJKk0gXFxcIi5AXFxcIlxcXCIyQDNBKkEgXFxcIi5nXFxcIlxcXCIyZzNoKjUgXFxcIi5SXFxcIlxcXCIyUjNTKikgXFxcIi5OXFxcIlxcXCIyTjNPXFxcIlxcXCJcXFwiIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlRcXFwiXFxcIjJUM1UqXFx4RTMgXFxcIi5WXFxcIlxcXCIyVjNXKlxceEQ3IFxcXCIuaVxcXCJcXFwiMmkzaipcXHhDQiBcXFwiLmtcXFwiXFxcIjJrM2wqXFx4QkYgXFxcIi46XFxcIlxcXCIyOjM7KlxceEIzIFxcXCIuRFxcXCJcXFwiMkQzRSpcXHhBNyBcXFwiLjJcXFwiXFxcIjIyMzMqXFx4OUIgXFxcIi44XFxcIlxcXCIyODM5KlxceDhGIFxcXCIubVxcXCJcXFwiMm0zbipcXHg4MyBcXFwiNyYqfSBcXFwiLjRcXFwiXFxcIjI0MzUqcSBcXFwiLm9cXFwiXFxcIjJvM3AqZSBcXFwiLnFcXFwiXFxcIjJxM3IqWSBcXFwiLjZcXFwiXFxcIjI2MzcqTSBcXFwiLj5cXFwiXFxcIjI+Mz8qQSBcXFwiLnNcXFwiXFxcIjJzM3QqNSBcXFwiLnVcXFwiXFxcIjJ1M3YqKSBcXFwiNycqIyBcXFwiNyhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDcpKlxcdTAxMkIgXFxcIi5GXFxcIlxcXCIyRjNHKlxcdTAxMUYgXFxcIi5KXFxcIlxcXCIySjNLKlxcdTAxMTMgXFxcIi5MXFxcIlxcXCIyTDNNKlxcdTAxMDcgXFxcIi5ZXFxcIlxcXCIyWTNaKlxceEZCIFxcXCIuUFxcXCJcXFwiMlAzUSpcXHhFRiBcXFwiLkhcXFwiXFxcIjJIM0kqXFx4RTMgXFxcIi5AXFxcIlxcXCIyQDNBKlxceEQ3IFxcXCIuZ1xcXCJcXFwiMmczaCpcXHhDQiBcXFwiLlJcXFwiXFxcIjJSM1MqXFx4QkYgXFxcIi5OXFxcIlxcXCIyTjNPKlxceEIzIFxcXCIuVFxcXCJcXFwiMlQzVSpcXHhBNyBcXFwiLlZcXFwiXFxcIjJWM1cqXFx4OUIgXFxcIi5pXFxcIlxcXCIyaTNqKlxceDhGIFxcXCIua1xcXCJcXFwiMmszbCpcXHg4MyBcXFwiLjhcXFwiXFxcIjI4MzkqdyBcXFwiLm1cXFwiXFxcIjJtM24qayBcXFwiNyYqZSBcXFwiLjRcXFwiXFxcIjI0MzUqWSBcXFwiLm9cXFwiXFxcIjJvM3AqTSBcXFwiLnFcXFwiXFxcIjJxM3IqQSBcXFwiLjZcXFwiXFxcIjI2MzcqNSBcXFwiLnNcXFwiXFxcIjJzM3QqKSBcXFwiLnVcXFwiXFxcIjJ1M3YrXFx1MDEzNCQsXFx1MDEzMSY3KSpcXHUwMTJCIFxcXCIuRlxcXCJcXFwiMkYzRypcXHUwMTFGIFxcXCIuSlxcXCJcXFwiMkozSypcXHUwMTEzIFxcXCIuTFxcXCJcXFwiMkwzTSpcXHUwMTA3IFxcXCIuWVxcXCJcXFwiMlkzWipcXHhGQiBcXFwiLlBcXFwiXFxcIjJQM1EqXFx4RUYgXFxcIi5IXFxcIlxcXCIySDNJKlxceEUzIFxcXCIuQFxcXCJcXFwiMkAzQSpcXHhENyBcXFwiLmdcXFwiXFxcIjJnM2gqXFx4Q0IgXFxcIi5SXFxcIlxcXCIyUjNTKlxceEJGIFxcXCIuTlxcXCJcXFwiMk4zTypcXHhCMyBcXFwiLlRcXFwiXFxcIjJUM1UqXFx4QTcgXFxcIi5WXFxcIlxcXCIyVjNXKlxceDlCIFxcXCIuaVxcXCJcXFwiMmkzaipcXHg4RiBcXFwiLmtcXFwiXFxcIjJrM2wqXFx4ODMgXFxcIi44XFxcIlxcXCIyODM5KncgXFxcIi5tXFxcIlxcXCIybTNuKmsgXFxcIjcmKmUgXFxcIi40XFxcIlxcXCIyNDM1KlkgXFxcIi5vXFxcIlxcXCIybzNwKk0gXFxcIi5xXFxcIlxcXCIycTNyKkEgXFxcIi42XFxcIlxcXCIyNjM3KjUgXFxcIi5zXFxcIlxcXCIyczN0KikgXFxcIi51XFxcIlxcXCIydTN2XFxcIlxcXCJcXFwiIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK0EkLlBcXFwiXFxcIjJQM1ErMSU3LysnJTQjNncjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK0EkLjRcXFwiXFxcIjI0MzUrMSU3LysnJTQjNngjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK0EkLj5cXFwiXFxcIjI+Mz8rMSU3LysnJTQjNnkjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK0EkLlRcXFwiXFxcIjJUM1UrMSU3LysnJTQjNnojICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK0EkLlZcXFwiXFxcIjJWM1crMSU3LysnJTQjNnsjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5rXFxcIlxcXCIyazNsKzEkNy8rJyU0XFxcIjZ8XFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rNyQuaVxcXCJcXFwiMmkzaisnJTRcXFwiNn1cXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC5EXFxcIlxcXCIyRDNFKzElNy8rJyU0IzZ+IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC4yXFxcIlxcXCIyMjMzKzElNy8rJyU0IzZ/IyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LytBJC44XFxcIlxcXCIyODM5KzElNy8rJyU0IzZcXHg4MCMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rMSQ3JisnJTRcXFwiNlxceDgxXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNyYrMSQ3LysnJTRcXFwiNlxceDgxXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNz0rVyQgXFxcXDdHKikgXFxcIjdLKiMgXFxcIjdGLC8mN0cqKSBcXFwiN0sqIyBcXFwiN0ZcXFwiKy0lNz4rIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMFxceDgyXFxcIlxcXCIxITNcXHg4MypBIFxcXCIwXFx4ODRcXFwiXFxcIjEhM1xceDg1KjUgXFxcIjBcXHg4NlxcXCJcXFwiMSEzXFx4ODcqKSBcXFwiNzMqIyBcXFwiNy5cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhNy8rVSQ3JitLJSBcXFxcN0oqIyBcXFwiN0ssKSY3SiojIFxcXCI3S1xcXCIrLSU3JisjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK2AkNyYrViUhIFxcXFw3SiojIFxcXCI3SywpJjdKKiMgXFxcIjdLXFxcIishICglKzIlNyYrKCU0JDZcXHg4OCQhISUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3LipHIFxcXCIuTFxcXCJcXFwiMkwzTSo7IFxcXCIwXFx4ODlcXFwiXFxcIjEhM1xceDhBKi8gXFxcIjBcXHg4NlxcXCJcXFwiMSEzXFx4ODcqIyBcXFwiNzNcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEubVxcXCJcXFwiMm0zbitLJDBcXHg4QlxcXCJcXFwiMSEzXFx4OEMqNSBcXFwiMFxceDhEXFxcIlxcXCIxITNcXHg4RSopIFxcXCIwXFx4OEZcXFwiXFxcIjEhM1xceDkwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN04rUSQuOFxcXCJcXFwiMjgzOStBJTdPKiMgXFxcIiBbKzElN1MrJyU0JDZcXHg5MSQgJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3TitrJC44XFxcIlxcXCIyODM5K1slN08qIyBcXFwiIFsrSyU3UytBJTdfKzclN2wqIyBcXFwiIFsrJyU0JjZcXHg5MiYgJSQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceDkzXFxcIlxcXCIxJDNcXHg5NCopIFxcXCIvXFx4OTVcXFwiXFxcIjEjM1xceDk2KycgNCE2XFx4OTchISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1ArYiQhLjhcXFwiXFxcIjI4MzkrLSQ3UisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWys3JS46XFxcIlxcXCIyOjM7KyclNCM2XFx4OTgjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3KyopIFxcXCI3LSojIFxcXCI3USsyJCwvJjcrKikgXFxcIjctKiMgXFxcIjdRXFxcIlxcXCJcXFwiIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi48XFxcIlxcXCIyPDM9KnEgXFxcIi4+XFxcIlxcXCIyPjM/KmUgXFxcIi5AXFxcIlxcXCIyQDNBKlkgXFxcIi5CXFxcIlxcXCIyQjNDKk0gXFxcIi5EXFxcIlxcXCIyRDNFKkEgXFxcIi4yXFxcIlxcXCIyMjMzKjUgXFxcIi42XFxcIlxcXCIyNjM3KikgXFxcIi40XFxcIlxcXCIyNDM1XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3KypfIFxcXCI3LSpZIFxcXCIuPFxcXCJcXFwiMjwzPSpNIFxcXCIuPlxcXCJcXFwiMj4zPypBIFxcXCIuQFxcXCJcXFwiMkAzQSo1IFxcXCIuQlxcXCJcXFwiMkIzQyopIFxcXCIuRFxcXCJcXFwiMkQzRSxlJjcrKl8gXFxcIjctKlkgXFxcIi48XFxcIlxcXCIyPDM9Kk0gXFxcIi4+XFxcIlxcXCIyPjM/KkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5CXFxcIlxcXCIyQjNDKikgXFxcIi5EXFxcIlxcXCIyRDNFXFxcIismIDQhNlxceDk5ISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1QrTiQhLjhcXFwiXFxcIjI4MzkrLSQ3XisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdVKikgXFxcIjdcXFxcKiMgXFxcIjdYKyYgNCE2XFx4OUEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXCE3ViszJC5KXFxcIlxcXCIySjNLKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLD4mITdWKzMkLkpcXFwiXFxcIjJKM0srIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiK0ckN1crPSUuSlxcXCJcXFwiMkozSyojIFxcXCIgWysnJTQjNlxceDlCIyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcMFxceDlDXFxcIlxcXCIxITNcXHg5RCssJCwpJjBcXHg5Q1xcXCJcXFwiMSEzXFx4OURcXFwiXFxcIlxcXCIgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITAkXFxcIlxcXCIxITMlK0EkIFxcXFwwXFx4OUVcXFwiXFxcIjEhM1xceDlGLCkmMFxceDlFXFxcIlxcXCIxITNcXHg5RlxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEub1xcXCJcXFwiMm8zcCtBJDdZKzclLnFcXFwiXFxcIjJxM3IrJyU0IzZcXHhBMCMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITdaK1xceEJGJC44XFxcIlxcXCIyODM5K1xceEFGJTdaK1xceEE1JS44XFxcIlxcXCIyODM5K1xceDk1JTdaK1xceDhCJS44XFxcIlxcXCIyODM5K3slN1orcSUuOFxcXCJcXFwiMjgzOSthJTdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnLSUkLSMgWCQsIyBYJCsjIFgkKiMgWCQpIyBYJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTA4MzggXFxcIiEuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMitcXHhBRiQ3WitcXHhBNSUuOFxcXCJcXFwiMjgzOStcXHg5NSU3WitcXHg4QiUuOFxcXCJcXFwiMjgzOSt7JTdaK3ElLjhcXFwiXFxcIjI4MzkrYSU3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJywlJCwjIFgkKyMgWCQqIyBYJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDc5NSBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK1xceDk1JDdaK1xceDhCJS44XFxcIlxcXCIyODM5K3slN1orcSUuOFxcXCJcXFwiMjgzOSthJTdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnKiUkKiMgWCQpIyBYJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTA3MEMgXFxcIiEuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMit7JDdaK3ElLjhcXFwiXFxcIjI4MzkrYSU3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyglJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTA2OUQgXFxcIiEuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMithJDdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnJiUkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNjQ4IFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrRyQ3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTA2MEQgXFxcIiEuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMistJDdbKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKlxcdTA1RUMgXFxcIiEuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMistJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKlxcdTA1Q0IgXFxcIiE3WitcXHhBNSQuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMitcXHg5NSU3WitcXHg4QiUuOFxcXCJcXFwiMjgzOSt7JTdaK3ElLjhcXFwiXFxcIjI4MzkrYSU3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyslJCsjIFgkKiMgWCQpIyBYJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTA1MzggXFxcIiE3WitcXHhCNiQhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHg4QiUuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMit7JTdaK3ElLjhcXFwiXFxcIjI4MzkrYSU3WitXJS44XFxcIlxcXCIyODM5K0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyolJCojIFgkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNDk0IFxcXCIhN1orXFx4QzckIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4OUMlIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrcSUuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMithJTdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnKSUkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwM0RGIFxcXCIhN1orXFx4RDgkIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4QUQlIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4ODIlIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrVyUuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMitHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScoJSQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwMzE5IFxcXCIhN1orXFx4RTkkIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4QkUlIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4OTMlIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsraCUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWys9JS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyKy0lN1srIyUnJyUkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTAyNDIgXFxcIiE3WitcXHUwMTE0JCEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceEU5JSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceEJFJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceDkzJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK2glIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrPSUuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMistJTdaKyMlJyglJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTAxNDAgXFxcIiE3WitcXHUwMTM1JCEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xcdTAxMEElIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4REYlIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4QjQlIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4ODklIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXiUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWyszJS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyKyMlJyglJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKyYgNCE2XFx4QTMhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3IytTJDcjKiMgXFxcIiBbK0MlNyMqIyBcXFwiIFsrMyU3IyojIFxcXCIgWysjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3Wis9JC44XFxcIlxcXCIyODM5Ky0lN1orIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWCojIFxcXCI3XFxcXFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITddK3UkLkpcXFwiXFxcIjJKM0srZSU3XStbJS5KXFxcIlxcXCIySjNLK0slN10rQSUuSlxcXCJcXFwiMkozSysxJTddKyclNCc2XFx4QTQnICUkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEE1XFxcIlxcXCIyXFx4QTUzXFx4QTYrMyQwXFx4QTdcXFwiXFxcIjEhM1xceEE4KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKlxceEEwIFxcXCIhLlxceEE5XFxcIlxcXCIyXFx4QTkzXFx4QUErPSQwXFx4QUJcXFwiXFxcIjEhM1xceEFDKy0lNyErIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWCpvIFxcXCIhLlxceEFEXFxcIlxcXCIyXFx4QUQzXFx4QUUrNyQ3ISstJTchKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFgqRCBcXFwiITBcXHhBRlxcXCJcXFwiMSEzXFx4QjArLSQ3ISsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCI3IVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3ISojIFxcXCIgWytjJDchKiMgXFxcIiBbK1MlNyEqIyBcXFwiIFsrQyU3ISojIFxcXCIgWyszJTchKiMgXFxcIiBbKyMlJyUlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKycgNCE2XFx4QjEhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXCEuMlxcXCJcXFwiMjIzMystJDdgKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLD4mIS4yXFxcIlxcXCIyMjMzKy0kN2ArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3YSpBIFxcXCI3Yio7IFxcXCI3Yyo1IFxcXCI3ZCovIFxcXCI3ZSopIFxcXCI3ZiojIFxcXCI3Z1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhCMlxcXCJcXFwiMSozXFx4QjMrYiQvXFx4QjRcXFwiXFxcIjEjM1xceEI1KkcgXFxcIi9cXHhCNlxcXCJcXFwiMSMzXFx4QjcqOyBcXFwiL1xceEI4XFxcIlxcXCIxJDNcXHhCOSovIFxcXCIvXFx4QkFcXFwiXFxcIjEjM1xceEJCKiMgXFxcIjc2KyglNFxcXCI2XFx4QkNcXFwiISAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEJEXFxcIlxcXCIxJTNcXHhCRStKJC9cXHhCRlxcXCJcXFwiMSUzXFx4QzAqLyBcXFwiL1xceEMxXFxcIlxcXCIxXFxcIjNcXHhDMiojIFxcXCI3NisoJTRcXFwiNlxceEMzXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhDNFxcXCJcXFwiMSczXFx4QzUrMiQ3XFx4OEYrKCU0XFxcIjZcXHhDNlxcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4QzdcXFwiXFxcIjEkM1xceEM4KzIkN1xceEVGKyglNFxcXCI2XFx4QzlcXFwiISAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceENBXFxcIlxcXCIxJjNcXHhDQisyJDdUKyglNFxcXCI2XFx4Q0NcXFwiISAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceENEXFxcIlxcXCIxXFxcIjNcXHhDRStSJCEuPlxcXCJcXFwiMj4zPystJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyclNFxcXCI2XFx4Q0ZcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3aCtUJCEuPlxcXCJcXFwiMj4zPystJDdpKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyklNFxcXCI2XFx4RDBcXFwiXFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcN2orJiQsIyY3alxcXCJcXFwiXFxcIiBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDdqKyYkLCMmN2pcXFwiXFxcIlxcXCIgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3ayopIFxcXCI3KyojIFxcXCI3LVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLm9cXFwiXFxcIjJvM3AqZSBcXFwiLnFcXFwiXFxcIjJxM3IqWSBcXFwiLjRcXFwiXFxcIjI0MzUqTSBcXFwiLjhcXFwiXFxcIjI4MzkqQSBcXFwiLjxcXFwiXFxcIjI8Mz0qNSBcXFwiLkBcXFwiXFxcIjJAM0EqKSBcXFwiLkJcXFwiXFxcIjJCM0NcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuNlxcXCJcXFwiMjYzNyt1JDdtK2slIFxcXFwhLjxcXFwiXFxcIjI8Mz0rLSQ3bSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw+JiEuPFxcXCJcXFwiMjwzPSstJDdtKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN24rQyQuPlxcXCJcXFwiMj4zPyszJTdvKyklNCM2XFx4RDEjXFxcIlxcXCIgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDdwKikgXFxcIjcrKiMgXFxcIjctKzIkLC8mN3AqKSBcXFwiNysqIyBcXFwiNy1cXFwiXFxcIlxcXCIgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3cCopIFxcXCI3KyojIFxcXCI3LSwvJjdwKikgXFxcIjcrKiMgXFxcIjctXFxcIlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLm9cXFwiXFxcIjJvM3AqZSBcXFwiLnFcXFwiXFxcIjJxM3IqWSBcXFwiLjRcXFwiXFxcIjI0MzUqTSBcXFwiLjZcXFwiXFxcIjI2MzcqQSBcXFwiLjhcXFwiXFxcIjI4MzkqNSBcXFwiLkBcXFwiXFxcIjJAM0EqKSBcXFwiLkJcXFwiXFxcIjJCM0NcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHg5MCojIFxcXCI3clwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg4RitLJDcnK0ElN3MrNyU3JystJTdcXHg4NCsjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN00qIyBcXFwiN3RcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3fytHJC44XFxcIlxcXCIyODM5KzclN3UqIyBcXFwiN3grJyU0IzZcXHhEMiMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN3YqIyBcXFwiN3crTiQhLjZcXFwiXFxcIjI2MzcrLSQ3XFx4ODMrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4RDNcXFwiXFxcIjJcXHhEMzNcXHhENCs9JDdcXHg4MCszJTd3KiMgXFxcIiBbKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuNFxcXCJcXFwiMjQzNSstJDd7KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN3orNSQgXFxcXDd5LCMmN3lcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3KiopIFxcXCI3KyojIFxcXCI3LVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNysqXFx4OEYgXFxcIjctKlxceDg5IFxcXCIuMlxcXCJcXFwiMjIzMyp9IFxcXCIuNlxcXCJcXFwiMjYzNypxIFxcXCIuOFxcXCJcXFwiMjgzOSplIFxcXCIuOlxcXCJcXFwiMjozOypZIFxcXCIuPFxcXCJcXFwiMjwzPSpNIFxcXCIuPlxcXCJcXFwiMj4zPypBIFxcXCIuQFxcXCJcXFwiMkAzQSo1IFxcXCIuQlxcXCJcXFwiMkIzQyopIFxcXCIuRFxcXCJcXFwiMkQzRVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITd8K2skIFxcXFwhLjRcXFwiXFxcIjI0MzUrLSQ3fCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw+JiEuNFxcXCJcXFwiMjQzNSstJDd8KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcN34sIyY3flxcXCIrayQgXFxcXCEuMlxcXCJcXFwiMjIzMystJDd9KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLD4mIS4yXFxcIlxcXCIyMjMzKy0kN30rIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDd+LCMmN35cXFwiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3Kyp3IFxcXCI3LSpxIFxcXCIuOFxcXCJcXFwiMjgzOSplIFxcXCIuOlxcXCJcXFwiMjozOypZIFxcXCIuPFxcXCJcXFwiMjwzPSpNIFxcXCIuPlxcXCJcXFwiMj4zPypBIFxcXCIuQFxcXCJcXFwiMkAzQSo1IFxcXCIuQlxcXCJcXFwiMkIzQyopIFxcXCIuRFxcXCJcXFwiMkQzRVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXFwiK1xceDhEJCBcXFxcN1xcXCIqRyBcXFwiNyEqQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkZcXFwiXFxcIjJGM0cqKSBcXFwiLkpcXFwiXFxcIjJKM0ssTSY3XFxcIipHIFxcXCI3ISpBIFxcXCIuQFxcXCJcXFwiMkAzQSo1IFxcXCIuRlxcXCJcXFwiMkYzRyopIFxcXCIuSlxcXCJcXFwiMkozS1xcXCIrJyU0XFxcIjZcXHhENVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceDgxKiMgXFxcIjdcXHg4MlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3TyszJC46XFxcIlxcXCIyOjM7KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKy0kN1MrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFtcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcNysqXFx4ODMgXFxcIjctKn0gXFxcIi5CXFxcIlxcXCIyQjNDKnEgXFxcIi5EXFxcIlxcXCIyRDNFKmUgXFxcIi4yXFxcIlxcXCIyMjMzKlkgXFxcIi44XFxcIlxcXCIyODM5Kk0gXFxcIi46XFxcIlxcXCIyOjM7KkEgXFxcIi48XFxcIlxcXCIyPDM9KjUgXFxcIi4+XFxcIlxcXCIyPjM/KikgXFxcIi5AXFxcIlxcXCIyQDNBK1xceDhDJCxcXHg4OSY3KypcXHg4MyBcXFwiNy0qfSBcXFwiLkJcXFwiXFxcIjJCM0MqcSBcXFwiLkRcXFwiXFxcIjJEM0UqZSBcXFwiLjJcXFwiXFxcIjIyMzMqWSBcXFwiLjhcXFwiXFxcIjI4MzkqTSBcXFwiLjpcXFwiXFxcIjI6MzsqQSBcXFwiLjxcXFwiXFxcIjI8Mz0qNSBcXFwiLj5cXFwiXFxcIjI+Mz8qKSBcXFwiLkBcXFwiXFxcIjJAM0FcXFwiXFxcIlxcXCIgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3eSwjJjd5XFxcIlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHg5NVxcXCJcXFwiMSMzXFx4RDYreSQuNFxcXCJcXFwiMjQzNStpJSBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYK1AlLkpcXFwiXFxcIjJKM0srQCUgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCsnJTQlNlxceEQ3JSAlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RDhcXFwiXFxcIjJcXHhEODNcXHhEOVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceERBXFxcIlxcXCIyXFx4REEzXFx4REJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhEQ1xcXCJcXFwiMlxceERDM1xceEREXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4REVcXFwiXFxcIjJcXHhERTNcXHhERlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEUwXFxcIlxcXCIyXFx4RTAzXFx4RTFcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhFMlxcXCJcXFwiMlxceEUyM1xceEUzXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RTRcXFwiXFxcIjJcXHhFNDNcXHhFNVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEU2XFxcIlxcXCIyXFx4RTYzXFx4RTdcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhFOFxcXCJcXFwiMlxceEU4M1xceEU5XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RUFcXFwiXFxcIjJcXHhFQTNcXHhFQlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg4NSpTIFxcXCI3XFx4ODYqTSBcXFwiN1xceDg4KkcgXFxcIjdcXHg4OSpBIFxcXCI3XFx4OEEqOyBcXFwiN1xceDhCKjUgXFxcIjdcXHg4QyovIFxcXCI3XFx4OEQqKSBcXFwiN1xceDhFKiMgXFxcIjc2KyYgNCE2XFx4RUMhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4ODQrSyQ3JytBJTdcXHg5MSs3JTcnKy0lN1xceDkzKyMlJyUlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDkyKycgNCE2XFx4RUQhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNyErNyQ3ISstJTchKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDcqKkEgXFxcIjcrKjsgXFxcIjctKjUgXFxcIjczKi8gXFxcIjc0KikgXFxcIjcnKiMgXFxcIjcoLEcmNyoqQSBcXFwiNysqOyBcXFwiNy0qNSBcXFwiNzMqLyBcXFwiNzQqKSBcXFwiNycqIyBcXFwiNyhcXFwiKyYgNCE2XFx4RUUhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QjUrXyQgXFxcXCE3QSstJDdcXHhCNSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHhCNSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3OStSJCEuOlxcXCJcXFwiMjozOystJDc5KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyclNFxcXCI2XFx4RUZcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3OipqIFxcXCIhN1xceDk3K18kIFxcXFwhN0ErLSQ3XFx4OTcrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3XFx4OTcrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKyYgNCE2XFx4RjAhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3TCojIFxcXCI3XFx4OTgrYyQgXFxcXCE3QistJDdcXHg5QSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHg5QSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrJyU0XFxcIjZcXHhGMVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5OSojIFxcXCIgWytBJDdAKzclN00rLSU3PysjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhNzYrXyQgXFxcXCE3ListJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITcuKy0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIjdIKycgNCE2XFx4RjIhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4OUIqKSBcXFwiN1xceDlDKiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhGM1xcXCJcXFwiMSEzXFx4RjQrPCQ3PCsyJTdcXHg5RSsoJTQjNlxceEY1IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEY2XFxcIlxcXCIxJzNcXHhGNys8JDc8KzIlN1xceDlEKyglNCM2XFx4RjgjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCsnIDQhNlxceEY5ISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHhGQVxcXCJcXFwiMlxceEZBM1xceEZCK3gkIS5KXFxcIlxcXCIySjNLK1MkNyEqIyBcXFwiIFsrQyU3ISojIFxcXCIgWyszJTchKiMgXFxcIiBbKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysnJTRcXFwiNlxceEZDXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrTiQhNzwrLSQ3XFx4QTArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrKSU0XFxcIjZcXHhGRFxcXCJcXFwiISAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3NiopIFxcXCI3VCojIFxcXCI3SFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhBMitfJCBcXFxcITdCKy0kN1xceEEzKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEEzKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhGRVxcXCJcXFwiMSYzXFx4RkYqRyBcXFwiL1xcdTAxMDBcXFwiXFxcIjEnM1xcdTAxMDEqOyBcXFwiL1xcdTAxMDJcXFwiXFxcIjEkM1xcdTAxMDMqLyBcXFwiL1xcdTAxMDRcXFwiXFxcIjElM1xcdTAxMDUqIyBcXFwiNzYrJiA0ITZcXHUwMTA2ISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QTQqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMDdcXFwiXFxcIjEoM1xcdTAxMDgrTyQ3PCtFJS9cXHUwMTA5XFxcIlxcXCIxKDNcXHUwMTBBKi8gXFxcIi9cXHUwMTBCXFxcIlxcXCIxKDNcXHUwMTBDKiMgXFxcIjc2KyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3NitfJCBcXFxcITdBKy0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCsnIDQhNlxcdTAxMEQhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEE4KyYgNCE2XFx1MDEwRSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhBOStzJDc7K2klN1xceEFFK18lIFxcXFwhN0IrLSQ3XFx4QUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4QUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEFBKiMgXFxcIjdcXHhBQlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiL1xcdTAxMEZcXFwiXFxcIjEkM1xcdTAxMTAqUyBcXFwiL1xcdTAxMTFcXFwiXFxcIjElM1xcdTAxMTIqRyBcXFwiL1xcdTAxMTNcXFwiXFxcIjElM1xcdTAxMTQqOyBcXFwiL1xcdTAxMTVcXFwiXFxcIjElM1xcdTAxMTYqLyBcXFwiL1xcdTAxMTdcXFwiXFxcIjErM1xcdTAxMTgqIyBcXFwiN1xceEFDXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIvXFx1MDExOVxcXCJcXFwiMSczXFx1MDExQSovIFxcXCIvXFx1MDExQlxcXCJcXFwiMSkzXFx1MDExQyojIFxcXCI3XFx4QUNcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjc2KiMgXFxcIjdcXHhBRFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTFEXFxcIlxcXCIxXFxcIjNcXHUwMTFFKy0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhBQyojIFxcXCI3NlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2KzckNzwrLSU3XFx4QjArIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNzYqIyBcXFwiN0hcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QjIrNyQ3ListJTdcXHg4RisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrJyA0ITZcXHUwMTFGISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5RCsnIDQhNlxcdTAxMjAhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEI1K2QkIFxcXFwhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyglNFxcXCI2XFx1MDEyMVxcXCIhISUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhNzcrayQgXFxcXCEuSlxcXCJcXFwiMkozSystJDc3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLD4mIS5KXFxcIlxcXCIySjNLKy0kNzcrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3TCojIFxcXCI3XFx4OTgrYyQgXFxcXCE3QistJDdcXHhCNysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhCNysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrJyU0XFxcIjZcXHUwMTIyXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QjgqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMjNcXFwiXFxcIjEjM1xcdTAxMjQrPCQ3PCsyJTc2KyglNCM2XFx1MDEyNSMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKycgNCE2XFx1MDEyNiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OUQrJyA0ITZcXHUwMTI3ISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcN1xceDk5LCMmN1xceDk5XFxcIitcXHg4MSQ3QCt3JTdNK20lNz8rYyUgXFxcXCE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrJyU0JTZcXHUwMTI4JSAlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QkRcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEyOVxcXCJcXFwiMSYzXFx1MDEyQStzJDcuK2klN1xceEMwK18lIFxcXFwhN0ErLSQ3XFx4QzArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3XFx4QzArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCojIFxcXCI3XFx4QkVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3NitzJDcuK2klN1xceEJGK18lIFxcXFwhN0ErLSQ3XFx4QkYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3XFx4QkYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2Kz0kNzwrMyU3NiojIFxcXCI3SCsjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QzEqRyBcXFwiN1xceEMzKkEgXFxcIjdcXHhDNSo7IFxcXCI3XFx4QzcqNSBcXFwiN1xceEM4Ki8gXFxcIjdcXHhDOSopIFxcXCI3XFx4Q0EqIyBcXFwiN1xceEJGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMkJcXFwiXFxcIjElM1xcdTAxMkMrNyQ3PCstJTdcXHhDMisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN0krJyA0ITZcXHUwMTJEISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTJFXFxcIlxcXCIxJjNcXHUwMTJGK1xceEE1JDc8K1xceDlCJTdEK1xceDkxJTdcXHhDNCtcXHg4NyUgXFxcXCEgXFxcXDcnKyYkLCMmNydcXFwiXFxcIlxcXCIgWCstJDdcXHhDNCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCxHJiEgXFxcXDcnKyYkLCMmNydcXFwiXFxcIlxcXCIgWCstJDdcXHhDNCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrLSU3RSsjJScmJSQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3dCojIFxcXCI3d1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTMwXFxcIlxcXCIxJTNcXHUwMTMxKzckNzwrLSU3XFx4QzYrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdJKycgNCE2XFx1MDEzMiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEzM1xcXCJcXFwiMSYzXFx1MDEzNCs8JDc8KzIlN0krKCU0IzZcXHUwMTM1IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMzZcXFwiXFxcIjElM1xcdTAxMzcrXyQ3PCtVJSEvXFx1MDEzOFxcXCJcXFwiMSQzXFx1MDEzOSsmIDQhNlxcdTAxM0EhICUqNCBcXFwiIS9cXHUwMTNCXFxcIlxcXCIxJTNcXHUwMTNDKyYgNCE2XFx1MDEzRCEgJSsjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxM0VcXFwiXFxcIjEpM1xcdTAxM0YrVCQ3PCtKJS9cXHUwMTQwXFxcIlxcXCIxIzNcXHUwMTQxKi8gXFxcIi9cXHUwMTQyXFxcIlxcXCIxKDNcXHUwMTQzKiMgXFxcIjc2KyglNCM2XFx1MDE0NCMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTQ1XFxcIlxcXCIxIzNcXHUwMTQ2K1xceDlFJDc8K1xceDk0JTdEK1xceDhBJSE3XFx4Q0IrayQgXFxcXCEuRFxcXCJcXFwiMkQzRSstJDdcXHhDQisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw+JiEuRFxcXCJcXFwiMkQzRSstJDdcXHhDQisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgrLSU3RSsjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTQ3XFxcIlxcXCIxKDNcXHUwMTQ4Ki8gXFxcIi9cXHUwMTQ5XFxcIlxcXCIxJDNcXHUwMTRBKiMgXFxcIjc2KycgNCE2XFx1MDE0QiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3NitfJCBcXFxcITdBKy0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4Q0UrSyQ3LitBJTdcXHhDRSs3JTcuKy0lN1xceDhGKyMlJyUlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrJyA0ITZcXHUwMTRDISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhEMCtjJCBcXFxcITdBKy0kN1xceEQwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceEQwKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxcdTAxNERcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTgrYyQgXFxcXCE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrJyU0XFxcIjZcXHUwMTRFXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN0wqVCBcXFwiN1xceDk4Kk4gXFxcIiE3QCojIFxcXCIgWys9JDd0KzMlNz8qIyBcXFwiIFsrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWCtjJCBcXFxcITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxcdTAxNEZcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RDMrYyQgXFxcXCE3QistJDdcXHhENCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhENCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrJyU0XFxcIjZcXHUwMTUwXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDk1KyYgNCE2XFx1MDE1MSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTUyXFxcIlxcXCIxKDNcXHUwMTUzKzwkNzwrMiU3NisoJTQjNlxcdTAxNTQjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFgqaiBcXFwiIS9cXHUwMTU1XFxcIlxcXCIxJjNcXHUwMTU2KzwkNzwrMiU3NisoJTQjNlxcdTAxNTcjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFgqOiBcXFwiIS9cXHUwMTU4XFxcIlxcXCIxKjNcXHUwMTU5KyYgNCE2XFx1MDE1QSEgJSojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhNzYrbyQgXFxcXCE3QSsyJDc2KyglNFxcXCI2XFx1MDE1QlxcXCIhICUkXFxcIiMgWFxcXCIjIFgsPSYhN0ErMiQ3NisoJTRcXFwiNlxcdTAxNUJcXFwiISAlJFxcXCIjIFhcXFwiIyBYXFxcIispJTRcXFwiNlxcdTAxNUNcXFwiXFxcIiEgJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysnIDQhNlxcdTAxNUQhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEQ3K18kIFxcXFwhN0ErLSQ3XFx4RDcrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3XFx4RDcrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDk4K18kIFxcXFwhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrJyA0ITZcXHUwMTVFISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhEQStfJCBcXFxcITdCKy0kN1xceERCKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceERCKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTVGXFxcIlxcXCIxJjNcXHUwMTYwKjsgXFxcIi9cXHUwMTYxXFxcIlxcXCIxJzNcXHUwMTYyKi8gXFxcIi9cXHUwMTYzXFxcIlxcXCIxKjNcXHUwMTY0KiMgXFxcIjc2KyYgNCE2XFx1MDE2NSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTY2XFxcIlxcXCIxJjNcXHUwMTY3KzwkNzwrMiU3XFx4REMrKCU0IzZcXHUwMTY4IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYKlxceDgzIFxcXCIhL1xceEY2XFxcIlxcXCIxJzNcXHhGNys8JDc8KzIlN1xceDlEKyglNCM2XFx1MDE2OSMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWCpTIFxcXCIhL1xcdTAxNkFcXFwiXFxcIjErM1xcdTAxNkIrPCQ3PCsyJTdcXHg5RCsoJTQjNlxcdTAxNkMjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFgqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIvXFx1MDE2RFxcXCJcXFwiMSszXFx1MDE2RSprIFxcXCIvXFx1MDE2RlxcXCJcXFwiMSkzXFx1MDE3MCpfIFxcXCIvXFx1MDE3MVxcXCJcXFwiMSgzXFx1MDE3MipTIFxcXCIvXFx1MDE3M1xcXCJcXFwiMSczXFx1MDE3NCpHIFxcXCIvXFx1MDE3NVxcXCJcXFwiMSYzXFx1MDE3Nio7IFxcXCIvXFx1MDE3N1xcXCJcXFwiMSozXFx1MDE3OCovIFxcXCIvXFx1MDE3OVxcXCJcXFwiMSkzXFx1MDE3QSojIFxcXCI3NlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNzEqIyBcXFwiIFtcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhNzYrbyQgXFxcXCE3QSsyJDc2KyglNFxcXCI2XFx1MDE1QlxcXCIhICUkXFxcIiMgWFxcXCIjIFgsPSYhN0ErMiQ3NisoJTRcXFwiNlxcdTAxNUJcXFwiISAlJFxcXCIjIFhcXFwiIyBYXFxcIispJTRcXFwiNlxcdTAxNUNcXFwiXFxcIiEgJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysnIDQhNlxcdTAxN0IhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN0wqIyBcXFwiN1xceDk4K2MkIFxcXFwhN0IrLSQ3XFx4RTArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4RTArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx1MDE3Q1xcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEI4KiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhFMitfJCBcXFxcITdBKy0kN1xceEUyKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceEUyKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhFOStzJDcuK2klN1xceEVDK18lIFxcXFwhN0IrLSQ3XFx4RTMrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4RTMrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEU0KjsgXFxcIjdcXHhFNSo1IFxcXCI3XFx4RTYqLyBcXFwiN1xceEU3KikgXFxcIjdcXHhFOCojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE3RFxcXCJcXFwiMSMzXFx1MDE3RSs8JDc8KzIlN1xceEVGKyglNCM2XFx1MDE3RiMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTgwXFxcIlxcXCIxJTNcXHUwMTgxKzwkNzwrMiU3VCsoJTQjNlxcdTAxODIjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE4M1xcXCJcXFwiMSgzXFx1MDE4NCtCJDc8KzglN1xcXFwqIyBcXFwiN1krKCU0IzZcXHUwMTg1IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxODZcXFwiXFxcIjEmM1xcdTAxODcrPCQ3PCsyJTc2KyglNCM2XFx1MDE4OCMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTg5XFxcIlxcXCIxJTNcXHUwMThBK1QkITc8KzUkIFxcXFw3ISwjJjchXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysnJTRcXFwiNlxcdTAxOEJcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RUErSyQ3OytBJTc2KzclNzsrLSU3XFx4RUIrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4OTVcXFwiXFxcIjEjM1xceEQ2KiMgXFxcIjc2KycgNCE2XFx1MDE4QyEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4QjRcXFwiXFxcIjEjM1xcdTAxOEQqRyBcXFwiL1xceEI2XFxcIlxcXCIxIzNcXHUwMThFKjsgXFxcIi9cXHhCQVxcXCJcXFwiMSMzXFx1MDE4RiovIFxcXCIvXFx4QjhcXFwiXFxcIjEkM1xcdTAxOTAqIyBcXFwiNzYrJyA0ITZcXHUwMTkxISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhFRCtIJCE3QystJDdcXHhFRSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdVKikgXFxcIjdcXFxcKiMgXFxcIjdYKyYgNCE2XFx1MDE5MiEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3ISojIFxcXCIgWytjJDchKiMgXFxcIiBbK1MlNyEqIyBcXFwiIFsrQyU3ISojIFxcXCIgWyszJTchKiMgXFxcIiBbKyMlJyUlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKycgNCE2XFx1MDE5MyEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhNyErQyQ3ISojIFxcXCIgWyszJTchKiMgXFxcIiBbKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFgrJyA0ITZcXHUwMTk0ISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEJEXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDlEK2QkIFxcXFwhN0IrLSQ3XFx4RjIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4RjIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyglNFxcXCI2XFx1MDE5NVxcXCIhISUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhGMyojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx1MDE5NlxcXCJcXFwiMlxcdTAxOTYzXFx1MDE5NytOJDc8K0QlLlxcdTAxOThcXFwiXFxcIjJcXHUwMTk4M1xcdTAxOTkqKSBcXFwiLlxcdTAxOUFcXFwiXFxcIjJcXHUwMTlBM1xcdTAxOUIrKCU0IzZcXHUwMTlDIyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDlEK2QkIFxcXFwhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyglNFxcXCI2XFx1MDE5RFxcXCIhISUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3Nis3JDcwKy0lN1xceEY2KyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcNzIqKSBcXFwiNzQqIyBcXFwiNy4sLyY3MiopIFxcXCI3NCojIFxcXCI3LlxcXCJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcNyUsIyY3JVxcXCJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RjkrPSQuOFxcXCJcXFwiMjgzOSstJTdcXHhGQSsjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxOUVcXFwiXFxcIjElM1xcdTAxOUYqKSBcXFwiL1xcdTAxQTBcXFwiXFxcIjEkM1xcdTAxQTErJyA0ITZcXHUwMUEyISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhGQitOJCEuOFxcXCJcXFwiMjgzOSstJDdeKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xcXFwqKSBcXFwiN1gqIyBcXFwiN1xceDgyKycgNCE2XFx1MDFBMyEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDdcXHhGRCopIFxcXCI3LSojIFxcXCI3XFx4RkUsLyY3XFx4RkQqKSBcXFwiNy0qIyBcXFwiN1xceEZFXFxcIishICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFxcIipTIFxcXCI3ISpNIFxcXCIuRlxcXCJcXFwiMkYzRypBIFxcXCIuSlxcXCJcXFwiMkozSyo1IFxcXCIuSFxcXCJcXFwiMkgzSSopIFxcXCIuTlxcXCJcXFwiMk4zT1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLkxcXFwiXFxcIjJMM00qXFx4OTUgXFxcIi5CXFxcIlxcXCIyQjNDKlxceDg5IFxcXCIuPFxcXCJcXFwiMjwzPSp9IFxcXCIuUlxcXCJcXFwiMlIzUypxIFxcXCIuVFxcXCJcXFwiMlQzVSplIFxcXCIuVlxcXCJcXFwiMlYzVypZIFxcXCIuUFxcXCJcXFwiMlAzUSpNIFxcXCIuQFxcXCJcXFwiMkAzQSpBIFxcXCIuRFxcXCJcXFwiMkQzRSo1IFxcXCIuMlxcXCJcXFwiMjIzMyopIFxcXCIuPlxcXCJcXFwiMj4zP1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHUwMTAwK2gkLjhcXFwiXFxcIjI4MzkrWCU3XFx4RkErTiUhLlxcdTAxQTRcXFwiXFxcIjJcXHUwMUE0M1xcdTAxQTUrLSQ3XFx4RUIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxQTZcXFwiXFxcIjElM1xcdTAxQTcqKSBcXFwiL1xcdTAxQThcXFwiXFxcIjEkM1xcdTAxQTkrJyA0ITZcXHUwMUEyISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhFQitRJC9cXHhCNFxcXCJcXFwiMSMzXFx4QjUqNyBcXFwiL1xceEI2XFxcIlxcXCIxIzNcXHhCNyorIFxcXCIgXFxcXDcrLCMmNytcXFwiKyclNFxcXCI2XFx1MDFBQVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHUwMTA0K1xceDhGJC5GXFxcIlxcXCIyRjNHK38lN1xcdTAxMDMrdSUuRlxcXCJcXFwiMkYzRytlJTdcXHUwMTAzK1slLkZcXFwiXFxcIjJGM0crSyU3XFx1MDEwMytBJS5GXFxcIlxcXCIyRjNHKzElN1xcdTAxMDUrJyU0KTZcXHUwMUFCKSAlJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3IytBJDcjKzclNyMrLSU3IysjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx1MDEwMystJDdcXHUwMTAzKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xcdTAxMDMrNyQ3XFx1MDEwMystJTdcXHUwMTAzKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIilcbiAgICAgICAgXSxcblxuICAgICAgICBwZWckY3VyclBvcyAgICAgICAgICA9IDAsXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyAgICAgID0gMCxcbiAgICAgICAgcGVnJGNhY2hlZFBvcyAgICAgICAgPSAwLFxuICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH0sXG4gICAgICAgIHBlZyRtYXhGYWlsUG9zICAgICAgID0gMCxcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCAgPSBbXSxcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxuXG4gICAgICAgIHBlZyRyZXN1bHQ7XG5cbiAgICBpZiAoXCJzdGFydFJ1bGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlSW5kaWNlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgXFxcIlwiICsgb3B0aW9ucy5zdGFydFJ1bGUgKyBcIlxcXCIuXCIpO1xuICAgICAgfVxuXG4gICAgICBwZWckc3RhcnRSdWxlSW5kZXggPSBwZWckc3RhcnRSdWxlSW5kaWNlc1tvcHRpb25zLnN0YXJ0UnVsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcocGVnJHJlcG9ydGVkUG9zLCBwZWckY3VyclBvcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHBlZyRyZXBvcnRlZFBvcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lKCkge1xuICAgICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmxpbmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sdW1uKCkge1xuICAgICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmNvbHVtbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbikge1xuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKFxuICAgICAgICBudWxsLFxuICAgICAgICBbeyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9XSxcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBudWxsLCBwZWckcmVwb3J0ZWRQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICAgIGZ1bmN0aW9uIGFkdmFuY2UoZGV0YWlscywgc3RhcnRQb3MsIGVuZFBvcykge1xuICAgICAgICB2YXIgcCwgY2g7XG5cbiAgICAgICAgZm9yIChwID0gc3RhcnRQb3M7IHAgPCBlbmRQb3M7IHArKykge1xuICAgICAgICAgIGNoID0gaW5wdXQuY2hhckF0KHApO1xuICAgICAgICAgIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgaWYgKCFkZXRhaWxzLnNlZW5DUikgeyBkZXRhaWxzLmxpbmUrKzsgfVxuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcclwiIHx8IGNoID09PSBcIlxcdTIwMjhcIiB8fCBjaCA9PT0gXCJcXHUyMDI5XCIpIHtcbiAgICAgICAgICAgIGRldGFpbHMubGluZSsrO1xuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbisrO1xuICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgIT09IHBvcykge1xuICAgICAgICBpZiAocGVnJGNhY2hlZFBvcyA+IHBvcykge1xuICAgICAgICAgIHBlZyRjYWNoZWRQb3MgPSAwO1xuICAgICAgICAgIHBlZyRjYWNoZWRQb3NEZXRhaWxzID0geyBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBhZHZhbmNlKHBlZyRjYWNoZWRQb3NEZXRhaWxzLCBwZWckY2FjaGVkUG9zLCBwb3MpO1xuICAgICAgICBwZWckY2FjaGVkUG9zID0gcG9zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGVnJGNhY2hlZFBvc0RldGFpbHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGZhaWwoZXhwZWN0ZWQpIHtcbiAgICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykge1xuICAgICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkID0gW107XG4gICAgICB9XG5cbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIGV4cGVjdGVkLCBwb3MpIHtcbiAgICAgIGZ1bmN0aW9uIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCkge1xuICAgICAgICB2YXIgaSA9IDE7XG5cbiAgICAgICAgZXhwZWN0ZWQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgaWYgKGEuZGVzY3JpcHRpb24gPCBiLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmIChhLmRlc2NyaXB0aW9uID4gYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZXhwZWN0ZWRbaSAtIDFdID09PSBleHBlY3RlZFtpXSkge1xuICAgICAgICAgICAgZXhwZWN0ZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpIHtcbiAgICAgICAgZnVuY3Rpb24gc3RyaW5nRXNjYXBlKHMpIHtcbiAgICAgICAgICBmdW5jdGlvbiBoZXgoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH1cblxuICAgICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAgICdcXFxcXFxcXCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgICAgJ1xcXFxcIicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywgICAnXFxcXHQnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAgICdcXFxcbicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxmL2csICAgJ1xcXFxmJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgICAnXFxcXHInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwN1xceDBCXFx4MEVcXHgwRl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg4MC1cXHhGRl0vZywgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MDE4MC1cXHUwRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTEwODAtXFx1RkZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1JyAgKyBoZXgoY2gpOyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBlY3RlZERlc2NzID0gbmV3IEFycmF5KGV4cGVjdGVkLmxlbmd0aCksXG4gICAgICAgICAgICBleHBlY3RlZERlc2MsIGZvdW5kRGVzYywgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBleHBlY3RlZERlc2NzW2ldID0gZXhwZWN0ZWRbaV0uZGVzY3JpcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3RlZERlc2MgPSBleHBlY3RlZC5sZW5ndGggPiAxXG4gICAgICAgICAgPyBleHBlY3RlZERlc2NzLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICAgKyBcIiBvciBcIlxuICAgICAgICAgICAgICArIGV4cGVjdGVkRGVzY3NbZXhwZWN0ZWQubGVuZ3RoIC0gMV1cbiAgICAgICAgICA6IGV4cGVjdGVkRGVzY3NbMF07XG5cbiAgICAgICAgZm91bmREZXNjID0gZm91bmQgPyBcIlxcXCJcIiArIHN0cmluZ0VzY2FwZShmb3VuZCkgKyBcIlxcXCJcIiA6IFwiZW5kIG9mIGlucHV0XCI7XG5cbiAgICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBleHBlY3RlZERlc2MgKyBcIiBidXQgXCIgKyBmb3VuZERlc2MgKyBcIiBmb3VuZC5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSxcbiAgICAgICAgICBmb3VuZCAgICAgID0gcG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KHBvcykgOiBudWxsO1xuXG4gICAgICBpZiAoZXhwZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgbWVzc2FnZSAhPT0gbnVsbCA/IG1lc3NhZ2UgOiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSxcbiAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgIGZvdW5kLFxuICAgICAgICBwb3MsXG4gICAgICAgIHBvc0RldGFpbHMubGluZSxcbiAgICAgICAgcG9zRGV0YWlscy5jb2x1bW5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGRlY29kZShzKSB7XG4gICAgICB2YXIgYmMgPSBuZXcgQXJyYXkocy5sZW5ndGgpLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBiY1tpXSA9IHMuY2hhckNvZGVBdChpKSAtIDMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlUnVsZShpbmRleCkge1xuICAgICAgdmFyIGJjICAgID0gcGVnJGJ5dGVjb2RlW2luZGV4XSxcbiAgICAgICAgICBpcCAgICA9IDAsXG4gICAgICAgICAgaXBzICAgPSBbXSxcbiAgICAgICAgICBlbmQgICA9IGJjLmxlbmd0aCxcbiAgICAgICAgICBlbmRzICA9IFtdLFxuICAgICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgICAgcGFyYW1zLCBpO1xuXG4gICAgICBmdW5jdGlvbiBwcm90ZWN0KG9iamVjdCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShvYmplY3QpID09PSBcIltvYmplY3QgQXJyYXldXCIgPyBbXSA6IG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgd2hpbGUgKGlwIDwgZW5kKSB7XG4gICAgICAgICAgc3dpdGNoIChiY1tpcF0pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChwcm90ZWN0KHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pKTtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBzdGFjay5sZW5ndGggLT0gYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgc3RhY2suc3BsaWNlKC0yLCAxKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHVzaChzdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goc3RhY2suc3BsaWNlKHN0YWNrLmxlbmd0aCAtIGJjW2lwICsgMV0sIGJjW2lwICsgMV0pKTtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goaW5wdXQuc3Vic3RyaW5nKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLCBwZWckY3VyclBvcykpO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl0pO1xuXG4gICAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgaXAgKz0gMztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl0pO1xuXG4gICAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgaXAgKz0gMztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl0pO1xuXG4gICAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgaXAgKz0gMztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgICBpcHMucHVzaChpcCk7XG5cbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDIgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXAgKz0gMiArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcblxuICAgICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdKTtcblxuICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCBwZWckY29uc3RzW2JjW2lwICsgMV1dLmxlbmd0aCkgPT09IHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM107XG4gICAgICAgICAgICAgICAgaXAgKz0gNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdKTtcblxuICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCBwZWckY29uc3RzW2JjW2lwICsgMV1dLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gcGVnJGNvbnN0c1tiY1tpcCArIDFdXSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM10pO1xuXG4gICAgICAgICAgICAgIGlmIChwZWckY29uc3RzW2JjW2lwICsgMV1dLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM107XG4gICAgICAgICAgICAgICAgaXAgKz0gNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIGJjW2lwICsgMV0pKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJGNvbnN0c1tiY1tpcCArIDFdXSk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IHBlZyRjb25zdHNbYmNbaXAgKyAxXV0ubGVuZ3RoO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChwZWckRkFJTEVEKTtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxIC0gYmNbaXAgKyAxXV07XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIHBhcmFtcyA9IGJjLnNsaWNlKGlwICsgNCwgaXAgKyA0ICsgYmNbaXAgKyAzXSk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBiY1tpcCArIDNdOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbaV0gPSBzdGFja1tzdGFjay5sZW5ndGggLSAxIC0gcGFyYW1zW2ldXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0YWNrLnNwbGljZShcbiAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggLSBiY1tpcCArIDJdLFxuICAgICAgICAgICAgICAgIGJjW2lwICsgMl0sXG4gICAgICAgICAgICAgICAgcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5hcHBseShudWxsLCBwYXJhbXMpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaXAgKz0gNCArIGJjW2lwICsgM107XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRwYXJzZVJ1bGUoYmNbaXAgKyAxXSkpO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3Bjb2RlOiBcIiArIGJjW2lwXSArIFwiLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZW5kID0gZW5kcy5wb3AoKTtcbiAgICAgICAgICBpcCA9IGlwcy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhY2tbMF07XG4gICAgfVxuXG5cbiAgICAgIG9wdGlvbnMuZGF0YSA9IHt9OyAvLyBPYmplY3QgdG8gd2hpY2ggaGVhZGVyIGF0dHJpYnV0ZXMgd2lsbCBiZSBhc3NpZ25lZCBkdXJpbmcgcGFyc2luZ1xuXG4gICAgICBmdW5jdGlvbiBsaXN0IChmaXJzdCwgcmVzdCkge1xuICAgICAgICByZXR1cm4gW2ZpcnN0XS5jb25jYXQocmVzdCk7XG4gICAgICB9XG5cblxuICAgIHBlZyRyZXN1bHQgPSBwZWckcGFyc2VSdWxlKHBlZyRzdGFydFJ1bGVJbmRleCk7XG5cbiAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcGVnJHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcGVnJGZhaWwoeyB0eXBlOiBcImVuZFwiLCBkZXNjcmlwdGlvbjogXCJlbmQgb2YgaW5wdXRcIiB9KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG51bGwsIHBlZyRtYXhGYWlsRXhwZWN0ZWQsIHBlZyRtYXhGYWlsUG9zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFN5bnRheEVycm9yOiBTeW50YXhFcnJvcixcbiAgICBwYXJzZTogICAgICAgcGFyc2VcbiAgfTtcbn0pKCk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0dyYW1tYXIvZGlzdC9HcmFtbWFyLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHRvcGxldmVsID0gZ2xvYmFsLndpbmRvdyB8fCBnbG9iYWw7XG5cbmZ1bmN0aW9uIGdldFByZWZpeGVkUHJvcGVydHkgKG9iamVjdCwgbmFtZSkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNhcGl0YWxpemVkTmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICB2YXIgcHJlZml4ZWROYW1lcyA9IFtuYW1lLCAnd2Via2l0JyArIGNhcGl0YWxpemVkTmFtZSwgJ21veicgKyBjYXBpdGFsaXplZE5hbWVdO1xuICBmb3IgKHZhciBpIGluIHByZWZpeGVkTmFtZXMpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBvYmplY3RbcHJlZml4ZWROYW1lc1tpXV07XG4gICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gcHJvcGVydHkuYmluZChvYmplY3QpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViU29ja2V0OiB0b3BsZXZlbC5XZWJTb2NrZXQsXG4gIFRyYW5zcG9ydDogcmVxdWlyZSgnLi9UcmFuc3BvcnQnKSxcbiAgb3BlbjogdG9wbGV2ZWwub3BlbixcbiAgUHJvbWlzZTogdG9wbGV2ZWwuUHJvbWlzZSxcbiAgdGltZXJzOiB0b3BsZXZlbCxcblxuICAvLyBDb25zb2xlIGlzIG5vdCBkZWZpbmVkIGluIEVDTUFTY3JpcHQsIHNvIGp1c3QgaW4gY2FzZS4uLlxuICBjb25zb2xlOiB0b3BsZXZlbC5jb25zb2xlIHx8IHtcbiAgICBkZWJ1ZzogZnVuY3Rpb24gKCkge30sXG4gICAgbG9nOiBmdW5jdGlvbiAoKSB7fSxcbiAgICB3YXJuOiBmdW5jdGlvbiAoKSB7fSxcbiAgICBlcnJvcjogZnVuY3Rpb24gKCkge31cbiAgfSxcblxuICBNZWRpYVN0cmVhbTogZ2V0UHJlZml4ZWRQcm9wZXJ0eSh0b3BsZXZlbCwgJ01lZGlhU3RyZWFtJyksXG4gIGdldFVzZXJNZWRpYTogZ2V0UHJlZml4ZWRQcm9wZXJ0eSh0b3BsZXZlbC5uYXZpZ2F0b3IsICdnZXRVc2VyTWVkaWEnKSxcbiAgUlRDUGVlckNvbm5lY3Rpb246IGdldFByZWZpeGVkUHJvcGVydHkodG9wbGV2ZWwsICdSVENQZWVyQ29ubmVjdGlvbicpLFxuICBSVENTZXNzaW9uRGVzY3JpcHRpb246IGdldFByZWZpeGVkUHJvcGVydHkodG9wbGV2ZWwsICdSVENTZXNzaW9uRGVzY3JpcHRpb24nKSxcblxuICBhZGRFdmVudExpc3RlbmVyOiBnZXRQcmVmaXhlZFByb3BlcnR5KHRvcGxldmVsLCAnYWRkRXZlbnRMaXN0ZW5lcicpLFxuICBIVE1MTWVkaWFFbGVtZW50OiB0b3BsZXZlbC5IVE1MTWVkaWFFbGVtZW50LFxuXG4gIGF0dGFjaE1lZGlhU3RyZWFtOiB0b3BsZXZlbC5hdHRhY2hNZWRpYVN0cmVhbSxcbiAgY3JlYXRlT2JqZWN0VVJMOiB0b3BsZXZlbC5VUkwgJiYgdG9wbGV2ZWwuVVJMLmNyZWF0ZU9iamVjdFVSTCxcbiAgcmV2b2tlT2JqZWN0VVJMOiB0b3BsZXZlbC5VUkwgJiYgdG9wbGV2ZWwuVVJMLnJldm9rZU9iamVjdFVSTFxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvZW52aXJvbm1lbnRfYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVHJhbnNwb3J0XG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgVHJhbnNwb3J0XG4gKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2ZXIgd3Nfc2VydmVyIE9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVAsIFdlYlNvY2tldCkge1xudmFyIFRyYW5zcG9ydCxcbiAgQyA9IHtcbiAgICAvLyBUcmFuc3BvcnQgc3RhdHVzIGNvZGVzXG4gICAgU1RBVFVTX1JFQURZOiAgICAgICAgMCxcbiAgICBTVEFUVVNfRElTQ09OTkVDVEVEOiAxLFxuICAgIFNUQVRVU19FUlJPUjogICAgICAgIDJcbiAgfTtcblxuLyoqXG4gKiBDb21wdXRlIGFuIGFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgdG8gd2FpdCBiZWZvcmUgc2VuZGluZyBhbm90aGVyXG4gKiBrZWVwLWFsaXZlLlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUtlZXBBbGl2ZVRpbWVvdXQodXBwZXJCb3VuZCkge1xuICB2YXIgbG93ZXJCb3VuZCA9IHVwcGVyQm91bmQgKiAwLjg7XG4gIHJldHVybiAxMDAwICogKE1hdGgucmFuZG9tKCkgKiAodXBwZXJCb3VuZCAtIGxvd2VyQm91bmQpICsgbG93ZXJCb3VuZCk7XG59XG5cblRyYW5zcG9ydCA9IGZ1bmN0aW9uKHVhLCBzZXJ2ZXIpIHtcblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnRyYW5zcG9ydCcpO1xuICB0aGlzLnVhID0gdWE7XG4gIHRoaXMud3MgPSBudWxsO1xuICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgdGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgPSAwO1xuICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IgPSB7fTtcblxuICB0aGlzLmtlZXBBbGl2ZUludGVydmFsID0gdWEuY29uZmlndXJhdGlvbi5rZWVwQWxpdmVJbnRlcnZhbDtcbiAgdGhpcy5rZWVwQWxpdmVUaW1lb3V0ID0gbnVsbDtcbiAgdGhpcy5rZWVwQWxpdmVUaW1lciA9IG51bGw7XG5cbiAgdGhpcy51YS50cmFuc3BvcnQgPSB0aGlzO1xuXG4gIC8vIENvbm5lY3RcbiAgdGhpcy5jb25uZWN0KCk7XG59O1xuXG5UcmFuc3BvcnQucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogU2VuZCBhIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7U0lQLk91dGdvaW5nUmVxdWVzdHxTdHJpbmd9IG1zZ1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHNlbmQ6IGZ1bmN0aW9uKG1zZykge1xuICAgIHZhciBtZXNzYWdlID0gbXNnLnRvU3RyaW5nKCk7XG5cbiAgICBpZih0aGlzLndzICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIGlmICh0aGlzLnVhLmNvbmZpZ3VyYXRpb24udHJhY2VTaXAgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdzZW5kaW5nIFdlYlNvY2tldCBtZXNzYWdlOlxcblxcbicgKyBtZXNzYWdlICsgJ1xcbicpO1xuICAgICAgfVxuICAgICAgdGhpcy53cy5zZW5kKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ3VuYWJsZSB0byBzZW5kIG1lc3NhZ2UsIFdlYlNvY2tldCBpcyBub3Qgb3BlbicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2VuZCBhIGtlZXAtYWxpdmUgKGEgZG91YmxlLUNSTEYgc2VxdWVuY2UpLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHNlbmRLZWVwQWxpdmU6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMua2VlcEFsaXZlVGltZW91dCkgeyByZXR1cm47IH1cblxuICAgIHRoaXMua2VlcEFsaXZlVGltZW91dCA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudWEuZW1pdCgna2VlcEFsaXZlVGltZW91dCcpO1xuICAgIH0uYmluZCh0aGlzKSwgMTAwMDApO1xuXG4gICAgcmV0dXJuIHRoaXMuc2VuZCgnXFxyXFxuXFxyXFxuJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0YXJ0IHNlbmRpbmcga2VlcC1hbGl2ZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydFNlbmRpbmdLZWVwQWxpdmVzOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5rZWVwQWxpdmVJbnRlcnZhbCAmJiAhdGhpcy5rZWVwQWxpdmVUaW1lcikge1xuICAgICAgdGhpcy5rZWVwQWxpdmVUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZW5kS2VlcEFsaXZlKCk7XG4gICAgICAgIHRoaXMua2VlcEFsaXZlVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXJ0U2VuZGluZ0tlZXBBbGl2ZXMoKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgY29tcHV0ZUtlZXBBbGl2ZVRpbWVvdXQodGhpcy5rZWVwQWxpdmVJbnRlcnZhbCkpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBzZW5kaW5nIGtlZXAtYWxpdmVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RvcFNlbmRpbmdLZWVwQWxpdmVzOiBmdW5jdGlvbigpIHtcbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLmtlZXBBbGl2ZVRpbWVyKTtcbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLmtlZXBBbGl2ZVRpbWVvdXQpO1xuICAgIHRoaXMua2VlcEFsaXZlVGltZXIgPSBudWxsO1xuICAgIHRoaXMua2VlcEFsaXZlVGltZW91dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICogRGlzY29ubmVjdCBzb2NrZXQuXG4gICovXG4gIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMud3MpIHtcbiAgICAgIC8vIENsZWFyIHJlY29ubmVjdFRpbWVyXG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVyKTtcblxuICAgICAgdGhpcy5zdG9wU2VuZGluZ0tlZXBBbGl2ZXMoKTtcblxuICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdjbG9zaW5nIFdlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpKTtcbiAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lcik7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMudWEuZW1pdCgnZGlzY29ubmVjdGVkJywge1xuICAgICAgICB0cmFuc3BvcnQ6IHRoaXMsXG4gICAgICAgIGNvZGU6IHRoaXMubGFzdFRyYW5zcG9ydEVycm9yLmNvZGUsXG4gICAgICAgIHJlYXNvbjogdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IucmVhc29uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQ29ubmVjdCBzb2NrZXQuXG4gICovXG4gIGNvbm5lY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzO1xuXG4gICAgaWYodGhpcy53cyAmJiAodGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTiB8fCB0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSArICcgaXMgYWxyZWFkeSBjb25uZWN0ZWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZih0aGlzLndzKSB7XG4gICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIubG9nKCdjb25uZWN0aW5nIHRvIFdlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpKTtcbiAgICB0aGlzLnVhLm9uVHJhbnNwb3J0Q29ubmVjdGluZyh0aGlzLFxuICAgICAgKHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzID09PSAwKT8xOnRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzKTtcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldCh0aGlzLnNlcnZlci53c191cmksICdzaXAnKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2Vycm9yIGNvbm5lY3RpbmcgdG8gV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkgKyAnOiAnICsgZSk7XG4gICAgfVxuXG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcblxuICAgIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICB0cmFuc3BvcnQub25PcGVuKCk7XG4gICAgfTtcblxuICAgIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRyYW5zcG9ydC5vbkNsb3NlKGUpO1xuICAgIH07XG5cbiAgICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRyYW5zcG9ydC5vbk1lc3NhZ2UoZSk7XG4gICAgfTtcblxuICAgIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRyYW5zcG9ydC5vbkVycm9yKGUpO1xuICAgIH07XG4gIH0sXG5cbiAgLy8gVHJhbnNwb3J0IEV2ZW50IEhhbmRsZXJzXG5cbiAgLyoqXG4gICogQGV2ZW50XG4gICogQHBhcmFtIHtldmVudH0gZVxuICAqL1xuICBvbk9wZW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcblxuICAgIHRoaXMubG9nZ2VyLmxvZygnV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkgKyAnIGNvbm5lY3RlZCcpO1xuICAgIC8vIENsZWFyIHJlY29ubmVjdFRpbWVyIHNpbmNlIHdlIGFyZSBub3QgZGlzY29ubmVjdGVkXG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZXIpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgfVxuICAgIC8vIFJlc2V0IHJlY29ubmVjdGlvbl9hdHRlbXB0c1xuICAgIHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzID0gMDtcbiAgICAvLyBEaXNhYmxlIGNsb3NlZFxuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgLy8gVHJpZ2dlciBvblRyYW5zcG9ydENvbm5lY3RlZCBjYWxsYmFja1xuICAgIHRoaXMudWEub25UcmFuc3BvcnRDb25uZWN0ZWQodGhpcyk7XG4gICAgLy8gU3RhcnQgc2VuZGluZyBrZWVwLWFsaXZlc1xuICAgIHRoaXMuc3RhcnRTZW5kaW5nS2VlcEFsaXZlcygpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBldmVudFxuICAqIEBwYXJhbSB7ZXZlbnR9IGVcbiAgKi9cbiAgb25DbG9zZTogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjb25uZWN0ZWRfYmVmb3JlID0gdGhpcy5jb25uZWN0ZWQ7XG5cbiAgICB0aGlzLmxhc3RUcmFuc3BvcnRFcnJvci5jb2RlID0gZS5jb2RlO1xuICAgIHRoaXMubGFzdFRyYW5zcG9ydEVycm9yLnJlYXNvbiA9IGUucmVhc29uO1xuXG4gICAgdGhpcy5zdG9wU2VuZGluZ0tlZXBBbGl2ZXMoKTtcblxuICAgIGlmICh0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyA+IDApIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnUmVjb25uZWN0aW9uIGF0dGVtcHQgJyArIHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzICsgJyBmYWlsZWQgKGNvZGU6ICcgKyBlLmNvZGUgKyAoZS5yZWFzb24/ICd8IHJlYXNvbjogJyArIGUucmVhc29uIDogJycpICsnKScpO1xuICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnV2ViU29ja2V0IGRpc2Nvbm5lY3RlZCAoY29kZTogJyArIGUuY29kZSArIChlLnJlYXNvbj8gJ3wgcmVhc29uOiAnICsgZS5yZWFzb24gOiAnJykgKycpJyk7XG5cbiAgICAgIGlmKGUud2FzQ2xlYW4gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1dlYlNvY2tldCBhYnJ1cHQgZGlzY29ubmVjdGlvbicpO1xuICAgICAgfVxuICAgICAgLy8gVHJhbnNwb3J0IHdhcyBjb25uZWN0ZWRcbiAgICAgIGlmKGNvbm5lY3RlZF9iZWZvcmUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy51YS5vblRyYW5zcG9ydENsb3NlZCh0aGlzKTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgdXNlciByZXF1ZXN0ZWQgdG8gY2xvc2UuXG4gICAgICAgIGlmKCF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51YS5lbWl0KCdkaXNjb25uZWN0ZWQnLCB7XG4gICAgICAgICAgICB0cmFuc3BvcnQ6IHRoaXMsXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmxhc3RUcmFuc3BvcnRFcnJvci5jb2RlLFxuICAgICAgICAgICAgcmVhc29uOiB0aGlzLmxhc3RUcmFuc3BvcnRFcnJvci5yZWFzb25cbiAgICAgICAgICB9KTtcblxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBjb25uZWN0aW9uIGF0dGVtcHRcbiAgICAgICAgLy9OZXR3b3JrIGVycm9yXG4gICAgICAgIHRoaXMudWEub25UcmFuc3BvcnRFcnJvcih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQGV2ZW50XG4gICogQHBhcmFtIHtldmVudH0gZVxuICAqL1xuICBvbk1lc3NhZ2U6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbWVzc2FnZSwgdHJhbnNhY3Rpb24sXG4gICAgICBkYXRhID0gZS5kYXRhO1xuXG4gICAgLy8gQ1JMRiBLZWVwIEFsaXZlIHJlc3BvbnNlIGZyb20gc2VydmVyLiBJZ25vcmUgaXQuXG4gICAgaWYoZGF0YSA9PT0gJ1xcclxcbicpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMua2VlcEFsaXZlVGltZW91dCk7XG4gICAgICB0aGlzLmtlZXBBbGl2ZVRpbWVvdXQgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy51YS5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygncmVjZWl2ZWQgV2ViU29ja2V0IG1lc3NhZ2Ugd2l0aCBDUkxGIEtlZXAgQWxpdmUgcmVzcG9uc2UnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdlYlNvY2tldCBiaW5hcnkgbWVzc2FnZS5cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgIH0gY2F0Y2goZXZ0KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ3JlY2VpdmVkIFdlYlNvY2tldCBiaW5hcnkgbWVzc2FnZSBmYWlsZWQgdG8gYmUgY29udmVydGVkIGludG8gc3RyaW5nLCBtZXNzYWdlIGRpc2NhcmRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnVhLmNvbmZpZ3VyYXRpb24udHJhY2VTaXAgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdyZWNlaXZlZCBXZWJTb2NrZXQgYmluYXJ5IG1lc3NhZ2U6XFxuXFxuJyArIGRhdGEgKyAnXFxuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2ViU29ja2V0IHRleHQgbWVzc2FnZS5cbiAgICBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnVhLmNvbmZpZ3VyYXRpb24udHJhY2VTaXAgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdyZWNlaXZlZCBXZWJTb2NrZXQgdGV4dCBtZXNzYWdlOlxcblxcbicgKyBkYXRhICsgJ1xcbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBTSVAuUGFyc2VyLnBhcnNlTWVzc2FnZShkYXRhLCB0aGlzLnVhKTtcblxuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKHRoaXMudWEuc3RhdHVzID09PSBTSVAuVUEuQy5TVEFUVVNfVVNFUl9DTE9TRUQgJiYgbWVzc2FnZSBpbnN0YW5jZW9mIFNJUC5JbmNvbWluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEbyBzb21lIHNhbml0eSBjaGVja1xuICAgIGlmKFNJUC5zYW5pdHlDaGVjayhtZXNzYWdlLCB0aGlzLnVhLCB0aGlzKSkge1xuICAgICAgaWYobWVzc2FnZSBpbnN0YW5jZW9mIFNJUC5JbmNvbWluZ1JlcXVlc3QpIHtcbiAgICAgICAgbWVzc2FnZS50cmFuc3BvcnQgPSB0aGlzO1xuICAgICAgICB0aGlzLnVhLnJlY2VpdmVSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXNwb25zZSkge1xuICAgICAgICAvKiBVbmlrZSBzdGF0ZWQgaW4gMTguMS4yLCBpZiBhIHJlc3BvbnNlIGRvZXMgbm90IG1hdGNoXG4gICAgICAgICogYW55IHRyYW5zYWN0aW9uLCBpdCBpcyBkaXNjYXJkZWQgaGVyZSBhbmQgbm8gcGFzc2VkIHRvIHRoZSBjb3JlXG4gICAgICAgICogaW4gb3JkZXIgdG8gYmUgZGlzY2FyZGVkIHRoZXJlLlxuICAgICAgICAqL1xuICAgICAgICBzd2l0Y2gobWVzc2FnZS5tZXRob2QpIHtcbiAgICAgICAgICBjYXNlIFNJUC5DLklOVklURTpcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdGhpcy51YS50cmFuc2FjdGlvbnMuaWN0W21lc3NhZ2UudmlhX2JyYW5jaF07XG4gICAgICAgICAgICBpZih0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5yZWNlaXZlUmVzcG9uc2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFNJUC5DLkFDSzpcbiAgICAgICAgICAgIC8vIEp1c3QgaW4gY2FzZSA7LSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRoaXMudWEudHJhbnNhY3Rpb25zLm5pY3RbbWVzc2FnZS52aWFfYnJhbmNoXTtcbiAgICAgICAgICAgIGlmKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJlY2VpdmVSZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBldmVudFxuICAqIEBwYXJhbSB7ZXZlbnR9IGVcbiAgKi9cbiAgb25FcnJvcjogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ1dlYlNvY2tldCBjb25uZWN0aW9uIGVycm9yOiAnICsgSlNPTi5zdHJpbmdpZnkoZSkpO1xuICB9LFxuXG4gIC8qKlxuICAqIFJlY29ubmVjdGlvbiBhdHRlbXB0IGxvZ2ljLlxuICAqIEBwcml2YXRlXG4gICovXG4gIHJlY29ubmVjdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYW5zcG9ydCA9IHRoaXM7XG5cbiAgICB0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyArPSAxO1xuXG4gICAgaWYodGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgPiB0aGlzLnVhLmNvbmZpZ3VyYXRpb24ud3NTZXJ2ZXJNYXhSZWNvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ21heGltdW0gcmVjb25uZWN0aW9uIGF0dGVtcHRzIGZvciBXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSk7XG4gICAgICB0aGlzLnVhLm9uVHJhbnNwb3J0RXJyb3IodGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyA9PT0gMSkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdDb25uZWN0aW9uIHRvIFdlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpICsgJyBzZXZlcmVkLCBhdHRlbXB0aW5nIGZpcnN0IHJlY29ubmVjdCcpO1xuICAgICAgdHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCd0cnlpbmcgdG8gcmVjb25uZWN0IHRvIFdlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpICsgJyAocmVjb25uZWN0aW9uIGF0dGVtcHQgJyArIHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzICsgJyknKTtcblxuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICAgICAgdHJhbnNwb3J0LnJlY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgICAgIH0sIHRoaXMudWEuY29uZmlndXJhdGlvbi53c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXQgKiAxMDAwKTtcbiAgICB9XG4gIH1cbn07XG5cblRyYW5zcG9ydC5DID0gQztcbnJldHVybiBUcmFuc3BvcnQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9UcmFuc3BvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=